diff --git a/project/ActiveDisplay/src/main/java/android/support/v4/content/WakefulBroadcastReceiver.java b/project/ActiveDisplay/src/main/java/android/support/v4/content/WakefulBroadcastReceiver.java
new file mode 100644
index 00000000..66cac887
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/android/support/v4/content/WakefulBroadcastReceiver.java
@@ -0,0 +1,134 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package android.support.v4.content;
+
+import android.content.BroadcastReceiver;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.os.PowerManager;
+import android.util.Log;
+import android.util.SparseArray;
+
+/**
+ * Helper for the common pattern of implementing a {@link android.content.BroadcastReceiver}
+ * that receives a device wakeup event and then passes the work off
+ * to a {@link android.app.Service}, while ensuring that the
+ * device does not go back to sleep during the transition.
+ *
+ * <p>This class takes care of creating and managing a partial wake lock
+ * for you; you must request the {@link android.Manifest.permission#WAKE_LOCK}
+ * permission to use it.</p>
+ *
+ * <h3>Example</h3>
+ *
+ * <p>A {@link android.support.v4.content.WakefulBroadcastReceiver} uses the method
+ * {@link android.support.v4.content.WakefulBroadcastReceiver#startWakefulService startWakefulService()}
+ * to start the service that does the work. This method is comparable to
+ * {@link android.content.Context#startService startService()}, except that
+ * the {@link android.support.v4.content.WakefulBroadcastReceiver} is holding a wake lock when the service
+ * starts. The intent that is passed with
+ * {@link android.support.v4.content.WakefulBroadcastReceiver#startWakefulService startWakefulService()}
+ * holds an extra identifying the wake lock.</p>
+ *
+ * {@sample development/samples/Support4Demos/src/com/example/android/supportv4/content/SimpleWakefulReceiver.java complete}
+ *
+ * <p>The service (in this example, an {@link android.app.IntentService}) does
+ * some work. When it is finished, it releases the wake lock by calling
+ * {@link android.support.v4.content.WakefulBroadcastReceiver#completeWakefulIntent
+ * completeWakefulIntent(intent)}. The intent it passes as a parameter
+ * is the same intent that the {@link android.support.v4.content.WakefulBroadcastReceiver} originally
+ * passed in.</p>
+ *
+ * {@sample development/samples/Support4Demos/src/com/example/android/supportv4/content/SimpleWakefulService.java complete}
+ */
+public abstract class WakefulBroadcastReceiver extends BroadcastReceiver {
+    private static final String EXTRA_WAKE_LOCK_ID = "android.support.content.wakelockid";
+
+    private static final SparseArray<PowerManager.WakeLock> mActiveWakeLocks
+            = new SparseArray<>();
+    private static int mNextId = 1;
+
+    /**
+     * Do a {@link android.content.Context#startService(android.content.Intent)
+     * Context.startService}, but holding a wake lock while the service starts.
+     * This will modify the Intent to hold an extra identifying the wake lock;
+     * when the service receives it in {@link android.app.Service#onStartCommand
+     * Service.onStartCommand}, it should pass back the Intent it receives there to
+     * {@link #completeWakefulIntent(android.content.Intent)} in order to release
+     * the wake lock.
+     *
+     * @param context The Context in which it operate.
+     * @param intent The Intent with which to start the service, as per
+     * {@link android.content.Context#startService(android.content.Intent)
+     * Context.startService}.
+     */
+    public static ComponentName startWakefulService(Context context, Intent intent) {
+        synchronized (mActiveWakeLocks) {
+            int id = mNextId;
+            mNextId++;
+            if (mNextId <= 0) {
+                mNextId = 1;
+            }
+
+            intent.putExtra(EXTRA_WAKE_LOCK_ID, id);
+            ComponentName comp = context.startService(intent);
+            if (comp == null) {
+                return null;
+            }
+
+            PowerManager pm = (PowerManager)context.getSystemService(Context.POWER_SERVICE);
+            PowerManager.WakeLock wl = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK,
+                    "wake:" + comp.flattenToShortString());
+            wl.setReferenceCounted(false);
+            wl.acquire(60*1000);
+            mActiveWakeLocks.put(id, wl);
+            return comp;
+        }
+    }
+
+    /**
+     * Finish the execution from a previous {@link #startWakefulService}.  Any wake lock
+     * that was being held will now be released.
+     *
+     * @param intent The Intent as originally generated by {@link #startWakefulService}.
+     * @return Returns true if the intent is associated with a wake lock that is
+     * now released; returns false if there was no wake lock specified for it.
+     */
+    public static boolean completeWakefulIntent(Intent intent) {
+        final int id = intent.getIntExtra(EXTRA_WAKE_LOCK_ID, 0);
+        if (id == 0) {
+            return false;
+        }
+        synchronized (mActiveWakeLocks) {
+            PowerManager.WakeLock wl = mActiveWakeLocks.get(id);
+            if (wl != null) {
+                wl.release();
+                mActiveWakeLocks.remove(id);
+                return true;
+            }
+            // We return true whether or not we actually found the wake lock
+            // the return code is defined to indicate whether the Intent contained
+            // an identifier for a wake lock that it was supposed to match.
+            // We just log a warning here if there is no wake lock found, which could
+            // happen for example if this function is called twice on the same
+            // intent or the process is killed and restarted before processing the intent.
+            Log.w("WakefulBroadcastReceiver", "No active wake lock id #" + id);
+            return true;
+        }
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/ActiveDisplayPresenter.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/ActiveDisplayPresenter.java
new file mode 100644
index 00000000..72b69e45
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/ActiveDisplayPresenter.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.os.PowerManager;
+import android.telephony.TelephonyManager;
+
+import com.achep.activedisplay.activities.ActiveDisplayActivity;
+import com.achep.activedisplay.services.LockscreenService;
+import com.achep.activedisplay.utils.LogUtils;
+import com.achep.activedisplay.utils.PowerUtils;
+
+import java.util.ArrayList;
+
+/**
+ * Created by Artem on 07.03.14.
+ */
+public class ActiveDisplayPresenter {
+
+    private static final String TAG = "ActiveDisplayPresenter";
+    private static final String WAKE_LOCK_TAG = "AcDisplay starter.";
+
+    public void stop(Context context) {
+        if (mActivity != null
+                && mActivity.hasWindowFocus()
+                && mActivity.getTimeout().getTimeout() != 0
+                && PowerUtils.isScreenOn(context)) {
+            mActivity.lock();
+        }
+    }
+
+    public void start(Context context) {
+        PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
+        TelephonyManager ts = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+        if (pm.isScreenOn() || ts.getCallState() != TelephonyManager.CALL_STATE_IDLE) {
+            return;
+        }
+
+        // Wake up from possible deep sleep.
+        //
+        //           )))
+        //          (((
+        //        +-----+
+        //        |     |]
+        //        `-----'    Good morning! ^-^
+        //      ___________
+        //      `---------'
+        pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, WAKE_LOCK_TAG).acquire(1000);
+
+        LockscreenService.ignoreCurrentTurningOn();
+        if (mActivity != null) mActivity.finish();
+        context.startActivity(new Intent(Intent.ACTION_MAIN, null)
+                .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
+                        | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS
+                        | Intent.FLAG_ACTIVITY_NO_USER_ACTION
+                        | Intent.FLAG_ACTIVITY_NO_ANIMATION
+                        | Intent.FLAG_FROM_BACKGROUND)
+                .putExtra(ActiveDisplayActivity.EXTRA_TURN_SCREEN_ON, true)
+                .setClass(context, ActiveDisplayActivity.class));
+
+        LogUtils.track();
+    }
+
+    public void kill() {
+        if (mActivity != null) mActivity.finish();
+    }
+
+    /**
+     * Listener to ActiveDisplayPresenter state.
+     */
+    public interface OnActiveDisplayStateChangedListener {
+        public void OnActiveDisplayStateChanged(Activity activity);
+    }
+
+    private static ActiveDisplayPresenter sActiveDisplayPresenter;
+
+    private ArrayList<OnActiveDisplayStateChangedListener> mListeners;
+    private ActiveDisplayActivity mActivity;
+
+    public static synchronized ActiveDisplayPresenter getInstance() {
+        if (sActiveDisplayPresenter == null)
+            sActiveDisplayPresenter = new ActiveDisplayPresenter();
+        return sActiveDisplayPresenter;
+    }
+
+    private ActiveDisplayPresenter() {
+        mListeners = new ArrayList<>(4);
+    }
+
+    public void addOnActiveDisplayStateChangedListener(OnActiveDisplayStateChangedListener listener) {
+        if (!mListeners.contains(listener)) mListeners.add(listener);
+    }
+
+    public void removeOnActiveDisplayStateChangedListener(OnActiveDisplayStateChangedListener listener) {
+        if (mListeners.contains(listener)) mListeners.remove(listener);
+    }
+
+    public void attachActivity(ActiveDisplayActivity activity) {
+        mActivity = activity;
+
+        for (OnActiveDisplayStateChangedListener listener : mListeners) {
+            listener.OnActiveDisplayStateChanged(mActivity);
+        }
+    }
+
+    public void detachActivity() {
+        attachActivity(null);
+    }
+
+    public boolean isActivityAttached() {
+        return mActivity != null;
+    }
+
+    public ActiveDisplayActivity getActivity() {
+        return mActivity;
+    }
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/App.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/App.java
new file mode 100644
index 00000000..2fccc543
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/App.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay;
+
+import android.app.Application;
+import android.content.Intent;
+
+import com.achep.activedisplay.services.LockscreenService;
+
+/**
+ * Created by Artem on 22.02.14.
+ */
+public class App extends Application {
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+
+        // If lockscreen is enabled launch it on start.
+        Config config = Config.getInstance(this);
+        if (config.isLockscreenEnabled()) {
+            Intent intent = new Intent(this, LockscreenService.class);
+            startService(intent);
+        }
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Config.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Config.java
index 582b3b97..12a7211a 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Config.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Config.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -20,7 +20,10 @@ package com.achep.activedisplay;
 
 import android.content.Context;
 import android.content.SharedPreferences;
+import android.util.Log;
 
+import com.achep.activedisplay.activemode.ActiveModeService;
+import com.achep.activedisplay.services.LockscreenService;
 import com.achep.activedisplay.utils.AccessUtils;
 
 import java.util.ArrayList;
@@ -37,11 +40,29 @@ public class Config {
     public static final String KEY_ONLY_WHILE_CHARGING = "b";
     public static final String KEY_LOW_PRIORITY_NOTIFICATIONS = "c";
 
+    // inactive time
+    public static final String KEY_INACTIVE_TIME_FROM = "inactive_time_from";
+    public static final String KEY_INACTIVE_TIME_TO = "inactive_time_to";
+    public static final String KEY_INACTIVE_TIME_ENABLED = "inactive_time_enabled";
+
     // timeouts
     public static final String KEY_TIMEOUT_NORMAL = "timeout_normal";
     public static final String KEY_TIMEOUT_SHORT = "timeout_short";
     public static final String KEY_TIMEOUT_INSTANT = "timeout_instant";
 
+    // lockscreen
+    public static final String KEY_LOCK_SCREEN = "lock_screen";
+
+    // active mode
+    public static final String KEY_ACTIVE_MODE = "active_mode";
+
+    // interface
+    public static final String KEY_INTERFACE_WALLPAPER_SHOWN = "wallpaper_shown";
+
+    // swipe actions
+    public static final String KEY_SWIPE_LEFT_ACTION = "swipe_left_action";
+    public static final String KEY_SWIPE_RIGHT_ACTION = "swipe_right_action";
+
     private static Config sConfigSoft;
 
     private boolean mActiveDisplayEnabled;
@@ -49,8 +70,15 @@ public class Config {
     private boolean mLowPriorityNotificationsAllowed;
     private int mTimeoutNormal;
     private int mTimeoutShort;
-    private int mTimeoutInstant;
+    private int mInactiveTimeFrom;
+    private int mInactiveTimeTo;
+    private int mSwipeLeftAction;
+    private int mSwipeRightAction;
+    private boolean mInactiveTimeEnabled;
+    private boolean mLockscreenEnabled;
+    private Boolean mActiveMode;
     private ArrayList<OnConfigChangedListener> mListeners;
+    private boolean mWallpaperShown;
 
     // //////////////////////////////////////////
     // /////////// -- LISTENERS -- //////////////
@@ -61,10 +89,12 @@ public class Config {
     }
 
     public void addOnConfigChangedListener(OnConfigChangedListener listener) {
+        if (Project.DEBUG) Log.d(TAG, "add_l=" + listener);
         mListeners.add(listener);
     }
 
     public void removeOnConfigChangedListener(OnConfigChangedListener listener) {
+        if (Project.DEBUG) Log.d(TAG, "remove_l=" + listener);
         mListeners.remove(listener);
     }
 
@@ -82,15 +112,19 @@ public class Config {
         mListeners = new ArrayList<>(6);
 
         SharedPreferences prefs = getSharedPreferences(context);
-        mActiveDisplayEnabled =
-                prefs.getBoolean(KEY_ENABLED, false);
-        mEnabledOnlyWhileCharging =
-                prefs.getBoolean(KEY_ONLY_WHILE_CHARGING, false);
-        mLowPriorityNotificationsAllowed =
-                prefs.getBoolean(KEY_LOW_PRIORITY_NOTIFICATIONS, false);
-        mTimeoutNormal = prefs.getInt(KEY_TIMEOUT_NORMAL, 15000);
+        mActiveDisplayEnabled = prefs.getBoolean(KEY_ENABLED, false);
+        mEnabledOnlyWhileCharging = prefs.getBoolean(KEY_ONLY_WHILE_CHARGING, false);
+        mLowPriorityNotificationsAllowed = prefs.getBoolean(KEY_LOW_PRIORITY_NOTIFICATIONS, false);
+        mLockscreenEnabled = prefs.getBoolean(KEY_LOCK_SCREEN, false);
+        mActiveMode = prefs.getBoolean(KEY_ACTIVE_MODE, false);
+        mWallpaperShown = prefs.getBoolean(KEY_INTERFACE_WALLPAPER_SHOWN, false);
+        mTimeoutNormal = prefs.getInt(KEY_TIMEOUT_NORMAL, 12000);
         mTimeoutShort = prefs.getInt(KEY_TIMEOUT_SHORT, 6000);
-        mTimeoutInstant = prefs.getInt(KEY_TIMEOUT_INSTANT, 3500);
+        mInactiveTimeFrom = prefs.getInt(KEY_INACTIVE_TIME_FROM, 0);
+        mInactiveTimeTo = prefs.getInt(KEY_INACTIVE_TIME_TO, 0);
+        mInactiveTimeEnabled = prefs.getBoolean(KEY_INACTIVE_TIME_ENABLED, false);
+        mSwipeLeftAction = prefs.getInt(KEY_SWIPE_LEFT_ACTION, 2);
+        mSwipeRightAction = prefs.getInt(KEY_SWIPE_RIGHT_ACTION, 2);
     }
 
     private SharedPreferences getSharedPreferences(Context context) {
@@ -98,26 +132,31 @@ public class Config {
     }
 
     private void notifyConfigChanged(String key, Object value, OnConfigChangedListener listener) {
+        if (Project.DEBUG) Log.d(TAG, "Notifying listeners: \"" + key + "\" = \"" + value + "\"");
         for (OnConfigChangedListener l : mListeners) {
             if (l == listener) continue;
             l.onConfigChanged(this, key, value);
         }
     }
 
-    private void putBooleanAndNotify(Context context, String key,
-                                     boolean enabled, OnConfigChangedListener listener) {
-        getSharedPreferences(context).edit().putBoolean(key, enabled).apply();
-        notifyConfigChanged(key, enabled, listener);
-    }
+    private void saveOption(Context context, String key, Object value,
+                            OnConfigChangedListener listener, boolean changed) {
+        if (!changed) return;
+
+        if (Project.DEBUG) Log.d(TAG, "Saving \"" + key + "\" to config as \"" + value + "\"");
+
+        SharedPreferences.Editor editor = getSharedPreferences(context).edit();
+        if (value instanceof Boolean) {
+            editor.putBoolean(key, (Boolean) value);
+        } else if (value instanceof Integer) {
+            editor.putInt(key, (Integer) value);
+        } else throw new IllegalArgumentException("Unknown option type.");
+        editor.apply();
 
-    private void putIntAndNotify(Context context, String key,
-                                     int value, OnConfigChangedListener listener) {
-        getSharedPreferences(context).edit().putInt(key, value).apply();
         notifyConfigChanged(key, value, listener);
     }
-
     // //////////////////////////////////////////
-    // ////////// -- PREFERENCES -- /////////////
+    // ///////////// -- OPTIONS -- //////////////
     // //////////////////////////////////////////
 
     public boolean setActiveDisplayEnabled(Context context, boolean enabled,
@@ -127,55 +166,83 @@ public class Config {
             return false;
         }
 
-        mActiveDisplayEnabled = enabled;
-        final String key = KEY_ENABLED;
+        boolean changed = mActiveDisplayEnabled != (mActiveDisplayEnabled = enabled);
+        saveOption(context, KEY_ENABLED, enabled, listener, changed);
 
-        getSharedPreferences(context).edit().putBoolean(key, enabled).apply();
-        notifyConfigChanged(key, enabled, listener);
+        if (changed) {
+            ActiveModeService.handleState(context);
+            LockscreenService.handleState(context);
+        }
         return true;
     }
 
-    public void setActiveDisplayEnabledOnlyWhenCharging(Context context, boolean enabled,
-                                                        OnConfigChangedListener listener) {
-        mEnabledOnlyWhileCharging = enabled;
-        putBooleanAndNotify(context, KEY_ONLY_WHILE_CHARGING, enabled, listener);
+    public void setActiveDisplayEnabledOnlyWhileCharging(Context context, boolean enabled,
+                                                         OnConfigChangedListener listener) {
+        saveOption(context, KEY_ONLY_WHILE_CHARGING, enabled, listener,
+                mEnabledOnlyWhileCharging != (mEnabledOnlyWhileCharging = enabled));
     }
 
     public void setLowPriorityNotificationsAllowed(Context context, boolean enabled,
                                                    OnConfigChangedListener listener) {
-        mLowPriorityNotificationsAllowed = enabled;
-        putBooleanAndNotify(context, KEY_LOW_PRIORITY_NOTIFICATIONS, enabled, listener);
+        saveOption(context, KEY_LOW_PRIORITY_NOTIFICATIONS, enabled, listener,
+                mLowPriorityNotificationsAllowed != (mLowPriorityNotificationsAllowed = enabled));
     }
 
-    public boolean isActiveDisplayEnabled() {
-        return mActiveDisplayEnabled;
+    public void setTimeoutNormal(Context context, int delayMillis, OnConfigChangedListener listener) {
+        saveOption(context, KEY_TIMEOUT_NORMAL, delayMillis, listener,
+                mTimeoutNormal != (mTimeoutNormal = delayMillis));
     }
 
-    public boolean isEnabledOnlyWhileCharging() {
-        return mEnabledOnlyWhileCharging;
+    public void setTimeoutShort(Context context, int delayMillis, OnConfigChangedListener listener) {
+        saveOption(context, KEY_TIMEOUT_SHORT, delayMillis, listener,
+                mTimeoutShort != (mTimeoutShort = delayMillis));
     }
 
-    public boolean isLowPriorityNotificationsAllowed() {
-        return mLowPriorityNotificationsAllowed;
+    public void setInactiveTimeEnabled(Context context, boolean enabled, OnConfigChangedListener listener) {
+        saveOption(context, KEY_INACTIVE_TIME_ENABLED, enabled, listener,
+                mInactiveTimeEnabled != (mInactiveTimeEnabled = enabled));
     }
 
-    // //////////////////////////////////////////
-    // //////////// -- TIMEOUT -- ///////////////
-    // //////////////////////////////////////////
+    public void setInactiveTimeFrom(Context context, int minutes, OnConfigChangedListener listener) {
+        saveOption(context, KEY_INACTIVE_TIME_FROM, minutes, listener,
+                mInactiveTimeFrom != (mInactiveTimeFrom = minutes));
+    }
 
-    public void setTimeoutNormal(Context context, int delayMillis, OnConfigChangedListener listener) {
-        mTimeoutNormal = delayMillis;
-        putIntAndNotify(context, KEY_TIMEOUT_NORMAL, delayMillis, listener);
+    public void setInactiveTimeTo(Context context, int minutes, OnConfigChangedListener listener) {
+        saveOption(context, KEY_INACTIVE_TIME_TO, minutes, listener,
+                mInactiveTimeTo != (mInactiveTimeTo = minutes));
     }
 
-    public void setTimeoutShort(Context context, int delayMillis, OnConfigChangedListener listener) {
-        mTimeoutShort = delayMillis;
-        putIntAndNotify(context, KEY_TIMEOUT_SHORT, delayMillis, listener);
+    public void setSwipeLeftAction(Context context, int action, OnConfigChangedListener listener) {
+        saveOption(context, KEY_SWIPE_LEFT_ACTION, action, listener,
+                mSwipeLeftAction != (mSwipeLeftAction = action));
     }
 
-    public void setTimeoutInstant(Context context, int delayMillis, OnConfigChangedListener listener) {
-        mTimeoutInstant = delayMillis;
-        putIntAndNotify(context, KEY_TIMEOUT_INSTANT, delayMillis, listener);
+    public void setSwipeRightAction(Context context, int action, OnConfigChangedListener listener) {
+        saveOption(context, KEY_SWIPE_RIGHT_ACTION, action, listener,
+                mSwipeRightAction != (mSwipeRightAction = action));
+    }
+
+    public void setLockscreenEnabled(Context context, boolean enabled, OnConfigChangedListener listener) {
+        boolean changed = mLockscreenEnabled != (mLockscreenEnabled = enabled);
+
+        saveOption(context, KEY_LOCK_SCREEN, enabled, listener, changed);
+
+        // Launch / stop lockscreen service
+        if (changed) LockscreenService.handleState(context);
+    }
+
+    public void setActiveModeEnabled(Context context, boolean enabled, OnConfigChangedListener listener) {
+        boolean changed = mActiveMode != (mActiveMode = enabled);
+        saveOption(context, KEY_ACTIVE_MODE, enabled, listener, changed);
+
+        // Launch / stop sensor monitor service
+        if (changed) ActiveModeService.handleState(context);
+    }
+
+    public void setWallpaperShown(Context context, boolean shown, OnConfigChangedListener listener) {
+        saveOption(context, KEY_INTERFACE_WALLPAPER_SHOWN, shown, listener,
+                mWallpaperShown != (mWallpaperShown = shown));
     }
 
     public int getTimeoutNormal() {
@@ -186,7 +253,48 @@ public class Config {
         return mTimeoutShort;
     }
 
-    public int getTimeoutInstant() {
-        return mTimeoutInstant;
+    public int getInactiveTimeFrom() {
+        return mInactiveTimeFrom;
+    }
+
+    public int getInactiveTimeTo() {
+        return mInactiveTimeTo;
+    }
+
+    public int getSwipeLeftAction() {
+        return mSwipeLeftAction;
+    }
+
+    public int getSwipeRightAction() {
+        return mSwipeRightAction;
     }
+
+    public boolean isActiveDisplayEnabled() {
+        return mActiveDisplayEnabled;
+    }
+
+    public boolean isEnabledOnlyWhileCharging() {
+        return mEnabledOnlyWhileCharging;
+    }
+
+    public boolean isLowPriorityNotificationsAllowed() {
+        return mLowPriorityNotificationsAllowed;
+    }
+
+    public boolean isLockscreenEnabled() {
+        return mLockscreenEnabled;
+    }
+
+    public boolean isActiveModeEnabled() {
+        return mActiveMode;
+    }
+
+    public boolean isWallpaperShown() {
+        return mWallpaperShown;
+    }
+
+    public boolean isInactiveTimeEnabled() {
+        return mInactiveTimeEnabled;
+    }
+
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/DebugLayerView.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/DebugLayerView.java
index 0750f09d..86474052 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/DebugLayerView.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/DebugLayerView.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Device.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Device.java
new file mode 100644
index 00000000..c8e8acf4
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Device.java
@@ -0,0 +1,36 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay;
+
+import android.os.Build;
+
+/**
+ * Created by Artem on 25.02.14.
+ */
+public class Device {
+
+    public static boolean hasKitKatApi() {
+        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
+    }
+
+    public static boolean hasJellyBeanMR2Api() {
+        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2;
+    }
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/DialogHelper.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/DialogHelper.java
index c5d9454e..96a7ac04 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/DialogHelper.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/DialogHelper.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -31,15 +31,17 @@ import android.app.FragmentTransaction;
 import android.content.Context;
 import android.content.res.Configuration;
 import android.graphics.drawable.Drawable;
+import android.text.TextUtils;
+import android.text.method.LinkMovementMethod;
 import android.view.LayoutInflater;
 import android.view.View;
-import android.widget.FrameLayout;
+import android.view.ViewGroup;
 import android.widget.TextView;
 
 import com.achep.activedisplay.fragments.AboutDialog;
 import com.achep.activedisplay.fragments.DonateDialog;
 import com.achep.activedisplay.fragments.FeedbackDialog;
-import com.achep.activedisplay.utils.ViewUtils;
+import com.achep.activedisplay.fragments.HelpDialog;
 
 /**
  * Helper class for showing fragment dialogs.
@@ -50,6 +52,10 @@ public class DialogHelper {
         showDialog(activity, AboutDialog.class, "dialog_about");
     }
 
+    public static void showHelpDialog(Activity activity) {
+        showDialog(activity, HelpDialog.class, "dialog_help");
+    }
+
     public static void showDonateDialog(Activity activity) {
         showDialog(activity, DonateDialog.class, "dialog_donate");
     }
@@ -79,10 +85,11 @@ public class DialogHelper {
      */
     public static class Builder {
 
-        private final Context mContext;
+        protected final Context mContext;
 
         private Drawable mIcon;
         private CharSequence mTitleText;
+        private CharSequence mMessageText;
         private View mView;
 
         public Builder(Context context) {
@@ -99,6 +106,23 @@ public class DialogHelper {
             return this;
         }
 
+        public Builder setMessage(CharSequence message) {
+            mMessageText = message;
+            return this;
+        }
+
+        public Builder setIcon(int iconRes) {
+            return iconRes == 0 ? null : setIcon(mContext.getResources().getDrawable(iconRes));
+        }
+
+        public Builder setTitle(int titleRes) {
+            return titleRes == 0 ? null : setTitle(mContext.getResources().getString(titleRes));
+        }
+
+        public Builder setMessage(int messageRes) {
+            return messageRes == 0 ? null : setMessage(mContext.getResources().getString(messageRes));
+        }
+
         public Builder setView(View view) {
             mView = view;
             return this;
@@ -108,29 +132,40 @@ public class DialogHelper {
          * Builds dialog's view
          */
         public View create() {
-            final LayoutInflater inflater = (LayoutInflater) mContext
+            LayoutInflater inflater = (LayoutInflater) mContext
                     .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-            final View root = inflater.inflate(R.layout.dialog_base, null);
-            assert root != null;
+
+            ViewGroup rootLayout = (ViewGroup) inflater.inflate(R.layout.dialog_base, null);
+            TextView titleView = (TextView) rootLayout.findViewById(R.id.title);
+            ViewGroup bodyLayout = (ViewGroup) rootLayout.findViewById(R.id.content);
+            TextView messageView = (TextView) rootLayout.findViewById(R.id.message);
 
             Drawable left = (mContext.getResources().getConfiguration().screenLayout &
                     Configuration.SCREENLAYOUT_SIZE_MASK) !=
                     Configuration.SCREENLAYOUT_SIZE_LARGE ? mIcon : null;
             Drawable top = left == null ? mIcon : null;
 
-            // Setting up title
-            TextView title = (TextView) root.findViewById(R.id.title);
-            ViewUtils.safelySetText(title, mTitleText);
-            title.setCompoundDrawablesWithIntrinsicBounds(left, top, null, null);
-
-            // Setting up content
-            FrameLayout content = (FrameLayout) root.findViewById(R.id.content);
-            content.addView(mView);
-
-            return root;
+            // Setup title
+            if (mTitleText != null) {
+                titleView.setText(mTitleText);
+                titleView.setCompoundDrawablesWithIntrinsicBounds(left, top, null, null);
+            } else {
+                rootLayout.removeView(titleView);
+            }
+
+            // Setup content
+            bodyLayout.removeView(messageView);
+            if (mView != null) bodyLayout.addView(mView);
+            if (!TextUtils.isEmpty(mMessageText)) {
+                messageView.setMovementMethod(new LinkMovementMethod());
+                messageView.setText(mMessageText);
+                bodyLayout.addView(messageView);
+            }
+
+            return rootLayout;
         }
 
-        public AlertDialog.Builder createAlertDialogBuilder() {
+        public AlertDialog.Builder wrap() {
             return new AlertDialog.Builder(mContext).setView(create());
         }
 
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/InactiveHoursHelper.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/InactiveHoursHelper.java
new file mode 100644
index 00000000..25dde2a1
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/InactiveHoursHelper.java
@@ -0,0 +1,38 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay;
+
+import android.text.format.Time;
+
+/**
+ * Created by Artem on 10.03.14.
+ */
+public class InactiveHoursHelper {
+
+    public static boolean isInactiveTime(Config config) {
+        Time time = new Time();
+        time.setToNow();
+
+        int now = time.hour * 60 + time.minute;
+        int from = config.getInactiveTimeFrom();
+        int to = config.getInactiveTimeTo();
+        return from < to ? now >= from && now <= to : now >= from || now <= to;
+    }
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Keys.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Keys.java
index 19243765..c2063811 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Keys.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Keys.java
@@ -1,3 +1,21 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
 package com.achep.activedisplay;
 
 /**
@@ -7,10 +25,12 @@ public class Keys {
 
     public static class Settings {
 
+        // TODO: Refactor it
         public static final String ONLY_WHILE_CHARGING = "only_while_charging";
         public static final String LOW_PRIORITY_NOTIFICATIONS = "low_priority_notifications";
         public static final String CONFIGURE_TIMEOUT = "configure_timeout";
         public static final String SHOW_DATE = "show_date";
+        public static final String INTERFACE_IS_WALLPAPER_SHOWN = "show_wallpaper";
 
     }
 
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/NotificationIds.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/NotificationIds.java
index c5c06b8d..dd4849a3 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/NotificationIds.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/NotificationIds.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -23,7 +23,9 @@ package com.achep.activedisplay;
  */
 public class NotificationIds {
 
+    public static final int LOCKSCREEN_NOTIFICATION = 1;
+    public static final int ACTIVE_MODE_NOTIFICATION = 2;
+
     public static final int INIT_NOTIFICATION = Integer.MAX_VALUE;
     public static final int TEST_NOTIFICATION = 11;
-    public static final int BREATHING_NOTIFICATION = 1;
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Operator.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Operator.java
index a7d299b5..046fed4c 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Operator.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Operator.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -26,5 +26,4 @@ public class Operator {
     public static boolean bitandCompare(int v, int target) {
         return (v & target) == target;
     }
-
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Project.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Project.java
index 151243a7..883c809e 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Project.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Project.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -28,9 +28,12 @@ public class Project {
     @SuppressWarnings("PointlessBooleanExpression")
     public static final boolean DEBUG = BuildConfig.MY_DEBUG && true;
 
-    public static final String EMAIL = "artemchep@gmail.com";
+    public static final String EMAIL = "support@artemchep.com";
+
+    public static final String SUFFIX = Project.class.getPackage().getName() + ":";
 
     public static String getPackageName(Context context) {
         return context.getApplicationInfo().packageName;
     }
+
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Timeout.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Timeout.java
index c1f9d65a..f19212a1 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Timeout.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/Timeout.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -22,6 +22,8 @@ import android.os.Handler;
 import android.os.Message;
 import android.os.SystemClock;
 
+import com.achep.activedisplay.utils.LogUtils;
+
 import java.util.ArrayList;
 
 /**
@@ -49,6 +51,7 @@ public class Timeout {
     };
 
     private long mTimeoutAt;
+    private boolean mLocked;
 
     public interface OnTimeoutEventListener {
         public void onTimeoutEvent(int event);
@@ -63,6 +66,7 @@ public class Timeout {
     }
 
     private void notifyOnEvent(int event) {
+        LogUtils.track();
         for (OnTimeoutEventListener l : mListeners) {
             l.onTimeoutEvent(event);
         }
@@ -72,6 +76,15 @@ public class Timeout {
         notifyOnEvent(EVENT_TIMEOUT);
     }
 
+    public void lock() {
+        mLocked = true;
+        clear();
+    }
+
+    public void release() {
+        mLocked = false;
+    }
+
     public void clear() {
         mTimeoutAt = 0;
         mHandler.removeMessages(0);
@@ -91,7 +104,7 @@ public class Timeout {
     }
 
     public void setTimeoutAt(long millis, boolean resetOld) {
-        if (mTimeoutAt > 0 && mTimeoutAt < millis && !resetOld) {
+        if (mTimeoutAt > 0 && mTimeoutAt < millis && !resetOld || mLocked) {
             return;
         }
 
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveModeService.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveModeService.java
new file mode 100644
index 00000000..0b45377d
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ActiveModeService.java
@@ -0,0 +1,319 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.activemode;
+
+import android.app.Activity;
+import android.app.Notification;
+import android.app.PendingIntent;
+import android.app.Service;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.hardware.SensorManager;
+import android.os.Handler;
+import android.os.IBinder;
+import android.os.PowerManager;
+import android.os.SystemClock;
+import android.util.Log;
+
+import com.achep.activedisplay.ActiveDisplayPresenter;
+import com.achep.activedisplay.Config;
+import com.achep.activedisplay.InactiveHoursHelper;
+import com.achep.activedisplay.NotificationIds;
+import com.achep.activedisplay.Project;
+import com.achep.activedisplay.R;
+import com.achep.activedisplay.settings.Settings;
+import com.achep.activedisplay.utils.PowerUtils;
+
+import java.util.Timer;
+import java.util.TimerTask;
+
+/**
+ * Created by Artem on 16.02.14.
+ */
+public class ActiveModeService extends Service implements Config.OnConfigChangedListener {
+
+    private static final String TAG = "ActiveModeService";
+
+    // TODO: Implement event based inactive time handling (using AlarmManager).
+    private static final int INACTIVE_HOURS_CHECK_PERIOD = 1000 * 60 * 5; // ms.
+
+    private Timer mTimer;
+    private ActiveModeSensor[] mSensors;
+
+    private boolean mListening;
+    private boolean mInactiveTime;
+
+    private Receiver mReceiver = new Receiver();
+
+    private class Receiver extends BroadcastReceiver {
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            ActiveDisplayPresenter presenter = ActiveDisplayPresenter.getInstance();
+            switch (intent.getAction()) {
+                case Intent.ACTION_SCREEN_ON:
+                    presenter.addOnActiveDisplayStateChangedListener(mStateListener);
+
+                    if (!presenter.isActivityAttached()) {
+                        stopListening();
+                    }
+                    break;
+                case Intent.ACTION_SCREEN_OFF:
+                    presenter.removeOnActiveDisplayStateChangedListener(mStateListener);
+                    startListeningDelayed(250);
+                    break;
+            }
+        }
+
+    }
+
+    private Handler mHandler = new Handler();
+    private Runnable mStartListeningRunnable = new Runnable() {
+        @Override
+        public void run() {
+            startListening();
+        }
+    };
+
+    private ActiveDisplayPresenter.OnActiveDisplayStateChangedListener mStateListener =
+            new ActiveDisplayPresenter.OnActiveDisplayStateChangedListener() {
+                @Override
+                public void OnActiveDisplayStateChanged(Activity activity) {
+                    if (activity == null) {
+                        stopListening();
+                    } else {
+                        startListening();
+                    }
+                }
+            };
+
+    /**
+     * Starts or stops this service as required by settings and device's state.
+     */
+    public static void handleState(Context context) {
+        Intent intent = new Intent(context, ActiveModeService.class);
+        Config config = Config.getInstance(context);
+        if (config.isActiveDisplayEnabled() && config.isActiveModeEnabled()) {
+            if (!config.isEnabledOnlyWhileCharging() || PowerUtils.isCharging(context)) {
+
+                context.startService(intent);
+            }
+        } else {
+            context.stopService(intent);
+        }
+    }
+
+    public static ActiveModeSensor[] buildSensorsList(Context context) {
+        SensorManager sensorManager = (SensorManager) context.getSystemService(SENSOR_SERVICE);
+        ActiveModeSensor[] sensors = new ActiveModeSensor[]{
+                new ShakeSensor(),
+                new ProximitySensor()
+        };
+
+        int count = sensors.length;
+        boolean[] supportList = new boolean[sensors.length];
+        for (int i = 0; i < sensors.length; i++) {
+            supportList[i] = sensors[i].isSupported(sensorManager, context);
+            if (!supportList[i]) {
+                count--;
+            }
+        }
+
+        ActiveModeSensor[] sensorsSupported = new ActiveModeSensor[count];
+        for (int i = 0, j = 0; i < sensors.length; i++) {
+            if (supportList[i]) {
+                sensorsSupported[j++] = sensors[i];
+            }
+        }
+        return sensorsSupported;
+    }
+
+    private void handleInactiveHoursChanged(boolean enabled) {
+        if (mTimer != null) mTimer.cancel();
+        if (enabled) {
+            mTimer = new Timer();
+            mTimer.schedule(new TimerTask() {
+
+                private static final String TAG = "InactiveTimeTicker";
+
+                @Override
+                public void run() {
+                    Config config = Config.getInstance(ActiveModeService.this);
+                    boolean inactive = InactiveHoursHelper.isInactiveTime(config);
+                    boolean changed = inactive != mInactiveTime;
+
+                    if (Project.DEBUG)
+                        Log.d(TAG, "On timer tick: elapsed_real_time="
+                                + SystemClock.elapsedRealtime());
+
+                    if (changed) {
+                        mInactiveTime = inactive;
+
+                        if (Project.DEBUG)
+                            Log.d(TAG, "is_inactive_time=" + inactive);
+
+                        if (inactive) {
+                            stopListening();
+                        } else {
+                            start();
+                        }
+                    }
+                }
+            }, 0, INACTIVE_HOURS_CHECK_PERIOD);
+        } else {
+            mInactiveTime = false;
+        }
+    }
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        mSensors = buildSensorsList(this);
+
+        IntentFilter intentFilter = new IntentFilter(Intent.ACTION_SCREEN_ON);
+        intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
+        intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY);
+        registerReceiver(mReceiver, intentFilter);
+
+        Config config = Config.getInstance(this);
+        handleInactiveHoursChanged(config.isInactiveTimeEnabled());
+        config.addOnConfigChangedListener(this);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        unregisterReceiver(mReceiver);
+        stopListening();
+
+        Config config = Config.getInstance(this);
+        config.removeOnConfigChangedListener(this);
+    }
+
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        start();
+
+        int notificationId = NotificationIds.ACTIVE_MODE_NOTIFICATION;
+        PendingIntent pendingIntent = PendingIntent.getActivity(this,
+                notificationId, new Intent(this, Settings.ActiveModeSettingsActivity.class),
+                PendingIntent.FLAG_UPDATE_CURRENT);
+        Notification notification = new Notification.Builder(this)
+                .setSmallIcon(R.drawable.ic_settings_active)
+                .setContentTitle(getString(
+                        R.string.service_active_mode,
+                        getString(R.string.app_name)))
+                .setContentText(getString(R.string.service_active_mode_text))
+                .setPriority(Notification.PRIORITY_MIN)
+                .setContentIntent(pendingIntent)
+                .setOngoing(true)
+                .build();
+
+        startForeground(notificationId, notification);
+        return Service.START_STICKY;
+    }
+
+    @Override
+    public void onConfigChanged(Config config, String key, Object value) {
+        boolean inactiveTimeEnabled = config.isInactiveTimeEnabled();
+        switch (key) {
+            case Config.KEY_INACTIVE_TIME_FROM:
+            case Config.KEY_INACTIVE_TIME_TO:
+                if (!inactiveTimeEnabled) {
+                    break;
+                }
+
+                // Immediately update sensors' blocker.
+                // ~ FALL DOWN ~
+            case Config.KEY_INACTIVE_TIME_ENABLED:
+                handleInactiveHoursChanged(inactiveTimeEnabled);
+                break;
+        }
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return null;
+    }
+
+    void start() {
+        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
+        ActiveDisplayPresenter presenter = ActiveDisplayPresenter.getInstance();
+        if (pm.isScreenOn()) {
+            mStateListener.OnActiveDisplayStateChanged(presenter.getActivity());
+        } else {
+            startListening();
+        }
+    }
+
+    /**
+     * Stops all monitoring sensors and removes delayed start event.
+     */
+    private void stopListening() {
+        mHandler.removeCallbacks(mStartListeningRunnable);
+
+        if (!mListening & !(mListening = false)) return;
+        if (Project.DEBUG) Log.d(TAG, "Stopping listening to sensors.");
+
+        SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
+        for (ActiveModeSensor sensor : mSensors) {
+            sensor.onDetach(sensorManager);
+        }
+    }
+
+    /**
+     * Starts all monitoring sensors after a delay.
+     *
+     * @param millis the delay before monitoring started.
+     */
+    private void startListeningDelayed(int millis) {
+        mHandler.postDelayed(mStartListeningRunnable, millis);
+    }
+
+    private void startListening() {
+        if (mListening & (mListening = true) | mInactiveTime) return;
+        if (Project.DEBUG) Log.d(TAG, "Starting listening to sensors.");
+
+        SensorManager sensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
+        for (ActiveModeSensor sensor : mSensors) {
+            sensor.onAttach(sensorManager, this);
+        }
+    }
+
+    public abstract static class ActiveModeSensor {
+
+        protected abstract boolean isSupported(SensorManager sensorManager, Context context);
+
+        protected abstract void onAttach(SensorManager sensorManager, Context context);
+
+        protected abstract void onDetach(SensorManager sensorManager);
+
+        protected void launchActiveDisplay(Context context) {
+            ActiveDisplayPresenter.getInstance().start(context);
+        }
+
+        protected void stopActiveDisplay(Context context) {
+            ActiveDisplayPresenter.getInstance().stop(context);
+        }
+
+    }
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ProximitySensor.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ProximitySensor.java
new file mode 100644
index 00000000..f4b29681
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ProximitySensor.java
@@ -0,0 +1,154 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.activemode;
+
+import android.content.Context;
+import android.hardware.Sensor;
+import android.hardware.SensorEvent;
+import android.hardware.SensorEventListener;
+import android.hardware.SensorManager;
+import android.os.Handler;
+import android.os.PowerManager;
+import android.os.SystemClock;
+import android.util.Log;
+
+import com.achep.activedisplay.Project;
+
+/**
+ * Created by Artem on 08.03.14.
+ */
+public class ProximitySensor extends ActiveModeService.ActiveModeSensor implements
+        SensorEventListener {
+
+    private static final String TAG = "ProximitySensor";
+
+    private static final long CHANGE_TO_FAR_MIN_DELAY = 2500; // ms.
+    private static final long CHANGE_TO_NEAR_MIN_DELAY = 0; // ms.
+    private static final long LOCK_DELAY = 1400; // ms.
+    private static final long LAUNCH_DELAY = 0; // ms.
+
+    private static boolean sProximityNear;
+    private static boolean sAttached;
+    private static long sLastEventTime;
+    private float mMaximumRange;
+
+    private Context mContext;
+
+    private Handler mHandler = new Handler();
+    private Runnable mLockRunnable = new Runnable() {
+        @Override
+        public void run() {
+            stopActiveDisplay(mContext);
+        }
+    };
+    private Runnable mLaunchRunnable = new Runnable() {
+        @Override
+        public void run() {
+            launchActiveDisplay(mContext);
+        }
+    };
+
+    /**
+     * True if sensor is in "near" position, and False otherwise
+     * (or if data is too old / sensor unsupported).
+     *
+     * @return True if sensor is in "near" position, and False otherwise
+     * (or if data is too old / sensor unsupported).
+     */
+    public static boolean isNear() {
+        return (getTimeNow() - sLastEventTime < 1000 || sAttached) && sProximityNear;
+    }
+
+    private static long getTimeNow() {
+        return SystemClock.elapsedRealtime();
+    }
+
+    @Override
+    protected boolean isSupported(SensorManager sensorManager, Context context) {
+        return sensorManager.getSensorList(Sensor.TYPE_PROXIMITY).size() > 0;
+    }
+
+    @Override
+    protected void onAttach(SensorManager sensorManager, Context context) {
+        Sensor proximitySensor = sensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY);
+        assert proximitySensor != null; // Otherwise excluded by Service.
+
+        sensorManager.registerListener(this, proximitySensor, SensorManager.SENSOR_DELAY_FASTEST);
+        mMaximumRange = proximitySensor.getMaximumRange();
+        mContext = context;
+
+        sAttached = true;
+        sProximityNear = false;
+        sLastEventTime = getTimeNow();
+
+        if (Project.DEBUG) Log.d(TAG, "maximum_range=" + mMaximumRange);
+    }
+
+    @Override
+    protected void onDetach(SensorManager sensorManager) {
+        sensorManager.unregisterListener(this);
+        mHandler.removeCallbacks(mLockRunnable);
+        mHandler.removeCallbacks(mLaunchRunnable);
+        mContext = null;
+
+        sAttached = false;
+        sLastEventTime = getTimeNow();
+    }
+
+    @Override
+    public void onSensorChanged(SensorEvent event) {
+        final float distance = event.values[0];
+        final boolean isNear = distance < mMaximumRange || distance < 1.0f;
+        final boolean changed = sProximityNear != (sProximityNear = isNear);
+
+        if (Project.DEBUG)
+            Log.d(TAG, "distance=" + distance + " is_near=" + isNear + " changed=" + changed);
+
+        if (!changed) {
+            // Well just in cause if proximity sensor NOT always sends
+            // binary results. This should not happen, but who knows...
+            // Maximum range is buggy enough :) :P
+            return;
+        }
+
+        mHandler.removeCallbacks(mLockRunnable);
+        mHandler.removeCallbacks(mLaunchRunnable);
+
+        long now = getTimeNow();
+        if (now > sLastEventTime + (isNear ? CHANGE_TO_NEAR_MIN_DELAY : CHANGE_TO_FAR_MIN_DELAY) && isNear == isScreenOn()) {
+            if (isNear) {
+                mHandler.postDelayed(mLockRunnable, LOCK_DELAY);
+            } else {
+                mHandler.postDelayed(mLaunchRunnable, LAUNCH_DELAY);
+            }
+        }
+
+        // TODO: Implement double swipe gesture.
+
+        sLastEventTime = now;
+    }
+
+    private boolean isScreenOn() {
+        PowerManager pm = (PowerManager) mContext.getSystemService(Context.POWER_SERVICE);
+        return pm.isScreenOn();
+    }
+
+    @Override
+    public void onAccuracyChanged(Sensor sensor, int accuracy) { /* unused */ }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ShakeSensor.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ShakeSensor.java
new file mode 100644
index 00000000..bd550792
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activemode/ShakeSensor.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.activemode;
+
+import android.content.Context;
+import android.hardware.Sensor;
+import android.hardware.SensorManager;
+
+/**
+ * Created by Artem on 08.03.14.
+ */
+public class ShakeSensor extends ActiveModeService.ActiveModeSensor {
+
+    @Override
+    protected boolean isSupported(SensorManager sensorManager, Context context) {
+        return sensorManager.getSensorList(Sensor.TYPE_ACCELEROMETER).size() > 0;
+    }
+
+    @Override
+    protected void onAttach(SensorManager sensorManager, Context context) {
+
+    }
+
+    @Override
+    protected void onDetach(SensorManager sensorManager) {
+
+    }
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/ActiveDisplayActivity.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/ActiveDisplayActivity.java
index abbee5e8..09a283c1 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/ActiveDisplayActivity.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/ActiveDisplayActivity.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -24,7 +24,6 @@ import android.animation.AnimatorListenerAdapter;
 import android.animation.AnimatorSet;
 import android.app.Activity;
 import android.app.FragmentManager;
-import android.app.admin.DevicePolicyManager;
 import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
@@ -34,7 +33,8 @@ import android.hardware.SensorEvent;
 import android.hardware.SensorEventListener;
 import android.hardware.SensorManager;
 import android.os.Bundle;
-import android.os.Handler;
+import android.service.notification.StatusBarNotification;
+import android.view.GestureDetector;
 import android.view.HapticFeedbackConstants;
 import android.view.MotionEvent;
 import android.view.VelocityTracker;
@@ -43,11 +43,11 @@ import android.view.ViewConfiguration;
 import android.view.WindowManager;
 import android.widget.ImageView;
 
+import com.achep.activedisplay.ActiveDisplayPresenter;
 import com.achep.activedisplay.Config;
 import com.achep.activedisplay.DebugLayerView;
 import com.achep.activedisplay.Project;
 import com.achep.activedisplay.R;
-import com.achep.activedisplay.Timeout;
 import com.achep.activedisplay.fragments.activedisplay.ActiveDisplayFragment;
 import com.achep.activedisplay.fragments.activedisplay.NotificationFragment;
 import com.achep.activedisplay.notifications.NotificationHelper;
@@ -61,12 +61,14 @@ import com.achep.activedisplay.widgets.WaveView;
 /**
  * Created by Artem on 25.01.14.
  */
-public class ActiveDisplayActivity extends Activity implements SensorEventListener,
-        ActiveDisplayFragment.OnEventListener,
-        Timeout.OnTimeoutEventListener {
+public class ActiveDisplayActivity extends KeyguardActivity implements
+        SensorEventListener,
+        ActiveDisplayFragment.OnEventListener {
 
     private static final String TAG = "ActiveDisplayActivity";
 
+    public static final String EXTRA_TURN_SCREEN_ON = "turn_screen_on";
+
     private WaveView mWaveView;
 
     private NotificationFragment mFragmentNotification;
@@ -75,6 +77,7 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
     private View mFragmentPreviewContainer;
     private ImageView mUnlockImageView;
     private ImageView mLockImageView;
+    private View mContent;
 
     private View[] mClickableViews;
 
@@ -85,22 +88,25 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
     private final NotificationListener mNotificationListener = new NotificationListener();
 
     private Config mConfig;
-    private Timeout mTimeout;
+    private NotificationPresenter mPresenter;
+
     private SensorManager mSensorManager;
-    private boolean mUnlocking;
-    private boolean mLocking;
-    private boolean mPaused;
 
     private volatile boolean mLockFeature;
 
     // swipe to dismiss notification
     private float[] mTouchHyperbola = new float[2];
     private float[] mTouchDownHyperbola = new float[2];
+    private float[] mTouchDownOffset = new float[2];
     private DebugLayerView mDebugLayerView;
     private VelocityTracker mVelocityTracker;
 
+    // fade out effect
+    private View mBackgroundView;
+
     private float mMaxFlingVelocity;
     private float mMinFlingVelocity;
+    private GestureDetector mGestureDetector;
 
     @Override
     public void onWindowFocusChanged(boolean hasFocus) {
@@ -109,14 +115,22 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
     }
 
     private void handleWindowFocusChanged(boolean hasFocus) {
+        int windowFlags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
         if (hasFocus) {
-            getWindow().getDecorView().setSystemUiVisibility(
-                    View.SYSTEM_UI_FLAG_LAYOUT_STABLE
-                            | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
-                            | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
-                            | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
-                            | View.SYSTEM_UI_FLAG_FULLSCREEN
-                            | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);
+            int visibility = View.SYSTEM_UI_FLAG_LAYOUT_STABLE
+                    | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
+                    | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
+                    | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
+                    | View.SYSTEM_UI_FLAG_FULLSCREEN
+                    | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;
+            getWindow().getDecorView().setSystemUiVisibility(visibility);
+            getWindow().addFlags(windowFlags);
+
+            getTimeout().release();
+            getTimeout().setTimeoutDelayed(mConfig.getTimeoutShort());
+        } else {
+            getWindow().clearFlags(windowFlags);
+            getTimeout().lock();
         }
     }
 
@@ -124,27 +138,39 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
+
+        Intent intent = getIntent();
+        int turnScreenOnFlag = 0;
+        if (intent != null) {
+            turnScreenOnFlag = WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON *
+                    MathUtils.bool(intent.getBooleanExtra(EXTRA_TURN_SCREEN_ON, false));
+        }
+
         getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED
-                | WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON
-                | WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON
-                | WindowManager.LayoutParams.FLAG_IGNORE_CHEEK_PRESSES);
+                | WindowManager.LayoutParams.FLAG_IGNORE_CHEEK_PRESSES
+                | turnScreenOnFlag);
 
-        setContentView(R.layout.activity_active_display);
+        mConfig = Config.getInstance(this);
+        mPresenter = NotificationPresenter.getInstance(this);
 
-        FragmentManager fm = getFragmentManager();
-        mFragmentNotification = (NotificationFragment)
-                fm.findFragmentById(R.id.notification_fragment);
+        if (mConfig.isWallpaperShown()) {
+            setTheme(R.style.ActiveDisplayTheme_Wallpaper);
+        }
+
+        setContentView(R.layout.activity_active_display);
 
+        mContent = findViewById(R.id.content);
+        mBackgroundView = findViewById(R.id.background);
         mDebugLayerView = (DebugLayerView) findViewById(R.id.debug);
         mWaveView = (WaveView) findViewById(R.id.wave);
-        mUnlockImageView = (ImageView) findViewById(R.id.unlock);
+        mUnlockImageView = (ImageView) mContent.findViewById(R.id.unlock);
         mUnlockImageView.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View view) {
-                unlock();
+                unlock(null);
             }
         });
-        mLockImageView = (ImageView) findViewById(R.id.lock);
+        mLockImageView = (ImageView) mContent.findViewById(R.id.lock);
         mLockImageView.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View view) {
@@ -161,13 +187,15 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
                 // I should not care about syncing with NotificationPresenter because
                 // getting current notification from NotificationFragment will return
                 // current VISIBLE to user notification.
-                // Or is should...
-                OpenStatusBarNotification notification = mFragmentNotification.getNotification();
+                // Or I should...
+                final OpenStatusBarNotification notification = mPresenter.getSelectedNotification();
                 if (notification != null) {
-                    boolean successful = NotificationHelper.startContentIntent(notification);
-                    if (successful) {
-                        unlock();
-                    }
+                    unlock(new Runnable() {
+                        @Override
+                        public void run() {
+                            NotificationHelper.startContentIntent(notification);
+                        }
+                    });
                 }
             }
         });
@@ -175,12 +203,15 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
         ViewConfiguration vc = ViewConfiguration.get(this);
         mMaxFlingVelocity = vc.getScaledMaximumFlingVelocity();
         mMinFlingVelocity = vc.getScaledMinimumFlingVelocity();
+        mGestureDetector = new GestureDetector(this, new GestureListener());
+
 
-        mTimeout = new Timeout();
-        mTimeout.addListener(this);
+        FragmentManager fm = getFragmentManager();
+        mFragmentNotification = (NotificationFragment)
+                fm.findFragmentById(R.id.notification_fragment);
         ActiveDisplayFragment activeDisplayFragment = (ActiveDisplayFragment)
                 fm.findFragmentById(R.id.active_display_fragment);
-        activeDisplayFragment.setTimeoutPresenter(mTimeout);
+        activeDisplayFragment.setTimeoutPresenter(getTimeout());
         activeDisplayFragment.setActiveDisplayActionsListener(this);
 
         mFragmentNotificationAnimation = (AnimatorSet) AnimatorInflater.loadAnimator(
@@ -190,42 +221,49 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
                 this, R.anim.card_flip_in_from_bottom);
         mFragmentPreviewAnimation.setTarget(mFragmentPreviewContainer);
 
-        mClickableViews = new View[]{mUnlockImageView, mLockImageView, mFragmentNotificationContainer};
+        mClickableViews = new View[]{
+                mUnlockImageView,
+                mLockImageView,
+                mFragmentNotificationContainer};
 
         // Register listeners
-        mConfig = Config.getInstance(this);
         mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
-        registerReceiver(mTurnScreenOffReceiver, new IntentFilter(Intent.ACTION_SCREEN_OFF));
-        NotificationPresenter np = NotificationPresenter.getInstance(this);
-        synchronized (np.monitor) {
-            np.addOnNotificationListChangedListener(mNotificationListener);
-        }
+
+        IntentFilter filter = new IntentFilter(Intent.ACTION_SCREEN_OFF);
+        registerReceiver(mTurnScreenOffReceiver, filter);
+
+        mPresenter.addOnNotificationListChangedListener(mNotificationListener);
+        handleSelectedNotificationChanged(mPresenter.getSelectedNotification());
+        handleNotificationCountChanged(mPresenter.getCount());
+
+        ActiveDisplayPresenter.getInstance().attachActivity(this);
+    }
+
+    private void handleSelectedNotificationChanged(OpenStatusBarNotification notification) {
+        boolean lockFeature = notification == null;
+        if (mLockFeature == lockFeature) return;
+        mLockFeature = lockFeature;
+    }
+
+    private void handleNotificationCountChanged(int count) {
+        ViewUtils.setVisible(mBackgroundView, count <= 1 && mConfig.isWallpaperShown());
     }
 
     @Override
     protected void onResume() {
         super.onResume();
-        mPaused = false;
-        mLocking = false;
-        mUnlocking = false;
-        if (mSensorManager != null)
-            mSensorManager.registerListener(this,
-                    mSensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY),
-                    SensorManager.SENSOR_DELAY_NORMAL);
-
-        setLockTimeout(mConfig.getTimeoutNormal(), true);
+        if (mSensorManager != null) mSensorManager.registerListener(this,
+                mSensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY),
+                SensorManager.SENSOR_DELAY_NORMAL);
+
+        getTimeout().setTimeoutDelayed(mConfig.getTimeoutNormal(), true);
         handleWindowFocusChanged(true);
     }
 
     @Override
     protected void onPause() {
         super.onPause();
-        mPaused = true;
-        clearLockTimeout();
-
-        if (mSensorManager != null) {
-            mSensorManager.unregisterListener(this);
-        }
+        if (mSensorManager != null) mSensorManager.unregisterListener(this);
     }
 
     @Override
@@ -233,52 +271,15 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
         super.onDestroy();
         unregisterReceiver(mTurnScreenOffReceiver);
         NotificationPresenter np = NotificationPresenter.getInstance(this);
-        synchronized (np.monitor) {
-            np.removeOnNotificationListChangedListener(mNotificationListener);
-        }
-    }
-
-    @Override
-    public void onTimeoutEvent(int event) {
-        switch (event) {
-            case Timeout.EVENT_TIMEOUT:
-                lock();
-                break;
-        }
-    }
+        np.removeOnNotificationListChangedListener(mNotificationListener);
 
-    private void lock() {
-        try {
-            DevicePolicyManager dpm = (DevicePolicyManager)
-                    getSystemService(Context.DEVICE_POLICY_SERVICE);
-            dpm.lockNow();
-
-            mLocking = true;
-        } catch (SecurityException e) {
-            mLocking = false;
-        }
-    }
-
-    private void unlock() {
-        getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
-
-        mUnlocking = true;
-        clearLockTimeout();
-        new Handler().postDelayed(new Runnable() {
-            @Override
-            public void run() {
-                finish();
-                overridePendingTransition(0, 0);
-            }
-        }, 100);
+        ActiveDisplayPresenter.getInstance().detachActivity();
     }
 
+    @SuppressWarnings("ConstantConditions")
     @Override
     public boolean onTouchHandleEvent(View view, MotionEvent event) {
         final View notification = mFragmentNotificationContainer;
-        toSwipeCoordinates(mTouchHyperbola,
-                event.getX() - view.getWidth() / 2,
-                event.getY() - view.getHeight() / 2);
 
         float rawX = event.getRawX();
         float rawY = event.getRawY();
@@ -293,13 +294,14 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
                 View decorView = getWindow().getDecorView();
                 mWaveView.init(
                         ViewUtils.getBottom(mLockFeature ?
-                                mLockImageView : mFragmentNotificationContainer, decorView),
+                                mLockImageView : notification, decorView),
                         ViewUtils.getTop(view, decorView) + view.getHeight() / 2,
                         ViewUtils.getTop(mUnlockImageView, decorView),
-                        view.getHeight() / 2);
+                        view.getHeight() / 2
+                );
                 mWaveView.animateExpand();
 
-                clearLockTimeout();
+                getTimeout().lock();
                 view.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
 
                 // ///////// -- SWIPE TO DISMISS -- /////////
@@ -307,6 +309,9 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
                 if (!mLockFeature) {
                     toSwipeCoordinates(mTouchDownHyperbola, 0, 0);
 
+                    mTouchDownOffset[0] = event.getX();
+                    mTouchDownOffset[1] = event.getY();
+
                     mVelocityTracker = VelocityTracker.obtain();
                     mVelocityTracker.addMovement(event);
                 }
@@ -317,10 +322,16 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
                 // ///////// -- SWIPE TO DISMISS -- /////////
 
                 if (!mLockFeature) {
+                    toSwipeCoordinates(mTouchHyperbola,
+                            event.getX() - mTouchDownOffset[0],
+                            event.getY() - mTouchDownOffset[1]);
+
                     float deltaX = mTouchHyperbola[0] - mTouchDownHyperbola[0];
+                    float alpha = Math.max(0f, Math.min(1f,
+                            1f - 2f * Math.abs(deltaX) / notification.getWidth()));
                     notification.setTranslationX(deltaX);
-                    notification.setAlpha(Math.max(0f, Math.min(1f,
-                            1f - 2f * Math.abs(deltaX) / notification.getWidth())));
+                    mBackgroundView.setAlpha(1 - alpha);
+                    mContent.setAlpha(alpha);
 
                     mVelocityTracker.addMovement(event);
                 }
@@ -338,13 +349,19 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
                         v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
                     }
                 }
+
                 break;
             case MotionEvent.ACTION_CANCEL:
             case MotionEvent.ACTION_UP:
+                getTimeout().release();
 
                 // ///////// -- SWIPE TO DISMISS -- /////////
 
                 if (!mLockFeature) {
+                    toSwipeCoordinates(mTouchHyperbola,
+                            event.getX() - mTouchDownOffset[0],
+                            event.getY() - mTouchDownOffset[1]);
+
                     mVelocityTracker.addMovement(event);
                     mVelocityTracker.computeCurrentVelocity(1000);
 
@@ -354,22 +371,29 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
                     float velocityX = mVelocityTracker.getXVelocity();
                     float absVelocityX = Math.abs(velocityX);
                     float absVelocityY = Math.abs(mVelocityTracker.getYVelocity());
-                    float deltaX = mTouchHyperbola[0] - mTouchDownHyperbola[0];
-                    if (Math.abs(deltaX) > notification.getWidth() / 3) {
+                    final float deltaX = mTouchHyperbola[0] - mTouchDownHyperbola[0];
+                    float absDeltaX = Math.abs(deltaX);
+                    if (absDeltaX > notification.getWidth() / 3) {
                         dismiss = true;
                         dismissRight = deltaX > 0;
                     } else if (mMinFlingVelocity <= absVelocityX
                             && absVelocityX <= mMaxFlingVelocity
-                            && absVelocityY < absVelocityX
-                            && absVelocityY < absVelocityX) {
+                            && absVelocityY * 2 < absVelocityX
+                            && absDeltaX > notification.getWidth() / 5) {
                         // dismiss only if flinging in the same direction as dragging
                         dismiss = (velocityX < 0) == (deltaX < 0);
                         dismissRight = mVelocityTracker.getXVelocity() > 0;
                     }
 
                     if (dismiss) {
-                        notification.animate()
-                                .alpha(0f)
+                        int duration = Math.round(absDeltaX * 1000f / Math.max(absVelocityX, 500f));
+                        final StatusBarNotification statusBarNotification = mPresenter
+                                .getSelectedNotification()
+                                .getStatusBarNotification();
+
+                        mBackgroundView.animate().alpha(1f).setDuration(duration);
+                        mContent.animate().alpha(0f).setDuration(duration);
+                        notification.animate().setDuration(duration)
                                 .translationX(notification.getTranslationX()
                                         + notification.getWidth()
                                         * MathUtils.charge(deltaX))
@@ -381,9 +405,16 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
 
                                     @Override
                                     public void onAnimationCancel(Animator animation) {
-                                        NotificationHelper.dismissNotification(mFragmentNotification
-                                                .getNotification()
-                                                .getStatusBarNotification());
+                                        final int count = mPresenter.getCount();
+
+                                        NotificationHelper.dismissNotification(statusBarNotification);
+                                        if (count <= 1) {
+                                            lock();
+
+                                            // Do not update user interface to default
+                                            // screen cause it'll make some visual lags.
+                                            if (isLocking()) return;
+                                        }
 
                                         // Reset view presentation
                                         notification.setAlpha(1f);
@@ -391,7 +422,7 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
 
                                         showMainFragment();
                                     }
-                                }).start();
+                                });
 
                         break;
                     }
@@ -407,7 +438,7 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
                         v.performClick();
                         v.refreshDrawableState();
                         v.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
-                        if (mUnlocking || mLocking) break main;
+                        if (isLocking() || isUnlocking()) break main;
                         break;
                     }
                 }
@@ -422,33 +453,30 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
 
     private void showMainFragment() {
         mWaveView.cancelExpand();
-
-        if (!mLockFeature)
-            mFragmentNotificationAnimation.cancel();
+        mFragmentNotificationAnimation.cancel();
         mFragmentPreviewAnimation.cancel();
         toggleVisibilities(true);
 
-        if (!mPaused) {
-            setLockTimeout(mConfig.getTimeoutShort());
-        }
+        getTimeout().setTimeoutDelayed(mConfig.getTimeoutShort());
     }
 
     private void toggleVisibilities(boolean showMain) {
         View main = mFragmentActiveDisplayContainer;
-        ViewUtils.setVisible(main, showMain, View.INVISIBLE);
-        main.animate().cancel();
-        if (showMain) {
+        if (showMain && main.getVisibility() != View.VISIBLE) {
             main.setAlpha(0);
-            main.animate().alpha(1).start();
+            main.animate().alpha(1).setDuration(180);
         }
 
+        mContent.setAlpha(1f);
+        mBackgroundView.setAlpha(0f);
+
+        ViewUtils.setVisible(main, showMain, View.INVISIBLE);
         ViewUtils.setVisible(mFragmentNotificationContainer, !mLockFeature && !showMain, View.INVISIBLE);
         ViewUtils.setVisible(mFragmentPreviewContainer, !mLockFeature && !showMain, View.INVISIBLE);
         ViewUtils.setVisible(mUnlockImageView, !showMain, View.INVISIBLE);
         ViewUtils.setVisible(mLockImageView, mLockFeature && !showMain, View.INVISIBLE);
     }
 
-
     private void toSwipeCoordinates(float[] out, float originX, float originY) {
         // x = (y0 - k1 * x0) / (k2 - k1)
         // y = k2 * x
@@ -471,20 +499,6 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
     // /////// -- ADDITIONAL SECURITY -- ////////
     // //////////////////////////////////////////
 
-    private void setLockTimeout(int delayMillis) {
-        setLockTimeout(delayMillis, false);
-    }
-
-    private void setLockTimeout(int delayMillis, boolean resetOld) {
-        if (!mUnlocking) {
-            mTimeout.setTimeoutDelayed(delayMillis, resetOld);
-        }
-    }
-
-    private void clearLockTimeout() {
-        mTimeout.clear();
-    }
-
     @Override
     public void onSensorChanged(SensorEvent event) {
         switch (event.sensor.getType()) {
@@ -501,7 +515,7 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
                 if (distance < 2 /* cm */) {
 
                     // Well, the device is probably somewhere in bag.
-                    setLockTimeout(mConfig.getTimeoutInstant());
+//                    getTimeout().setTimeoutDelayed(mConfig.getTimeoutInstant());
 
                     if (Project.DEBUG)
                         LogUtils.d(TAG, "Device is in pocket[proximity=" + distance
@@ -513,16 +527,18 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
 
     @Override
     public boolean onTouchEvent(MotionEvent event) {
-        if (event.getAction() == MotionEvent.ACTION_DOWN)
-            setLockTimeout(mConfig.getTimeoutShort());
+        mGestureDetector.onTouchEvent(event);
+        switch (event.getAction()) {
+            case MotionEvent.ACTION_DOWN:
+                getTimeout().setTimeoutDelayed(mConfig.getTimeoutShort());
+                break;
+        }
         return super.onTouchEvent(event);
     }
 
     @Override
     public void onAccuracyChanged(Sensor sensor, int i) { /* unused */ }
 
-    @Override
-    public void onBackPressed() { /* override back button */ }
 
     // //////////////////////////////////////////
     // ///////////// -- CLASSES -- //////////////
@@ -532,30 +548,46 @@ public class ActiveDisplayActivity extends Activity implements SensorEventListen
 
         @Override
         public void onReceive(final Context context, Intent intent) {
-
             // Finish the activity to avoid of displaying on turning screen on.
-            clearLockTimeout();
             finish();
         }
     }
 
-    private class NotificationListener extends NotificationPresenter.SimpleOnNotificationListChangedListener {
+    private class NotificationListener extends
+            NotificationPresenter.SimpleOnNotificationListChangedListener {
 
         @Override
-        // running on wrong thread
-        public void onNotificationEvent(NotificationPresenter nm,
-                                        OpenStatusBarNotification notification,
+        // running on wrong thread & already synced
+        public void onNotificationEvent(final NotificationPresenter nm,
+                                        final OpenStatusBarNotification notification,
                                         final int event) {
             super.onNotificationEvent(nm, notification, event);
             runOnUiThread(new Runnable() {
                 @Override
                 public void run() {
-                    setLockTimeout(mConfig.getTimeoutNormal(), true);
+                    switch (event) {
+                        case SELECTED:
+                            handleSelectedNotificationChanged(notification);
+                            break;
+                        case POSTED:
+                        case REMOVED:
+                            handleNotificationCountChanged(nm.getCount());
+                            break;
+                    }
+
+                    getTimeout().setTimeoutDelayed(mConfig.getTimeoutNormal(), true);
+
                 }
             });
-            if (event == SELECTED) {
-                mLockFeature = notification == null;
-            }
+        }
+    }
+
+    private class GestureListener extends GestureDetector.SimpleOnGestureListener {
+
+        @Override
+        public boolean onDoubleTap(MotionEvent e) {
+            lock();
+            return true;
         }
     }
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/KeyguardActivity.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/KeyguardActivity.java
new file mode 100644
index 00000000..d9036993
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/KeyguardActivity.java
@@ -0,0 +1,129 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.activities;
+
+import android.app.Activity;
+import android.app.admin.DevicePolicyManager;
+import android.content.Context;
+import android.os.Bundle;
+import android.os.Handler;
+import android.view.WindowManager;
+
+import com.achep.activedisplay.Timeout;
+
+/**
+ * Created by Artem on 23.02.14.
+ */
+public abstract class KeyguardActivity extends Activity implements Timeout.OnTimeoutEventListener {
+
+    private boolean mLocking;
+    private boolean mUnlocking;
+
+    private Timeout mTimeout = new Timeout();
+
+    @SuppressWarnings("ConstantConditions")
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
+
+        mLocking = false;
+        mUnlocking = false;
+        mTimeout.addListener(this);
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        mTimeout.release();
+
+        mUnlocking = false;
+        mLocking = false;
+    }
+
+    @Override
+    protected void onPause() {
+        super.onPause();
+        mTimeout.lock();
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        mTimeout.removeListener(this);
+    }
+
+    @Override
+    public void onTimeoutEvent(int event) {
+        switch (event) {
+            case Timeout.EVENT_TIMEOUT:
+                lock();
+                break;
+        }
+    }
+
+    public void lock() {
+        DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
+        try {
+            dpm.lockNow();
+
+            mTimeout.lock();
+            mLocking = true;
+        } catch (SecurityException e) {
+            mLocking = false;
+        }
+    }
+
+    /**
+     * Unlocks device and runs {@link Runnable runnable} when unlocked.
+     *
+     * @param runnable may be null
+     */
+    public void unlock(final Runnable runnable) {
+        getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
+
+        mTimeout.lock();
+        mUnlocking = true;
+        new Handler().postDelayed(new Runnable() {
+            @Override
+            public void run() {
+                if (runnable != null) runnable.run();
+
+                finish();
+                overridePendingTransition(0, 0);
+            }
+        }, 100 /* We need this delay to get new flags applied */);
+    }
+
+    public final boolean isLocking() {
+        return mLocking;
+    }
+
+    public final boolean isUnlocking() {
+        return mUnlocking;
+    }
+
+    public final Timeout getTimeout() {
+        return mTimeout;
+    }
+
+    @Override
+    public void onBackPressed() { /* override back button */ }
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/MainActivity.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/MainActivity.java
index b7dc4918..f0378519 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/MainActivity.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/MainActivity.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -41,7 +41,9 @@ import com.achep.activedisplay.DialogHelper;
 import com.achep.activedisplay.NotificationIds;
 import com.achep.activedisplay.R;
 import com.achep.activedisplay.admin.AdminReceiver;
+import com.achep.activedisplay.blacklist.activities.BlacklistActivity;
 import com.achep.activedisplay.services.SendNotificationService;
+import com.achep.activedisplay.settings.Settings;
 import com.achep.activedisplay.utils.AccessUtils;
 import com.achep.activedisplay.utils.ViewUtils;
 
@@ -65,7 +67,7 @@ public class MainActivity extends Activity implements Config.OnConfigChangedList
     private View mAccessAllowNotification;
     private View mAccessAllowDeviceAdmin;
 
-    private MenuItem mTestMenuItem;
+    private MenuItem mSendTestNotificationMenuItem;
 
     @Override
     protected void onCreate(Bundle savedInstanceState) {
@@ -77,13 +79,13 @@ public class MainActivity extends Activity implements Config.OnConfigChangedList
 
         getActionBar().setDisplayShowCustomEnabled(true);
         getActionBar().setCustomView(R.layout.layout_ab_switch);
-        mSwitch = (Switch) getActionBar().getCustomView().findViewById(R.id.swatch);
+        mSwitch = (Switch) getActionBar().getCustomView().findViewById(R.id.switch_);
         mSwitch.setChecked(mConfig.isActiveDisplayEnabled());
         mSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
 
             @Override
             public void onCheckedChanged(CompoundButton compoundButton, boolean b) {
-                updateTestMenuItem();
+                updateSendTestNotificationMenuItem();
                 if (mBroadcasting) {
                     return;
                 }
@@ -141,15 +143,15 @@ public class MainActivity extends Activity implements Config.OnConfigChangedList
         }
 
         mSwitch.setEnabled(!showDeviceAdminBtn && !showNotifiesBtn);
-        updateTestMenuItem();
+        updateSendTestNotificationMenuItem();
     }
 
-    private void updateTestMenuItem() {
-        if (mTestMenuItem == null) {
+    private void updateSendTestNotificationMenuItem() {
+        if (mSendTestNotificationMenuItem == null) {
             return;
         }
 
-        mTestMenuItem.setVisible(mSwitch.isEnabled() && mSwitch.isChecked());
+        mSendTestNotificationMenuItem.setVisible(mSwitch.isEnabled() && mSwitch.isChecked());
     }
 
     @Override
@@ -173,8 +175,8 @@ public class MainActivity extends Activity implements Config.OnConfigChangedList
     public boolean onCreateOptionsMenu(Menu menu) {
         getMenuInflater().inflate(R.menu.main, menu);
 
-        mTestMenuItem = menu.findItem(R.id.action_test);
-        updateTestMenuItem();
+        mSendTestNotificationMenuItem = menu.findItem(R.id.action_test);
+        updateSendTestNotificationMenuItem();
         return true;
     }
 
@@ -182,18 +184,25 @@ public class MainActivity extends Activity implements Config.OnConfigChangedList
     public boolean onMenuItemSelected(int featureId, MenuItem item) {
         switch (item.getItemId()) {
             case R.id.action_settings:
-                startActivity(new Intent(this, SettingsActivity.class));
+                startActivity(new Intent(this, Settings.class));
+                break;
+            case R.id.action_blacklist:
+                startActivity(new Intent(this, BlacklistActivity.class));
                 break;
             case R.id.action_test:
-                Intent notificationIntent = new Intent(this, SendNotificationService.class)
-                        .putExtra(SendNotificationService.EXTRA_TITLE, getString(R.string.app_name))
-                        .putExtra(SendNotificationService.EXTRA_TEXT, getString(R.string.test_notification_message))
-                        .putExtra(SendNotificationService.EXTRA_ID, NotificationIds.TEST_NOTIFICATION)
-                        .putExtra(SendNotificationService.EXTRA_ICON_RESOURCE, R.drawable.stat_test)
-                        .putExtra(SendNotificationService.EXTRA_PRIORITY, Notification.PRIORITY_DEFAULT)
-                        .putExtra(SendNotificationService.EXTRA_SOUND_URI, RingtoneManager.getDefaultUri(
-                                RingtoneManager.TYPE_NOTIFICATION));
-                PendingIntent pi = SendNotificationService.sendDelayed(this,
+                Intent contentIntent = new Intent(this, MainActivity.class);
+                Intent notificationIntent = SendNotificationService
+                        .createNotificationIntent(this, getString(R.string.app_name),
+                                getString(R.string.test_notification_message),
+                                NotificationIds.TEST_NOTIFICATION,
+                                R.drawable.stat_test,
+                                R.mipmap.ic_launcher,
+                                Notification.PRIORITY_DEFAULT,
+                                RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION),
+                                PendingIntent.getService(this, 0, contentIntent,
+                                        PendingIntent.FLAG_UPDATE_CURRENT)
+                        );
+                PendingIntent pi = SendNotificationService.notify(this,
                         notificationIntent, SLEEP_SEND_NOTIFICATION_DELAY);
 
                 try {
@@ -214,6 +223,9 @@ public class MainActivity extends Activity implements Config.OnConfigChangedList
             case R.id.action_about:
                 DialogHelper.showAboutDialog(this);
                 break;
+            case R.id.action_help:
+                DialogHelper.showHelpDialog(this);
+                break;
             default:
                 return super.onMenuItemSelected(featureId, item);
         }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/SettingsActivity.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/SettingsActivity.java
deleted file mode 100644
index 95be7e41..00000000
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/activities/SettingsActivity.java
+++ /dev/null
@@ -1,121 +0,0 @@
-/*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.activedisplay.activities;
-
-import android.os.Bundle;
-import android.preference.CheckBoxPreference;
-import android.preference.Preference;
-import android.preference.PreferenceActivity;
-
-import com.achep.activedisplay.Config;
-import com.achep.activedisplay.Keys;
-import com.achep.activedisplay.R;
-import com.achep.activedisplay.preferences.TimeoutPreference;
-
-/**
- * Created by Artem on 21.01.14.
- */
-@SuppressWarnings("deprecation")
-public class SettingsActivity extends PreferenceActivity implements
-        Preference.OnPreferenceChangeListener,
-        Config.OnConfigChangedListener {
-
-    private static final String TAG = "SettingsActivity";
-
-    private CheckBoxPreference mOnlyWhileCharging;
-    private CheckBoxPreference mLowPriorityNotifications;
-
-    private TimeoutPreference mTimeoutPreference;
-
-    private Config mConfig;
-    private boolean mBroadcasting;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        addPreferencesFromResource(R.xml.settings);
-
-        mConfig = Config.getInstance(this);
-        mConfig.addOnConfigChangedListener(this);
-
-        mOnlyWhileCharging = (CheckBoxPreference)
-                findPreference(Keys.Settings.ONLY_WHILE_CHARGING);
-        mOnlyWhileCharging.setOnPreferenceChangeListener(this);
-        mLowPriorityNotifications = (CheckBoxPreference)
-                findPreference(Keys.Settings.LOW_PRIORITY_NOTIFICATIONS);
-        mLowPriorityNotifications.setOnPreferenceChangeListener(this);
-
-        mTimeoutPreference = (TimeoutPreference)
-                findPreference(Keys.Settings.CONFIGURE_TIMEOUT);
-        updateTimeoutPreferenceSummary();
-
-        mBroadcasting = true;
-        mOnlyWhileCharging.setChecked(mConfig.isEnabledOnlyWhileCharging());
-        mLowPriorityNotifications.setChecked(mConfig.isLowPriorityNotificationsAllowed());
-        mBroadcasting = false;
-    }
-
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-        mConfig.removeOnConfigChangedListener(this);
-    }
-
-    @Override
-    public boolean onPreferenceChange(Preference preference, Object o) {
-        //noinspection StatementWithEmptyBody
-        if (mBroadcasting) {
-            /* fall down */
-        } else if (mOnlyWhileCharging == preference) {
-            mConfig.setActiveDisplayEnabledOnlyWhenCharging(this, (Boolean) o, null);
-        } else if (mLowPriorityNotifications == preference) {
-            mConfig.setLowPriorityNotificationsAllowed(this, (Boolean) o, null);
-        } else
-            return false;
-        return true;
-    }
-
-    @Override
-    public void onConfigChanged(Config config, String key, Object value) {
-        mBroadcasting = true;
-        switch (key) {
-            case Config.KEY_ONLY_WHILE_CHARGING:
-                mOnlyWhileCharging.setChecked((Boolean) value);
-                break;
-            case Config.KEY_LOW_PRIORITY_NOTIFICATIONS:
-                mLowPriorityNotifications.setChecked((Boolean) value);
-                break;
-            case Config.KEY_TIMEOUT_NORMAL:
-            case Config.KEY_TIMEOUT_SHORT:
-            case Config.KEY_TIMEOUT_INSTANT:
-                updateTimeoutPreferenceSummary();
-                break;
-        }
-        mBroadcasting = false;
-    }
-
-    private void updateTimeoutPreferenceSummary() {
-        Config config = Config.getInstance(this);
-        mTimeoutPreference.setSummary(getString(R.string.settings_timeout_summary,
-                Float.toString(config.getTimeoutNormal() / 1000f),
-                Float.toString(config.getTimeoutShort() / 1000f),
-                Float.toString(config.getTimeoutInstant() / 1000f)));
-    }
-}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/admin/AdminReceiver.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/admin/AdminReceiver.java
index ddf9dd37..527b51a3 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/admin/AdminReceiver.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/admin/AdminReceiver.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/AppConfig.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/AppConfig.java
new file mode 100644
index 00000000..be5b63a6
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/AppConfig.java
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.blacklist;
+
+import android.content.SharedPreferences;
+import android.util.Log;
+
+import com.achep.activedisplay.utils.MathUtils;
+
+import org.apache.commons.lang.builder.EqualsBuilder;
+import org.apache.commons.lang.builder.HashCodeBuilder;
+
+/**
+ * <b>Attention: its equality key is package name only!<b/>
+ */
+public class AppConfig {
+
+    private static final String TAG = "AppConfig";
+
+    public static final int DIFF_ENABLED = 1;
+    public static final int DIFF_RESTRICTED = 2;
+    public static final int DIFF_HIDDEN = 4;
+
+    /**
+     * Really restricted app is enabled & restricted app
+     */
+    public static final int DIFF_RESTRICTED_REAL = 8;
+
+    /**
+     * Really hidden app is enabled & hidden app
+     */
+    public static final int DIFF_HIDDEN_REAL = 16;
+
+    static final boolean DEFAULT_ENABLED = false;
+    static final boolean DEFAULT_RESTRICTED = false;
+    static final boolean DEFAULT_HIDDEN = false;
+
+    public String packageName;
+    public boolean enabled = DEFAULT_ENABLED;
+    public boolean[] restricted = new boolean[]{DEFAULT_RESTRICTED};
+    public boolean[] hidden = new boolean[]{DEFAULT_HIDDEN};
+
+    public AppConfig(String packageName, boolean enabled,
+                     boolean restricted, boolean hidden) {
+        this.enabled = enabled;
+        this.packageName = packageName;
+        this.restricted[0] = restricted;
+        this.hidden[0] = hidden;
+    }
+
+    /**
+     * Simple wrapper of package name.
+     *
+     * @return an instance of empty {@link AppConfig} with package name.
+     */
+    public static AppConfig wrap(String packageName) {
+        return new AppConfig(packageName, DEFAULT_ENABLED, DEFAULT_RESTRICTED, DEFAULT_HIDDEN);
+    }
+
+    /**
+     * Resets all, except package name, to defaults
+     */
+    public static void reset(AppConfig config) {
+        config.enabled = DEFAULT_ENABLED;
+        config.setRestricted(DEFAULT_RESTRICTED);
+        config.setHidden(DEFAULT_HIDDEN);
+    }
+
+    public static void copy(AppConfig config, AppConfig clone) {
+        clone.enabled = config.enabled;
+        clone.setRestricted(config.isRestricted());
+        clone.setHidden(config.isHidden());
+    }
+
+    /**
+     * Log this config (to debug cats)
+     */
+    public static void log(String tag, AppConfig config) {
+        Log.d(tag, "enabled=" + config.enabled
+                + " restricted=" + config.isRestricted()
+                + " hidden=" + config.isHidden()
+                + " pkg=" + config.packageName);
+    }
+
+    @Override
+    public int hashCode() {
+        return new HashCodeBuilder(279, 351)
+                .append(packageName)
+                .toHashCode();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (o == null)
+            return false;
+        if (o == this)
+            return true;
+        if (!(o instanceof AppConfig))
+            return false;
+
+        AppConfig ps = (AppConfig) o;
+        return new EqualsBuilder()
+                .append(packageName, ps.packageName)
+                .isEquals();
+    }
+
+    // TODO: Make sure that it won't cause any problems.
+    public AppConfig clone() {
+        return new AppConfig(packageName, enabled, isRestricted(), isHidden());
+    }
+
+    public void setRestricted(boolean restricted) {
+        this.restricted[0] = restricted;
+    }
+
+    public void setHidden(boolean hidden) {
+        this.hidden[0] = hidden;
+    }
+
+    public boolean isRestricted() {
+        return restricted[0];
+    }
+
+    public boolean isHidden() {
+        return hidden[0];
+    }
+
+    public boolean isRestrictedReal() {
+        return enabled && isRestricted();
+    }
+
+    public boolean isHiddenReal() {
+        return enabled && isHidden();
+    }
+
+    /**
+     * Created by Artem on 01.03.14.
+     */
+    static final class AppConfigSaver extends SharedList.Saver<AppConfig> {
+
+        private static final String KEY_PACKAGE = "package_name_";
+        private static final String KEY_ENABLED = "enabled_";
+        private static final String KEY_RESTRICTED = "restricted_";
+        private static final String KEY_HIDDEN = "hidden_";
+
+        @Override
+        public SharedPreferences.Editor put(AppConfig ps, SharedPreferences.Editor editor, int position) {
+            editor.putString(KEY_PACKAGE + position, ps.packageName);
+            editor.putBoolean(KEY_ENABLED + position, ps.enabled);
+            editor.putBoolean(KEY_RESTRICTED + position, ps.isRestricted());
+            editor.putBoolean(KEY_HIDDEN + position, ps.isHidden());
+            return editor;
+        }
+
+        @Override
+        public AppConfig get(SharedPreferences prefs, int position) {
+            String pkg = prefs.getString(KEY_PACKAGE + position, null);
+            boolean enabled = prefs.getBoolean(KEY_ENABLED + position, DEFAULT_ENABLED);
+            boolean restricted = prefs.getBoolean(KEY_RESTRICTED + position, DEFAULT_RESTRICTED);
+            boolean hidden = prefs.getBoolean(KEY_HIDDEN + position, DEFAULT_HIDDEN);
+            return new AppConfig(pkg, enabled, restricted, hidden);
+        }
+    }
+
+    /**
+     * Created by Artem on 01.03.14.
+     */
+    static final class AppConfigComparator extends SharedList.Comparator<AppConfig> {
+
+        @Override
+        public int compare(AppConfig object, AppConfig old) {
+            return orZero(DIFF_ENABLED, object.enabled, old.enabled)
+                    | orZero(DIFF_HIDDEN, object.isHidden(), old.isHidden())
+                    | orZero(DIFF_HIDDEN_REAL, object.isHiddenReal(), old.isHiddenReal())
+                    | orZero(DIFF_RESTRICTED, object.isRestricted(), old.isRestricted())
+                    | orZero(DIFF_RESTRICTED_REAL, object.isRestrictedReal(), old.isRestrictedReal());
+        }
+
+        private int orZero(int value, boolean a, boolean b) {
+            return value * MathUtils.bool(a != b);
+        }
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/Blacklist.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/Blacklist.java
new file mode 100644
index 00000000..ec2c9f4f
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/Blacklist.java
@@ -0,0 +1,128 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.blacklist;
+
+import android.content.Context;
+import android.util.Log;
+
+import java.lang.ref.SoftReference;
+
+/**
+ * Created by Artem on 09.02.14.
+ */
+public final class Blacklist extends SharedList<AppConfig, AppConfig.AppConfigSaver> {
+
+    private static final String TAG = "Blacklist";
+
+    public static final String PREF_NAME = "blacklist";
+
+    private static SoftReference<Blacklist> sBlacklistSoft;
+
+    public static synchronized Blacklist getInstance(Context context) {
+        Blacklist instance;
+        if (sBlacklistSoft == null || (instance = sBlacklistSoft.get()) == null) {
+            Log.i(TAG, "Blacklist initialized.");
+
+            instance = new Blacklist(context);
+            sBlacklistSoft = new SoftReference<>(instance);
+            return instance;
+        }
+        return instance;
+    }
+
+    private Blacklist(Context context) {
+        super(context, AppConfig.AppConfigSaver.class);
+    }
+
+    @Override
+    protected String getPreferencesFileName() {
+        return PREF_NAME;
+    }
+
+    @Override
+    protected Comparator<AppConfig> onCreateComparator() {
+        return new AppConfig.AppConfigComparator();
+    }
+
+    @Override
+    protected boolean isOverwriteAllowed(AppConfig object) {
+        return true;
+    }
+
+    public void saveAppConfig(Context context, AppConfig config,
+                              OnSharedListChangedListener listener) {
+        if (config.enabled == AppConfig.DEFAULT_ENABLED
+                && config.isRestricted() == AppConfig.DEFAULT_RESTRICTED
+                && config.isHidden() == AppConfig.DEFAULT_HIDDEN) {
+
+            // The config is empty. We can delete it without
+            // any cares of losing its data.
+            remove(context, config, listener);
+            return;
+        }
+
+        AppConfig clone = AppConfig.wrap(config.packageName);
+        AppConfig.copy(config, clone);
+        put(context, clone, listener);
+    }
+
+    public AppConfig fill(AppConfig config) {
+        for (AppConfig c : valuesSet()) {
+            if (c.equals(config)) {
+                AppConfig.copy(c, config);
+                return config;
+            }
+        }
+        AppConfig.reset(config);
+        return config;
+    }
+
+    public static abstract class OnBlacklistChangedListener implements
+            OnSharedListChangedListener<AppConfig> {
+
+        public abstract void onBlacklistChanged(AppConfig configNew, AppConfig configOld, int diff);
+
+        @Override
+        public final void onPut(AppConfig objectNew, AppConfig objectOld, int diff) {
+            onBlacklistChanged(objectNew, objectOld, diff);
+        }
+
+        @Override
+        public final void onRemoved(AppConfig objectRemoved) { /* unused */ }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    // No more Removed event
+    protected void notifyOnRemoved(AppConfig object, OnSharedListChangedListener l) {
+        super.notifyOnPut(AppConfig.wrap(object.packageName), object, l);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    // Do not allow null as old object
+    protected void notifyOnPut(AppConfig object, AppConfig old, OnSharedListChangedListener l) {
+        super.notifyOnPut(object, old == null ? AppConfig.wrap(object.packageName) : old, l);
+    }
+}
+
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/BlacklistEnabler.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/BlacklistEnabler.java
new file mode 100644
index 00000000..90d42002
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/BlacklistEnabler.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.blacklist;
+
+import android.content.Context;
+import android.widget.CompoundButton;
+
+import com.achep.activedisplay.Operator;
+
+import java.util.ArrayList;
+
+/**
+ * Created by Artem on 21.02.14.
+ */
+public class BlacklistEnabler extends Blacklist.OnBlacklistChangedListener
+        implements CompoundButton.OnCheckedChangeListener {
+
+    private static final String TAG = "BlacklistEnabler";
+
+    private final Context mContext;
+    private final Blacklist mBlacklist;
+    private AppConfig mAppConfig;
+    private CompoundButton mCompoundButton;
+
+    private boolean mResumed;
+    private boolean mBroadcasting;
+
+    private ArrayList<Blacklist.OnBlacklistChangedListener> mListeners;
+
+    public void addOnAppConfigChangedListener(Blacklist.OnBlacklistChangedListener listener) {
+        mListeners.add(listener);
+    }
+
+    public void removeOnAppConfigChangedListener(Blacklist.OnBlacklistChangedListener listener) {
+        mListeners.remove(listener);
+    }
+
+    public BlacklistEnabler(Context context, CompoundButton cb, String packageName) {
+        mContext = context;
+        mCompoundButton = cb;
+        mBlacklist = Blacklist.getInstance(mContext);
+        mAppConfig = AppConfig.wrap(packageName);
+
+        mListeners = new ArrayList<>(6);
+    }
+
+    /**
+     * Sets up listeners and updates the current state.
+     * Make sure that you call {@link #pause()} after!
+     */
+    public void resume() {
+        if (mResumed) {
+            return;
+        }
+
+        mResumed = true;
+        mBlacklist.addOnSharedListChangedListener(this);
+        mCompoundButton.setOnCheckedChangeListener(this);
+        reloadAppConfig();
+    }
+
+    public void pause() {
+        if (!mResumed) {
+            return;
+        }
+
+        mResumed = false;
+        mBlacklist.removeOnSharedListChangedListener(this);
+        mCompoundButton.setOnCheckedChangeListener(null);
+    }
+
+    // //////////////////////////////////////////
+    // ////////////// -- MAIN -- ////////////////
+    // //////////////////////////////////////////
+
+    public void setSwitch(CompoundButton cb) {
+        if (mCompoundButton == cb) {
+            return;
+        }
+
+        boolean checked = mCompoundButton.isChecked();
+
+        mCompoundButton.setOnCheckedChangeListener(null);
+        mCompoundButton = cb;
+        mCompoundButton.setOnCheckedChangeListener(this);
+        setChecked(checked);
+    }
+
+    /**
+     * Changes tracking app to new one.
+     *
+     * @param packageName a package name of new app
+     */
+    public void setPackageName(String packageName) {
+        mAppConfig.packageName = packageName;
+        reloadAppConfig();
+    }
+
+    public AppConfig getAppConfig() {
+        return mAppConfig;
+    }
+
+    private void reloadAppConfig() {
+        AppConfig configOld = mAppConfig.clone();
+        mBlacklist.fill(mAppConfig);
+        onBlacklistChanged(mAppConfig, configOld,
+                mBlacklist.getComparator().compare(mAppConfig, configOld));
+    }
+
+    private void setChecked(boolean checked) {
+        mBroadcasting = true;
+        mCompoundButton.setChecked(checked);
+        mBroadcasting = false;
+    }
+
+    @Override
+    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+        if (mBroadcasting) {
+            return;
+        }
+
+        mAppConfig.enabled = isChecked;
+        mBlacklist.saveAppConfig(mContext, mAppConfig, this);
+    }
+
+    // //////////////////////////////////////////
+    // ///////// -- BLACKLIST CORE -- ///////////
+    // //////////////////////////////////////////
+
+    @Override
+    public void onBlacklistChanged(AppConfig configNew, AppConfig configOld, int diff) {
+        if (configNew.equals(mAppConfig)) {
+            AppConfig.copy(configNew, mAppConfig);
+
+            if (Operator.bitandCompare(diff, AppConfig.DIFF_ENABLED))
+                setChecked(configNew.enabled);
+            for (Blacklist.OnBlacklistChangedListener listener : mListeners)
+                listener.onBlacklistChanged(mAppConfig, configOld, diff);
+        }
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/SharedList.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/SharedList.java
index 3e16562e..48a462e6 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/SharedList.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/SharedList.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -28,7 +28,7 @@ import java.util.Set;
 
 /**
  * Simple list which automatically saves items to private storage and restores on initialize.
- * This is useful for implementing blacklists.
+ * This may be useful for implementing blacklists or something fun.
  */
 public abstract class SharedList<V, T extends SharedList.Saver<V>> {
 
@@ -39,21 +39,37 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> {
 
     private final HashMap<V, Integer> mList;
     private final ArrayList<Integer> mPlaceholder;
+    private final Comparator<V> mComparator;
     private final T mSaver;
 
     private ArrayList<OnSharedListChangedListener<V>> mListeners;
 
     public interface OnSharedListChangedListener<V> {
-        public void onPut(V object);
 
-        public void onRemoved(V object);
+        /**
+         * Called on object put to / replaced in the list.
+         *
+         * @param objectNew current object
+         * @param objectOld old object from the list
+         * @param diff      the difference between old and new objects (provided by {@link Comparator})
+         */
+        public void onPut(V objectNew, V objectOld, int diff);
+
+        /**
+         * Called on object removed from the list.
+         *
+         * @param objectRemoved removed object from the list
+         */
+        public void onRemoved(V objectRemoved);
     }
 
     public void addOnSharedListChangedListener(OnSharedListChangedListener<V> listener) {
+        Log.i(TAG, "Registered new listener: (" + mListeners.size() + ")" + listener);
         mListeners.add(listener);
     }
 
     public void removeOnSharedListChangedListener(OnSharedListChangedListener<V> listener) {
+        Log.i(TAG, "Unregistered listener: (" + mListeners.size() + ")" + listener);
         mListeners.remove(listener);
     }
 
@@ -61,6 +77,7 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> {
         mList = new HashMap<>();
         mPlaceholder = new ArrayList<>(3);
         mListeners = new ArrayList<>(6);
+        mComparator = onCreateComparator();
 
         try {
             mSaver = clazz.newInstance();
@@ -86,13 +103,43 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> {
 
     protected abstract String getPreferencesFileName();
 
-    public synchronized void remove(Context context, V object) {
-        Integer value = mList.remove(object);
-        if (value == null) {
-            Log.w(TAG, "Tried to remove non-existing object from blacklist.");
+    /**
+     * May be null.
+     */
+    protected Comparator<V> onCreateComparator() {
+        return null;
+    }
+
+    public Comparator<V> getComparator() {
+        return mComparator;
+    }
+
+    protected boolean isOverwriteAllowed(V object) {
+        return false;
+    }
+
+    // ///////// -- CORE CODE -- ///////////
+
+    public void remove(Context context, V object) {
+        remove(context, object, null);
+    }
+
+    public void remove(Context context, V object, OnSharedListChangedListener l) {
+        if (!mList.containsKey(object)) {
+            Log.w(TAG, "Tried to remove non-existing object from the list.");
             return;
         }
 
+        V objectRemoved = null;
+        for (V o : mList.keySet()) {
+            if (o.equals(object)) {
+                objectRemoved = o;
+                break;
+            }
+        }
+
+        Integer value = mList.remove(object);
+
         int i = 0;
         int length = mPlaceholder.size();
         for (; i < length; i++)
@@ -104,19 +151,44 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> {
                 .putBoolean(KEY_USED_ITEM + value, false)
                 .apply();
 
+        notifyOnRemoved(objectRemoved, l);
+    }
+
+    /**
+     * Notifies listener about Remove event
+     */
+    protected void notifyOnRemoved(V objectRemoved, OnSharedListChangedListener l) {
         for (OnSharedListChangedListener<V> listener : mListeners) {
-            listener.onRemoved(object);
+            if (listener == l) continue;
+            listener.onRemoved(objectRemoved);
         }
     }
 
-    public synchronized void put(Context context, V object) {
-        if (mList.containsKey(object)) {
-            Log.w(TAG, "Trying to put existing object to blacklist.");
-            return;
-        }
+    public V put(Context context, V object) {
+        return put(context, object, null);
+    }
 
+    public V put(Context context, V object, OnSharedListChangedListener l) {
         boolean growUp = mPlaceholder.size() == 0;
         int value = growUp ? mList.size() : mPlaceholder.get(0);
+
+        V old = null;
+        if (mList.containsKey(object)) {
+            if (!isOverwriteAllowed(object)) {
+                Log.w(TAG, "Trying to put an existing object to the list.");
+                return null;
+            }
+
+            for (V o : mList.keySet()) {
+                if (o.equals(object)) {
+                    old = o;
+                    break;
+                }
+            }
+            value = mList.get(object);
+            mList.remove(object);
+        }
+
         mList.put(object, value);
 
         SharedPreferences.Editor editor = mSaver
@@ -125,24 +197,47 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> {
         if (growUp) editor.putInt(KEY_NUMBER, value);
         editor.apply();
 
+        notifyOnPut(object, old, l);
+        return old;
+    }
+
+    /**
+     * Notifies listener about Put event
+     *
+     * @param object new object
+     * @param old    old object from the list
+     */
+    protected void notifyOnPut(V object, V old, OnSharedListChangedListener l) {
+        int diff = mComparator != null ? mComparator.compare(object, old) : 0;
         for (OnSharedListChangedListener<V> listener : mListeners) {
-            listener.onPut(object);
+            if (listener == l) continue;
+            listener.onPut(object, old, diff);
         }
     }
 
-    public synchronized boolean contains(V object) {
+    public boolean contains(V object) {
         return mList.containsKey(object);
     }
 
-    public synchronized Set<V> valuesSet() {
+    public Set<V> valuesSet() {
         return mList.keySet();
     }
 
+    // ///////// -- CLASSES-- ///////////
+
+    /**
+     * Additional class to provide diffs between "old" and "new" objects.
+     */
+    public static abstract class Comparator<V> {
+        public abstract int compare(V object, V old);
+    }
+
+    // I could use Parcelable for that too.
     public static abstract class Saver<V> {
 
         /**
          * Should not overwrite value at {@link SharedList#KEY_NUMBER} or/and
-         * has key starts with {@link SharedList#KEY_USED_ITEM}!
+         * has key which starts with {@link SharedList#KEY_USED_ITEM}!
          */
         public abstract SharedPreferences.Editor put(V object, SharedPreferences.Editor editor, int position);
 
@@ -150,19 +245,4 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> {
 
     }
 
-    public static class StringSaver extends Saver<String> {
-
-        private static final String KEY = "str_";
-
-        @Override
-        public SharedPreferences.Editor put(String str, SharedPreferences.Editor editor, int position) {
-            return editor.putString(KEY + position, str);
-        }
-
-        @Override
-        public String get(SharedPreferences prefs, int position) {
-            return prefs.getString(KEY + position, null);
-        }
-    }
-
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/activities/BlacklistActivity.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/activities/BlacklistActivity.java
new file mode 100644
index 00000000..84331289
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/activities/BlacklistActivity.java
@@ -0,0 +1,702 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.blacklist.activities;
+
+import android.app.Activity;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.SharedPreferences;
+import android.content.pm.ActivityInfo;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.graphics.drawable.Drawable;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.os.SystemClock;
+import android.preference.Preference;
+import android.preference.PreferenceActivity;
+import android.preference.PreferenceFragment;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.ImageView;
+import android.widget.ListAdapter;
+import android.widget.Switch;
+import android.widget.TextView;
+
+import com.achep.activedisplay.R;
+import com.achep.activedisplay.blacklist.Blacklist;
+import com.achep.activedisplay.blacklist.BlacklistEnabler;
+import com.achep.activedisplay.blacklist.fragments.BlacklistAppFragment;
+import com.achep.activedisplay.utils.MathUtils;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * Top-level settings activity to handle single pane and double pane UI layout.
+ */
+public class BlacklistActivity extends PreferenceActivity {
+
+    private static final String TAG = "BlacklistActivity";
+
+    // meta data
+    private static final String META_DATA_KEY_HEADER_ID =
+            "com.achep.activedisplay.blacklist.TOP_LEVEL_HEADER_ID";
+    private static final String META_DATA_KEY_FRAGMENT_CLASS =
+            "com.achep.activedisplay.blacklist.FRAGMENT_CLASS";
+    private static final String META_DATA_KEY_PARENT_TITLE =
+            "com.achep.activedisplay.blacklist.PARENT_FRAGMENT_TITLE";
+    private static final String META_DATA_KEY_PARENT_FRAGMENT_CLASS =
+            "com.achep.activedisplay.blacklist.PARENT_FRAGMENT_CLASS";
+
+    // save state
+    private static final String SAVE_KEY_CURRENT_HEADER =
+            "com.achep.activedisplay.blacklist.CURRENT_HEADER";
+    private static final String SAVE_KEY_PARENT_HEADER =
+            "com.achep.activedisplay.blacklist.PARENT_HEADER";
+
+    // preferences
+    private static final String PREF_KEY_SHOW_SYSTEM_APPS = "show_system_apps";
+
+    private String mFragmentClass;
+    private int mTopLevelHeaderId;
+    private Header mFirstHeader;
+    private Header mCurrentHeader;
+    private Header mParentHeader;
+    private boolean mInLocalHeaderSwitch;
+
+    protected HashMap<Integer, Integer> mHeaderIndexMap = new HashMap<>();
+
+    private SharedPreferences mPreferences;
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        mPreferences = getSharedPreferences(Blacklist.PREF_NAME, Activity.MODE_PRIVATE);
+
+        getMetaData();
+        mInLocalHeaderSwitch = true;
+        super.onCreate(savedInstanceState);
+        mInLocalHeaderSwitch = false;
+
+        if (!onIsHidingHeaders() && onIsMultiPane()) {
+            highlightHeader(mTopLevelHeaderId);
+            // Force the title so that it doesn't get overridden by a direct launch of
+            // a specific settings screen.
+            setTitle(R.string.settings);
+        }
+
+        // Retrieve any saved state
+        if (savedInstanceState != null) {
+            mCurrentHeader = savedInstanceState.getParcelable(SAVE_KEY_CURRENT_HEADER);
+            mParentHeader = savedInstanceState.getParcelable(SAVE_KEY_PARENT_HEADER);
+        }
+
+        // If the current header was saved, switch to it
+        if (savedInstanceState != null && mCurrentHeader != null) {
+            //switchToHeaderLocal(mCurrentHeader);
+            showBreadCrumbs(mCurrentHeader.title, null);
+        }
+
+        if (mParentHeader != null) {
+            setParentTitle(mParentHeader.title, null, new OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    switchToParent(mParentHeader.fragment);
+                }
+            });
+        }
+
+        // Override up navigation for multi-pane, since we handle it in the fragment breadcrumbs
+        if (onIsMultiPane()) {
+            getActionBar().setDisplayHomeAsUpEnabled(false);
+            getActionBar().setHomeButtonEnabled(false);
+        }
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        // Save the current fragment, if it is the same as originally launched
+        if (mCurrentHeader != null) {
+            outState.putParcelable(SAVE_KEY_CURRENT_HEADER, mCurrentHeader);
+        }
+        if (mParentHeader != null) {
+            outState.putParcelable(SAVE_KEY_PARENT_HEADER, mParentHeader);
+        }
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        ListAdapter listAdapter = getListAdapter();
+        if (listAdapter instanceof HeaderAdapter) {
+            ((HeaderAdapter) listAdapter).resume();
+        }
+        invalidateHeaders();
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        ListAdapter listAdapter = getListAdapter();
+        if (listAdapter instanceof HeaderAdapter) {
+            ((HeaderAdapter) listAdapter).pause();
+        }
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        getMenuInflater().inflate(R.menu.blacklist, menu);
+        menu.findItem(R.id.show_system_apps).setChecked(shouldShowSystemApps());
+        return true;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+            case R.id.show_system_apps:
+                item.setChecked(!item.isChecked());
+                mPreferences
+                        .edit()
+                        .putBoolean(PREF_KEY_SHOW_SYSTEM_APPS, item.isChecked())
+                        .commit();
+                invalidateHeaders();
+                break;
+            default:
+                return super.onOptionsItemSelected(item);
+        }
+        return true;
+    }
+
+    private boolean shouldShowSystemApps() {
+        return mPreferences.getBoolean(PREF_KEY_SHOW_SYSTEM_APPS, false);
+    }
+
+    private void updateIcons() {
+        ListAdapter listAdapter = getListAdapter();
+        if (listAdapter instanceof HeaderAdapter) {
+            ((HeaderAdapter) listAdapter).loadIcons();
+        }
+    }
+
+    /**
+     * Fills header list with a list of installed apps.
+     */
+    private void buildHeaderList(List<Header> headers, boolean showSystemApps) {
+        String fragmentName = BlacklistAppFragment.class.getCanonicalName();
+        int id = 1;
+
+        PackageManager pm = getPackageManager();
+        List<ApplicationInfo> packages = pm.getInstalledApplications(PackageManager.GET_META_DATA);
+        for (ApplicationInfo app : packages) {
+            int systemFlag = ApplicationInfo.FLAG_SYSTEM | ApplicationInfo.FLAG_UPDATED_SYSTEM_APP;
+            int system = MathUtils.bool((app.flags & systemFlag) != 0);
+
+            if (system == 1 && !showSystemApps) {
+                continue;
+            }
+
+            Header header = new Header();
+            header.fragment = fragmentName;
+            header.title = app.loadLabel(pm); // TODO: This is pretty huge operation
+            header.summary = app.packageName;
+            header.id = system | id++ << 1; // Store if system app to id
+
+            // Add package name for the fragment
+            Bundle args = new Bundle();
+            args.putString(BlacklistAppFragment.ARGS_PACKAGE_NAME, app.packageName);
+            header.fragmentArguments = args;
+
+            headers.add(header);
+        }
+
+        // Sort by app name
+        Collections.sort(headers, new Comparator<Header>() {
+            @Override
+            public int compare(Header header1, Header header2) {
+                String title1 = header1.title.toString();
+                String title2 = header2.title.toString();
+                return title1.compareToIgnoreCase(title2);
+            }
+        });
+    }
+
+    @Override
+    protected boolean isValidFragment(String fragmentName) {
+        return true;
+    }
+
+    private void switchToHeaderLocal(Header header) {
+        mInLocalHeaderSwitch = true;
+        switchToHeader(header);
+        mInLocalHeaderSwitch = false;
+    }
+
+    @Override
+    public void switchToHeader(Header header) {
+        if (!mInLocalHeaderSwitch) {
+            mCurrentHeader = null;
+            mParentHeader = null;
+        }
+        super.switchToHeader(header);
+    }
+
+    /**
+     * Switch to parent fragment and store the grand parent's info
+     *
+     * @param className name of the activity wrapper for the parent fragment.
+     */
+    private void switchToParent(String className) {
+        final ComponentName cn = new ComponentName(this, className);
+        try {
+            final PackageManager pm = getPackageManager();
+            final ActivityInfo parentInfo = pm.getActivityInfo(cn, PackageManager.GET_META_DATA);
+
+            if (parentInfo != null && parentInfo.metaData != null) {
+                String fragmentClass = parentInfo.metaData.getString(META_DATA_KEY_FRAGMENT_CLASS);
+                CharSequence fragmentTitle = parentInfo.loadLabel(pm);
+                Header parentHeader = new Header();
+                parentHeader.fragment = fragmentClass;
+                parentHeader.title = fragmentTitle;
+                mCurrentHeader = parentHeader;
+
+                switchToHeaderLocal(parentHeader);
+                highlightHeader(mTopLevelHeaderId);
+
+                mParentHeader = new Header();
+                mParentHeader.fragment
+                        = parentInfo.metaData.getString(META_DATA_KEY_PARENT_FRAGMENT_CLASS);
+                mParentHeader.title = parentInfo.metaData.getString(META_DATA_KEY_PARENT_TITLE);
+            }
+        } catch (NameNotFoundException nnfe) {
+            Log.w(TAG, "Could not find parent activity : " + className);
+        }
+    }
+
+    @Override
+    public void onNewIntent(Intent intent) {
+        super.onNewIntent(intent);
+
+        // If it is not launched from history, then reset to top-level
+        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY) == 0) {
+            if (mFirstHeader != null && !onIsHidingHeaders() && onIsMultiPane()) {
+                switchToHeaderLocal(mFirstHeader);
+            }
+            getListView().setSelectionFromTop(0, 0);
+        }
+    }
+
+    private void highlightHeader(int id) {
+        if (id != 0) {
+            Integer index = mHeaderIndexMap.get(id);
+            if (index != null) {
+                getListView().setItemChecked(index, true);
+                if (isMultiPane()) {
+                    getListView().smoothScrollToPosition(index);
+                }
+            }
+        }
+    }
+
+    @Override
+    public Intent getIntent() {
+        Intent superIntent = super.getIntent();
+        String startingFragment = getStartingFragmentClass(superIntent);
+        // This is called from super.onCreate, isMultiPane() is not yet reliable
+        // Do not use onIsHidingHeaders either, which relies itself on this method
+        if (startingFragment != null && !onIsMultiPane()) {
+            Intent modIntent = new Intent(superIntent);
+            modIntent.putExtra(EXTRA_SHOW_FRAGMENT, startingFragment);
+            Bundle args = superIntent.getExtras();
+            if (args != null) {
+                args = new Bundle(args);
+            } else {
+                args = new Bundle();
+            }
+            args.putParcelable("intent", superIntent);
+            modIntent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, superIntent.getExtras());
+            return modIntent;
+        }
+        return superIntent;
+    }
+
+    /**
+     * Checks if the component name in the intent is different from the Settings class and
+     * returns the class name to load as a fragment.
+     */
+    protected String getStartingFragmentClass(Intent intent) {
+        if (mFragmentClass != null) return mFragmentClass;
+        String intentClass = intent.getComponent().getClassName();
+        if (intentClass.equals(getClass().getName())) return null;
+
+        return intentClass;
+    }
+
+    /**
+     * Override initial header when an activity-alias is causing Settings to be launched
+     * for a specific fragment encoded in the android:name parameter.
+     */
+    @Override
+    public Header onGetInitialHeader() {
+        String fragmentClass = getStartingFragmentClass(super.getIntent());
+        if (fragmentClass != null) {
+            Header header = new Header();
+            header.fragment = fragmentClass;
+            header.title = getTitle();
+            header.fragmentArguments = getIntent().getExtras();
+            mCurrentHeader = header;
+            return header;
+        }
+
+        return mFirstHeader;
+    }
+
+    @Override
+    public Intent onBuildStartFragmentIntent(String fragmentName, Bundle args,
+                                             int titleRes, int shortTitleRes) {
+        return super
+                .onBuildStartFragmentIntent(fragmentName, args, titleRes, shortTitleRes)
+                .setClass(this, SubBlacklistActivity.class);
+    }
+
+    /**
+     * Populate the activity with the top-level headers.
+     */
+    @Override
+    public void onBuildHeaders(List<Header> headers) {
+        if (!onIsHidingHeaders()) {
+            buildHeaderList(headers, shouldShowSystemApps());
+            updateHeaderList(headers);
+            updateIcons();
+        }
+    }
+
+    private void updateHeaderList(List<Header> target) {
+        int i = 0;
+        mHeaderIndexMap.clear();
+        while (i < target.size()) {
+            Header header = target.get(i);
+            // Ids are integers, so downcasting
+            int id = (int) header.id;
+
+            // Increment if the current one wasn't removed by the Utils code.
+            if (i < target.size() && target.get(i) == header) {
+                // Hold on to the first header, when we need to reset to the top-level
+                int headerType = HeaderAdapter.getHeaderType(header);
+                if (mFirstHeader == null &&
+                        headerType != HeaderAdapter.HEADER_TYPE_CATEGORY) {
+                    mFirstHeader = header;
+                }
+                mHeaderIndexMap.put(id, i);
+                i++;
+            }
+        }
+    }
+
+    private void getMetaData() {
+        try {
+            ActivityInfo ai = getPackageManager().getActivityInfo(getComponentName(),
+                    PackageManager.GET_META_DATA);
+            if (ai == null || ai.metaData == null) return;
+            mTopLevelHeaderId = ai.metaData.getInt(META_DATA_KEY_HEADER_ID);
+            mFragmentClass = ai.metaData.getString(META_DATA_KEY_FRAGMENT_CLASS);
+
+            // Check if it has a parent specified and create a Header object
+            final int parentHeaderTitleRes = ai.metaData.getInt(META_DATA_KEY_PARENT_TITLE);
+            String parentFragmentClass = ai.metaData.getString(META_DATA_KEY_PARENT_FRAGMENT_CLASS);
+            if (parentFragmentClass != null) {
+                mParentHeader = new Header();
+                mParentHeader.fragment = parentFragmentClass;
+                if (parentHeaderTitleRes != 0) {
+                    mParentHeader.title = getResources().getString(parentHeaderTitleRes);
+                }
+            }
+        } catch (NameNotFoundException e) {
+            // No recovery
+        }
+    }
+
+    private static class HeaderAdapter extends ArrayAdapter<Header> {
+
+        static final int HEADER_TYPE_CATEGORY = 0;
+        static final int HEADER_TYPE_SWITCH = 1;
+        private static final int HEADER_TYPE_COUNT = 2;
+
+        private final Context mContext;
+        private final LayoutInflater mInflater;
+
+        private final PackageManager mPackageManager;
+        private final Drawable mDefaultImg;
+        private final List<Header> mHeaders;
+        private LoadIconsTask mLoadIconsTask;
+
+        private final ConcurrentHashMap<String, Drawable> mIcons;
+        private final HashSet<BlacklistEnabler> mBlacklistEnablers;
+
+        static int getHeaderType(Header header) {
+            if (header.fragment == null && header.intent == null) {
+                return HEADER_TYPE_CATEGORY;
+            } else {
+                return HEADER_TYPE_SWITCH;
+            }
+        }
+
+        @Override
+        public int getItemViewType(int position) {
+            Header header = getItem(position);
+            return getHeaderType(header);
+        }
+
+        @Override
+        public boolean areAllItemsEnabled() {
+            return false; // because of categories
+        }
+
+        @Override
+        public boolean isEnabled(int position) {
+            return getItemViewType(position) != HEADER_TYPE_CATEGORY;
+        }
+
+        @Override
+        public int getViewTypeCount() {
+            return HEADER_TYPE_COUNT;
+        }
+
+        @Override
+        public boolean hasStableIds() {
+            return true;
+        }
+
+        public HeaderAdapter(Context context, List<Header> headers) {
+            super(context, 0, headers);
+
+            mContext = context;
+            mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+            mPackageManager = context.getPackageManager();
+            mHeaders = headers;
+
+            // Set the default icon till the actual app icon is loaded in async task
+            mDefaultImg = context.getResources().getDrawable(android.R.mipmap.sym_def_app_icon);
+
+            mBlacklistEnablers = new HashSet<>();
+            mIcons = new ConcurrentHashMap<>();
+
+            loadIcons();
+        }
+
+        private static class Holder {
+            ImageView icon;
+            TextView title;
+            TextView summary;
+            Switch switch_;
+
+            BlacklistEnabler enabler;
+        }
+
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+            final Holder holder;
+            final Header header = getItem(position);
+            final int headerType = getHeaderType(header);
+            View view = null;
+
+            if (convertView == null) {
+                holder = new Holder();
+                switch (headerType) {
+                    case HEADER_TYPE_CATEGORY:
+                        view = new TextView(getContext(), null,
+                                android.R.attr.listSeparatorTextViewStyle);
+                        holder.title = (TextView) view;
+                        break;
+
+                    case HEADER_TYPE_SWITCH:
+                        view = mInflater.inflate(
+                                R.layout.preference_header_switch_item, parent,
+                                false);
+                        holder.icon = (ImageView) view.findViewById(R.id.icon);
+                        holder.title = (TextView) view.findViewById(android.R.id.title);
+                        holder.summary = (TextView) view.findViewById(android.R.id.summary);
+                        holder.switch_ = (Switch) view.findViewById(R.id.switch_);
+
+                        // Set up one more listener.
+                        String packageName = "" + header.summary;
+                        holder.enabler = new BlacklistEnabler(mContext, holder.switch_, packageName);
+                        holder.enabler.resume();
+                        mBlacklistEnablers.add(holder.enabler);
+                        break;
+                }
+                view.setTag(holder);
+            } else {
+                view = convertView;
+                holder = (Holder) view.getTag();
+            }
+
+            // All view fields must be updated every time, because the view may be recycled
+            switch (headerType) {
+                case HEADER_TYPE_CATEGORY:
+                    holder.title.setText(header.getTitle(getContext().getResources()));
+                    break;
+
+                case HEADER_TYPE_SWITCH:
+                    CharSequence title;
+                    String packageName = "" + header.summary;
+                    if (header.title != null && !header.title.equals(packageName)) {
+                        title = header.title;
+                        holder.summary.setVisibility(View.VISIBLE);
+                        holder.summary.setText(packageName);
+                    } else {
+                        title = packageName;
+                        holder.summary.setVisibility(View.GONE);
+                    }
+
+                    Drawable icon = mIcons.get(packageName);
+                    holder.icon.setImageDrawable(icon != null ? icon : mDefaultImg);
+                    holder.title.setText(title);
+
+                    // Track current app.
+                    holder.enabler.setSwitch(holder.switch_);
+                    holder.enabler.setPackageName(packageName);
+                    break;
+            }
+
+            return view;
+        }
+
+        /**
+         * Update the list of apps' icons
+         */
+        public void loadIcons() {
+            if (mLoadIconsTask != null && !mLoadIconsTask.getStatus()
+                    .equals(AsyncTask.Status.FINISHED)) {
+                mLoadIconsTask.cancel = true;
+                mLoadIconsTask.cancel(false);
+            }
+            mLoadIconsTask = new LoadIconsTask();
+            mLoadIconsTask.execute(mHeaders.toArray(new Header[mHeaders.size()]));
+        }
+
+        public void resume() {
+            for (BlacklistEnabler enabler : mBlacklistEnablers) {
+                enabler.resume();
+            }
+        }
+
+        public void pause() {
+            for (BlacklistEnabler enabler : mBlacklistEnablers) {
+                enabler.pause();
+            }
+        }
+
+        /**
+         * An asynchronous task to load the icons & titles of the installed applications.
+         */
+        // TODO: Maybe use SoftReference<> to save some memory.
+        private class LoadIconsTask extends AsyncTask<Header, Void, Void> {
+
+            private volatile long time;
+            private volatile boolean cancel;
+
+            @Override
+            protected Void doInBackground(Header... headers) {
+                for (Header header : headers) {
+                    try {
+                        if (cancel) return null;
+
+                        String packageName = "" + header.summary;
+                        if (mIcons.containsKey(packageName)) {
+                            continue;
+                        }
+
+                        ApplicationInfo app = mPackageManager.getApplicationInfo(packageName, 0);
+                        Drawable icon = mPackageManager.getApplicationIcon(app.packageName);
+                        mIcons.put(app.packageName, icon);
+
+                        long now = SystemClock.uptimeMillis();
+                        if (now - time > 500) {
+                            publishProgress();
+                            time = now;
+                        }
+                    } catch (NameNotFoundException e) {
+                        // ignored; app will show up with default image & title
+                    }
+                }
+                return null;
+            }
+
+            @Override
+            protected void onProgressUpdate(Void... progress) {
+                notifyDataSetChanged();
+            }
+
+            @Override
+            protected void onPostExecute(Void aVoid) {
+                super.onPostExecute(aVoid);
+                notifyDataSetChanged();
+            }
+        }
+    }
+
+    @Override
+    public boolean onPreferenceStartFragment(PreferenceFragment caller, Preference pref) {
+        startPreferencePanel(
+                pref.getFragment(),
+                pref.getExtras(),
+                pref.getTitleRes(),
+                pref.getTitle(), null, 0);
+        return true;
+    }
+
+    @Override
+    public boolean shouldUpRecreateTask(Intent targetIntent) {
+        return super.shouldUpRecreateTask(new Intent(this, BlacklistActivity.class));
+    }
+
+    @Override
+    public void setListAdapter(ListAdapter adapter) {
+        if (adapter == null) {
+            super.setListAdapter(null);
+        } else {
+            List<Header> headers = null;
+            try {
+                Method method = PreferenceActivity.class.getDeclaredMethod("getHeaders");
+                method.setAccessible(true);
+                headers = (List<Header>) method.invoke(this);
+            } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
+                e.printStackTrace();
+            }
+
+            super.setListAdapter(new HeaderAdapter(this, headers));
+        }
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/activities/SubBlacklistActivity.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/activities/SubBlacklistActivity.java
new file mode 100644
index 00000000..5e0254d1
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/activities/SubBlacklistActivity.java
@@ -0,0 +1,60 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.blacklist.activities;
+
+import android.app.FragmentManager;
+import android.util.Log;
+import android.view.Menu;
+
+/**
+ * Top-level settings activity to handle single pane and double pane UI layout.
+ */
+public class SubBlacklistActivity extends BlacklistActivity {
+
+    private static final String TAG = "SubBlacklist";
+
+    @Override
+    public boolean onNavigateUp() {
+        if (!popFragment()) {
+            finish();
+        }
+        return true;
+    }
+
+    @Override
+    protected boolean isValidFragment(String fragmentName) {
+        Log.d(TAG, "Launching fragment " + fragmentName);
+        return true;
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        return false;
+    }
+
+    private boolean popFragment() {
+        FragmentManager fm = getFragmentManager();
+        if (fm.getBackStackEntryCount() > 0) {
+            fm.popBackStack();
+            return true;
+        }
+        return false;
+    }
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/fragments/BlacklistAppFragment.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/fragments/BlacklistAppFragment.java
new file mode 100644
index 00000000..6880610c
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/fragments/BlacklistAppFragment.java
@@ -0,0 +1,199 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.blacklist.fragments;
+
+import android.app.ActionBar;
+import android.app.Activity;
+import android.app.Fragment;
+import android.content.pm.ApplicationInfo;
+import android.content.pm.PackageManager;
+import android.os.Bundle;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.CheckBox;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.ScrollView;
+import android.widget.Switch;
+import android.widget.TextView;
+
+import com.achep.activedisplay.R;
+import com.achep.activedisplay.blacklist.BlacklistEnabler;
+import com.achep.activedisplay.blacklist.options.HideOption;
+import com.achep.activedisplay.blacklist.options.Option;
+import com.achep.activedisplay.blacklist.options.RestrictOption;
+
+/**
+ * Created by Artem on 09.02.14.
+ */
+public class BlacklistAppFragment extends Fragment {
+
+    public static final String ARGS_PACKAGE_NAME = "package_name";
+
+    private static final String SAVE_KEY_PACKAGE_NAME = "package_name";
+    private static final String SAVE_KEY_SCROLL_VIEW_X = "scroll_view_x";
+    private static final String SAVE_KEY_SCROLL_VIEW_Y = "scroll_view_y";
+
+    private BlacklistEnabler mEnabler;
+    private Option[] mOptions;
+
+    // header
+    private ImageView mAppIcon;
+    private TextView mAppName;
+    private TextView mAppPackageName;
+
+    // options
+    private LinearLayout mContainer;
+    private ScrollView mScrollView;
+
+    private String extractPackageName(Bundle args, Bundle savedInstanceState) {
+        String packageName;
+        if (args != null) {
+            packageName = args.getString(ARGS_PACKAGE_NAME);
+            if (packageName != null) return packageName;
+        }
+        if (savedInstanceState != null) {
+            packageName = savedInstanceState.getString(SAVE_KEY_PACKAGE_NAME);
+            if (packageName != null) return packageName;
+        }
+        return "";
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        String packageName = extractPackageName(getArguments(), savedInstanceState);
+        Activity activity = getActivity();
+        ActionBar actionBar = activity.getActionBar();
+
+        actionBar.setDisplayShowCustomEnabled(true);
+        actionBar.setCustomView(R.layout.layout_ab_switch);
+        Switch switch_ = (Switch) actionBar.getCustomView().findViewById(R.id.switch_);
+        mEnabler = new BlacklistEnabler(activity, switch_, packageName);
+        mOptions = new Option[]{
+                new HideOption(activity, new CheckBox(activity), mEnabler),
+                new RestrictOption(activity, new CheckBox(activity), mEnabler)
+        };
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+        outState.putString(SAVE_KEY_PACKAGE_NAME, mEnabler.getAppConfig().packageName);
+        outState.putInt(SAVE_KEY_SCROLL_VIEW_X, mScrollView.getScrollX());
+        outState.putInt(SAVE_KEY_SCROLL_VIEW_Y, mScrollView.getScrollY());
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        mEnabler.resume();
+        for (Option option : mOptions) {
+            option.resume();
+        }
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        mEnabler.pause();
+        for (Option option : mOptions) {
+            option.pause();
+        }
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        View view = inflater.inflate(R.layout.fragment_blacklist_app_config, container, false);
+        assert view != null;
+
+        // Hide switch from the header
+        mAppIcon = (ImageView) view.findViewById(R.id.icon);
+        mAppName = (TextView) view.findViewById(R.id.title);
+        mAppPackageName = (TextView) view.findViewById(R.id.summary);
+
+        // Options list
+        mScrollView = (ScrollView) view.findViewById(R.id.scrollview);
+        mContainer = (LinearLayout) view.findViewById(R.id.container);
+        buildOptionsList();
+
+        if (savedInstanceState != null) {
+
+            // Restore scroll position
+            final int scrollX = savedInstanceState.getInt(SAVE_KEY_SCROLL_VIEW_X);
+            final int scrollY = savedInstanceState.getInt(SAVE_KEY_SCROLL_VIEW_Y);
+            mScrollView.post(new Runnable() {
+                @Override
+                public void run() {
+                    mScrollView.scrollTo(scrollX, scrollY);
+                }
+            });
+        }
+
+        displayApp(mEnabler.getAppConfig().packageName);
+        return view;
+    }
+
+    private void buildOptionsList() {
+        mContainer.removeAllViews();
+
+        LayoutInflater inflater = getActivity().getLayoutInflater();
+        for (Option option : mOptions) {
+            View view = inflater.inflate(R.layout.preference_blacklist_app_config, mContainer, false);
+
+            ImageView icon = (ImageView) view.findViewById(R.id.icon);
+            TextView title = (TextView) view.findViewById(android.R.id.title);
+            TextView summary = (TextView) view.findViewById(android.R.id.summary);
+
+            icon.setImageDrawable(option.icon);
+            title.setText(option.title);
+            summary.setText(option.summary);
+
+            final CheckBox checkBox = (CheckBox) view.findViewById(R.id.checkbox);
+            option.setCompoundButton(checkBox);
+            view.setOnClickListener(new View.OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    checkBox.toggle();
+                }
+            });
+
+            mContainer.addView(view);
+        }
+    }
+
+    public void displayApp(String packageName) {
+        mEnabler.setPackageName(packageName);
+        mScrollView.scrollTo(0, 0);
+
+        // Update header
+        final PackageManager pm = getActivity().getPackageManager();
+        try {
+            ApplicationInfo ai = pm.getApplicationInfo(packageName, 0);
+
+            mAppIcon.setImageDrawable(pm.getApplicationIcon(ai));
+            mAppName.setText(pm.getApplicationLabel(ai));
+            mAppPackageName.setText(packageName);
+        } catch (PackageManager.NameNotFoundException e) {
+            mAppName.setText("Name not found");
+        }
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/options/HideOption.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/options/HideOption.java
new file mode 100644
index 00000000..5c45f1ab
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/options/HideOption.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.blacklist.options;
+
+import android.content.Context;
+import android.widget.CompoundButton;
+
+import com.achep.activedisplay.Operator;
+import com.achep.activedisplay.R;
+import com.achep.activedisplay.blacklist.AppConfig;
+import com.achep.activedisplay.blacklist.BlacklistEnabler;
+
+/**
+ * Created by Artem on 28.02.14.
+ */
+public class HideOption extends Option {
+
+    public HideOption(Context context, CompoundButton cb, BlacklistEnabler enabler) {
+        super(context, cb, enabler,
+                context.getResources().getDrawable(R.drawable.ic_settings_hide_notifications),
+                context.getResources().getString(R.string.blacklist_app_hide_title),
+                context.getResources().getString(R.string.blacklist_app_hide_summary));
+    }
+
+    @Override
+    public boolean[] extractVariable(AppConfig config) {
+        return config.hidden;
+    }
+
+    @Override
+    public boolean isChanged(int diff) {
+        return Operator.bitandCompare(diff, AppConfig.DIFF_HIDDEN);
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/options/Option.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/options/Option.java
new file mode 100644
index 00000000..814900ea
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/options/Option.java
@@ -0,0 +1,133 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.blacklist.options;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.widget.CompoundButton;
+
+import com.achep.activedisplay.blacklist.AppConfig;
+import com.achep.activedisplay.blacklist.Blacklist;
+import com.achep.activedisplay.blacklist.BlacklistEnabler;
+
+/**
+ * Created by Artem on 27.02.14.
+ */
+public abstract class Option extends Blacklist.OnBlacklistChangedListener implements
+        CompoundButton.OnCheckedChangeListener {
+
+    private final Context mContext;
+    private final Blacklist mBlacklist;
+    private final BlacklistEnabler mBlacklistEnabler;
+
+    private CompoundButton mCompoundButton;
+    private boolean mBroadcasting;
+    private boolean mResumed;
+
+    // ui
+    public Drawable icon;
+    public CharSequence title;
+    public CharSequence summary;
+
+    public Option(Context context, CompoundButton cb, BlacklistEnabler enabler,
+                  Drawable icon,
+                  CharSequence title,
+                  CharSequence summary) {
+        this.icon = icon;
+        this.title = title;
+        this.summary = summary;
+
+        mContext = context;
+        mCompoundButton = cb;
+        mBlacklist = Blacklist.getInstance(context);
+        mBlacklistEnabler = enabler;
+    }
+
+    public abstract boolean[] extractVariable(AppConfig config);
+
+    public abstract boolean isChanged(int diff);
+
+    /**
+     * Sets up listeners and updates the current state.
+     * Make sure that you'll call {@link #pause()} later!
+     */
+    public void resume() {
+        if (mResumed) {
+            return;
+        }
+
+        mResumed = true;
+        mBlacklistEnabler.addOnAppConfigChangedListener(this);
+        mCompoundButton.setOnCheckedChangeListener(this);
+        onBlacklistChanged(mBlacklistEnabler.getAppConfig(), null, -1);
+    }
+
+    public void pause() {
+        if (!mResumed) {
+            return;
+        }
+
+        mResumed = false;
+        mBlacklistEnabler.removeOnAppConfigChangedListener(this);
+        mCompoundButton.setOnCheckedChangeListener(null);
+    }
+
+    public void setCompoundButton(CompoundButton cb) {
+        if (mCompoundButton == cb) {
+            return;
+        }
+
+        boolean checked = cb.isChecked();
+
+        mCompoundButton.setOnCheckedChangeListener(null);
+        mCompoundButton = cb;
+        mCompoundButton.setOnCheckedChangeListener(this);
+        setChecked(checked);
+    }
+
+    private void setChecked(boolean checked) {
+        mBroadcasting = true;
+        mCompoundButton.setChecked(checked);
+        mBroadcasting = false;
+    }
+
+    @Override
+    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+        if (mBroadcasting) {
+            return;
+        }
+
+        AppConfig config = mBlacklistEnabler.getAppConfig();
+        extractVariable(config)[0] = isChecked;
+
+        // Clone current state cause it can be changed after.
+        mBlacklist.saveAppConfig(mContext, config, mBlacklistEnabler);
+    }
+
+    // //////////////////////////////////////////
+    // ///////// -- BLACKLIST CORE -- ///////////
+    // //////////////////////////////////////////
+
+    @Override
+    public void onBlacklistChanged(AppConfig configNew, AppConfig configOld, int diff) {
+        if (diff == -1 || isChanged(diff)) {
+            setChecked(extractVariable(configNew)[0]);
+        }
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/options/RestrictOption.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/options/RestrictOption.java
new file mode 100644
index 00000000..6cb69e44
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/blacklist/options/RestrictOption.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.blacklist.options;
+
+import android.content.Context;
+import android.widget.CompoundButton;
+
+import com.achep.activedisplay.Operator;
+import com.achep.activedisplay.R;
+import com.achep.activedisplay.blacklist.AppConfig;
+import com.achep.activedisplay.blacklist.BlacklistEnabler;
+
+/**
+ * Created by Artem on 28.02.14.
+ */
+public class RestrictOption extends Option {
+
+    public RestrictOption(Context context, CompoundButton cb, BlacklistEnabler enabler) {
+        super(context, cb, enabler,
+                context.getResources().getDrawable(R.drawable.ic_blacklist_sleep_mode),
+                context.getResources().getString(R.string.blacklist_app_restricted_title),
+                context.getResources().getString(R.string.blacklist_app_restricted_summary));
+    }
+
+    @Override
+    public boolean[] extractVariable(AppConfig config) {
+        return config.restricted;
+    }
+
+    @Override
+    public boolean isChanged(int diff) {
+        return Operator.bitandCompare(diff, AppConfig.DIFF_RESTRICTED);
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/cryptocoin/Bitcoin.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/cryptocoin/Bitcoin.java
index e7ce8460..4b351fb2 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/cryptocoin/Bitcoin.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/cryptocoin/Bitcoin.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/cryptocoin/Coin.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/cryptocoin/Coin.java
index 79d6a71b..67170a51 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/cryptocoin/Coin.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/cryptocoin/Coin.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/AboutDialog.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/AboutDialog.java
index ba098ae6..7de7efeb 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/AboutDialog.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/AboutDialog.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -23,16 +23,13 @@ import android.app.DialogFragment;
 import android.content.Context;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
-import android.graphics.drawable.Drawable;
+import android.content.res.Resources;
 import android.os.Bundle;
 import android.text.Html;
-import android.text.method.LinkMovementMethod;
-import android.view.LayoutInflater;
-import android.widget.TextView;
 
 import com.achep.activedisplay.DialogHelper;
+import com.achep.activedisplay.Project;
 import com.achep.activedisplay.R;
-import com.achep.activedisplay.utils.ViewUtils;
 
 /**
  * Created by Artem on 30.01.14.
@@ -41,11 +38,9 @@ public class AboutDialog extends DialogFragment {
 
     private static final String VERSION_UNAVAILABLE = "N/A";
 
-    @Override
-    public Dialog onCreateDialog(Bundle savedInstanceState) {
-
-        PackageManager pm = getActivity().getPackageManager();
-        String packageName = getActivity().getPackageName();
+    static CharSequence getVersionTitle(Context context) {
+        PackageManager pm = context.getPackageManager();
+        String packageName = context.getPackageName();
         String versionName;
         try {
             PackageInfo info = pm.getPackageInfo(packageName, 0);
@@ -54,23 +49,23 @@ public class AboutDialog extends DialogFragment {
             versionName = VERSION_UNAVAILABLE;
         }
 
-        Drawable icon = getResources().getDrawable(R.mipmap.ic_launcher);
-        CharSequence title = Html.fromHtml(getString(R.string.about_title,
-                getString(R.string.app_name), versionName));
-        CharSequence message = Html.fromHtml(getString(R.string.about_message));
+        if (Project.DEBUG) versionName += "-dev";
 
-        // Setting up message
-        LayoutInflater inflater = (LayoutInflater) getActivity()
-                .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-        TextView messageTextView = (TextView) inflater.inflate(R.layout.layout_dialog_message, null);
-        messageTextView.setMovementMethod(new LinkMovementMethod());
-        ViewUtils.safelySetText(messageTextView, message);
+        Resources res = context.getResources();
+        return Html.fromHtml(
+                res.getString(R.string.about_title,
+                        res.getString(R.string.app_name), versionName)
+        );
+    }
 
+    @SuppressWarnings("ConstantConditions")
+    @Override
+    public Dialog onCreateDialog(Bundle savedInstanceState) {
         return new DialogHelper.Builder(getActivity())
-                .setIcon(icon)
-                .setTitle(title)
-                .setView(messageTextView)
-                .createAlertDialogBuilder()
+                .setIcon(R.mipmap.ic_launcher)
+                .setTitle(getVersionTitle(getActivity()))
+                .setMessage(Html.fromHtml(getString(R.string.about_message)))
+                .wrap()
                 .setPositiveButton(R.string.close, null)
                 .create();
     }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/BlacklistFragment.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/BlacklistFragment.java
deleted file mode 100644
index 67398d89..00000000
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/BlacklistFragment.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.activedisplay.fragments;
-
-import android.app.ListFragment;
-import android.content.Context;
-import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageManager;
-import android.os.Bundle;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ArrayAdapter;
-import android.widget.ImageView;
-import android.widget.TextView;
-
-import com.achep.activedisplay.R;
-
-/**
- * Created by Artem on 09.02.14.
- */
-public class BlacklistFragment extends ListFragment {
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-    }
-
-    private static class Package {
-
-        private String packageName;
-        private ApplicationInfo info;
-
-        public Package(String packageName, ApplicationInfo info) {
-            this.packageName = packageName;
-            this.info = info;
-        }
-    }
-
-    private static class PackageAdapter extends ArrayAdapter<Package> {
-
-        private final Context mContext;
-        private final Package[] mPackages;
-        private final PackageManager mPackageManager;
-
-        public PackageAdapter(Context context, Package[] packages) {
-            super(context, R.layout.list_blacklist_item, packages);
-            this.mContext = context;
-            this.mPackages = packages;
-
-            mPackageManager = context.getPackageManager();
-        }
-
-        static class ViewHolder {
-            public ImageView imageView;
-            public TextView textView;
-        }
-
-        @Override
-        public View getView(int position, View convertView, ViewGroup parent) {
-
-            ViewHolder holder;
-            View rowView = convertView;
-            if (rowView == null) {
-                LayoutInflater inflater = (LayoutInflater) mContext
-                        .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-                rowView = inflater.inflate(R.layout.list_blacklist_item, null, true);
-
-                holder = new ViewHolder();
-                holder.imageView = (ImageView) rowView.findViewById(R.id.icon);
-                holder.textView = (TextView) rowView.findViewById(R.id.title);
-
-                rowView.setTag(holder);
-            } else {
-                holder = (ViewHolder) rowView.getTag();
-            }
-
-            Package pkg = mPackages[position];
-            if (pkg.info != null) {
-                holder.textView.setText(pkg.info.name);
-                holder.imageView.setImageDrawable(pkg.info.loadIcon(mPackageManager));
-            } else {
-                holder.textView.setText(pkg.packageName);
-            }
-
-            return rowView;
-        }
-    }
-
-}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/DonateDialog.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/DonateDialog.java
index 8f1d685f..c27c0dbc 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/DonateDialog.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/DonateDialog.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -25,30 +25,27 @@ import android.app.DialogFragment;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.content.Intent;
-import android.graphics.drawable.Drawable;
 import android.net.Uri;
 import android.os.Bundle;
 import android.text.Html;
-import android.text.method.LinkMovementMethod;
-import android.view.LayoutInflater;
-import android.widget.TextView;
 
 import com.achep.activedisplay.DialogHelper;
 import com.achep.activedisplay.R;
 import com.achep.activedisplay.cryptocoin.Bitcoin;
 import com.achep.activedisplay.cryptocoin.Coin;
-import com.achep.activedisplay.utils.ViewUtils;
-
-import java.util.List;
+import com.achep.activedisplay.utils.IntentUtils;
 
 /**
  * Donation dialog fragment.
  * <p/>
  * Provides an description of cryptocoin and ability
- * to donate.
+ * to donate via any cryptocoin or PayPal.
  */
 public class DonateDialog extends DialogFragment {
 
+    private static final String PAYPAL_DONATION_URL =
+            "http://goo.gl/UrecGo"; // shortened link to be able to get some stats
+
     private static class OnClickIntentLauncher implements DialogInterface.OnClickListener {
 
         private final Context mContext;
@@ -61,66 +58,60 @@ public class DonateDialog extends DialogFragment {
 
         @Override
         public void onClick(DialogInterface dialogInterface, int i) {
-            try {
+            if (IntentUtils.hasActivityForThat(mContext, mIntent)) {
                 mContext.startActivity(mIntent);
-            } catch (android.content.ActivityNotFoundException ex) {
+            } else {
                 // TODO: Show toast message
-                ex.printStackTrace();
             }
         }
     }
 
+    @SuppressWarnings("ConstantConditions")
     @Override
     public Dialog onCreateDialog(Bundle savedInstanceState) {
         Coin coin = new Bitcoin();
-
         Activity activity = getActivity();
-        assert activity != null;
 
-        Drawable icon = getResources().getDrawable(coin.getIconResource());
-        CharSequence title = getString(R.string.donate_title);
-        CharSequence message = Html.fromHtml(getString(R.string.donate_message,
+        CharSequence messageText = Html.fromHtml(getString(R.string.donate_message,
                 getString(R.string.app_name),
                 coin.getBrowseUri().toString(),
                 coin.getWikiUri().toString(),
                 getString(coin.getNameResource())));
-
-        LayoutInflater inflater = (LayoutInflater) activity
-                .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-        TextView messageTextView = (TextView) inflater.inflate(R.layout.layout_dialog_message, null);
-        assert messageTextView != null;
-
-        // Setting up message
-        messageTextView.setMovementMethod(new LinkMovementMethod());
-        ViewUtils.safelySetText(messageTextView, message);
+        OnClickIntentLauncher payPalClick = createBrowserClicker(Uri.parse(PAYPAL_DONATION_URL));
 
         AlertDialog.Builder builder = new DialogHelper.Builder(getActivity())
-                .setIcon(icon)
-                .setTitle(title)
-                .setView(messageTextView)
-                .createAlertDialogBuilder()
-                .setNegativeButton(R.string.close, null);
+                .setIcon(coin.getIconResource())
+                .setTitle(R.string.donate_title)
+                .setMessage(messageText)
+                .wrap()
+                .setNegativeButton(R.string.close, null)
+                .setNeutralButton(R.string.donate_use_paypal, payPalClick);
 
         final Intent paymentIntent = Coin.getPaymentIntent(coin);
-        @SuppressWarnings("ConstantConditions")
-        final List apps = activity.getPackageManager().queryIntentActivities(paymentIntent, 0);
-
-        if (apps != null && apps.size() > 0) {
+        if (IntentUtils.hasActivityForThat(activity, paymentIntent)) {
 
-            // If user has any coin's wallet installed
-            // slap him with a large "Donate" button.
-            builder.setPositiveButton(R.string.donate,
-                    new OnClickIntentLauncher(getActivity(), paymentIntent));
+            // There's a wallet installed so show donation button
+            // to make the process faster.
+            builder.setPositiveButton(R.string.donate, createClicker(paymentIntent));
         } else {
-            Uri howtoUri = coin.getHowToUri();
-            if (howtoUri != null) {
-                Intent howtoIntent = new Intent(Intent.ACTION_VIEW, howtoUri);
-                builder.setPositiveButton(R.string.donate_how_to,
-                        new OnClickIntentLauncher(getActivity(), howtoIntent));
+
+            // Show tutorial button if link is present because user
+            // probably doesn't know about cryptocoins.
+            Uri howToUri = coin.getHowToUri();
+            if (howToUri != null) {
+                builder.setPositiveButton(R.string.donate_how_to, createBrowserClicker(howToUri));
             }
         }
 
         return builder.create();
     }
 
+    private OnClickIntentLauncher createClicker(Intent intent) {
+        return new OnClickIntentLauncher(getActivity(), intent);
+    }
+
+    private OnClickIntentLauncher createBrowserClicker(Uri uri) {
+        return createClicker(new Intent(Intent.ACTION_VIEW, uri));
+    }
+
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/FeedbackDialog.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/FeedbackDialog.java
index 1e341e7b..b97d452b 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/FeedbackDialog.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/FeedbackDialog.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -22,61 +22,126 @@ import android.app.Activity;
 import android.app.AlertDialog;
 import android.app.Dialog;
 import android.app.DialogFragment;
+import android.content.ContentProvider;
+import android.content.ContentValues;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.content.Intent;
 import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
-import android.graphics.drawable.Drawable;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.net.Uri;
 import android.os.Build;
 import android.os.Bundle;
+import android.os.ParcelFileDescriptor;
+import android.provider.OpenableColumns;
+import android.util.Log;
 import android.view.LayoutInflater;
 import android.view.View;
+import android.widget.AdapterView;
 import android.widget.Button;
+import android.widget.CheckBox;
+import android.widget.CompoundButton;
 import android.widget.EditText;
 import android.widget.Spinner;
-import android.widget.Toast;
 
 import com.achep.activedisplay.DialogHelper;
 import com.achep.activedisplay.Project;
 import com.achep.activedisplay.R;
+import com.achep.activedisplay.utils.FileUtils;
+import com.achep.activedisplay.utils.IntentUtils;
+import com.achep.activedisplay.utils.ToastUtils;
+import com.achep.activedisplay.utils.ViewUtils;
+
+import java.io.BufferedReader;
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+import java.io.OutputStreamWriter;
+import java.text.SimpleDateFormat;
+import java.util.Date;
+import java.util.List;
+import java.util.Locale;
+import java.util.TimeZone;
 
 /**
- * Donation dialog fragment.
+ * Feedback dialog fragment.
  * <p/>
- * Provides an UI for sending bugs & suggestions to my email.
+ * Provides an UI for sending bugs & suggestions on my email.
  */
 public class FeedbackDialog extends DialogFragment {
 
+    private static final String TAG = "FeedbackDialog";
+
+    private Spinner mSpinner;
+    private EditText mEditText;
+    private CheckBox mAttachLogCheckBox;
+
+    private boolean mTriedToSendShortMessage;
+
+    private boolean mBroadcasting;
+
     @Override
     public Dialog onCreateDialog(Bundle savedInstanceState) {
         Activity activity = getActivity();
         assert activity != null;
 
-    //    activity.startService(new Intent(activity, BreathingService.class));
-
-        Drawable icon = getResources().getDrawable(R.drawable.ic_mail);
-        CharSequence title = getString(R.string.feedback_title);
-
         LayoutInflater inflater = (LayoutInflater) activity
                 .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-        View root = inflater.inflate(R.layout.layout_dialog_feedback, null);
+        View root = inflater.inflate(R.layout.fragment_dialog_feedback, null);
         assert root != null;
 
-        final Spinner spinner = (Spinner) root.findViewById(R.id.type);
-        final EditText editText = (EditText) root.findViewById(R.id.message);
+        mSpinner = (Spinner) root.findViewById(R.id.type);
+        mSpinner.setOnItemSelectedListener(new AdapterView.OnItemSelectedListener() {
+            @Override
+            public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
+                ViewUtils.setVisible(mAttachLogCheckBox, position == 0);
+            }
+
+            @Override
+            public void onNothingSelected(AdapterView<?> parent) {
+                ViewUtils.setVisible(mAttachLogCheckBox, false);
+            }
+        });
+        mEditText = (EditText) root.findViewById(R.id.message);
+        mAttachLogCheckBox = (CheckBox) root.findViewById(R.id.checkbox);
+        mAttachLogCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
+            @Override
+            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+                if (mBroadcasting || !isChecked) {
+                    return;
+                }
+
+                CharSequence messageText = getString(R.string.feedback_attach_log_description);
+                new DialogHelper.Builder(getActivity())
+                        .setMessage(messageText)
+                        .wrap()
+                        .setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {
+                            @Override
+                            public void onClick(DialogInterface dialog, int which) {
+                                mBroadcasting = true;
+                                mAttachLogCheckBox.setChecked(false);
+                                mBroadcasting = false;
+                            }
+                        })
+                        .setPositiveButton(android.R.string.ok, null)
+                        .create()
+                        .show();
+            }
+        });
+
         final AlertDialog alertDialog = new DialogHelper.Builder(getActivity())
-                .setIcon(icon)
-                .setTitle(title)
+                .setIcon(getResources().getDrawable(R.drawable.ic_mail))
+                .setTitle(getString(R.string.feedback))
                 .setView(root)
-                .createAlertDialogBuilder()
+                .wrap()
                 .setNegativeButton(android.R.string.cancel, null)
                 .setPositiveButton(R.string.feedback_send, null)
                 .create();
-
-        assert spinner != null;
-        assert editText != null;
-
         alertDialog.setOnShowListener(new DialogInterface.OnShowListener() {
 
             @Override
@@ -87,47 +152,7 @@ public class FeedbackDialog extends DialogFragment {
 
                     @Override
                     public void onClick(View view) {
-                        CharSequence message = editText.getText();
-
-                        // Check for message's length
-                        int messageMinLength = getResources() .getInteger(
-                                R.integer.config_feedback_minMessageLength);
-                        if (message == null || message.length() < messageMinLength) {
-                            Toast.makeText(getActivity(), getString(
-                                    R.string.feedback_error_msg_too_short,
-                                    messageMinLength), Toast.LENGTH_SHORT)
-                                    .show();
-                            return; // Don't dismiss dialog
-                        }
-
-                        PackageInfo pi;
-                        try {
-                            //noinspection ConstantConditions
-                            pi = getActivity().getPackageManager().getPackageInfo(
-                                    Project.getPackageName(getActivity()), 0);
-                        } catch (PackageManager.NameNotFoundException e) {
-                            e.printStackTrace();
-                            return;
-                        }
-
-                        CharSequence title = createTitleMessage(pi, spinner.getSelectedItemPosition());
-                        CharSequence body = createBodyMessage(pi, message);
-                        Intent intent = new Intent(Intent.ACTION_SEND)
-                                .setType("message/rfc822")
-                                .putExtra(Intent.EXTRA_EMAIL, new String[] {Project.EMAIL})
-                                .putExtra(Intent.EXTRA_SUBJECT, title)
-                                .putExtra(Intent.EXTRA_TEXT, body);
-
-                        try {
-                            startActivity(Intent.createChooser(intent,
-                                    getString(R.string.feedback_send_via)));
-
-                            // Dismiss current dialog once everything is ok
-                            alertDialog.dismiss();
-                        } catch (android.content.ActivityNotFoundException ex) {
-                            Toast.makeText(getActivity(), getString(R.string.feedback_error_no_app),
-                                    Toast.LENGTH_LONG).show();
-                        }
+                        send();
                     }
                 });
             }
@@ -136,35 +161,199 @@ public class FeedbackDialog extends DialogFragment {
         return alertDialog;
     }
 
-    private CharSequence createTitleMessage(PackageInfo pi, int type) {
-        CharSequence typeName;
-        switch (type) {
-            case 0:
-                typeName = "bug";
-                break;
-            case 1:
-                typeName = "suggestion";
-                break;
-            case 2:
-                typeName = "other";
-                break;
-            default:
-                typeName = "unknown";
-                break;
+    private void send() {
+        Activity activity = getActivity();
+        CharSequence message = mEditText.getText();
+
+        // Check for message's length
+        int messageMinLength = getResources().getInteger(
+                R.integer.config_feedback_minMessageLength);
+        if (message == null || (message.length() < messageMinLength && !Project.DEBUG)) {
+            String toastText = getString(R.string.feedback_error_msg_too_short, messageMinLength);
+            ToastUtils.showShort(activity, toastText);
+            mTriedToSendShortMessage = true;
+            return;
+        }
+
+        PackageInfo pi;
+        try {
+            pi = activity
+                    .getPackageManager()
+                    .getPackageInfo(Project.getPackageName(activity), 0);
+        } catch (PackageManager.NameNotFoundException e) {
+            Log.wtf(TAG, "Failed to find my PackageInfo.");
+            return;
+        }
+
+        CharSequence title = createTitleMessage(activity, mSpinner.getSelectedItemPosition());
+        CharSequence body = createBodyMessage(pi, message);
+        Intent intent = new Intent()
+                .putExtra(Intent.EXTRA_EMAIL, new String[]{Project.EMAIL})
+                .putExtra(Intent.EXTRA_SUBJECT, title)
+                .putExtra(Intent.EXTRA_TEXT, body);
+
+        if (mAttachLogCheckBox.getVisibility() == View.VISIBLE && mAttachLogCheckBox.isChecked()) {
+            attachLog(intent);
+            intent.setAction(Intent.ACTION_SEND);
+            intent.setType("message/rfc822");
+        } else {
+            intent.setAction(Intent.ACTION_SENDTO);
+            intent.setData(Uri.parse("mailto:")); // only email apps should handle it
+        }
+
+        if (IntentUtils.hasActivityForThat(activity, intent)) {
+            startActivity(intent);
+            dismiss();
+        } else {
+            String toastText = getString(R.string.feedback_error_no_app);
+            ToastUtils.showLong(activity, toastText);
         }
-        return "Feedback: " + typeName + ", " + pi.packageName;
+    }
+
+    private CharSequence createTitleMessage(Context context, int type) {
+        CharSequence[] typeNames = new CharSequence[]{"bug", "suggestion", "other"};
+        return AboutDialog.getVersionTitle(context) + ": " + typeNames[type];
     }
 
     private CharSequence createBodyMessage(PackageInfo pi, CharSequence msg) {
         return "" + msg +
                 '\n' +
                 '\n' +
-                "- - - - - - - - - - - - -" + '\n' +
+                "- - - - - - - - - - device details - - - - - - - - -" + '\n' +
                 "app_version:" + pi.versionName + '(' + pi.versionCode + ")\n" +
                 "android_version:" + Build.VERSION.RELEASE + '(' + Build.VERSION.SDK_INT + ")\n" +
                 "build_display:" + Build.DISPLAY + '\n' +
                 "build_brand:" + Build.BRAND + '\n' +
-                "build_model:" + Build.MODEL;
+                "build_model:" + Build.MODEL + '\n' +
+                "had_short_message:" + mTriedToSendShortMessage + '\n' +
+                "language:" + Locale.getDefault().getLanguage();
+    }
+
+    private void attachLog(Intent intent) {
+        Context context = getActivity();
+        StringBuilder log = new StringBuilder();
+
+        try {
+            // Read logs from runtime
+            String[] logcatCmd = new String[]{"logcat", "-v", "threadtime", "-d"};
+            Process process = Runtime.getRuntime().exec(logcatCmd);
+            BufferedReader bufferedReader = new BufferedReader(
+                    new InputStreamReader(process.getInputStream()));
+            String line;
+            while ((line = bufferedReader.readLine()) != null) {
+                log.append(line);
+                log.append('\n');
+            }
+
+            // Write everything to a file
+            File cacheDir = context.getCacheDir();
+            if (cacheDir == null) {
+                throw new IOException("Cache directory inaccessible");
+            }
+            File logsDir = new File(cacheDir, LogAttachmentProvider.DIRECTORY);
+            FileUtils.deleteRecursive(logsDir);
+            logsDir.mkdirs();
+
+            SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd_HHmm");
+            sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
+            String fileName = "AcDisplay_log_" + sdf.format(new Date()) + ".txt";
+            File logFile = new File(logsDir, fileName);
+
+            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(
+                    new FileOutputStream(logFile)));
+            writer.write(log.toString());
+            writer.close();
+
+            // Put extra stream to intent
+            Uri uri = Uri.parse("content://" + LogAttachmentProvider.AUTHORITY + "/" + fileName);
+            intent.putExtra(Intent.EXTRA_STREAM, uri);
+        } catch (IOException e) {
+            ToastUtils.showShort(context, getString(R.string.feedback_error_accessing_log));
+        }
     }
 
+    public static class LogAttachmentProvider extends ContentProvider {
+
+        private static final String TAG = "LogAttachmentProvider";
+
+        static final String AUTHORITY = "com.achep.activedisplay.logs";
+        static final String DIRECTORY = "logs";
+
+        private static final String COLUMN_DATA = "_data";
+
+        @Override
+        public boolean onCreate() {
+            return true;
+        }
+
+        @Override
+        public Cursor query(Uri uri, String[] projection, String selection,
+                            String[] selectionArgs, String orderBy) {
+            List<String> pathSegments = uri.getPathSegments();
+            String fileName = pathSegments.get(0);
+            File logFile = getContext().getCacheDir();
+            if (logFile == null) {
+                Log.e(TAG, "No cache dir.");
+                return null;
+            }
+
+            logFile = new File(new File(logFile, DIRECTORY), fileName);
+            if (!logFile.exists()) {
+                Log.e(TAG, "Requested log file doesn't exist.");
+                return null;
+            }
+
+            if (projection == null) {
+                projection = new String[]{
+                        COLUMN_DATA,
+                        OpenableColumns.DISPLAY_NAME,
+                        OpenableColumns.SIZE,
+                };
+            }
+
+            MatrixCursor matrixCursor = new MatrixCursor(projection, 1);
+            Object[] row = new Object[projection.length];
+            for (int col = 0; col < projection.length; col++) {
+                switch (projection[col]) {
+                    case COLUMN_DATA:
+                        row[col] = logFile.getAbsolutePath();
+                        break;
+                    case OpenableColumns.DISPLAY_NAME:
+                        row[col] = fileName;
+                        break;
+                    case OpenableColumns.SIZE:
+                        row[col] = logFile.length();
+                        break;
+                }
+            }
+            matrixCursor.addRow(row);
+            return matrixCursor;
+        }
+
+        @Override
+        public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
+            return openFileHelper(uri, "r");
+        }
+
+        @Override
+        public String getType(Uri uri) {
+            return "text/plain";
+        }
+
+        @Override
+        public Uri insert(Uri uri, ContentValues values) {
+            throw new UnsupportedOperationException("insert not supported");
+        }
+
+        @Override
+        public int delete(Uri uri, String selection, String[] selectionArgs) {
+            throw new UnsupportedOperationException("delete not supported");
+        }
+
+        @Override
+        public int update(Uri uri, ContentValues contentValues, String selection,
+                          String[] selectionArgs) {
+            throw new UnsupportedOperationException("update not supported");
+        }
+    }
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/HelpDialog.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/HelpDialog.java
new file mode 100644
index 00000000..0fc9dc34
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/HelpDialog.java
@@ -0,0 +1,44 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.fragments;
+
+import android.app.Dialog;
+import android.app.DialogFragment;
+import android.os.Bundle;
+import android.text.Html;
+
+import com.achep.activedisplay.DialogHelper;
+import com.achep.activedisplay.R;
+
+/**
+ * Created by Artem on 30.01.14.
+ */
+public class HelpDialog extends DialogFragment {
+
+    @Override
+    public Dialog onCreateDialog(Bundle savedInstanceState) {
+        return new DialogHelper.Builder(getActivity())
+                .setIcon(R.drawable.ic_help)
+                .setTitle(R.string.help)
+                .setMessage(Html.fromHtml(getString(R.string.help_message)))
+                .wrap()
+                .setPositiveButton(R.string.close, null)
+                .create();
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/activedisplay/ActiveDisplayFragment.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/activedisplay/ActiveDisplayFragment.java
index 31f00b6b..7967f1b4 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/activedisplay/ActiveDisplayFragment.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/activedisplay/ActiveDisplayFragment.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -20,11 +20,11 @@ package com.achep.activedisplay.fragments.activedisplay;
 
 import android.app.Activity;
 import android.content.Context;
+import android.content.Intent;
 import android.content.SharedPreferences;
 import android.os.Bundle;
 import android.preference.PreferenceManager;
 import android.view.LayoutInflater;
-import android.view.Menu;
 import android.view.MenuItem;
 import android.view.MotionEvent;
 import android.view.View;
@@ -34,15 +34,15 @@ import android.widget.ImageView;
 import android.widget.PopupMenu;
 import android.widget.RadioGroup;
 import android.widget.TextClock;
+import android.widget.TextView;
 
 import com.achep.activedisplay.Keys;
 import com.achep.activedisplay.Operator;
-import com.achep.activedisplay.Project;
 import com.achep.activedisplay.R;
 import com.achep.activedisplay.Timeout;
-import com.achep.activedisplay.blacklist.SharedList;
-import com.achep.activedisplay.fragments.MyFragment;
-import com.achep.activedisplay.notifications.Blacklist;
+import com.achep.activedisplay.activities.KeyguardActivity;
+import com.achep.activedisplay.blacklist.Blacklist;
+import com.achep.activedisplay.blacklist.activities.BlacklistActivity;
 import com.achep.activedisplay.notifications.NotificationPresenter;
 import com.achep.activedisplay.notifications.OpenStatusBarNotification;
 import com.achep.activedisplay.utils.ViewUtils;
@@ -61,12 +61,12 @@ public class ActiveDisplayFragment extends MyFragment implements
 
     private static final int REFRESH_UI_NOTIFICATION = 1;
     private static final int REFRESH_UI_NOTIFICATION_LIST = 2;
-    private static final int REFRESH_UI_NOTIFICATION_STATE_INDICATOR = 4;
-    private static final int REFRESH_UI_TIMEOUT = 8;
+    private static final int REFRESH_UI_TIMEOUT = 4;
 
     private TextClock mDateView;
     private HoloCircularProgressBar mHandleTimeoutProgressBar;
     private ImageView mHandleIconImageView;
+    private TextView mNotificationNumber;
     private RadioGroup mRadioGroup;
 
     private View mOverflowView;
@@ -77,7 +77,6 @@ public class ActiveDisplayFragment extends MyFragment implements
     private NotificationPresenter mPresenter;
     private NotificationListener mNotificationListener = new NotificationListener();
     private Blacklist mBlacklist;
-    private BlacklistListener mBlacklistListener = new BlacklistListener();
     private boolean mBroadcasting;
 
     private Timeout mTimeout;
@@ -100,11 +99,9 @@ public class ActiveDisplayFragment extends MyFragment implements
 
         mBlacklist = Blacklist.getInstance(activity);
         mPresenter = NotificationPresenter.getInstance(getActivity());
-        synchronized (mPresenter.monitor) {
-            mPresenter.addOnNotificationListChangedListener(mNotificationListener);
-            updateNotification();
-            updateNotificationList();
-        }
+        mPresenter.addOnNotificationListChangedListener(mNotificationListener);
+        updateNotification();
+        updateNotificationList();
 
         setTimeoutPresenter(mTimeout); // may be null
 
@@ -115,12 +112,8 @@ public class ActiveDisplayFragment extends MyFragment implements
 
     @Override
     public void onDestroyView() {
-        mBlacklist.removeOnSharedListChangedListener(mBlacklistListener);
-
-        synchronized (mPresenter.monitor) {
-            mPresenter.removeOnNotificationListChangedListener(mNotificationListener);
-            mPresenter = null;
-        }
+        //mBlacklist.removeOnSharedListChangedListener(mBlacklistListener);
+        mPresenter.removeOnNotificationListChangedListener(mNotificationListener);
         if (mTimeout != null) {
             mTimeout.removeListener(this);
             mTimeout = null;
@@ -147,8 +140,6 @@ public class ActiveDisplayFragment extends MyFragment implements
             updateNotification();
         if (Operator.bitandCompare(v, REFRESH_UI_NOTIFICATION_LIST))
             updateNotificationList();
-        if (Operator.bitandCompare(v, REFRESH_UI_NOTIFICATION_STATE_INDICATOR))
-            updateNotificationStateIndicator();
         if (Operator.bitandCompare(v, REFRESH_UI_TIMEOUT))
             refreshTimeout();
     }
@@ -165,18 +156,14 @@ public class ActiveDisplayFragment extends MyFragment implements
                 boolean handled = true;
                 switch (event.getAction()) {
                     case MotionEvent.ACTION_DOWN:
-                        synchronized (mPresenter.monitor) {
 
-                            // Keep current selected notification to display
-                            // for all the time of this touch gesture.
-                            mPresenter.lockSelectedNotification();
-                        }
+                        // Keep current selected notification to display
+                        // for all the time of this touch gesture.
+                        mPresenter.lockSelectedNotification();
                         break;
                     case MotionEvent.ACTION_CANCEL:
                     case MotionEvent.ACTION_UP:
-                        synchronized (mPresenter.monitor) {
-                            mPresenter.unlockSelectedNotification();
-                        }
+                        mPresenter.unlockSelectedNotification();
                         break;
                     default:
                         handled = false;
@@ -189,6 +176,7 @@ public class ActiveDisplayFragment extends MyFragment implements
         // handle
         mHandleTimeoutProgressBar = (HoloCircularProgressBar) handle.findViewById(R.id.timeout);
         mHandleIconImageView = (ImageView) handle.findViewById(R.id.icon);
+        mNotificationNumber = (TextView) handle.findViewById(R.id.count);
 
         // multi notifications
         mRadioGroup = (RadioGroup) root.findViewById(R.id.radios);
@@ -208,27 +196,18 @@ public class ActiveDisplayFragment extends MyFragment implements
             @SuppressWarnings("ConstantConditions")
             @Override
             public void onClick(View view) {
-                synchronized (mPresenter.monitor) {
-                    OpenStatusBarNotification notification = mPresenter.getSelectedNotification();
-                    if (notification == null) {
-                        return;
-                    }
-
-                    Context context = view.getContext();
-                    mPopupMenu = new PopupMenu(context, view);
-                    mPopupMenu.inflate(R.menu.ad_overflow);
+                OpenStatusBarNotification notification = mPresenter.getSelectedNotification();
+                if (notification == null) {
+                    return;
+                }
 
-                    // Manage available options.
-                    // TODO: Move it to OpenNotification class (?)
-                    Menu m = mPopupMenu.getMenu();
-                    boolean isBlacklisted = notification.isBlacklisted(context);
-                    m.findItem(R.id.action_add_to_blacklist).setVisible(!isBlacklisted);
-                    m.findItem(R.id.action_remove_from_blacklist).setVisible(isBlacklisted);
+                Context context = view.getContext();
+                mPopupMenu = new PopupMenu(context, view);
+                mPopupMenu.inflate(R.menu.ad_overflow);
 
-                    mPopupMenu.setOnDismissListener(onDismissListener);
-                    mPopupMenu.setOnMenuItemClickListener(onMenuItemClickListener);
-                    mPopupMenu.show();
-                }
+                mPopupMenu.setOnDismissListener(onDismissListener);
+                mPopupMenu.setOnMenuItemClickListener(onMenuItemClickListener);
+                mPopupMenu.show();
             }
         });
 
@@ -238,54 +217,44 @@ public class ActiveDisplayFragment extends MyFragment implements
     }
 
     private void updateNotification() {
-        if (tryPutTodo(REFRESH_UI_NOTIFICATION)) return;
+        if (tryPutTodo(REFRESH_UI_NOTIFICATION)) {
+            return;
+        }
 
-        updateNotificationStateIndicator();
+        final OpenStatusBarNotification notification = mPresenter.getSelectedNotification();
+        final boolean emptyNotification = notification == null;
 
-        synchronized (mPresenter.monitor) {
-            OpenStatusBarNotification notification = mPresenter.getSelectedNotification();
-            boolean emptyNotification = notification == null;
+        // Update overflow & notification icons
+        ViewUtils.setVisible(mOverflowView, !emptyNotification, View.INVISIBLE);
+        mHandleIconImageView.setImageDrawable(emptyNotification
+                ? getResources().getDrawable(R.drawable.stat_unlock)
+                : notification.getSmallIcon(getActivity()));
 
-            ViewUtils.setVisible(mOverflowView, !emptyNotification && Project.DEBUG, View.INVISIBLE);
-            mHandleIconImageView.setImageDrawable(emptyNotification
-                    ? getResources().getDrawable(R.drawable.stat_unlock)
-                    : notification.getSmallIcon(getActivity()));
-        }
+        // Update notification number
+        final int number = emptyNotification ? 0 : notification.getNotificationData().number;
+        ViewUtils.setVisible(mNotificationNumber, number > 0);
+        mNotificationNumber.setText(Integer.toString(number));
     }
 
-    private void updateNotificationStateIndicator() {
-    /*
-        if (tryPutTodo(REFRESH_UI_NOTIFICATION_STATE_INDICATOR)) return;
-
-        synchronized (mPresenter.monitor) {
-            OpenStatusBarNotification notification = mPresenter.getSelectedNotification();
-            ViewUtils.setVisible(mBlacklistedIndicator,
-                    notification != null && mBlacklist.contains(notification) && Project.DEBUG,
-                    View.GONE);
-        }
-    */
-    }
     private void updateNotificationList() {
         if (tryPutTodo(REFRESH_UI_NOTIFICATION_LIST)) return;
 
-        synchronized (mPresenter.monitor) {
-            boolean visible = Helper.updateNotificationList(mPresenter, mRadioGroup,
-                    R.layout.radio_notification_icon, getActivity().getLayoutInflater());
-            if (!visible) return;
-
-            // Check current notification
-            final int size = mPresenter.getList().size();
-            final OpenStatusBarNotification notification = mPresenter.getSelectedNotification();
-            for (int i = 0; i < size; i++) {
-                NotificationRadioButton nrb = (NotificationRadioButton) mRadioGroup.getChildAt(i);
-
-                assert nrb != null;
-                nrb.setOnCheckedChangeListener(this);
-                if (notification == nrb.getNotification()) {
-                    mBroadcasting = true;
-                    nrb.setChecked(true);
-                    mBroadcasting = false;
-                }
+        boolean visible = Helper.updateNotificationList(mPresenter, mRadioGroup,
+                R.layout.radio_notification_icon, getActivity().getLayoutInflater());
+        if (!visible) return;
+
+        // Check current notification
+        final int size = mPresenter.getList().size();
+        final OpenStatusBarNotification notification = mPresenter.getSelectedNotification();
+        for (int i = 0; i < size; i++) {
+            NotificationRadioButton nrb = (NotificationRadioButton) mRadioGroup.getChildAt(i);
+
+            assert nrb != null;
+            nrb.setOnCheckedChangeListener(this);
+            if (notification == nrb.getNotification()) {
+                mBroadcasting = true;
+                nrb.setChecked(true);
+                mBroadcasting = false;
             }
         }
     }
@@ -297,9 +266,7 @@ public class ActiveDisplayFragment extends MyFragment implements
         }
 
         NotificationRadioButton nrb = (NotificationRadioButton) compoundButton;
-        synchronized (mPresenter.monitor) {
-            mPresenter.setSelectedNotification(nrb.getNotification());
-        }
+        mPresenter.setSelectedNotification(nrb.getNotification());
     }
 
     // //////////////////////////////////////////
@@ -345,61 +312,49 @@ public class ActiveDisplayFragment extends MyFragment implements
     private class NotificationListener extends NotificationPresenter.SimpleOnNotificationListChangedListener {
 
         @Override
-        // running on wrong thread
         public void onNotificationEvent(NotificationPresenter nm,
                                         OpenStatusBarNotification notification,
                                         final int event) {
             super.onNotificationEvent(nm, notification, event);
-            getActivity().runOnUiThread(new Runnable() {
-                @Override
-                public void run() {
-                    switch (event) {
-                        case SELECTED:
-                            updateNotification();
-
-                            if (mPopupMenu != null) {
-                                mPopupMenu.dismiss();
-                            }
-                            break;
-                        default:
-                            updateNotificationList();
-                            break;
-                    }
-                }
-            });
-        }
-    }
+            switch (event) {
+                case SELECTED:
+                    updateNotification();
 
-    private class BlacklistListener implements SharedList.OnSharedListChangedListener<String> {
-
-        @Override
-        // running on ui thread
-        public void onPut(String object) {
-            updateNotificationStateIndicator();
-        }
-
-        @Override
-        // running on ui thread
-        public void onRemoved(String object) {
-            updateNotificationStateIndicator();
+                    if (mPopupMenu != null) {
+                        mPopupMenu.dismiss();
+                    }
+                    break;
+                default:
+                    updateNotificationList();
+                    break;
+            }
         }
     }
 
     private class OverflowClickListener implements PopupMenu.OnMenuItemClickListener {
 
+        private Runnable mLaunchBlacklist = new Runnable() {
+            @Override
+            public void run() {
+                // TODO: Launch notification's app settings
+                startActivity(new Intent(getActivity(), BlacklistActivity.class));
+            }
+        };
+
         @Override
         public boolean onMenuItemClick(MenuItem item) {
-            synchronized (mPresenter.monitor) {
-                switch (item.getItemId()) {
-                    case R.id.action_add_to_blacklist:
-                        mBlacklist.put(getActivity(), mPresenter.getSelectedNotification());
-                        break;
-                    case R.id.action_remove_from_blacklist:
-                        mBlacklist.remove(getActivity(), mPresenter.getSelectedNotification());
-                        break;
-                    default:
-                        return false;
-                }
+            switch (item.getItemId()) {
+                case R.id.action_launch_blacklist:
+                    Activity activity = getActivity();
+                    if (activity instanceof KeyguardActivity) {
+                        KeyguardActivity keyguard = (KeyguardActivity) activity;
+                        keyguard.unlock(mLaunchBlacklist);
+                    } else {
+                        mLaunchBlacklist.run();
+                    }
+                    break;
+                default:
+                    return false;
             }
             return true;
         }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/activedisplay/Helper.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/activedisplay/Helper.java
index 6cf15611..78d5be47 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/activedisplay/Helper.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/activedisplay/Helper.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/MyFragment.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/activedisplay/MyFragment.java
similarity index 77%
rename from project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/MyFragment.java
rename to project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/activedisplay/MyFragment.java
index a1fd0e06..26e7c329 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/MyFragment.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/activedisplay/MyFragment.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -16,14 +16,9 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.activedisplay.fragments;
+package com.achep.activedisplay.fragments.activedisplay;
 
 import android.app.Fragment;
-import android.os.Bundle;
-import android.view.View;
-
-import com.achep.activedisplay.Project;
-import com.achep.activedisplay.utils.LogUtils;
 
 /**
  * Created by Artem on 01.02.14.
@@ -48,8 +43,6 @@ public abstract class MyFragment extends Fragment {
             mTodoOnResumeFragment |= todo;
         } else
             return false;
-        if (Project.DEBUG)
-            LogUtils.e(TAG, "Todo list infos: view_is_null=" + (getView() == null) + " is_paused=" + isResumed());
         return true;
     }
 
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/activedisplay/NotificationFragment.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/activedisplay/NotificationFragment.java
index 4402cf16..714240f0 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/activedisplay/NotificationFragment.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/activedisplay/NotificationFragment.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -31,7 +31,6 @@ import android.widget.TextView;
 
 import com.achep.activedisplay.Operator;
 import com.achep.activedisplay.R;
-import com.achep.activedisplay.fragments.MyFragment;
 import com.achep.activedisplay.notifications.NotificationData;
 import com.achep.activedisplay.notifications.NotificationPresenter;
 import com.achep.activedisplay.notifications.OpenStatusBarNotification;
@@ -57,24 +56,18 @@ public class NotificationFragment extends MyFragment {
 
     private NotificationPresenter mPresenter;
     private NotificationListener mListener = new NotificationListener();
-    private OpenStatusBarNotification mNotification;
 
     @Override
     public void onActivityCreated(Bundle savedInstanceState) {
         super.onActivityCreated(savedInstanceState);
         mPresenter = NotificationPresenter.getInstance(getActivity());
-        synchronized (mPresenter.monitor) {
-            mPresenter.addOnNotificationListChangedListener(mListener);
-            updateNotification();
-        }
+        mPresenter.addOnNotificationListChangedListener(mListener);
+        updateNotification();
     }
 
     @Override
     public void onDestroyView() {
-        synchronized (mPresenter.monitor) {
-            mPresenter.removeOnNotificationListChangedListener(mListener);
-            mPresenter = null;
-        }
+        mPresenter.removeOnNotificationListChangedListener(mListener);
         super.onDestroyView();
     }
 
@@ -112,69 +105,51 @@ public class NotificationFragment extends MyFragment {
             return; // not a good time...
         }
 
-        synchronized (mPresenter.monitor) {
-            mNotification = mPresenter.getSelectedNotification();
+        OpenStatusBarNotification openNotification = mPresenter.getSelectedNotification();
 
-            // Hide everything if notification is null.
-            boolean visible = mNotification != null;
-            for (View view : mHidingViews) // getView().setVisibility(GONE) is incorrect way!
-                ViewUtils.setVisible(view, visible);
-            if (!visible) return;
+        // Hide everything if notification is null.
+        boolean visible = openNotification != null;
+        for (View view : mHidingViews) // Warning: getView().setVisibility(GONE) is a wrong way!
+            ViewUtils.setVisible(view, visible);
 
-            StatusBarNotification notification = mNotification.getStatusBarNotification();
-            NotificationData data = mNotification.getNotificationData();
+        if (!visible) {
+            return;
+        }
 
-            ViewUtils.safelySetText(mTitleTextView, data.titleText);
-            ViewUtils.safelySetText(mMessageTextView, data.getLargeMessage());
-            ViewUtils.safelySetText(mInfoTextView, data.infoText == null ? data.subText : data.infoText);
-            ViewUtils.safelySetText(mCountTextView, data.number > 0 ? Integer.toString(data.number) : null);
+        StatusBarNotification n = openNotification.getStatusBarNotification();
+        NotificationData data = openNotification.getNotificationData();
 
-            mWhenTextView.setText(DateUtils.formatDateTime(getActivity(),
-                    notification.getPostTime(), DateUtils.FORMAT_SHOW_TIME));
+        ViewUtils.safelySetText(mTitleTextView, data.titleText);
+        ViewUtils.safelySetText(mMessageTextView, data.getLargeMessage());
+        ViewUtils.safelySetText(mInfoTextView, data.infoText == null ? data.subText : data.infoText);
+        ViewUtils.safelySetText(mCountTextView, data.number > 0 ? Integer.toString(data.number) : null);
 
-            boolean showSmallIcon = mCountTextView.getVisibility() == View.VISIBLE;
+        mWhenTextView.setText(DateUtils.formatDateTime(getActivity(),
+                n.getPostTime(), DateUtils.FORMAT_SHOW_TIME));
 
-            Drawable drawable = mNotification.getSmallIcon(getActivity());
-            Bitmap bitmap = notification.getNotification().largeIcon;
-            if (bitmap != null) {
-                mIcon.setImageBitmap(bitmap);
-                showSmallIcon = true;
-            } else {
-                mIcon.setImageDrawable(drawable);
-            }
+        boolean showSmallIcon = mCountTextView.getVisibility() == View.VISIBLE;
 
-            if (showSmallIcon) mSmallIcon.setImageDrawable(drawable);
-            ViewUtils.setVisible(mSmallIcon, showSmallIcon);
+        Drawable drawable = openNotification.getSmallIcon(getActivity());
+        Bitmap bitmap = n.getNotification().largeIcon;
+        if (bitmap != null) {
+            mIcon.setImageBitmap(bitmap);
+            showSmallIcon = true;
+        } else {
+            mIcon.setImageDrawable(drawable);
         }
-    }
 
-    /**
-     * Returns the displaying notification.
-     * The return value may differ from {@link NotificationPresenter#getSelectedNotification()}!
-     */
-    public OpenStatusBarNotification getNotification() {
-        return mNotification;
+        if (showSmallIcon) mSmallIcon.setImageDrawable(drawable);
+        ViewUtils.setVisible(mSmallIcon, showSmallIcon);
     }
 
-    // //////////////////////////////////////////
-    // ///////////// -- CLASSES -- //////////////
-    // //////////////////////////////////////////
-
     private class NotificationListener extends NotificationPresenter.SimpleOnNotificationListChangedListener {
 
-        @SuppressWarnings("ConstantConditions")
         @Override
-        // running on wrong thread
         public void onNotificationSelected(final NotificationPresenter nm,
                                            final OpenStatusBarNotification notification,
                                            boolean isChanged) {
             super.onNotificationSelected(nm, notification, isChanged);
-            getActivity().runOnUiThread(new Runnable() {
-                @Override
-                public void run() {
-                    updateNotification();
-                }
-            });
+            updateNotification();
         }
     }
 
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/activedisplay/PreviewFragment.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/activedisplay/PreviewFragment.java
index 1fbea2fd..3196de7f 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/activedisplay/PreviewFragment.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/fragments/activedisplay/PreviewFragment.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -26,7 +26,6 @@ import android.widget.LinearLayout;
 
 import com.achep.activedisplay.Operator;
 import com.achep.activedisplay.R;
-import com.achep.activedisplay.fragments.MyFragment;
 import com.achep.activedisplay.notifications.NotificationPresenter;
 import com.achep.activedisplay.notifications.OpenStatusBarNotification;
 import com.achep.activedisplay.utils.ViewUtils;
@@ -50,54 +49,52 @@ public class PreviewFragment extends MyFragment {
     public void onActivityCreated(Bundle savedInstanceState) {
         super.onActivityCreated(savedInstanceState);
         mPresenter = NotificationPresenter.getInstance(getActivity());
-        synchronized (mPresenter.monitor) {
-            mPresenter.addOnNotificationListChangedListener(mListener);
-            updateNotificationList();
-        }
+        mPresenter.addOnNotificationListChangedListener(mListener);
+        updateNotificationList();
     }
 
     @Override
     public void onDestroyView() {
-        synchronized (mPresenter.monitor) {
-            mPresenter.removeOnNotificationListChangedListener(mListener);
-            mPresenter = null;
-        }
+        mPresenter.removeOnNotificationListChangedListener(mListener);
         super.onDestroyView();
     }
 
     @Override
     protected void handleTodoList(int v) {
-        if (Operator.bitandCompare(v, UPDATE_NOTIFICATION_LIST))
+        if (Operator.bitandCompare(v, UPDATE_NOTIFICATION_LIST)) {
             updateNotificationList();
+        }
     }
 
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
         View view = inflater.inflate(R.layout.fragment_ad_preview_list, container, false);
         assert view != null;
+
         mContainer = (LinearLayout) view.findViewById(R.id.container);
+
         return view;
     }
 
     private void updateNotificationList() {
-        if (tryPutTodo(UPDATE_NOTIFICATION_LIST)) return;
-
-        synchronized (mPresenter.monitor) {
-            //noinspection ConstantConditions
-            boolean visible = Helper.updateNotificationList(mPresenter, mContainer,
-                    R.layout.item_ad_preview, getActivity().getLayoutInflater());
-
-            if (!visible) {
-                return;
-            }
-
-            final int size = mPresenter.getList().size();
-            final OpenStatusBarNotification notification = mPresenter.getSelectedNotification();
-            for (int i = 0; i < size; i++) {
-                NotificationPreviewLayout child = (NotificationPreviewLayout) mContainer.getChildAt(i);
-                assert child != null;
-                ViewUtils.setVisible(child, notification != child.getNotification());
-            }
+        if (tryPutTodo(UPDATE_NOTIFICATION_LIST)) {
+            return; // not a good time...
+        }
+
+        //noinspection ConstantConditions
+        boolean visible = Helper.updateNotificationList(mPresenter, mContainer,
+                R.layout.item_ad_preview, getActivity().getLayoutInflater());
+
+        if (!visible) {
+            return;
+        }
+
+        final int size = mPresenter.getList().size();
+        final OpenStatusBarNotification notification = mPresenter.getSelectedNotification();
+        for (int i = 0; i < size; i++) {
+            NotificationPreviewLayout child = (NotificationPreviewLayout) mContainer.getChildAt(i);
+            assert child != null;
+            ViewUtils.setVisible(child, notification != child.getNotification());
         }
     }
 
@@ -105,39 +102,14 @@ public class PreviewFragment extends MyFragment {
     // ///////////// -- CLASSES -- //////////////
     // //////////////////////////////////////////
 
-    @SuppressWarnings("ConstantConditions")
     private class NotificationListener extends NotificationPresenter.SimpleOnNotificationListChangedListener {
 
         @Override
-        // running on wrong thread
-        public void onNotificationSelected(final NotificationPresenter nm,
-                                           final OpenStatusBarNotification notification,
-                                           boolean isChanged) {
-            super.onNotificationSelected(nm, notification, isChanged);
-            if (!isChanged) {
-                getActivity().runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        updateNotificationList();
-                    }
-                });
-            }
-        }
-
-        @Override
-        // running on wrong thread
         public void onNotificationEvent(NotificationPresenter nm,
                                         OpenStatusBarNotification notification,
                                         int event) {
             super.onNotificationEvent(nm, notification, event);
-            if (event != SELECTED) {
-                getActivity().runOnUiThread(new Runnable() {
-                    @Override
-                    public void run() {
-                        updateNotificationList();
-                    }
-                });
-            }
+            updateNotificationList();
         }
     }
 
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/legacy/MainActivity.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/legacy/MainActivity.java
deleted file mode 100644
index 8b9dce6a..00000000
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/legacy/MainActivity.java
+++ /dev/null
@@ -1,599 +0,0 @@
-/*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.activedisplay.legacy;
-
-public class MainActivity {
-
-}
-/*
-public class MainActivity extends Activity implements
-        NotificationPresenter.OnNotificationListChangedListener,
-        SensorEventListener, CompoundButton.OnCheckedChangeListener {
-
-    private static final String TAG = "ActiveDisplayActivity";
-
-    private static final int SCREEN_OFF_TIMEOUT = 10000; // ms.
-    private static final int SCREEN_OFF_TIMEOUT_SHORT = 6000; // ms.
-    private static final int SCREEN_OFF_TIMEOUT_SUPER_SHORT = 3500; // ms.
-
-    private static final int MSG_TURN_SCREEN_OFF = 1;
-    private static final int MSG_UNLOCK = 2;
-
-    private OpenStatusBarNotification mCurrentNotification;
-    private OpenStatusBarNotification mHandlingNotification;
-
-    private FrameLayout mHandleView;
-    private ImageView mHandleActionIcon;
-    private ImageView mUnlockImageView;
-    private ImageView mLockImageView;
-    private LinearLayout mHandleLayout;
-    private WaveView mWaveView;
-
-    private AnimatorSet mUnlockViewInAnimation;
-    private AnimatorSet mNotificationViewInAnimation;
-    private AnimatorSet mLockViewInAnimation;
-
-    private float mTouchDownX, mTouchDownY;
-
-    private float mNotificationDismissProgress;
-    private SensorManager mSensorManager;
-    private HoloCircularProgressBar mScreenOffProgressBar;
-    private boolean mUnlocking;
-
-    private final Handler mHandler = new Handler() {
-        @Override
-        public void handleMessage(Message msg) {
-            super.handleMessage(msg);
-            switch (msg.what) {
-                case MSG_TURN_SCREEN_OFF:
-                    turnScreenOff();
-                    break;
-                case MSG_UNLOCK:
-                    unlock();
-                    break;
-            }
-        }
-    };
-
-    private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            finish();
-        }
-    };
-    private DebugLayerView mDebugLayerView;
-    private boolean mUpdateWaveViewRequired;
-    private RadioGroup mHandleNotifiesGroup;
-    private boolean mBroadcasting;
-    private NotificationWidget mNotificationWidget;
-
-    private View[] mClickableViews;
-
-    @Override
-    public void onWindowFocusChanged(boolean hasFocus) {
-        super.onWindowFocusChanged(hasFocus);
-        if (hasFocus) {
-            getWindow().addFlags(
-                    WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD
-                            | WindowManager.LayoutParams.FLAG_FULLSCREEN);
-            getWindow().getDecorView().setSystemUiVisibility(
-                    View.SYSTEM_UI_FLAG_LAYOUT_STABLE
-                            | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
-                            | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
-                            | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION
-                            | View.SYSTEM_UI_FLAG_FULLSCREEN
-                            | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY);
-        } else {
-            getWindow().clearFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
-        }
-    }
-
-    private float[] mTouchHyperbola = new float[2];
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        getWindow().addFlags(WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED
-                | WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON
-                | WindowManager.LayoutParams.FLAG_IGNORE_CHEEK_PRESSES);
-
-        setContentView(R.layout.activity_main);
-
-        if (Project.DEBUG) {
-            mDebugLayerView = (DebugLayerView) findViewById(R.id.debug);
-        }
-
-        mHandleLayout = (LinearLayout) findViewById(R.id.panel);
-        mHandleNotifiesGroup = (RadioGroup) mHandleLayout.findViewById(R.id.radios);
-        mHandleView = (FrameLayout) mHandleLayout.findViewById(R.id.handle);
-        mHandleActionIcon = (ImageView) mHandleView.findViewById(R.id.icon);
-        mScreenOffProgressBar = (HoloCircularProgressBar) mHandleView.findViewById(R.id.timeout);
-        mHandleView.setOnTouchListener(new View.OnTouchListener() {
-            @Override
-            public boolean onTouch(View view, MotionEvent event) {
-                View decorView = getWindow().getDecorView();
-
-                // TODO: That doesn't look like the best place for this.
-                if (mUpdateWaveViewRequired) {
-                    mUpdateWaveViewRequired = false;
-                    mWaveView.init(ViewUtils.getBottom(mCurrentNotification == null
-                            ? mLockImageView
-                            : mNotificationWidget, decorView),
-                            ViewUtils.getBottom(view, decorView) + view.getHeight() / 2,
-                            ViewUtils.getTop(mUnlockImageView, decorView),
-                            view.getHeight() / 2);
-                }
-
-                final float localX = event.getX() - view.getWidth() / 2;
-                final float localY = event.getY() - view.getHeight() / 2;
-                final float x = event.getRawX();
-                final float y = event.getRawY();
-
-                switch_case:
-                switch (event.getAction()) {
-                    case MotionEvent.ACTION_DOWN:
-                        mNotificationDismissProgress = 0f;
-                        mHandlingNotification = mCurrentNotification;
-
-                        mHandleLayout.setVisibility(View.INVISIBLE);
-                        mUnlockImageView.setVisibility(View.VISIBLE);
-
-                        if (mHandlingNotification == null) {
-                            mLockImageView.setVisibility(View.VISIBLE);
-                            mLockViewInAnimation.start();
-                        } else {
-                            mNotificationWidget.setVisibility(View.VISIBLE);
-                            mNotificationViewInAnimation.start();
-                        }
-
-                        mUnlockViewInAnimation.start();
-                        mWaveView.animateExpand();
-
-                        // Remove screen off timeout.
-                        cancelTurningScreenOff();
-
-                        mTouchDownX = localX;
-                        mTouchDownY = localY;
-                        break;
-
-                    case MotionEvent.ACTION_MOVE:
-                        mTouchHyperbola[0] = localX - mTouchDownX;
-                        mTouchHyperbola[1] = localY - mTouchDownY;
-                        CoordsUtils.putIntoHyperbola(mTouchHyperbola, 100);
-
-                        if (Project.DEBUG) {
-                            mDebugLayerView.setTouchPoint(x, y);
-                            mDebugLayerView.setHyperbolaPoint(
-                                    mTouchHyperbola[0] - localX + x,
-                                    mTouchHyperbola[1] - localY + y);
-                            mDebugLayerView.postInvalidateOnAnimation();
-                        }
-
-                        for (View v : mClickableViews) {
-                            v.setPressed(ViewUtils.isTouchPointInView(v, x, y, decorView));
-                        }
-
-                        mNotificationDismissProgress =
-                                Math.abs(mTouchHyperbola[0]) * 2 / mNotificationWidget.getWidth();
-
-                        mNotificationWidget.setAlpha(
-                                MathUtils.range(1 - mNotificationDismissProgress, 0, 1));
-                        mNotificationWidget.setTranslationX(mNotificationDismissProgress
-                                * MathUtils.charge(mTouchHyperbola[0])
-                                * mNotificationWidget.getWidth() / 2);
-                        break;
-                    case MotionEvent.ACTION_CANCEL:
-                    case MotionEvent.ACTION_UP:
-                        for (View v : mClickableViews) {
-                            if (ViewUtils.isTouchPointInView(v, x, y, decorView)
-                                    && (mHandlingNotification != null || v != mNotificationWidget)) {
-                                v.performClick();
-                                v.setPressed(false);
-                                break switch_case;
-                            }
-                        }
-
-                        if (mHandlingNotification != null && mNotificationDismissProgress > 0.6) {
-                            NotificationHelper.dismissNotification(mHandlingNotification.getStatusBarNotification());
-                        }
-
-                        mNotificationWidget.setVisibility(View.INVISIBLE);
-                        mHandleLayout.setVisibility(View.VISIBLE);
-                        mUnlockImageView.setVisibility(View.INVISIBLE);
-                        mLockImageView.setVisibility(View.INVISIBLE);
-
-                        mUnlockViewInAnimation.cancel();
-                        mNotificationViewInAnimation.cancel();
-                        mWaveView.cancelExpand();
-
-                        setScreenOffTimeout(SCREEN_OFF_TIMEOUT);
-                        break;
-                    default:
-                        return false;
-                }
-                return true;
-            }
-        });
-        mWaveView = (WaveView) findViewById(R.id.wave);
-
-        // Setup content views
-        mNotificationWidget = (NotificationWidget) findViewById(R.id.notification);
-        mUnlockImageView = (ImageView) findViewById(R.id.unlock);
-        mLockImageView = (ImageView) findViewById(R.id.lock);
-
-        // Load animations
-        mUnlockViewInAnimation = (AnimatorSet) AnimatorInflater.loadAnimator(this, R.anim.card_flip_in_from_bottom);
-        assert mUnlockViewInAnimation != null;
-        mUnlockViewInAnimation.setTarget(mUnlockImageView);
-        mLockViewInAnimation = (AnimatorSet) AnimatorInflater.loadAnimator(this, R.anim.card_flip_in_from_top);
-        assert mLockViewInAnimation != null;
-        mLockViewInAnimation.setTarget(mLockImageView);
-        mNotificationViewInAnimation = (AnimatorSet) AnimatorInflater.loadAnimator(this, R.anim.card_flip_in_from_top);
-        assert mNotificationViewInAnimation != null;
-        mNotificationViewInAnimation.setTarget(mNotificationWidget);
-
-        // Setup active notification
-        ArrayList<OpenStatusBarNotification> n = NotificationPresenter.getInstance().getList();
-        final int size = n.size();
-        if (size != 0) mCurrentNotification = n.get(size - 1);
-        refreshUiCurrentNotification();
-        refreshUiNotificationsList();
-
-        mClickableViews = new View[]{mLockImageView, mUnlockImageView, mNotificationWidget};
-
-        // Register listeners
-        NotificationPresenter.getInstance().addOnNotificationListChangedListener(this);
-        registerReceiver(mReceiver, new IntentFilter(Intent.ACTION_SCREEN_OFF));
-        mSensorManager = (SensorManager) getSystemService(Context.SENSOR_SERVICE);
-    }
-
-    private void refreshUiNotificationsList() {
-        ArrayList<OpenStatusBarNotification> list = NotificationPresenter.getInstance().getList();
-        if (list.size() > 1) {
-            mHandleNotifiesGroup.setVisibility(View.VISIBLE);
-
-            final int notifiesCount = list.size();
-            final int viewsCount = mHandleNotifiesGroup.getChildCount();
-            final boolean[] notifiesUsage = new boolean[notifiesCount];
-            final boolean[] viewsUsage = new boolean[viewsCount];
-
-            // Does not need an update
-            for (int i = 0; i < viewsCount; i++) {
-                NotificationRadioButton nrb = (NotificationRadioButton) mHandleNotifiesGroup.getChildAt(i);
-                OpenStatusBarNotification target = nrb.getNotification();
-                for (int j = 0; j < notifiesCount; j++) {
-                    OpenStatusBarNotification n = list.get(j);
-                    if (target == n || NotificationUtils
-                            .equals(target, n)) {
-
-                        notifiesUsage[j] = true;
-                        viewsUsage[i] = true;
-
-                        if (target != n) {
-                            nrb.setNotification(n);
-                        }
-                        break;
-                    }
-                }
-            }
-
-            // Re-use free views and remove redundant views.
-            boolean removeAllAfter = false;
-            for (int i = 0; i < viewsCount; i++) {
-                if (viewsUsage[i] & (viewsUsage[i] = true))
-                    continue;
-
-                if (removeAllAfter) {
-                    mHandleNotifiesGroup.removeViewAt(i);
-                    continue;
-                }
-
-                NotificationRadioButton nrb = (NotificationRadioButton) mHandleNotifiesGroup.getChildAt(i);
-                for (int j = 0; j < notifiesCount; j++) {
-                    if (j == notifiesCount - 1)
-                        removeAllAfter = true;
-                    if (notifiesUsage[j] & (notifiesUsage[j] = true))
-                        continue;
-
-                    nrb.setNotification(list.get(j));
-                }
-            }
-
-            // Create new views
-            for (int i = 0; i < notifiesCount; i++) {
-                if (notifiesUsage[i])
-                    continue;
-
-                NotificationRadioButton nrb = (NotificationRadioButton) getLayoutInflater().inflate(
-                        R.layout.radio_notification_icon, mHandleNotifiesGroup, false);
-                nrb.setNotification(list.get(i));
-                nrb.setOnCheckedChangeListener(this);
-                mHandleNotifiesGroup.addView(nrb, i);
-            }
-
-            // Check current notification
-            for (int i = 0; i < notifiesCount; i++) {
-                NotificationRadioButton nrb = (NotificationRadioButton) mHandleNotifiesGroup.getChildAt(i);
-                if (mCurrentNotification == nrb.getNotification()) {
-                    mBroadcasting = true;
-                    nrb.setChecked(true);
-                    mBroadcasting = false;
-                    break;
-                }
-            }
-        } else {
-            mHandleNotifiesGroup.setVisibility(View.GONE);
-        }
-        mUpdateWaveViewRequired = true;
-    }
-
-    private void refreshUiCurrentNotification() {
-        mNotificationWidget.setNotification(mCurrentNotification);
-
-        Drawable notifyIcon = mCurrentNotification == null
-                ? getResources().getDrawable(R.drawable.stat_unlock)
-                : mCurrentNotification.getSmallIcon(this);
-        mHandleActionIcon.setImageDrawable(notifyIcon);
-        mUpdateWaveViewRequired = true;
-    }
-
-    @Override
-    public void onCheckedChanged(CompoundButton compoundButton, boolean checked) {
-        if (!checked || mBroadcasting) {
-            return;
-        }
-
-        setScreenOffTimeout(SCREEN_OFF_TIMEOUT, true);
-
-        NotificationRadioButton nrb = (NotificationRadioButton) compoundButton;
-        mCurrentNotification = nrb.getNotification();
-        refreshUiCurrentNotification();
-    }
-
-    private void turnScreenOff() {
-        removeMessageFromHandler(MSG_TURN_SCREEN_OFF);
-
-        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
-        if (pm.isScreenOn()) {
-            DevicePolicyManager dpm = (DevicePolicyManager)
-                    getSystemService(Context.DEVICE_POLICY_SERVICE);
-            dpm.lockNow();
-        }
-    }
-
-    private void unlock() {
-        removeMessageFromHandler(MSG_UNLOCK | MSG_TURN_SCREEN_OFF);
-
-        mUnlocking = true;
-        finish();
-        overridePendingTransition(0, 0);
-    }
-
-    private void removeMessageFromHandler(int what) {
-        if ((what & MSG_UNLOCK) == MSG_UNLOCK)
-            mHandler.removeMessages(MSG_UNLOCK);
-        if ((what & MSG_TURN_SCREEN_OFF) == MSG_TURN_SCREEN_OFF)
-            mHandler.removeMessages(MSG_TURN_SCREEN_OFF);
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-        if (mSensorManager != null)
-            mSensorManager.registerListener(this,
-                    mSensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY),
-                    SensorManager.SENSOR_DELAY_NORMAL);
-
-        setScreenOffTimeout(SCREEN_OFF_TIMEOUT, true);
-    }
-
-    @Override
-    protected void onPause() {
-        super.onPause();
-        removeMessageFromHandler(MSG_UNLOCK | MSG_TURN_SCREEN_OFF);
-
-        if (mSensorManager != null)
-            mSensorManager.unregisterListener(this);
-        if (!mUnlocking) {
-
-            // Cause i can't disable navigation bar's
-            // buttons - the only thing i can to do is to turn
-            // screen off to prevent random calls and porn.
-            PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
-            if (pm.isScreenOn()) {
-                mHandler.sendEmptyMessageDelayed(MSG_TURN_SCREEN_OFF, 500);
-            }
-        }
-    }
-
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-        unregisterReceiver(mReceiver);
-        NotificationPresenter.getInstance().removeOnNotificationListChangedListener(this);
-    }
-
-    @Override
-    public void onConfigurationChanged(Configuration newConfig) {
-        super.onConfigurationChanged(newConfig);
-        mUpdateWaveViewRequired = true;
-    }
-
-    // //////////////////////////////////////////
-    // ////////// -- NOTIFICATION -- ////////////
-    // //////////////////////////////////////////
-
-    @Override
-    public void onNotificationInitialized(NotificationPresenter nm) {
-
-    }
-
-    @Override
-    // running on wrong ui thread
-    public void onNotificationPosted(final NotificationPresenter nm, final OpenStatusBarNotification notification) {
-        runOnUiThread(new Runnable() {
-            @Override
-            public void run() {
-                if (mCurrentNotification == null) {
-                    mCurrentNotification = notification;
-                    refreshUiCurrentNotification();
-                }
-
-                refreshUiNotificationsList();
-            }
-        });
-    }
-
-    @Override
-    //  running on wrong ui thread
-    public void onNotificationChanged(final NotificationPresenter nm, final OpenStatusBarNotification notification) {
-        runOnUiThread(new Runnable() {
-            @Override
-            public void run() {
-                if (NotificationUtils.equals(mCurrentNotification.getStatusBarNotification(),
-                        notification.getStatusBarNotification())) {
-                    mCurrentNotification = notification;
-                    refreshUiCurrentNotification();
-                }
-                refreshUiNotificationsList();
-            }
-        });
-    }
-
-    @Override
-    //  running on wrong ui thread
-    public void onNotificationRemoved(final NotificationPresenter nm, final OpenStatusBarNotification notification) {
-        runOnUiThread(new Runnable() {
-            @Override
-            public void run() {
-                final int size = nm.getList().size();
-                if (NotificationUtils.equals(mCurrentNotification, notification)) {
-                    mCurrentNotification = size > 0 ? nm.getList().get(size - 1) : null;
-                    refreshUiCurrentNotification();
-                }
-
-                if (size > 0) {
-                    refreshUiNotificationsList();
-                } else {
-                    refreshUiCurrentNotification();
-                    // turnScreenOff();
-                }
-
-                setScreenOffTimeout(mScreenOffTimeout, true);
-            }
-        });
-    }
-
-    @Override
-    public void onNotificationSelected(NotificationPresenter nm, OpenStatusBarNotification notification, boolean isChanged) {
-
-    }
-
-    // //////////////////////////////////////////
-    // /////// -- ADDITIONAL SECURITY -- ////////
-    // //////////////////////////////////////////
-
-    private long mScreenOffAtTime = Long.MAX_VALUE;
-    private int mScreenOffTimeout;
-
-    private void setScreenOffTimeout(int delayMillis) {
-        setScreenOffTimeout(delayMillis, false);
-    }
-
-    private void setScreenOffTimeout(int delayMillis, boolean resetOld) {
-        if (resetOld) cancelTurningScreenOff();
-
-        // Notify the user that timeout have changed.
-        long now = SystemClock.uptimeMillis();
-        if (delayMillis + now < mScreenOffAtTime) {
-            mHandler.sendEmptyMessageDelayed(MSG_TURN_SCREEN_OFF, delayMillis);
-            mScreenOffProgressBar.animateProgressFromOne(delayMillis);
-            mScreenOffTimeout = delayMillis;
-            mScreenOffAtTime = now + mScreenOffTimeout;
-        }
-    }
-
-    private void cancelTurningScreenOff() {
-        removeMessageFromHandler(MSG_TURN_SCREEN_OFF);
-        mScreenOffProgressBar.cancelAnimateProgress();
-        mScreenOffAtTime = Long.MAX_VALUE;
-    }
-
-    @Override
-    public void onSensorChanged(SensorEvent event) {
-        switch (event.sensor.getType()) {
-            case Sensor.TYPE_PROXIMITY:
-
-                // This is only needed to determinate
-                // proximity level on activity's start.
-                // I don't think that reacting on this
-                // event after can be useful.
-                mSensorManager.unregisterListener(this);
-                mSensorManager = null;
-
-                float distance = event.values[0];
-                if (distance < 2 ) {
-
-                    // Well, the device is probably somewhere in bag.
-                    setScreenOffTimeout(SCREEN_OFF_TIMEOUT_SUPER_SHORT);
-
-                    if (Project.DEBUG)
-                        Log.d(TAG, "Device is in pocket[proximity=" + distance
-                                + "cm] --> delayed turning screen off.");
-                }
-                break;
-        }
-    }
-
-    @Override
-    public boolean onTouchEvent(MotionEvent event) {
-        switch (event.getAction()) {
-            case MotionEvent.ACTION_DOWN:
-                setScreenOffTimeout(SCREEN_OFF_TIMEOUT_SHORT);
-                break;
-            default:
-                return super.onTouchEvent(event);
-        }
-        return true;
-    }
-
-    @Override
-    public void onAccuracyChanged(Sensor sensor, int i) {  }
-
-    @Override
-    public void onBackPressed() {   }
-
-    // //////////////////////////////////////////
-    // ////////// -- CLICK EVENTS -- ////////////
-    // //////////////////////////////////////////
-
-    public void onClickLockView(View view) {
-        turnScreenOff();
-    }
-
-    public void onClickUnlockView(View view) {
-        unlock();
-    }
-
-    public void onClickNotificationView(View view) {
-        unlock();
-        NotificationHelper.startContentIntent(mCurrentNotification.getStatusBarNotification());
-    }
-}
-*/
\ No newline at end of file
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/Blacklist.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/Blacklist.java
deleted file mode 100644
index 86dbd67c..00000000
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/Blacklist.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.activedisplay.notifications;
-
-import android.content.Context;
-
-import com.achep.activedisplay.Project;
-import com.achep.activedisplay.blacklist.SharedList;
-import com.achep.activedisplay.utils.LogUtils;
-
-import java.lang.ref.SoftReference;
-
-/**
- * Created by Artem on 09.02.14.
- */
-public class Blacklist extends SharedList<String, SharedList.StringSaver> {
-
-    private static SoftReference<Blacklist> sBlacklistSoft;
-
-    public static synchronized Blacklist getInstance(Context context) {
-        Blacklist instance;
-        if (sBlacklistSoft == null || (instance = sBlacklistSoft.get()) == null) {
-            if (Project.DEBUG) LogUtils.track();
-
-            instance = new Blacklist(context);
-            sBlacklistSoft = new SoftReference<>(instance);
-            return instance;
-        }
-        return instance;
-    }
-
-    private Blacklist(Context context) {
-        super(context, StringSaver.class);
-    }
-
-    @Override
-    protected String getPreferencesFileName() {
-        return "blacklist_package";
-    }
-
-    public synchronized void put(Context context, OpenStatusBarNotification notification) {
-        put(context, getPackageName(notification));
-    }
-
-    public synchronized void remove(Context context, OpenStatusBarNotification notification) {
-        remove(context, getPackageName(notification));
-    }
-
-    public synchronized boolean contains(OpenStatusBarNotification notification) {
-        return contains(getPackageName(notification));
-    }
-
-    private String getPackageName(OpenStatusBarNotification notification) {
-        return notification.getStatusBarNotification().getPackageName();
-    }
-
-}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationData.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationData.java
index 55f83409..c6f62586 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationData.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationData.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -18,6 +18,8 @@
  */
 package com.achep.activedisplay.notifications;
 
+import android.app.Notification;
+
 /**
  * Created by Artem on 13.01.14.
  */
@@ -29,8 +31,25 @@ public class NotificationData {
     public CharSequence infoText;
     public CharSequence subText;
     public CharSequence summaryText;
+
+    /**
+     * The number of events that this notification represents. For example, in a new mail
+     * notification, this could be the number of unread messages.
+     * <p/>
+     * The system may or may not use this field to modify the appearance of the notification. For
+     * example, before {@link android.os.Build.VERSION_CODES#HONEYCOMB}, this number was
+     * superimposed over the icon in the status bar. Starting with
+     * {@link android.os.Build.VERSION_CODES#HONEYCOMB}, the template used by
+     * {@link Notification.Builder} has displayed the number in the expanded notification view.
+     * <p/>
+     * If the number is 0 or negative, it is never shown.
+     */
     public int number;
 
+    /**
+     * @return {@link #messageTextLarge large message} if not null,
+     * otherwise returns {@link #messageText short message}.
+     */
     public CharSequence getLargeMessage() {
         return messageTextLarge == null ? messageText : messageTextLarge;
     }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationHandleService.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationHandleService.java
index b81790c1..9cf2f36b 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationHandleService.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationHandleService.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -21,12 +21,13 @@ package com.achep.activedisplay.notifications;
 import android.app.ActivityManager;
 import android.content.Context;
 import android.content.Intent;
+import android.os.Handler;
 import android.os.IBinder;
+import android.os.Looper;
 import android.service.notification.NotificationListenerService;
 import android.service.notification.StatusBarNotification;
 import android.util.Log;
 
-import com.achep.activedisplay.Project;
 import com.achep.activedisplay.utils.LogUtils;
 
 /**
@@ -36,29 +37,27 @@ public class NotificationHandleService extends NotificationListenerService {
 
     private static final String TAG = "NotificationHandleService";
 
-    public static NotificationHandleService notificationHandleService;
-    public static boolean isNotificationAccessEnabled = false;
+    public static NotificationHandleService sService;
+    public static boolean isNotificationAccessEnabled;
 
     @Override
     public IBinder onBind(Intent intent) {
-        IBinder binder = super.onBind(intent);
+        isNotificationAccessEnabled = true;
+        sService = this;
 
-        if (Project.DEBUG) LogUtils.track();
-        NotificationPresenter.getInstance(this).tryStartInitProcess(this);
+        LogUtils.track();
+        NotificationPresenter
+                .getInstance(this)
+                .tryStartInitProcess(this);
 
-        isNotificationAccessEnabled = true;
-        notificationHandleService = this;
-        return binder;
+        return super.onBind(intent);
     }
 
     @Override
     public boolean onUnbind(Intent intent) {
         boolean unbind = super.onUnbind(intent);
-
-        if (Project.DEBUG) LogUtils.track();
-
         isNotificationAccessEnabled = false;
-        notificationHandleService = null;
+        sService = null;
         return unbind;
     }
 
@@ -73,23 +72,37 @@ public class NotificationHandleService extends NotificationListenerService {
     }
 
     @Override
-    public void onNotificationPosted(StatusBarNotification statusBarNotification) {
-        try {
-            NotificationPresenter.getInstance(this).postNotification(this, statusBarNotification);
-        } catch (Exception e) { // don't die
-            Log.wtf(TAG, "The world crashed. The details below:");
-            e.printStackTrace();
-        }
+    public void onNotificationPosted(final StatusBarNotification statusBarNotification) {
+        handleOnNotificationChanged(statusBarNotification, getActiveNotifications(), true);
     }
 
     @Override
-    public void onNotificationRemoved(StatusBarNotification statusBarNotification) {
-        try {
-            NotificationPresenter.getInstance(this).removeNotification(this, statusBarNotification);
-        } catch (Exception e) { // don't die
-            Log.wtf(TAG, "The world crashed. The details below:");
-            e.printStackTrace();
-        }
+    public void onNotificationRemoved(final StatusBarNotification statusBarNotification) {
+        handleOnNotificationChanged(statusBarNotification, getActiveNotifications(), false);
+    }
+
+    private void handleOnNotificationChanged(final StatusBarNotification statusBarNotification,
+                                             final StatusBarNotification[] activeNotifications,
+                                             final boolean post) {
+        new Handler(Looper.getMainLooper()).post(new Runnable() {
+            @Override
+            public void run() {
+                Context context = NotificationHandleService.this;
+                NotificationPresenter np = NotificationPresenter.getInstance(context);
+
+                try {
+                    np.tryInit(context, statusBarNotification, activeNotifications);
+                    if (post) {
+                        np.postNotification(context, statusBarNotification);
+                    } else {
+                        np.removeNotification(context, statusBarNotification);
+                    }
+                } catch (Exception e) { // don't die
+                    Log.wtf(TAG, "The world of pink unicorns just crashed:");
+                    e.printStackTrace();
+                }
+            }
+        });
     }
 
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationHelper.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationHelper.java
index 29555739..4b57d8f2 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationHelper.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationHelper.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -18,9 +18,11 @@
  */
 package com.achep.activedisplay.notifications;
 
+import android.app.Notification;
 import android.app.PendingIntent;
 import android.service.notification.StatusBarNotification;
 
+import com.achep.activedisplay.Operator;
 import com.achep.activedisplay.utils.PendingIntentUtils;
 
 /**
@@ -35,13 +37,19 @@ public class NotificationHelper {
     public static boolean startContentIntent(StatusBarNotification notification) {
         if (notification != null) {
             PendingIntent pi = notification.getNotification().contentIntent;
-            return PendingIntentUtils.sendPendingIntent(pi);
+            boolean successful = PendingIntentUtils.sendPendingIntent(pi);
+            if (successful && Operator.bitandCompare(
+                    notification.getNotification().flags,
+                    Notification.FLAG_AUTO_CANCEL)) {
+                dismissNotification(notification);
+            }
+            return successful;
         }
         return false;
     }
 
     public static void dismissNotification(StatusBarNotification notification) {
-        NotificationHandleService nhs = NotificationHandleService.notificationHandleService;
+        NotificationHandleService nhs = NotificationHandleService.sService;
         if (nhs != null) {
             nhs.cancelNotification(
                     notification.getPackageName(),
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationList.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationList.java
new file mode 100644
index 00000000..174ca4f9
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationList.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.notifications;
+
+import android.util.Log;
+
+import java.util.ArrayList;
+
+/**
+ * Created by Artem on 20.02.14.
+ */
+class NotificationList {
+
+    private static final String TAG = "NotificationList";
+
+    private ArrayList<OpenStatusBarNotification> mList;
+
+    private Callback mCallback;
+
+    public interface Callback {
+        public int onNotificationAdded(OpenStatusBarNotification n);
+
+        public int onNotificationChanged(OpenStatusBarNotification n);
+
+        public int onNotificationRemoved(OpenStatusBarNotification n);
+    }
+
+    public NotificationList(Callback callback) {
+        mCallback = callback;
+        mList = new ArrayList<>(10);
+    }
+
+    public void setCallback(Callback callback) {
+        mCallback = callback;
+    }
+
+    public int pushOrRemove(OpenStatusBarNotification n, boolean push, boolean silently) {
+        Callback cb = mCallback;
+        if (silently) mCallback = null;
+        final int callback = push ? push(n) : remove(n);
+        if (silently) mCallback = cb;
+        return callback;
+    }
+
+    /**
+     * Replace or add notification to the list.
+     *
+     * @return {@link Callback#onNotificationAdded(OpenStatusBarNotification n)} or
+     * {@link Callback#onNotificationChanged(OpenStatusBarNotification n)}
+     */
+    public int push(OpenStatusBarNotification n) {
+        int index = indexOf(n);
+        if (index < 0) {
+            mList.add(n);
+            if (mCallback != null) return mCallback.onNotificationAdded(n);
+        } else {
+            mList.remove(index);
+            mList.add(index, n);
+            if (mCallback != null) return mCallback.onNotificationChanged(n);
+        }
+        return 0;
+    }
+
+    public int remove(OpenStatusBarNotification n) {
+        int index = indexOf(n);
+        if (index >= 0) {
+            mList.remove(index);
+            if (mCallback != null) return mCallback.onNotificationRemoved(n);
+        }
+        return 0;
+    }
+
+    public ArrayList<OpenStatusBarNotification> list() {
+        return mList;
+    }
+
+    public int indexOf(OpenStatusBarNotification n) {
+        for (int i = mList.size() - 1; i >= 0; i--) {
+            OpenStatusBarNotification o = mList.get(i);
+            if (o == null || o.getStatusBarNotification() == null) {
+                Log.wtf(TAG, "Null-notification found!");
+            } else if (NotificationUtils.equals(n, o)) {
+                return i;
+            }
+        }
+        return -1;
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationPresenter.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationPresenter.java
index 51e40ae7..df4a0a9a 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationPresenter.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationPresenter.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -22,20 +22,21 @@ import android.app.Notification;
 import android.app.NotificationManager;
 import android.content.Context;
 import android.content.Intent;
-import android.os.PowerManager;
 import android.os.SystemClock;
 import android.service.notification.StatusBarNotification;
-import android.telephony.TelephonyManager;
 import android.util.Log;
 
+import com.achep.activedisplay.ActiveDisplayPresenter;
 import com.achep.activedisplay.Config;
+import com.achep.activedisplay.InactiveHoursHelper;
 import com.achep.activedisplay.NotificationIds;
 import com.achep.activedisplay.Operator;
 import com.achep.activedisplay.Project;
 import com.achep.activedisplay.R;
-import com.achep.activedisplay.activities.ActiveDisplayActivity;
+import com.achep.activedisplay.activemode.ProximitySensor;
+import com.achep.activedisplay.blacklist.AppConfig;
+import com.achep.activedisplay.blacklist.Blacklist;
 import com.achep.activedisplay.services.SendNotificationService;
-import com.achep.activedisplay.utils.LogUtils;
 import com.achep.activedisplay.utils.PowerUtils;
 
 import java.util.ArrayList;
@@ -43,13 +44,10 @@ import java.util.ArrayList;
 /**
  * Created by Artem on 27.12.13.
  */
-public class NotificationPresenter {
+public class NotificationPresenter implements NotificationList.Callback {
 
     private static final String TAG = "NotificationPresenter";
 
-    private static final String COM_ANDROID_PROVIDERS_DOWNLOADS = "com.android.providers.downloads";
-    private static final String COM_ANDROID_SETTINGS = "com.android.settings";
-
     private static final int UI_MULTI_START_TIMEOUT = 1000; // ms.
 
     private static final int INITIALIZING_PROCESS_NONE = 0;
@@ -57,27 +55,55 @@ public class NotificationPresenter {
     private static final int INITIALIZING_PROCESS_DONE = 2;
 
     private static NotificationPresenter sNotificationPresenter;
-    public final Object monitor = new Object();
 
-    private final ArrayList<OpenStatusBarNotification> mList = new ArrayList<>();
-    private final ArrayList<OpenStatusBarNotification> mNotificationList = new ArrayList<>();
     private final ArrayList<OnNotificationListChangedListener> mListeners = new ArrayList<>();
 
     private long mUIStartTime;
     private int mInitProcess = INITIALIZING_PROCESS_NONE;
 
+    private NotificationList mGList = new NotificationList(null);
+    private NotificationList mLList = new NotificationList(this);
     private OpenStatusBarNotification mSelectedNotification;
     private OpenStatusBarNotification mFutureSelectedNotification;
     private boolean mSelectedNotificationLocked;
 
     private final Config mConfig;
+    private final Blacklist mBlacklist;
 
     private class ConfigListener implements Config.OnConfigChangedListener {
 
         @Override
         public void onConfigChanged(Config config, String key, Object value) {
             if (key.equals(Config.KEY_LOW_PRIORITY_NOTIFICATIONS)) {
-                rebuildLocalList();
+
+                // Check if the change touches our notifications.
+                for (OpenStatusBarNotification osbn : mGList.list()) {
+                    StatusBarNotification notification = osbn.getStatusBarNotification();
+
+                    if (notification.getNotification().priority <= Notification.PRIORITY_LOW) {
+                        rebuildLocalList();
+                        break;
+                    }
+                }
+            }
+        }
+    }
+
+    private class BlacklistListener extends Blacklist.OnBlacklistChangedListener {
+
+        @Override
+        public void onBlacklistChanged(AppConfig configNew, AppConfig configOld, int diff) {
+            if (Operator.bitandCompare(diff, AppConfig.DIFF_HIDDEN_REAL)) {
+
+                // Check if the change touches our notifications.
+                for (OpenStatusBarNotification osbn : mGList.list()) {
+                    StatusBarNotification notification = osbn.getStatusBarNotification();
+
+                    if (notification.getPackageName().equals(configNew.packageName)) {
+                        rebuildLocalList();
+                        break;
+                    }
+                }
             }
         }
     }
@@ -89,6 +115,8 @@ public class NotificationPresenter {
     private NotificationPresenter(Context context) {
         mConfig = Config.getInstance(context);
         mConfig.addOnConfigChangedListener(new ConfigListener());
+        mBlacklist = Blacklist.getInstance(context);
+        mBlacklist.addOnSharedListChangedListener(new BlacklistListener());
     }
 
     public synchronized static NotificationPresenter getInstance(Context context) {
@@ -100,15 +128,10 @@ public class NotificationPresenter {
     /**
      * Should be called when notification listener service is ready to receive events.
      */
-    synchronized void tryStartInitProcess(final Context context) {
-        boolean doNotStart = context == null || mInitProcess > INITIALIZING_PROCESS_NONE;
-        if (context == null) Log.i(TAG, "Tried to start init process but context is null.");
-        if (mInitProcess > INITIALIZING_PROCESS_NONE)
-            Log.wtf(TAG, "Initializing process is already on the way.");
-        if (doNotStart) return;
-
+    // Running on wrong thread
+    void tryStartInitProcess(final Context context) {
+        if (context == null || mInitProcess > INITIALIZING_PROCESS_NONE) return;
         mInitProcess = INITIALIZING_PROCESS_STARTED;
-        if (Project.DEBUG) LogUtils.d(TAG, "Sending initial notification.");
 
         // Send initializing notification with a short delay.
         Intent notificationIntent = new Intent(context, SendNotificationService.class)
@@ -116,251 +139,186 @@ public class NotificationPresenter {
                 .putExtra(SendNotificationService.EXTRA_ID, NotificationIds.INIT_NOTIFICATION)
                 .putExtra(SendNotificationService.EXTRA_ICON_RESOURCE, R.drawable.stat_test)
                 .putExtra(SendNotificationService.EXTRA_PRIORITY, Notification.PRIORITY_MIN);
-        SendNotificationService.sendDelayed(context, notificationIntent, 500);
+        SendNotificationService.notify(context, notificationIntent, 500);
     }
 
-    private void tryInit(Context context, StatusBarNotification n) {
+    void tryInit(Context context, StatusBarNotification n, StatusBarNotification[] activeNotifications) {
         if (mInitProcess != INITIALIZING_PROCESS_STARTED
                 || !(context instanceof NotificationHandleService)
                 || !Project.getPackageName(context).equals(n.getPackageName())) {
-            if (mInitProcess == INITIALIZING_PROCESS_STARTED)
-                Log.w(TAG, "Initializing notification failed: " + n.toString());
             return;
         }
         mInitProcess = INITIALIZING_PROCESS_DONE;
 
-        final NotificationHandleService nhs = (NotificationHandleService) context;
-        for (StatusBarNotification notification : nhs.getActiveNotifications()) {
-            postNotification(context, notification, false, false);
-        }
-
-        if (mFutureSelectedNotification == null)
-            setSelectedNotification(getLastNotification());
-        for (OnNotificationListChangedListener listener : mListeners)
-            listener.onNotificationInitialized(this);
-
-        // Init notification isn't needed anymore.
-        NotificationManager nm = (NotificationManager)
-                context.getSystemService(Context.NOTIFICATION_SERVICE);
-        nm.cancel(n.getId());
-    }
-
-    private void rebuildLocalList() {
-        synchronized (monitor) {
-            mNotificationList.clear();
-
-            for (OpenStatusBarNotification notification : mList) {
-                if (isValidForLocal(notification.getStatusBarNotification()))
-                    mNotificationList.add(notification);
+        if (activeNotifications != null) {
+            for (StatusBarNotification notification : activeNotifications) {
+                postNotification(context, notification, true);
             }
 
-            setSelectedNotification(getLastNotification());
-
+            trySelectNotification(getLastNotification());
             for (OnNotificationListChangedListener listener : mListeners)
                 listener.onNotificationInitialized(this);
+        } else {
+            Log.w(TAG, "Failed to get current active notifications!");
         }
+
+        // Init notification isn't needed anymore.
+        NotificationManager nm = (NotificationManager)
+                context.getSystemService(Context.NOTIFICATION_SERVICE);
+        nm.cancel(NotificationIds.INIT_NOTIFICATION);
     }
 
     // //////////////////////////////////////////
     // //////// -- POST NOTIFICATION -- /////////
     // //////////////////////////////////////////
 
-    /**
-     * If notification is {@link #isValidForLocal(StatusBarNotification) valid} and
-     * {@link #isValid(Context, StatusBarNotification) valid} puts
-     * notification to the list and launches gui.
-     *
-     * @see OnNotificationListChangedListener#onNotificationPosted(NotificationPresenter, OpenStatusBarNotification)
-     * @see OnNotificationListChangedListener#onNotificationChanged(NotificationPresenter, OpenStatusBarNotification)
-     */
-    synchronized void postNotification(Context context, StatusBarNotification notification) {
-        synchronized (monitor) {
-            postNotification(context, notification, true, true);
-        }
+    public ArrayList<OpenStatusBarNotification> getList() {
+        return mLList.list();
     }
 
-    private void postNotification(Context context, StatusBarNotification notification,
-                                  boolean startGui, boolean makeActions) {
-        tryInit(context, notification);
-
-        if (Project.DEBUG) logNotification(context, notification, "posted");
+    public int getCount() {
+        return getList().size();
+    }
 
+    public void postNotification(Context context, StatusBarNotification n) {
+        postNotification(context, n, false);
+    }
 
-        // ////////////// -- GLOBAL -- //////////////
+    public void postNotification(Context context, StatusBarNotification n, boolean internal) {
+        logNotification(context, n, "Post");
+        OpenStatusBarNotification osbn = OpenStatusBarNotification.wrap(n);
 
+        boolean globalValid = isValidForGlobal(context, n);
+        boolean localValid = globalValid && isValidForLocal(n);
 
-        int index = indexOf(mList, notification);
-        if (!isValid(context, notification)) {
-            if (index >= 0) removeNotification(context, notification);
-            return;
+        if (globalValid) {
+            osbn.parse(context);
         }
 
-        OpenStatusBarNotification openNotification = new OpenStatusBarNotification(notification);
+        mGList.pushOrRemove(osbn, globalValid, internal);
+        mLList.pushOrRemove(osbn, localValid, internal);
 
-        if (index < 0) {
-            mList.add(openNotification);
-        } else {
-            mList.remove(index);
-            mList.add(index, openNotification);
+        if (localValid && !internal) {
+            trySelectNotification(osbn);
+            tryStartGui(context, osbn);
         }
+    }
 
+    public void removeNotification(Context context, StatusBarNotification n) {
+        logNotification(context, n, "Remove");
+        OpenStatusBarNotification osbn = OpenStatusBarNotification.wrap(n);
+        mGList.remove(osbn);
+        mLList.remove(osbn);
+    }
 
-        // ////////////// -- LOCAL -- ///////////////
+    private void rebuildLocalList() {
+        if (Project.DEBUG) Log.d(TAG, "Rebuilding local list of notifications.");
 
+        OpenStatusBarNotification selectedOld = mFutureSelectedNotification;
+        ArrayList<OpenStatusBarNotification> list = mLList.list();
+        list.clear();
 
-        index = indexOf(mNotificationList, notification);
-        if (!isValidForLocal(notification)) {
-            if (index >= 0) removeNotificationFromLocal(notification);
-            return;
+        for (OpenStatusBarNotification notification : mGList.list()) {
+            if (isValidForLocal(notification.getStatusBarNotification()))
+                list.add(notification);
         }
 
-        if (index < 0) {
-            mNotificationList.add(openNotification);
+        // Reselect old notification if available.
+        int index = mLList.indexOf(selectedOld);
+        setSelectedNotification(index < 0 ? getLastNotification() : list.get(index));
 
-            // Notify on notification posted
-            if (makeActions)
-                for (OnNotificationListChangedListener listener : mListeners)
-                    listener.onNotificationPosted(this, openNotification);
-        } else {
-            mNotificationList.remove(index);
-            mNotificationList.add(index, openNotification);
-
-            // Notify on notification changed
-            if (makeActions)
-                for (OnNotificationListChangedListener listener : mListeners)
-                    listener.onNotificationChanged(this, openNotification);
-
-            if (Operator.bitandCompare(
-                    notification.getNotification().flags,
-                    Notification.FLAG_ONLY_ALERT_ONCE)
-                    || isPackageSpammer(notification)) {
-                startGui = false;
-            }
-        }
-
-        if (makeActions && (
-                NotificationUtils.equals(
-                        mFutureSelectedNotification, openNotification)
-                        || mFutureSelectedNotification == null)) {
-            setSelectedNotification(openNotification);
-        }
-
-        if (startGui) {
-            tryStartGui(context, openNotification);
-        }
+        for (OnNotificationListChangedListener listener : mListeners)
+            listener.onNotificationInitialized(this);
     }
 
     // //////////////////////////////////////////
-    // /////// -- REMOVE NOTIFICATION -- ////////
+    // ///////////// -- EVENTS -- ///////////////
     // //////////////////////////////////////////
 
-    synchronized void removeNotification(Context context, StatusBarNotification notification) {
-        synchronized (monitor) {
-            tryInit(context, notification);
-
-            if (Project.DEBUG) logNotification(context, notification, "removed");
-
-            int index = indexOf(mList, notification);
-            if (index < 0) {
-                return;
-            }
-
-            mList.remove(index);
-            removeNotificationFromLocal(notification);
+    private void trySelectNotification(OpenStatusBarNotification n) {
+        OpenStatusBarNotification f = mFutureSelectedNotification;
+        if (f == null || NotificationUtils.equals(n, f)) {
+            setSelectedNotification(n);
         }
     }
 
-    private void removeNotificationFromLocal(StatusBarNotification notification) {
-        int index = indexOf(mNotificationList, notification);
-        if (index < 0) {
-            return;
-        }
+    @Override
+    public int onNotificationAdded(OpenStatusBarNotification n) {
+        for (OnNotificationListChangedListener listener : mListeners)
+            listener.onNotificationPosted(this, n);
+        return 0;
+    }
 
-        OpenStatusBarNotification rmn = mNotificationList.get(index);
-        mNotificationList.remove(index);
+    @Override
+    public int onNotificationChanged(OpenStatusBarNotification n) {
+        for (OnNotificationListChangedListener listener : mListeners)
+            listener.onNotificationChanged(this, n);
+        return 0;
+    }
 
-        if (NotificationUtils.equals(mFutureSelectedNotification, rmn)) {
+    @Override
+    public int onNotificationRemoved(OpenStatusBarNotification n) {
+        if (NotificationUtils.equals(n, mFutureSelectedNotification)) {
             setSelectedNotification(getLastNotification());
         }
 
         for (OnNotificationListChangedListener listener : mListeners)
-            listener.onNotificationRemoved(this, rmn);
+            listener.onNotificationRemoved(this, n);
+        return 0;
     }
 
     // //////////////////////////////////////////
     // //////// -- NOTIFICATION UTILS -- ////////
     // //////////////////////////////////////////
 
-    private int indexOf(ArrayList<OpenStatusBarNotification> list, StatusBarNotification n) {
-        final int size = list.size();
-        for (int i = 0; i < size; i++)
-            if (NotificationUtils.equals(n, list.get(i)
-                    .getStatusBarNotification()))
-                return i;
-        return -1;
-    }
-
     private OpenStatusBarNotification getLastNotification() {
-        final int size = mNotificationList.size();
-        return size > 0 ? mNotificationList.get(size - 1) : null;
+        final int size = getList().size();
+        return size > 0 ? getList().get(size - 1) : null;
     }
 
     /**
-     * Returns {@code false} if the notification doesn't meet
+     * Returns {@code false} if the notification doesn't fit
      * the requirements (such as not ongoing and clearable).
      */
     private boolean isValidForLocal(StatusBarNotification n) {
-        return n.getNotification().priority >= Notification.PRIORITY_LOW
-                || mConfig.isLowPriorityNotificationsAllowed();
+        AppConfig config = AppConfig.wrap(n.getPackageName());
+        mBlacklist.fill(config);
+
+        boolean hidden = config.enabled && config.isHidden();
+
+        return (n.getNotification().priority >= Notification.PRIORITY_LOW
+                || mConfig.isLowPriorityNotificationsAllowed())
+                && !hidden;
     }
 
-    private boolean isValid(Context context, StatusBarNotification n) {
+    private boolean isValidForGlobal(Context context, StatusBarNotification n) {
         final boolean isInitNotification = n.getId() == NotificationIds.INIT_NOTIFICATION
                 && !Project.getPackageName(context).equals(n.getPackageName());
         return !n.isOngoing() && n.isClearable() && !isInitNotification;
     }
 
-    // TODO: Add auto ban for some notifications
-    private boolean isPackageSpammer(StatusBarNotification n) {
-        String packageName = n.getPackageName();
-        return packageName.equals(COM_ANDROID_PROVIDERS_DOWNLOADS)
-                || packageName.equals(COM_ANDROID_SETTINGS);
-    }
-
     // //////////////////////////////////////////
     // ///////// -- USER INTERFACE -- ///////////
     // //////////////////////////////////////////
 
     /**
-     * Starts {@link ActiveDisplayActivity activity} if active display
+     * Starts {@link com.achep.activedisplay.activities.ActiveDisplayActivity activity} if active display
      * is enabled and screen is turned off and...
      */
     private boolean tryStartGui(Context context, OpenStatusBarNotification notification) {
-        if (notification.isBlacklisted(context)
+        if (notification.isRestricted(mBlacklist)
                 || !mConfig.isActiveDisplayEnabled()
+                || ProximitySensor.isNear()
                 || mConfig.isEnabledOnlyWhileCharging() /* show only      */
-                && !PowerUtils.isConnected(context))    /* while charging */
+                && !PowerUtils.isCharging(context))     /* while charging */
             return false;
 
-        PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
-        TelephonyManager ts = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
-        if (pm.isScreenOn()
-                || /* activity is started    */ SystemClock.uptimeMillis() - mUIStartTime < UI_MULTI_START_TIMEOUT
-                || /* somebody is calling me */ ts.getCallState() != TelephonyManager.CALL_STATE_IDLE) {
-            if (Project.DEBUG)
-                LogUtils.d(TAG, "Passed an UI launch:"
-                        + " screen_on=" + pm.isScreenOn()
-                        + " call_state=" + ts.getCallState());
+        // Inactive time
+        if (mConfig.isInactiveTimeEnabled() && InactiveHoursHelper.isInactiveTime(mConfig)) {
             return false;
-        } else if (Project.DEBUG) LogUtils.d(TAG, "Starting UI");
+        }
 
-        context.startActivity(new Intent(Intent.ACTION_MAIN, null)
-                .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
-                        | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS
-                        | Intent.FLAG_ACTIVITY_NO_USER_ACTION
-                        | Intent.FLAG_ACTIVITY_NO_ANIMATION
-                        | Intent.FLAG_FROM_BACKGROUND)
-                .setClass(context, ActiveDisplayActivity.class));
+        ActiveDisplayPresenter.getInstance().start(context);
 
         mUIStartTime = SystemClock.uptimeMillis();
         setSelectedNotification(notification);
@@ -371,25 +329,20 @@ public class NotificationPresenter {
     // /////////// -- LOG THINGS -- /////////////
     // //////////////////////////////////////////
 
-    private void logNotification(Context context, StatusBarNotification notification, String action) {
-        LogUtils.d(TAG, action + ": owner=" + notification.getPackageName()
-                + " id=" + notification.getId()
-                + " user_id=" + notification.getUserId()
-                + " tag=" + notification.getTag()
-                + " post_time=" + notification.getPostTime()
-                + " is_valid=" + isValidForLocal(notification)
-                + " is_spammer=" + isPackageSpammer(notification)
-                + " is_blacklisted=" + Blacklist.getInstance(context).contains(notification.getPackageName()));
+    private void logNotification(Context context, StatusBarNotification n, String action) {
+        Log.d(TAG, action + ": package=" + n.getPackageName()
+                + " id=" + n.getId()
+                + " user_id=" + n.getUserId()
+                + " tag=" + n.getTag()
+                + " post_time=" + n.getPostTime()
+                + " is_valid_global=" + isValidForGlobal(context, n)
+                + " is_valid_local=" + isValidForLocal(n));
     }
 
     // //////////////////////////////////////////
     // // -- TRACKING SELECTED NOTIFICATION -- //
     // //////////////////////////////////////////
 
-    public ArrayList<OpenStatusBarNotification> getList() {
-        return mNotificationList;
-    }
-
     public void lockSelectedNotification() {
         mSelectedNotificationLocked = true;
     }
@@ -400,10 +353,6 @@ public class NotificationPresenter {
     }
 
     public void setSelectedNotification(OpenStatusBarNotification notification) {
-        setSelectedNotification(notification, false);
-    }
-
-    private void setSelectedNotification(OpenStatusBarNotification notification, boolean isChanged) {
         mFutureSelectedNotification = notification;
 
         if (mSelectedNotificationLocked || mSelectedNotification == notification) {
@@ -412,7 +361,7 @@ public class NotificationPresenter {
 
         mSelectedNotification = notification;
         for (OnNotificationListChangedListener listener : mListeners) {
-            listener.onNotificationSelected(this, notification, isChanged);
+            listener.onNotificationSelected(this, notification, false);
         }
     }
 
@@ -491,8 +440,6 @@ public class NotificationPresenter {
         public void onNotificationEvent(NotificationPresenter nm,
                                         OpenStatusBarNotification notification,
                                         int event) {
-            LogUtils.track();
         }
     }
-
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationUtils.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationUtils.java
index ef072bc1..5debd526 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationUtils.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/NotificationUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/OpenStatusBarNotification.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/OpenStatusBarNotification.java
index 10947f98..9f26a085 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/OpenStatusBarNotification.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/OpenStatusBarNotification.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -23,6 +23,9 @@ import android.graphics.drawable.Drawable;
 import android.service.notification.StatusBarNotification;
 
 import com.achep.activedisplay.R;
+import com.achep.activedisplay.blacklist.AppConfig;
+import com.achep.activedisplay.blacklist.Blacklist;
+import com.achep.activedisplay.notifications.parser.Parser;
 
 /**
  * Created by Artem on 23.01.14.
@@ -30,11 +33,18 @@ import com.achep.activedisplay.R;
 public class OpenStatusBarNotification {
 
     private final StatusBarNotification mStatusBarNotification;
-    private final NotificationData mNotificationData;
+    private NotificationData mNotificationData;
 
-    public OpenStatusBarNotification(StatusBarNotification notification) {
+    private OpenStatusBarNotification(StatusBarNotification notification) {
         mStatusBarNotification = notification;
-        mNotificationData = Parser.parse(notification);
+    }
+
+    public void parse(Context context) {
+        mNotificationData = Parser.parse(context, mStatusBarNotification);
+    }
+
+    public static OpenStatusBarNotification wrap(StatusBarNotification notification) {
+        return new OpenStatusBarNotification(notification);
     }
 
     @Override
@@ -68,8 +78,15 @@ public class OpenStatusBarNotification {
         return icon != null ? icon : context.getResources().getDrawable(R.drawable.stat_test);
     }
 
-    public boolean isBlacklisted(Context context) {
-        return Blacklist.getInstance(context)
-                .contains(mStatusBarNotification.getPackageName());
+    public AppConfig getAppConfig(Blacklist blacklist) {
+        return blacklist.fill(AppConfig.wrap(mStatusBarNotification.getPackageName()));
+    }
+
+    public boolean isHidden(Blacklist blacklist) {
+        return getAppConfig(blacklist).isHiddenReal();
+    }
+
+    public boolean isRestricted(Blacklist blacklist) {
+        return getAppConfig(blacklist).isRestrictedReal();
     }
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/Parser.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/Parser.java
deleted file mode 100644
index 056f5500..00000000
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/Parser.java
+++ /dev/null
@@ -1,75 +0,0 @@
-/*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.activedisplay.notifications;
-
-import android.app.Notification;
-import android.os.Bundle;
-import android.service.notification.StatusBarNotification;
-import android.util.Log;
-
-/**
- * Created by Artem on 23.01.14.
- */
-class Parser {
-
-    private static final String TAG = "Parser";
-
-    public static NotificationData parse(StatusBarNotification notification) {
-        NotificationData nd = new NotificationData();
-        try {
-            Bundle extras = notification.getNotification().extras;
-            nd.titleText = extras.getCharSequence(Notification.EXTRA_TITLE_BIG);
-            if (nd.titleText == null)
-                nd.titleText = extras.getCharSequence(Notification.EXTRA_TITLE);
-            nd.infoText = extras.getCharSequence(Notification.EXTRA_INFO_TEXT);
-            nd.subText = extras.getCharSequence(Notification.EXTRA_SUB_TEXT);
-            nd.summaryText = extras.getCharSequence(Notification.EXTRA_SUMMARY_TEXT);
-            nd.number = notification.getNotification().number;
-
-            // Large message text
-            CharSequence[] textLines = extras.getCharSequenceArray(Notification.EXTRA_TEXT_LINES);
-            if (textLines != null) {
-                StringBuilder sb = new StringBuilder();
-                for (CharSequence line : textLines) {
-                    sb.append(line);
-                    sb.append('\n');
-                }
-                nd.messageTextLarge = removeSpaces(sb.toString());
-            }
-
-            // Small message text
-            nd.messageText = extras.getCharSequence(Notification.EXTRA_TEXT);
-            if (nd.messageText != null) {
-                nd.messageText = removeSpaces(nd.messageText.toString());
-            }
-        } catch (Exception e) {
-            e.printStackTrace();
-            Log.wtf(TAG, "Notification parsing failed.");
-        }
-        return nd;
-    }
-
-    private static String removeSpaces(String string) {
-        if (string == null) return null;
-        return string
-                .replaceAll("(\\s+$|^\\s+)", "")
-                .replaceAll("\n+", "\n");
-    }
-
-}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/parser/NativeParser.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/parser/NativeParser.java
new file mode 100644
index 00000000..3175985c
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/parser/NativeParser.java
@@ -0,0 +1,81 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.notifications.parser;
+
+import android.app.Notification;
+import android.content.Context;
+import android.os.Bundle;
+import android.service.notification.StatusBarNotification;
+import android.util.Log;
+
+import com.achep.activedisplay.Project;
+import com.achep.activedisplay.notifications.NotificationData;
+
+/**
+ * Created by Artem on 04.03.14.
+ */
+final class NativeParser implements Parser.NotificationParser {
+
+    private static final String TAG = "NativeParser";
+
+    @Override
+    public NotificationData parse(Context context, StatusBarNotification statusBarNotification, NotificationData data) {
+        if (Project.DEBUG) Log.d(TAG, "Extracting notification data via native API.");
+
+        Notification notification = statusBarNotification.getNotification();
+        Bundle extras = notification.extras;
+
+        if (extras == null) {
+            Log.i(TAG, "");
+            return data;
+        }
+
+        try {
+            data.titleText = extras.getCharSequence(Notification.EXTRA_TITLE_BIG);
+            if (data.titleText == null)
+                data.titleText = extras.getCharSequence(Notification.EXTRA_TITLE);
+            data.infoText = extras.getCharSequence(Notification.EXTRA_INFO_TEXT);
+            data.subText = extras.getCharSequence(Notification.EXTRA_SUB_TEXT);
+            data.summaryText = extras.getCharSequence(Notification.EXTRA_SUMMARY_TEXT);
+            data.number = notification.number;
+
+            // Large message text
+            CharSequence[] textLines = extras.getCharSequenceArray(Notification.EXTRA_TEXT_LINES);
+            if (textLines != null) {
+                StringBuilder sb = new StringBuilder();
+                for (CharSequence line : textLines) {
+                    sb.append(line);
+                    sb.append('\n');
+                }
+                data.messageTextLarge = Parser.removeSpaces(sb.toString());
+            }
+
+            // Small message text
+            data.messageText = extras.getCharSequence(Notification.EXTRA_TEXT);
+            if (data.messageText != null) {
+                data.messageText = Parser.removeSpaces(data.messageText.toString());
+            }
+        } catch (Exception e) {
+            Log.wtf(TAG, "Native notification parsing failed.");
+            e.printStackTrace();
+        }
+        return data;
+    }
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/parser/Parser.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/parser/Parser.java
new file mode 100644
index 00000000..ecdd5e50
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/parser/Parser.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.notifications.parser;
+
+import android.content.Context;
+import android.service.notification.StatusBarNotification;
+import android.text.TextUtils;
+
+import com.achep.activedisplay.Device;
+import com.achep.activedisplay.notifications.NotificationData;
+
+/**
+ * Created by Artem on 23.01.14.
+ */
+public class Parser {
+
+    private static final NotificationParser NATIVE = new NativeParser();
+    private static final NotificationParser VIEW_PARSER = new ViewParser();
+
+    public static NotificationData parse(Context context, StatusBarNotification notification) {
+        NotificationData data = new NotificationData();
+        boolean useViewParser = !Device.hasKitKatApi();
+
+        if (!useViewParser) {
+            NATIVE.parse(context, notification, data);
+            useViewParser = true
+                    && TextUtils.isEmpty(data.titleText)
+                    && TextUtils.isEmpty(data.getLargeMessage());
+        }
+        if (useViewParser) VIEW_PARSER.parse(context, notification, data);
+        return data;
+    }
+
+    /**
+     * Removes all kinds of multiple spaces from given string.
+     */
+    static String removeSpaces(String string) {
+        if (string == null) return null;
+        return string
+                .replaceAll("(\\s+$|^\\s+)", "")
+                .replaceAll("\n+", "\n");
+    }
+
+    interface NotificationParser {
+        public NotificationData parse(Context context, StatusBarNotification notification, NotificationData nd);
+    }
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/legacy/NotificationParser.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/parser/ViewParser.java
similarity index 52%
rename from project/ActiveDisplay/src/main/java/com/achep/activedisplay/legacy/NotificationParser.java
rename to project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/parser/ViewParser.java
index 9be94743..e885a1f1 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/legacy/NotificationParser.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/notifications/parser/ViewParser.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -16,12 +16,10 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.activedisplay.legacy;
+package com.achep.activedisplay.notifications.parser;
 
 import android.app.Notification;
 import android.content.Context;
-import android.os.Build;
-import android.os.Bundle;
 import android.service.notification.StatusBarNotification;
 import android.util.Log;
 import android.view.LayoutInflater;
@@ -33,70 +31,42 @@ import android.widget.TextView;
 import com.achep.activedisplay.R;
 import com.achep.activedisplay.notifications.NotificationData;
 import com.achep.activedisplay.notifications.NotificationUtils;
+import com.achep.activedisplay.utils.LogUtils;
 
 import java.util.ArrayList;
 
 /**
- * Created by Artem on 13.01.14.
+ * Jelly bean 4.3 backport.
  */
-public class NotificationParser implements INotificationParser {
+final class ViewParser implements Parser.NotificationParser {
 
-    private static final String TAG = "NotificationParser";
+    private static final String TAG = "ViewParser";
 
-    public NotificationData parce(Context myContext, StatusBarNotification notification) {
-        NotificationData nd = new NotificationData();
-
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-
-            try {
-                Bundle extras = notification.getNotification().extras;
-                nd.titleText = extras.getCharSequence(Notification.EXTRA_TITLE_BIG);
-                nd.infoText = extras.getCharSequence(Notification.EXTRA_INFO_TEXT);
-                nd.subText = extras.getCharSequence(Notification.EXTRA_SUB_TEXT);
-                nd.summaryText = extras.getCharSequence(Notification.EXTRA_SUMMARY_TEXT);
-
-                CharSequence[] textLines = extras.getCharSequenceArray(Notification.EXTRA_TEXT_LINES);
-                if (textLines != null) {
-                    StringBuilder sb = new StringBuilder();
-                    for (CharSequence line : textLines) {
-                        sb.append(line);
-                        sb.append('\n');
-                    }
-                    nd.messageText = sb.toString();
-                } else {
-                    nd.messageText = extras.getCharSequence(Notification.EXTRA_TEXT);
-                }
-            } catch (Exception e) {
-                e.printStackTrace();
-                Log.wtf(TAG, "KitKat notification parsing failed.");
-                return null;
-            }
-
-            if (nd.titleText != null && nd.messageText != null) {
-                return nd;
-            }
-        }
+    @Override
+    public NotificationData parse(Context contextApp, StatusBarNotification notification, NotificationData nd) {
+        Log.i(TAG, "Parsing notification using view parser.");
 
+        nd.number = notification.getNotification().number;
 
         // Replace app's context with notification's context
         // to be able to get its resources.
-        Context context = NotificationUtils.createContext(myContext, notification);
+        Context contextNotify = NotificationUtils.createContext(contextApp, notification);
         final Notification n = notification.getNotification();
         final RemoteViews rvs = n.bigContentView == null ? n.contentView : n.bigContentView;
 
         ViewGroup view;
         try {
-            LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+            LayoutInflater inflater = (LayoutInflater) contextNotify.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
             view = (ViewGroup) inflater.inflate(rvs.getLayoutId(), null);
             if (view == null) {
-                Log.w(TAG, "Notification package (layout is @null): " + notification.getPackageName());
-                return null;
+                LogUtils.track();
+                return nd;
             }
-            rvs.reapply(context, view);
+            rvs.reapply(contextNotify, view);
         } catch (Exception e) {
+            LogUtils.track();
             e.printStackTrace();
-            Log.w(TAG, "Notification package (exception): " + notification.getPackageName());
-            return null;
+            return nd;
         }
 
         ArrayList<ViewParentLink<TextView>> textViews =
@@ -105,8 +75,7 @@ public class NotificationParser implements INotificationParser {
         ViewParentLink<TextView> title = findTitleTextView(textViews);
 
         nd.titleText = title.view.getText();
-        nd.messageText = findMessageText(myContext, textViews, n, title);
-
+        nd.messageText = findMessageText(contextApp, textViews, n, title);
         return nd;
     }
 
@@ -142,9 +111,9 @@ public class NotificationParser implements INotificationParser {
             for (Notification.Action action : notification.actions) {
                 final int size = textViewsList.size();
                 for (int i = 0; i < size; i++) {
-                    if (textViewsList.get(i).view.getText().equals(action.title)) {
-                        Log.d(TAG, "Removed \"" + action.title + "\" action from the list of texts.");
-
+                    CharSequence text = textViewsList.get(i).view.getText();
+                    assert text != null;
+                    if (text.equals(action.title)) {
                         textViewsList.remove(i);
                         break;
                     }
@@ -158,70 +127,19 @@ public class NotificationParser implements INotificationParser {
             final TextView view = textViewsList.get(k).view;
             if (view.getTextSize() == subtextSize
                     || view.toString().matches("^(\\s*|)$")) {
-                Log.d(TAG, "Removed item \"" + view.getText() + "\" from the list of texts.");
-
                 textViewsList.remove(k);
                 offset--;
             }
         }
 
-        /*final SimilarityStrategy strategy = new JaroWinklerStrategy();
-        final StringSimilarityService service = new StringSimilarityServiceImpl(strategy);
-        final String titleText = title.view.getText().toString();
-        final String tickerText = notification.tickerText != null
-                ? notification.tickerText.toString() : null;
-
-        int maxScoreItem = 0;
-        int maxScore = Integer.MIN_VALUE;
-        int maxLength = Integer.MIN_VALUE;
-
-        size = textViewsList.size();
-        double[] similaritiesToTitle = new double[size];
-        double[] similaritiesToTicker = tickerText != null ? new double[size] : null;
-
-        // pre calculations
-        for (int i = 0; i < size; i++) {
-            final TextView textView = textViewsList.get(i).view;
-
-            final String text = textView.getText().toString();
-            maxLength = Math.max(text.length(), maxLength);
-            similaritiesToTitle[i] = service.score(text, titleText);
-            if (tickerText != null) similaritiesToTicker[i] = service.score(text, tickerText);
-        }
-
-        // score calculations
-        for (int i = 0; i < size; i++) {
-            final TextView textView = textViews.get(i);
-            if (textView == titleTextView)
-                continue;
-            final String text = textView.getText().toString();
-
-            int score = 0;
-            score -= 30 * similaritiesToTitle[i];
-            score += 30 * similaritiesToTicker[i];
-            score += 40 * text.length() / maxLength;
-            score -= 40 * (text.matches("[a-zA-Z0-9[!#$%&'()*+,/\\-_\\.\\\"]]+@[a-zA-Z0-9[!#$%&'()*+,/\\-_\\\"]]+\\.[a-zA-Z0-9[!#$%&'()*+,/\\-_\\\"\\.]]+") ? 1 : 0);
-            score -= 30 * (text.matches("^(\\d|)\\d:\\d\\d$") ? 1 : 0);
-            score -= 30 * (textView.isClickable() ? 1 : 0);
-            score -= 20 * (text.matches("^\\d+$") ? 1 : 0);
-            if (textView.getTextSize() < titleTextView.getTextSize()) score += 30;
-
-            if (score > maxScore) {
-                maxScore = score;
-                maxScoreItem = i;
-            }
-
-            if (Project.DEBUG) Log.d(TAG, "text=" + text + " score=" + score);
-        }*/
-
         StringBuilder sb = new StringBuilder();
         for (ViewParentLink<TextView> tv : textViewsList) {
-            sb.append(tv.view.getText().toString().replaceAll("\\s+$", ""));
+            sb.append(tv.view.getText());
             sb.append('\n');
         }
-        sb.delete(sb.length() - 1, sb.length());
+        if (sb.length() > 0) sb.delete(sb.length() - 1, sb.length());
 
-        return sb.toString();
+        return Parser.removeSpaces(sb.toString());
     }
 
     private static class RecursiveFinder<T extends View> {
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/receiver/Receiver.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/receiver/Receiver.java
new file mode 100644
index 00000000..2ee5c69a
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/receiver/Receiver.java
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.receiver;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.util.Log;
+
+import com.achep.activedisplay.activemode.ActiveModeService;
+import com.achep.activedisplay.services.LockscreenService;
+
+/**
+ * Created by Artem on 11.03.14.
+ */
+public class Receiver extends BroadcastReceiver {
+
+    private static final String TAG = "Receiver";
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        Log.d(TAG, "action=" + intent.getAction() + " intent=" + intent.toString());
+        switch (intent.getAction()) {
+            case Intent.ACTION_BOOT_COMPLETED:
+            case Intent.ACTION_POWER_CONNECTED:
+            case Intent.ACTION_POWER_DISCONNECTED:
+                ActiveModeService.handleState(context);
+                LockscreenService.handleState(context);
+                break;
+        }
+    }
+}
\ No newline at end of file
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/receiver/ReceiverActivity.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/receiver/ReceiverActivity.java
new file mode 100644
index 00000000..66535a7e
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/receiver/ReceiverActivity.java
@@ -0,0 +1,101 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.receiver;
+
+import android.app.Activity;
+import android.content.ComponentName;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Bundle;
+import android.util.Log;
+
+import com.achep.activedisplay.Project;
+import com.achep.activedisplay.utils.IntentUtils;
+
+/**
+ * Created by Artem on 12.03.14.
+ */
+public class ReceiverActivity extends Activity {
+
+    private static final String TAG = "ReceiverActivity";
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+
+        Intent intent = getIntent();
+        if (intent != null) {
+
+            if (Project.DEBUG) Log.d(TAG, "" + intent.getPackage());
+            if (true) {
+                handleLocalIntent(intent);
+            } else {
+                handleIntent(intent);
+            }
+        } else {
+            Log.wtf(TAG, "Got an empty launch intent.");
+        }
+
+        finish();
+    }
+
+    private void handleLocalIntent(Intent intent) {
+        Uri data = intent.getData();
+
+        if (data == null) {
+            return;
+        }
+
+        String host = data.getHost();
+
+        if (host == null) {
+            return;
+        }
+
+        switch (host) {
+            case "launch_device_admins_activity":
+                Intent launchIntent = new Intent().setComponent(new ComponentName(
+                        "com.android.settings",
+                        "com.android.settings.DeviceAdminSettings"));
+                if (IntentUtils.hasActivityForThat(this, launchIntent)) {
+                    startActivity(launchIntent);
+                } else {
+                    // TODO: Show toast message
+                }
+                break;
+            case "launch_uninstall_screen":
+                Uri packageUri = Uri.parse("package:" + Project.getPackageName(this));
+                launchIntent = new Intent(Intent.ACTION_UNINSTALL_PACKAGE, packageUri);
+                if (IntentUtils.hasActivityForThat(this, launchIntent)) {
+                    startActivity(launchIntent);
+                } else {
+                    // TODO: Show toast message
+                }
+                break;
+            default:
+                Log.wtf(TAG, "Got an unknown intent: " + host);
+                break;
+        }
+    }
+
+    private void handleIntent(Intent intent) {
+
+    }
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/services/BreathingService.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/services/BreathingService.java
deleted file mode 100644
index 6b16bdc4..00000000
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/services/BreathingService.java
+++ /dev/null
@@ -1,80 +0,0 @@
-package com.achep.activedisplay.services;
-
-import android.app.Notification;
-import android.app.Service;
-import android.content.Intent;
-import android.graphics.BitmapFactory;
-import android.hardware.Sensor;
-import android.hardware.SensorEvent;
-import android.hardware.SensorEventListener;
-import android.hardware.SensorManager;
-import android.os.IBinder;
-import android.widget.Toast;
-
-import com.achep.activedisplay.NotificationIds;
-import com.achep.activedisplay.R;
-import com.achep.activedisplay.activities.ActiveDisplayActivity;
-
-/**
- * Created by Artem on 16.02.14.
- */
-public class BreathingService extends Service {
-
-    private SensorManager mSensorManager;
-    private SensorEventListener mAccelerometerMonitor = new SensorEventListener() {
-
-        @Override
-        public void onSensorChanged(SensorEvent event) {
-        }
-
-        @Override
-        public void onAccuracyChanged(Sensor sensor, int i) {
-
-        }
-
-    };
-    private SensorEventListener mProximityMonitor = new SensorEventListener() {
-
-        @Override
-        public void onSensorChanged(SensorEvent event) {
-        }
-
-        @Override
-        public void onAccuracyChanged(Sensor sensor, int i) { /* unused */ }
-
-    };
-
-    @Override
-    public void onDestroy() {
-        mSensorManager.unregisterListener(mProximityMonitor);
-        mSensorManager.unregisterListener(mAccelerometerMonitor);
-    }
-
-    @Override
-    public int onStartCommand(Intent intent, int flags, int startId) {
-        mSensorManager = (SensorManager) getSystemService(SENSOR_SERVICE);
-        mSensorManager.registerListener(mProximityMonitor,
-                mSensorManager.getDefaultSensor(Sensor.TYPE_PROXIMITY),
-                SensorManager.SENSOR_DELAY_NORMAL);
-        mSensorManager.registerListener(mAccelerometerMonitor,
-                mSensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER),
-                SensorManager.SENSOR_DELAY_NORMAL);
-
-        Notification notification = new Notification.Builder(this)
-                        .setSmallIcon(R.drawable.stat_test)
-                        .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))
-                        .setContentTitle(getString(R.string.app_name))
-                        .setPriority(Notification.PRIORITY_MIN)
-                        .setAutoCancel(true)
-                        .setOngoing(true)
-                        .build();
-        startForeground(NotificationIds.BREATHING_NOTIFICATION, notification);
-        return Service.START_STICKY;
-    }
-
-    @Override
-    public IBinder onBind(Intent intent) {
-        return null;
-    }
-
-}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/services/LockscreenService.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/services/LockscreenService.java
new file mode 100644
index 00000000..3e8da54d
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/services/LockscreenService.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.services;
+
+import android.app.Notification;
+import android.app.PendingIntent;
+import android.app.Service;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.IBinder;
+import android.os.SystemClock;
+import android.telephony.TelephonyManager;
+
+import com.achep.activedisplay.ActiveDisplayPresenter;
+import com.achep.activedisplay.Config;
+import com.achep.activedisplay.NotificationIds;
+import com.achep.activedisplay.R;
+import com.achep.activedisplay.activities.ActiveDisplayActivity;
+import com.achep.activedisplay.settings.Settings;
+import com.achep.activedisplay.utils.PowerUtils;
+
+/**
+ * Created by Artem on 16.02.14.
+ */
+public class LockscreenService extends Service {
+
+    public static long sIgnoreTillTime;
+
+    public static void ignoreCurrentTurningOn() {
+        sIgnoreTillTime = SystemClock.elapsedRealtime() + 2000;
+    }
+
+    /**
+     * Starts or stops this service as required by settings and device's state.
+     */
+    public static void handleState(Context context) {
+        Intent intent = new Intent(context, LockscreenService.class);
+        Config config = Config.getInstance(context);
+        if (config.isActiveDisplayEnabled() && config.isLockscreenEnabled()) {
+            if (!config.isEnabledOnlyWhileCharging() || PowerUtils.isCharging(context)) {
+
+                context.startService(intent);
+            }
+        } else {
+            context.stopService(intent);
+        }
+    }
+
+    private BroadcastReceiver mReceiver = new BroadcastReceiver() {
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            TelephonyManager ts = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
+            final boolean isCall = ts.getCallState() != TelephonyManager.CALL_STATE_IDLE;
+
+            switch (intent.getAction()) {
+                case Intent.ACTION_SCREEN_ON:
+
+                    // Somebody requested this ignoring.
+                    if (SystemClock.elapsedRealtime() < sIgnoreTillTime && !isCall) {
+                        sIgnoreTillTime = 0;
+                        return;
+                    }
+
+                    if (isCall) {
+
+                        // Why do we need to kill it? Because otherwise it'll
+                        // be displayed after you've done with your call and
+                        // closed phone app.
+                        ActiveDisplayPresenter.getInstance().kill();
+                    } else startGui();
+
+                    break;
+                case Intent.ACTION_SCREEN_OFF:
+                    // Do not start
+                    if (!isCall) startGui();
+                    break;
+            }
+        }
+
+    };
+
+    private void startGui() {
+        startActivity(new Intent(Intent.ACTION_MAIN, null)
+                .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
+                        | Intent.FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS
+                        | Intent.FLAG_ACTIVITY_NO_USER_ACTION
+                        | Intent.FLAG_ACTIVITY_NO_ANIMATION
+                        | Intent.FLAG_FROM_BACKGROUND)
+                .setClass(this, ActiveDisplayActivity.class));
+    }
+
+    @Override
+    public void onCreate() {
+        super.onCreate();
+        IntentFilter intentFilter = new IntentFilter(Intent.ACTION_SCREEN_ON);
+        intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
+        intentFilter.setPriority(Integer.MAX_VALUE);
+        registerReceiver(mReceiver, intentFilter);
+
+        int notificationId = NotificationIds.LOCKSCREEN_NOTIFICATION;
+        PendingIntent pendingIntent = PendingIntent.getActivity(this,
+                notificationId, new Intent(this, Settings.LockscreenSettingsActivity.class),
+                PendingIntent.FLAG_UPDATE_CURRENT);
+        Notification notification = new Notification.Builder(this)
+                .setSmallIcon(R.drawable.stat_lock)
+                .setContentTitle(getString(
+                        R.string.service_lockscreen,
+                        getString(R.string.app_name)))
+                .setContentText(getString(R.string.service_lockscreen_text))
+                .setPriority(Notification.PRIORITY_MIN)
+                .setContentIntent(pendingIntent)
+                .setOngoing(true)
+                .build();
+
+        startForeground(notificationId, notification);
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        unregisterReceiver(mReceiver);
+    }
+
+    @Override
+    public IBinder onBind(Intent intent) {
+        return null;
+    }
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/services/SendNotificationService.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/services/SendNotificationService.java
index f450d764..e0d74f57 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/services/SendNotificationService.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/services/SendNotificationService.java
@@ -1,3 +1,21 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
 package com.achep.activedisplay.services;
 
 import android.app.AlarmManager;
@@ -7,6 +25,7 @@ import android.app.PendingIntent;
 import android.app.Service;
 import android.content.Context;
 import android.content.Intent;
+import android.graphics.BitmapFactory;
 import android.net.Uri;
 import android.os.IBinder;
 
@@ -19,8 +38,10 @@ public class SendNotificationService extends Service {
     public static final String EXTRA_TEXT = "text";
     public static final String EXTRA_ID = "id";
     public static final String EXTRA_ICON_RESOURCE = "icon";
+    public static final String EXTRA_LARGE_ICON_RESOURCE = "large_icon";
     public static final String EXTRA_PRIORITY = "priority";
     public static final String EXTRA_SOUND_URI = "sound_uri";
+    public static final String EXTRA_CONTENT_INTENT = "content_intent";
 
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
@@ -32,20 +53,29 @@ public class SendNotificationService extends Service {
         CharSequence title = intent.getCharSequenceExtra(EXTRA_TITLE);
         CharSequence text = intent.getCharSequenceExtra(EXTRA_TEXT);
         Uri soundUri = intent.getParcelableExtra(EXTRA_SOUND_URI);
+        PendingIntent pi = intent.getParcelableExtra(EXTRA_CONTENT_INTENT);
         int id = intent.getIntExtra(EXTRA_ID, 0);
         int iconRes = intent.getIntExtra(EXTRA_ICON_RESOURCE, 0);
+        int largeIconRes = intent.getIntExtra(EXTRA_LARGE_ICON_RESOURCE, 0);
         int priority = intent.getIntExtra(EXTRA_PRIORITY, Notification.PRIORITY_DEFAULT);
 
-        Notification n = new Notification.Builder(this)
+        Notification.Builder builder = new Notification.Builder(this)
                 .setContentTitle(title)
                 .setContentText(text)
                 .setSmallIcon(iconRes)
                 .setPriority(priority)
-                .setSound(soundUri)
-                .build();
+                .setAutoCancel(true)
+                .setSound(soundUri);
+
+        if (largeIconRes != 0) {
+            builder.setLargeIcon(BitmapFactory.decodeResource(getResources(), largeIconRes));
+        }
+        if (pi != null) {
+            builder.setContentIntent(pi);
+        }
 
         NotificationManager nm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
-        nm.notify(id, n);
+        nm.notify(id, builder.build());
 
         stopSelf();
     }
@@ -55,10 +85,12 @@ public class SendNotificationService extends Service {
         return null;
     }
 
-    public static PendingIntent sendDelayed(Context context, Intent intent, int delayMillis) {
+    public static PendingIntent notify(Context context, Intent intent, int delayMillis) {
         AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
-        PendingIntent pendingIntent = PendingIntent.getService(context, 0, intent, PendingIntent.FLAG_CANCEL_CURRENT);
-        am.set(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + delayMillis, pendingIntent);
+        PendingIntent pendingIntent = PendingIntent.getService(context,
+                intent.getIntExtra(EXTRA_ID, 0), intent,
+                PendingIntent.FLAG_UPDATE_CURRENT);
+        am.setExact(AlarmManager.RTC_WAKEUP, System.currentTimeMillis() + delayMillis, pendingIntent);
         return pendingIntent;
     }
 
@@ -66,4 +98,24 @@ public class SendNotificationService extends Service {
         AlarmManager am = (AlarmManager) context.getSystemService(Context.ALARM_SERVICE);
         am.cancel(pendingIntent);
     }
+
+    /**
+     * Simple notification builder with all possible args.
+     *
+     * @see #notify(android.content.Context, android.content.Intent, int)
+     * @see #cancel(android.content.Context, android.app.PendingIntent)
+     */
+    public static Intent createNotificationIntent(Context context, String title, String text,
+                                                  int id, int iconRes, int largeIconRes, int priority,
+                                                  Uri soundUri, PendingIntent pi) {
+        return new Intent(context, SendNotificationService.class)
+                .putExtra(SendNotificationService.EXTRA_TITLE, title)
+                .putExtra(SendNotificationService.EXTRA_TEXT, text)
+                .putExtra(SendNotificationService.EXTRA_ID, id)
+                .putExtra(SendNotificationService.EXTRA_ICON_RESOURCE, iconRes)
+                .putExtra(SendNotificationService.EXTRA_LARGE_ICON_RESOURCE, largeIconRes)
+                .putExtra(SendNotificationService.EXTRA_PRIORITY, priority)
+                .putExtra(SendNotificationService.EXTRA_SOUND_URI, soundUri)
+                .putExtra(SendNotificationService.EXTRA_CONTENT_INTENT, pi);
+    }
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/ActiveFragment.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/ActiveFragment.java
new file mode 100644
index 00000000..71f22f25
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/ActiveFragment.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.settings;
+
+import android.app.ActionBar;
+import android.app.Activity;
+import android.os.Bundle;
+import android.preference.PreferenceFragment;
+import android.widget.Switch;
+
+import com.achep.activedisplay.R;
+
+/**
+ * Created by Artem on 09.02.14.
+ */
+public class ActiveFragment extends PreferenceFragment {
+
+    private ActiveModeEnabler mActiveModeEnabler;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        addPreferencesFromResource(R.xml.active_settings);
+
+        Activity activity = getActivity();
+        ActionBar actionBar = activity.getActionBar();
+
+        actionBar.setDisplayShowCustomEnabled(true);
+        actionBar.setCustomView(R.layout.layout_ab_switch);
+        Switch switch_ = (Switch) actionBar.getCustomView().findViewById(R.id.switch_);
+        mActiveModeEnabler = new ActiveModeEnabler(activity, switch_);
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        mActiveModeEnabler.resume();
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        mActiveModeEnabler.pause();
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/ActiveModeEnabler.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/ActiveModeEnabler.java
new file mode 100644
index 00000000..b5cc4260
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/ActiveModeEnabler.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.settings;
+
+import android.content.Context;
+import android.widget.CompoundButton;
+import android.widget.Switch;
+
+import com.achep.activedisplay.Config;
+
+/**
+ * Created by Artem on 21.02.14.
+ */
+public final class ActiveModeEnabler extends Enabler {
+
+    private boolean mBroadcasting;
+
+    public ActiveModeEnabler(Context context, Switch switch_) {
+        super(context, switch_);
+    }
+
+    @Override
+    protected void updateState() {
+        mSwitch.setEnabled(mConfig.isActiveDisplayEnabled());
+        mBroadcasting = true;
+        mSwitch.setChecked(mConfig.isActiveModeEnabled());
+        mBroadcasting = false;
+    }
+
+    @Override
+    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+        if (mBroadcasting) {
+            return;
+        }
+
+        mConfig.setActiveModeEnabled(mContext, isChecked, this);
+    }
+
+    @Override
+    public void onConfigChanged(Config config, String key, Object value) {
+        switch (key) {
+            case Config.KEY_ENABLED:
+            case Config.KEY_ACTIVE_MODE:
+                updateState();
+                break;
+        }
+    }
+}
\ No newline at end of file
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/Enabler.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/Enabler.java
new file mode 100644
index 00000000..9faaabbb
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/Enabler.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.settings;
+
+import android.content.Context;
+import android.widget.CompoundButton;
+import android.widget.Switch;
+
+import com.achep.activedisplay.Config;
+
+/**
+ * Created by Artem on 21.02.14.
+ */
+abstract class Enabler implements
+        Config.OnConfigChangedListener,
+        CompoundButton.OnCheckedChangeListener {
+
+    final Context mContext;
+    final Config mConfig;
+    Switch mSwitch;
+
+    public Enabler(Context context, Switch switch_) {
+        mContext = context;
+        mConfig = Config.getInstance(mContext);
+        mSwitch = switch_;
+    }
+
+    abstract protected void updateState();
+
+    public void resume() {
+        mConfig.addOnConfigChangedListener(this);
+        mSwitch.setOnCheckedChangeListener(this);
+        updateState();
+    }
+
+    public void pause() {
+        mConfig.removeOnConfigChangedListener(this);
+        mSwitch.setOnCheckedChangeListener(null);
+    }
+
+    public void setSwitch(Switch switch_) {
+        if (mSwitch == switch_) {
+            return;
+        }
+
+        mSwitch = switch_;
+        mSwitch.setOnCheckedChangeListener(this);
+        updateState();
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/InterfaceFragment.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/InterfaceFragment.java
new file mode 100644
index 00000000..534a3f4c
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/InterfaceFragment.java
@@ -0,0 +1,95 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.settings;
+
+import android.os.Bundle;
+import android.preference.CheckBoxPreference;
+import android.preference.Preference;
+import android.preference.PreferenceFragment;
+
+import com.achep.activedisplay.Config;
+import com.achep.activedisplay.Keys;
+import com.achep.activedisplay.R;
+
+/**
+ * Created by Artem on 09.02.14.
+ */
+public class InterfaceFragment extends PreferenceFragment implements
+        Preference.OnPreferenceChangeListener,
+        Config.OnConfigChangedListener {
+
+    private CheckBoxPreference mShowWallpaper;
+
+    private boolean mBroadcasting;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        addPreferencesFromResource(R.xml.interface_settings);
+
+        mShowWallpaper = (CheckBoxPreference) findPreference(
+                Keys.Settings.INTERFACE_IS_WALLPAPER_SHOWN);
+        mShowWallpaper.setOnPreferenceChangeListener(this);
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        Config config = Config.getInstance(getActivity());
+        config.addOnConfigChangedListener(this);
+
+        updateShowWallpaperPreference(config);
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        Config config = Config.getInstance(getActivity());
+        config.removeOnConfigChangedListener(this);
+    }
+
+    private void updateShowWallpaperPreference(Config config) {
+        mBroadcasting = true;
+        mShowWallpaper.setChecked(config.isWallpaperShown());
+        mBroadcasting = false;
+    }
+
+    @Override
+    public boolean onPreferenceChange(Preference preference, Object newValue) {
+        if (mBroadcasting) {
+            return true;
+        }
+
+        Config config = Config.getInstance(getActivity());
+        if (preference == mShowWallpaper) {
+            config.setWallpaperShown(getActivity(), (Boolean) newValue, this);
+        } else
+            return false;
+        return true;
+    }
+
+    @Override
+    public void onConfigChanged(Config config, String key, Object value) {
+        switch (key) {
+            case Config.KEY_INTERFACE_WALLPAPER_SHOWN:
+                updateShowWallpaperPreference(config);
+                break;
+        }
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/LockscreenEnabler.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/LockscreenEnabler.java
new file mode 100644
index 00000000..8bd476dd
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/LockscreenEnabler.java
@@ -0,0 +1,64 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.settings;
+
+import android.content.Context;
+import android.widget.CompoundButton;
+import android.widget.Switch;
+
+import com.achep.activedisplay.Config;
+
+/**
+ * Created by Artem on 21.02.14.
+ */
+public final class LockscreenEnabler extends Enabler {
+
+    private boolean mBroadcasting;
+
+    public LockscreenEnabler(Context context, Switch switch_) {
+        super(context, switch_);
+    }
+
+    @Override
+    protected void updateState() {
+        mSwitch.setEnabled(mConfig.isActiveDisplayEnabled());
+        mBroadcasting = true;
+        mSwitch.setChecked(mConfig.isLockscreenEnabled());
+        mBroadcasting = false;
+    }
+
+    @Override
+    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+        if (mBroadcasting) {
+            return;
+        }
+
+        mConfig.setLockscreenEnabled(mContext, isChecked, this);
+    }
+
+    @Override
+    public void onConfigChanged(Config config, String key, Object value) {
+        switch (key) {
+            case Config.KEY_ENABLED:
+            case Config.KEY_LOCK_SCREEN:
+                updateState();
+                break;
+        }
+    }
+}
\ No newline at end of file
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/LockscreenFragment.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/LockscreenFragment.java
new file mode 100644
index 00000000..cef25f5b
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/LockscreenFragment.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.settings;
+
+import android.app.ActionBar;
+import android.app.Activity;
+import android.os.Bundle;
+import android.preference.PreferenceFragment;
+import android.widget.Switch;
+
+import com.achep.activedisplay.R;
+
+/**
+ * Created by Artem on 09.02.14.
+ */
+public class LockscreenFragment extends PreferenceFragment {
+
+    private LockscreenEnabler mLockscreenEnabler;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        addPreferencesFromResource(R.xml.lockscreen_settings);
+
+        Activity activity = getActivity();
+        ActionBar actionBar = activity.getActionBar();
+
+        actionBar.setDisplayShowCustomEnabled(true);
+        actionBar.setCustomView(R.layout.layout_ab_switch);
+        Switch switch_ = (Switch) actionBar.getCustomView().findViewById(R.id.switch_);
+        mLockscreenEnabler = new LockscreenEnabler(activity, switch_);
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        mLockscreenEnabler.resume();
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        mLockscreenEnabler.pause();
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/MoreFragment.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/MoreFragment.java
new file mode 100644
index 00000000..a3296f7b
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/MoreFragment.java
@@ -0,0 +1,157 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.settings;
+
+import android.os.Bundle;
+import android.preference.CheckBoxPreference;
+import android.preference.ListPreference;
+import android.preference.Preference;
+import android.preference.PreferenceFragment;
+
+import com.achep.activedisplay.Config;
+import com.achep.activedisplay.R;
+import com.achep.activedisplay.utils.DateUtils;
+import com.achep.activedisplay.utils.LogUtils;
+import com.achep.activedisplay.utils.MathUtils;
+
+/**
+ * Created by Artem on 09.02.14.
+ */
+public class MoreFragment extends PreferenceFragment implements Config.OnConfigChangedListener, Preference.OnPreferenceChangeListener {
+
+    private CheckBoxPreference mOnlyWhileChargingPreference;
+    private Preference mInactiveHoursPreference;
+    private Preference mTimeoutPreference;
+    private ListPreference mSwipeLeftListPreference;
+    private ListPreference mSwipeRightListPreference;
+
+    private boolean mBroadcasting;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        addPreferencesFromResource(R.xml.more_settings);
+
+        mOnlyWhileChargingPreference = (CheckBoxPreference) findPreference("only_while_charging");
+        mInactiveHoursPreference = findPreference("inactive_hours");
+        mTimeoutPreference = findPreference("timeout");
+        mSwipeLeftListPreference = (ListPreference) findPreference("swipe_left_action");
+        mSwipeRightListPreference = (ListPreference) findPreference("swipe_right_action");
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        Config config = Config.getInstance(getActivity());
+        config.addOnConfigChangedListener(this);
+
+        updateOnlyWhileCharging(config);
+        updateInactiveHoursSummary(config);
+        updateTimeoutSummary(config);
+        updateSwipeLeftSummary(config);
+        updateSwipeRightSummary(config);
+
+        mOnlyWhileChargingPreference.setOnPreferenceChangeListener(this);
+        mSwipeLeftListPreference.setOnPreferenceChangeListener(this);
+        mSwipeRightListPreference.setOnPreferenceChangeListener(this);
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        Config config = Config.getInstance(getActivity());
+        config.removeOnConfigChangedListener(this);
+    }
+
+    private void updateOnlyWhileCharging(Config config) {
+        mBroadcasting = true;
+        mOnlyWhileChargingPreference.setChecked(config.isEnabledOnlyWhileCharging());
+        mBroadcasting = false;
+    }
+
+    private void updateInactiveHoursSummary(Config config) {
+        if (config.isInactiveTimeEnabled()) {
+            int from = config.getInactiveTimeFrom();
+            int to = config.getInactiveTimeTo();
+            mInactiveHoursPreference.setSummary(getString(R.string.settings_inactive_hours_enabled,
+                    DateUtils.formatTime(getActivity(), MathUtils.div(from, 60), from % 60),
+                    DateUtils.formatTime(getActivity(), MathUtils.div(to, 60), to % 60)));
+        } else {
+            mInactiveHoursPreference.setSummary(getString(R.string.settings_inactive_hours_disabled));
+        }
+    }
+
+    private void updateTimeoutSummary(Config config) {
+        mTimeoutPreference.setSummary(getString(R.string.settings_timeout_summary,
+                Float.toString(config.getTimeoutNormal() / 1000),
+                Float.toString(config.getTimeoutShort() / 1000)));
+    }
+
+    private void updateSwipeLeftSummary(Config config) {
+        mSwipeLeftListPreference.setSummary(
+                mSwipeLeftListPreference.getEntries()[config.getSwipeLeftAction()]);
+    }
+
+    private void updateSwipeRightSummary(Config config) {
+        mSwipeRightListPreference.setSummary(
+                mSwipeRightListPreference.getEntries()[config.getSwipeRightAction()]);
+    }
+
+    @Override
+    public boolean onPreferenceChange(Preference preference, Object newValue) {
+        if (mBroadcasting) {
+            return true;
+        }
+
+        Config config = Config.getInstance(getActivity());
+        if (preference == mOnlyWhileChargingPreference) {
+            config.setActiveDisplayEnabledOnlyWhileCharging(getActivity(), (Boolean) newValue, null);
+        } else if (preference == mSwipeLeftListPreference) {
+            config.setSwipeLeftAction(getActivity(), Integer.parseInt((String) newValue), null);
+        } else if (preference == mSwipeRightListPreference) {
+            config.setSwipeRightAction(getActivity(), Integer.parseInt((String) newValue), null);
+        } else
+            return false;
+        return true;
+    }
+
+    @Override
+    public void onConfigChanged(Config config, String key, Object value) {
+        switch (key) {
+            case Config.KEY_INACTIVE_TIME_ENABLED:
+            case Config.KEY_INACTIVE_TIME_FROM:
+            case Config.KEY_INACTIVE_TIME_TO:
+                updateInactiveHoursSummary(config);
+                break;
+            case Config.KEY_TIMEOUT_NORMAL:
+            case Config.KEY_TIMEOUT_SHORT:
+                updateTimeoutSummary(config);
+                break;
+            case Config.KEY_ONLY_WHILE_CHARGING:
+                updateOnlyWhileCharging(config);
+                break;
+            case Config.KEY_SWIPE_LEFT_ACTION:
+                updateSwipeLeftSummary(config);
+                break;
+            case Config.KEY_SWIPE_RIGHT_ACTION:
+                updateSwipeRightSummary(config);
+                break;
+        }
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/NotificationFragment.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/NotificationFragment.java
new file mode 100644
index 00000000..85694531
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/NotificationFragment.java
@@ -0,0 +1,93 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.settings;
+
+import android.os.Bundle;
+import android.preference.CheckBoxPreference;
+import android.preference.Preference;
+import android.preference.PreferenceFragment;
+
+import com.achep.activedisplay.Config;
+import com.achep.activedisplay.R;
+
+/**
+ * Created by Artem on 09.02.14.
+ */
+public class NotificationFragment extends PreferenceFragment implements
+        Preference.OnPreferenceChangeListener,
+        Config.OnConfigChangedListener {
+
+    private CheckBoxPreference mLowPriorityPreference;
+
+    private boolean mBroadcasting;
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        addPreferencesFromResource(R.xml.notification_settings);
+
+        mLowPriorityPreference = (CheckBoxPreference) findPreference("low_priority_notifications");
+        mLowPriorityPreference.setOnPreferenceChangeListener(this);
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        Config config = Config.getInstance(getActivity());
+        config.addOnConfigChangedListener(this);
+
+        updateLowPriorityPreference(config);
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        Config config = Config.getInstance(getActivity());
+        config.removeOnConfigChangedListener(this);
+    }
+
+    private void updateLowPriorityPreference(Config config) {
+        mBroadcasting = true;
+        mLowPriorityPreference.setChecked(config.isLowPriorityNotificationsAllowed());
+        mBroadcasting = false;
+    }
+
+    @Override
+    public boolean onPreferenceChange(Preference preference, Object newValue) {
+        if (mBroadcasting) {
+            return true;
+        }
+
+        Config config = Config.getInstance(getActivity());
+        if (preference == mLowPriorityPreference) {
+            config.setLowPriorityNotificationsAllowed(getActivity(), (Boolean) newValue, this);
+        } else
+            return false;
+        return true;
+    }
+
+    @Override
+    public void onConfigChanged(Config config, String key, Object value) {
+        switch (key) {
+            case Config.KEY_LOW_PRIORITY_NOTIFICATIONS:
+                updateLowPriorityPreference(config);
+                break;
+        }
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/Settings.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/Settings.java
new file mode 100644
index 00000000..b8dc2250
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/Settings.java
@@ -0,0 +1,557 @@
+/*
+ * Copyright (C) 2008 The Android Open Source Project
+ * Modified 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.achep.activedisplay.settings;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.os.Bundle;
+import android.preference.Preference;
+import android.preference.PreferenceActivity;
+import android.preference.PreferenceFragment;
+import android.text.TextUtils;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.View.OnClickListener;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+import android.widget.ImageView;
+import android.widget.ListAdapter;
+import android.widget.Switch;
+import android.widget.TextView;
+
+import com.achep.activedisplay.R;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * Top-level settings activity to handle single pane and double pane UI layout.
+ */
+public class Settings extends PreferenceActivity {
+
+    // Fuck you Android Devs for the hidden #getHeaders()!
+    private static final String HEADERS_TAG = ":android:headers";
+
+    private static final String LOG_TAG = "Settings";
+
+    private static final String META_DATA_KEY_HEADER_ID =
+            "com.achep.activedisplay.TOP_LEVEL_HEADER_ID";
+    private static final String META_DATA_KEY_FRAGMENT_CLASS =
+            "com.achep.activedisplay.FRAGMENT_CLASS";
+    private static final String META_DATA_KEY_PARENT_TITLE =
+            "com.achep.activedisplay.PARENT_FRAGMENT_TITLE";
+    private static final String META_DATA_KEY_PARENT_FRAGMENT_CLASS =
+            "com.achep.activedisplay.PARENT_FRAGMENT_CLASS";
+
+    private static final String EXTRA_UI_OPTIONS = "settings:ui_options";
+    private static final String EXTRA_CLEAR_UI_OPTIONS = "settings:remove_ui_options";
+
+    private static final String SAVE_KEY_CURRENT_HEADER = "com.achep.activedisplay.CURRENT_HEADER";
+    private static final String SAVE_KEY_PARENT_HEADER = "com.achep.activedisplay.PARENT_HEADER";
+
+    private String mFragmentClass;
+    private int mTopLevelHeaderId;
+    private Header mFirstHeader;
+    private Header mCurrentHeader;
+    private Header mParentHeader;
+    private boolean mInLocalHeaderSwitch;
+
+    protected HashMap<Integer, Integer> mHeaderIndexMap = new HashMap<>();
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        if (getIntent().hasExtra(EXTRA_UI_OPTIONS)) {
+            getWindow().setUiOptions(getIntent().getIntExtra(EXTRA_UI_OPTIONS, 0));
+        }
+
+        getMetaData();
+        mInLocalHeaderSwitch = true;
+        super.onCreate(savedInstanceState);
+        mInLocalHeaderSwitch = false;
+
+        if (!onIsHidingHeaders() && onIsMultiPane()) {
+            highlightHeader(mTopLevelHeaderId);
+            // Force the title so that it doesn't get overridden by a direct launch of
+            // a specific settings screen.
+            setTitle(R.string.settings);
+        }
+
+        // Retrieve any saved state
+        if (savedInstanceState != null) {
+            mCurrentHeader = savedInstanceState.getParcelable(SAVE_KEY_CURRENT_HEADER);
+            mParentHeader = savedInstanceState.getParcelable(SAVE_KEY_PARENT_HEADER);
+        }
+
+        // If the current header was saved, switch to it
+        if (savedInstanceState != null && mCurrentHeader != null) {
+            //switchToHeaderLocal(mCurrentHeader);
+            showBreadCrumbs(mCurrentHeader.title, null);
+        }
+
+        if (mParentHeader != null) {
+            setParentTitle(mParentHeader.title, null, new OnClickListener() {
+                @Override
+                public void onClick(View v) {
+                    switchToParent(mParentHeader.fragment);
+                }
+            });
+        }
+
+        // Override up navigation for multi-pane, since we handle it in the fragment breadcrumbs
+        if (onIsMultiPane()) {
+            getActionBar().setDisplayHomeAsUpEnabled(false);
+            getActionBar().setHomeButtonEnabled(false);
+        }
+    }
+
+    @Override
+    protected void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        // Save the current fragment, if it is the same as originally launched
+        if (mCurrentHeader != null) {
+            outState.putParcelable(SAVE_KEY_CURRENT_HEADER, mCurrentHeader);
+        }
+        if (mParentHeader != null) {
+            outState.putParcelable(SAVE_KEY_PARENT_HEADER, mParentHeader);
+        }
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        ListAdapter listAdapter = getListAdapter();
+        if (listAdapter instanceof HeaderAdapter) {
+            ((HeaderAdapter) listAdapter).resume();
+        }
+        invalidateHeaders();
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        ListAdapter listAdapter = getListAdapter();
+        if (listAdapter instanceof HeaderAdapter) {
+            ((HeaderAdapter) listAdapter).pause();
+        }
+    }
+
+    private static final String[] ENTRY_FRAGMENTS = {
+            LockscreenFragment.class.getName(),
+            ActiveFragment.class.getName(),
+            NotificationFragment.class.getName(),
+            InterfaceFragment.class.getName(),
+            MoreFragment.class.getName()
+    };
+
+    @Override
+    protected boolean isValidFragment(String fragmentName) {
+        // Almost all fragments are wrapped in this,
+        // except for a few that have their own activities.
+        for (String str : ENTRY_FRAGMENTS) {
+            if (str.equals(fragmentName)) return true;
+        }
+        return false;
+    }
+
+    private void switchToHeaderLocal(Header header) {
+        mInLocalHeaderSwitch = true;
+        switchToHeader(header);
+        mInLocalHeaderSwitch = false;
+    }
+
+    @Override
+    public void switchToHeader(Header header) {
+        if (!mInLocalHeaderSwitch) {
+            mCurrentHeader = null;
+            mParentHeader = null;
+        }
+        super.switchToHeader(header);
+    }
+
+    /**
+     * Switch to parent fragment and store the grand parent's info
+     *
+     * @param className name of the activity wrapper for the parent fragment.
+     */
+    private void switchToParent(String className) {
+        final ComponentName cn = new ComponentName(this, className);
+        try {
+            final PackageManager pm = getPackageManager();
+            final ActivityInfo parentInfo = pm.getActivityInfo(cn, PackageManager.GET_META_DATA);
+
+            if (parentInfo != null && parentInfo.metaData != null) {
+                String fragmentClass = parentInfo.metaData.getString(META_DATA_KEY_FRAGMENT_CLASS);
+                CharSequence fragmentTitle = parentInfo.loadLabel(pm);
+                Header parentHeader = new Header();
+                parentHeader.fragment = fragmentClass;
+                parentHeader.title = fragmentTitle;
+                mCurrentHeader = parentHeader;
+
+                switchToHeaderLocal(parentHeader);
+                highlightHeader(mTopLevelHeaderId);
+
+                mParentHeader = new Header();
+                mParentHeader.fragment
+                        = parentInfo.metaData.getString(META_DATA_KEY_PARENT_FRAGMENT_CLASS);
+                mParentHeader.title = parentInfo.metaData.getString(META_DATA_KEY_PARENT_TITLE);
+            }
+        } catch (NameNotFoundException nnfe) {
+            Log.w(LOG_TAG, "Could not find parent activity : " + className);
+        }
+    }
+
+    @Override
+    public void onNewIntent(Intent intent) {
+        super.onNewIntent(intent);
+
+        // If it is not launched from history, then reset to top-level
+        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY) == 0) {
+            if (mFirstHeader != null && !onIsHidingHeaders() && onIsMultiPane()) {
+                switchToHeaderLocal(mFirstHeader);
+            }
+            getListView().setSelectionFromTop(0, 0);
+        }
+    }
+
+    private void highlightHeader(int id) {
+        if (id != 0) {
+            Integer index = mHeaderIndexMap.get(id);
+            if (index != null) {
+                getListView().setItemChecked(index, true);
+                if (isMultiPane()) {
+                    getListView().smoothScrollToPosition(index);
+                }
+            }
+        }
+    }
+
+    @Override
+    public Intent getIntent() {
+        Intent superIntent = super.getIntent();
+        String startingFragment = getStartingFragmentClass(superIntent);
+        // This is called from super.onCreate, isMultiPane() is not yet reliable
+        // Do not use onIsHidingHeaders either, which relies itself on this method
+        if (startingFragment != null && !onIsMultiPane()) {
+            Intent modIntent = new Intent(superIntent);
+            modIntent.putExtra(EXTRA_SHOW_FRAGMENT, startingFragment);
+            Bundle args = superIntent.getExtras();
+            if (args != null) {
+                args = new Bundle(args);
+            } else {
+                args = new Bundle();
+            }
+            args.putParcelable("intent", superIntent);
+            modIntent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, superIntent.getExtras());
+            return modIntent;
+        }
+        return superIntent;
+    }
+
+    /**
+     * Checks if the component name in the intent is different from the Settings class and
+     * returns the class name to load as a fragment.
+     */
+    protected String getStartingFragmentClass(Intent intent) {
+        if (mFragmentClass != null) return mFragmentClass;
+        String intentClass = intent.getComponent().getClassName();
+        if (intentClass.equals(getClass().getName())) return null;
+
+        return intentClass;
+    }
+
+    /**
+     * Override initial header when an activity-alias is causing Settings to be launched
+     * for a specific fragment encoded in the android:name parameter.
+     */
+    @Override
+    public Header onGetInitialHeader() {
+        String fragmentClass = getStartingFragmentClass(super.getIntent());
+        if (fragmentClass != null) {
+            Header header = new Header();
+            header.fragment = fragmentClass;
+            header.title = getTitle();
+            header.fragmentArguments = getIntent().getExtras();
+            mCurrentHeader = header;
+            return header;
+        }
+
+        return mFirstHeader;
+    }
+
+    @Override
+    public Intent onBuildStartFragmentIntent(String fragmentName, Bundle args,
+                                             int titleRes, int shortTitleRes) {
+        Intent intent = super.onBuildStartFragmentIntent(fragmentName, args,
+                titleRes, shortTitleRes);
+        onBuildStartFragmentIntentHelper(fragmentName, intent);
+        return intent;
+    }
+
+    private void onBuildStartFragmentIntentHelper(String fragmentName, Intent intent) {
+        intent.setClass(this, SubSettings.class);
+    }
+
+    /**
+     * Populate the activity with the top-level headers.
+     */
+    @Override
+    public void onBuildHeaders(List<Header> headers) {
+        if (!onIsHidingHeaders()) {
+            loadHeadersFromResource(R.xml.settings_headers, headers);
+            updateHeaderList(headers);
+        }
+    }
+
+    private void updateHeaderList(List<Header> target) {
+        int i = 0;
+        mHeaderIndexMap.clear();
+        while (i < target.size()) {
+            Header header = target.get(i);
+            // Ids are integers, so downcasting
+            int id = (int) header.id;
+
+            // Increment if the current one wasn't removed by the Utils code.
+            if (target.get(i) == header) {
+                // Hold on to the first header, when we need to reset to the top-level
+                int headerType = HeaderAdapter.getHeaderType(header);
+                if (mFirstHeader == null &&
+                        headerType == HeaderAdapter.HEADER_TYPE_NORMAL) {
+                    mFirstHeader = header;
+                }
+                mHeaderIndexMap.put(id, i);
+                i++;
+            }
+        }
+    }
+
+    private void getMetaData() {
+        try {
+            ActivityInfo ai = getPackageManager().getActivityInfo(getComponentName(),
+                    PackageManager.GET_META_DATA);
+            if (ai == null || ai.metaData == null) return;
+            mTopLevelHeaderId = ai.metaData.getInt(META_DATA_KEY_HEADER_ID);
+            mFragmentClass = ai.metaData.getString(META_DATA_KEY_FRAGMENT_CLASS);
+
+            // Check if it has a parent specified and create a Header object
+            final int parentHeaderTitleRes = ai.metaData.getInt(META_DATA_KEY_PARENT_TITLE);
+            String parentFragmentClass = ai.metaData.getString(META_DATA_KEY_PARENT_FRAGMENT_CLASS);
+            if (parentFragmentClass != null) {
+                mParentHeader = new Header();
+                mParentHeader.fragment = parentFragmentClass;
+                if (parentHeaderTitleRes != 0) {
+                    mParentHeader.title = getResources().getString(parentHeaderTitleRes);
+                }
+            }
+        } catch (NameNotFoundException nnfe) {
+            // No recovery
+        }
+    }
+
+    private static class HeaderAdapter extends ArrayAdapter<Header> {
+        static final int HEADER_TYPE_CATEGORY = 0;
+        static final int HEADER_TYPE_NORMAL = 1;
+        static final int HEADER_TYPE_SWITCH = 2;
+
+        private static final int HEADER_TYPE_COUNT = 3;
+
+        private final Enabler mLockscreenEnabler;
+        private final Enabler mActiveEnabler;
+
+        private static class HeaderViewHolder {
+            ImageView icon;
+            TextView title;
+            TextView summary;
+            Switch switch_;
+        }
+
+        private LayoutInflater mInflater;
+
+        static int getHeaderType(Header header) {
+            if (header.fragment == null && header.intent == null) {
+                return HEADER_TYPE_CATEGORY;
+            } else if (header.id == R.id.lockscreen_settings
+                    || header.id == R.id.active_settings) {
+                return HEADER_TYPE_SWITCH;
+            } else {
+                return HEADER_TYPE_NORMAL;
+            }
+        }
+
+        @Override
+        public int getItemViewType(int position) {
+            Header header = getItem(position);
+            return getHeaderType(header);
+        }
+
+        @Override
+        public boolean areAllItemsEnabled() {
+            return false; // because of categories
+        }
+
+        @Override
+        public boolean isEnabled(int position) {
+            return getItemViewType(position) != HEADER_TYPE_CATEGORY;
+        }
+
+        @Override
+        public int getViewTypeCount() {
+            return HEADER_TYPE_COUNT;
+        }
+
+        @Override
+        public boolean hasStableIds() {
+            return true;
+        }
+
+        public HeaderAdapter(Context context, List<Header> objects) {
+            super(context, 0, objects);
+
+            mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+
+            // Temp Switches provided as placeholder until the adapter replaces these with actual
+            // Switches inflated from their layouts. Must be done before adapter is set in super
+            mLockscreenEnabler = new LockscreenEnabler(context, new Switch(context));
+            mActiveEnabler = new ActiveModeEnabler(context, new Switch(context));
+        }
+
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+            final HeaderViewHolder holder;
+            final Header header = getItem(position);
+            final int headerType = getHeaderType(header);
+            View view = null;
+
+            if (convertView == null) {
+                holder = new HeaderViewHolder();
+                switch (headerType) {
+                    case HEADER_TYPE_CATEGORY:
+                        view = new TextView(getContext(), null,
+                                android.R.attr.listSeparatorTextViewStyle);
+                        holder.title = (TextView) view;
+                        break;
+
+                    case HEADER_TYPE_SWITCH:
+                        view = mInflater.inflate(
+                                R.layout.preference_header_switch_item, parent,
+                                false);
+                        holder.icon = (ImageView) view.findViewById(R.id.icon);
+                        holder.title = (TextView) view.findViewById(android.R.id.title);
+                        holder.summary = (TextView) view.findViewById(android.R.id.summary);
+                        holder.switch_ = (Switch) view.findViewById(R.id.switch_);
+                        break;
+
+                    case HEADER_TYPE_NORMAL:
+                        view = mInflater.inflate(
+                                R.layout.preference_header_item, parent,
+                                false);
+                        holder.icon = (ImageView) view.findViewById(R.id.icon);
+                        holder.title = (TextView) view.findViewById(android.R.id.title);
+                        holder.summary = (TextView) view.findViewById(android.R.id.summary);
+                        break;
+                }
+                view.setTag(holder);
+            } else {
+                view = convertView;
+                holder = (HeaderViewHolder) view.getTag();
+            }
+
+            // All view fields must be updated every time, because the view may be recycled
+            switch (headerType) {
+                case HEADER_TYPE_CATEGORY:
+                    holder.title.setText(header.getTitle(getContext().getResources()));
+                    break;
+
+                case HEADER_TYPE_SWITCH:
+                    if (header.id == R.id.lockscreen_settings) {
+                        mLockscreenEnabler.setSwitch(holder.switch_);
+                    } else if (header.id == R.id.active_settings) {
+                        mActiveEnabler.setSwitch(holder.switch_);
+                    }
+                case HEADER_TYPE_NORMAL:
+                    holder.icon.setImageResource(header.iconRes);
+                    holder.title.setText(header.getTitle(getContext().getResources()));
+
+                    CharSequence summary = header.getSummary(getContext().getResources());
+                    if (!TextUtils.isEmpty(summary)) {
+                        holder.summary.setVisibility(View.VISIBLE);
+                        holder.summary.setText(summary);
+                    } else {
+                        holder.summary.setVisibility(View.GONE);
+                    }
+                    break;
+            }
+
+            return view;
+        }
+
+        public void resume() {
+            mLockscreenEnabler.resume();
+            mActiveEnabler.resume();
+        }
+
+        public void pause() {
+            mLockscreenEnabler.pause();
+            mActiveEnabler.pause();
+        }
+    }
+
+    @Override
+    public boolean onPreferenceStartFragment(PreferenceFragment caller, Preference pref) {
+        int titleRes = pref.getTitleRes();
+        startPreferencePanel(pref.getFragment(), pref.getExtras(),
+                titleRes, pref.getTitle(), null, 0);
+        return true;
+    }
+
+    @Override
+    public boolean shouldUpRecreateTask(Intent targetIntent) {
+        return super.shouldUpRecreateTask(new Intent(this, Settings.class));
+    }
+
+    @Override
+    public void setListAdapter(ListAdapter adapter) {
+        if (adapter == null) {
+            super.setListAdapter(null);
+        } else {
+            List<Header> headers = null;
+            try {
+                Method method = PreferenceActivity.class.getDeclaredMethod("getHeaders");
+                method.setAccessible(true);
+                headers = (List<Header>) method.invoke(this);
+            } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
+                e.printStackTrace();
+            }
+
+            super.setListAdapter(new HeaderAdapter(this, headers));
+        }
+    }
+
+    public static class ActiveModeSettingsActivity extends Settings { /* empty */
+    }
+
+    public static class LockscreenSettingsActivity extends Settings { /* empty */
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/SubSettings.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/SubSettings.java
new file mode 100644
index 00000000..801cf971
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/SubSettings.java
@@ -0,0 +1,51 @@
+/*
+ * Copyright (C) 2011 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.achep.activedisplay.settings;
+
+import android.app.FragmentManager;
+import android.util.Log;
+
+import com.achep.activedisplay.Project;
+
+/**
+ * Stub class for showing sub-settings; we can't use the main Settings class
+ * since for our app it is a special singleTask class.
+ */
+public class SubSettings extends Settings {
+
+    @Override
+    public boolean onNavigateUp() {
+        if (!popFragment()) {
+            finish();
+        }
+        return true;
+    }
+
+    @Override
+    protected boolean isValidFragment(String fragmentName) {
+        if (Project.DEBUG) Log.d("SubSettings", "Launching fragment " + fragmentName);
+        return true;
+    }
+
+    private boolean popFragment() {
+        FragmentManager fm = getFragmentManager();
+        if (fm.getBackStackEntryCount() > 0) {
+            fm.popBackStack();
+            return true;
+        }
+        return false;
+    }
+}
\ No newline at end of file
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/preferences/InactiveHoursPreference.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/preferences/InactiveHoursPreference.java
new file mode 100644
index 00000000..2c80c5aa
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/preferences/InactiveHoursPreference.java
@@ -0,0 +1,143 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.settings.preferences;
+
+import android.app.TimePickerDialog;
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.preference.DialogPreference;
+import android.text.Html;
+import android.util.AttributeSet;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.CheckBox;
+import android.widget.TextView;
+import android.widget.TimePicker;
+
+import com.achep.activedisplay.Config;
+import com.achep.activedisplay.DialogHelper;
+import com.achep.activedisplay.R;
+import com.achep.activedisplay.utils.DateUtils;
+import com.achep.activedisplay.utils.MathUtils;
+
+/**
+ * Preference to configure timeouts.
+ */
+public class InactiveHoursPreference extends DialogPreference implements View.OnClickListener {
+
+    private static final String TAG = "InactiveHoursPreference";
+
+    private final Drawable mIcon;
+    private final CharSequence mTitle;
+
+    private CheckBox mEnabled;
+
+    private Data mFrom = new Data();
+    private Data mTo = new Data();
+
+    public static class Data {
+        public int hours;
+        public int minutes;
+        public String labelSource;
+        public TextView labelTextView;
+
+        public void setTime(Context context, int timeInMinutes) {
+            setTime(context, MathUtils.div(timeInMinutes, 60), timeInMinutes % 60);
+        }
+
+        public void setTime(Context context, int hours, int minutes) {
+            this.hours = hours;
+            this.minutes = minutes;
+
+            String labelTime = DateUtils.formatTime(context, hours, minutes);
+            labelTextView.setText(Html.fromHtml(String.format(labelSource, labelTime)));
+        }
+    }
+
+    public InactiveHoursPreference(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        // Get data from default dialog and hide it.
+        mIcon = getDialogIcon();
+        mTitle = getDialogTitle();
+        setDialogTitle(null);
+    }
+
+    @Override
+    protected View onCreateDialogView() {
+        Context context = getContext();
+        LayoutInflater inflater = (LayoutInflater) context
+                .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        final ViewGroup root = (ViewGroup) inflater.inflate(R.layout.preference_dialog_inactive_hours, null);
+        assert root != null;
+
+        TextView fromTextView = (TextView) root.findViewById(R.id.from);
+        TextView toTextView = (TextView) root.findViewById(R.id.to);
+        mEnabled = (CheckBox) root.findViewById(R.id.checkbox);
+
+        fromTextView.setOnClickListener(this);
+        toTextView.setOnClickListener(this);
+
+        mFrom.labelTextView = fromTextView;
+        mFrom.labelSource = context.getString(R.string.preference_inactive_hours_from);
+        mTo.labelTextView = toTextView;
+        mTo.labelSource = context.getString(R.string.preference_inactive_hours_to);
+
+        Config config = Config.getInstance(context);
+        mFrom.setTime(context, config.getInactiveTimeFrom());
+        mTo.setTime(context, config.getInactiveTimeTo());
+        mEnabled.setChecked(config.isInactiveTimeEnabled());
+
+        // Build custom dialog.
+        return new DialogHelper.Builder(getContext())
+                .setIcon(mIcon)
+                .setTitle(mTitle)
+                .setView(root)
+                .create();
+    }
+
+    @Override
+    protected void onDialogClosed(boolean positiveResult) {
+        super.onDialogClosed(positiveResult);
+
+        if (!positiveResult) {
+            return;
+        }
+
+        Context context = getContext();
+        Config config = Config.getInstance(context);
+        config.setInactiveTimeFrom(context, mFrom.hours * 60 + mFrom.minutes, null);
+        config.setInactiveTimeTo(context, mTo.hours * 60 + mTo.minutes, null);
+        config.setInactiveTimeEnabled(context, mEnabled.isChecked(), null);
+    }
+
+    @Override
+    public void onClick(View v) {
+        final Data data = v == mFrom.labelTextView ? mFrom : mTo;
+
+        TimePickerDialog timePickerDialog = new TimePickerDialog(getContext(), new TimePickerDialog.OnTimeSetListener() {
+            @Override
+            public void onTimeSet(TimePicker timePicker, int selectedHour, int selectedMinute) {
+                data.setTime(getContext(), selectedHour, selectedMinute);
+            }
+        }, data.hours, data.minutes, true);
+        timePickerDialog.show();
+    }
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/preferences/TimeoutPreference.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/preferences/TimeoutPreference.java
similarity index 87%
rename from project/ActiveDisplay/src/main/java/com/achep/activedisplay/preferences/TimeoutPreference.java
rename to project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/preferences/TimeoutPreference.java
index d7148e8e..12f8009c 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/preferences/TimeoutPreference.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/settings/preferences/TimeoutPreference.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.activedisplay.preferences;
+package com.achep.activedisplay.settings.preferences;
 
 import android.content.Context;
 import android.graphics.drawable.Drawable;
@@ -62,30 +62,26 @@ public class TimeoutPreference extends DialogPreference implements
         mTitle = getDialogTitle();
         setDialogTitle(null);
 
-        mValueLabel = getContext().getResources().getString(R.string.settings_timeout_sec);
+        mValueLabel = getContext().getResources().getString(R.string.preference_timeout_sec);
     }
 
     @Override
     protected View onCreateDialogView() {
         LayoutInflater inflater = (LayoutInflater) getContext()
                 .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-        View content = inflater.inflate(R.layout.layout_dialog_pref_timeout, null);
-        assert content != null;
+        View root = inflater.inflate(R.layout.preference_dialog_timeout, null);
+        assert root != null;
 
-        mProgresses = new int[3];
-        mGroups = new Group[3];
+        mProgresses = new int[2];
+        mGroups = new Group[mProgresses.length];
         mGroups[0] = new Group(
-                (SeekBar) content.findViewById(R.id.normal_timeout_seekbar),
-                (TextView) content.findViewById(R.id.normal_timeout_value),
+                (SeekBar) root.findViewById(R.id.normal_timeout_seekbar),
+                (TextView) root.findViewById(R.id.normal_timeout_value),
                 "setTimeoutNormal", "getTimeoutNormal");
         mGroups[1] = new Group(
-                (SeekBar) content.findViewById(R.id.short_timeout_seekbar),
-                (TextView) content.findViewById(R.id.short_timeout_value),
+                (SeekBar) root.findViewById(R.id.short_timeout_seekbar),
+                (TextView) root.findViewById(R.id.short_timeout_value),
                 "setTimeoutShort", "getTimeoutShort");
-        mGroups[2] = new Group(
-                (SeekBar) content.findViewById(R.id.instant_timeout_seekbar),
-                (TextView) content.findViewById(R.id.instant_timeout_value),
-                "setTimeoutInstant", "getTimeoutInstant");
 
         final int max = getContext().getResources()
                 .getInteger(R.integer.config_timeout_maxDurationMillis) / MULTIPLIER;
@@ -111,7 +107,7 @@ public class TimeoutPreference extends DialogPreference implements
         return new DialogHelper.Builder(getContext())
                 .setIcon(mIcon)
                 .setTitle(mTitle)
-                .setView(content)
+                .setView(root)
                 .create();
     }
 
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/AccessUtils.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/AccessUtils.java
index 29efc620..500df1cc 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/AccessUtils.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/AccessUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/ButtonUtils.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/ButtonUtils.java
index d3dbca9b..ace0d168 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/ButtonUtils.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/ButtonUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/legacy/INotificationParser.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/DateUtils.java
similarity index 65%
rename from project/ActiveDisplay/src/main/java/com/achep/activedisplay/legacy/INotificationParser.java
rename to project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/DateUtils.java
index 39d808e2..a14b6d4a 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/legacy/INotificationParser.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/DateUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -16,18 +16,21 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.activedisplay.legacy;
+package com.achep.activedisplay.utils;
 
 import android.content.Context;
-import android.service.notification.StatusBarNotification;
-
-import com.achep.activedisplay.notifications.NotificationData;
+import android.text.format.DateFormat;
 
 /**
- * Created by Artem on 01.01.14.
+ * Created by Artem on 03.01.14.
  */
-public interface INotificationParser {
+public class DateUtils {
 
-    public NotificationData parce(Context context, StatusBarNotification notification);
+    public static String formatTime(Context context, int h, int m) {
+        if (h > 12 && !DateFormat.is24HourFormat(context)) {
+            h -= 12;
+        }
+        return h + ":" + (m < 10 ? "0" + m : m);
+    }
 
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/FileUtils.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/FileUtils.java
new file mode 100644
index 00000000..3decc0e5
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/FileUtils.java
@@ -0,0 +1,55 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.utils;
+
+import android.util.Log;
+
+import java.io.File;
+
+/**
+ * Created by Artem on 15.03.14.
+ */
+public class FileUtils {
+
+    private static final String TAG = "FileUtils";
+
+    /**
+     * Deletes all files from given directory
+     */
+    public static void deleteRecursive(File file) {
+        if (file != null) {
+            File[] children;
+            if (file.isDirectory() && (children = file.listFiles()) != null && children.length > 0) {
+                for (File child : children) {
+                    deleteRecursive(child);
+                }
+            } else {
+                int i = 0;
+                for (; i < 5; i++) {
+                    if (file.delete()) {
+                        i = 0;
+                        break;
+                    }
+                }
+                if (i > 0) Log.w(TAG, "Failed to delete " + file.getName());
+            }
+        }
+    }
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/IntentUtils.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/IntentUtils.java
new file mode 100644
index 00000000..c2741a85
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/IntentUtils.java
@@ -0,0 +1,35 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.utils;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageManager;
+
+/**
+ * Created by Artem on 16.03.14.
+ */
+public class IntentUtils {
+
+    public static boolean hasActivityForThat(Context context, Intent intent) {
+        PackageManager pm = context.getPackageManager();
+        return pm != null && intent.resolveActivity(pm) != null;
+    }
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/LogUtils.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/LogUtils.java
index a28ab7c9..836dfe88 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/LogUtils.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/LogUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -71,7 +71,7 @@ public class LogUtils {
                     found = true;
 
                     StringBuilder sb = new StringBuilder();
-                    for (int j = i + 2; j < i + 5 && j < traces.length; j++) {
+                    for (int j = i + 2; j < i + 7 && j < traces.length; j++) {
                         sb.append(traces[j].getMethodName());
                         sb.append(" / ");
                     }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/MathUtils.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/MathUtils.java
index cbb4a2b8..a1d6069d 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/MathUtils.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/MathUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -31,4 +31,12 @@ public class MathUtils {
         return a >= 0 ? 1 : -1;
     }
 
+    public static int bool(boolean a) {
+        return a ? 1 : 0;
+    }
+
+    public static int div(int a, int b) {
+        return (a - a % b) / b;
+    }
+
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/PendingIntentUtils.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/PendingIntentUtils.java
index a3e8202b..3c0632a0 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/PendingIntentUtils.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/PendingIntentUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/PowerUtils.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/PowerUtils.java
index 00d70950..e142c29e 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/PowerUtils.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/PowerUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -22,24 +22,37 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.os.BatteryManager;
+import android.os.PowerManager;
 
 /**
  * Created by Artem on 28.01.14.
  */
 public class PowerUtils {
 
-    public static boolean isConnected(Context context) {
+    /**
+     * @return true is device is charging at this moment, false otherwise.
+     */
+    public static boolean isCharging(Context context) {
         Intent intent = context.registerReceiver(null,
                 new IntentFilter(Intent.ACTION_BATTERY_CHANGED));
 
-        // TODO: I'm not sure if we need that.
         if (intent == null) {
             return false;
         }
 
+        final int status = intent.getIntExtra(BatteryManager.EXTRA_STATUS, -1);
+        return status == BatteryManager.BATTERY_STATUS_CHARGING;
+        /*
         final int plugged = intent.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1);
         return plugged == BatteryManager.BATTERY_PLUGGED_AC
-                || plugged == BatteryManager.BATTERY_PLUGGED_USB;
+                || plugged == BatteryManager.BATTERY_PLUGGED_USB
+                || plugged == BatteryManager.BATTERY_PLUGGED_WIRELESS;
+                */
+    }
+
+    public static boolean isScreenOn(Context context) {
+        PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
+        return pm.isScreenOn();
     }
 
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/ToastUtils.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/ToastUtils.java
new file mode 100644
index 00000000..ebe19c01
--- /dev/null
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/ToastUtils.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.activedisplay.utils;
+
+import android.content.Context;
+import android.widget.Toast;
+
+/**
+ * Created by Artem on 15.03.14.
+ */
+public class ToastUtils {
+
+    public static void showShort(Context context, CharSequence text) {
+        show(context, text, Toast.LENGTH_SHORT);
+    }
+
+    public static void showLong(Context context, CharSequence text) {
+        show(context, text, Toast.LENGTH_LONG);
+    }
+
+    private static void show(Context context, CharSequence text, int duration) {
+        Toast.makeText(context, text, duration).show();
+    }
+
+}
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/ViewUtils.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/ViewUtils.java
index 49fa1eb9..23b97ed8 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/ViewUtils.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/utils/ViewUtils.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -18,13 +18,10 @@
  */
 package com.achep.activedisplay.utils;
 
-import android.content.Context;
 import android.view.MotionEvent;
 import android.view.View;
 import android.widget.TextView;
 
-import com.achep.activedisplay.Config;
-
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
 
@@ -47,7 +44,7 @@ public class ViewUtils {
         view.getLocationInWindow(coordinates);
         int top = coordinates[1];
         decorView.getLocationInWindow(coordinates);
-        return top;
+        return top - coordinates[1];
     }
 
     public static int getBottom(View view, View decorView) {
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationPreviewLayout.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationPreviewLayout.java
index 34d4c7f5..cd1f0fb3 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationPreviewLayout.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationPreviewLayout.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationRadioButton.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationRadioButton.java
index 605b5b18..8df42c4f 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationRadioButton.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationRadioButton.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationView.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationView.java
index f02d3793..4c7918c9 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationView.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/NotificationView.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/DateView.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/TimeView.java
similarity index 56%
rename from project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/DateView.java
rename to project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/TimeView.java
index db8faccf..9a4ab047 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/DateView.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/TimeView.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2013 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -22,44 +22,35 @@ import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.text.format.Time;
 import android.util.AttributeSet;
 import android.widget.TextView;
 
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
+import com.achep.activedisplay.utils.DateUtils;
 
 /**
  * Created by Artem on 29.01.14.
  */
-public class DateView extends TextView {
+public class TimeView extends TextView {
 
-    private static final String TAG = "DateView";
+    private static final String TAG = "TimeView";
 
-    private final Date mCurrentTime = new Date();
-
-    private SimpleDateFormat mDateFormat;
-    private String mLastText;
+    private int mLastTime;
 
     private BroadcastReceiver mIntentReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
-            final String action = intent.getAction();
-            if (Intent.ACTION_TIME_TICK.equals(action)
-                    || Intent.ACTION_TIME_CHANGED.equals(action)
-                    || Intent.ACTION_TIMEZONE_CHANGED.equals(action)
-                    || Intent.ACTION_LOCALE_CHANGED.equals(action)) {
-                if (Intent.ACTION_LOCALE_CHANGED.equals(action)
-                        || Intent.ACTION_TIMEZONE_CHANGED.equals(action)) {
-                    // need to get a fresh date format
-                    mDateFormat = null;
-                }
-                updateClock();
+            switch (intent.getAction()) {
+                case Intent.ACTION_TIME_TICK:
+                case Intent.ACTION_TIME_CHANGED:
+                case Intent.ACTION_TIMEZONE_CHANGED:
+                    updateClock();
+                    break;
             }
         }
     };
 
-    public DateView(Context context, AttributeSet attrs) {
+    public TimeView(Context context, AttributeSet attrs) {
         super(context, attrs);
     }
 
@@ -71,7 +62,6 @@ public class DateView extends TextView {
         filter.addAction(Intent.ACTION_TIME_TICK);
         filter.addAction(Intent.ACTION_TIME_CHANGED);
         filter.addAction(Intent.ACTION_TIMEZONE_CHANGED);
-        filter.addAction(Intent.ACTION_LOCALE_CHANGED);
         getContext().registerReceiver(mIntentReceiver, filter, null, null);
 
         updateClock();
@@ -80,22 +70,17 @@ public class DateView extends TextView {
     @Override
     protected void onDetachedFromWindow() {
         super.onDetachedFromWindow();
-
-        mDateFormat = null; // reload the locale next time
         getContext().unregisterReceiver(mIntentReceiver);
     }
 
     protected void updateClock() {
-        if (mDateFormat == null) {
-            mDateFormat = new SimpleDateFormat("dd MM yyyy", Locale.getDefault());
-        }
-
-        mCurrentTime.setTime(System.currentTimeMillis());
+        Time time = new Time();
+        time.setToNow();
 
-        final String text = mDateFormat.format(mCurrentTime);
-        if (!text.equals(mLastText)) {
-            setText(text);
-            mLastText = text;
+        int now = time.hour * 60 + time.minute;
+        if (now != mLastTime) {
+            setText(DateUtils.formatTime(getContext(), time.hour, time.minute));
+            mLastTime = now;
         }
     }
 }
diff --git a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/WaveView.java b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/WaveView.java
index 9aa9844d..744b8619 100644
--- a/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/WaveView.java
+++ b/project/ActiveDisplay/src/main/java/com/achep/activedisplay/widgets/WaveView.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2013-2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
