diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/GetSshHostFingerprintTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/GetSshHostFingerprintTask.java
index c41a59fe8..93d0053f3 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/GetSshHostFingerprintTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/GetSshHostFingerprintTask.java
@@ -34,6 +34,7 @@ import com.amaze.filemanager.application.AppConfig;
 import com.amaze.filemanager.asynchronous.asynctasks.AsyncTaskResult;
 import com.amaze.filemanager.filesystem.ssh.CustomSshJConfig;
 import com.amaze.filemanager.filesystem.ssh.SshClientUtils;
+import com.amaze.filemanager.filesystem.ssh.SshConnectionPool;
 
 import android.app.ProgressDialog;
 import android.os.AsyncTask;
@@ -83,7 +84,7 @@ public class GetSshHostFingerprintTask extends AsyncTask<Void, Void, AsyncTaskRe
     final AtomicReference<AsyncTaskResult<PublicKey>> holder =
         new AtomicReference<AsyncTaskResult<PublicKey>>();
     final CountDownLatch latch = new CountDownLatch(1);
-    final SSHClient sshClient = new SSHClient(new CustomSshJConfig());
+    final SSHClient sshClient = SshConnectionPool.getSSHClientFactory().create(new CustomSshJConfig());
     sshClient.setConnectTimeout(SSH_CONNECT_TIMEOUT);
     sshClient.addHostKeyVerifier(
         (hostname, port, key) -> {
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/SshAuthenticationTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/SshAuthenticationTask.java
index 9f7c2a253..68a8bb427 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/SshAuthenticationTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/SshAuthenticationTask.java
@@ -33,6 +33,7 @@ import com.amaze.filemanager.R;
 import com.amaze.filemanager.application.AppConfig;
 import com.amaze.filemanager.asynchronous.asynctasks.AsyncTaskResult;
 import com.amaze.filemanager.filesystem.ssh.CustomSshJConfig;
+import com.amaze.filemanager.filesystem.ssh.SshConnectionPool;
 
 import android.app.AlertDialog;
 import android.os.AsyncTask;
@@ -115,7 +116,7 @@ public class SshAuthenticationTask extends AsyncTask<Void, Void, AsyncTaskResult
   @Override
   protected AsyncTaskResult<SSHClient> doInBackground(Void... voids) {
 
-    final SSHClient sshClient = new SSHClient(new CustomSshJConfig());
+    final SSHClient sshClient = SshConnectionPool.getSSHClientFactory().create(new CustomSshJConfig());
     sshClient.addHostKeyVerifier(hostKey);
     sshClient.setConnectTimeout(SSH_CONNECT_TIMEOUT);
 
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPool.java b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPool.java
index f494a042d..32791d0f7 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPool.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPool.java
@@ -41,6 +41,7 @@ import android.util.Log;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
+import net.schmizz.sshj.Config;
 import net.schmizz.sshj.SSHClient;
 
 /**
@@ -58,6 +59,8 @@ public class SshConnectionPool {
 
   private static final String TAG = SshConnectionPool.class.getSimpleName();
 
+  private static SSHClientFactory factory = new DefaultSSHClientFactory();
+
   private final Map<String, SSHClient> connections;
 
   private SshConnectionPool() {
@@ -77,6 +80,14 @@ public class SshConnectionPool {
     return SshConnectionPoolHolder.instance;
   }
 
+  public static void setSSHClientFactory(@NonNull SSHClientFactory sshClientFactory) {
+    factory = sshClientFactory;
+  }
+
+  public static final @NonNull SSHClientFactory getSSHClientFactory() {
+    return factory;
+  }
+
   /**
    * Remove a SSH connection from connection pool. Disconnects from server before removing.
    *
@@ -318,4 +329,16 @@ public class SshConnectionPool {
       if (callback != null) callback.run();
     }
   }
+
+  public interface SSHClientFactory {
+    @NonNull SSHClient create(Config config);
+  }
+
+  static class DefaultSSHClientFactory implements SSHClientFactory {
+    @NonNull
+    @Override
+    public SSHClient create(Config config) {
+      return new SSHClient(config);
+    }
+  }
 }
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPoolTest.java b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPoolTest.java
index 5286c5a99..caf7c0131 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPoolTest.java
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPoolTest.java
@@ -20,348 +20,423 @@
 
 package com.amaze.filemanager.filesystem.ssh;
 
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
 
-import java.io.IOException;
-import java.io.StringWriter;
-import java.security.PrivateKey;
+import com.amaze.filemanager.shadows.ShadowMultiDex;
+import com.amaze.filemanager.test.ShadowCryptUtil;
+import com.amaze.filemanager.utils.Utils;
+
+import net.schmizz.sshj.SSHClient;
+import net.schmizz.sshj.common.KeyType;
+import net.schmizz.sshj.common.SecurityUtils;
+import net.schmizz.sshj.userauth.UserAuthException;
+import net.schmizz.sshj.userauth.keyprovider.KeyProvider;
 
-import org.apache.sshd.server.SshServer;
-import org.apache.sshd.server.auth.pubkey.AcceptAllPublickeyAuthenticator;
-import org.bouncycastle.openssl.jcajce.JcaPEMWriter;
 import org.junit.After;
 import org.junit.BeforeClass;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
 
-import com.amaze.filemanager.database.UtilitiesDatabase;
-import com.amaze.filemanager.database.UtilsHandler;
-import com.amaze.filemanager.database.models.OperationData;
-import com.amaze.filemanager.filesystem.ssh.test.TestKeyProvider;
-import com.amaze.filemanager.shadows.ShadowMultiDex;
-import com.amaze.filemanager.test.ShadowCryptUtil;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.test.core.app.ApplicationProvider;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.io.IOException;
+import java.security.KeyPair;
+import java.security.PrivateKey;
+import java.security.PublicKey;
 
 import io.reactivex.plugins.RxJavaPlugins;
 import io.reactivex.schedulers.Schedulers;
-import net.schmizz.sshj.common.SecurityUtils;
+
+import static com.amaze.filemanager.filesystem.ssh.test.TestUtils.saveSshConnectionSettings;
+import static org.junit.Assert.assertNotNull;
+import static org.junit.Assert.assertNull;
+import static org.mockito.AdditionalMatchers.not;
+import static org.mockito.Matchers.eq;
+import static org.mockito.Mockito.atLeastOnce;
+import static org.mockito.Mockito.doNothing;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.mock;
+import static org.mockito.Mockito.never;
+import static org.mockito.Mockito.times;
+import static org.mockito.Mockito.verify;
 
 @RunWith(AndroidJUnit4.class)
 @Config(shadows = {ShadowMultiDex.class, ShadowCryptUtil.class})
 public class SshConnectionPoolTest {
 
-  private SshServer server;
-
-  private UtilitiesDatabase utilitiesDatabase;
-
-  private UtilsHandler utilsHandler;
+  private static KeyPair hostKeyPair, userKeyPair;
 
-  private static TestKeyProvider hostKeyProvider, userKeyProvider;
+  private static KeyProvider sshKeyProvider;
 
   @BeforeClass
   public static void bootstrap() throws Exception {
-    hostKeyProvider = new TestKeyProvider();
-    userKeyProvider = new TestKeyProvider();
+    hostKeyPair = com.amaze.filemanager.filesystem.ssh.test.TestUtils.createKeyPair();
+    userKeyPair = com.amaze.filemanager.filesystem.ssh.test.TestUtils.createKeyPair();
+    sshKeyProvider = new KeyProvider() {
+      @Override
+      public PrivateKey getPrivate() throws IOException {
+        return userKeyPair.getPrivate();
+      }
+
+      @Override
+      public PublicKey getPublic() throws IOException {
+        return userKeyPair.getPublic();
+      }
+
+      @Override
+      public KeyType getType() throws IOException {
+        return KeyType.RSA;
+      }
+
+      @Override
+      public boolean equals(@Nullable Object obj) {
+        if(obj == null || !(obj instanceof KeyProvider))
+          return false;
+        else {
+          KeyProvider other = (KeyProvider)obj;
+          try {
+            return other.getPrivate().equals(getPrivate()) && other.getPublic().equals(getPublic());
+          } catch (IOException shallNeverHappenHere) { return false; }
+
+        }
+      }
+    };
     RxJavaPlugins.reset();
     RxJavaPlugins.setIoSchedulerHandler(scheduler -> Schedulers.trampoline());
   }
 
   @After
   public void tearDown() {
-    if (server != null && server.isOpen()) server.close(true);
-    if (utilitiesDatabase != null && utilitiesDatabase.isOpen()) utilitiesDatabase.close();
+    SshConnectionPool.getInstance().shutdown();
   }
 
   @Test
   public void testGetConnectionWithUsernameAndPassword() throws IOException {
-    createSshServer("testuser", "testpassword");
+    SSHClient mock = createSshServer("testuser", "testpassword");
     assertNotNull(
         SshConnectionPool.getInstance()
             .getConnection(
                 "127.0.0.1",
                 22222,
-                SecurityUtils.getFingerprint(hostKeyProvider.getKeyPair().getPublic()),
+                SecurityUtils.getFingerprint(hostKeyPair.getPublic()),
                 "testuser",
                 "testpassword",
                 null));
-
     assertNull(
         SshConnectionPool.getInstance()
             .getConnection(
                 "127.0.0.1",
                 22222,
-                SecurityUtils.getFingerprint(hostKeyProvider.getKeyPair().getPublic()),
+                SecurityUtils.getFingerprint(hostKeyPair.getPublic()),
                 "invaliduser",
                 "invalidpassword",
                 null));
+
+    verify(mock, times(2)).addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
+    verify(mock, times(2)).connect("127.0.0.1", 22222);
+    verify(mock).authPassword("testuser", "testpassword");
+    verify(mock).authPassword("invaliduser", "invalidpassword");
   }
 
   @Test
   public void testGetConnectionWithUsernameAndKey() throws IOException {
-    createSshServer("testuser", null);
+    SSHClient mock = createSshServer("testuser", null);
     assertNotNull(
         SshConnectionPool.getInstance()
             .getConnection(
                 "127.0.0.1",
                 22222,
-                SecurityUtils.getFingerprint(hostKeyProvider.getKeyPair().getPublic()),
+                SecurityUtils.getFingerprint(hostKeyPair.getPublic()),
                 "testuser",
                 null,
-                userKeyProvider.getKeyPair()));
-
+                    userKeyPair));
+    SshConnectionPool.getInstance().shutdown();
     assertNull(
         SshConnectionPool.getInstance()
             .getConnection(
                 "127.0.0.1",
                 22222,
-                SecurityUtils.getFingerprint(hostKeyProvider.getKeyPair().getPublic()),
+                SecurityUtils.getFingerprint(hostKeyPair.getPublic()),
                 "invaliduser",
                 null,
-                userKeyProvider.getKeyPair()));
+                    userKeyPair));
+
+    verify(mock, times(2)).addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
+    verify(mock, times(2)).connect("127.0.0.1", 22222);
+    verify(mock).authPublickey("testuser", sshKeyProvider);
+    verify(mock).authPublickey("invaliduser", sshKeyProvider);
   }
 
   @Test
   public void testGetConnectionWithUrl() throws IOException {
     String validPassword = "testpassword";
-    createSshServer("testuser", validPassword);
-    saveSshConnectionSettings("testuser", validPassword, null);
+    SSHClient mock = createSshServer("testuser", validPassword);
+    saveSshConnectionSettings(hostKeyPair,"testuser", validPassword, null);
     assertNotNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://testuser:testpassword@127.0.0.1:22222"));
     assertNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://invaliduser:invalidpassword@127.0.0.1:22222"));
+
+    verify(mock, atLeastOnce()).addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
+    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
+    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
+    verify(mock).authPassword("testuser", "testpassword");
+    //invalid username won't give host key. Should never called this
+    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
   }
 
   @Test
   public void testGetConnectionWithUrlAndKeyAuth() throws IOException {
-    createSshServer("testuser", null);
-    saveSshConnectionSettings("testuser", null, userKeyProvider.getKeyPair().getPrivate());
+    SSHClient mock = createSshServer("testuser", null);
+    saveSshConnectionSettings(hostKeyPair, "testuser", null, userKeyPair.getPrivate());
     assertNotNull(SshConnectionPool.getInstance().getConnection("ssh://testuser@127.0.0.1:22222"));
     assertNull(SshConnectionPool.getInstance().getConnection("ssh://invaliduser@127.0.0.1:22222"));
+
+    verify(mock, atLeastOnce()).addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
+    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
+    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
+
+    verify(mock).authPublickey("testuser", sshKeyProvider);
+    //invalid username won't give host key. Should never called this
+    verify(mock, never()).authPublickey("invaliduser", sshKeyProvider);
   }
 
   @Test
   public void testGetConnectionWithUrlHavingComplexPassword1() throws IOException {
     String validPassword = "testP@ssw0rd";
-    createSshServer("testuser", validPassword);
-    saveSshConnectionSettings("testuser", validPassword, null);
+    SSHClient mock = createSshServer("testuser", validPassword);
+    saveSshConnectionSettings(hostKeyPair, "testuser", validPassword, null);
     assertNotNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://testuser:testP@ssw0rd@127.0.0.1:22222"));
     assertNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://invaliduser:invalidpassword@127.0.0.1:22222"));
+
+    verify(mock, atLeastOnce()).addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
+    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
+    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
+
+    verify(mock).authPassword("testuser", validPassword);
+    //invalid username won't give host key. Should never called this
+    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
   }
 
   @Test
   public void testGetConnectionWithUrlHavingComplexPassword2() throws IOException {
     String validPassword = "testP@##word";
-    createSshServer("testuser", validPassword);
-    saveSshConnectionSettings("testuser", validPassword, null);
+    SSHClient mock = createSshServer("testuser", validPassword);
+    saveSshConnectionSettings(hostKeyPair, "testuser", validPassword, null);
     assertNotNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://testuser:testP@##word@127.0.0.1:22222"));
     assertNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://invaliduser:invalidpassword@127.0.0.1:22222"));
+
+    verify(mock, atLeastOnce()).addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
+    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
+    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
+
+    verify(mock).authPassword("testuser", validPassword);
+    //invalid username won't give host key. Should never called this
+    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
   }
 
   @Test
   public void testGetConnectionWithUrlHavingComplexCredential1() throws IOException {
     String validPassword = "testP@##word";
-    createSshServer("testuser", validPassword);
-    saveSshConnectionSettings("testuser", validPassword, null);
+    SSHClient mock = createSshServer("testuser", validPassword);
+    saveSshConnectionSettings(hostKeyPair, "testuser", validPassword, null);
     assertNotNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://testuser:testP@##word@127.0.0.1:22222"));
     assertNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://invaliduser:invalidpassword@127.0.0.1:22222"));
+
+    verify(mock, atLeastOnce()).addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
+    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
+    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
+
+    verify(mock).authPassword("testuser", validPassword);
+    //invalid username won't give host key. Should never called this
+    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
   }
 
   @Test
   public void testGetConnectionWithUrlHavingComplexCredential2() throws IOException {
     String validPassword = "testP@##word";
-    createSshServer("testuser", validPassword);
-    saveSshConnectionSettings("testuser", validPassword, null);
+    SSHClient mock = createSshServer("testuser", validPassword);
+    saveSshConnectionSettings(hostKeyPair, "testuser", validPassword, null);
     assertNotNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://testuser:testP@##word@127.0.0.1:22222"));
     assertNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://invaliduser:invalidpassword@127.0.0.1:22222"));
+
+    verify(mock, atLeastOnce()).addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
+    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
+    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
+
+    verify(mock).authPassword("testuser", validPassword);
+    //invalid username won't give host key. Should never called this
+    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
   }
 
   @Test
   public void testGetConnectionWithUrlHavingComplexCredential3() throws IOException {
     String validUsername = "test@example.com";
     String validPassword = "testP@ssw0rd";
-    createSshServer(validUsername, validPassword);
-    saveSshConnectionSettings(validUsername, validPassword, null);
+    SSHClient mock = createSshServer(validUsername, validPassword);
+    saveSshConnectionSettings(hostKeyPair, validUsername, validPassword, null);
     assertNotNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://test@example.com:testP@ssw0rd@127.0.0.1:22222"));
     assertNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://invaliduser:invalidpassword@127.0.0.1:22222"));
+
+    verify(mock, atLeastOnce()).addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
+    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
+    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
+
+    verify(mock).authPassword(validUsername, validPassword);
+    //invalid username won't give host key. Should never called this
+    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
   }
 
   @Test
   public void testGetConnectionWithUrlHavingComplexCredential4() throws IOException {
     String validUsername = "test@example.com";
     String validPassword = "testP@ssw0##$";
-    createSshServer(validUsername, validPassword);
-    saveSshConnectionSettings(validUsername, validPassword, null);
+    SSHClient mock = createSshServer(validUsername, validPassword);
+    saveSshConnectionSettings(hostKeyPair, validUsername, validPassword, null);
     assertNotNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://test@example.com:testP@ssw0##$@127.0.0.1:22222"));
     assertNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://invaliduser:invalidpassword@127.0.0.1:22222"));
+
+    verify(mock, atLeastOnce()).addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
+    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
+    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
+
+    verify(mock).authPassword(validUsername, validPassword);
+    //invalid username won't give host key. Should never called this
+    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
   }
 
   @Test
   public void testGetConnectionWithUrlHavingMinusSignInPassword1() throws IOException {
     String validUsername = "test@example.com";
     String validPassword = "abcd-efgh";
-    createSshServer(validUsername, validPassword);
-    saveSshConnectionSettings(validUsername, validPassword, null);
+    SSHClient mock = createSshServer(validUsername, validPassword);
+    saveSshConnectionSettings(hostKeyPair, validUsername, validPassword, null);
     assertNotNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://test@example.com:abcd-efgh@127.0.0.1:22222"));
     assertNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://invaliduser:invalidpassword@127.0.0.1:22222"));
+
+    verify(mock, atLeastOnce()).addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
+    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
+    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
+
+    verify(mock).authPassword(validUsername, validPassword);
+    //invalid username won't give host key. Should never called this
+    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
   }
 
   @Test
   public void testGetConnectionWithUrlHavingMinusSignInPassword2() throws IOException {
     String validUsername = "test@example.com";
     String validPassword = "---------------";
-    createSshServer(validUsername, validPassword);
-    saveSshConnectionSettings(validUsername, validPassword, null);
+    SSHClient mock = createSshServer(validUsername, validPassword);
+    saveSshConnectionSettings(hostKeyPair, validUsername, validPassword, null);
     assertNotNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://test@example.com:---------------@127.0.0.1:22222"));
     assertNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://invaliduser:invalidpassword@127.0.0.1:22222"));
+
+    verify(mock, atLeastOnce()).addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
+    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
+    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
+
+    verify(mock).authPassword(validUsername, validPassword);
+    //invalid username won't give host key. Should never called this
+    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
   }
 
   @Test
   public void testGetConnectionWithUrlHavingMinusSignInPassword3() throws IOException {
     String validUsername = "test@example.com";
     String validPassword = "--agdiuhdpost15";
-    createSshServer(validUsername, validPassword);
-    saveSshConnectionSettings(validUsername, validPassword, null);
+    SSHClient mock = createSshServer(validUsername, validPassword);
+    saveSshConnectionSettings(hostKeyPair, validUsername, validPassword, null);
     assertNotNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://test@example.com:--agdiuhdpost15@127.0.0.1:22222"));
     assertNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://invaliduser:invalidpassword@127.0.0.1:22222"));
+
+    verify(mock, atLeastOnce()).addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
+    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
+    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
+
+    verify(mock).authPassword(validUsername, validPassword);
+    //invalid username won't give host key. Should never called this
+    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
   }
 
   @Test
   public void testGetConnectionWithUrlHavingMinusSignInPassword4() throws IOException {
     String validUsername = "test@example.com";
     String validPassword = "t-h-i-s-i-s-p-a-s-s-w-o-r-d-";
-    createSshServer(validUsername, validPassword);
-    saveSshConnectionSettings(validUsername, validPassword, null);
+    SSHClient mock = createSshServer(validUsername, validPassword);
+    saveSshConnectionSettings(hostKeyPair, validUsername, validPassword, null);
     assertNotNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://test@example.com:t-h-i-s-i-s-p-a-s-s-w-o-r-d-@127.0.0.1:22222"));
     assertNull(
         SshConnectionPool.getInstance()
             .getConnection("ssh://invaliduser:invalidpassword@127.0.0.1:22222"));
+
+    verify(mock, atLeastOnce()).addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
+    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
+    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
+
+    verify(mock).authPassword(validUsername, validPassword);
+    //invalid username won't give host key. Should never called this
+    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
   }
 
-  private void createSshServer(@NonNull String validUsername, @Nullable String validPassword)
+  private SSHClient createSshServer(@NonNull String validUsername, @Nullable String validPassword)
       throws IOException {
-    server = SshServer.setUpDefaultServer();
-    server.setPublickeyAuthenticator(AcceptAllPublickeyAuthenticator.INSTANCE);
-    server.setPort(22222);
-    server.setHost("127.0.0.1");
-    server.setKeyPairProvider(hostKeyProvider);
-    if (validPassword != null)
-      server.setPasswordAuthenticator(
-          ((username, password, session) ->
-              username.equals(validUsername) && password.equals(validPassword)));
-    server.setPublickeyAuthenticator(
-        (username, key, session) ->
-            username.equals(validUsername) && key.equals(userKeyProvider.getKeyPair().getPublic()));
-    server.start();
-  }
 
-  private void saveSshConnectionSettings(
-      @NonNull String validUsername,
-      @Nullable String validPassword,
-      @Nullable PrivateKey privateKey) {
-    utilitiesDatabase = UtilitiesDatabase.initialize(ApplicationProvider.getApplicationContext());
-    utilsHandler = new UtilsHandler(ApplicationProvider.getApplicationContext(), utilitiesDatabase);
-
-    String privateKeyContents = null;
-    if (privateKey != null) {
-      StringWriter writer = new StringWriter();
-      JcaPEMWriter jw = new JcaPEMWriter(writer);
-      try {
-        jw.writeObject(userKeyProvider.getKeyPair().getPrivate());
-        jw.flush();
-        jw.close();
-      } catch (IOException shallNeverHappen) {
-      }
-      privateKeyContents = writer.toString();
+    SSHClient mock = mock(SSHClient.class);
+    doNothing().when(mock).connect("127.0.0.1", 22222);
+    doNothing().when(mock).addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
+    doNothing().when(mock).disconnect();
+    if(!Utils.isNullOrEmpty(validPassword)) {
+      doNothing().when(mock).authPassword(validUsername, validPassword);
+      doThrow(new UserAuthException("Invalid login/password")).when(mock).authPassword(not(eq(validUsername)), not(eq(validPassword)));
     }
-
-    StringBuilder fullUri = new StringBuilder().append("ssh://").append(validUsername);
-
-    if (validPassword != null) fullUri.append(':').append(validPassword);
-
-    fullUri.append("@127.0.0.1:22222");
-
-    if (validPassword != null)
-      utilsHandler.saveToDatabase(
-          new OperationData(
-              UtilsHandler.Operation.SFTP,
-              SshClientUtils.encryptSshPathAsNecessary(fullUri.toString()),
-              "Test",
-              SecurityUtils.getFingerprint(hostKeyProvider.getKeyPair().getPublic()),
-              null,
-              null));
-    else
-      utilsHandler.saveToDatabase(
-          new OperationData(
-              UtilsHandler.Operation.SFTP,
-              SshClientUtils.encryptSshPathAsNecessary(fullUri.toString()),
-              "Test",
-              SecurityUtils.getFingerprint(hostKeyProvider.getKeyPair().getPublic()),
-              "id_rsa",
-              privateKeyContents));
-  }
-
-  @Test
-  public void testConnectionInfoCreate() {
-    SshConnectionPool.ConnectionInfo conn =
-        new SshConnectionPool.ConnectionInfo("ssh://toor:root@127.0.0.1:2468");
-    assertEquals("toor", conn.username);
-    assertEquals("root", conn.password);
-    assertEquals("127.0.0.1", conn.host);
-    assertEquals(2468, conn.port);
-    assertNull(conn.defaultPath);
-
-    conn = new SshConnectionPool.ConnectionInfo("ssh://root:root@127.0.0.1:3268/home/root");
-    assertEquals("root", conn.username);
-    assertEquals("root", conn.password);
-    assertEquals("127.0.0.1", conn.host);
-    assertEquals(3268, conn.port);
-    assertEquals("/home/root", conn.defaultPath);
+    else {
+      doNothing().when(mock).authPublickey(validUsername, sshKeyProvider);
+      doThrow(new UserAuthException("Invalid key")).when(mock).authPublickey(not(eq(validUsername)), eq(sshKeyProvider));
+    }
+    //reset(mock);
+    SshConnectionPool.setSSHClientFactory(config -> mock);
+    return mock;
   }
 }
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/test/TestUtils.java b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/test/TestUtils.java
new file mode 100644
index 000000000..d0652e5ac
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/test/TestUtils.java
@@ -0,0 +1,79 @@
+package com.amaze.filemanager.filesystem.ssh.test;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.test.core.app.ApplicationProvider;
+
+import com.amaze.filemanager.database.UtilitiesDatabase;
+import com.amaze.filemanager.database.UtilsHandler;
+import com.amaze.filemanager.database.models.OperationData;
+import com.amaze.filemanager.filesystem.ssh.SshClientUtils;
+
+import net.schmizz.sshj.common.SecurityUtils;
+
+import org.bouncycastle.openssl.jcajce.JcaPEMWriter;
+
+import java.io.IOException;
+import java.io.StringWriter;
+import java.security.KeyPair;
+import java.security.KeyPairGenerator;
+import java.security.NoSuchAlgorithmException;
+import java.security.PrivateKey;
+import java.security.SecureRandom;
+
+public class TestUtils {
+
+    public static KeyPair createKeyPair() throws NoSuchAlgorithmException {
+        KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
+        keyPairGenerator.initialize(1024, new SecureRandom());
+        return keyPairGenerator.generateKeyPair();
+    }
+
+    public static void saveSshConnectionSettings(
+            @NonNull KeyPair hostKeyPair,
+            @NonNull String validUsername,
+            @Nullable String validPassword,
+            @Nullable PrivateKey privateKey) {
+        UtilitiesDatabase utilitiesDatabase = UtilitiesDatabase.initialize(ApplicationProvider.getApplicationContext());
+        UtilsHandler utilsHandler = new UtilsHandler(ApplicationProvider.getApplicationContext(), utilitiesDatabase);
+
+        String privateKeyContents = null;
+        if (privateKey != null) {
+            StringWriter writer = new StringWriter();
+            JcaPEMWriter jw = new JcaPEMWriter(writer);
+            try {
+                jw.writeObject(privateKey);
+                jw.flush();
+                jw.close();
+            } catch (IOException shallNeverHappen) {
+            }
+            privateKeyContents = writer.toString();
+        }
+
+        StringBuilder fullUri = new StringBuilder().append("ssh://").append(validUsername);
+
+        if (validPassword != null) fullUri.append(':').append(validPassword);
+
+        fullUri.append("@127.0.0.1:22222");
+
+        if (validPassword != null)
+            utilsHandler.saveToDatabase(
+                    new OperationData(
+                            UtilsHandler.Operation.SFTP,
+                            SshClientUtils.encryptSshPathAsNecessary(fullUri.toString()),
+                            "Test",
+                            SecurityUtils.getFingerprint(hostKeyPair.getPublic()),
+                            null,
+                            null));
+        else
+            utilsHandler.saveToDatabase(
+                    new OperationData(
+                            UtilsHandler.Operation.SFTP,
+                            SshClientUtils.encryptSshPathAsNecessary(fullUri.toString()),
+                            "Test",
+                            SecurityUtils.getFingerprint(hostKeyPair.getPublic()),
+                            "id_rsa",
+                            privateKeyContents));
+
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/ui/activities/AbstractMainActivityTest.java b/app/src/test/java/com/amaze/filemanager/ui/activities/AbstractMainActivityTest.java
new file mode 100644
index 000000000..a1a095fa9
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/ui/activities/AbstractMainActivityTest.java
@@ -0,0 +1,70 @@
+package com.amaze.filemanager.ui.activities;
+
+import android.os.Build;
+import android.os.storage.StorageManager;
+
+import androidx.lifecycle.Lifecycle;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+
+import com.amaze.filemanager.shadows.ShadowMultiDex;
+import com.amaze.filemanager.test.TestUtils;
+
+import org.junit.After;
+import org.junit.Before;
+import org.junit.BeforeClass;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+import org.robolectric.annotation.LooperMode;
+import org.robolectric.shadows.ShadowLooper;
+import org.robolectric.shadows.ShadowStorageManager;
+
+import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.schedulers.Schedulers;
+
+import static android.os.Build.VERSION_CODES.N;
+import static androidx.test.core.app.ActivityScenario.launch;
+import static org.robolectric.Shadows.shadowOf;
+
+/*
+ * Need to make LooperMode PAUSED and flush the main looper before activity can show up.
+ * @see {@link LooperMode.Mode.PAUSED}
+ * @see {@link <a href="https://stackoverflow.com/questions/55679636/robolectric-throws-fragmentmanager-is-already-executing-transactions">StackOverflow discussion</a>}
+ */
+@LooperMode(LooperMode.Mode.PAUSED)
+@RunWith(AndroidJUnit4.class)
+@Config(
+        shadows = {
+                ShadowMultiDex.class,
+                ShadowStorageManager.class})
+public abstract class AbstractMainActivityTest {
+
+    protected ActivityScenario<MainActivity> scenario;
+
+    @BeforeClass
+    public static void setUpBeforeClass() {
+        RxJavaPlugins.reset();
+        RxJavaPlugins.setIoSchedulerHandler(scheduler -> Schedulers.trampoline());
+    }
+
+    @Before
+    public void setUp() {
+        if (Build.VERSION.SDK_INT >= N) TestUtils.initializeInternalStorage();
+
+        ShadowLooper.idleMainLooper();
+        scenario = launch(MainActivity.class);
+        scenario.moveToState(Lifecycle.State.STARTED);
+    }
+
+    @After
+    public void tearDown() {
+
+        scenario.moveToState(Lifecycle.State.DESTROYED);
+        scenario.close();
+
+        if (Build.VERSION.SDK_INT >= N)
+            shadowOf(ApplicationProvider.getApplicationContext().getSystemService(StorageManager.class))
+                    .resetStorageVolumeList();
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/ui/activities/MainActivityTest.java b/app/src/test/java/com/amaze/filemanager/ui/activities/MainActivityTest.java
index 36413585d..d779015bf 100644
--- a/app/src/test/java/com/amaze/filemanager/ui/activities/MainActivityTest.java
+++ b/app/src/test/java/com/amaze/filemanager/ui/activities/MainActivityTest.java
@@ -20,88 +20,38 @@
 
 package com.amaze.filemanager.ui.activities;
 
-import static android.os.Build.VERSION_CODES.N;
-import static androidx.test.core.app.ActivityScenario.launch;
-import static org.awaitility.Awaitility.await;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
-import static org.robolectric.Shadows.shadowOf;
-
-import java.io.IOException;
-import java.security.GeneralSecurityException;
-import java.util.List;
-import java.util.concurrent.TimeUnit;
-
-import org.junit.After;
-import org.junit.Before;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
-import org.robolectric.annotation.LooperMode;
-import org.robolectric.shadows.ShadowLooper;
-import org.robolectric.shadows.ShadowStorageManager;
+import androidx.lifecycle.Lifecycle;
+import androidx.test.core.app.ActivityScenario;
+import androidx.test.core.app.ApplicationProvider;
 
 import com.amaze.filemanager.application.AppConfig;
-import com.amaze.filemanager.shadows.ShadowMultiDex;
 import com.amaze.filemanager.shadows.jcifs.smb.ShadowSmbFile;
 import com.amaze.filemanager.test.ShadowCryptUtil;
-import com.amaze.filemanager.test.TestUtils;
 import com.amaze.filemanager.utils.SmbUtil;
 
-import android.os.Build;
-import android.os.storage.StorageManager;
+import org.junit.Test;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLooper;
 
-import androidx.lifecycle.Lifecycle;
-import androidx.test.core.app.ActivityScenario;
-import androidx.test.core.app.ApplicationProvider;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+import java.util.List;
+import java.util.concurrent.TimeUnit;
 
-import io.reactivex.plugins.RxJavaPlugins;
-import io.reactivex.schedulers.Schedulers;
+import static androidx.test.core.app.ActivityScenario.launch;
+import static org.awaitility.Awaitility.await;
+import static org.junit.Assert.assertEquals;
+import static org.junit.Assert.fail;
 
-@RunWith(AndroidJUnit4.class)
 @Config(
     shadows = {
-      ShadowMultiDex.class,
-      ShadowStorageManager.class,
       ShadowCryptUtil.class,
       ShadowSmbFile.class
     })
-/*
- * Need to make LooperMode PAUSED and flush the main looper before activity can show up.
- * @see {@link LooperMode.Mode.PAUSED}
- * @see {@link <a href="https://stackoverflow.com/questions/55679636/robolectric-throws-fragmentmanager-is-already-executing-transactions">StackOverflow discussion</a>}
- */
-@LooperMode(LooperMode.Mode.PAUSED)
-public class MainActivityTest {
-
-  @BeforeClass
-  public static void setUpBeforeClass() {
-    RxJavaPlugins.reset();
-    RxJavaPlugins.setIoSchedulerHandler(scheduler -> Schedulers.trampoline());
-  }
-
-  @Before
-  public void setUp() {
-    if (Build.VERSION.SDK_INT >= N) TestUtils.initializeInternalStorage();
-  }
-
-  @After
-  public void tearDown() {
-    if (Build.VERSION.SDK_INT >= N)
-      shadowOf(ApplicationProvider.getApplicationContext().getSystemService(StorageManager.class))
-          .resetStorageVolumeList();
-  }
+public class MainActivityTest extends AbstractMainActivityTest {
 
   @Test
   public void testUpdateSmbExceptionShouldNotThrowNPE() {
-    ActivityScenario<MainActivity> scenario = launch(MainActivity.class);
-
-    ShadowLooper.idleMainLooper();
-
-    scenario.moveToState(Lifecycle.State.STARTED);
-
     scenario.onActivity(
         activity -> {
           String path = "smb://root:toor@192.168.1.1";
@@ -145,9 +95,6 @@ public class MainActivityTest {
 
           } catch (GeneralSecurityException | IOException e) {
             fail(e.getMessage());
-          } finally {
-            scenario.moveToState(Lifecycle.State.DESTROYED);
-            scenario.close();
           }
         });
   }
diff --git a/app/src/test/java/com/amaze/filemanager/ui/dialogs/SftpConnectDialogTest.java b/app/src/test/java/com/amaze/filemanager/ui/dialogs/SftpConnectDialogTest.java
new file mode 100644
index 000000000..acedaee81
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/ui/dialogs/SftpConnectDialogTest.java
@@ -0,0 +1,151 @@
+package com.amaze.filemanager.ui.dialogs;
+
+import android.os.Bundle;
+import android.view.View;
+import android.widget.Button;
+import android.widget.EditText;
+
+import androidx.annotation.NonNull;
+import androidx.annotation.Nullable;
+import androidx.test.ext.junit.runners.AndroidJUnit4;
+
+import com.afollestad.materialdialogs.DialogAction;
+import com.afollestad.materialdialogs.MaterialDialog;
+import com.amaze.filemanager.R;
+import com.amaze.filemanager.filesystem.ssh.SshConnectionPool;
+import com.amaze.filemanager.shadows.ShadowMultiDex;
+import com.amaze.filemanager.ui.activities.AbstractMainActivityTest;
+import com.amaze.filemanager.utils.Utils;
+
+import net.schmizz.sshj.SSHClient;
+import net.schmizz.sshj.common.KeyType;
+import net.schmizz.sshj.common.SecurityUtils;
+import net.schmizz.sshj.userauth.UserAuthException;
+import net.schmizz.sshj.userauth.keyprovider.KeyProvider;
+
+import org.junit.BeforeClass;
+import org.junit.Ignore;
+import org.junit.Test;
+import org.junit.runner.RunWith;
+import org.robolectric.annotation.Config;
+import org.robolectric.shadows.ShadowLooper;
+import org.robolectric.shadows.ShadowStorageManager;
+
+import java.io.IOException;
+import java.security.KeyPair;
+import java.security.PrivateKey;
+import java.security.PublicKey;
+
+import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.schedulers.Schedulers;
+
+import static android.os.Build.VERSION_CODES.KITKAT;
+import static org.mockito.AdditionalMatchers.not;
+import static org.mockito.ArgumentMatchers.eq;
+import static org.mockito.Mockito.doNothing;
+import static org.mockito.Mockito.doThrow;
+import static org.mockito.Mockito.mock;
+
+@RunWith(AndroidJUnit4.class)
+@Config(minSdk = KITKAT,
+        shadows = {
+                ShadowMultiDex.class,
+                ShadowStorageManager.class
+})
+@Ignore("Pending SSH infra classes refactoring")
+public class SftpConnectDialogTest extends AbstractMainActivityTest {
+
+    private static KeyPair hostKeyPair, userKeyPair;
+
+    private static KeyProvider sshKeyProvider;
+
+    @BeforeClass
+    public static void bootstrap() throws Exception {
+        hostKeyPair = com.amaze.filemanager.filesystem.ssh.test.TestUtils.createKeyPair();
+        userKeyPair = com.amaze.filemanager.filesystem.ssh.test.TestUtils.createKeyPair();
+        sshKeyProvider = new KeyProvider() {
+            @Override
+            public PrivateKey getPrivate() throws IOException {
+                return userKeyPair.getPrivate();
+            }
+
+            @Override
+            public PublicKey getPublic() throws IOException {
+                return userKeyPair.getPublic();
+            }
+
+            @Override
+            public KeyType getType() throws IOException {
+                return KeyType.RSA;
+            }
+
+            @Override
+            public boolean equals(@Nullable Object obj) {
+                if(obj == null || !(obj instanceof KeyProvider))
+                    return false;
+                else {
+                    KeyProvider other = (KeyProvider)obj;
+                    try {
+                        return other.getPrivate().equals(getPrivate()) && other.getPublic().equals(getPublic());
+                    } catch (IOException shallNeverHappenHere) { return false; }
+
+                }
+            }
+        };
+        RxJavaPlugins.reset();
+        RxJavaPlugins.setIoSchedulerHandler(scheduler -> Schedulers.trampoline());
+    }
+
+    @Test
+    public void testCreateConnectionDialog() {
+        scenario.onActivity(activity -> {
+            SftpConnectDialog dialog = new SftpConnectDialog();
+            dialog.setArguments(new Bundle());
+            dialog.show(activity.getFragmentManager(), "sftpdialog");
+
+            ShadowLooper.idleMainLooper();
+
+            MaterialDialog md = (MaterialDialog)dialog.getDialog();
+
+            View view = md.getView();
+            EditText connectionET = view.findViewById(R.id.connectionET);
+            EditText addressET = view.findViewById(R.id.ipET);
+            EditText portET = view.findViewById(R.id.portET);
+            EditText defaultPathET = view.findViewById(R.id.defaultPathET);
+            EditText usernameET = view.findViewById(R.id.usernameET);
+            EditText passwordET = view.findViewById(R.id.passwordET);
+            Button selectPemBTN = view.findViewById(R.id.selectPemBTN);
+
+            connectionET.setText("Test connection");
+            addressET.setText("1.2.3.4");
+            portET.setText("22");
+            usernameET.setText("user");
+            passwordET.setText("password");
+
+
+            md.getActionButton(DialogAction.POSITIVE).callOnClick();
+
+//            dialog.dismissAllowingStateLoss();
+        });
+    }
+
+    private SSHClient createSshServer(@NonNull String validUsername, @Nullable String validPassword)
+            throws IOException {
+
+        SSHClient mock = mock(SSHClient.class);
+        doNothing().when(mock).connect("1.2.3.4", 22);
+        doNothing().when(mock).addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
+        doNothing().when(mock).disconnect();
+        if(!Utils.isNullOrEmpty(validPassword)) {
+            doNothing().when(mock).authPassword(validUsername, validPassword);
+            doThrow(new UserAuthException("Invalid login/password")).when(mock).authPassword(not(eq(validUsername)), not(eq(validPassword)));
+        }
+        else {
+            doNothing().when(mock).authPublickey(validUsername, sshKeyProvider);
+            doThrow(new UserAuthException("Invalid key")).when(mock).authPublickey(not(eq(validUsername)), eq(sshKeyProvider));
+        }
+        //reset(mock);
+        SshConnectionPool.setSSHClientFactory(config -> mock);
+        return mock;
+    }
+}
