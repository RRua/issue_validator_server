diff --git a/qDict/src/main/java/com/annie/dictionary/BaseActivity.java b/qDict/src/main/java/com/annie/dictionary/BaseActivity.java
deleted file mode 100644
index 45d2808..0000000
--- a/qDict/src/main/java/com/annie/dictionary/BaseActivity.java
+++ /dev/null
@@ -1,229 +0,0 @@
-package com.annie.dictionary;
-
-import android.Manifest;
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.content.res.Configuration;
-import android.net.Uri;
-import android.os.Bundle;
-import android.provider.Settings;
-import android.text.TextUtils;
-import android.view.MenuItem;
-import android.view.View;
-import android.view.Window;
-import android.view.WindowManager;
-
-import androidx.annotation.NonNull;
-import androidx.fragment.app.Fragment;
-import androidx.fragment.app.FragmentTransaction;
-
-import com.annie.dictionary.frags.ListDictFragment;
-import com.annie.dictionary.frags.NavigatorFragment;
-import com.annie.dictionary.utils.Utils;
-import com.annie.dictionary.utils.Utils.Def;
-import com.mmt.app.SlidingFragmentActivity;
-import com.mmt.app.SystemBarTintManager;
-import com.mmt.widget.slidemenu.SlidingMenu;
-import com.mmt.widget.slidemenu.SlidingMenu.OnClosedListener;
-
-import java.util.Locale;
-
-public abstract class BaseActivity extends SlidingFragmentActivity {
-
-    public final static int REQUEST_STORAGE_CODE = 1001;
-    public final static int REQUEST_ALERT_WINDOW_CODE = 1003;
-    /**
-     * Read and write permission for storage listed here.
-     */
-    public static String STORAGE_PERMISSIONS[] = new String[]{
-            Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE
-    };
-    protected Fragment mFrag;
-    protected SharedPreferences mSharedPreferences;
-    protected int mThemeIndex;
-    String mCurrentLanguage;
-    OnClosedListener mOnClosedListener = () -> onMenuClose();
-
-    public void checkPermission(int requestCode) {
-        switch (requestCode) {
-            case REQUEST_STORAGE_CODE:
-                if (Utils.hasSelfPermission(this, STORAGE_PERMISSIONS))
-                    onRequestPermissionResult(requestCode, true);
-                else
-                    requestPermissions(STORAGE_PERMISSIONS, requestCode);
-                break;
-            case REQUEST_ALERT_WINDOW_CODE:
-                if (!Utils.hasMmAbove()) {
-                    onRequestPermissionResult(REQUEST_ALERT_WINDOW_CODE, true);
-                } else {
-                    if (Settings.canDrawOverlays(this)) {
-                        onRequestPermissionResult(REQUEST_ALERT_WINDOW_CODE, true);
-                    } else {
-                        Intent drawOverlaysSettingsIntent = new Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION);
-                        drawOverlaysSettingsIntent.setData(Uri.parse("package:" + getPackageName()));
-                        startActivityForResult(drawOverlaysSettingsIntent, REQUEST_ALERT_WINDOW_CODE);
-                    }
-                }
-                break;
-            default:
-                break;
-        }
-    }
-
-    public abstract void onRequestPermissionResult(int requestCode, boolean isSucess);
-
-    @Override
-    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
-        switch (requestCode) {
-            case REQUEST_STORAGE_CODE:
-            case REQUEST_ALERT_WINDOW_CODE:
-                onRequestPermissionResult(requestCode, Utils.verifyAllPermissions(grantResults));
-                break;
-            default:
-                super.onRequestPermissionsResult(requestCode, permissions, grantResults);
-                break;
-        }
-    }
-
-    @Override
-    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-        if (requestCode == REQUEST_ALERT_WINDOW_CODE) {
-            onRequestPermissionResult(REQUEST_ALERT_WINDOW_CODE, Settings.canDrawOverlays(this));
-        } else {
-            super.onActivityResult(requestCode, resultCode, data);
-        }
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        mSharedPreferences = getSharedPreferences(Def.APP_NAME, Context.MODE_PRIVATE);
-        setLanguage();
-        mThemeIndex = mSharedPreferences.getInt("prefs_key_theme", 0);
-        Utils.onActivityCreateSetTheme(this, mThemeIndex, Utils.ThemeActivity.HOME);
-        super.onCreate(savedInstanceState);
-        setTitle(R.string.app_name);
-        if (Utils.hasKk()) {
-            setTranslucentStatus(true);
-            SystemBarTintManager tintManager = new SystemBarTintManager(this);
-            tintManager.setStatusBarTintEnabled(true);
-            tintManager.setStatusBarTintColor(Utils.getColor(this, R.attr.colorPrimaryDark));
-        }
-        // set the Behind View
-        setBehindContentView(R.layout.menu_frame);
-        // float density = getResources().getDisplayMetrics().density;
-        boolean headerShow;
-        try {
-            headerShow = getResources().getBoolean(R.bool.header_menu_visiable);
-        } catch (Exception e) {
-            headerShow = false;
-        }
-        findViewById(R.id.img_header).setVisibility(headerShow ? View.VISIBLE : View.GONE);
-        if (savedInstanceState == null) {
-            FragmentTransaction t = this.getSupportFragmentManager().beginTransaction();
-            mFrag = new NavigatorFragment();
-            t.replace(R.id.menu_frame, mFrag);
-            t.commit();
-        } else {
-            mFrag = this.getSupportFragmentManager().findFragmentById(R.id.menu_frame);
-        }
-        // customize the SlidingMenu
-        SlidingMenu sm = getSlidingMenu();
-        sm.setShadowWidthRes(R.dimen.shadow_width);
-        sm.setShadowDrawable(R.drawable.shadow);
-        sm.setBehindOffsetRes(R.dimen.slidingmenu_offset);
-        sm.setFadeDegree(0.35f);
-        sm.setTouchModeAbove(SlidingMenu.TOUCHMODE_FULLSCREEN);
-        sm.setOnClosedListener(mOnClosedListener);
-    }
-
-    public abstract void onMenuClose();
-
-    private void setLanguage() {
-        String language = mSharedPreferences.getString("prefs_key_languages", "");
-        Configuration configuration = getResources().getConfiguration();
-        String lang = configuration.locale.getLanguage();
-        if (TextUtils.isEmpty(language)) {
-            if (lang.equalsIgnoreCase("zh")) {
-                String country = configuration.locale.getCountry();
-                lang += "_" + country.toUpperCase(Locale.US);
-            }
-            language = lang;
-            if (Utils.checkLanguageSupport(language)) {
-                mSharedPreferences.edit().putString("prefs_key_languages", language).apply();
-                if (language.contains("_")) {
-                    String[] s = language.split("_");
-                    Utils.changeLocale(getResources(), s[0], s[1]);
-                } else {
-                    Utils.changeLocale(getResources(), language);
-                }
-
-            }
-        } else if (!language.contains(lang)) {
-            if (language.contains("_")) {
-                String[] s = language.split("_");
-                Utils.changeLocale(getResources(), s[0], s[1]);
-            } else {
-                Utils.changeLocale(getResources(), language);
-            }
-        }
-        mCurrentLanguage = language;
-    }
-
-    @TargetApi(19)
-    private void setTranslucentStatus(boolean on) {
-        Window win = getWindow();
-        WindowManager.LayoutParams winParams = win.getAttributes();
-        final int bits = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS;
-        if (on) {
-            winParams.flags |= bits;
-        } else {
-            winParams.flags &= ~bits;
-        }
-        win.setAttributes(winParams);
-    }
-
-    @Override
-    protected void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-    }
-
-    public void backMainMenuFragment() {
-        FragmentTransaction t = this.getSupportFragmentManager().beginTransaction();
-        t.setCustomAnimations(R.anim.push_right_in, R.anim.push_right_out, R.anim.push_left_in, R.anim.push_left_out);
-        if (mFrag instanceof ListDictFragment) {
-            mFrag = new NavigatorFragment();
-        }
-        t.replace(R.id.menu_frame, mFrag);
-        t.commit();
-    }
-
-    @Override
-    public void resroteDefaultFragment() {
-        if (mFrag instanceof ListDictFragment) {
-            FragmentTransaction t = this.getSupportFragmentManager().beginTransaction();
-            mFrag = new NavigatorFragment();
-            t.replace(R.id.menu_frame, mFrag);
-            t.commit();
-        }
-    }
-
-    public void setMenuFragment(Fragment fragment) {
-        FragmentTransaction t = this.getSupportFragmentManager().beginTransaction();
-        mFrag = fragment;
-        t.setCustomAnimations(R.anim.push_left_in, R.anim.push_left_out, R.anim.push_right_in, R.anim.push_right_out);
-        t.replace(R.id.menu_frame, fragment);
-        t.commit();
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        switch (item.getItemId()) {
-            case android.R.id.home:
-                toggle();
-                return true;
-        }
-        return super.onOptionsItemSelected(item);
-    }
-}
diff --git a/qDict/src/main/java/com/annie/dictionary/BaseActivity.kt b/qDict/src/main/java/com/annie/dictionary/BaseActivity.kt
new file mode 100644
index 0000000..ec151bf
--- /dev/null
+++ b/qDict/src/main/java/com/annie/dictionary/BaseActivity.kt
@@ -0,0 +1,135 @@
+package com.annie.dictionary
+
+import android.Manifest
+import android.annotation.TargetApi
+import android.content.Context
+import android.content.Intent
+import android.content.SharedPreferences
+import android.net.Uri
+import android.os.Bundle
+import android.provider.Settings
+import android.text.TextUtils
+import android.view.MenuItem
+import android.view.WindowManager
+import androidx.appcompat.app.AppCompatActivity
+import com.annie.dictionary.utils.Utils
+import com.annie.dictionary.utils.Utils.Def
+import com.mmt.app.SystemBarTintManager
+import java.util.*
+
+abstract class BaseActivity : AppCompatActivity() {
+    protected var mSharedPreferences: SharedPreferences? = null
+    private var mThemeIndex: Int = 0
+    private var mCurrentLanguage: String? = null
+
+    fun checkPermission(requestCode: Int) {
+        when (requestCode) {
+            REQUEST_STORAGE_CODE -> if (Utils.hasSelfPermission(this, STORAGE_PERMISSIONS))
+                onRequestPermissionResult(requestCode, true)
+            else
+                if (Utils.hasMmAbove()) {
+                    requestPermissions(STORAGE_PERMISSIONS, requestCode)
+                }
+            REQUEST_ALERT_WINDOW_CODE -> if (!Utils.hasMmAbove()) {
+                onRequestPermissionResult(REQUEST_ALERT_WINDOW_CODE, true)
+            } else {
+                if (Settings.canDrawOverlays(this)) {
+                    onRequestPermissionResult(REQUEST_ALERT_WINDOW_CODE, true)
+                } else {
+                    val drawOverlaysSettingsIntent = Intent(Settings.ACTION_MANAGE_OVERLAY_PERMISSION)
+                    drawOverlaysSettingsIntent.data = Uri.parse("package:$packageName")
+                    startActivityForResult(drawOverlaysSettingsIntent, REQUEST_ALERT_WINDOW_CODE)
+                }
+            }
+            else -> {
+            }
+        }
+    }
+
+    abstract fun onRequestPermissionResult(requestCode: Int, isSuccess: Boolean)
+
+    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<String>, grantResults: IntArray) {
+        when (requestCode) {
+            REQUEST_STORAGE_CODE, REQUEST_ALERT_WINDOW_CODE -> onRequestPermissionResult(requestCode, Utils.verifyAllPermissions(grantResults))
+            else -> super.onRequestPermissionsResult(requestCode, permissions, grantResults)
+        }
+    }
+
+    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
+        if (requestCode == REQUEST_ALERT_WINDOW_CODE && Utils.hasMmAbove()) {
+            onRequestPermissionResult(REQUEST_ALERT_WINDOW_CODE, Settings.canDrawOverlays(this))
+        } else {
+            super.onActivityResult(requestCode, resultCode, data)
+        }
+    }
+
+    public override fun onCreate(savedInstanceState: Bundle?) {
+        mSharedPreferences = getSharedPreferences(Def.APP_NAME, Context.MODE_PRIVATE)
+        setLanguage()
+        mThemeIndex = mSharedPreferences?.getInt("prefs_key_theme", 0) ?: 0
+        Utils.onActivityCreateSetTheme(this, mThemeIndex, Utils.ThemeActivity.HOME)
+        super.onCreate(savedInstanceState)
+        setTitle(R.string.app_name)
+        if (Utils.hasKk()) {
+            setTranslucentStatus(true)
+            val tintManager = SystemBarTintManager(this)
+            tintManager.isStatusBarTintEnabled = true
+            tintManager.setStatusBarTintColor(Utils.getColor(this, R.attr.colorPrimaryDark))
+        }
+
+    }
+
+    private fun setLanguage() {
+        var language = mSharedPreferences?.getString("prefs_key_languages", "") ?: ""
+        val configuration = resources.configuration
+        var lang = configuration.locale.language
+        if (TextUtils.isEmpty(language)) {
+            if (lang.equals("zh", ignoreCase = true)) {
+                val country = configuration.locale.country
+                lang += "_" + country.toUpperCase(Locale.US)
+            }
+            language = lang
+            if (Utils.checkLanguageSupport(language)) {
+                mSharedPreferences?.edit()?.putString("prefs_key_languages", language)?.apply()
+                if (language.contains("_")) {
+                    val s = language.split("_".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
+                    Utils.changeLocale(resources, s[0], s[1])
+                } else {
+                    Utils.changeLocale(resources, language)
+                }
+
+            }
+        } else if (!language.contains(lang)) {
+            if (language.contains("_")) {
+                val s = language.split("_".toRegex()).dropLastWhile { it.isEmpty() }.toTypedArray()
+                Utils.changeLocale(resources, s[0], s[1])
+            } else {
+                Utils.changeLocale(resources, language)
+            }
+        }
+        mCurrentLanguage = language
+    }
+
+    @TargetApi(19)
+    private fun setTranslucentStatus(on: Boolean) {
+        val win = window
+        val winParams = win.attributes
+        val bits = WindowManager.LayoutParams.FLAG_TRANSLUCENT_STATUS
+        if (on) {
+            winParams.flags = winParams.flags or bits
+        } else {
+            winParams.flags = winParams.flags and bits.inv()
+        }
+        win.attributes = winParams
+    }
+
+    companion object {
+
+        const val REQUEST_STORAGE_CODE = 1001
+        const val REQUEST_ALERT_WINDOW_CODE = 1003
+        /**
+         * Read and write permission for storage listed here.
+         */
+        val STORAGE_PERMISSIONS = arrayOf(Manifest.permission.WRITE_EXTERNAL_STORAGE, Manifest.permission.READ_EXTERNAL_STORAGE)
+    }
+}
diff --git a/qDict/src/main/java/com/annie/dictionary/MainActivity.java b/qDict/src/main/java/com/annie/dictionary/MainActivity.java
deleted file mode 100644
index 2794315..0000000
--- a/qDict/src/main/java/com/annie/dictionary/MainActivity.java
+++ /dev/null
@@ -1,780 +0,0 @@
-package com.annie.dictionary;
-
-import android.app.Activity;
-import android.app.Dialog;
-import android.app.ProgressDialog;
-import android.content.BroadcastReceiver;
-import android.content.ClipboardManager;
-import android.content.ClipboardManager.OnPrimaryClipChangedListener;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.graphics.Typeface;
-import android.os.AsyncTask;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Message;
-import android.os.SystemClock;
-import android.speech.RecognizerIntent;
-import android.text.Editable;
-import android.text.Selection;
-import android.text.TextUtils;
-import android.util.Log;
-import android.view.Gravity;
-import android.view.KeyEvent;
-import android.view.MotionEvent;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.view.inputmethod.EditorInfo;
-import android.view.inputmethod.InputMethodManager;
-import android.widget.ImageButton;
-import android.widget.LinearLayout;
-import android.widget.LinearLayout.LayoutParams;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import androidx.annotation.NonNull;
-import androidx.appcompat.app.ActionBar;
-import androidx.appcompat.widget.AppCompatEditText;
-import androidx.appcompat.widget.Toolbar;
-import androidx.fragment.app.Fragment;
-import androidx.fragment.app.FragmentManager;
-
-import com.annie.dictionary.frags.ListDictFragment;
-import com.annie.dictionary.frags.NavigatorFragment.NavigationCallbacks;
-import com.annie.dictionary.frags.RecentFragment;
-import com.annie.dictionary.frags.SearchFragment;
-import com.annie.dictionary.service.QDictService;
-import com.annie.dictionary.standout.StandOutWindow;
-import com.annie.dictionary.utils.Utils;
-import com.annie.dictionary.utils.Utils.DIALOG;
-import com.annie.dictionary.utils.Utils.Def;
-import com.annie.dictionary.utils.Utils.NAVIG;
-import com.annie.dictionary.utils.Utils.RECV_UI;
-import com.mmt.widget.DropDownListView;
-import com.mmt.widget.SlidingUpPanelLayout;
-import com.mmt.widget.SlidingUpPanelLayout.PanelState;
-import com.mmt.widget.slidemenu.SlidingMenu;
-import com.mmt.widget.slidemenu.SlidingMenu.CanvasTransformer;
-
-import java.util.ArrayList;
-import java.util.Locale;
-
-public class MainActivity extends BaseActivity implements NavigationCallbacks, OnClickListener {
-
-    public static final String ACTION_UPDATE_UI = "com.annie.dictionary.ACTION_UPDATE_UI";
-
-    public static final String ACTION_UPDATE_KEY = "receiver_update_ui";
-    // const
-    public static final int REQUEST_CODE = 101;
-    public static final int POPUPWORDSLIST_TIMER = 200;
-    public static final int LIST_WORDS_NORMAL = 0;
-    public static final int LIST_WORDS_FUZZY = 1;
-    public static final int LIST_WORDS_PATTERN = 2;
-    public static final int LIST_WORDS_FULLTEXT = 3;
-    public static boolean hasStoragePermission = false;
-    //
-    public static boolean active = false;
-    private static Handler mProgressCBHandler = null;
-    FragmentManager mFragmentManager;
-    Toolbar mToolbar;
-    // UX
-    DictSpeechEng mSpeechEng;
-    QDictions mDictions;
-    int mCurrentNavPosition = -1;
-    String tempKeyword;
-    int tempPos;
-    boolean onNavig = false;
-    private CanvasTransformer mTransformer = (canvas, percentOpen) -> canvas.scale(percentOpen, 1, 0, 0);
-    // UI
-    private SlidingUpPanelLayout mLayout;
-    // dict
-    private DictEditTextView mDictKeywordView = null;
-    private TextView mInfoSearch;
-    private DropDownListView mDictKeywordsPopupList = null;
-    private ImageButton mActionMenu, mActionWordsList;
-    private ProgressDialog mProgressDialog = null;
-    private Handler mPopupWordsListHandler = null;
-    // keyboard handler
-    private Handler mShowKeyboardHander = null;
-    private Runnable mShowKeyboarRunable = null;
-    private Runnable mPopupWordsListRunnable = null;
-    private boolean mReplaceKeyword = false;
-    private boolean mIsTaskRunning = false;
-    private ClipboardManager mClipboardManager = null;
-    private String mClipboardText = "";
-
-    private OnPrimaryClipChangedListener mClipboardListener = null;
-
-    BroadcastReceiver mUIReceiver = new BroadcastReceiver() {
-        @Override
-        public void onReceive(Context context, Intent intent) {
-            int id = intent.getIntExtra(ACTION_UPDATE_KEY, -1);
-            if (id == RECV_UI.SELECT_DICT) {
-                backMainMenuFragment();
-            } else if (id == RECV_UI.CHANGE_THEME || id == RECV_UI.CHANGE_FONT) {
-                stopService();
-                Utils.changeToTheme(MainActivity.this);
-            } else if (id == RECV_UI.SEARCH_WORD) {
-                String keyword = intent.getStringExtra("receiver_keyword");
-                if (!TextUtils.isEmpty(keyword)) {
-                    mDictKeywordView.setText(keyword);
-                    showSearchContent();
-                }
-            } else if (id == RECV_UI.RELOAD_DICT) {
-                mDictions.initDicts();
-            } else if (id == RECV_UI.RUN_SERVICE) {
-                startService();
-            } else if (id == RECV_UI.CHANGE_FRAG) {
-                int pos = intent.getIntExtra("receiver_frag_position", NAVIG.RECENT);
-                if (mCurrentNavPosition == NAVIG.SEARCH) {
-                    setFragment("", pos);
-                }
-                mCurrentNavPosition = pos;
-            }
-        }
-    };
-
-    public static void lookupProgressCB(int progress) {
-        Message m = Message.obtain();
-        m.arg1 = progress;
-        m.setTarget(mProgressCBHandler);
-        m.sendToTarget();
-    }
-
-    public void initClipboard() {
-        if (mClipboardManager == null) {
-            mClipboardManager = (ClipboardManager) getSystemService(Context.CLIPBOARD_SERVICE);
-            mClipboardManager.addPrimaryClipChangedListener(mClipboardListener);
-        }
-    }
-
-    public void releaseClipboard() {
-        if (mClipboardManager != null) {
-            mClipboardManager.removePrimaryClipChangedListener(mClipboardListener);
-        }
-        mClipboardManager = null;
-    }
-
-    private void clipboardCheck() {
-        String clipboardText;
-        CharSequence s = null;
-        if (mClipboardManager != null && mClipboardManager.hasPrimaryClip()) {
-            s = mClipboardManager.getPrimaryClip().getItemAt(0).getText();
-        }
-        if (TextUtils.isEmpty(s)) {
-            return;
-        }
-        clipboardText = s.toString().trim();
-        if (clipboardText.length() > Def.LIMIT_TRANSLATE_CHAR)
-            clipboardText = clipboardText.substring(0, Def.LIMIT_TRANSLATE_CHAR);
-        if (mClipboardText.equalsIgnoreCase(clipboardText))
-            return;
-        if (clipboardText.length() > 0) {
-            mClipboardText = clipboardText;
-            mDictKeywordView.setText(mClipboardText);
-            showSearchContent();
-        }
-    }
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        // UX:
-        mSpeechEng = DictSpeechEng.getInstance(this);
-        mSpeechEng.setLocale("en_US");
-        checkPermission(REQUEST_STORAGE_CODE);
-        // UI: set the Above View
-        setContentView(R.layout.content_frame);
-        mToolbar = (Toolbar) findViewById(R.id.main_toolbar);
-        mToolbar.setTitle(null);
-        setSupportActionBar(mToolbar);
-        ActionBar actionBar = getSupportActionBar();
-        if (actionBar != null) {
-            actionBar.setDefaultDisplayHomeAsUpEnabled(true);
-            actionBar.setHomeButtonEnabled(true);
-        }
-        mLayout = (SlidingUpPanelLayout) findViewById(R.id.sliding_layout);
-        mLayout.setPanelState(PanelState.HIDDEN);
-        mLayout.setTouchEnabled(false);
-        mFragmentManager = getSupportFragmentManager();
-        //
-        SlidingMenu sm = getSlidingMenu();
-        setSlidingActionBarEnabled(true);
-        sm.setBehindScrollScale(0.0f);
-        sm.setBehindCanvasTransformer(mTransformer);
-        // layout_drag
-        mActionMenu = (ImageButton) findViewById(R.id.action_menu);
-        ImageButton mActionVoice = (ImageButton) findViewById(R.id.action_voice);
-        mActionWordsList = (ImageButton) findViewById(R.id.action_wordslist);
-        mActionMenu.setOnClickListener(this);
-        mActionVoice.setOnClickListener(this);
-        mActionWordsList.setOnClickListener(this);
-        LinearLayout inputLayout;
-        inputLayout = (LinearLayout) findViewById(R.id.layout_input);
-        mInfoSearch = (TextView) findViewById(R.id.tv_info_search);
-        mDictKeywordView = new DictEditTextView(this);
-        inputLayout.addView(mDictKeywordView, 0,
-                new LayoutParams(0, android.view.ViewGroup.LayoutParams.MATCH_PARENT, 1));
-        initDropList();
-
-        String keyword = null;
-        if (savedInstanceState != null) {
-            mCurrentNavPosition = savedInstanceState.getInt("position_fragment");
-            keyword = savedInstanceState.getString("search_fragment_keyword", "");
-        }
-        boolean isFirst = mSharedPreferences.getBoolean("qdict_firt_start", true);
-        if (isFirst) {
-            setFragment(getString(R.string.guide_lable), NAVIG.HOME);
-            mSharedPreferences.edit().putBoolean("qdict_firt_start", false).apply();
-        } else {
-            boolean isSearch = !TextUtils.isEmpty(keyword);
-            String title = (mCurrentNavPosition == NAVIG.HOME || mCurrentNavPosition == NAVIG.SEARCH)
-                    ? ((isSearch) ? keyword : getResources().getString(R.string.guide_lable)) : "";
-            setFragment(title, (mCurrentNavPosition != -1) ? mCurrentNavPosition : NAVIG.RECENT);
-        }
-        mShowKeyboardHander = new Handler();
-        mProgressCBHandler = new Handler() {
-            @Override
-            public void handleMessage(@NonNull Message msg) {
-                int progress = msg.arg1;
-                if (null != mProgressDialog)
-                    mProgressDialog.setProgress(progress);
-            }
-        };
-        mShowKeyboarRunable = () -> {
-            mDictKeywordView.requestFocus();
-            mDictKeywordView.dispatchTouchEvent(MotionEvent.obtain(SystemClock.uptimeMillis(),
-                    SystemClock.uptimeMillis(), MotionEvent.ACTION_DOWN, 0, 0, 0));
-            mDictKeywordView.dispatchTouchEvent(MotionEvent.obtain(SystemClock.uptimeMillis(),
-                    SystemClock.uptimeMillis(), MotionEvent.ACTION_UP, 0, 0, 0));
-        };
-        mClipboardListener = this::clipboardCheck;
-
-        startService();
-        registerReceiver(mUIReceiver, new IntentFilter(ACTION_UPDATE_UI));
-    }
-
-    @Override
-    public void onRequestPermissionResult(int requestCode, boolean isSucess) {
-        if (REQUEST_STORAGE_CODE == requestCode) {
-            hasStoragePermission = isSucess;
-            if (isSucess) {
-                mDictions = new QDictions(this);
-                mDictions.initDicts();
-            } else {
-                finish();
-            }
-        } else if (REQUEST_ALERT_WINDOW_CODE == requestCode) {
-            Intent i = new Intent(Intent.ACTION_RUN);
-            i.setClass(MainActivity.this, QDictService.class);
-            i.setFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-            if (!QDictService.RUNNING)
-                startService(i);
-            if (!isSucess) {
-                runOnUiThread(() -> Toast.makeText(MainActivity.this, R.string.msg_do_not_show_popup, Toast.LENGTH_SHORT).show());
-            }
-        }
-    }
-
-    @Override
-    protected void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        outState.putInt("position_fragment", mCurrentNavPosition);
-        if (mCurrentNavPosition == NAVIG.SEARCH) {
-            Fragment fragment = this.getSupportFragmentManager().findFragmentById(R.id.content_frame);
-            if (fragment instanceof SearchFragment) {
-                SearchFragment fg = ((SearchFragment) fragment);
-                if (fg.isSearch()) {
-                    outState.putString("search_fragment_keyword", fg.getKeyword());
-                }
-            }
-        }
-    }
-
-    public Toolbar getToolbar() {
-        return mToolbar;
-    }
-
-    private void initDropList() {
-        mDictKeywordsPopupList = (DropDownListView) findViewById(R.id.drop_list);
-        mDictKeywordsPopupList.setFocusable(true);
-        mDictKeywordsPopupList.setFocusableInTouchMode(true);
-        mDictKeywordsPopupList.setListSelectionHidden(false);
-        mDictKeywordsPopupList.setOnItemClickListener((parent, v, position, id) -> {
-
-            TextView textView = (TextView) v;
-            String keyword = textView.getText().toString();
-
-            mReplaceKeyword = true; // Don't response the
-            // onTextChanged event this
-            // time.
-
-            mDictKeywordView.setText(keyword);
-            mInfoSearch.setVisibility(View.GONE);
-            mActionWordsList.setVisibility(View.GONE);
-            mInfoSearch.setText(null);
-            // make sure we keep the caret at the end of the text
-            // view
-            Editable spannable = mDictKeywordView.getText();
-            Selection.setSelection(spannable, spannable.length());
-            showSearchContent();
-        });
-        mPopupWordsListHandler = new Handler();
-        mPopupWordsListRunnable = this::startKeywordsList;
-
-    }
-
-    private void startService() {
-        if (mSharedPreferences.getBoolean(getString(R.string.prefs_key_using_capture), false)) {
-            if (!QDictService.RUNNING)
-                checkPermission(REQUEST_ALERT_WINDOW_CODE);
-        } else {
-            if (QDictService.RUNNING)
-                StandOutWindow.closeAll(this, QDictService.class);
-        }
-        checkUseClipboard();
-    }
-
-    private void checkUseClipboard() {
-        if (!QDictService.RUNNING) {
-            initClipboard();
-        } else {
-            releaseClipboard();
-        }
-    }
-
-    private void stopService() {
-        if (QDictService.RUNNING) {
-            StandOutWindow.closeAll(this, QDictService.class);
-        }
-        checkUseClipboard();
-    }
-
-    @Override
-    protected void onStart() {
-        active = true;
-        super.onStart();
-    }
-
-    @Override
-    protected void onStop() {
-        active = false;
-        super.onStop();
-    }
-
-    private void showProgressDialog() {
-        mProgressDialog = new ProgressDialog(this);
-        mProgressDialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
-        mProgressDialog.setMessage(getResources().getString(R.string.keywords_search));
-        mProgressDialog.setCancelable(false);
-        mProgressDialog.setButton(DialogInterface.BUTTON_NEGATIVE, getResources().getString(R.string.cancel),
-                (dialog, i) -> {
-                    mDictions.cancelLookup();
-                    dialog.cancel();
-                });
-        mProgressDialog.show();
-    }
-
-    private void startKeywordsList() {
-        int listType = LIST_WORDS_NORMAL;
-        String keyword = mDictKeywordView.getText().toString().trim();
-        keyword = keyword.trim();
-
-        if (keyword.length() <= 0) {
-            return;
-        }
-
-        if ((keyword.charAt(0) == '/') || (keyword.charAt(0) == ':') || (keyword.indexOf('*') >= 0)
-                || (keyword.indexOf('?') >= 0)) {
-            if (keyword.charAt(0) == '/') {
-                keyword = keyword.substring(1);
-                listType = LIST_WORDS_FUZZY;
-            } else if (keyword.charAt(0) == ':') {
-                keyword = keyword.substring(1);
-                listType = LIST_WORDS_FULLTEXT;
-            } else {
-                listType = LIST_WORDS_PATTERN;
-            }
-        }
-
-        if (!mIsTaskRunning) // One task is running.
-        {
-            mIsTaskRunning = true;
-            if (LIST_WORDS_NORMAL != listType)
-                showProgressDialog();
-            ListWordsTask mListWordsTask = new ListWordsTask(listType);
-            mListWordsTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, keyword);
-        }
-    }
-
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-        if (mSpeechEng != null) {
-            mSpeechEng.destroy();
-            mSpeechEng = null;
-        }
-        if (mDictions != null) {
-            mDictions.destroy();
-            mDictions = null;
-        }
-        if (mUIReceiver != null)
-            unregisterReceiver(mUIReceiver);
-        //
-        mShowKeyboardHander.removeCallbacks(mShowKeyboarRunable);
-        mShowKeyboarRunable = null;
-        mPopupWordsListRunnable = null;
-        releaseClipboard();
-    }
-
-    @Override
-    protected void onPause() {
-        mPopupWordsListHandler.removeCallbacks(mPopupWordsListRunnable);
-        super.onPause();
-    }
-
-    // start Recognition
-    private void startVoiceRecognition() {
-        // start voice
-        Intent intent = new Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH);
-        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM);
-        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE, Locale.ENGLISH);
-        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_PREFERENCE, Locale.ENGLISH);
-        intent.putExtra(RecognizerIntent.EXTRA_ONLY_RETURN_LANGUAGE_PREFERENCE, Locale.ENGLISH);
-        intent.putExtra(RecognizerIntent.EXTRA_PROMPT, getString(R.string.press_on_when_done));
-        intent.putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 1);
-        // ... put other settings in the Intent
-        startActivityForResult(intent, REQUEST_CODE);
-    }
-
-    private void hideKeyboard() {
-        InputMethodManager inputManager = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
-        // check if no view has focus:
-        View view = getCurrentFocus();
-        if (view != null && inputManager != null) {
-            inputManager.hideSoftInputFromWindow(view.getWindowToken(), InputMethodManager.HIDE_NOT_ALWAYS);
-        }
-    }
-
-    public void showSearchContent() {
-        String keyword = mDictKeywordView.getText().toString().trim();
-        Fragment fragment = this.getSupportFragmentManager().findFragmentById(R.id.content_frame);
-        if (fragment instanceof SearchFragment) {
-            SearchFragment sFrag = (SearchFragment) fragment;
-            sFrag.setDictions(mDictions);
-            sFrag.setSpeechEng(mSpeechEng);
-            sFrag.setKeyword(keyword);
-            mCurrentNavPosition = NAVIG.SEARCH;
-        } else {
-            try {
-                Fragment searchFrag = SearchFragment.newInstance(mSpeechEng, mDictions, keyword, true);
-                mFragmentManager.beginTransaction().replace(R.id.content_frame, searchFrag).commit();
-                mCurrentNavPosition = NAVIG.SEARCH;
-            } catch (IllegalStateException ex) {
-                Log.e("MainActivity", ex.toString());
-            }
-        }
-
-        if (mLayout != null && (mLayout.getPanelState() != PanelState.HIDDEN)) {
-            mLayout.setPanelState(PanelState.HIDDEN);
-            mActionMenu.clearFocus();
-        }
-        hideKeyboard();
-    }
-
-    @Override
-    public void onBackPressed() {
-        if (mLayout != null
-                && (mLayout.getPanelState() == PanelState.EXPANDED || mLayout.getPanelState() == PanelState.ANCHORED)) {
-            mLayout.setPanelState(PanelState.HIDDEN);
-            mActionMenu.clearFocus();
-        } else {
-            super.onBackPressed();
-        }
-    }
-
-    // call from layout xml
-    public void onActionButtonClick(View v) {
-        if (mLayout != null) {
-            mLayout.setPanelState(PanelState.EXPANDED);
-            mShowKeyboardHander.removeCallbacks(mShowKeyboarRunable);
-            int textLength = mDictKeywordView.getText().length();
-            if (textLength == 0) {
-                mShowKeyboardHander.postDelayed(mShowKeyboarRunable, 200);
-            }
-        }
-    }
-
-    @Override
-    public void onNavigationItemSelected(final String title, final int position) {
-        if (position == NAVIG.SELECT_DICT) {
-            Fragment fragment = ListDictFragment.newInstance(mDictions);
-            setMenuFragment(fragment);
-        } else {
-            onNavig = true;
-            tempKeyword = title;
-            tempPos = position;
-            toggle();
-        }
-    }
-
-    @Override
-    public void onMenuClose() {
-        if (onNavig) {
-            if (tempPos == NAVIG.SETTINGS) {
-                Intent intent = new Intent(this, SettingsActivity.class);
-                startActivity(intent);
-                overridePendingTransition(R.anim.push_left_in, R.anim.push_left_out);
-            } else if (tempPos == NAVIG.JOIN_US) {
-                Intent intent = Utils.getOpenPageFBIntent(getApplicationContext());
-                startActivity(intent);
-            } else {
-                if (mLayout != null && (mLayout.getPanelState() == PanelState.EXPANDED
-                        || mLayout.getPanelState() == PanelState.ANCHORED)) {
-                    mLayout.setPanelState(PanelState.HIDDEN);
-                }
-                if (mCurrentNavPosition != tempPos)
-                    setFragment(tempKeyword, tempPos);
-            }
-            onNavig = false;
-        }
-    }
-
-    public void setFragment(String keyword, int position) {
-        Fragment fragment;
-        switch (position) {
-            case NAVIG.HOME:
-            case NAVIG.SEARCH:
-                fragment = SearchFragment.newInstance(mSpeechEng, mDictions, keyword, position == NAVIG.SEARCH);
-                break;
-            case NAVIG.RECENT:
-            case NAVIG.FAVORITE:
-                fragment = this.getSupportFragmentManager().findFragmentById(R.id.content_frame);
-                boolean favorite = (position == NAVIG.FAVORITE);
-                if (fragment instanceof RecentFragment) {
-                    ((RecentFragment) fragment).setFavorite(favorite);
-                } else {
-                    fragment = new RecentFragment();
-                    Bundle b = new Bundle();
-                    b.putBoolean("qdict_is_favorite", favorite);
-                    fragment.setArguments(b);
-                }
-                break;
-            default:
-                fragment = null;
-                break;
-        }
-        if (fragment != null) {
-            mFragmentManager.beginTransaction().replace(R.id.content_frame, fragment).commit();
-            mCurrentNavPosition = position;
-        }
-    }
-
-    private void showKeywordsList(String[] strWordsList) {
-        MyArrayAdapter keywordsAdapter = new MyArrayAdapter(this, strWordsList);
-        mDictKeywordsPopupList.setAdapter(keywordsAdapter);
-    }
-
-    @Override
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        if (requestCode == REQUEST_CODE) {
-            if (resultCode == Activity.RESULT_OK) {
-                ArrayList<String> results = data.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS);
-                String keyword = results.get(0);
-                if (!TextUtils.isEmpty(keyword)) {
-                    mDictKeywordView.setText(keyword);
-                    runOnUiThread(() -> showSearchContent());
-
-                }
-            }
-        }
-        super.onActivityResult(requestCode, resultCode, data);
-    }
-
-    @SuppressWarnings("deprecation")
-    @Override
-    public void onClick(View v) {
-        switch (v.getId()) {
-            case R.id.action_menu:
-                toggle();
-                break;
-            case R.id.action_voice:
-                startVoiceRecognition();
-                break;
-            case R.id.action_wordslist:
-                startKeywordsList();
-                break;
-            case R.id.action_share:
-                startActivity(Utils.getIntentShareData(MainActivity.class));
-                break;
-            case R.id.action_about:
-                showDialog(DIALOG.ABOUT);
-                break;
-            default:
-                break;
-        }
-    }
-
-    // / for menu
-    @SuppressWarnings("deprecation")
-    @Override
-    protected Dialog onCreateDialog(int id) {
-        switch (id) {
-            case DIALOG.ABOUT:
-                return Utils.createAboutDialog(this);
-            case DIALOG.CHANGE_LOG:
-                return Utils.createWhatsNewDialog(this);
-            default:
-                break;
-        }
-        return super.onCreateDialog(id);
-    }
-
-    // Extend classes.
-    private class DictEditTextView extends AppCompatEditText {
-
-        int type = LIST_WORDS_NORMAL;
-
-        public DictEditTextView(Context context) {
-            super(context, null);
-            setSelectAllOnFocus(true);
-            setHint(R.string.action_search);
-            setImeOptions(EditorInfo.IME_ACTION_SEARCH);
-            setPadding(10, 0, 3, 0);
-            setGravity(Gravity.CENTER_VERTICAL);
-            setSingleLine();
-            Typeface mFont = Utils.getFont(context, mSharedPreferences.getString(Def.PREF_KEY_FONT, Def.DEFAULT_FONT));
-            setTypeface(mFont);
-        }
-
-        @Override
-        public boolean onKeyUp(int keyCode, KeyEvent event) {
-            if (keyCode != KeyEvent.KEYCODE_SPACE && (mDictKeywordsPopupList.getSelectedItemPosition() >= 0
-                    || (keyCode != KeyEvent.KEYCODE_SEARCH && keyCode != KeyEvent.KEYCODE_DPAD_CENTER))) {
-                mDictKeywordsPopupList.onKeyUp(keyCode, event);
-            }
-
-            switch (keyCode) {
-                // avoid passing the focus from the text view to the next
-                // component
-                case KeyEvent.KEYCODE_SEARCH:
-                case KeyEvent.KEYCODE_DPAD_CENTER:
-                case KeyEvent.KEYCODE_DPAD_DOWN:
-                case KeyEvent.KEYCODE_DPAD_UP:
-                    return (type == LIST_WORDS_NORMAL);
-
-            }
-            return super.onKeyUp(keyCode, event);
-        }
-
-        @Override
-        public boolean onKeyDown(int keyCode, KeyEvent event) {
-            if (keyCode != KeyEvent.KEYCODE_SPACE && (mDictKeywordsPopupList.getSelectedItemPosition() >= 0
-                    || (keyCode != KeyEvent.KEYCODE_SEARCH && keyCode != KeyEvent.KEYCODE_DPAD_CENTER))) {
-                mDictKeywordsPopupList.requestFocusFromTouch();
-                mDictKeywordsPopupList.onKeyDown(keyCode, event);
-            }
-            switch (keyCode) {
-                // avoid passing the focus from the text view to the next
-                // component
-                case KeyEvent.KEYCODE_SEARCH:
-                case KeyEvent.KEYCODE_DPAD_CENTER:
-                case KeyEvent.KEYCODE_DPAD_DOWN:
-                case KeyEvent.KEYCODE_DPAD_UP:
-                    mDictKeywordsPopupList.setListSelectionHidden(false);
-                    return true;
-            }
-            if (KeyEvent.KEYCODE_ENTER == keyCode) {
-                if (type == LIST_WORDS_NORMAL) {
-                    showSearchContent();
-                } else {
-                    mPopupWordsListHandler.postDelayed(mPopupWordsListRunnable, POPUPWORDSLIST_TIMER);
-                }
-                hideKeyboard();
-            }
-            return super.onKeyDown(keyCode, event);
-        }
-
-        @Override
-        protected void onTextChanged(CharSequence text, int start, int before, int after) {
-            if (mPopupWordsListHandler != null)
-                mPopupWordsListHandler.removeCallbacks(mPopupWordsListRunnable);
-
-            if (mReplaceKeyword) {
-                mReplaceKeyword = false;
-            } else {
-                String keyword = text.toString();
-                if (!TextUtils.isEmpty(keyword)) {
-                    if (keyword.charAt(0) == '/') {
-                        mInfoSearch.setVisibility(View.VISIBLE);
-                        mInfoSearch.setText(R.string.fuzzy_query_prompt);
-                        mActionWordsList.setVisibility(View.VISIBLE);
-                        type = LIST_WORDS_FUZZY;
-                    } else if (keyword.charAt(0) == ':') {
-                        mInfoSearch.setVisibility(View.VISIBLE);
-                        mInfoSearch.setText(R.string.fulltext_query_prompt);
-                        mActionWordsList.setVisibility(View.VISIBLE);
-                        type = LIST_WORDS_FULLTEXT;
-                    } else if (((keyword.indexOf('*') >= 0) || (keyword.indexOf('?') >= 0))) {
-                        mInfoSearch.setVisibility(View.VISIBLE);
-                        mInfoSearch.setText(R.string.pattern_query_prompt);
-                        mActionWordsList.setVisibility(View.VISIBLE);
-                        type = LIST_WORDS_PATTERN;
-                    } else {
-                        mInfoSearch.setVisibility(View.GONE);
-                        mActionWordsList.setVisibility(View.GONE);
-                        mInfoSearch.setText(null);
-                        type = LIST_WORDS_NORMAL;
-                        if (mPopupWordsListHandler != null)
-                            mPopupWordsListHandler.postDelayed(mPopupWordsListRunnable, POPUPWORDSLIST_TIMER);
-                    }
-                }
-            }
-            super.onTextChanged(text, start, before, after);
-        }
-    }
-
-    private class ListWordsTask extends AsyncTask<String, Void, String[]> {
-
-        int mListType;
-
-        public ListWordsTask(int listType) {
-            mListType = listType;
-        }
-
-        @Override
-        protected String[] doInBackground(String... params) {
-            String strWordsList[] = null;
-            String keyword = params[0];
-            switch (mListType) {
-                case LIST_WORDS_NORMAL:
-                    strWordsList = mDictions.listWords(keyword);
-                    break;
-                case LIST_WORDS_FUZZY:
-                    strWordsList = mDictions.fuzzyListWords(keyword);
-                    break;
-                case LIST_WORDS_PATTERN:
-                    strWordsList = mDictions.patternListWords(keyword);
-                    break;
-                case LIST_WORDS_FULLTEXT:
-                    strWordsList = mDictions.fullTextListWords(keyword);
-                    break;
-            }
-            return strWordsList;
-        }
-
-        @Override
-        protected void onPostExecute(String[] strWordsList) {
-            mIsTaskRunning = false; // Task has stopped.
-            if (null != mProgressDialog && mProgressDialog.isShowing())
-                mProgressDialog.cancel();
-            if (null == strWordsList || strWordsList.length <= 0) {
-                return;
-            }
-            showKeywordsList(strWordsList);
-        }
-    }
-
-}
diff --git a/qDict/src/main/java/com/annie/dictionary/MainActivity.kt b/qDict/src/main/java/com/annie/dictionary/MainActivity.kt
new file mode 100644
index 0000000..0ed461b
--- /dev/null
+++ b/qDict/src/main/java/com/annie/dictionary/MainActivity.kt
@@ -0,0 +1,723 @@
+package com.annie.dictionary
+
+import android.annotation.SuppressLint
+import android.app.Activity
+import android.app.Dialog
+import android.app.ProgressDialog
+import android.content.*
+import android.content.ClipboardManager.OnPrimaryClipChangedListener
+import android.os.*
+import android.speech.RecognizerIntent
+import android.text.Selection
+import android.text.TextUtils
+import android.util.Log
+import android.view.*
+import android.view.View.OnClickListener
+import android.view.inputmethod.EditorInfo
+import android.view.inputmethod.InputMethodManager
+import android.widget.LinearLayout.LayoutParams
+import android.widget.TextView
+import android.widget.Toast
+import androidx.appcompat.app.ActionBarDrawerToggle
+import androidx.appcompat.widget.AppCompatEditText
+import androidx.appcompat.widget.Toolbar
+import androidx.core.view.GravityCompat
+import androidx.fragment.app.Fragment
+import com.annie.dictionary.frags.ListDictFragment
+import com.annie.dictionary.frags.NavigatorFragment
+import com.annie.dictionary.frags.RecentFragment
+import com.annie.dictionary.frags.SearchFragment
+import com.annie.dictionary.service.QDictService
+import com.annie.dictionary.standout.StandOutWindow
+import com.annie.dictionary.utils.Utils.*
+import com.mmt.widget.M2tToast
+import com.mmt.widget.SlidingUpPanelLayout.PanelState
+import kotlinx.android.synthetic.main.activity_main.*
+import kotlinx.android.synthetic.main.content_frame.*
+import kotlinx.android.synthetic.main.layout_drag.*
+import java.util.*
+
+class MainActivity : BaseActivity(), NavigatorFragment.NavigationCallbacks, OnClickListener {
+
+    private var navFragment: Fragment? = null
+    // UX
+    var mSpeechEng: DictSpeechEng? = null
+    var mDictions: QDictions? = null
+    var mCurrentNavPosition = -1
+    var tempKeyword: String = ""
+    var tempPos: Int = 0
+    var onNavig = false
+    // dict
+    private var mDictKeywordView: DictEditTextView? = null
+    private var mProgressDialog: ProgressDialog? = null
+    private var mPopupWordsListHandler: Handler? = null
+    // keyboard handler
+    private var mShowKeyboardHander: Handler? = null
+    private var mShowKeyboarRunable: Runnable? = null
+
+    private var mReplaceKeyword = false
+    private var mIsTaskRunning = false
+    private var mClipboardManager: ClipboardManager? = null
+    private var mClipboardText = ""
+
+    private var mClipboardListener: OnPrimaryClipChangedListener? = null
+
+    private var mPopupWordsListRunnable: Runnable = Runnable { this.startKeywordsList() }
+
+    private var mUIReceiver: BroadcastReceiver? = object : BroadcastReceiver() {
+        override fun onReceive(context: Context, intent: Intent) {
+            val id = intent.getIntExtra(ACTION_UPDATE_KEY, -1)
+            if (id == RECV_UI.SELECT_DICT) {
+                setMainMenuFragment()
+            } else if (id == RECV_UI.CHANGE_THEME || id == RECV_UI.CHANGE_FONT) {
+                stopService()
+                changeToTheme(this@MainActivity)
+            } else if (id == RECV_UI.SEARCH_WORD) {
+                val keyword = intent.getStringExtra("receiver_keyword")
+                if (!TextUtils.isEmpty(keyword)) {
+                    mDictKeywordView?.setText(keyword)
+                    showSearchContent()
+                }
+            } else if (id == RECV_UI.RELOAD_DICT) {
+                mDictions!!.initDicts()
+            } else if (id == RECV_UI.RUN_SERVICE) {
+                startService()
+            } else if (id == RECV_UI.CHANGE_FRAG) {
+                val pos = intent.getIntExtra("receiver_frag_position", NAVIG.RECENT)
+                if (mCurrentNavPosition == NAVIG.SEARCH) {
+                    setFragment("", pos)
+                }
+                mCurrentNavPosition = pos
+            }
+        }
+    }
+
+
+    fun setMainMenuFragment() {
+        val transaction = supportFragmentManager.beginTransaction()
+        transaction.replace(R.id.frame_container, NavigatorFragment())
+        transaction.commit()
+    }
+
+    fun getToolbar(): Toolbar {
+        return main_toolbar
+    }
+
+    private fun initClipboard() {
+        if (mClipboardManager == null) {
+            mClipboardManager = getSystemService(Context.CLIPBOARD_SERVICE) as ClipboardManager
+            mClipboardManager!!.addPrimaryClipChangedListener(mClipboardListener)
+        }
+    }
+
+    private fun releaseClipboard() {
+        mClipboardManager?.removePrimaryClipChangedListener(mClipboardListener)
+        mClipboardManager = null
+    }
+
+    private fun clipboardCheck() {
+        var clipboardText: String
+        var s: CharSequence? = null
+        mClipboardManager?.let {
+            if (it.hasPrimaryClip()) {
+                s = it.primaryClip?.getItemAt(0)?.text
+            }
+        }
+
+        if (TextUtils.isEmpty(s)) {
+            return
+        }
+        clipboardText = s.toString().trim { it <= ' ' }
+        if (clipboardText.length > Def.LIMIT_TRANSLATE_CHAR)
+            clipboardText = clipboardText.substring(0, Def.LIMIT_TRANSLATE_CHAR)
+        if (mClipboardText.equals(clipboardText, ignoreCase = true))
+            return
+        if (clipboardText.isNotEmpty()) {
+            mClipboardText = clipboardText
+            mDictKeywordView?.setText(mClipboardText)
+            showSearchContent()
+        }
+    }
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        // UX:
+        mSpeechEng = DictSpeechEng.getInstance(this)
+        mSpeechEng?.setLocale("en_US")
+        checkPermission(REQUEST_STORAGE_CODE)
+        // UI: set the Above View
+        setContentView(R.layout.activity_main)
+        main_toolbar.title = null
+        setSupportActionBar(main_toolbar)
+        supportActionBar?.let {
+            it.setDefaultDisplayHomeAsUpEnabled(true)
+            it.setHomeButtonEnabled(true)
+        }
+
+        sliding_layout.panelState = PanelState.HIDDEN
+        sliding_layout.isTouchEnabled = false
+        val toggle = ActionBarDrawerToggle(this, drawer_layout, main_toolbar, R.string.ok, R.string.close)
+        drawer_layout.addDrawerListener(toggle)
+        toggle.syncState()
+
+        toggle.drawerArrowDrawable.color = getColor(this, R.attr.colorPrimary)
+        // layout_drag
+        action_menu.setOnClickListener(this)
+        action_voice.setOnClickListener(this)
+        action_wordslist.setOnClickListener(this)
+        mDictKeywordView = DictEditTextView(this)
+        layout_input.addView(mDictKeywordView, 0,
+                LayoutParams(0, ViewGroup.LayoutParams.MATCH_PARENT, 1f))
+        initDropList()
+
+        var keyword: String? = null
+        if (savedInstanceState == null) {
+            navFragment = NavigatorFragment()
+            navFragment?.let {
+                supportFragmentManager.beginTransaction().replace(R.id.frame_container, it).commit()
+            }
+        } else {
+            navFragment = supportFragmentManager.findFragmentById(R.id.frame_container)
+            mCurrentNavPosition = savedInstanceState.getInt("position_fragment")
+            keyword = savedInstanceState.getString("search_fragment_keyword", "")
+        }
+
+        val isFirst = mSharedPreferences?.getBoolean("qdict_firt_start", true) ?: true
+        if (isFirst) {
+            setFragment(getString(R.string.guide_lable), NAVIG.HOME)
+            mSharedPreferences?.edit()?.putBoolean("qdict_firt_start", false)?.apply()
+        } else {
+            val isSearch = !TextUtils.isEmpty(keyword)
+            val title = if (mCurrentNavPosition == NAVIG.HOME || mCurrentNavPosition == NAVIG.SEARCH)
+                if (isSearch) keyword else resources.getString(R.string.guide_lable)
+            else
+                ""
+            setFragment(title
+                    ?: "", if (mCurrentNavPosition != -1) mCurrentNavPosition else NAVIG.RECENT)
+        }
+        mShowKeyboardHander = Handler()
+        mProgressCBHandler = @SuppressLint("HandlerLeak")
+        object : Handler() {
+            override fun handleMessage(msg: Message) {
+                val progress = msg.arg1
+                mProgressDialog?.let {
+                    it.progress = progress
+                }
+            }
+        }
+
+        mShowKeyboarRunable = Runnable {
+            mDictKeywordView?.requestFocus()
+            mDictKeywordView?.dispatchTouchEvent(MotionEvent.obtain(SystemClock.uptimeMillis(),
+                    SystemClock.uptimeMillis(), MotionEvent.ACTION_DOWN, 0f, 0f, 0))
+            mDictKeywordView?.dispatchTouchEvent(MotionEvent.obtain(SystemClock.uptimeMillis(),
+                    SystemClock.uptimeMillis(), MotionEvent.ACTION_UP, 0f, 0f, 0))
+        }
+        mClipboardListener = OnPrimaryClipChangedListener { this.clipboardCheck() }
+
+        startService()
+        registerReceiver(mUIReceiver, IntentFilter(ACTION_UPDATE_UI))
+    }
+
+    override fun onRequestPermissionResult(requestCode: Int, isSucess: Boolean) {
+        if (REQUEST_STORAGE_CODE == requestCode) {
+            hasStoragePermission = isSucess
+            if (isSucess) {
+                mDictions = QDictions(this)
+                mDictions?.initDicts()
+            } else {
+                finish()
+            }
+        } else if (BaseActivity.Companion.REQUEST_ALERT_WINDOW_CODE == requestCode) {
+            val i = Intent(Intent.ACTION_RUN)
+            i.setClass(this@MainActivity, QDictService::class.java)
+            i.flags = Intent.FLAG_ACTIVITY_NEW_TASK
+            if (!QDictService.RUNNING)
+                startService(i)
+            if (!isSucess) {
+                runOnUiThread { Toast.makeText(this@MainActivity, R.string.msg_do_not_show_popup, Toast.LENGTH_SHORT).show() }
+            }
+        }
+    }
+
+    override fun onSaveInstanceState(outState: Bundle) {
+        super.onSaveInstanceState(outState)
+        outState.putInt("position_fragment", mCurrentNavPosition)
+        if (mCurrentNavPosition == NAVIG.SEARCH) {
+            val fragment = this.supportFragmentManager.findFragmentById(R.id.content_frame)
+            if (fragment is SearchFragment) {
+                val fg = fragment as SearchFragment?
+                if (fg?.isSearch == true) {
+                    outState.putString("search_fragment_keyword", fg.keyword)
+                }
+            }
+        }
+    }
+
+    private fun initDropList() {
+        drop_list.isFocusable = true
+        drop_list.isFocusableInTouchMode = true
+        drop_list.isListSelectionHidden = false
+        drop_list.setOnItemClickListener { _, v, _, _ ->
+
+            val textView = v as TextView
+            val keyword = textView.text.toString()
+
+            mReplaceKeyword = true // Don't response the
+            // onTextChanged event this
+            // time.
+
+            mDictKeywordView?.setText(keyword)
+            tv_info_search.visibility = View.GONE
+            action_wordslist.visibility = View.GONE
+            tv_info_search.text = null
+            // make sure we keep the caret at the end of the text
+            // view
+            val spannable = mDictKeywordView?.text
+            Selection.setSelection(spannable, spannable?.length ?: 0)
+            showSearchContent()
+        }
+        mPopupWordsListHandler = Handler()
+
+    }
+
+    private fun startService() {
+        if (mSharedPreferences?.getBoolean(getString(R.string.prefs_key_using_capture), false) == true) {
+            if (!QDictService.RUNNING)
+                checkPermission(REQUEST_ALERT_WINDOW_CODE)
+        } else {
+            if (QDictService.RUNNING)
+                StandOutWindow.closeAll(this, QDictService::class.java)
+        }
+        checkUseClipboard()
+    }
+
+    private fun checkUseClipboard() {
+        if (!QDictService.RUNNING) {
+            initClipboard()
+        } else {
+            releaseClipboard()
+        }
+    }
+
+    private fun stopService() {
+        if (QDictService.RUNNING) {
+            StandOutWindow.closeAll(this, QDictService::class.java)
+        }
+        checkUseClipboard()
+    }
+
+    override fun onStart() {
+        active = true
+        super.onStart()
+    }
+
+    override fun onStop() {
+        active = false
+        super.onStop()
+    }
+
+    @Suppress("DEPRECATION")
+    private fun showProgressDialog() {
+        mProgressDialog = ProgressDialog(this)
+        mProgressDialog?.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL)
+        mProgressDialog?.setMessage(resources.getString(R.string.keywords_search))
+        mProgressDialog?.setCancelable(false)
+        mProgressDialog?.setButton(DialogInterface.BUTTON_NEGATIVE, resources.getString(R.string.cancel)
+        ) { dialog, _ ->
+            mDictions?.cancelLookup()
+            dialog.cancel()
+        }
+        mProgressDialog?.show()
+    }
+
+    private fun startKeywordsList() {
+        var listType = LIST_WORDS_NORMAL
+        var keyword = mDictKeywordView?.text?.toString()?.trim { it <= ' ' } ?: ""
+        keyword = keyword.trim { it <= ' ' }
+
+        if (keyword.isEmpty()) {
+            return
+        }
+
+        if (keyword[0] == '/' || keyword[0] == ':' || keyword.indexOf('*') >= 0
+                || keyword.indexOf('?') >= 0) {
+            if (keyword[0] == '/') {
+                keyword = keyword.substring(1)
+                listType = LIST_WORDS_FUZZY
+            } else if (keyword[0] == ':') {
+                keyword = keyword.substring(1)
+                listType = LIST_WORDS_FULLTEXT
+            } else {
+                listType = LIST_WORDS_PATTERN
+            }
+        }
+
+        if (!mIsTaskRunning)
+        // One task is running.
+        {
+            mIsTaskRunning = true
+            if (LIST_WORDS_NORMAL != listType)
+                showProgressDialog()
+            val mListWordsTask = ListWordsTask(listType)
+            mListWordsTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR, keyword)
+        }
+    }
+
+    override fun onDestroy() {
+        super.onDestroy()
+        if (mSpeechEng != null) {
+            mSpeechEng!!.destroy()
+            mSpeechEng = null
+        }
+        if (mDictions != null) {
+            mDictions!!.destroy()
+            mDictions = null
+        }
+        if (mUIReceiver != null)
+            unregisterReceiver(mUIReceiver)
+        //
+        mShowKeyboarRunable?.let {
+            mShowKeyboardHander?.removeCallbacks(it)
+        }
+        mShowKeyboarRunable = null
+        releaseClipboard()
+    }
+
+    override fun onPause() {
+        mPopupWordsListHandler?.removeCallbacks(mPopupWordsListRunnable)
+        super.onPause()
+    }
+
+    // start Recognition
+    private fun startVoiceRecognition() {
+        // start voice
+        val intent = Intent(RecognizerIntent.ACTION_RECOGNIZE_SPEECH)
+        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_MODEL, RecognizerIntent.LANGUAGE_MODEL_FREE_FORM)
+        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE, Locale.ENGLISH)
+        intent.putExtra(RecognizerIntent.EXTRA_LANGUAGE_PREFERENCE, Locale.ENGLISH)
+        intent.putExtra(RecognizerIntent.EXTRA_ONLY_RETURN_LANGUAGE_PREFERENCE, Locale.ENGLISH)
+        intent.putExtra(RecognizerIntent.EXTRA_PROMPT, getString(R.string.press_on_when_done))
+        intent.putExtra(RecognizerIntent.EXTRA_MAX_RESULTS, 1)
+        // ... put other settings in the Intent
+        try {
+            startActivityForResult(intent, REQUEST_CODE)
+        } catch (e: ActivityNotFoundException) {
+            M2tToast.makeText(this, e.localizedMessage, M2tToast.LENGTH_SHORT).show()
+        }
+    }
+
+    private fun hideKeyboard() {
+        val inputManager = getSystemService(Context.INPUT_METHOD_SERVICE) as InputMethodManager
+        inputManager.hideSoftInputFromWindow(currentFocus?.windowToken, InputMethodManager.HIDE_NOT_ALWAYS)
+    }
+
+    fun showSearchContent() {
+        val keyword = mDictKeywordView?.text?.toString()?.trim { it <= ' ' } ?: ""
+        val fragment = this.supportFragmentManager.findFragmentById(R.id.content_frame)
+        if (fragment is SearchFragment) {
+            val sFrag = fragment as SearchFragment?
+            sFrag?.setDictions(mDictions)
+            sFrag?.setSpeechEng(mSpeechEng)
+            sFrag?.keyword = keyword
+            mCurrentNavPosition = NAVIG.SEARCH
+        } else {
+            try {
+                val searchFrag = SearchFragment.newInstance(mSpeechEng, mDictions, keyword, true)
+                supportFragmentManager.beginTransaction().replace(R.id.content_frame, searchFrag).commit()
+                mCurrentNavPosition = NAVIG.SEARCH
+            } catch (ex: IllegalStateException) {
+                Log.e("MainActivity", ex.toString())
+            }
+
+        }
+        if (sliding_layout.panelState != PanelState.HIDDEN) {
+            sliding_layout.panelState = PanelState.HIDDEN
+            action_menu.clearFocus()
+        }
+
+        hideKeyboard()
+    }
+
+    override fun onBackPressed() {
+        when {
+            drawer_layout.isDrawerOpen(GravityCompat.START) -> drawer_layout.closeDrawer(GravityCompat.START)
+            sliding_layout.panelState == PanelState.EXPANDED || sliding_layout.panelState == PanelState.ANCHORED -> {
+                sliding_layout.panelState = PanelState.HIDDEN
+                action_menu.clearFocus()
+            }
+            else -> super.onBackPressed()
+        }
+
+    }
+
+    // call from layout xml
+    fun onActionButtonClick(v: View) {
+        sliding_layout.panelState = PanelState.EXPANDED
+        mShowKeyboarRunable?.let {
+            mShowKeyboardHander?.removeCallbacks(it)
+            val textLength = mDictKeywordView?.text?.length ?: 0
+            if (textLength == 0) {
+                mShowKeyboardHander?.postDelayed(it, 200)
+            }
+        }
+
+    }
+
+
+    override fun onNavigationItemSelected(title: String, position: Int) =
+            if (position == NAVIG.SELECT_DICT) {
+                setMenuFragment(ListDictFragment.newInstance(mDictions))
+            } else {
+                onNavig = true
+                tempKeyword = title
+                tempPos = position
+                drawer_layout.closeDrawer(GravityCompat.START)
+                onMenuClose()
+            }
+
+    private fun setMenuFragment(fragment: Fragment) {
+        val t = supportFragmentManager.beginTransaction()
+        t.setCustomAnimations(R.anim.push_left_in, R.anim.push_left_out, R.anim.push_right_in, R.anim.push_right_out)
+        t.replace(R.id.frame_container, fragment).commit()
+    }
+
+    private fun onMenuClose() {
+        if (onNavig) {
+            when (tempPos) {
+                NAVIG.SETTINGS -> {
+                    startActivity(Intent(this, SettingsActivity::class.java))
+                    overridePendingTransition(R.anim.push_left_in, R.anim.push_left_out)
+                }
+                NAVIG.JOIN_US -> {
+                    startActivity(getOpenPageFBIntent(applicationContext))
+                }
+                else -> {
+                    if (sliding_layout.panelState == PanelState.EXPANDED || sliding_layout.panelState == PanelState.ANCHORED) {
+                        sliding_layout.panelState = PanelState.HIDDEN
+                    }
+                    if (mCurrentNavPosition != tempPos)
+                        setFragment(tempKeyword, tempPos)
+                }
+            }
+            onNavig = false
+        }
+    }
+
+    fun setFragment(keyword: String, position: Int) {
+        var fragment: Fragment?
+        when (position) {
+            NAVIG.HOME, NAVIG.SEARCH -> fragment = SearchFragment.newInstance(mSpeechEng, mDictions, keyword, position == NAVIG.SEARCH)
+            NAVIG.RECENT, NAVIG.FAVORITE -> {
+                fragment = this.supportFragmentManager.findFragmentById(R.id.content_frame)
+                val favorite = position == NAVIG.FAVORITE
+                if (fragment is RecentFragment) {
+                    fragment.setFavorite(favorite)
+                } else {
+                    fragment = RecentFragment()
+                    val b = Bundle()
+                    b.putBoolean("qdict_is_favorite", favorite)
+                    fragment.arguments = b
+                }
+            }
+            else -> fragment = null
+        }
+        if (fragment != null) {
+            supportFragmentManager.beginTransaction().replace(R.id.content_frame, fragment).commit()
+            mCurrentNavPosition = position
+        }
+    }
+
+    private fun showKeywordsList(strWordsList: Array<String>) {
+        drop_list.adapter = MyArrayAdapter(this, strWordsList)
+    }
+
+    public override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
+        if (requestCode == REQUEST_CODE) {
+            if (resultCode == Activity.RESULT_OK) {
+                data?.getStringArrayListExtra(RecognizerIntent.EXTRA_RESULTS)?.let { results ->
+                    val keyword = results[0]
+                    if (!TextUtils.isEmpty(keyword)) {
+                        mDictKeywordView?.setText(keyword)
+                        runOnUiThread { showSearchContent() }
+
+                    }
+                }
+
+            }
+        }
+        super.onActivityResult(requestCode, resultCode, data)
+    }
+
+    override fun onClick(v: View) {
+        when (v.id) {
+            R.id.action_menu -> {
+                if (drawer_layout.isDrawerOpen(GravityCompat.START)) {
+                    drawer_layout.closeDrawer(GravityCompat.START)
+                } else {
+                    drawer_layout.openDrawer(GravityCompat.START)
+                }
+            }
+            R.id.action_voice -> startVoiceRecognition()
+            R.id.action_wordslist -> startKeywordsList()
+            R.id.action_share -> startActivity(getIntentShareData(MainActivity::class.java))
+            R.id.action_about -> showDialog(DIALOG.ABOUT)
+            else -> {
+            }
+        }
+    }
+
+    // / for menu
+    override fun onCreateDialog(id: Int): Dialog {
+        when (id) {
+            DIALOG.ABOUT -> return createAboutDialog(this)
+            DIALOG.CHANGE_LOG -> return createWhatsNewDialog(this)
+            else -> {
+            }
+        }
+        return super.onCreateDialog(id)
+    }
+
+    // Extend classes.
+    private inner class DictEditTextView(context: Context) : AppCompatEditText(context, null) {
+
+        internal var type = LIST_WORDS_NORMAL
+
+        init {
+            setSelectAllOnFocus(true)
+            setHint(R.string.action_search)
+            imeOptions = EditorInfo.IME_ACTION_SEARCH
+            setPadding(10, 0, 3, 0)
+            gravity = Gravity.CENTER_VERTICAL
+            setSingleLine()
+            val mFont = getFont(context, mSharedPreferences?.getString(Def.PREF_KEY_FONT, Def.DEFAULT_FONT)
+                    ?: Def.DEFAULT_FONT)
+            typeface = mFont
+        }
+
+        override fun onKeyUp(keyCode: Int, event: KeyEvent): Boolean {
+            if (keyCode != KeyEvent.KEYCODE_SPACE && (drop_list.selectedItemPosition >= 0 || keyCode != KeyEvent.KEYCODE_SEARCH && keyCode != KeyEvent.KEYCODE_DPAD_CENTER)) {
+                drop_list.onKeyUp(keyCode, event)
+            }
+
+            when (keyCode) {
+                // avoid passing the focus from the text view to the next
+                // component
+                KeyEvent.KEYCODE_SEARCH, KeyEvent.KEYCODE_DPAD_CENTER, KeyEvent.KEYCODE_DPAD_DOWN, KeyEvent.KEYCODE_DPAD_UP -> return type == LIST_WORDS_NORMAL
+            }
+            return super.onKeyUp(keyCode, event)
+        }
+
+        override fun onKeyDown(keyCode: Int, event: KeyEvent): Boolean {
+            if (keyCode != KeyEvent.KEYCODE_SPACE && (drop_list.selectedItemPosition >= 0 || keyCode != KeyEvent.KEYCODE_SEARCH && keyCode != KeyEvent.KEYCODE_DPAD_CENTER)) {
+                drop_list.requestFocusFromTouch()
+                drop_list.onKeyDown(keyCode, event)
+            }
+            when (keyCode) {
+                // avoid passing the focus from the text view to the next
+                // component
+                KeyEvent.KEYCODE_SEARCH, KeyEvent.KEYCODE_DPAD_CENTER, KeyEvent.KEYCODE_DPAD_DOWN, KeyEvent.KEYCODE_DPAD_UP -> {
+                    drop_list.isListSelectionHidden = false
+                    return true
+                }
+            }
+            if (KeyEvent.KEYCODE_ENTER == keyCode) {
+                if (type == LIST_WORDS_NORMAL) {
+                    showSearchContent()
+                } else {
+                    mPopupWordsListHandler?.postDelayed(mPopupWordsListRunnable, POPUPWORDSLIST_TIMER.toLong())
+                }
+                hideKeyboard()
+            }
+            return super.onKeyDown(keyCode, event)
+        }
+
+        override fun onTextChanged(text: CharSequence, start: Int, before: Int, after: Int) {
+            mPopupWordsListHandler?.removeCallbacks(mPopupWordsListRunnable)
+            if (mReplaceKeyword) {
+                mReplaceKeyword = false
+            } else {
+                val keyword = text.toString()
+                if (!TextUtils.isEmpty(keyword)) {
+                    if (keyword[0] == '/') {
+                        tv_info_search.visibility = View.VISIBLE
+                        tv_info_search.setText(R.string.fuzzy_query_prompt)
+                        action_wordslist.visibility = View.VISIBLE
+                        type = LIST_WORDS_FUZZY
+                    } else if (keyword[0] == ':') {
+                        tv_info_search.visibility = View.VISIBLE
+                        tv_info_search.setText(R.string.fulltext_query_prompt)
+                        action_wordslist.visibility = View.VISIBLE
+                        type = LIST_WORDS_FULLTEXT
+                    } else if (keyword.indexOf('*') >= 0 || keyword.indexOf('?') >= 0) {
+                        tv_info_search.visibility = View.VISIBLE
+                        tv_info_search.setText(R.string.pattern_query_prompt)
+                        action_wordslist.visibility = View.VISIBLE
+                        type = LIST_WORDS_PATTERN
+                    } else {
+                        tv_info_search.visibility = View.GONE
+                        action_wordslist.visibility = View.GONE
+                        tv_info_search.text = null
+                        type = LIST_WORDS_NORMAL
+                        mPopupWordsListHandler?.postDelayed(mPopupWordsListRunnable, POPUPWORDSLIST_TIMER.toLong())
+                    }
+                }
+            }
+            super.onTextChanged(text, start, before, after)
+        }
+    }
+
+    private inner class ListWordsTask(internal var mListType: Int) : AsyncTask<String, Void, Array<String>>() {
+
+        override fun doInBackground(vararg params: String): Array<String>? {
+            var strWordsList: Array<String>? = null
+            val keyword = params[0]
+            mDictions?.let {
+                when (mListType) {
+                    LIST_WORDS_NORMAL -> strWordsList = it.listWords(keyword)
+                    LIST_WORDS_FUZZY -> strWordsList = it.fuzzyListWords(keyword)
+                    LIST_WORDS_PATTERN -> strWordsList = it.patternListWords(keyword)
+                    LIST_WORDS_FULLTEXT -> strWordsList = it.fullTextListWords(keyword)
+                }
+            }
+
+            return strWordsList
+        }
+
+        override fun onPostExecute(strWordsList: Array<String>?) {
+            mIsTaskRunning = false // Task has stopped.
+            if (mProgressDialog?.isShowing == true)
+                mProgressDialog?.cancel()
+            if (null == strWordsList || strWordsList.isEmpty()) {
+                return
+            }
+            showKeywordsList(strWordsList)
+        }
+    }
+
+    companion object {
+
+        const val ACTION_UPDATE_UI = "com.annie.dictionary.ACTION_UPDATE_UI"
+
+        const val ACTION_UPDATE_KEY = "receiver_update_ui"
+        // const
+        const val REQUEST_CODE = 101
+        const val POPUPWORDSLIST_TIMER = 200
+        const val LIST_WORDS_NORMAL = 0
+        const val LIST_WORDS_FUZZY = 1
+        const val LIST_WORDS_PATTERN = 2
+        const val LIST_WORDS_FULLTEXT = 3
+        var hasStoragePermission = false
+        //
+        var active = false
+        private var mProgressCBHandler: Handler? = null
+
+        fun lookupProgressCB(progress: Int) {
+            val m = Message.obtain()
+            m.arg1 = progress
+            m.target = mProgressCBHandler
+            m.sendToTarget()
+        }
+    }
+
+}
diff --git a/qDict/src/main/java/com/annie/dictionary/QDictEng.java b/qDict/src/main/java/com/annie/dictionary/QDictEng.java
index a5fe5fe..6550cf3 100644
--- a/qDict/src/main/java/com/annie/dictionary/QDictEng.java
+++ b/qDict/src/main/java/com/annie/dictionary/QDictEng.java
@@ -28,7 +28,7 @@ public class QDictEng {
 
     // This function is called in JNI C code, it must be 'static' function.
     private static void lookupProgressCB(int progress) {
-        MainActivity.lookupProgressCB(progress);
+        MainActivity.Companion.lookupProgressCB(progress);
     }
 
     // -----------------------------------------------------------------------------------------------------//
diff --git a/qDict/src/main/java/com/annie/dictionary/frags/BaseListFragment.java b/qDict/src/main/java/com/annie/dictionary/frags/BaseListFragment.java
index 201dcd7..2d7e117 100644
--- a/qDict/src/main/java/com/annie/dictionary/frags/BaseListFragment.java
+++ b/qDict/src/main/java/com/annie/dictionary/frags/BaseListFragment.java
@@ -5,6 +5,7 @@ import android.view.LayoutInflater;
 import android.view.View;
 import android.view.ViewGroup;
 
+import androidx.annotation.NonNull;
 import androidx.fragment.app.ListFragment;
 
 public abstract class BaseListFragment extends ListFragment {
@@ -23,7 +24,7 @@ public abstract class BaseListFragment extends ListFragment {
     }
 
     @Override
-    public void onViewCreated(View view, Bundle savedInstanceState) {
+    public void onViewCreated(@NonNull View view, Bundle savedInstanceState) {
         super.onViewCreated(view, savedInstanceState);
 
         if (!hasInitializedRootView) {
diff --git a/qDict/src/main/java/com/annie/dictionary/frags/ListDictFragment.java b/qDict/src/main/java/com/annie/dictionary/frags/ListDictFragment.java
index b51e6cc..720ad68 100644
--- a/qDict/src/main/java/com/annie/dictionary/frags/ListDictFragment.java
+++ b/qDict/src/main/java/com/annie/dictionary/frags/ListDictFragment.java
@@ -16,6 +16,7 @@ import android.widget.Button;
 import android.widget.CheckBox;
 import android.widget.ImageButton;
 import android.widget.RelativeLayout;
+import android.widget.Switch;
 import android.widget.TextView;
 
 import androidx.annotation.Nullable;
@@ -74,7 +75,7 @@ public class ListDictFragment extends ListFragment implements Def, OnItemClickLi
             }
         }
     };
-    private CheckBox mCheckBox;
+    private Switch mCheckBox;
     private TextView mEmptyDictTv, mDictCountTv;
     private RelativeLayout mEmptyDictLayout;
 
diff --git a/qDict/src/main/java/com/annie/dictionary/frags/PreferenceFragment.java b/qDict/src/main/java/com/annie/dictionary/frags/PreferenceFragment.java
index 3e6c38b..fed94a8 100644
--- a/qDict/src/main/java/com/annie/dictionary/frags/PreferenceFragment.java
+++ b/qDict/src/main/java/com/annie/dictionary/frags/PreferenceFragment.java
@@ -1,5 +1,6 @@
 package com.annie.dictionary.frags;
 
+import android.annotation.SuppressLint;
 import android.content.Intent;
 import android.os.Bundle;
 import android.os.Handler;
@@ -56,11 +57,11 @@ public abstract class PreferenceFragment extends Fragment
         }
 
     };
+    @SuppressLint("HandlerLeak")
     private Handler mHandler = new Handler() {
         @Override
         public void handleMessage(Message msg) {
             switch (msg.what) {
-
                 case MSG_BIND_PREFERENCES:
                     bindPreferences();
                     break;
diff --git a/qDict/src/main/java/com/annie/dictionary/frags/RecentFragment.java b/qDict/src/main/java/com/annie/dictionary/frags/RecentFragment.java
index e03f712..59ff437 100644
--- a/qDict/src/main/java/com/annie/dictionary/frags/RecentFragment.java
+++ b/qDict/src/main/java/com/annie/dictionary/frags/RecentFragment.java
@@ -54,7 +54,7 @@ public class RecentFragment extends BaseListFragment {
     }
 
     @Override
-    public void onAttach(Context context) {
+    public void onAttach(@NonNull Context context) {
         super.onAttach(context);
         setHasOptionsMenu(true);
     }
@@ -103,7 +103,6 @@ public class RecentFragment extends BaseListFragment {
         return getPersistentView(inflater, container, savedInstanceState, R.layout.fragment_recent);
     }
 
-    @SuppressWarnings("deprecation")
     @Override
     public void doInitialSetUpOfUI() {
         Bundle b = getArguments();
diff --git a/qDict/src/main/java/com/annie/dictionary/frags/SearchFragment.java b/qDict/src/main/java/com/annie/dictionary/frags/SearchFragment.java
index c443b24..2d78309 100644
--- a/qDict/src/main/java/com/annie/dictionary/frags/SearchFragment.java
+++ b/qDict/src/main/java/com/annie/dictionary/frags/SearchFragment.java
@@ -3,7 +3,6 @@ package com.annie.dictionary.frags;
 import android.content.Context;
 import android.content.Intent;
 import android.content.SharedPreferences;
-import android.os.Build;
 import android.os.Bundle;
 import android.text.TextUtils;
 import android.view.LayoutInflater;
@@ -17,6 +16,7 @@ import android.webkit.WebView;
 import android.widget.ImageButton;
 import android.widget.TextView;
 
+import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 import androidx.fragment.app.Fragment;
 
@@ -89,8 +89,7 @@ public class SearchFragment extends Fragment {
         mTvKeyword.setText(mKeyword);
         if (mMenu != null) {
             onCreateOptionsMenu(mMenu, mMenuInflater);
-            if (Build.VERSION.SDK_INT > 10)
-                getActivity().invalidateOptionsMenu();
+            getActivity().invalidateOptionsMenu();
         }
         showSearchContent();
     }
@@ -145,10 +144,10 @@ public class SearchFragment extends Fragment {
     public View onCreateView(LayoutInflater inflater, @Nullable ViewGroup container,
                              @Nullable Bundle savedInstanceState) {
         View root = inflater.inflate(R.layout.layout_search, container, false);
-        mDictBackBtn = (ImageButton) root.findViewById(R.id.back_word);
-        mTvKeyword = (TextView) root.findViewById(R.id.tv_title);
-        mSpeakBtn = (ImageButton) root.findViewById(R.id.action_speak);
-        mDictContentView = (WebView) root.findViewById(R.id.dictContentView);
+        mDictBackBtn = root.findViewById(R.id.back_word);
+        mTvKeyword = root.findViewById(R.id.tv_title);
+        mSpeakBtn = root.findViewById(R.id.action_speak);
+        mDictContentView = root.findViewById(R.id.dictContentView);
         DictWebViewClient webclient = new DictWebViewClient(getActivity().getApplicationContext(),
                 new MyWebViewClientCallback());
         mDictContentView.setWebViewClient(webclient);
@@ -159,35 +158,24 @@ public class SearchFragment extends Fragment {
         setHasOptionsMenu(true);
 
         // /
-        mDictBackBtn.setOnClickListener(new View.OnClickListener() {
-
-            @Override
-            public void onClick(View v) {
-                mCurrentHisIndex++;
-                String text = mWordsFileUtilsHis.getBeforeWord(mCurrentHisIndex);
-                if (!TextUtils.isEmpty(text)) {
-                    mBackClick = true;
-                    mKeyword = text;
-                    mTvKeyword.setText(mKeyword);
-                    if (mMenu != null) {
-                        onCreateOptionsMenu(mMenu, mMenuInflater);
-                        if (Build.VERSION.SDK_INT > 10)
-                            getActivity().invalidateOptionsMenu();
-                    }
-                    showSearchContent();
-                }
-                if (!mWordsFileUtilsHis.canBackSearch(mCurrentHisIndex + 1)) {
-                    mDictBackBtn.setVisibility(View.INVISIBLE);
+        mDictBackBtn.setOnClickListener(v -> {
+            mCurrentHisIndex++;
+            String text = mWordsFileUtilsHis.getBeforeWord(mCurrentHisIndex);
+            if (!TextUtils.isEmpty(text)) {
+                mBackClick = true;
+                mKeyword = text;
+                mTvKeyword.setText(mKeyword);
+                if (mMenu != null) {
+                    onCreateOptionsMenu(mMenu, mMenuInflater);
+                    getActivity().invalidateOptionsMenu();
                 }
+                showSearchContent();
             }
-        });
-        mSpeakBtn.setOnClickListener(new View.OnClickListener() {
-
-            @Override
-            public void onClick(View v) {
-                mSpeechEng.speak(mKeyword.trim());
+            if (!mWordsFileUtilsHis.canBackSearch(mCurrentHisIndex + 1)) {
+                mDictBackBtn.setVisibility(View.INVISIBLE);
             }
         });
+        mSpeakBtn.setOnClickListener(v -> mSpeechEng.speak(mKeyword.trim()));
         return root;
     }
 
@@ -196,7 +184,7 @@ public class SearchFragment extends Fragment {
         super.onActivityCreated(savedInstanceState);
         SharedPreferences mSharedPreferences = getActivity().getSharedPreferences(Def.APP_NAME, Context.MODE_PRIVATE);
 
-        if (mDictions == null && MainActivity.hasStoragePermission) {
+        if (mDictions == null && MainActivity.Companion.getHasStoragePermission()) {
             mDictions = new QDictions(getActivity());
             mDictions.initDicts();
         }
@@ -225,7 +213,7 @@ public class SearchFragment extends Fragment {
     }
 
     @Override
-    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
+    public void onCreateOptionsMenu(@NonNull Menu menu, @NonNull MenuInflater inflater) {
         super.onCreateOptionsMenu(menu, inflater);
         menu.clear();
         inflater.inflate(R.menu.search_menu, menu);
diff --git a/qDict/src/main/java/com/annie/dictionary/frags/SettingFragment.java b/qDict/src/main/java/com/annie/dictionary/frags/SettingFragment.java
index 0cd7807..041afda 100644
--- a/qDict/src/main/java/com/annie/dictionary/frags/SettingFragment.java
+++ b/qDict/src/main/java/com/annie/dictionary/frags/SettingFragment.java
@@ -10,11 +10,11 @@ import android.content.SharedPreferences.Editor;
 import android.graphics.Paint;
 import android.graphics.Typeface;
 import android.os.Bundle;
-import android.preference.CheckBoxPreference;
 import android.preference.ListPreference;
 import android.preference.Preference;
 import android.preference.Preference.OnPreferenceChangeListener;
 import android.preference.Preference.OnPreferenceClickListener;
+import android.preference.SwitchPreference;
 import android.text.SpannableStringBuilder;
 import android.text.Spanned;
 import android.text.TextPaint;
@@ -45,7 +45,7 @@ public class SettingFragment extends PreferenceFragment implements Def, OnPrefer
     private SharedPreferences mSharedPreferences;
     private Preference mPrefSource;
     private ListPreference mFontPreference, mThemePreference, mMaxFavPreference, mLangPreference;
-    private CheckBoxPreference mTTSPref, mNotifPref, mUseCapture;
+    private SwitchPreference mTTSPref, mNotifPref, mUseCapture;
     private int mCurrentFontIndex = 0;
     private int mCurrentThemeIndex = 0;
     private FragmentActivity activity;
@@ -99,14 +99,14 @@ public class SettingFragment extends PreferenceFragment implements Def, OnPrefer
         mThemePreference.setOnPreferenceChangeListener(this);
         mMaxFavPreference = (ListPreference) findPreference(getString(R.string.prefs_key_max_recent_word));
         mMaxFavPreference.setOnPreferenceChangeListener(this);
-        mTTSPref = (CheckBoxPreference) findPreference(getResources().getString(R.string.prefs_key_using_tts));
+        mTTSPref = (SwitchPreference) findPreference(getResources().getString(R.string.prefs_key_using_tts));
         mTTSPref.setOnPreferenceChangeListener(this);
         mLangPreference = (ListPreference) findPreference(getString(R.string.prefs_key_languages));
         mLangPreference.setOnPreferenceChangeListener(this);
-        mNotifPref = (CheckBoxPreference) findPreference(
+        mNotifPref = (SwitchPreference) findPreference(
                 getResources().getString(R.string.prefs_key_capture_notification));
         mNotifPref.setOnPreferenceChangeListener(this);
-        mUseCapture = (CheckBoxPreference) findPreference(getString(R.string.prefs_key_using_capture));
+        mUseCapture = (SwitchPreference) findPreference(getString(R.string.prefs_key_using_capture));
         mUseCapture.setOnPreferenceChangeListener(this);
         mLangValues = getResources().getStringArray(R.array.language_values);
         initInfo();
diff --git a/qDict/src/main/java/com/annie/dictionary/service/QDictService.java b/qDict/src/main/java/com/annie/dictionary/service/QDictService.java
index 3f6d597..6f067e9 100644
--- a/qDict/src/main/java/com/annie/dictionary/service/QDictService.java
+++ b/qDict/src/main/java/com/annie/dictionary/service/QDictService.java
@@ -120,7 +120,7 @@ public class QDictService extends StandOutWindow {
             return;
         if (clipboardText.length() > 0) {
             mClipboardText = clipboardText;
-            if (!MainActivity.active) {
+            if (!MainActivity.Companion.getActive()) {
                 showCaptureWindow();
                 if (Utils.isSdCardWrittenable())
                     mThreadPool.execute(new WriteHistoryRunnable(mClipboardText));
@@ -143,7 +143,7 @@ public class QDictService extends StandOutWindow {
 
     @Override
     public void onCreate() {
-        if (Utils.hasSelfPermission(this, BaseActivity.STORAGE_PERMISSIONS)) {
+        if (Utils.hasSelfPermission(this, BaseActivity.Companion.getSTORAGE_PERMISSIONS())) {
             mQDictions = new QDictions(this);
         } else {
             stopSelf();
diff --git a/qDict/src/main/java/com/annie/dictionary/utils/WordsFileUtils.java b/qDict/src/main/java/com/annie/dictionary/utils/WordsFileUtils.java
index 4c6472e..c766981 100644
--- a/qDict/src/main/java/com/annie/dictionary/utils/WordsFileUtils.java
+++ b/qDict/src/main/java/com/annie/dictionary/utils/WordsFileUtils.java
@@ -21,10 +21,10 @@ public class WordsFileUtils {
 
     SharedPreferences mShares;
     int maxWords = Def.MAX_COUNT;
-    private String mPath = null;
+    private String mPath;
     private String mName = null;
-    private boolean mChanged = false;
-    private ArrayList<String> mWordsArrayList = null;
+    private boolean mChanged;
+    private ArrayList<String> mWordsArrayList;
 
     public WordsFileUtils(SharedPreferences shares, int typeHis) {
         mPath = Utils.getRootDictFolder(shares) + "/" + Def.WORDSLIST_FOLDER;
diff --git a/qDict/src/main/java/com/mmt/app/SlidingActivityBase.java b/qDict/src/main/java/com/mmt/app/SlidingActivityBase.java
deleted file mode 100644
index fda7b1c..0000000
--- a/qDict/src/main/java/com/mmt/app/SlidingActivityBase.java
+++ /dev/null
@@ -1,79 +0,0 @@
-package com.mmt.app;
-
-import android.view.View;
-import android.view.ViewGroup.LayoutParams;
-
-import com.mmt.widget.slidemenu.SlidingMenu;
-
-public interface SlidingActivityBase {
-
-    /**
-     * Set the behind view content to an explicit view. This view is placed
-     * directly into the behind view 's view hierarchy. It can itself be a
-     * complex view hierarchy.
-     *
-     * @param view         The desired content to display.
-     * @param layoutParams Layout parameters for the view.
-     */
-    public void setBehindContentView(View view, LayoutParams layoutParams);
-
-    /**
-     * Set the behind view content to an explicit view. This view is placed
-     * directly into the behind view 's view hierarchy. It can itself be a
-     * complex view hierarchy. When calling this method, the layout parameters
-     * of the specified view are ignored. Both the width and the height of the
-     * view are set by default to MATCH_PARENT. To use your own layout
-     * parameters, invoke setContentView(android.view.View,
-     * android.view.ViewGroup.LayoutParams) instead.
-     *
-     * @param view The desired content to display.
-     */
-    public void setBehindContentView(View view);
-
-    /**
-     * Set the behind view content from a layout resource. The resource will be
-     * inflated, adding all top-level views to the behind view.
-     *
-     * @param layoutResID Resource ID to be inflated.
-     */
-    public void setBehindContentView(int layoutResID);
-
-    /**
-     * Gets the SlidingMenu associated with this activity.
-     *
-     * @return the SlidingMenu associated with this activity.
-     */
-    public SlidingMenu getSlidingMenu();
-
-    /**
-     * Toggle the SlidingMenu. If it is open, it will be closed, and vice versa.
-     */
-    public void toggle();
-
-    /**
-     * Close the SlidingMenu and show the content view.
-     */
-    public void showContent();
-
-    /**
-     * Open the SlidingMenu and show the menu view.
-     */
-    public void showMenu();
-
-    /**
-     * Open the SlidingMenu and show the secondary (right) menu view. Will
-     * default to the regular menu if there is only one.
-     */
-    public void showSecondaryMenu();
-
-    /**
-     * Controls whether the ActionBar slides along with the above view when the
-     * menu is opened, or if it stays in place.
-     *
-     * @param slidingActionBarEnabled True if you want the ActionBar to slide
-     *                                along with the SlidingMenu, false if you want the ActionBar to
-     *                                stay in place
-     */
-    public void setSlidingActionBarEnabled(boolean slidingActionBarEnabled);
-
-}
diff --git a/qDict/src/main/java/com/mmt/app/SlidingActivityHelper.java b/qDict/src/main/java/com/mmt/app/SlidingActivityHelper.java
deleted file mode 100644
index 05baad7..0000000
--- a/qDict/src/main/java/com/mmt/app/SlidingActivityHelper.java
+++ /dev/null
@@ -1,225 +0,0 @@
-package com.mmt.app;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.os.Handler;
-import android.view.KeyEvent;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup.LayoutParams;
-
-import com.annie.dictionary.R;
-import com.mmt.widget.slidemenu.SlidingMenu;
-
-public class SlidingActivityHelper {
-
-    private Activity mActivity;
-
-    private SlidingMenu mSlidingMenu;
-
-    private View mViewAbove;
-
-    private View mViewBehind;
-
-    private boolean mBroadcasting = false;
-
-    private boolean mOnPostCreateCalled = false;
-
-    private boolean mEnableSlide = true;
-
-    /**
-     * Instantiates a new SlidingActivityHelper.
-     *
-     * @param activity the associated activity
-     */
-    public SlidingActivityHelper(Activity activity) {
-        mActivity = activity;
-    }
-
-    /**
-     * Sets mSlidingMenu as a newly inflated SlidingMenu. Should be called
-     * within the activitiy's onCreate()
-     *
-     * @param savedInstanceState the saved instance state (unused)
-     */
-    public void onCreate(Bundle savedInstanceState) {
-        mSlidingMenu = (SlidingMenu) LayoutInflater.from(mActivity).inflate(R.layout.slidingmenumain, null);
-    }
-
-    /**
-     * Further SlidingMenu initialization. Should be called within the
-     * activitiy's onPostCreate()
-     *
-     * @param savedInstanceState the saved instance state (unused)
-     */
-    public void onPostCreate(Bundle savedInstanceState) {
-        if (mViewBehind == null || mViewAbove == null) {
-            throw new IllegalStateException(
-                    "Both setBehindContentView must be called " + "in onCreate in addition to setContentView.");
-        }
-
-        mOnPostCreateCalled = true;
-
-        mSlidingMenu.attachToActivity(mActivity,
-                mEnableSlide ? SlidingMenu.SLIDING_WINDOW : SlidingMenu.SLIDING_CONTENT);
-
-        final boolean open;
-        final boolean secondary;
-        if (savedInstanceState != null) {
-            open = savedInstanceState.getBoolean("SlidingActivityHelper.open");
-            secondary = savedInstanceState.getBoolean("SlidingActivityHelper.secondary");
-        } else {
-            open = false;
-            secondary = false;
-        }
-        new Handler().post(() -> {
-            if (open) {
-                if (secondary) {
-                    mSlidingMenu.showSecondaryMenu(false);
-                } else {
-                    mSlidingMenu.showMenu(false);
-                }
-            } else {
-                mSlidingMenu.showContent(false);
-            }
-        });
-    }
-
-    /**
-     * Controls whether the ActionBar slides along with the above view when the
-     * menu is opened, or if it stays in place.
-     *
-     * @param slidingActionBarEnabled True if you want the ActionBar to slide
-     *                                along with the SlidingMenu, false if you want the ActionBar to
-     *                                stay in place
-     */
-    public void setSlidingActionBarEnabled(boolean slidingActionBarEnabled) {
-        if (mOnPostCreateCalled)
-            throw new IllegalStateException("enableSlidingActionBar must be called in onCreate.");
-        mEnableSlide = slidingActionBarEnabled;
-    }
-
-    /**
-     * Finds a view that was identified by the id attribute from the XML that
-     * was processed in onCreate(Bundle).
-     *
-     * @param id the resource id of the desired view
-     * @return The view if found or null otherwise.
-     */
-    public View findViewById(int id) {
-        View v;
-        if (mSlidingMenu != null) {
-            v = mSlidingMenu.findViewById(id);
-            if (v != null)
-                return v;
-        }
-        return null;
-    }
-
-    /**
-     * Called to retrieve per-instance state from an activity before being
-     * killed so that the state can be restored in onCreate(Bundle) or
-     * onRestoreInstanceState(Bundle) (the Bundle populated by this method will
-     * be passed to both).
-     *
-     * @param outState Bundle in which to place your saved state.
-     */
-    public void onSaveInstanceState(Bundle outState) {
-        outState.putBoolean("SlidingActivityHelper.open", mSlidingMenu.isMenuShowing());
-        outState.putBoolean("SlidingActivityHelper.secondary", mSlidingMenu.isSecondaryMenuShowing());
-    }
-
-    /**
-     * Register the above content view.
-     *
-     * @param v      the above content view to register
-     * @param params LayoutParams for that view (unused)
-     */
-    public void registerAboveContentView(View v, LayoutParams params) {
-        if (!mBroadcasting)
-            mViewAbove = v;
-    }
-
-    /**
-     * Set the activity content to an explicit view. This view is placed
-     * directly into the activity's view hierarchy. It can itself be a complex
-     * view hierarchy. When calling this method, the layout parameters of the
-     * specified view are ignored. Both the width and the height of the view are
-     * set by default to MATCH_PARENT. To use your own layout parameters, invoke
-     * setContentView(android.view.View, android.view.ViewGroup.LayoutParams)
-     * instead.
-     *
-     * @param v The desired content to display.
-     */
-    public void setContentView(View v) {
-        mBroadcasting = true;
-        mActivity.setContentView(v);
-    }
-
-    /**
-     * Set the behind view content to an explicit view. This view is placed
-     * directly into the behind view 's view hierarchy. It can itself be a
-     * complex view hierarchy.
-     *
-     * @param view         The desired content to display.
-     * @param layoutParams Layout parameters for the view. (unused)
-     */
-    public void setBehindContentView(View view, LayoutParams layoutParams) {
-        mViewBehind = view;
-        mSlidingMenu.setMenu(mViewBehind);
-    }
-
-    /**
-     * Gets the SlidingMenu associated with this activity.
-     *
-     * @return the SlidingMenu associated with this activity.
-     */
-    public SlidingMenu getSlidingMenu() {
-        return mSlidingMenu;
-    }
-
-    /**
-     * Toggle the SlidingMenu. If it is open, it will be closed, and vice versa.
-     */
-    public boolean toggle() {
-        return mSlidingMenu.toggle();
-    }
-
-    /**
-     * Close the SlidingMenu and show the content view.
-     */
-    public void showContent() {
-        mSlidingMenu.showContent();
-    }
-
-    /**
-     * Open the SlidingMenu and show the menu view.
-     */
-    public void showMenu() {
-        mSlidingMenu.showMenu();
-    }
-
-    /**
-     * Open the SlidingMenu and show the secondary menu view. Will default to
-     * the regular menu if there is only one.
-     */
-    public void showSecondaryMenu() {
-        mSlidingMenu.showSecondaryMenu();
-    }
-
-    /**
-     * On key up.
-     *
-     * @param keyCode the key code
-     * @param event   the event
-     * @return true, if successful
-     */
-    public boolean onKeyUp(int keyCode, KeyEvent event) {
-        if (keyCode == KeyEvent.KEYCODE_BACK && mSlidingMenu.isMenuShowing()) {
-            showContent();
-            return true;
-        }
-        return false;
-    }
-
-}
diff --git a/qDict/src/main/java/com/mmt/app/SlidingFragmentActivity.java b/qDict/src/main/java/com/mmt/app/SlidingFragmentActivity.java
deleted file mode 100644
index a9b2c2b..0000000
--- a/qDict/src/main/java/com/mmt/app/SlidingFragmentActivity.java
+++ /dev/null
@@ -1,186 +0,0 @@
-package com.mmt.app;
-
-import android.os.Bundle;
-import android.view.KeyEvent;
-import android.view.View;
-import android.view.ViewGroup.LayoutParams;
-
-import androidx.appcompat.app.AppCompatActivity;
-
-import com.mmt.widget.slidemenu.SlidingMenu;
-
-public abstract class SlidingFragmentActivity extends AppCompatActivity implements SlidingActivityBase {
-
-    private SlidingActivityHelper mHelper;
-
-    /*
-     * (non-Javadoc)
-     * @see android.support.v4.app.FragmentActivity#onCreate(android.os.Bundle)
-     */
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        mHelper = new SlidingActivityHelper(this);
-        mHelper.onCreate(savedInstanceState);
-    }
-
-    /*
-     * (non-Javadoc)
-     * @see android.app.Activity#onPostCreate(android.os.Bundle)
-     */
-    @Override
-    public void onPostCreate(Bundle savedInstanceState) {
-        super.onPostCreate(savedInstanceState);
-        mHelper.onPostCreate(savedInstanceState);
-    }
-
-    /*
-     * (non-Javadoc)
-     * @see android.app.Activity#findViewById(int)
-     */
-    @Override
-    public View findViewById(int id) {
-        View v = super.findViewById(id);
-        if (v != null)
-            return v;
-        return mHelper.findViewById(id);
-    }
-
-    /*
-     * (non-Javadoc)
-     * @see
-     * android.support.v4.app.FragmentActivity#onSaveInstanceState(android.os
-     * .Bundle)
-     */
-    @Override
-    protected void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-        mHelper.onSaveInstanceState(outState);
-    }
-
-    /*
-     * (non-Javadoc)
-     * @see android.app.Activity#setContentView(int)
-     */
-    @Override
-    public void setContentView(int id) {
-        setContentView(getLayoutInflater().inflate(id, null));
-    }
-
-    /*
-     * (non-Javadoc)
-     * @see android.app.Activity#setContentView(android.view.View)
-     */
-    @Override
-    public void setContentView(View v) {
-        setContentView(v, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
-    }
-
-    /*
-     * (non-Javadoc)
-     * @see android.app.Activity#setContentView(android.view.View,
-     * android.view.ViewGroup.LayoutParams)
-     */
-    @Override
-    public void setContentView(View v, LayoutParams params) {
-        super.setContentView(v, params);
-        mHelper.registerAboveContentView(v, params);
-    }
-
-    /*
-     * (non-Javadoc)
-     * @see com.jeremyfeinstein.slidingmenu.lib.app.SlidingActivityBase#
-     * setBehindContentView(int)
-     */
-    public void setBehindContentView(int id) {
-        setBehindContentView(getLayoutInflater().inflate(id, null));
-    }
-
-    /*
-     * (non-Javadoc)
-     * @see com.jeremyfeinstein.slidingmenu.lib.app.SlidingActivityBase#
-     * setBehindContentView(android.view.View)
-     */
-    public void setBehindContentView(View v) {
-        setBehindContentView(v, new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT));
-    }
-
-    /*
-     * (non-Javadoc)
-     * @see com.jeremyfeinstein.slidingmenu.lib.app.SlidingActivityBase#
-     * setBehindContentView(android.view.View,
-     * android.view.ViewGroup.LayoutParams)
-     */
-    public void setBehindContentView(View v, LayoutParams params) {
-        mHelper.setBehindContentView(v, params);
-    }
-
-    /*
-     * (non-Javadoc)
-     * @see com.jeremyfeinstein.slidingmenu.lib.app.SlidingActivityBase#
-     * getSlidingMenu ()
-     */
-    public SlidingMenu getSlidingMenu() {
-        return mHelper.getSlidingMenu();
-    }
-
-    /*
-     * (non-Javadoc)
-     * @see com.jeremyfeinstein.slidingmenu.lib.app.SlidingActivityBase#toggle()
-     */
-    public void toggle() {
-        boolean showContent = mHelper.toggle();
-        resroteDefaultFragment();
-    }
-
-    public abstract void resroteDefaultFragment();
-
-    /*
-     * (non-Javadoc)
-     * @see
-     * com.jeremyfeinstein.slidingmenu.lib.app.SlidingActivityBase#showAbove()
-     */
-    public void showContent() {
-        mHelper.showContent();
-    }
-
-    /*
-     * (non-Javadoc)
-     * @see
-     * com.jeremyfeinstein.slidingmenu.lib.app.SlidingActivityBase#showBehind()
-     */
-    public void showMenu() {
-        mHelper.showMenu();
-    }
-
-    /*
-     * (non-Javadoc)
-     * @see com.jeremyfeinstein.slidingmenu.lib.app.SlidingActivityBase#
-     * showSecondaryMenu ()
-     */
-    public void showSecondaryMenu() {
-        mHelper.showSecondaryMenu();
-    }
-
-    /*
-     * (non-Javadoc)
-     * @see com.jeremyfeinstein.slidingmenu.lib.app.SlidingActivityBase#
-     * setSlidingActionBarEnabled(boolean)
-     */
-    public void setSlidingActionBarEnabled(boolean b) {
-        mHelper.setSlidingActionBarEnabled(b);
-    }
-
-    /*
-     * (non-Javadoc)
-     * @see android.app.Activity#onKeyUp(int, android.view.KeyEvent)
-     */
-    @Override
-    public boolean onKeyUp(int keyCode, KeyEvent event) {
-        boolean b = mHelper.onKeyUp(keyCode, event);
-        if (b)
-            return b;
-        return super.onKeyUp(keyCode, event);
-    }
-
-}
diff --git a/qDict/src/main/java/com/mmt/widget/ActionButton.java b/qDict/src/main/java/com/mmt/widget/ActionButton.java
deleted file mode 100644
index 330925d..0000000
--- a/qDict/src/main/java/com/mmt/widget/ActionButton.java
+++ /dev/null
@@ -1,1432 +0,0 @@
-/*
- * Copyright 2015 Shell Software Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * File created: 2015-01-17 10:39:13
- */
-
-package com.mmt.widget;
-
-import android.annotation.SuppressLint;
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.Paint;
-import android.graphics.drawable.BitmapDrawable;
-import android.graphics.drawable.Drawable;
-import android.os.Build;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.MotionEvent;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.ViewOutlineProvider;
-import android.view.animation.Animation;
-import android.view.animation.AnimationUtils;
-
-import com.annie.dictionary.R;
-
-
-/**
- * This class represents a <b>Action Button</b>, which is used in
- * <a href="http://www.google.com.ua/design/spec/components/buttons.html">Material Design</a>
- */
-public class ActionButton extends View {
-
-    /**
-     * Logging tag
-     */
-    private static final String LOG_TAG = "M2t";
-
-    /**
-     * <b>Action Button</b> type
-     */
-    private Type type = Type.DEFAULT;
-
-    /**
-     * <b>Action Button</b> state
-     */
-    private State state = State.NORMAL;
-
-    /**
-     * <b>Action Button</b> color in {@link State#NORMAL} state
-     */
-    private int buttonColor = Color.LTGRAY;
-
-    /**
-     * <b>Action Button</b> color in {@link State#PRESSED} state
-     */
-    private int buttonColorPressed = Color.DKGRAY;
-
-    /**
-     * Shadow radius expressed in actual pixels
-     */
-    private float shadowRadius = MetricsConverter.dpToPx(getContext(), 2.0f);
-
-    /**
-     * Shadow X-axis offset expressed in actual pixels
-     */
-    private float shadowXOffset = MetricsConverter.dpToPx(getContext(), 1.0f);
-
-    /**
-     * Shadow Y-axis offset expressed in actual pixels
-     */
-    private float shadowYOffset = MetricsConverter.dpToPx(getContext(), 1.5f);
-
-    /**
-     * Shadow color
-     */
-    private int shadowColor = Color.parseColor("#757575");
-
-    /**
-     * Stroke width
-     */
-    private float strokeWidth = 0.0f;
-
-    /**
-     * Stroke color
-     */
-    private int strokeColor = Color.BLACK;
-
-    /**
-     * <b>Action Button</b> image drawable centered inside the view
-     */
-    private Drawable image;
-
-    /**
-     * Size of the <b>Action Button</b> image inside the view
-     */
-    private float imageSize = MetricsConverter.dpToPx(getContext(), 24.0f);
-
-    /**
-     * Animation, which is used while showing <b>Action Button</b>
-     */
-    private Animation showAnimation;
-
-    /**
-     * Animation, which is used while hiding or dismissing <b>Action Button</b>
-     */
-    private Animation hideAnimation;
-
-    /**
-     * {@link Paint}, which is used for drawing the elements of
-     * <b>Action Button</b>
-     */
-    protected final Paint paint = new Paint(Paint.ANTI_ALIAS_FLAG);
-
-    /**
-     * Creates an instance of the <b>Action Button</b>
-     * <p>
-     * Used when instantiating <b>Action Button</b> programmatically
-     *
-     * @param context context the view is running in
-     */
-    public ActionButton(Context context) {
-        super(context);
-        initActionButton();
-    }
-
-    /**
-     * Creates an instance of the <b>Action Button</b>
-     * <p>
-     * Used when inflating the declared <b>Action Button</b>
-     * within XML resource
-     *
-     * @param context context the view is running in
-     * @param attrs   attributes of the XML tag that is inflating the view
-     */
-    public ActionButton(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        initActionButton(context, attrs, 0, 0);
-    }
-
-    /**
-     * Creates an instance of the <b>Action Button</b>
-     * <p>
-     * Used when inflating the declared <b>Action Button</b>
-     * within XML resource
-     *
-     * @param context      context the view is running in
-     * @param attrs        attributes of the XML tag that is inflating the view
-     * @param defStyleAttr attribute in the current theme that contains a
-     *                     reference to a style resource that supplies default values for
-     *                     the view. Can be 0 to not look for defaults
-     */
-    public ActionButton(Context context, AttributeSet attrs, int defStyleAttr) {
-        super(context, attrs, defStyleAttr);
-        initActionButton(context, attrs, defStyleAttr, 0);
-    }
-
-    /**
-     * Creates an instance of the <b>Action Button</b>
-     * <p>
-     * Used when inflating the declared <b>Action Button</b>
-     * within XML resource
-     * <p>
-     * Might be called if target API is LOLLIPOP (21) and higher
-     *
-     * @param context      context the view is running in
-     * @param attrs        attributes of the XML tag that is inflating the view
-     * @param defStyleAttr attribute in the current theme that contains a
-     *                     reference to a style resource that supplies default values for
-     *                     the view. Can be 0 to not look for defaults
-     * @param defStyleRes  resource identifier of a style resource that
-     *                     supplies default values for the view, used only if
-     *                     defStyleAttr is 0 or can not be found in the theme. Can be 0
-     *                     to not look for defaults
-     */
-    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
-    public ActionButton(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
-        super(context, attrs, defStyleAttr, defStyleRes);
-        initActionButton(context, attrs, defStyleAttr, defStyleRes);
-    }
-
-    /**
-     * Initializes the <b>Action Button</b>, which is created programmatically
-     */
-    private void initActionButton() {
-        initLayerType();
-        Log.v(LOG_TAG, "Action Button initialized");
-    }
-
-    /**
-     * Initializes the <b>Action Button</b>, which is declared within XML resource
-     * <p>
-     * Makes calls to different initialization methods for parameters initialization.
-     * For those parameters, which are not declared in the XML resource,
-     * the default value will be used
-     *
-     * @param context      context the view is running in
-     * @param attrs        attributes of the XML tag that is inflating the view
-     * @param defStyleAttr attribute in the current theme that contains a
-     *                     reference to a style resource that supplies default values for
-     *                     the view. Can be 0 to not look for defaults
-     * @param defStyleRes  resource identifier of a style resource that
-     *                     supplies default values for the view, used only if
-     *                     defStyleAttr is 0 or can not be found in the theme. Can be 0
-     *                     to not look for defaults
-     */
-    private void initActionButton(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
-        initLayerType();
-        TypedArray attributes = context.getTheme().obtainStyledAttributes(attrs, R.styleable.ActionButton,
-                defStyleAttr, defStyleRes);
-        try {
-            initType(attributes);
-            initButtonColor(attributes);
-            initButtonColorPressed(attributes);
-            initShadowRadius(attributes);
-            initShadowXOffset(attributes);
-            initShadowYOffset(attributes);
-            initShadowColor(attributes);
-            initStrokeWidth(attributes);
-            initStrokeColor(attributes);
-            initImage(attributes);
-            initImageSize(attributes);
-            initShowAnimation(attributes);
-            initHideAnimation(attributes);
-        } catch (Exception e) {
-            Log.e(LOG_TAG, "Unable to read attr", e);
-        } finally {
-            attributes.recycle();
-        }
-        Log.v(LOG_TAG, "Action Button initialized");
-    }
-
-    /**
-     * Initializes the layer type needed for shadows drawing
-     * <p>
-     * Might be called if target API is HONEYCOMB (11) and higher
-     */
-    private void initLayerType() {
-        setLayerType(LAYER_TYPE_SOFTWARE, paint);
-    }
-
-    /**
-     * Initializes the {@link Type} of <b>Action Button</b>
-     *
-     * @param attrs attributes of the XML tag that is inflating the view
-     */
-    private void initType(TypedArray attrs) {
-        if (attrs.hasValue(R.styleable.ActionButton_type)) {
-            final int id = attrs.getInteger(R.styleable.ActionButton_type, type.getId());
-            type = Type.forId(id);
-            Log.v(LOG_TAG, "Initialized type: " + getType());
-        }
-    }
-
-    /**
-     * Initializes the <b>Action Button</b> color for
-     * {@link #state} set to {@link State#NORMAL}
-     *
-     * @param attrs attributes of the XML tag that is inflating the view
-     */
-    private void initButtonColor(TypedArray attrs) {
-        if (attrs.hasValue(R.styleable.ActionButton_button_color)) {
-            buttonColor = attrs.getColor(R.styleable.ActionButton_button_color, buttonColor);
-            Log.v(LOG_TAG, "Initialized button color: " + getButtonColor());
-        }
-    }
-
-    /**
-     * Initializes the <b>Action Button</b> color for
-     * {@link #state} set to {@link State#PRESSED}
-     *
-     * @param attrs attributes of the XML tag that is inflating the view
-     */
-    private void initButtonColorPressed(TypedArray attrs) {
-        if (attrs.hasValue(R.styleable.ActionButton_button_colorPressed)) {
-            buttonColorPressed = attrs.getColor(R.styleable.ActionButton_button_colorPressed,
-                    buttonColorPressed);
-            Log.v(LOG_TAG, "Initialized button color pressed: " + getButtonColorPressed());
-        }
-    }
-
-    /**
-     * Initializes the shadow radius
-     *
-     * @param attrs attributes of the XML tag that is inflating the view
-     */
-    private void initShadowRadius(TypedArray attrs) {
-        if (attrs.hasValue(R.styleable.ActionButton_shadow_radius)) {
-            shadowRadius = attrs.getDimension(R.styleable.ActionButton_shadow_radius, shadowRadius);
-            Log.v(LOG_TAG, "Initialized shadow radius: " + getShadowRadius());
-        }
-    }
-
-    /**
-     * Initializes the shadow X-axis offset
-     *
-     * @param attrs attributes of the XML tag that is inflating the view
-     */
-    private void initShadowXOffset(TypedArray attrs) {
-        if (attrs.hasValue(R.styleable.ActionButton_shadow_xOffset)) {
-            shadowXOffset = attrs.getDimension(R.styleable.ActionButton_shadow_xOffset, shadowXOffset);
-            Log.v(LOG_TAG, "Initialized shadow X-axis offset: " + getShadowXOffset());
-        }
-    }
-
-    /**
-     * Initializes the shadow Y-axis offset
-     *
-     * @param attrs attributes of the XML tag that is inflating the view
-     */
-    private void initShadowYOffset(TypedArray attrs) {
-        if (attrs.hasValue(R.styleable.ActionButton_shadow_yOffset)) {
-            shadowYOffset = attrs.getDimension(R.styleable.ActionButton_shadow_yOffset, shadowYOffset);
-            Log.v(LOG_TAG, "Initialized shadow Y-axis offset: " + getShadowYOffset());
-        }
-    }
-
-    /**
-     * Initializes the shadow color
-     *
-     * @param attrs attributes of the XML tag that is inflating the view
-     */
-    private void initShadowColor(TypedArray attrs) {
-        if (attrs.hasValue(R.styleable.ActionButton_shadow_color)) {
-            shadowColor = attrs.getColor(R.styleable.ActionButton_shadow_color, shadowColor);
-            Log.v(LOG_TAG, "Initialized shadow color: " + getShadowColor());
-        }
-    }
-
-    /**
-     * Initializes the stroke width
-     *
-     * @param attrs attributes of the XML tag that is inflating the view
-     */
-    private void initStrokeWidth(TypedArray attrs) {
-        if (attrs.hasValue(R.styleable.ActionButton_stroke_width)) {
-            strokeWidth = attrs.getDimension(R.styleable.ActionButton_stroke_width, strokeWidth);
-            Log.v(LOG_TAG, "Initialized stroke width: " + getStrokeWidth());
-        }
-    }
-
-    /**
-     * Initializes the stroke color
-     *
-     * @param attrs attributes of the XML tag that is inflating the view
-     */
-    private void initStrokeColor(TypedArray attrs) {
-        if (attrs.hasValue(R.styleable.ActionButton_stroke_color)) {
-            strokeColor = attrs.getColor(R.styleable.ActionButton_stroke_color, strokeColor);
-            Log.v(LOG_TAG, "Initialized stroke color: " + getStrokeColor());
-        }
-    }
-
-    /**
-     * Initializes the animation, which is used while showing
-     * <b>Action Button</b>
-     *
-     * @param attrs attributes of the XML tag that is inflating the view
-     */
-    private void initShowAnimation(TypedArray attrs) {
-        if (attrs.hasValue(R.styleable.ActionButton_show_animation)) {
-            final int animResId = attrs.getResourceId(R.styleable.ActionButton_show_animation,
-                    Animations.NONE.animResId);
-            showAnimation = Animations.load(getContext(), animResId);
-            Log.v(LOG_TAG, "Initialized animation on show");
-        }
-    }
-
-    /**
-     * Initializes the animation, which is used while hiding or dismissing
-     * <b>Action Button</b>
-     *
-     * @param attrs attributes of the XML tag that is inflating the view
-     */
-    private void initHideAnimation(TypedArray attrs) {
-        if (attrs.hasValue(R.styleable.ActionButton_hide_animation)) {
-            final int animResId = attrs.getResourceId(R.styleable.ActionButton_hide_animation,
-                    Animations.NONE.animResId);
-            hideAnimation = Animations.load(getContext(), animResId);
-            Log.v(LOG_TAG, "Initialized animation on hide");
-        }
-    }
-
-    /**
-     * Initializes the image inside <b>Action Button</b>
-     *
-     * @param attrs attributes of the XML tag that is inflating the view
-     */
-    private void initImage(TypedArray attrs) {
-        if (attrs.hasValue(R.styleable.ActionButton_image)) {
-            image = attrs.getDrawable(R.styleable.ActionButton_image);
-            Log.v(LOG_TAG, "Initialized image");
-        }
-    }
-
-    /**
-     * Initializes the image size inside <b>Action Button</b>
-     * <p>
-     * Changing the default size of the image breaks the rules of
-     * <a href="http://www.google.com/design/spec/components/buttons.html">Material Design</a>
-     *
-     * @param attrs attributes of the XML tag that is inflating the view
-     */
-    private void initImageSize(TypedArray attrs) {
-        if (attrs.hasValue(R.styleable.ActionButton_image_size)) {
-            imageSize = attrs.getDimension(R.styleable.ActionButton_image_size, imageSize);
-            Log.v(LOG_TAG, "Initialized image size: " + getImageSize());
-        }
-    }
-
-    /**
-     * Plays the {@link #showAnimation} if set
-     */
-    public void playShowAnimation() {
-        startAnimation(getShowAnimation());
-    }
-
-    /**
-     * Plays the {@link #hideAnimation} if set
-     */
-    public void playHideAnimation() {
-        startAnimation(getHideAnimation());
-    }
-
-    /**
-     * Makes the <b>Action Button</b> to appear and
-     * sets its visibility to {@link #VISIBLE}
-     * <p>
-     * {@link #showAnimation} is played if set
-     */
-    public void show() {
-        if (isHidden()) {
-            playShowAnimation();
-            setVisibility(VISIBLE);
-            Log.v(LOG_TAG, "Action Button shown");
-        }
-    }
-
-    /**
-     * Makes the <b>Action Button</b> to disappear and
-     * sets its visibility to {@link #INVISIBLE}
-     * <p>
-     * {@link #hideAnimation} is played if set
-     */
-    public void hide() {
-        if (!isHidden() && !isDismissed()) {
-            playHideAnimation();
-            setVisibility(INVISIBLE);
-            Log.v(LOG_TAG, "Action Button hidden");
-        }
-    }
-
-    /**
-     * Completely dismisses the <b>Action Button</b>,
-     * sets its visibility to {@link #GONE} and removes it from the parent view
-     * <p>
-     * After calling this method any calls to {@link #show()} won't result in showing
-     * the <b>Action Button</b> so far as it is removed from the parent View
-     * <p>
-     * {@link #hideAnimation} is played if set
-     */
-    public void dismiss() {
-        if (!isDismissed()) {
-            if (!isHidden()) {
-                playHideAnimation();
-            }
-            setVisibility(GONE);
-            ViewGroup parent = (ViewGroup) getParent();
-            parent.removeView(this);
-            Log.v(LOG_TAG, "Action Button dismissed");
-        }
-    }
-
-    /**
-     * Checks whether <b>Action Button</b> is hidden
-     *
-     * @return true if <b>Action Button</b> is hidden, otherwise false
-     */
-    public boolean isHidden() {
-        return getVisibility() == INVISIBLE;
-    }
-
-    /**
-     * Checks whether <b>Action Button</b> is dismissed
-     *
-     * @return true if <b>Action Button</b> is dismissed, otherwise false
-     */
-    public boolean isDismissed() {
-        ViewGroup parent = (ViewGroup) getParent();
-        return parent == null;
-    }
-
-    /**
-     * Returns the size of the <b>Action Button</b> in actual pixels (px).
-     * Size of the <b>Action Button</b> is the diameter of the main circle
-     *
-     * @return size of the <b>Action Button</b> in actual pixels (px)
-     */
-    public int getButtonSize() {
-        final int buttonSize = (int) type.getSize(getContext());
-        Log.v(LOG_TAG, "Button size is: " + buttonSize);
-        return buttonSize;
-    }
-
-    /**
-     * Returns the type of the <b>Action Button</b>
-     *
-     * @return type of the <b>Action Button</b>
-     */
-    public Type getType() {
-        return type;
-    }
-
-    /**
-     * Sets the type of the <b>Action Button</b> and
-     * invalidates the layout of the view
-     *
-     * @param type type of the <b>Action Button</b>
-     */
-    public void setType(Type type) {
-        this.type = type;
-        requestLayout();
-        Log.v(LOG_TAG, "Type changed to: " + getType());
-    }
-
-    /**
-     * Returns the current state of the <b>Action Button</b>
-     *
-     * @return current state of the <b>Action Button</b>
-     */
-    public State getState() {
-        return state;
-    }
-
-    /**
-     * Sets the current state of the <b>Action Button</b> and
-     * invalidates the view
-     *
-     * @param state new state of the <b>Action Button</b>
-     */
-    public void setState(State state) {
-        this.state = state;
-        invalidate();
-        Log.v(LOG_TAG, "State changed to: " + getState());
-    }
-
-    /**
-     * Returns the <b>Action Button</b> color when in
-     * {@link State#NORMAL} state
-     *
-     * @return <b>Action Button</b> color when in
-     * {@link State#NORMAL} state
-     */
-    public int getButtonColor() {
-        return buttonColor;
-    }
-
-    /**
-     * Sets the <b>Action Button</b> color when in
-     * {@link State#NORMAL} state and invalidates the view
-     *
-     * @param buttonColor <b>Action Button</b> color
-     *                    when in {@link State#NORMAL} state
-     */
-    public void setButtonColor(int buttonColor) {
-        this.buttonColor = buttonColor;
-        invalidate();
-        Log.v(LOG_TAG, "Color changed to: " + getButtonColor());
-    }
-
-    /**
-     * Sets the <b>Action Button</b> color when in
-     * {@link State#PRESSED} state
-     *
-     * @return <b>Action Button</b> color when in
-     * {@link State#PRESSED} state
-     */
-    public int getButtonColorPressed() {
-        return buttonColorPressed;
-    }
-
-    /**
-     * Sets the <b>Action Button</b> color when in
-     * {@link State#PRESSED} state and invalidates the view
-     *
-     * @param buttonColorPressed <b>Action Button</b> color
-     *                           when in {@link State#PRESSED} state
-     */
-    public void setButtonColorPressed(int buttonColorPressed) {
-        this.buttonColorPressed = buttonColorPressed;
-        invalidate();
-        Log.v(LOG_TAG, "Pressed color changed to: " + getButtonColorPressed());
-    }
-
-    /**
-     * Checks whether <b>Action Button</b> has shadow by determining shadow radius
-     * <p>
-     * Shadow is disabled if elevation is set API level is {@code 21 Lollipop} and higher
-     *
-     * @return true if <b>Action Button</b> has radius, otherwise false
-     */
-    public boolean hasShadow() {
-        return !hasElevation() && getShadowRadius() > 0.0f;
-    }
-
-    /**
-     * Returns the <b>Action Button</b> shadow radius in actual
-     * pixels (px)
-     *
-     * @return <b>Action Button</b> shadow radius in actual pixels (px)
-     */
-    public float getShadowRadius() {
-        return shadowRadius;
-    }
-
-    /**
-     * Sets the <b>Action Button</b> shadow radius and
-     * invalidates the layout of the view
-     * <p>
-     * Must be specified in density-independent (dp) pixels, which are
-     * then converted into actual pixels (px). If shadow radius is set to 0,
-     * shadow is removed
-     *
-     * @param shadowRadius shadow radius specified in density-independent
-     *                     (dp) pixels
-     */
-    public void setShadowRadius(float shadowRadius) {
-        this.shadowRadius = MetricsConverter.dpToPx(getContext(), shadowRadius);
-        requestLayout();
-        Log.v(LOG_TAG, "Shadow radius changed to:" + getShadowRadius());
-    }
-
-    /**
-     * Removes the <b>Action Button</b> shadow by setting its radius to 0
-     */
-    public void removeShadow() {
-        if (hasShadow()) {
-            setShadowRadius(0.0f);
-        }
-    }
-
-    /**
-     * Returns the <b>Action Button</b> shadow X-axis offset
-     * in actual pixels (px)
-     * <p>
-     * If X-axis offset is greater than 0 shadow is shifted right.
-     * If X-axis offset is lesser than 0 shadow is shifted left.
-     * 0 X-axis offset means that shadow is not X-axis shifted at all
-     *
-     * @return <b>Action Button</b> shadow X-axis offset
-     * in actual pixels (px)
-     */
-    public float getShadowXOffset() {
-        return shadowXOffset;
-    }
-
-    /**
-     * Sets the <b>Action Button</b> shadow X-axis offset and
-     * invalidates the layout of the view
-     * <p>
-     * If X-axis offset is greater than 0 shadow is shifted right.
-     * If X-axis offset is lesser than 0 shadow is shifted left.
-     * 0 X-axis offset means that shadow is not shifted at all
-     * <p>
-     * Must be specified in density-independent (dp) pixels, which are
-     * then converted into actual pixels (px)
-     *
-     * @param shadowXOffset shadow X-axis offset specified in density-independent
-     *                      (dp) pixels
-     */
-    public void setShadowXOffset(float shadowXOffset) {
-        this.shadowXOffset = MetricsConverter.dpToPx(getContext(), shadowXOffset);
-        requestLayout();
-        Log.v(LOG_TAG, "Shadow X offset changed to: " + getShadowXOffset());
-    }
-
-    /**
-     * Returns the <b>Action Button</b> shadow Y-axis offset
-     * in actual pixels (px)
-     * <p>
-     * If Y-axis offset is greater than 0 shadow is shifted down.
-     * If Y-axis offset is lesser than 0 shadow is shifted up.
-     * 0 Y-axis offset means that shadow is not Y-axis shifted at all
-     *
-     * @return <b>Action Button</b> shadow Y-axis offset
-     * in actual pixels (px)
-     */
-    public float getShadowYOffset() {
-        return shadowYOffset;
-    }
-
-    /**
-     * Sets the <b>Action Button</b> shadow Y-axis offset and
-     * invalidates the layout of the view
-     * <p>
-     * If Y-axis offset is greater than 0 shadow is shifted down.
-     * If Y-axis offset is lesser than 0 shadow is shifted up.
-     * 0 Y-axis offset means that shadow is not Y-axis shifted at all
-     * <p>
-     * Must be specified in density-independent (dp) pixels, which are
-     * then converted into actual pixels (px)
-     *
-     * @param shadowYOffset shadow Y-axis offset specified in density-independent
-     *                      (dp) pixels
-     */
-    public void setShadowYOffset(float shadowYOffset) {
-        this.shadowYOffset = MetricsConverter.dpToPx(getContext(), shadowYOffset);
-        requestLayout();
-        Log.v(LOG_TAG, "Shadow Y offset changed to:" + getShadowYOffset());
-    }
-
-    /**
-     * Returns <b>Action Button</b> shadow color
-     *
-     * @return <b>Action Button</b> shadow color
-     */
-    public int getShadowColor() {
-        return shadowColor;
-    }
-
-    /**
-     * Sets the <b>Action Button</b> shadow color and
-     * invalidates the view
-     *
-     * @param shadowColor <b>Action Button</b> color
-     */
-    public void setShadowColor(int shadowColor) {
-        this.shadowColor = shadowColor;
-        invalidate();
-        Log.v(LOG_TAG, "Shadow color changed to: " + getShadowColor());
-    }
-
-    /**
-     * Returns the <b>Action Button</b> stroke width in actual
-     * pixels (px)
-     *
-     * @return <b>Action Button</b> stroke width in actual
-     * pixels (px)
-     */
-    public float getStrokeWidth() {
-        return strokeWidth;
-    }
-
-    /**
-     * Checks whether <b>Action Button</b> has stroke by checking
-     * stroke width
-     *
-     * @return true if <b>Action Button</b> has stroke, otherwise false
-     */
-    public boolean hasStroke() {
-        return getStrokeWidth() > 0.0f;
-    }
-
-    /**
-     * Sets the <b>Action Button</b> stroke width and
-     * invalidates the layout of the view
-     * <p>
-     * Stroke width value must be greater than 0. If stroke width is
-     * set to 0 stroke is removed
-     * <p>
-     * Must be specified in density-independent (dp) pixels, which are
-     * then converted into actual pixels (px)
-     *
-     * @param strokeWidth stroke width specified in density-independent
-     *                    (dp) pixels
-     */
-    public void setStrokeWidth(float strokeWidth) {
-        this.strokeWidth = MetricsConverter.dpToPx(getContext(), strokeWidth);
-        requestLayout();
-        Log.v(LOG_TAG, "Stroke width changed to: " + getStrokeWidth());
-    }
-
-    /**
-     * Removes the <b>Action Button</b> stroke by setting its width to 0
-     */
-    public void removeStroke() {
-        if (hasStroke()) {
-            setStrokeWidth(0.0f);
-        }
-    }
-
-    /**
-     * Returns the <b>Action Button</b> stroke color
-     *
-     * @return <b>Action Button</b> stroke color
-     */
-    public int getStrokeColor() {
-        return strokeColor;
-    }
-
-    /**
-     * Sets the <b>Action Button</b> stroke color and
-     * invalidates the view
-     *
-     * @param strokeColor <b>Action Button</b> stroke color
-     */
-    public void setStrokeColor(int strokeColor) {
-        this.strokeColor = strokeColor;
-        invalidate();
-        Log.v(LOG_TAG, "Stroke color changed to: " + getStrokeColor());
-    }
-
-    /**
-     * Returns the <b>Action Button</b> image drawable centered
-     * inside the view
-     *
-     * @return <b>Action Button</b> image drawable centered
-     * inside the view
-     */
-    public Drawable getImage() {
-        return image;
-    }
-
-    /**
-     * Checks whether <b>Action Button</b> has an image centered
-     * inside the view
-     *
-     * @return true if <b>Action Button</b> has an image centered
-     * inside the view, otherwise false
-     */
-    public boolean hasImage() {
-        return getImage() != null;
-    }
-
-    /**
-     * Places the image drawable centered inside the view and
-     * invalidates the view
-     * <p>
-     * Size of the image while drawing is fit to {@link #imageSize}
-     *
-     * @param image image drawable, which will be placed centered
-     *              inside the view
-     */
-    public void setImageDrawable(Drawable image) {
-        this.image = image;
-        invalidate();
-        Log.v(LOG_TAG, "Image drawable set");
-    }
-
-    /**
-     * Resolves the drawable resource id and places the resolved image drawable
-     * centered inside the view
-     *
-     * @param resId drawable resource id, which is to be resolved to
-     *              image drawable and used as parameter when calling
-     *              {@link #setImageDrawable(Drawable)}
-     */
-    @SuppressWarnings("deprecation")
-    public void setImageResource(int resId) {
-        setImageDrawable(getResources().getDrawable(resId));
-    }
-
-    /**
-     * Creates the {@link BitmapDrawable} from the given
-     * {@link Bitmap} and places it centered inside the view
-     *
-     * @param bitmap bitmap, from which {@link BitmapDrawable}
-     *               is created and used as parameter when calling
-     *               {@link #setImageDrawable(Drawable)}
-     */
-    public void setImageBitmap(Bitmap bitmap) {
-        setImageDrawable(new BitmapDrawable(getResources(), bitmap));
-    }
-
-    /**
-     * Removes the <b>Action Button</b> image by setting its value to null
-     */
-    public void removeImage() {
-        if (hasImage()) {
-            setImageDrawable(null);
-        }
-    }
-
-    /**
-     * Returns the <b>Action Button</b> image size in actual pixels (px).
-     * If <b>Action Button</b> image is not set returns 0
-     *
-     * @return <b>Action Button</b> image size in actual pixels (px),
-     * 0 if image is not set
-     */
-    public float getImageSize() {
-        return getImage() != null ? imageSize : 0.0f;
-    }
-
-    /**
-     * Sets the size of the <b>Action Button</b> image
-     * <p>
-     * Changing the default size of the image breaks the rules of
-     * <a href="http://www.google.com/design/spec/components/buttons.html">Material Design</a>
-     * <p>
-     * Must be specified in density-independent (dp) pixels, which are
-     * then converted into actual pixels (px)
-     *
-     * @param size size of the <b>Action Button</b> image
-     *             specified in density-independent (dp) pixels
-     */
-    public void setImageSize(float size) {
-        this.imageSize = MetricsConverter.dpToPx(getContext(), size);
-        Log.v(LOG_TAG, "Image size changed to: " + getImageSize());
-    }
-
-    /**
-     * Returns an animation, which is used while showing <b>Action Button</b>
-     *
-     * @return animation, which is used while showing <b>Action Button</b>
-     */
-    public Animation getShowAnimation() {
-        return showAnimation;
-    }
-
-    /**
-     * Sets the animation, which is used while showing <b>Action Button</b>
-     *
-     * @param animation animation, which is to be used while showing
-     *                  <b>Action Button</b>
-     */
-    public void setShowAnimation(Animation animation) {
-        this.showAnimation = animation;
-        Log.v(LOG_TAG, "Show animation set");
-    }
-
-    /**
-     * Sets one of the {@link Animations} as animation, which is used while showing
-     * <b>Action Button</b>
-     *
-     * @param animation one of the {@link Animations}, which is to be used while
-     *                  showing <b>Action Button</b>
-     */
-    public void setShowAnimation(Animations animation) {
-        setShowAnimation(Animations.load(getContext(), animation.animResId));
-    }
-
-    /**
-     * Removes the animation, which is used while showing <b>Action Button</b>
-     */
-    public void removeShowAnimation() {
-        setShowAnimation(Animations.NONE);
-        Log.v(LOG_TAG, "Show animation removed");
-    }
-
-    /**
-     * Returns an animation, which is used while hiding <b>Action Button</b>
-     *
-     * @return animation, which is used while hiding <b>Action Button</b>
-     */
-    public Animation getHideAnimation() {
-        return hideAnimation;
-    }
-
-    /**
-     * Sets the animation, which is used while hiding <b>Action Button</b>
-     *
-     * @param animation animation, which is to be used while hiding
-     *                  <b>Action Button</b>
-     */
-    public void setHideAnimation(Animation animation) {
-        this.hideAnimation = animation;
-        Log.v(LOG_TAG, "Hide animation set");
-    }
-
-    /**
-     * Sets one of the {@link Animations} as animation, which is used while hiding
-     * <b>Action Button</b>
-     *
-     * @param animation one of the {@link Animations}, which is to be used while
-     *                  hiding <b>Action Button</b>
-     */
-    public void setHideAnimation(Animations animation) {
-        setHideAnimation(Animations.load(getContext(), animation.animResId));
-    }
-
-    public void removeHideAnimation() {
-        setHideAnimation(Animations.NONE);
-        Log.v(LOG_TAG, "Hide animation removed");
-    }
-
-    /**
-     * Adds additional actions on motion events:
-     * 1. Changes the <b>Action Button</b> {@link #state} to {@link State#PRESSED}
-     * on {@link MotionEvent#ACTION_DOWN}
-     * 2. Changes the <b>Action Button</b> {@link #state} to {@link State#NORMAL}
-     * on {@link MotionEvent#ACTION_UP}
-     *
-     * @param event motion event
-     * @return true if event was handled, otherwise false
-     */
-    @SuppressWarnings("all")
-    @SuppressLint("ClickableViewAccessibility")
-    @Override
-    public boolean onTouchEvent(MotionEvent event) {
-        super.onTouchEvent(event);
-        final int action = event.getAction();
-        switch (action) {
-            case MotionEvent.ACTION_DOWN:
-                Log.v(LOG_TAG, "Motion event action down detected");
-                setState(State.PRESSED);
-                return true;
-            case MotionEvent.ACTION_UP:
-                Log.v(LOG_TAG, "Motion event action up detected");
-                setState(State.NORMAL);
-                return true;
-            default:
-                Log.v(LOG_TAG, "Unrecognized motion event detected");
-                return false;
-        }
-    }
-
-    /**
-     * Adds additional checking whether animation is null before starting to play it
-     *
-     * @param animation animation to play
-     */
-    @SuppressWarnings("all")
-    @Override
-    public void startAnimation(Animation animation) {
-        if (animation != null) {
-            super.startAnimation(animation);
-        }
-    }
-
-    /**
-     * Resets the paint to its default values and sets initial flags to it
-     * <p>
-     * Use this method before drawing the new element of the view
-     */
-    protected final void resetPaint() {
-        paint.reset();
-        paint.setFlags(Paint.ANTI_ALIAS_FLAG);
-        Log.v(LOG_TAG, "Paint reset");
-    }
-
-    /**
-     * Draws the elements of the <b>Action Button</b>
-     *
-     * @param canvas canvas, on which the drawing is to be performed
-     */
-    @SuppressWarnings("all")
-    @Override
-    protected void onDraw(Canvas canvas) {
-        super.onDraw(canvas);
-        Log.v(LOG_TAG, "Action Button onDraw called");
-        drawCircle(canvas);
-        if (hasElevation()) {
-            drawElevation();
-        }
-        if (hasStroke()) {
-            drawStroke(canvas);
-        }
-        if (hasImage()) {
-            drawImage(canvas);
-        }
-    }
-
-    /**
-     * Draws the main circle of the <b>Action Button</b> and calls
-     * {@link #drawShadow()} to draw the shadow if present
-     *
-     * @param canvas canvas, on which circle is to be drawn
-     */
-    protected void drawCircle(Canvas canvas) {
-        resetPaint();
-        if (hasShadow()) {
-            drawShadow();
-        }
-        paint.setStyle(Paint.Style.FILL);
-        paint.setColor(getState() == State.PRESSED ? getButtonColorPressed() : getButtonColor());
-        canvas.drawCircle(calculateCenterX(), calculateCenterY(), calculateCircleRadius(), paint);
-        Log.v(LOG_TAG, "Circle drawn");
-    }
-
-    /**
-     * Calculates the X-axis center coordinate of the entire view
-     *
-     * @return X-axis center coordinate of the entire view
-     */
-    protected float calculateCenterX() {
-        final float centerX = getMeasuredWidth() / 2;
-        Log.v(LOG_TAG, "Calculated center X = " + centerX);
-        return centerX;
-    }
-
-    /**
-     * Calculates the Y-axis center coordinate of the entire view
-     *
-     * @return Y-axis center coordinate of the entire view
-     */
-    protected float calculateCenterY() {
-        final float centerY = getMeasuredHeight() / 2;
-        Log.v(LOG_TAG, "Calculated center Y = " + centerY);
-        return centerY;
-    }
-
-    /**
-     * Calculates the radius of the main circle
-     *
-     * @return radius of the main circle
-     */
-    protected final float calculateCircleRadius() {
-        final float circleRadius = getButtonSize() / 2;
-        Log.v(LOG_TAG, "Calculated circle circleRadius = " + circleRadius);
-        return circleRadius;
-    }
-
-    /**
-     * Draws the shadow if view elevation is not enabled
-     */
-    protected void drawShadow() {
-        paint.setShadowLayer(getShadowRadius(), getShadowXOffset(), getShadowYOffset(), getShadowColor());
-        Log.v(LOG_TAG, "Shadow drawn");
-    }
-
-    /**
-     * Draws the elevation around the main circle
-     * <p>
-     * Uses the stroke corrective, which helps to avoid the elevation overlapping issue
-     */
-    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
-    protected void drawElevation() {
-        final int strokeWeightCorrective = (int) (getStrokeWidth() / 1.5f);
-        final int width = getWidth() - strokeWeightCorrective;
-        final int height = getHeight() - strokeWeightCorrective;
-        final ViewOutlineProvider outlineProvider = new ActionButtonOutlineProvider(width, height);
-        setOutlineProvider(outlineProvider);
-        Log.v(LOG_TAG, "Elevation drawn");
-    }
-
-    /**
-     * Checks whether view elevation is enabled
-     *
-     * @return true if view elevation enabled, otherwise false
-     */
-    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
-    private boolean hasElevation() {
-        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP && getElevation() > 0.0f;
-    }
-
-    /**
-     * Draws stroke around the main circle
-     *
-     * @param canvas canvas, on which circle is to be drawn
-     */
-    protected void drawStroke(Canvas canvas) {
-        resetPaint();
-        paint.setStyle(Paint.Style.STROKE);
-        paint.setStrokeWidth(getStrokeWidth());
-        paint.setColor(getStrokeColor());
-        canvas.drawCircle(calculateCenterX(), calculateCenterY(), calculateCircleRadius(), paint);
-        Log.v(LOG_TAG, "Stroke drawn");
-    }
-
-    /**
-     * Draws the image centered inside the view
-     *
-     * @param canvas canvas, on which circle is to be drawn
-     */
-    protected void drawImage(Canvas canvas) {
-        final int startPointX = (int) (calculateCenterX() - getImageSize() / 2);
-        final int startPointY = (int) (calculateCenterY() - getImageSize() / 2);
-        final int endPointX = (int) (startPointX + getImageSize());
-        final int endPointY = (int) (startPointY + getImageSize());
-        getImage().setBounds(startPointX, startPointY, endPointX, endPointY);
-        getImage().draw(canvas);
-        Log.v(LOG_TAG, String.format("Image drawn on canvas with coordinates: startPointX = %s, startPointY = %s, " +
-                "endPointX = %s, endPointY = %s", startPointX, startPointY, endPointX, endPointY));
-    }
-
-    /**
-     * Sets the measured dimension for the entire view
-     *
-     * @param widthMeasureSpec  horizontal space requirements as imposed by the parent.
-     *                          The requirements are encoded with
-     *                          {@link MeasureSpec}
-     * @param heightMeasureSpec vertical space requirements as imposed by the parent.
-     *                          The requirements are encoded with
-     *                          {@link MeasureSpec}
-     */
-    @Override
-    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
-        Log.v(LOG_TAG, "Action Button onMeasure called");
-        setMeasuredDimension(calculateMeasuredWidth(), calculateMeasuredHeight());
-        Log.v(LOG_TAG, String.format("View size measured with: height = %s, width = %s", getHeight(), getWidth()));
-    }
-
-    /**
-     * Calculates the measured width in actual pixels for the entire view
-     *
-     * @return measured width in actual pixels for the entire view
-     */
-    private int calculateMeasuredWidth() {
-        final int measuredWidth = getButtonSize() + calculateShadowWidth() + calculateStrokeWeight();
-        Log.v(LOG_TAG, "Calculated measured width = " + measuredWidth);
-        return measuredWidth;
-    }
-
-    /**
-     * Calculates the measured height in actual pixels for the entire view
-     *
-     * @return measured width in actual pixels for the entire view
-     */
-    private int calculateMeasuredHeight() {
-        final int measuredHeight = getButtonSize() + calculateShadowHeight() + calculateStrokeWeight();
-        Log.v(LOG_TAG, "Calculated measured height = " + measuredHeight);
-        return measuredHeight;
-    }
-
-    /**
-     * Calculates shadow width in actual pixels
-     *
-     * @return shadow width in actual pixels
-     */
-    private int calculateShadowWidth() {
-        final int shadowWidth = hasShadow() ? (int) ((getShadowRadius() + Math.abs(getShadowXOffset())) * 2) : 0;
-        Log.v(LOG_TAG, "Calculated shadow width = " + shadowWidth);
-        return shadowWidth;
-    }
-
-    /**
-     * Calculates shadow height in actual pixels
-     *
-     * @return shadow height in actual pixels
-     */
-    private int calculateShadowHeight() {
-        final int shadowHeight = hasShadow() ? (int) ((getShadowRadius() + Math.abs(getShadowYOffset())) * 2) : 0;
-        Log.v(LOG_TAG, "Calculated shadow height = " + shadowHeight);
-        return shadowHeight;
-    }
-
-    /**
-     * Calculates the stroke weight in actual pixels
-     * *
-     *
-     * @return stroke weight in actual pixels
-     */
-    private int calculateStrokeWeight() {
-        final int strokeWeight = (int) (getStrokeWidth() * 2.0f);
-        Log.v(LOG_TAG, "Calculated stroke weight is: " + strokeWeight);
-        return strokeWeight;
-    }
-
-    /**
-     * Determines the <b>Action Button</b> types
-     */
-    public enum Type {
-
-        /**
-         * <b>Action Button</b> default (56dp) type
-         */
-        DEFAULT {
-            @Override
-            int getId() {
-                return 0;
-            }
-
-            @Override
-            float getSize(Context context) {
-                return MetricsConverter.dpToPx(context, 56.0f);
-            }
-        },
-
-        /**
-         * <b>Action Button</b> mini (40dp) type
-         */
-        MINI {
-            @Override
-            int getId() {
-                return 1;
-            }
-
-            @Override
-            float getSize(Context context) {
-                return MetricsConverter.dpToPx(context, 40.0f);
-            }
-        };
-
-        /**
-         * Returns an {@code id} for specific <b>Action Button</b>
-         * type, which is defined in attributes
-         *
-         * @return {@code id} for particular <b>Action Button</b> type,
-         * which is defined in attributes
-         */
-        abstract int getId();
-
-        /**
-         * Returns the size of the specific type of the <b>Action Button</b>
-         *
-         * @param context context the view is running in
-         * @return size of the particular type of the <b>Action Button</b>
-         */
-        abstract float getSize(Context context);
-
-        /**
-         * Returns the <b>Action Button</b> type for a specific {@code id}
-         *
-         * @param id an {@code id}, for which <b>Action Button</b> type required
-         * @return <b>Action Button</b> type
-         */
-        static Type forId(int id) {
-            for (Type type : values()) {
-                if (type.getId() == id) {
-                    return type;
-                }
-            }
-            return DEFAULT;
-        }
-
-    }
-
-    /**
-     * Determines the <b>Action Button</b> states
-     */
-    public enum State {
-
-        /**
-         * <b>Action Button</b> normal state
-         */
-        NORMAL,
-
-        /**
-         * <b>Action Button</b> pressed state
-         */
-        PRESSED
-
-    }
-
-    public enum Animations {
-
-        /**
-         * None. Animation absent
-         */
-        NONE(0),
-
-        /**
-         * Fade in animation
-         */
-        FADE_IN(R.anim.mmt_fade_in),
-
-        /**
-         * Fade out animation
-         */
-        FADE_OUT(R.anim.mmt_fade_out),
-
-        /**
-         * Scale up animation
-         */
-        SCALE_UP(R.anim.mmt_scale_up),
-
-        /**
-         * Scale down animation
-         */
-        SCALE_DOWN(R.anim.mmt_scale_down),
-
-        /**
-         * Roll from down animation
-         */
-        ROLL_FROM_DOWN(R.anim.mmt_roll_from_down),
-
-        /**
-         * Roll to down animation
-         */
-        ROLL_TO_DOWN(R.anim.mmt_roll_to_down),
-
-        /**
-         * Roll from right animation
-         */
-        ROLL_FROM_RIGHT(R.anim.mmt_roll_from_right),
-
-        /**
-         * Roll to right animation
-         */
-        ROLL_TO_RIGHT(R.anim.mmt_roll_to_right),
-
-        /**
-         * Jump from down animation
-         */
-        JUMP_FROM_DOWN(R.anim.mmt_jump_from_down),
-
-        /**
-         * Jump to down animation
-         */
-        JUMP_TO_DOWN(R.anim.mmt_jump_to_down),
-
-        /**
-         * Jump from right animation
-         */
-        JUMP_FROM_RIGHT(R.anim.mmt_jump_from_right),
-
-        /**
-         * Jump to right animation
-         */
-        JUMP_TO_RIGHT(R.anim.mmt_jump_to_right);
-
-        /**
-         * Correspondent animation resource id
-         */
-        final int animResId;
-
-        private Animations(int animResId) {
-            this.animResId = animResId;
-        }
-
-        /**
-         * Loads an animation from animation resource id
-         *
-         * @param context   context the view is running in
-         * @param animResId resource id of the animation, which is to be loaded
-         * @return loaded animation
-         */
-        protected static Animation load(Context context, int animResId) {
-            return animResId == NONE.animResId ? null : AnimationUtils.loadAnimation(context, animResId);
-        }
-
-    }
-
-}
diff --git a/qDict/src/main/java/com/mmt/widget/ActionButtonOutlineProvider.java b/qDict/src/main/java/com/mmt/widget/ActionButtonOutlineProvider.java
deleted file mode 100644
index 47090bf..0000000
--- a/qDict/src/main/java/com/mmt/widget/ActionButtonOutlineProvider.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright 2015 Shell Software Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * File created: 2015-02-25 19:54:28
- */
-
-package com.mmt.widget;
-
-import android.annotation.TargetApi;
-import android.graphics.Outline;
-import android.os.Build;
-import android.view.View;
-import android.view.ViewOutlineProvider;
-
-/**
- * An implementation of the {@link ViewOutlineProvider}
- * for <b>Action Button</b>
- * <p>
- * Used for drawing the elevation shadow for {@code API 21 Lollipop} and higher
- *
- * @author Vladislav
- * @version 1.0.0
- * @since 1.0.0
- */
-@TargetApi(Build.VERSION_CODES.LOLLIPOP)
-class ActionButtonOutlineProvider extends ViewOutlineProvider {
-
-    /**
-     * Outline provider width
-     */
-    private int width;
-
-    /**
-     * Outline provider height
-     */
-    private int height;
-
-    /**
-     * Creates an instance of the {@link ActionButtonOutlineProvider}
-     *
-     * @param width  initial outline provider width
-     * @param height initial outline provider height
-     */
-    ActionButtonOutlineProvider(int width, int height) {
-        this.width = width;
-        this.height = height;
-    }
-
-    /**
-     * Called to get the provider to populate the Outline. This method will be called by a View
-     * when its owned Drawables are invalidated, when the View's size changes, or if invalidateOutline()
-     * is called explicitly. The input outline is empty and has an alpha of 1.0f
-     *
-     * @param view    a view, which builds the outline
-     * @param outline an empty outline, which is to be populated
-     */
-    @Override
-    public void getOutline(View view, Outline outline) {
-        outline.setOval(0, 0, width, height);
-    }
-
-}
diff --git a/qDict/src/main/java/com/mmt/widget/DropDownListView.java b/qDict/src/main/java/com/mmt/widget/DropDownListView.java
index e1f9ef6..aa85d65 100644
--- a/qDict/src/main/java/com/mmt/widget/DropDownListView.java
+++ b/qDict/src/main/java/com/mmt/widget/DropDownListView.java
@@ -13,7 +13,7 @@ public class DropDownListView extends ListView {
         super(context, null, android.R.attr.dropDownListViewStyle);
     }
 
-    @TargetApi(20)
+    @TargetApi(21)
     public DropDownListView(Context context, AttributeSet attrs, int defStyleAttr, int defStyleRes) {
         super(context, attrs, android.R.attr.dropDownListViewStyle, defStyleRes);
     }
diff --git a/qDict/src/main/java/com/mmt/widget/MetricsConverter.java b/qDict/src/main/java/com/mmt/widget/MetricsConverter.java
deleted file mode 100644
index b20a376..0000000
--- a/qDict/src/main/java/com/mmt/widget/MetricsConverter.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/*
- * Copyright 2015 Shell Software Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *
- * File created: 2015-01-30 22:55:44
- */
-
-package com.mmt.widget;
-
-import android.content.Context;
-
-/**
- * Contains utility methods for metrics conversion
- *
- * @author Vladislav
- * @version 1.0.0
- * @since 1.0.0
- */
-public final class MetricsConverter {
-
-    /**
-     * Prevents from creating {@link MetricsConverter} instances
-     */
-    private MetricsConverter() {
-    }
-
-    /**
-     * Converts the density-independent value into real pixel value based on display metrics
-     *
-     * @param context application context
-     * @param dp      density-independent value
-     * @return converted real pixel value
-     */
-    public static float dpToPx(Context context, float dp) {
-        final float scale = context.getResources().getDisplayMetrics().density;
-        return dp * scale;
-    }
-
-}
diff --git a/qDict/src/main/java/com/mmt/widget/SlidingUpPanelLayout.java b/qDict/src/main/java/com/mmt/widget/SlidingUpPanelLayout.java
index 5901dc4..f72c526 100644
--- a/qDict/src/main/java/com/mmt/widget/SlidingUpPanelLayout.java
+++ b/qDict/src/main/java/com/mmt/widget/SlidingUpPanelLayout.java
@@ -20,12 +20,9 @@ import androidx.core.view.MotionEventCompat;
 import androidx.core.view.ViewCompat;
 
 import com.annie.dictionary.R;
-import com.mmt.widget.slidemenu.SlidingMenu;
 
 public class SlidingUpPanelLayout extends ViewGroup {
 
-    public static final String TAG = SlidingUpPanelLayout.class.getSimpleName();
-
     /**
      * Default peeking out panel height
      */
@@ -77,7 +74,6 @@ public class SlidingUpPanelLayout extends ViewGroup {
     /**
      * Drawable used to draw the shadow between panes.
      */
-    private final Drawable mShadowDrawable;
     private final ViewDragHelper mDragHelper;
     private final Rect mTmpRect = new Rect();
     /**
@@ -178,7 +174,6 @@ public class SlidingUpPanelLayout extends ViewGroup {
         super(context, attrs, defStyle);
 
         if (isInEditMode()) {
-            mShadowDrawable = null;
             mDragHelper = null;
             return;
         }
@@ -228,17 +223,6 @@ public class SlidingUpPanelLayout extends ViewGroup {
         if (mParallaxOffset == -1) {
             mParallaxOffset = (int) (DEFAULT_PARALAX_OFFSET * density);
         }
-        // If the shadow height is zero, don't show the shadow
-        if (mShadowHeight > 0) {
-            if (mIsSlidingUp) {
-                mShadowDrawable = SlidingMenu.getDrawable(getContext(), R.drawable.above_shadow);
-            } else {
-                mShadowDrawable = SlidingMenu.getDrawable(getContext(), R.drawable.below_shadow);
-            }
-
-        } else {
-            mShadowDrawable = null;
-        }
 
         setWillNotDraw(false);
 
@@ -1008,28 +992,6 @@ public class SlidingUpPanelLayout extends ViewGroup {
         }
     }
 
-    @Override
-    public void draw(Canvas c) {
-        super.draw(c);
-
-        // draw the shadow
-        if (mShadowDrawable != null) {
-            final int right = mSlideableView.getRight();
-            final int top;
-            final int bottom;
-            if (mIsSlidingUp) {
-                top = mSlideableView.getTop() - mShadowHeight;
-                bottom = mSlideableView.getTop();
-            } else {
-                top = mSlideableView.getBottom();
-                bottom = mSlideableView.getBottom() + mShadowHeight;
-            }
-            final int left = mSlideableView.getLeft();
-            mShadowDrawable.setBounds(left, top, right, bottom);
-            mShadowDrawable.draw(c);
-        }
-    }
-
     /**
      * Tests scrollability within child views of v given a delta of dx.
      *
@@ -1058,7 +1020,7 @@ public class SlidingUpPanelLayout extends ViewGroup {
                 }
             }
         }
-        return checkV && ViewCompat.canScrollHorizontally(v, -dx);
+        return checkV && v.canScrollHorizontally(-dx);
     }
 
     @Override
diff --git a/qDict/src/main/java/com/mmt/widget/slidemenu/CanvasTransformerBuilder.java b/qDict/src/main/java/com/mmt/widget/slidemenu/CanvasTransformerBuilder.java
deleted file mode 100644
index 9f657b4..0000000
--- a/qDict/src/main/java/com/mmt/widget/slidemenu/CanvasTransformerBuilder.java
+++ /dev/null
@@ -1,88 +0,0 @@
-package com.mmt.widget.slidemenu;
-
-import android.graphics.Canvas;
-import android.view.animation.Interpolator;
-
-import com.mmt.widget.slidemenu.SlidingMenu.CanvasTransformer;
-
-public class CanvasTransformerBuilder {
-
-    private static Interpolator lin = new Interpolator() {
-        public float getInterpolation(float t) {
-            return t;
-        }
-    };
-    private CanvasTransformer mTrans;
-
-    private void initTransformer() {
-        if (mTrans == null)
-            mTrans = new CanvasTransformer() {
-                public void transformCanvas(Canvas canvas, float percentOpen) {
-                }
-            };
-    }
-
-    public CanvasTransformer zoom(final int openedX, final int closedX, final int openedY, final int closedY,
-                                  final int px, final int py) {
-        return zoom(openedX, closedX, openedY, closedY, px, py, lin);
-    }
-
-    public CanvasTransformer zoom(final int openedX, final int closedX, final int openedY, final int closedY,
-                                  final int px, final int py, final Interpolator interp) {
-        initTransformer();
-        mTrans = new CanvasTransformer() {
-            public void transformCanvas(Canvas canvas, float percentOpen) {
-                mTrans.transformCanvas(canvas, percentOpen);
-                float f = interp.getInterpolation(percentOpen);
-                canvas.scale((openedX - closedX) * f + closedX, (openedY - closedY) * f + closedY, px, py);
-            }
-        };
-        return mTrans;
-    }
-
-    public CanvasTransformer rotate(final int openedDeg, final int closedDeg, final int px, final int py) {
-        return rotate(openedDeg, closedDeg, px, py, lin);
-    }
-
-    public CanvasTransformer rotate(final int openedDeg, final int closedDeg, final int px, final int py,
-                                    final Interpolator interp) {
-        initTransformer();
-        mTrans = new CanvasTransformer() {
-            public void transformCanvas(Canvas canvas, float percentOpen) {
-                mTrans.transformCanvas(canvas, percentOpen);
-                float f = interp.getInterpolation(percentOpen);
-                canvas.rotate((openedDeg - closedDeg) * f + closedDeg, px, py);
-            }
-        };
-        return mTrans;
-    }
-
-    public CanvasTransformer translate(final int openedX, final int closedX, final int openedY, final int closedY) {
-        return translate(openedX, closedX, openedY, closedY, lin);
-    }
-
-    public CanvasTransformer translate(final int openedX, final int closedX, final int openedY, final int closedY,
-                                       final Interpolator interp) {
-        initTransformer();
-        mTrans = new CanvasTransformer() {
-            public void transformCanvas(Canvas canvas, float percentOpen) {
-                mTrans.transformCanvas(canvas, percentOpen);
-                float f = interp.getInterpolation(percentOpen);
-                canvas.translate((openedX - closedX) * f + closedX, (openedY - closedY) * f + closedY);
-            }
-        };
-        return mTrans;
-    }
-
-    public CanvasTransformer concatTransformer(final CanvasTransformer t) {
-        initTransformer();
-        mTrans = new CanvasTransformer() {
-            public void transformCanvas(Canvas canvas, float percentOpen) {
-                mTrans.transformCanvas(canvas, percentOpen);
-                t.transformCanvas(canvas, percentOpen);
-            }
-        };
-        return mTrans;
-    }
-
-}
diff --git a/qDict/src/main/java/com/mmt/widget/slidemenu/CustomViewAbove.java b/qDict/src/main/java/com/mmt/widget/slidemenu/CustomViewAbove.java
deleted file mode 100644
index 5072500..0000000
--- a/qDict/src/main/java/com/mmt/widget/slidemenu/CustomViewAbove.java
+++ /dev/null
@@ -1,1001 +0,0 @@
-package com.mmt.widget.slidemenu;
-
-import android.content.Context;
-import android.graphics.Canvas;
-import android.graphics.Rect;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.FocusFinder;
-import android.view.KeyEvent;
-import android.view.MotionEvent;
-import android.view.SoundEffectConstants;
-import android.view.VelocityTracker;
-import android.view.View;
-import android.view.ViewConfiguration;
-import android.view.ViewGroup;
-import android.view.animation.Interpolator;
-import android.widget.Scroller;
-
-import androidx.core.view.MotionEventCompat;
-import androidx.core.view.VelocityTrackerCompat;
-import androidx.core.view.ViewCompat;
-import androidx.core.view.ViewConfigurationCompat;
-
-import com.mmt.widget.slidemenu.SlidingMenu.OnClosedListener;
-import com.mmt.widget.slidemenu.SlidingMenu.OnOpenedListener;
-
-import java.util.ArrayList;
-import java.util.List;
-
-public class CustomViewAbove extends ViewGroup {
-
-    private static final String TAG = "CustomViewAbove";
-
-    private static final boolean DEBUG = false;
-
-    private static final boolean USE_CACHE = false;
-
-    private static final int MAX_SETTLE_DURATION = 600; // ms
-
-    private static final int MIN_DISTANCE_FOR_FLING = 25; // dips
-
-    private static final Interpolator sInterpolator = new Interpolator() {
-        public float getInterpolation(float t) {
-            t -= 1.0f;
-            return t * t * t * t * t + 1.0f;
-        }
-    };
-    /**
-     * Sentinel value for no current active pointer. Used by
-     * {@link #mActivePointerId}.
-     */
-    private static final int INVALID_POINTER = -1;
-    /**
-     * ID of the active pointer. This is used to retain consistency during
-     * drags/flings if multiple pointers are used.
-     */
-    protected int mActivePointerId = INVALID_POINTER;
-    /**
-     * Determines speed during touch scrolling
-     */
-    protected VelocityTracker mVelocityTracker;
-    protected int mMaximumVelocity;
-    protected int mTouchMode = SlidingMenu.TOUCHMODE_MARGIN;
-    private View mContent;
-    private int mCurItem;
-    private Scroller mScroller;
-    private boolean mScrollingCacheEnabled;
-    private boolean mScrolling;
-    private boolean mIsBeingDragged;
-    private boolean mIsUnableToDrag;
-    private int mTouchSlop;
-    private float mInitialMotionX;
-    /**
-     * Position of the last motion event.
-     */
-    private float mLastMotionX;
-    private float mLastMotionY;
-    private int mMinimumVelocity;
-    private int mFlingDistance;
-    private CustomViewBehind mViewBehind;
-    // private int mMode;
-    private boolean mEnabled = true;
-    private OnPageChangeListener mOnPageChangeListener;
-    private OnPageChangeListener mInternalPageChangeListener;
-    // private OnCloseListener mCloseListener;
-    // private OnOpenListener mOpenListener;
-    private OnClosedListener mClosedListener;
-    private OnOpenedListener mOpenedListener;
-
-    // private int mScrollState = SCROLL_STATE_IDLE;
-    private List<View> mIgnoredViews = new ArrayList<View>();
-    private boolean mQuickReturn = false;
-    // variables for drawing
-    private float mScrollX = 0.0f;
-
-    public CustomViewAbove(Context context) {
-        this(context, null);
-    }
-
-    public CustomViewAbove(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        initCustomViewAbove();
-    }
-
-    void initCustomViewAbove() {
-        setWillNotDraw(false);
-        setDescendantFocusability(FOCUS_AFTER_DESCENDANTS);
-        setFocusable(true);
-        final Context context = getContext();
-        mScroller = new Scroller(context, sInterpolator);
-        final ViewConfiguration configuration = ViewConfiguration.get(context);
-        mTouchSlop = ViewConfigurationCompat.getScaledPagingTouchSlop(configuration);
-        mMinimumVelocity = configuration.getScaledMinimumFlingVelocity();
-        mMaximumVelocity = configuration.getScaledMaximumFlingVelocity();
-        setInternalPageChangeListener(new SimpleOnPageChangeListener() {
-            public void onPageSelected(int position) {
-                if (mViewBehind != null) {
-                    switch (position) {
-                        case 0:
-                        case 2:
-                            mViewBehind.setChildrenEnabled(true);
-                            break;
-                        case 1:
-                            mViewBehind.setChildrenEnabled(false);
-                            break;
-                    }
-                }
-            }
-        });
-
-        final float density = context.getResources().getDisplayMetrics().density;
-        mFlingDistance = (int) (MIN_DISTANCE_FOR_FLING * density);
-    }
-
-    /**
-     * Set the currently selected page.
-     *
-     * @param item         Item index to select
-     * @param smoothScroll True to smoothly scroll to the new item, false to
-     *                     transition immediately
-     */
-    public void setCurrentItem(int item, boolean smoothScroll) {
-        setCurrentItemInternal(item, smoothScroll, false);
-    }
-
-    public int getCurrentItem() {
-        return mCurItem;
-    }
-
-    /**
-     * Set the currently selected page. If the CustomViewPager has already been
-     * through its first layout there will be a smooth animated transition
-     * between the current item and the specified item.
-     *
-     * @param item Item index to select
-     */
-    public void setCurrentItem(int item) {
-        setCurrentItemInternal(item, true, false);
-    }
-
-    void setCurrentItemInternal(int item, boolean smoothScroll, boolean always) {
-        setCurrentItemInternal(item, smoothScroll, always, 0);
-    }
-
-    void setCurrentItemInternal(int item, boolean smoothScroll, boolean always, int velocity) {
-        if (!always && mCurItem == item) {
-            setScrollingCacheEnabled(false);
-            return;
-        }
-
-        item = mViewBehind.getMenuPage(item);
-
-        final boolean dispatchSelected = mCurItem != item;
-        mCurItem = item;
-        final int destX = getDestScrollX(mCurItem);
-        if (dispatchSelected && mOnPageChangeListener != null) {
-            mOnPageChangeListener.onPageSelected(item);
-        }
-        if (dispatchSelected && mInternalPageChangeListener != null) {
-            mInternalPageChangeListener.onPageSelected(item);
-        }
-        if (smoothScroll) {
-            smoothScrollTo(destX, 0, velocity);
-        } else {
-            completeScroll();
-            scrollTo(destX, 0);
-        }
-    }
-
-    /**
-     * Set a listener that will be invoked whenever the page changes or is
-     * incrementally scrolled. See {@link OnPageChangeListener}.
-     *
-     * @param listener Listener to set
-     */
-    public void setOnPageChangeListener(OnPageChangeListener listener) {
-        mOnPageChangeListener = listener;
-    }
-
-    /*
-     * public void setOnOpenListener(OnOpenListener l) { mOpenListener = l; }
-     * public void setOnCloseListener(OnCloseListener l) { mCloseListener = l; }
-     */
-    public void setOnOpenedListener(OnOpenedListener l) {
-        mOpenedListener = l;
-    }
-
-    public void setOnClosedListener(OnClosedListener l) {
-        mClosedListener = l;
-    }
-
-    /**
-     * Set a separate OnPageChangeListener for internal use by the support
-     * library.
-     *
-     * @param listener Listener to set
-     * @return The old listener that was set, if any.
-     */
-    OnPageChangeListener setInternalPageChangeListener(OnPageChangeListener listener) {
-        OnPageChangeListener oldListener = mInternalPageChangeListener;
-        mInternalPageChangeListener = listener;
-        return oldListener;
-    }
-
-    public void addIgnoredView(View v) {
-        if (!mIgnoredViews.contains(v)) {
-            mIgnoredViews.add(v);
-        }
-    }
-
-    public void removeIgnoredView(View v) {
-        mIgnoredViews.remove(v);
-    }
-
-    public void clearIgnoredViews() {
-        mIgnoredViews.clear();
-    }
-
-    // We want the duration of the page snap animation to be influenced by the
-    // distance that
-    // the screen has to travel, however, we don't want this duration to be
-    // effected in a
-    // purely linear fashion. Instead, we use this method to moderate the effect
-    // that the distance
-    // of travel has on the overall snap duration.
-    float distanceInfluenceForSnapDuration(float f) {
-        f -= 0.5f; // center the values about 0.
-        f *= 0.3f * Math.PI / 2.0f;
-        return (float) Math.sin(f);
-    }
-
-    public int getDestScrollX(int page) {
-        switch (page) {
-            case 0:
-            case 2:
-                return mViewBehind.getMenuLeft(mContent, page);
-            case 1:
-                return mContent.getLeft();
-        }
-        return 0;
-    }
-
-    private int getLeftBound() {
-        return mViewBehind.getAbsLeftBound(mContent);
-    }
-
-    private int getRightBound() {
-        return mViewBehind.getAbsRightBound(mContent);
-    }
-
-    public int getContentLeft() {
-        return mContent.getLeft() + mContent.getPaddingLeft();
-    }
-
-    public boolean isMenuOpen() {
-        return mCurItem == 0 || mCurItem == 2;
-    }
-
-    private boolean isInIgnoredView(MotionEvent ev) {
-        Rect rect = new Rect();
-        for (View v : mIgnoredViews) {
-            v.getHitRect(rect);
-            if (rect.contains((int) ev.getX(), (int) ev.getY()))
-                return true;
-        }
-        return false;
-    }
-
-    public int getBehindWidth() {
-        if (mViewBehind == null) {
-            return 0;
-        } else {
-            return mViewBehind.getBehindWidth();
-        }
-    }
-
-    public int getChildWidth(int i) {
-        switch (i) {
-            case 0:
-                return getBehindWidth();
-            case 1:
-                return mContent.getWidth();
-            default:
-                return 0;
-        }
-    }
-
-    public boolean isSlidingEnabled() {
-        return mEnabled;
-    }
-
-    public void setSlidingEnabled(boolean b) {
-        mEnabled = b;
-    }
-
-    /**
-     * Like {@link View#scrollBy}, but scroll smoothly instead of immediately.
-     *
-     * @param x the number of pixels to scroll by on the X axis
-     * @param y the number of pixels to scroll by on the Y axis
-     */
-    void smoothScrollTo(int x, int y) {
-        smoothScrollTo(x, y, 0);
-    }
-
-    /**
-     * Like {@link View#scrollBy}, but scroll smoothly instead of immediately.
-     *
-     * @param x        the number of pixels to scroll by on the X axis
-     * @param y        the number of pixels to scroll by on the Y axis
-     * @param velocity the velocity associated with a fling, if applicable. (0
-     *                 otherwise)
-     */
-    void smoothScrollTo(int x, int y, int velocity) {
-        if (getChildCount() == 0) {
-            // Nothing to do.
-            setScrollingCacheEnabled(false);
-            return;
-        }
-        int sx = getScrollX();
-        int sy = getScrollY();
-        int dx = x - sx;
-        int dy = y - sy;
-        if (dx == 0 && dy == 0) {
-            completeScroll();
-            if (isMenuOpen()) {
-                if (mOpenedListener != null)
-                    mOpenedListener.onOpened();
-            } else {
-                if (mClosedListener != null)
-                    mClosedListener.onClosed();
-            }
-            return;
-        }
-
-        setScrollingCacheEnabled(true);
-        mScrolling = true;
-
-        final int width = getBehindWidth();
-        final int halfWidth = width / 2;
-        final float distanceRatio = Math.min(1f, 1.0f * Math.abs(dx) / width);
-        final float distance = halfWidth + halfWidth * distanceInfluenceForSnapDuration(distanceRatio);
-
-        int duration = 0;
-        velocity = Math.abs(velocity);
-        if (velocity > 0) {
-            duration = 4 * Math.round(1000 * Math.abs(distance / velocity));
-        } else {
-            final float pageDelta = (float) Math.abs(dx) / width;
-            duration = (int) ((pageDelta + 1) * 100);
-            duration = MAX_SETTLE_DURATION;
-        }
-        duration = Math.min(duration, MAX_SETTLE_DURATION);
-
-        mScroller.startScroll(sx, sy, dx, dy, duration);
-        invalidate();
-    }
-
-    public View getContent() {
-        return mContent;
-    }
-
-    public void setContent(View v) {
-        if (mContent != null)
-            this.removeView(mContent);
-        mContent = v;
-        addView(mContent);
-    }
-
-    public void setCustomViewBehind(CustomViewBehind cvb) {
-        mViewBehind = cvb;
-    }
-
-    @Override
-    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-
-        int width = getDefaultSize(0, widthMeasureSpec);
-        int height = getDefaultSize(0, heightMeasureSpec);
-        setMeasuredDimension(width, height);
-
-        final int contentWidth = getChildMeasureSpec(widthMeasureSpec, 0, width);
-        final int contentHeight = getChildMeasureSpec(heightMeasureSpec, 0, height);
-        mContent.measure(contentWidth, contentHeight);
-    }
-
-    @Override
-    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
-        super.onSizeChanged(w, h, oldw, oldh);
-        // Make sure scroll position is set correctly.
-        if (w != oldw) {
-            // [ChrisJ] - This fixes the onConfiguration change for orientation
-            // issue..
-            // maybe worth having a look why the recomputeScroll pos is screwing
-            // up?
-            completeScroll();
-            scrollTo(getDestScrollX(mCurItem), getScrollY());
-        }
-    }
-
-    @Override
-    protected void onLayout(boolean changed, int l, int t, int r, int b) {
-        final int width = r - l;
-        final int height = b - t;
-        mContent.layout(0, 0, width, height);
-    }
-
-    public void setAboveOffset(int i) {
-        // RelativeLayout.LayoutParams params =
-        // ((RelativeLayout.LayoutParams)mContent.getLayoutParams());
-        // params.setMargins(i, params.topMargin, params.rightMargin,
-        // params.bottomMargin);
-        mContent.setPadding(i, mContent.getPaddingTop(), mContent.getPaddingRight(), mContent.getPaddingBottom());
-    }
-
-    @Override
-    public void computeScroll() {
-        if (!mScroller.isFinished()) {
-            if (mScroller.computeScrollOffset()) {
-                int oldX = getScrollX();
-                int oldY = getScrollY();
-                int x = mScroller.getCurrX();
-                int y = mScroller.getCurrY();
-
-                if (oldX != x || oldY != y) {
-                    scrollTo(x, y);
-                    pageScrolled(x);
-                }
-
-                // Keep on drawing until the animation has finished.
-                invalidate();
-                return;
-            }
-        }
-
-        // Done with scroll, clean up state.
-        completeScroll();
-    }
-
-    private void pageScrolled(int xpos) {
-        final int widthWithMargin = getWidth();
-        final int position = xpos / widthWithMargin;
-        final int offsetPixels = xpos % widthWithMargin;
-        final float offset = (float) offsetPixels / widthWithMargin;
-
-        onPageScrolled(position, offset, offsetPixels);
-    }
-
-    /**
-     * This method will be invoked when the current page is scrolled, either as
-     * part of a programmatically initiated smooth scroll or a user initiated
-     * touch scroll. If you override this method you must call through to the
-     * superclass implementation (e.g. super.onPageScrolled(position, offset,
-     * offsetPixels)) before onPageScrolled returns.
-     *
-     * @param position     Position index of the first page currently being
-     *                     displayed. Page position+1 will be visible if positionOffset
-     *                     is nonzero.
-     * @param offset       Value from [0, 1) indicating the offset from the page at
-     *                     position.
-     * @param offsetPixels Value in pixels indicating the offset from position.
-     */
-    protected void onPageScrolled(int position, float offset, int offsetPixels) {
-        if (mOnPageChangeListener != null) {
-            mOnPageChangeListener.onPageScrolled(position, offset, offsetPixels);
-        }
-        if (mInternalPageChangeListener != null) {
-            mInternalPageChangeListener.onPageScrolled(position, offset, offsetPixels);
-        }
-    }
-
-    private void completeScroll() {
-        boolean needPopulate = mScrolling;
-        if (needPopulate) {
-            // Done with scroll, no longer want to cache view drawing.
-            setScrollingCacheEnabled(false);
-            mScroller.abortAnimation();
-            int oldX = getScrollX();
-            int oldY = getScrollY();
-            int x = mScroller.getCurrX();
-            int y = mScroller.getCurrY();
-            if (oldX != x || oldY != y) {
-                scrollTo(x, y);
-            }
-            if (isMenuOpen()) {
-                if (mOpenedListener != null)
-                    mOpenedListener.onOpened();
-            } else {
-                if (mClosedListener != null)
-                    mClosedListener.onClosed();
-            }
-        }
-        mScrolling = false;
-    }
-
-    public int getTouchMode() {
-        return mTouchMode;
-    }
-
-    public void setTouchMode(int i) {
-        mTouchMode = i;
-    }
-
-    private boolean thisTouchAllowed(MotionEvent ev) {
-        int x = (int) (ev.getX() + mScrollX);
-        if (isMenuOpen()) {
-            return mViewBehind.menuOpenTouchAllowed(mContent, mCurItem, x);
-        } else {
-            switch (mTouchMode) {
-                case SlidingMenu.TOUCHMODE_FULLSCREEN:
-                    return !isInIgnoredView(ev);
-                case SlidingMenu.TOUCHMODE_NONE:
-                    return false;
-                case SlidingMenu.TOUCHMODE_MARGIN:
-                    return mViewBehind.marginTouchAllowed(mContent, x);
-            }
-        }
-        return false;
-    }
-
-    private boolean thisSlideAllowed(float dx) {
-        boolean allowed = false;
-        if (isMenuOpen()) {
-            allowed = mViewBehind.menuOpenSlideAllowed(dx);
-        } else {
-            allowed = mViewBehind.menuClosedSlideAllowed(dx);
-        }
-        if (DEBUG)
-            Log.v(TAG, "this slide allowed " + allowed + " dx: " + dx);
-        return allowed;
-    }
-
-    private int getPointerIndex(MotionEvent ev, int id) {
-        int activePointerIndex = MotionEventCompat.findPointerIndex(ev, id);
-        if (activePointerIndex == -1)
-            mActivePointerId = INVALID_POINTER;
-        return activePointerIndex;
-    }
-
-    @Override
-    public boolean onInterceptTouchEvent(MotionEvent ev) {
-
-        if (!mEnabled)
-            return false;
-
-        final int action = ev.getAction() & MotionEventCompat.ACTION_MASK;
-
-        if (DEBUG)
-            if (action == MotionEvent.ACTION_DOWN)
-                Log.v(TAG, "Received ACTION_DOWN");
-
-        if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP
-                || (action != MotionEvent.ACTION_DOWN && mIsUnableToDrag)) {
-            endDrag();
-            return false;
-        }
-
-        switch (action) {
-            case MotionEvent.ACTION_MOVE:
-                determineDrag(ev);
-                break;
-            case MotionEvent.ACTION_DOWN:
-                int index = MotionEventCompat.getActionIndex(ev);
-                mActivePointerId = MotionEventCompat.getPointerId(ev, index);
-                if (mActivePointerId == INVALID_POINTER)
-                    break;
-                mLastMotionX = mInitialMotionX = MotionEventCompat.getX(ev, index);
-                mLastMotionY = MotionEventCompat.getY(ev, index);
-                if (thisTouchAllowed(ev)) {
-                    mIsBeingDragged = false;
-                    mIsUnableToDrag = false;
-                    if (isMenuOpen() && mViewBehind.menuTouchInQuickReturn(mContent, mCurItem, ev.getX() + mScrollX)) {
-                        mQuickReturn = true;
-                    }
-                } else {
-                    mIsUnableToDrag = true;
-                }
-                break;
-            case MotionEventCompat.ACTION_POINTER_UP:
-                onSecondaryPointerUp(ev);
-                break;
-        }
-
-        if (!mIsBeingDragged) {
-            if (mVelocityTracker == null) {
-                mVelocityTracker = VelocityTracker.obtain();
-            }
-            mVelocityTracker.addMovement(ev);
-        }
-        return mIsBeingDragged || mQuickReturn;
-    }
-
-    @Override
-    public boolean onTouchEvent(MotionEvent ev) {
-
-        if (!mEnabled)
-            return false;
-
-        if (!mIsBeingDragged && !thisTouchAllowed(ev))
-            return false;
-
-        // if (!mIsBeingDragged && !mQuickReturn)
-        // return false;
-
-        final int action = ev.getAction();
-
-        if (mVelocityTracker == null) {
-            mVelocityTracker = VelocityTracker.obtain();
-        }
-        mVelocityTracker.addMovement(ev);
-
-        switch (action & MotionEventCompat.ACTION_MASK) {
-            case MotionEvent.ACTION_DOWN:
-                /*
-                 * If being flinged and user touches, stop the fling. isFinished
-                 * will be false if being flinged.
-                 */
-                completeScroll();
-
-                // Remember where the motion event started
-                int index = MotionEventCompat.getActionIndex(ev);
-                mActivePointerId = MotionEventCompat.getPointerId(ev, index);
-                mLastMotionX = mInitialMotionX = ev.getX();
-                break;
-            case MotionEvent.ACTION_MOVE:
-                if (!mIsBeingDragged) {
-                    determineDrag(ev);
-                    if (mIsUnableToDrag)
-                        return false;
-                }
-                if (mIsBeingDragged) {
-                    // Scroll to follow the motion event
-                    final int activePointerIndex = getPointerIndex(ev, mActivePointerId);
-                    if (mActivePointerId == INVALID_POINTER)
-                        break;
-                    final float x = MotionEventCompat.getX(ev, activePointerIndex);
-                    final float deltaX = mLastMotionX - x;
-                    mLastMotionX = x;
-                    float oldScrollX = getScrollX();
-                    float scrollX = oldScrollX + deltaX;
-                    final float leftBound = getLeftBound();
-                    final float rightBound = getRightBound();
-                    if (scrollX < leftBound) {
-                        scrollX = leftBound;
-                    } else if (scrollX > rightBound) {
-                        scrollX = rightBound;
-                    }
-                    // Don't lose the rounded component
-                    mLastMotionX += scrollX - (int) scrollX;
-                    scrollTo((int) scrollX, getScrollY());
-                    pageScrolled((int) scrollX);
-                }
-                break;
-            case MotionEvent.ACTION_UP:
-                if (mIsBeingDragged) {
-                    final VelocityTracker velocityTracker = mVelocityTracker;
-                    velocityTracker.computeCurrentVelocity(1000, mMaximumVelocity);
-                    int initialVelocity = (int) VelocityTrackerCompat.getXVelocity(velocityTracker, mActivePointerId);
-                    final int scrollX = getScrollX();
-                    final float pageOffset = (float) (scrollX - getDestScrollX(mCurItem)) / getBehindWidth();
-                    final int activePointerIndex = getPointerIndex(ev, mActivePointerId);
-                    if (mActivePointerId != INVALID_POINTER) {
-                        final float x = MotionEventCompat.getX(ev, activePointerIndex);
-                        final int totalDelta = (int) (x - mInitialMotionX);
-                        int nextPage = determineTargetPage(pageOffset, initialVelocity, totalDelta);
-                        setCurrentItemInternal(nextPage, true, true, initialVelocity);
-                    } else {
-                        setCurrentItemInternal(mCurItem, true, true, initialVelocity);
-                    }
-                    mActivePointerId = INVALID_POINTER;
-                    endDrag();
-                } else if (mQuickReturn
-                        && mViewBehind.menuTouchInQuickReturn(mContent, mCurItem, ev.getX() + mScrollX)) {
-                    // close the menu
-                    setCurrentItem(1);
-                    endDrag();
-                }
-                break;
-            case MotionEvent.ACTION_CANCEL:
-                if (mIsBeingDragged) {
-                    setCurrentItemInternal(mCurItem, true, true);
-                    mActivePointerId = INVALID_POINTER;
-                    endDrag();
-                }
-                break;
-            case MotionEventCompat.ACTION_POINTER_DOWN: {
-                final int indexx = MotionEventCompat.getActionIndex(ev);
-                mLastMotionX = MotionEventCompat.getX(ev, indexx);
-                mActivePointerId = MotionEventCompat.getPointerId(ev, indexx);
-                break;
-            }
-            case MotionEventCompat.ACTION_POINTER_UP:
-                onSecondaryPointerUp(ev);
-                int pointerIndex = getPointerIndex(ev, mActivePointerId);
-                if (mActivePointerId == INVALID_POINTER)
-                    break;
-                mLastMotionX = MotionEventCompat.getX(ev, pointerIndex);
-                break;
-        }
-        return true;
-    }
-
-    private void determineDrag(MotionEvent ev) {
-        final int activePointerId = mActivePointerId;
-        final int pointerIndex = getPointerIndex(ev, activePointerId);
-        if (activePointerId == INVALID_POINTER || pointerIndex == INVALID_POINTER)
-            return;
-        final float x = MotionEventCompat.getX(ev, pointerIndex);
-        final float dx = x - mLastMotionX;
-        final float xDiff = Math.abs(dx);
-        final float y = MotionEventCompat.getY(ev, pointerIndex);
-        final float dy = y - mLastMotionY;
-        final float yDiff = Math.abs(dy);
-        if (xDiff > (isMenuOpen() ? mTouchSlop / 2 : mTouchSlop) && xDiff > yDiff && thisSlideAllowed(dx)) {
-            startDrag();
-            mLastMotionX = x;
-            mLastMotionY = y;
-            setScrollingCacheEnabled(true);
-            // TODO add back in touch slop check
-        } else if (xDiff > mTouchSlop) {
-            mIsUnableToDrag = true;
-        }
-    }
-
-    @Override
-    public void scrollTo(int x, int y) {
-        super.scrollTo(x, y);
-        mScrollX = x;
-        mViewBehind.scrollBehindTo(mContent, x, y);
-        ((SlidingMenu) getParent()).manageLayers(getPercentOpen());
-    }
-
-    private int determineTargetPage(float pageOffset, int velocity, int deltaX) {
-        int targetPage = mCurItem;
-        if (Math.abs(deltaX) > mFlingDistance && Math.abs(velocity) > mMinimumVelocity) {
-            if (velocity > 0 && deltaX > 0) {
-                targetPage -= 1;
-            } else if (velocity < 0 && deltaX < 0) {
-                targetPage += 1;
-            }
-        } else {
-            targetPage = (int) Math.round(mCurItem + pageOffset);
-        }
-        return targetPage;
-    }
-
-    protected float getPercentOpen() {
-        return Math.abs(mScrollX - mContent.getLeft()) / getBehindWidth();
-    }
-
-    @Override
-    protected void dispatchDraw(Canvas canvas) {
-        super.dispatchDraw(canvas);
-        // Draw the margin drawable if needed.
-        mViewBehind.drawShadow(mContent, canvas);
-        mViewBehind.drawFade(mContent, canvas, getPercentOpen());
-        mViewBehind.drawSelector(mContent, canvas, getPercentOpen());
-    }
-
-    private void onSecondaryPointerUp(MotionEvent ev) {
-        if (DEBUG)
-            Log.v(TAG, "onSecondaryPointerUp called");
-        final int pointerIndex = MotionEventCompat.getActionIndex(ev);
-        final int pointerId = MotionEventCompat.getPointerId(ev, pointerIndex);
-        if (pointerId == mActivePointerId) {
-            // This was our active pointer going up. Choose a new
-            // active pointer and adjust accordingly.
-            final int newPointerIndex = pointerIndex == 0 ? 1 : 0;
-            mLastMotionX = MotionEventCompat.getX(ev, newPointerIndex);
-            mActivePointerId = MotionEventCompat.getPointerId(ev, newPointerIndex);
-            if (mVelocityTracker != null) {
-                mVelocityTracker.clear();
-            }
-        }
-    }
-
-    private void startDrag() {
-        mIsBeingDragged = true;
-        mQuickReturn = false;
-    }
-
-    private void endDrag() {
-        mQuickReturn = false;
-        mIsBeingDragged = false;
-        mIsUnableToDrag = false;
-        mActivePointerId = INVALID_POINTER;
-
-        if (mVelocityTracker != null) {
-            mVelocityTracker.recycle();
-            mVelocityTracker = null;
-        }
-    }
-
-    private void setScrollingCacheEnabled(boolean enabled) {
-        if (mScrollingCacheEnabled != enabled) {
-            mScrollingCacheEnabled = enabled;
-            if (USE_CACHE) {
-                final int size = getChildCount();
-                for (int i = 0; i < size; ++i) {
-                    final View child = getChildAt(i);
-                    if (child.getVisibility() != GONE) {
-                        child.setDrawingCacheEnabled(enabled);
-                    }
-                }
-            }
-        }
-    }
-
-    /**
-     * Tests scrollability within child views of v given a delta of dx.
-     *
-     * @param v      View to test for horizontal scrollability
-     * @param checkV Whether the view v passed should itself be checked for
-     *               scrollability (true), or just its children (false).
-     * @param dx     Delta scrolled in pixels
-     * @param x      X coordinate of the active touch point
-     * @param y      Y coordinate of the active touch point
-     * @return true if child views of v can be scrolled by delta of dx.
-     */
-    protected boolean canScroll(View v, boolean checkV, int dx, int x, int y) {
-        if (v instanceof ViewGroup) {
-            final ViewGroup group = (ViewGroup) v;
-            final int scrollX = v.getScrollX();
-            final int scrollY = v.getScrollY();
-            final int count = group.getChildCount();
-            // Count backwards - let topmost views consume scroll distance
-            // first.
-            for (int i = count - 1; i >= 0; i--) {
-                final View child = group.getChildAt(i);
-                if (x + scrollX >= child.getLeft() && x + scrollX < child.getRight() && y + scrollY >= child.getTop()
-                        && y + scrollY < child.getBottom()
-                        && canScroll(child, true, dx, x + scrollX - child.getLeft(), y + scrollY - child.getTop())) {
-                    return true;
-                }
-            }
-        }
-
-        return checkV && ViewCompat.canScrollHorizontally(v, -dx);
-    }
-
-    @Override
-    public boolean dispatchKeyEvent(KeyEvent event) {
-        // Let the focused view and/or our descendants get the key first
-        return super.dispatchKeyEvent(event) || executeKeyEvent(event);
-    }
-
-    /**
-     * You can call this function yourself to have the scroll view perform
-     * scrolling from a key event, just as if the event had been dispatched to
-     * it by the view hierarchy.
-     *
-     * @param event The key event to execute.
-     * @return Return true if the event was handled, else false.
-     */
-    public boolean executeKeyEvent(KeyEvent event) {
-        boolean handled = false;
-        if (event.getAction() == KeyEvent.ACTION_DOWN) {
-            switch (event.getKeyCode()) {
-                case KeyEvent.KEYCODE_DPAD_LEFT:
-                    handled = arrowScroll(FOCUS_LEFT);
-                    break;
-                case KeyEvent.KEYCODE_DPAD_RIGHT:
-                    handled = arrowScroll(FOCUS_RIGHT);
-                    break;
-                case KeyEvent.KEYCODE_TAB:
-                    // The focus finder had a bug handling FOCUS_FORWARD and
-                    // FOCUS_BACKWARD
-                    // before Android 3.0. Ignore the tab key on those
-                    // devices.
-                    if (event.hasNoModifiers()) {
-                        handled = arrowScroll(FOCUS_FORWARD);
-                    } else if (event.hasModifiers(KeyEvent.META_SHIFT_ON)) {
-                        handled = arrowScroll(FOCUS_BACKWARD);
-                    }
-                    break;
-            }
-        }
-        return handled;
-    }
-
-    public boolean arrowScroll(int direction) {
-        View currentFocused = findFocus();
-        if (currentFocused == this)
-            currentFocused = null;
-
-        boolean handled = false;
-
-        View nextFocused = FocusFinder.getInstance().findNextFocus(this, currentFocused, direction);
-        if (nextFocused != null && nextFocused != currentFocused) {
-            if (direction == View.FOCUS_LEFT) {
-                handled = nextFocused.requestFocus();
-            } else if (direction == View.FOCUS_RIGHT) {
-                // If there is nothing to the right, or this is causing us to
-                // jump to the left, then what we really want to do is page
-                // right.
-                if (currentFocused != null && nextFocused.getLeft() <= currentFocused.getLeft()) {
-                    handled = pageRight();
-                } else {
-                    handled = nextFocused.requestFocus();
-                }
-            }
-        } else if (direction == FOCUS_LEFT || direction == FOCUS_BACKWARD) {
-            // Trying to move left and nothing there; try to page.
-            handled = pageLeft();
-        } else if (direction == FOCUS_RIGHT || direction == FOCUS_FORWARD) {
-            // Trying to move right and nothing there; try to page.
-            handled = pageRight();
-        }
-        if (handled) {
-            playSoundEffect(SoundEffectConstants.getContantForFocusDirection(direction));
-        }
-        return handled;
-    }
-
-    boolean pageLeft() {
-        if (mCurItem > 0) {
-            setCurrentItem(mCurItem - 1, true);
-            return true;
-        }
-        return false;
-    }
-
-    boolean pageRight() {
-        if (mCurItem < 1) {
-            setCurrentItem(mCurItem + 1, true);
-            return true;
-        }
-        return false;
-    }
-
-    /**
-     * Callback interface for responding to changing state of the selected page.
-     */
-    public interface OnPageChangeListener {
-
-        /**
-         * This method will be invoked when the current page is scrolled, either
-         * as part of a programmatically initiated smooth scroll or a user
-         * initiated touch scroll.
-         *
-         * @param position             Position index of the first page currently being
-         *                             displayed. Page position+1 will be visible if
-         *                             positionOffset is nonzero.
-         * @param positionOffset       Value from [0, 1) indicating the offset from
-         *                             the page at position.
-         * @param positionOffsetPixels Value in pixels indicating the offset
-         *                             from position.
-         */
-        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels);
-
-        /**
-         * This method will be invoked when a new page becomes selected.
-         * Animation is not necessarily complete.
-         *
-         * @param position Position index of the new selected page.
-         */
-        public void onPageSelected(int position);
-
-    }
-
-    /**
-     * Simple implementation of the {@link OnPageChangeListener} interface with
-     * stub implementations of each method. Extend this if you do not intend to
-     * override every method of {@link OnPageChangeListener}.
-     */
-    public static class SimpleOnPageChangeListener implements OnPageChangeListener {
-
-        public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
-            // This space for rent
-        }
-
-        public void onPageSelected(int position) {
-            // This space for rent
-        }
-
-        public void onPageScrollStateChanged(int state) {
-            // This space for rent
-        }
-
-    }
-
-}
diff --git a/qDict/src/main/java/com/mmt/widget/slidemenu/CustomViewBehind.java b/qDict/src/main/java/com/mmt/widget/slidemenu/CustomViewBehind.java
deleted file mode 100644
index 17ee71e..0000000
--- a/qDict/src/main/java/com/mmt/widget/slidemenu/CustomViewBehind.java
+++ /dev/null
@@ -1,440 +0,0 @@
-package com.mmt.widget.slidemenu;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.Color;
-import android.graphics.Paint;
-import android.graphics.drawable.Drawable;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.util.TypedValue;
-import android.view.MotionEvent;
-import android.view.View;
-import android.view.ViewGroup;
-
-import com.annie.dictionary.R;
-import com.mmt.widget.slidemenu.SlidingMenu.CanvasTransformer;
-
-public class CustomViewBehind extends ViewGroup {
-
-    private static final String TAG = "CustomViewBehind";
-
-    private static final int MARGIN_THRESHOLD = 48; // dips
-    private final Paint mFadePaint = new Paint();
-    private int mTouchMode = SlidingMenu.TOUCHMODE_MARGIN;
-    private CustomViewAbove mViewAbove;
-    private View mContent;
-    private View mSecondaryContent;
-    private int mMarginThreshold;
-    private int mWidthOffset;
-    private CanvasTransformer mTransformer;
-    private boolean mChildrenEnabled;
-    private int mMode;
-    private boolean mFadeEnabled;
-    private float mScrollScale;
-    private Drawable mShadowDrawable;
-    private Drawable mSecondaryShadowDrawable;
-    private int mShadowWidth;
-    private float mFadeDegree;
-    private boolean mSelectorEnabled = true;
-    private Bitmap mSelectorDrawable;
-    private View mSelectedView;
-
-    public CustomViewBehind(Context context) {
-        this(context, null);
-    }
-
-    public CustomViewBehind(Context context, AttributeSet attrs) {
-        super(context, attrs);
-        mMarginThreshold = (int) TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, MARGIN_THRESHOLD,
-                getResources().getDisplayMetrics());
-    }
-
-    public void setCustomViewAbove(CustomViewAbove customViewAbove) {
-        mViewAbove = customViewAbove;
-    }
-
-    public void setCanvasTransformer(CanvasTransformer t) {
-        mTransformer = t;
-    }
-
-    public void setWidthOffset(int i) {
-        mWidthOffset = i;
-        requestLayout();
-    }
-
-    public int getMarginThreshold() {
-        return mMarginThreshold;
-    }
-
-    public void setMarginThreshold(int marginThreshold) {
-        mMarginThreshold = marginThreshold;
-    }
-
-    public int getBehindWidth() {
-        return mContent.getWidth();
-    }
-
-    public View getContent() {
-        return mContent;
-    }
-
-    public void setContent(View v) {
-        if (mContent != null)
-            removeView(mContent);
-        mContent = v;
-        addView(mContent);
-    }
-
-    public View getSecondaryContent() {
-        return mSecondaryContent;
-    }
-
-    /**
-     * Sets the secondary (right) menu for use when setMode is called with
-     * SlidingMenu.LEFT_RIGHT.
-     *
-     * @param v the right menu
-     */
-    public void setSecondaryContent(View v) {
-        if (mSecondaryContent != null)
-            removeView(mSecondaryContent);
-        mSecondaryContent = v;
-        addView(mSecondaryContent);
-    }
-
-    public void setChildrenEnabled(boolean enabled) {
-        mChildrenEnabled = enabled;
-    }
-
-    @Override
-    public void scrollTo(int x, int y) {
-        super.scrollTo(x, y);
-        if (mTransformer != null)
-            invalidate();
-    }
-
-    @Override
-    public boolean onInterceptTouchEvent(MotionEvent e) {
-        return !mChildrenEnabled;
-    }
-
-    @Override
-    public boolean onTouchEvent(MotionEvent e) {
-        return !mChildrenEnabled;
-    }
-
-    @Override
-    protected void dispatchDraw(Canvas canvas) {
-        if (mTransformer != null) {
-            canvas.save();
-            mTransformer.transformCanvas(canvas, mViewAbove.getPercentOpen());
-            super.dispatchDraw(canvas);
-            canvas.restore();
-        } else
-            super.dispatchDraw(canvas);
-    }
-
-    @Override
-    protected void onLayout(boolean changed, int l, int t, int r, int b) {
-        final int width = r - l;
-        final int height = b - t;
-        mContent.layout(0, 0, width - mWidthOffset, height);
-        if (mSecondaryContent != null)
-            mSecondaryContent.layout(0, 0, width - mWidthOffset, height);
-    }
-
-    @Override
-    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
-        int width = getDefaultSize(0, widthMeasureSpec);
-        int height = getDefaultSize(0, heightMeasureSpec);
-        setMeasuredDimension(width, height);
-        final int contentWidth = getChildMeasureSpec(widthMeasureSpec, 0, width - mWidthOffset);
-        final int contentHeight = getChildMeasureSpec(heightMeasureSpec, 0, height);
-        mContent.measure(contentWidth, contentHeight);
-        if (mSecondaryContent != null)
-            mSecondaryContent.measure(contentWidth, contentHeight);
-    }
-
-    public int getMode() {
-        return mMode;
-    }
-
-    public void setMode(int mode) {
-        if (mode == SlidingMenu.LEFT || mode == SlidingMenu.RIGHT) {
-            if (mContent != null)
-                mContent.setVisibility(View.VISIBLE);
-            if (mSecondaryContent != null)
-                mSecondaryContent.setVisibility(View.INVISIBLE);
-        }
-        mMode = mode;
-    }
-
-    public float getScrollScale() {
-        return mScrollScale;
-    }
-
-    public void setScrollScale(float scrollScale) {
-        mScrollScale = scrollScale;
-    }
-
-    public void setShadowDrawable(Drawable shadow) {
-        mShadowDrawable = shadow;
-        invalidate();
-    }
-
-    public void setSecondaryShadowDrawable(Drawable shadow) {
-        mSecondaryShadowDrawable = shadow;
-        invalidate();
-    }
-
-    public void setShadowWidth(int width) {
-        mShadowWidth = width;
-        invalidate();
-    }
-
-    public void setFadeEnabled(boolean b) {
-        mFadeEnabled = b;
-    }
-
-    public void setFadeDegree(float degree) {
-        if (degree > 1.0f || degree < 0.0f)
-            throw new IllegalStateException("The BehindFadeDegree must be between 0.0f and 1.0f");
-        mFadeDegree = degree;
-    }
-
-    public int getMenuPage(int page) {
-        page = (page > 1) ? 2 : ((page < 1) ? 0 : page);
-        if (mMode == SlidingMenu.LEFT && page > 1) {
-            return 0;
-        } else if (mMode == SlidingMenu.RIGHT && page < 1) {
-            return 2;
-        } else {
-            return page;
-        }
-    }
-
-    public void scrollBehindTo(View content, int x, int y) {
-        int vis = View.VISIBLE;
-        if (mMode == SlidingMenu.LEFT) {
-            if (x >= content.getLeft())
-                vis = View.INVISIBLE;
-            scrollTo((int) ((x + getBehindWidth()) * mScrollScale), y);
-        } else if (mMode == SlidingMenu.RIGHT) {
-            if (x <= content.getLeft())
-                vis = View.INVISIBLE;
-            scrollTo((int) (getBehindWidth() - getWidth() + (x - getBehindWidth()) * mScrollScale), y);
-        } else if (mMode == SlidingMenu.LEFT_RIGHT) {
-            mContent.setVisibility(x >= content.getLeft() ? View.INVISIBLE : View.VISIBLE);
-            mSecondaryContent.setVisibility(x <= content.getLeft() ? View.INVISIBLE : View.VISIBLE);
-            vis = x == 0 ? View.INVISIBLE : View.VISIBLE;
-            if (x <= content.getLeft()) {
-                scrollTo((int) ((x + getBehindWidth()) * mScrollScale), y);
-            } else {
-                scrollTo((int) (getBehindWidth() - getWidth() + (x - getBehindWidth()) * mScrollScale), y);
-            }
-        }
-        if (vis == View.INVISIBLE)
-            Log.v(TAG, "behind INVISIBLE");
-        setVisibility(vis);
-    }
-
-    public int getMenuLeft(View content, int page) {
-        if (mMode == SlidingMenu.LEFT) {
-            switch (page) {
-                case 0:
-                    return content.getLeft() - getBehindWidth();
-                case 2:
-                    return content.getLeft();
-            }
-        } else if (mMode == SlidingMenu.RIGHT) {
-            switch (page) {
-                case 0:
-                    return content.getLeft();
-                case 2:
-                    return content.getLeft() + getBehindWidth();
-            }
-        } else if (mMode == SlidingMenu.LEFT_RIGHT) {
-            switch (page) {
-                case 0:
-                    return content.getLeft() - getBehindWidth();
-                case 2:
-                    return content.getLeft() + getBehindWidth();
-            }
-        }
-        return content.getLeft();
-    }
-
-    public int getAbsLeftBound(View content) {
-        if (mMode == SlidingMenu.LEFT || mMode == SlidingMenu.LEFT_RIGHT) {
-            return content.getLeft() - getBehindWidth();
-        } else if (mMode == SlidingMenu.RIGHT) {
-            return content.getLeft();
-        }
-        return 0;
-    }
-
-    public int getAbsRightBound(View content) {
-        if (mMode == SlidingMenu.LEFT) {
-            return content.getLeft();
-        } else if (mMode == SlidingMenu.RIGHT || mMode == SlidingMenu.LEFT_RIGHT) {
-            return content.getLeft() + getBehindWidth();
-        }
-        return 0;
-    }
-
-    public boolean marginTouchAllowed(View content, int x) {
-        int left = content.getLeft();
-        int right = content.getRight();
-        if (mMode == SlidingMenu.LEFT) {
-            return (x >= left && x <= mMarginThreshold + left);
-        } else if (mMode == SlidingMenu.RIGHT) {
-            return (x <= right && x >= right - mMarginThreshold);
-        } else if (mMode == SlidingMenu.LEFT_RIGHT) {
-            return (x >= left && x <= mMarginThreshold + left) || (x <= right && x >= right - mMarginThreshold);
-        }
-        return false;
-    }
-
-    public void setTouchMode(int i) {
-        mTouchMode = i;
-    }
-
-    public boolean menuOpenTouchAllowed(View content, int currPage, float x) {
-        switch (mTouchMode) {
-            case SlidingMenu.TOUCHMODE_FULLSCREEN:
-                return true;
-            case SlidingMenu.TOUCHMODE_MARGIN:
-                return menuTouchInQuickReturn(content, currPage, x);
-        }
-        return false;
-    }
-
-    public boolean menuTouchInQuickReturn(View content, int currPage, float x) {
-        if (mMode == SlidingMenu.LEFT || (mMode == SlidingMenu.LEFT_RIGHT && currPage == 0)) {
-            return x >= content.getLeft();
-        } else if (mMode == SlidingMenu.RIGHT || (mMode == SlidingMenu.LEFT_RIGHT && currPage == 2)) {
-            return x <= content.getRight();
-        }
-        return false;
-    }
-
-    public boolean menuClosedSlideAllowed(float dx) {
-        if (mMode == SlidingMenu.LEFT) {
-            return dx > 0;
-        } else if (mMode == SlidingMenu.RIGHT) {
-            return dx < 0;
-        } else if (mMode == SlidingMenu.LEFT_RIGHT) {
-            return true;
-        }
-        return false;
-    }
-
-    public boolean menuOpenSlideAllowed(float dx) {
-        if (mMode == SlidingMenu.LEFT) {
-            return dx < 0;
-        } else if (mMode == SlidingMenu.RIGHT) {
-            return dx > 0;
-        } else if (mMode == SlidingMenu.LEFT_RIGHT) {
-            return true;
-        }
-        return false;
-    }
-
-    public void drawShadow(View content, Canvas canvas) {
-        if (mShadowDrawable == null || mShadowWidth <= 0)
-            return;
-        int left = 0;
-        if (mMode == SlidingMenu.LEFT) {
-            left = content.getLeft() - mShadowWidth;
-        } else if (mMode == SlidingMenu.RIGHT) {
-            left = content.getRight();
-        } else if (mMode == SlidingMenu.LEFT_RIGHT) {
-            if (mSecondaryShadowDrawable != null) {
-                left = content.getRight();
-                mSecondaryShadowDrawable.setBounds(left, 0, left + mShadowWidth, getHeight());
-                mSecondaryShadowDrawable.draw(canvas);
-            }
-            left = content.getLeft() - mShadowWidth;
-        }
-        mShadowDrawable.setBounds(left, 0, left + mShadowWidth, getHeight());
-        mShadowDrawable.draw(canvas);
-    }
-
-    public void drawFade(View content, Canvas canvas, float openPercent) {
-        if (!mFadeEnabled)
-            return;
-        final int alpha = (int) (mFadeDegree * 255 * Math.abs(1 - openPercent));
-        mFadePaint.setColor(Color.argb(alpha, 0, 0, 0));
-        int left = 0;
-        int right = 0;
-        if (mMode == SlidingMenu.LEFT) {
-            left = content.getLeft() - getBehindWidth();
-            right = content.getLeft();
-        } else if (mMode == SlidingMenu.RIGHT) {
-            left = content.getRight();
-            right = content.getRight() + getBehindWidth();
-        } else if (mMode == SlidingMenu.LEFT_RIGHT) {
-            left = content.getLeft() - getBehindWidth();
-            right = content.getLeft();
-            canvas.drawRect(left, 0, right, getHeight(), mFadePaint);
-            left = content.getRight();
-            right = content.getRight() + getBehindWidth();
-        }
-        canvas.drawRect(left, 0, right, getHeight(), mFadePaint);
-    }
-
-    public void drawSelector(View content, Canvas canvas, float openPercent) {
-        if (!mSelectorEnabled)
-            return;
-        if (mSelectorDrawable != null && mSelectedView != null) {
-            String tag = (String) mSelectedView.getTag(R.id.selected_view);
-            if (tag.equals(TAG + "SelectedView")) {
-                canvas.save();
-                int left, right, offset;
-                offset = (int) (mSelectorDrawable.getWidth() * openPercent);
-                if (mMode == SlidingMenu.LEFT) {
-                    right = content.getLeft();
-                    left = right - offset;
-                    canvas.clipRect(left, 0, right, getHeight());
-                    canvas.drawBitmap(mSelectorDrawable, left, getSelectorTop(), null);
-                } else if (mMode == SlidingMenu.RIGHT) {
-                    left = content.getRight();
-                    right = left + offset;
-                    canvas.clipRect(left, 0, right, getHeight());
-                    canvas.drawBitmap(mSelectorDrawable, right - mSelectorDrawable.getWidth(), getSelectorTop(), null);
-                }
-                canvas.restore();
-            }
-        }
-    }
-
-    public void setSelectorEnabled(boolean b) {
-        mSelectorEnabled = b;
-    }
-
-    public void setSelectedView(View v) {
-        if (mSelectedView != null) {
-            mSelectedView.setTag(R.id.selected_view, null);
-            mSelectedView = null;
-        }
-        if (v != null && v.getParent() != null) {
-            mSelectedView = v;
-            mSelectedView.setTag(R.id.selected_view, TAG + "SelectedView");
-            invalidate();
-        }
-    }
-
-    private int getSelectorTop() {
-        int y = mSelectedView.getTop();
-        y += (mSelectedView.getHeight() - mSelectorDrawable.getHeight()) / 2;
-        return y;
-    }
-
-    public void setSelectorBitmap(Bitmap b) {
-        mSelectorDrawable = b;
-        refreshDrawableState();
-    }
-
-}
diff --git a/qDict/src/main/java/com/mmt/widget/slidemenu/MenuInterface.java b/qDict/src/main/java/com/mmt/widget/slidemenu/MenuInterface.java
deleted file mode 100644
index d5ce02c..0000000
--- a/qDict/src/main/java/com/mmt/widget/slidemenu/MenuInterface.java
+++ /dev/null
@@ -1,33 +0,0 @@
-package com.mmt.widget.slidemenu;
-
-import android.graphics.Canvas;
-import android.graphics.drawable.Drawable;
-import android.view.View;
-
-public interface MenuInterface {
-
-    public abstract void scrollBehindTo(int x, int y, CustomViewBehind cvb, float scrollScale);
-
-    public abstract int getMenuLeft(CustomViewBehind cvb, View content);
-
-    public abstract int getAbsLeftBound(CustomViewBehind cvb, View content);
-
-    public abstract int getAbsRightBound(CustomViewBehind cvb, View content);
-
-    public abstract boolean marginTouchAllowed(View content, int x, int threshold);
-
-    public abstract boolean menuOpenTouchAllowed(View content, int currPage, int x);
-
-    public abstract boolean menuTouchInQuickReturn(View content, int currPage, int x);
-
-    public abstract boolean menuClosedSlideAllowed(int x);
-
-    public abstract boolean menuOpenSlideAllowed(int x);
-
-    public abstract void drawShadow(Canvas canvas, Drawable shadow, int width);
-
-    public abstract void drawFade(Canvas canvas, int alpha, CustomViewBehind cvb, View content);
-
-    public abstract void drawSelector(View content, Canvas canvas, float percentOpen);
-
-}
diff --git a/qDict/src/main/java/com/mmt/widget/slidemenu/SlidingMenu.java b/qDict/src/main/java/com/mmt/widget/slidemenu/SlidingMenu.java
deleted file mode 100644
index 65697b1..0000000
--- a/qDict/src/main/java/com/mmt/widget/slidemenu/SlidingMenu.java
+++ /dev/null
@@ -1,1071 +0,0 @@
-package com.mmt.widget.slidemenu;
-
-import android.annotation.SuppressLint;
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.content.Context;
-import android.content.res.Configuration;
-import android.content.res.Resources;
-import android.content.res.TypedArray;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.graphics.Canvas;
-import android.graphics.Point;
-import android.graphics.Rect;
-import android.graphics.drawable.Drawable;
-import android.os.Build;
-import android.os.Parcel;
-import android.os.Parcelable;
-import android.util.AttributeSet;
-import android.util.DisplayMetrics;
-import android.util.Log;
-import android.view.Display;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.WindowManager;
-import android.widget.FrameLayout;
-import android.widget.RelativeLayout;
-
-import com.annie.dictionary.R;
-import com.annie.dictionary.utils.Utils;
-import com.mmt.widget.slidemenu.CustomViewAbove.OnPageChangeListener;
-
-import java.lang.reflect.Method;
-
-public class SlidingMenu extends RelativeLayout {
-
-    public static final int SLIDING_WINDOW = 0;
-    public static final int SLIDING_CONTENT = 1;
-    /**
-     * Constant value for use with setTouchModeAbove(). Allows the SlidingMenu
-     * to be opened with a swipe gesture on the screen's margin
-     */
-    public static final int TOUCHMODE_MARGIN = 0;
-    /**
-     * Constant value for use with setTouchModeAbove(). Allows the SlidingMenu
-     * to be opened with a swipe gesture anywhere on the screen
-     */
-    public static final int TOUCHMODE_FULLSCREEN = 1;
-    /**
-     * Constant value for use with setTouchModeAbove(). Denies the SlidingMenu
-     * to be opened with a swipe gesture
-     */
-    public static final int TOUCHMODE_NONE = 2;
-    /**
-     * Constant value for use with setMode(). Puts the menu to the left of the
-     * content.
-     */
-    public static final int LEFT = 0;
-    /**
-     * Constant value for use with setMode(). Puts the menu to the right of the
-     * content.
-     */
-    public static final int RIGHT = 1;
-    /**
-     * Constant value for use with setMode(). Puts menus to the left and right
-     * of the content.
-     */
-    public static final int LEFT_RIGHT = 2;
-    private static final String TAG = SlidingMenu.class.getSimpleName();
-    public CustomViewBehind mViewBehind;
-    private boolean mActionbarOverlay = false;
-    private CustomViewAbove mViewAbove;
-    private OnOpenListener mOpenListener;
-
-    private OnOpenListener mSecondaryOpenListner;
-
-    private OnCloseListener mCloseListener;
-
-    /**
-     * Instantiates a new SlidingMenu.
-     *
-     * @param context the associated Context
-     */
-    public SlidingMenu(Context context) {
-        this(context, null);
-    }
-
-    /**
-     * Instantiates a new SlidingMenu and attach to Activity.
-     *
-     * @param activity   the activity to attach slidingmenu
-     * @param slideStyle the slidingmenu style
-     */
-    public SlidingMenu(Activity activity, int slideStyle) {
-        this(activity, null);
-        this.attachToActivity(activity, slideStyle);
-    }
-
-    /**
-     * Instantiates a new SlidingMenu.
-     *
-     * @param context the associated Context
-     * @param attrs   the attrs
-     */
-    public SlidingMenu(Context context, AttributeSet attrs) {
-        this(context, attrs, 0);
-    }
-
-    /**
-     * Instantiates a new SlidingMenu.
-     *
-     * @param context  the associated Context
-     * @param attrs    the attrs
-     * @param defStyle the def style
-     */
-    public SlidingMenu(Context context, AttributeSet attrs, int defStyle) {
-        super(context, attrs, defStyle);
-
-        LayoutParams behindParams = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
-        mViewBehind = new CustomViewBehind(context);
-        addView(mViewBehind, behindParams);
-        LayoutParams aboveParams = new LayoutParams(LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
-        mViewAbove = new CustomViewAbove(context);
-        addView(mViewAbove, aboveParams);
-        // register the CustomViewBehind with the CustomViewAbove
-        mViewAbove.setCustomViewBehind(mViewBehind);
-        mViewBehind.setCustomViewAbove(mViewAbove);
-        mViewAbove.setOnPageChangeListener(new OnPageChangeListener() {
-            public static final int POSITION_OPEN = 0;
-
-            public static final int POSITION_CLOSE = 1;
-
-            public static final int POSITION_SECONDARY_OPEN = 2;
-
-            public void onPageScrolled(int position, float positionOffset, int positionOffsetPixels) {
-            }
-
-            public void onPageSelected(int position) {
-                if (position == POSITION_OPEN && mOpenListener != null) {
-                    mOpenListener.onOpen();
-                } else if (position == POSITION_CLOSE && mCloseListener != null) {
-                    mCloseListener.onClose();
-                } else if (position == POSITION_SECONDARY_OPEN && mSecondaryOpenListner != null) {
-                    mSecondaryOpenListner.onOpen();
-                }
-            }
-        });
-
-        // now style everything!
-        TypedArray ta = context.obtainStyledAttributes(attrs, R.styleable.SlidingMenu);
-        // set the above and behind views if defined in xml
-        int mode = ta.getInt(R.styleable.SlidingMenu_mode, LEFT);
-        setMode(mode);
-        int viewAbove = ta.getResourceId(R.styleable.SlidingMenu_viewAbove, -1);
-        if (viewAbove != -1) {
-            setContent(viewAbove);
-        } else {
-            setContent(new FrameLayout(context));
-        }
-        int viewBehind = ta.getResourceId(R.styleable.SlidingMenu_viewBehind, -1);
-        if (viewBehind != -1) {
-            setMenu(viewBehind);
-        } else {
-            setMenu(new FrameLayout(context));
-        }
-        int touchModeAbove = ta.getInt(R.styleable.SlidingMenu_touchModeAbove, TOUCHMODE_MARGIN);
-        setTouchModeAbove(touchModeAbove);
-        int touchModeBehind = ta.getInt(R.styleable.SlidingMenu_touchModeBehind, TOUCHMODE_MARGIN);
-        setTouchModeBehind(touchModeBehind);
-
-        int offsetBehind = (int) ta.getDimension(R.styleable.SlidingMenu_behindOffset, -1);
-        int widthBehind = (int) ta.getDimension(R.styleable.SlidingMenu_behindWidth, -1);
-        if (offsetBehind != -1 && widthBehind != -1)
-            throw new IllegalStateException("Cannot set both behindOffset and behindWidth for a SlidingMenu");
-        else if (offsetBehind != -1)
-            setBehindOffset(offsetBehind);
-        else if (widthBehind != -1)
-            setBehindWidth(widthBehind);
-        else
-            setBehindOffset(0);
-        float scrollOffsetBehind = ta.getFloat(R.styleable.SlidingMenu_behindScrollScale, 0.33f);
-        setBehindScrollScale(scrollOffsetBehind);
-        int shadowRes = ta.getResourceId(R.styleable.SlidingMenu_shadowDrawable, -1);
-        if (shadowRes != -1) {
-            setShadowDrawable(shadowRes);
-        }
-        int shadowWidth = (int) ta.getDimension(R.styleable.SlidingMenu_shadowWidth, 0);
-        setShadowWidth(shadowWidth);
-        boolean fadeEnabled = ta.getBoolean(R.styleable.SlidingMenu_fadeEnabled, true);
-        setFadeEnabled(fadeEnabled);
-        float fadeDeg = ta.getFloat(R.styleable.SlidingMenu_fadeDegree, 0.33f);
-        setFadeDegree(fadeDeg);
-        boolean selectorEnabled = ta.getBoolean(R.styleable.SlidingMenu_selectorEnabled, false);
-        setSelectorEnabled(selectorEnabled);
-        int selectorRes = ta.getResourceId(R.styleable.SlidingMenu_selectorDrawable, -1);
-        if (selectorRes != -1)
-            setSelectorDrawable(selectorRes);
-        ta.recycle();
-    }
-
-    public static Drawable getDrawable(Context context, int resource) {
-        if (Build.VERSION.SDK_INT >= 21) {
-            return context.getResources().getDrawable(resource, null);
-        }
-
-        return context.getResources().getDrawable(resource);
-    }
-
-    /**
-     * Attaches the SlidingMenu to an entire Activity
-     *
-     * @param activity   the Activity
-     * @param slideStyle either SLIDING_CONTENT or SLIDING_WINDOW
-     */
-    public void attachToActivity(Activity activity, int slideStyle) {
-        attachToActivity(activity, slideStyle, false);
-    }
-
-    /**
-     * Attaches the SlidingMenu to an entire Activity
-     *
-     * @param activity         the Activity
-     * @param slideStyle       either SLIDING_CONTENT or SLIDING_WINDOW
-     * @param actionbarOverlay whether or not the ActionBar is overlaid
-     */
-    public void attachToActivity(Activity activity, int slideStyle, boolean actionbarOverlay) {
-        if (slideStyle != SLIDING_WINDOW && slideStyle != SLIDING_CONTENT)
-            throw new IllegalArgumentException("slideStyle must be either SLIDING_WINDOW or SLIDING_CONTENT");
-
-        if (getParent() != null)
-            throw new IllegalStateException("This SlidingMenu appears to already be attached");
-
-        // get the window background
-        TypedArray a = activity.getTheme().obtainStyledAttributes(new int[]{android.R.attr.windowBackground});
-        int background = a.getResourceId(0, 0);
-        a.recycle();
-
-        switch (slideStyle) {
-            case SLIDING_WINDOW:
-                mActionbarOverlay = false;
-                ViewGroup decor = (ViewGroup) activity.getWindow().getDecorView();
-                ViewGroup decorChild = (ViewGroup) decor.getChildAt(0);
-                // save ActionBar themes that have transparent assets
-                decorChild.setBackgroundResource(background);
-                decor.removeView(decorChild);
-                decor.addView(this);
-                setContent(decorChild);
-                break;
-            case SLIDING_CONTENT:
-                mActionbarOverlay = actionbarOverlay;
-                // take the above view out of
-                ViewGroup contentParent = (ViewGroup) activity.findViewById(android.R.id.content);
-                View content = contentParent.getChildAt(0);
-                contentParent.removeView(content);
-                contentParent.addView(this);
-                setContent(content);
-                // save people from having transparent backgrounds
-                if (content.getBackground() == null)
-                    content.setBackgroundResource(background);
-                break;
-        }
-    }
-
-    /**
-     * Set the above view content from a layout resource. The resource will be
-     * inflated, adding all top-level views to the above view.
-     *
-     * @param res the new content
-     */
-    public void setContent(int res) {
-        setContent(LayoutInflater.from(getContext()).inflate(res, null));
-    }
-
-    /**
-     * Retrieves the current content.
-     *
-     * @return the current content
-     */
-    public View getContent() {
-        return mViewAbove.getContent();
-    }
-
-    /**
-     * Set the above view content to the given View.
-     *
-     * @param view The desired content to display.
-     */
-    public void setContent(View view) {
-        mViewAbove.setContent(view);
-        showContent();
-    }
-
-    /**
-     * Set the behind view (menu) content from a layout resource. The resource
-     * will be inflated, adding all top-level views to the behind view.
-     *
-     * @param res the new content
-     */
-    public void setMenu(int res) {
-        setMenu(LayoutInflater.from(getContext()).inflate(res, null));
-    }
-
-    /**
-     * Retrieves the main menu.
-     *
-     * @return the main menu
-     */
-    public View getMenu() {
-        return mViewBehind.getContent();
-    }
-
-    /**
-     * Set the behind view (menu) content to the given View.
-     *
-     * @param v The desired content to display.
-     */
-    public void setMenu(View v) {
-        mViewBehind.setContent(v);
-    }
-
-    /**
-     * Set the secondary behind view (right menu) content from a layout
-     * resource. The resource will be inflated, adding all top-level views to
-     * the behind view.
-     *
-     * @param res the new content
-     */
-    public void setSecondaryMenu(int res) {
-        setSecondaryMenu(LayoutInflater.from(getContext()).inflate(res, null));
-    }
-
-    /**
-     * Retrieves the current secondary menu (right).
-     *
-     * @return the current menu
-     */
-    public View getSecondaryMenu() {
-        return mViewBehind.getSecondaryContent();
-    }
-
-    /**
-     * Set the secondary behind view (right menu) content to the given View.
-     *
-     * @param v The desired content to display.
-     */
-    public void setSecondaryMenu(View v) {
-        mViewBehind.setSecondaryContent(v);
-        // mViewBehind.invalidate();
-    }
-
-    /**
-     * Checks if is sliding enabled.
-     *
-     * @return true, if is sliding enabled
-     */
-    public boolean isSlidingEnabled() {
-        return mViewAbove.isSlidingEnabled();
-    }
-
-    /**
-     * Sets the sliding enabled.
-     *
-     * @param b true to enable sliding, false to disable it.
-     */
-    public void setSlidingEnabled(boolean b) {
-        mViewAbove.setSlidingEnabled(b);
-    }
-
-    /**
-     * Returns the current side that the SlidingMenu is on.
-     *
-     * @return the current mode, either SlidingMenu.LEFT or SlidingMenu.RIGHT
-     */
-    public int getMode() {
-        return mViewBehind.getMode();
-    }
-
-    /**
-     * Sets which side the SlidingMenu should appear on.
-     *
-     * @param mode must be either SlidingMenu.LEFT or SlidingMenu.RIGHT
-     */
-    public void setMode(int mode) {
-        if (mode != LEFT && mode != RIGHT && mode != LEFT_RIGHT) {
-            throw new IllegalStateException("SlidingMenu mode must be LEFT, RIGHT, or LEFT_RIGHT");
-        }
-        mViewBehind.setMode(mode);
-    }
-
-    /**
-     * Sets whether or not the SlidingMenu is in static mode (i.e. nothing is
-     * moving and everything is showing)
-     *
-     * @param b true to set static mode, false to disable static mode.
-     */
-    public void setStatic(boolean b) {
-        if (b) {
-            setSlidingEnabled(false);
-            mViewAbove.setCustomViewBehind(null);
-            mViewAbove.setCurrentItem(1);
-            // mViewBehind.setCurrentItem(0);
-        } else {
-            mViewAbove.setCurrentItem(1);
-            // mViewBehind.setCurrentItem(1);
-            mViewAbove.setCustomViewBehind(mViewBehind);
-            setSlidingEnabled(true);
-        }
-    }
-
-    /**
-     * Opens the menu and shows the menu view.
-     */
-    public void showMenu() {
-        showMenu(true);
-    }
-
-    /**
-     * Opens the menu and shows the menu view.
-     *
-     * @param animate true to animate the transition, false to ignore animation
-     */
-    public void showMenu(boolean animate) {
-        mViewAbove.setCurrentItem(0, animate);
-    }
-
-    /**
-     * Opens the menu and shows the secondary menu view. Will default to the
-     * regular menu if there is only one.
-     */
-    public void showSecondaryMenu() {
-        showSecondaryMenu(true);
-    }
-
-    /**
-     * Opens the menu and shows the secondary (right) menu view. Will default to
-     * the regular menu if there is only one.
-     *
-     * @param animate true to animate the transition, false to ignore animation
-     */
-    public void showSecondaryMenu(boolean animate) {
-        mViewAbove.setCurrentItem(2, animate);
-    }
-
-    /**
-     * Closes the menu and shows the above view.
-     */
-    public void showContent() {
-        showContent(true);
-    }
-
-    /**
-     * Closes the menu and shows the above view.
-     *
-     * @param animate true to animate the transition, false to ignore animation
-     */
-    public void showContent(boolean animate) {
-        mViewAbove.setCurrentItem(1, animate);
-    }
-
-    /**
-     * Toggle the SlidingMenu. If it is open, it will be closed, and vice versa.
-     */
-    public boolean toggle() {
-        return toggle(true);
-    }
-
-    /**
-     * Toggle the SlidingMenu. If it is open, it will be closed, and vice versa.
-     *
-     * @param animate true to animate the transition, false to ignore animation
-     */
-    public boolean toggle(boolean animate) {
-        if (isMenuShowing()) {
-            showContent(animate);
-            return true;
-        } else {
-            showMenu(animate);
-            return false;
-        }
-    }
-
-    /**
-     * Checks if is the behind view showing.
-     *
-     * @return Whether or not the behind view is showing
-     */
-    public boolean isMenuShowing() {
-        return mViewAbove.getCurrentItem() == 0 || mViewAbove.getCurrentItem() == 2;
-    }
-
-    /**
-     * Checks if is the behind view showing.
-     *
-     * @return Whether or not the behind view is showing
-     */
-    public boolean isSecondaryMenuShowing() {
-        return mViewAbove.getCurrentItem() == 2;
-    }
-
-    /**
-     * Gets the behind offset.
-     *
-     * @return The margin on the right of the screen that the behind view
-     * scrolls to
-     */
-    public int getBehindOffset() {
-        return ((RelativeLayout.LayoutParams) mViewBehind.getLayoutParams()).rightMargin;
-    }
-
-    /**
-     * Sets the behind offset.
-     *
-     * @param i The margin, in pixels, on the right of the screen that the
-     *          behind view scrolls to.
-     */
-    public void setBehindOffset(int i) {
-        // RelativeLayout.LayoutParams params =
-        // ((RelativeLayout.LayoutParams)mViewBehind.getLayoutParams());
-        // int bottom = params.bottomMargin;
-        // int top = params.topMargin;
-        // int left = params.leftMargin;
-        // params.setMargins(left, top, i, bottom);
-        mViewBehind.setWidthOffset(i);
-    }
-
-    /**
-     * Sets the behind offset.
-     *
-     * @param resID The dimension resource id to be set as the behind offset. The
-     *              menu, when open, will leave this width margin on the right of
-     *              the screen.
-     */
-    public void setBehindOffsetRes(int resID) {
-        int i = (int) getContext().getResources().getDimension(resID);
-        setBehindOffset(i);
-    }
-
-    /**
-     * Sets the above offset.
-     *
-     * @param i the new above offset, in pixels
-     */
-    public void setAboveOffset(int i) {
-        mViewAbove.setAboveOffset(i);
-    }
-
-    /**
-     * Sets the above offset.
-     *
-     * @param resID The dimension resource id to be set as the above offset.
-     */
-    public void setAboveOffsetRes(int resID) {
-        int i = (int) getContext().getResources().getDimension(resID);
-        setAboveOffset(i);
-    }
-
-    /**
-     * Sets the behind width.
-     *
-     * @param i The width the Sliding Menu will open to, in pixels
-     */
-    @SuppressWarnings("deprecation")
-    public void setBehindWidth(int i) {
-        int width;
-        Display display = ((WindowManager) getContext().getSystemService(Context.WINDOW_SERVICE)).getDefaultDisplay();
-        try {
-            Class<?> cls = Display.class;
-            Class<?>[] parameterTypes = {Point.class};
-            Point parameter = new Point();
-            Method method = cls.getMethod("getSize", parameterTypes);
-            method.invoke(display, parameter);
-            width = parameter.x;
-        } catch (Exception e) {
-            width = display.getWidth();
-        }
-        setBehindOffset(width - i);
-    }
-
-    /**
-     * Sets the behind width.
-     *
-     * @param res The dimension resource id to be set as the behind width
-     *            offset. The menu, when open, will open this wide.
-     */
-    public void setBehindWidthRes(int res) {
-        int i = (int) getContext().getResources().getDimension(res);
-        setBehindWidth(i);
-    }
-
-    /**
-     * Gets the behind scroll scale.
-     *
-     * @return The scale of the parallax scroll
-     */
-    public float getBehindScrollScale() {
-        return mViewBehind.getScrollScale();
-    }
-
-    /**
-     * Sets the behind scroll scale.
-     *
-     * @param f The scale of the parallax scroll (i.e. 1.0f scrolls 1 pixel
-     *          for every 1 pixel that the above view scrolls and 0.0f scrolls
-     *          0 pixels)
-     */
-    public void setBehindScrollScale(float f) {
-        if (f < 0 && f > 1)
-            throw new IllegalStateException("ScrollScale must be between 0 and 1");
-        mViewBehind.setScrollScale(f);
-    }
-
-    /**
-     * Gets the touch mode margin threshold
-     *
-     * @return the touch mode margin threshold
-     */
-    public int getTouchmodeMarginThreshold() {
-        return mViewBehind.getMarginThreshold();
-    }
-
-    /**
-     * Set the touch mode margin threshold
-     *
-     * @param touchmodeMarginThreshold
-     */
-    public void setTouchmodeMarginThreshold(int touchmodeMarginThreshold) {
-        mViewBehind.setMarginThreshold(touchmodeMarginThreshold);
-    }
-
-    /**
-     * Sets the behind canvas transformer.
-     *
-     * @param t the new behind canvas transformer
-     */
-    public void setBehindCanvasTransformer(CanvasTransformer t) {
-        mViewBehind.setCanvasTransformer(t);
-    }
-
-    /**
-     * Gets the touch mode above.
-     *
-     * @return the touch mode above
-     */
-    public int getTouchModeAbove() {
-        return mViewAbove.getTouchMode();
-    }
-
-    /**
-     * Controls whether the SlidingMenu can be opened with a swipe gesture.
-     * Options are {@link #TOUCHMODE_MARGIN TOUCHMODE_MARGIN},
-     * {@link #TOUCHMODE_FULLSCREEN TOUCHMODE_FULLSCREEN}, or
-     * {@link #TOUCHMODE_NONE TOUCHMODE_NONE}
-     *
-     * @param i the new touch mode
-     */
-    public void setTouchModeAbove(int i) {
-        if (i != TOUCHMODE_FULLSCREEN && i != TOUCHMODE_MARGIN && i != TOUCHMODE_NONE) {
-            throw new IllegalStateException(
-                    "TouchMode must be set to either" + "TOUCHMODE_FULLSCREEN or TOUCHMODE_MARGIN or TOUCHMODE_NONE.");
-        }
-        mViewAbove.setTouchMode(i);
-    }
-
-    /**
-     * Controls whether the SlidingMenu can be opened with a swipe gesture.
-     * Options are {@link #TOUCHMODE_MARGIN TOUCHMODE_MARGIN},
-     * {@link #TOUCHMODE_FULLSCREEN TOUCHMODE_FULLSCREEN}, or
-     * {@link #TOUCHMODE_NONE TOUCHMODE_NONE}
-     *
-     * @param i the new touch mode
-     */
-    public void setTouchModeBehind(int i) {
-        if (i != TOUCHMODE_FULLSCREEN && i != TOUCHMODE_MARGIN && i != TOUCHMODE_NONE) {
-            throw new IllegalStateException(
-                    "TouchMode must be set to either" + "TOUCHMODE_FULLSCREEN or TOUCHMODE_MARGIN or TOUCHMODE_NONE.");
-        }
-        mViewBehind.setTouchMode(i);
-    }
-
-    /**
-     * Sets the shadow drawable.
-     *
-     * @param resId the resource ID of the new shadow drawable
-     */
-    public void setShadowDrawable(int resId) {
-        setShadowDrawable(getDrawable(getContext(), resId));
-    }
-
-    /**
-     * Sets the shadow drawable.
-     *
-     * @param d the new shadow drawable
-     */
-    public void setShadowDrawable(Drawable d) {
-        mViewBehind.setShadowDrawable(d);
-    }
-
-    /**
-     * Sets the secondary (right) shadow drawable.
-     *
-     * @param resId the resource ID of the new shadow drawable
-     */
-    public void setSecondaryShadowDrawable(int resId) {
-        setSecondaryShadowDrawable(getDrawable(getContext(), resId));
-    }
-
-    /**
-     * Sets the secondary (right) shadow drawable.
-     *
-     * @param d the new shadow drawable
-     */
-    public void setSecondaryShadowDrawable(Drawable d) {
-        mViewBehind.setSecondaryShadowDrawable(d);
-    }
-
-    /**
-     * Sets the shadow width.
-     *
-     * @param resId The dimension resource id to be set as the shadow width.
-     */
-    public void setShadowWidthRes(int resId) {
-        setShadowWidth((int) getResources().getDimension(resId));
-    }
-
-    /**
-     * Sets the shadow width.
-     *
-     * @param pixels the new shadow width, in pixels
-     */
-    public void setShadowWidth(int pixels) {
-        mViewBehind.setShadowWidth(pixels);
-    }
-
-    /**
-     * Enables or disables the SlidingMenu's fade in and out
-     *
-     * @param b true to enable fade, false to disable it
-     */
-    public void setFadeEnabled(boolean b) {
-        mViewBehind.setFadeEnabled(b);
-    }
-
-    /**
-     * Sets how much the SlidingMenu fades in and out. Fade must be enabled, see
-     * {@link #setFadeEnabled(boolean) setFadeEnabled(boolean)}
-     *
-     * @param f the new fade degree, between 0.0f and 1.0f
-     */
-    public void setFadeDegree(float f) {
-        mViewBehind.setFadeDegree(f);
-    }
-
-    /**
-     * Enables or disables whether the selector is drawn
-     *
-     * @param b true to draw the selector, false to not draw the selector
-     */
-    public void setSelectorEnabled(boolean b) {
-        mViewBehind.setSelectorEnabled(true);
-    }
-
-    /**
-     * Sets the selected view. The selector will be drawn here
-     *
-     * @param v the new selected view
-     */
-    public void setSelectedView(View v) {
-        mViewBehind.setSelectedView(v);
-    }
-
-    /**
-     * Sets the selector drawable.
-     *
-     * @param res a resource ID for the selector drawable
-     */
-    public void setSelectorDrawable(int res) {
-        mViewBehind.setSelectorBitmap(BitmapFactory.decodeResource(getResources(), res));
-    }
-
-    /**
-     * Sets the selector drawable.
-     *
-     * @param b the new selector bitmap
-     */
-    public void setSelectorBitmap(Bitmap b) {
-        mViewBehind.setSelectorBitmap(b);
-    }
-
-    /**
-     * Add a View ignored by the Touch Down event when mode is Fullscreen
-     *
-     * @param v a view to be ignored
-     */
-    public void addIgnoredView(View v) {
-        mViewAbove.addIgnoredView(v);
-    }
-
-    /**
-     * Remove a View ignored by the Touch Down event when mode is Fullscreen
-     *
-     * @param v a view not wanted to be ignored anymore
-     */
-    public void removeIgnoredView(View v) {
-        mViewAbove.removeIgnoredView(v);
-    }
-
-    /**
-     * Clear the list of Views ignored by the Touch Down event when mode is
-     * Fullscreen
-     */
-    public void clearIgnoredViews() {
-        mViewAbove.clearIgnoredViews();
-    }
-
-    /**
-     * Sets the OnOpenListener. {@link OnOpenListener#onOpen()
-     * OnOpenListener.onOpen()} will be called when the SlidingMenu is opened
-     *
-     * @param listener the new OnOpenListener
-     */
-    public void setOnOpenListener(OnOpenListener listener) {
-        // mViewAbove.setOnOpenListener(listener);
-        mOpenListener = listener;
-    }
-
-    /**
-     * Sets the OnOpenListner for secondary menu {@link OnOpenListener#onOpen()
-     * OnOpenListener.onOpen()} will be called when the secondary SlidingMenu is
-     * opened
-     *
-     * @param listener the new OnOpenListener
-     */
-
-    public void setSecondaryOnOpenListner(OnOpenListener listener) {
-        mSecondaryOpenListner = listener;
-    }
-
-    /**
-     * Sets the OnCloseListener. {@link OnCloseListener#onClose()
-     * OnCloseListener.onClose()} will be called when any one of the SlidingMenu
-     * is closed
-     *
-     * @param listener the new setOnCloseListener
-     */
-    public void setOnCloseListener(OnCloseListener listener) {
-        // mViewAbove.setOnCloseListener(listener);
-        mCloseListener = listener;
-    }
-
-    /**
-     * Sets the OnOpenedListener. {@link OnOpenedListener#onOpened()
-     * OnOpenedListener.onOpened()} will be called after the SlidingMenu is
-     * opened
-     *
-     * @param listener the new OnOpenedListener
-     */
-    public void setOnOpenedListener(OnOpenedListener listener) {
-        mViewAbove.setOnOpenedListener(listener);
-    }
-
-    /**
-     * Sets the OnClosedListener. {@link OnClosedListener#onClosed()
-     * OnClosedListener.onClosed()} will be called after the SlidingMenu is
-     * closed
-     *
-     * @param listener the new OnClosedListener
-     */
-    public void setOnClosedListener(OnClosedListener listener) {
-        mViewAbove.setOnClosedListener(listener);
-    }
-
-    /*
-     * (non-Javadoc)
-     *
-     * @see android.view.View#onSaveInstanceState()
-     */
-    @Override
-    protected Parcelable onSaveInstanceState() {
-        Parcelable superState = super.onSaveInstanceState();
-        SavedState ss = new SavedState(superState, mViewAbove.getCurrentItem());
-        return ss;
-    }
-
-    /*
-     * (non-Javadoc)
-     *
-     * @see android.view.View#onRestoreInstanceState(android.os.Parcelable)
-     */
-    @Override
-    protected void onRestoreInstanceState(Parcelable state) {
-        SavedState ss = (SavedState) state;
-        super.onRestoreInstanceState(ss.getSuperState());
-        mViewAbove.setCurrentItem(ss.getItem());
-    }
-
-    /*
-     * (non-Javadoc)
-     *
-     * @see android.view.ViewGroup#fitSystemWindows(android.graphics.Rect)
-     */
-    @SuppressLint("NewApi")
-    @Override
-    protected boolean fitSystemWindows(Rect insets) {
-        int leftPadding = insets.left;
-        int rightPadding = insets.right;
-        int topPadding = insets.top;
-        int bottomPadding = insets.bottom;
-
-        Resources resources = getContent().getResources();
-        boolean isBottom = isSystemBarOnBottom(resources);
-        Configuration cfg = resources.getConfiguration();
-        int orientation = cfg.orientation;
-        int resourceId;
-        if (orientation == Configuration.ORIENTATION_LANDSCAPE) {
-            resourceId = resources.getIdentifier("navigation_bar_width", "dimen", "android");
-        } else {
-            resourceId = resources.getIdentifier("navigation_bar_height", "dimen", "android");
-        }
-        if (resourceId > 0) {
-            if (isBottom)
-                bottomPadding += resources.getDimensionPixelSize(resourceId);
-            else {
-                rightPadding += resources.getDimensionPixelSize(resourceId);
-            }
-        }
-
-        if (!mActionbarOverlay) {
-            setPadding(leftPadding, topPadding, rightPadding, bottomPadding);
-        }
-        return true;
-    }
-
-    private boolean isSystemBarOnBottom(Resources res) {
-        Configuration cfg = res.getConfiguration();
-        DisplayMetrics dm = res.getDisplayMetrics();
-        boolean canMove = (dm.widthPixels != dm.heightPixels && cfg.smallestScreenWidthDp < 600);
-
-        return (!canMove || dm.widthPixels < dm.heightPixels);
-    }
-
-    public void manageLayers(float percentOpen) {
-        boolean layer = percentOpen > 0.0f && percentOpen < 1.0f;
-        final int layerType = layer ? View.LAYER_TYPE_HARDWARE : View.LAYER_TYPE_NONE;
-
-        if (layerType != getContent().getLayerType()) {
-            getHandler().post(() -> {
-                Log.v(TAG, "changing layerType. hardware? " + (layerType == View.LAYER_TYPE_HARDWARE));
-                getContent().setLayerType(layerType, null);
-                getMenu().setLayerType(layerType, null);
-                if (getSecondaryMenu() != null) {
-                    getSecondaryMenu().setLayerType(layerType, null);
-                }
-            });
-        }
-    }
-
-    /**
-     * The listener interface for receiving onOpen events. The class that is
-     * interested in processing a onOpen event implements this interface, and
-     * the object created with that class is registered with a component using
-     * the component's <code>addOnOpenListener<code> method. When the onOpen
-     * event occurs, that object's appropriate method is invoked
-     */
-    public interface OnOpenListener {
-
-        /**
-         * On open.
-         */
-        public void onOpen();
-    }
-
-    /**
-     * The listener interface for receiving onOpened events. The class that is
-     * interested in processing a onOpened event implements this interface, and
-     * the object created with that class is registered with a component using
-     * the component's <code>addOnOpenedListener<code> method. When the onOpened
-     * event occurs, that object's appropriate method is invoked.
-     */
-    public interface OnOpenedListener {
-
-        /**
-         * On opened.
-         */
-        public void onOpened();
-    }
-
-    /**
-     * The listener interface for receiving onClose events. The class that is
-     * interested in processing a onClose event implements this interface, and
-     * the object created with that class is registered with a component using
-     * the component's <code>addOnCloseListener<code> method. When the onClose
-     * event occurs, that object's appropriate method is invoked.
-     */
-    public interface OnCloseListener {
-
-        /**
-         * On close.
-         */
-        public void onClose();
-    }
-
-    /**
-     * The listener interface for receiving onClosed events. The class that is
-     * interested in processing a onClosed event implements this interface, and
-     * the object created with that class is registered with a component using
-     * the component's <code>addOnClosedListener<code> method. When the onClosed
-     * event occurs, that object's appropriate method is invoked.
-     */
-    public interface OnClosedListener {
-
-        /**
-         * On closed.
-         */
-        public void onClosed();
-    }
-
-    /**
-     * The Interface CanvasTransformer.
-     */
-    public interface CanvasTransformer {
-
-        /**
-         * Transform canvas.
-         *
-         * @param canvas      the canvas
-         * @param percentOpen the percent open
-         */
-        public void transformCanvas(Canvas canvas, float percentOpen);
-    }
-
-    public static class SavedState extends BaseSavedState {
-
-        public static final Parcelable.Creator<SavedState> CREATOR = new Parcelable.Creator<SavedState>() {
-            public SavedState createFromParcel(Parcel in) {
-                return new SavedState(in);
-            }
-
-            public SavedState[] newArray(int size) {
-                return new SavedState[size];
-            }
-        };
-        private final int mItem;
-
-        public SavedState(Parcelable superState, int item) {
-            super(superState);
-            mItem = item;
-        }
-
-        private SavedState(Parcel in) {
-            super(in);
-            mItem = in.readInt();
-        }
-
-        public int getItem() {
-            return mItem;
-        }
-
-        /*
-         * (non-Javadoc)
-         *
-         * @see android.view.AbsSavedState#writeToParcel(android.os.Parcel, int)
-         */
-        public void writeToParcel(Parcel out, int flags) {
-            super.writeToParcel(out, flags);
-            out.writeInt(mItem);
-        }
-
-    }
-
-}
