diff --git a/app/src/androidTest/java/com/amaze/filemanager/asynchronous/services/ftp/FtpServiceEspressoTest.kt b/app/src/androidTest/java/com/amaze/filemanager/asynchronous/services/ftp/FtpServiceEspressoTest.kt
index 02cdb4d94..3b7e4952c 100644
--- a/app/src/androidTest/java/com/amaze/filemanager/asynchronous/services/ftp/FtpServiceEspressoTest.kt
+++ b/app/src/androidTest/java/com/amaze/filemanager/asynchronous/services/ftp/FtpServiceEspressoTest.kt
@@ -29,6 +29,7 @@ import androidx.test.ext.junit.runners.AndroidJUnit4
 import androidx.test.rule.ServiceTestRule
 import com.amaze.filemanager.utils.ObtainableServiceBinder
 import com.amaze.filemanager.utils.PasswordUtil
+import org.apache.commons.net.PrintCommandListener
 import org.apache.commons.net.ftp.FTP
 import org.apache.commons.net.ftp.FTPClient
 import org.apache.commons.net.ftp.FTPSClient
@@ -92,9 +93,11 @@ class FtpServiceEspressoTest {
                 .putExtra(FtpService.TAG_STARTED_BY_TILE, false)
         )
 
-        await().atMost(10, TimeUnit.SECONDS).until { FtpService.isRunning() }
-        waitForServer()
+        await().atMost(10, TimeUnit.SECONDS).until {
+            FtpService.isRunning() && isServerReady()
+        }
         FTPClient().run {
+            addProtocolCommandListener(PrintCommandListener(System.err))
             loginAndVerifyWith(this)
             testUploadWith(this)
             testDownloadWith(this)
@@ -118,10 +121,12 @@ class FtpServiceEspressoTest {
                 .putExtra(FtpService.TAG_STARTED_BY_TILE, false)
         )
 
-        await().atMost(10, TimeUnit.SECONDS).until { FtpService.isRunning() }
-        waitForServer()
+        await().atMost(10, TimeUnit.SECONDS).until {
+            FtpService.isRunning() && isServerReady()
+        }
 
         FTPSClient(true).run {
+            addProtocolCommandListener(PrintCommandListener(System.err))
             loginAndVerifyWith(this)
             testUploadWith(this)
             testDownloadWith(this)
@@ -150,9 +155,9 @@ class FtpServiceEspressoTest {
                 .putExtra(FtpService.TAG_STARTED_BY_TILE, false)
         )
 
-        while (!FtpService.isRunning());
-        assertTrue(FtpService.isRunning())
-        waitForServer()
+        await().atMost(10, TimeUnit.SECONDS).until {
+            FtpService.isRunning() && isServerReady()
+        }
 
         FTPClient().run {
             connect("localhost", FtpService.DEFAULT_PORT)
@@ -171,7 +176,7 @@ class FtpServiceEspressoTest {
         assertTrue(
             "No files found on device? It is also possible that app doesn't have " +
                 "permission to access storage, which may occur on broken Android emulators",
-            files.size > 0
+            files.isNotEmpty()
         )
         var downloadFolderExists = false
         for (f in files) {
@@ -203,12 +208,12 @@ class FtpServiceEspressoTest {
             enterLocalPassiveMode()
             setFileType(FTP.ASCII_FILE_TYPE)
             ByteArrayInputStream(randomString.toByteArray(charset("utf-8"))).run {
-                storeFile("test.txt", this)
+                this.copyTo(storeFileStream("test.txt"))
                 close()
             }
             ByteArrayInputStream(bytes2).run {
-                setFileType(FTP.BINARY_FILE_TYPE)
-                storeFile("test.bin", this)
+                assertTrue(setFileType(FTP.BINARY_FILE_TYPE))
+                this.copyTo(storeFileStream("test.bin"))
                 close()
             }
             logout()
@@ -296,17 +301,15 @@ class FtpServiceEspressoTest {
         }
     }
 
-    private fun waitForServer() {
-        var available = false
-        while (!available) {
-            Socket().run {
-                available = try {
-                    connect(InetSocketAddress(InetAddress.getLocalHost(), FtpService.DEFAULT_PORT))
-                    close()
-                    true
-                } catch (e: SocketException) {
-                    false
-                }
+    private fun isServerReady(): Boolean {
+        return Socket().let {
+            try {
+                it.connect(InetSocketAddress(InetAddress.getLocalHost(), FtpService.DEFAULT_PORT))
+                true
+            } catch (e: SocketException) {
+                false
+            } finally {
+                it.close()
             }
         }
     }
diff --git a/app/src/androidTest/java/com/amaze/filemanager/database/UtilsHandlerTest.java b/app/src/androidTest/java/com/amaze/filemanager/database/UtilsHandlerTest.java
index 231b7920d..154e48970 100644
--- a/app/src/androidTest/java/com/amaze/filemanager/database/UtilsHandlerTest.java
+++ b/app/src/androidTest/java/com/amaze/filemanager/database/UtilsHandlerTest.java
@@ -33,7 +33,7 @@ import org.junit.Test;
 import org.junit.runner.RunWith;
 
 import com.amaze.filemanager.database.models.OperationData;
-import com.amaze.filemanager.filesystem.ssh.SshClientUtils;
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientUtils;
 
 import android.content.Context;
 import android.os.Environment;
@@ -118,7 +118,7 @@ public class UtilsHandlerTest {
   }
 
   private void performEncryptUriTest(@NonNull final String origPath) {
-    String encryptedPath = SshClientUtils.encryptSshPathAsNecessary(origPath);
+    String encryptedPath = NetCopyClientUtils.INSTANCE.encryptFtpPathAsNecessary(origPath);
 
     utilsHandler.saveToDatabase(
         new OperationData(
diff --git a/app/src/androidTest/java/com/amaze/filemanager/ssh/SshClientUtilTest.java b/app/src/androidTest/java/com/amaze/filemanager/ssh/SshClientUtilTest.java
index 48d5850e5..1965d8d55 100644
--- a/app/src/androidTest/java/com/amaze/filemanager/ssh/SshClientUtilTest.java
+++ b/app/src/androidTest/java/com/amaze/filemanager/ssh/SshClientUtilTest.java
@@ -26,7 +26,7 @@ import static org.junit.Assert.assertTrue;
 import org.junit.Test;
 import org.junit.runner.RunWith;
 
-import com.amaze.filemanager.filesystem.ssh.SshClientUtils;
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientUtils;
 
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 
@@ -36,47 +36,47 @@ public class SshClientUtilTest {
   @Test
   public void testEncryptDecryptUriWithNoPassword() {
     String uri = "ssh://testuser@127.0.0.1:22";
-    assertEquals(uri, SshClientUtils.encryptSshPathAsNecessary(uri));
-    assertEquals(uri, SshClientUtils.decryptSshPathAsNecessary(uri));
+    assertEquals(uri, NetCopyClientUtils.INSTANCE.encryptFtpPathAsNecessary(uri));
+    assertEquals(uri, NetCopyClientUtils.INSTANCE.encryptFtpPathAsNecessary(uri));
   }
 
   @Test
   public void testEncryptDecryptPasswordWithMinusSign1() {
     String uri = "ssh://testuser:abcd-efgh@127.0.0.1:22";
-    String result = SshClientUtils.encryptSshPathAsNecessary(uri);
+    String result = NetCopyClientUtils.INSTANCE.encryptFtpPathAsNecessary(uri);
     assertTrue(result.contains("ssh://testuser:"));
     assertTrue(result.contains("@127.0.0.1:22"));
-    String verify = SshClientUtils.decryptSshPathAsNecessary(result);
+    String verify = NetCopyClientUtils.INSTANCE.encryptFtpPathAsNecessary(result);
     assertEquals(uri, verify);
   }
 
   @Test
   public void testEncryptDecryptPasswordWithMinusSign2() {
     String uri = "ssh://testuser:---------------@127.0.0.1:22";
-    String result = SshClientUtils.encryptSshPathAsNecessary(uri);
+    String result = NetCopyClientUtils.INSTANCE.encryptFtpPathAsNecessary(uri);
     assertTrue(result.contains("ssh://testuser:"));
     assertTrue(result.contains("@127.0.0.1:22"));
-    String verify = SshClientUtils.decryptSshPathAsNecessary(result);
+    String verify = NetCopyClientUtils.INSTANCE.encryptFtpPathAsNecessary(result);
     assertEquals(uri, verify);
   }
 
   @Test
   public void testEncryptDecryptPasswordWithMinusSign3() {
     String uri = "ssh://testuser:--agdiuhdpost15@127.0.0.1:22";
-    String result = SshClientUtils.encryptSshPathAsNecessary(uri);
+    String result = NetCopyClientUtils.INSTANCE.encryptFtpPathAsNecessary(uri);
     assertTrue(result.contains("ssh://testuser:"));
     assertTrue(result.contains("@127.0.0.1:22"));
-    String verify = SshClientUtils.decryptSshPathAsNecessary(result);
+    String verify = NetCopyClientUtils.INSTANCE.encryptFtpPathAsNecessary(result);
     assertEquals(uri, verify);
   }
 
   @Test
   public void testEncryptDecryptPasswordWithMinusSign4() {
     String uri = "ssh://testuser:t-h-i-s-i-s-p-a-s-s-w-o-r-d-@127.0.0.1:22";
-    String result = SshClientUtils.encryptSshPathAsNecessary(uri);
+    String result = NetCopyClientUtils.INSTANCE.encryptFtpPathAsNecessary(uri);
     assertTrue(result.contains("ssh://testuser:"));
     assertTrue(result.contains("@127.0.0.1:22"));
-    String verify = SshClientUtils.decryptSshPathAsNecessary(result);
+    String verify = NetCopyClientUtils.INSTANCE.encryptFtpPathAsNecessary(result);
     assertEquals(uri, verify);
   }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/RecyclerAdapter.java b/app/src/main/java/com/amaze/filemanager/adapters/RecyclerAdapter.java
index 2730ecd5c..047aadfba 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/RecyclerAdapter.java
+++ b/app/src/main/java/com/amaze/filemanager/adapters/RecyclerAdapter.java
@@ -46,6 +46,7 @@ import com.amaze.filemanager.adapters.holders.EmptyViewHolder;
 import com.amaze.filemanager.adapters.holders.ItemViewHolder;
 import com.amaze.filemanager.adapters.holders.SpecialViewHolder;
 import com.amaze.filemanager.application.AppConfig;
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.files.CryptUtil;
 import com.amaze.filemanager.ui.ItemPopupMenu;
 import com.amaze.filemanager.ui.activities.superclasses.PreferenceActivity;
@@ -859,7 +860,7 @@ public class RecyclerAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolde
     switch (rowItem.filetype) {
       case Icons.IMAGE:
       case Icons.VIDEO:
-        if (getBoolean(PREFERENCE_SHOW_THUMB)) {
+        if (getBoolean(PREFERENCE_SHOW_THUMB) && rowItem.getMode() != OpenMode.FTP) {
           if (getBoolean(PREFERENCE_USE_CIRCULAR_IMAGES)) {
             showThumbnailWithBackground(
                 holder, rowItem.iconData, holder.pictureIcon, rowItem.iconData::setImageBroken);
@@ -1006,27 +1007,24 @@ public class RecyclerAdapter extends RecyclerView.Adapter<RecyclerView.ViewHolde
     holder.checkImageViewGrid.setVisibility(View.INVISIBLE);
 
     if (rowItem.filetype == Icons.IMAGE || rowItem.filetype == Icons.VIDEO) {
-      if (getBoolean(PREFERENCE_SHOW_THUMB)) {
+      if (getBoolean(PREFERENCE_SHOW_THUMB) && rowItem.getMode() != OpenMode.FTP) {
         holder.imageView1.setVisibility(View.VISIBLE);
         holder.imageView1.setImageDrawable(null);
         if (utilsProvider.getAppTheme().equals(AppTheme.DARK)
-            || utilsProvider.getAppTheme().equals(AppTheme.BLACK)) {
+            || utilsProvider.getAppTheme().equals(AppTheme.BLACK))
           holder.imageView1.setBackgroundColor(Color.BLACK);
-        }
         showRoundedThumbnail(
             holder, rowItem.iconData, holder.imageView1, rowItem.iconData::setImageBroken);
       } else {
-        if (rowItem.filetype == Icons.IMAGE) {
+        if (rowItem.filetype == Icons.IMAGE)
           holder.genericIcon.setImageResource(R.drawable.ic_doc_image);
-        } else {
-          holder.genericIcon.setImageResource(R.drawable.ic_doc_video_am);
-        }
+        else holder.genericIcon.setImageResource(R.drawable.ic_doc_video_am);
       }
     } else if (rowItem.filetype == Icons.APK) {
-      if (getBoolean(PREFERENCE_SHOW_THUMB)) {
+      if (getBoolean(PREFERENCE_SHOW_THUMB))
         showRoundedThumbnail(
             holder, rowItem.iconData, holder.genericIcon, rowItem.iconData::setImageBroken);
-      } else {
+      else {
         holder.genericIcon.setImageResource(R.drawable.ic_doc_apk_white);
       }
     } else {
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/data/LayoutElementParcelable.java b/app/src/main/java/com/amaze/filemanager/adapters/data/LayoutElementParcelable.java
index 0ecfde8b4..0a4d34b67 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/data/LayoutElementParcelable.java
+++ b/app/src/main/java/com/amaze/filemanager/adapters/data/LayoutElementParcelable.java
@@ -163,6 +163,11 @@ public class LayoutElementParcelable implements Parcelable {
             this.iconData = new IconDataParcelable(IconDataParcelable.IMAGE_RES, fallbackIcon);
           }
           break;
+          // Until we find a way to properly handle threading issues with thread unsafe FTPClient,
+          // we refrain from loading any files via FTP as file thumbnail. - TranceLove
+        case FTP:
+          this.iconData = new IconDataParcelable(IconDataParcelable.IMAGE_RES, fallbackIcon);
+          break;
         default:
           if (filetype == Icons.IMAGE || filetype == Icons.VIDEO || filetype == Icons.APK) {
             this.iconData =
diff --git a/app/src/main/java/com/amaze/filemanager/adapters/glide/cloudicon/CloudIconModelLoader.java b/app/src/main/java/com/amaze/filemanager/adapters/glide/cloudicon/CloudIconModelLoader.java
index 6a15ff546..afc9e683e 100644
--- a/app/src/main/java/com/amaze/filemanager/adapters/glide/cloudicon/CloudIconModelLoader.java
+++ b/app/src/main/java/com/amaze/filemanager/adapters/glide/cloudicon/CloudIconModelLoader.java
@@ -20,6 +20,9 @@
 
 package com.amaze.filemanager.adapters.glide.cloudicon;
 
+import static com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.SSH_URI_PREFIX;
+import static com.amaze.filemanager.filesystem.smb.CifsContexts.SMB_URI_PREFIX;
+
 import com.amaze.filemanager.database.CloudHandler;
 import com.bumptech.glide.load.Options;
 import com.bumptech.glide.load.model.ModelLoader;
@@ -33,7 +36,7 @@ import androidx.annotation.Nullable;
 /** Created by Vishal Nehra on 3/27/2018. */
 public class CloudIconModelLoader implements ModelLoader<String, Bitmap> {
 
-  private Context context;
+  private final Context context;
 
   public CloudIconModelLoader(Context context) {
     this.context = context;
@@ -56,7 +59,7 @@ public class CloudIconModelLoader implements ModelLoader<String, Bitmap> {
         || s.startsWith(CloudHandler.CLOUD_PREFIX_DROPBOX)
         || s.startsWith(CloudHandler.CLOUD_PREFIX_GOOGLE_DRIVE)
         || s.startsWith(CloudHandler.CLOUD_PREFIX_ONE_DRIVE)
-        || s.startsWith("smb:/")
-        || s.startsWith("ssh:/");
+        || s.startsWith(SMB_URI_PREFIX)
+        || s.startsWith(SSH_URI_PREFIX);
   }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/LoadFilesListTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/LoadFilesListTask.java
index 9240456ce..ab8b1b0c9 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/LoadFilesListTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/LoadFilesListTask.java
@@ -169,26 +169,21 @@ public class LoadFilesListTask
         }
         break;
       case SFTP:
-        HybridFile sftpHFile = new HybridFile(OpenMode.SFTP, path);
-        ArrayList<LayoutElementParcelable> sftpCache = mainActivityViewModel.getFromListCache(path);
-        if (sftpCache != null) {
-          list = sftpCache;
-        } else {
-          list = new ArrayList();
-          sftpHFile.forEachChildrenFile(
-              context,
-              false,
-              file -> {
-                if (!(dataUtils.isFileHidden(file.getPath())
-                    || file.isHidden() && !showHiddenFiles)) {
-                  LayoutElementParcelable elem = createListParcelables(file);
-                  if (elem != null) {
-                    list.add(elem);
-                  }
+      case FTP:
+        HybridFile ftpHFile = new HybridFile(openmode, path);
+        list = new ArrayList<>();
+        ftpHFile.forEachChildrenFile(
+            context,
+            false,
+            file -> {
+              if (!(dataUtils.isFileHidden(file.getPath())
+                  || file.isHidden() && !showHiddenFiles)) {
+                LayoutElementParcelable elem = createListParcelables(file);
+                if (elem != null) {
+                  list.add(elem);
                 }
-              });
-          mainActivityViewModel.putInCache(path, list);
-        }
+              }
+            });
         break;
       case CUSTOM:
         list = getCachedMediaList(mainActivityViewModel);
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ftp/AbstractGetHostInfoTask.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ftp/AbstractGetHostInfoTask.kt
new file mode 100644
index 000000000..26404fa7e
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ftp/AbstractGetHostInfoTask.kt
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.asynchronous.asynctasks.ftp
+
+import android.app.ProgressDialog
+import android.widget.Toast
+import androidx.annotation.MainThread
+import com.amaze.filemanager.R
+import com.amaze.filemanager.application.AppConfig
+import com.amaze.filemanager.asynchronous.asynctasks.Task
+import java.util.concurrent.Callable
+
+abstract class AbstractGetHostInfoTask<V, T : Callable<V>>(
+    private val hostname: String,
+    private val port: Int,
+    private val callback: (V) -> Unit
+) : Task<V, T> {
+
+    private lateinit var progressDialog: ProgressDialog
+
+    /**
+     * Routine to run before passing control to worker thread, usually for UI related operations.
+     */
+    @MainThread
+    open fun onPreExecute() {
+        AppConfig.getInstance().run {
+            progressDialog = ProgressDialog.show(
+                this.mainActivityContext,
+                "",
+                this.resources.getString(R.string.processing)
+            )
+        }
+    }
+
+    @MainThread
+    override fun onError(error: Throwable) {
+        progressDialog.dismiss()
+        Toast.makeText(
+            AppConfig.getInstance(),
+            AppConfig.getInstance()
+                .resources
+                .getString(
+                    R.string.ssh_connect_failed,
+                    hostname,
+                    port,
+                    error.localizedMessage
+                ),
+            Toast.LENGTH_LONG
+        ).show()
+    }
+
+    @MainThread
+    override fun onFinish(value: V) {
+        callback(value)
+        progressDialog.dismiss()
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ftp/auth/FtpAuthenticationTask.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ftp/auth/FtpAuthenticationTask.kt
new file mode 100644
index 000000000..d9132a042
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ftp/auth/FtpAuthenticationTask.kt
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.asynchronous.asynctasks.ftp.auth
+
+import androidx.annotation.MainThread
+import com.amaze.filemanager.R
+import com.amaze.filemanager.application.AppConfig
+import com.amaze.filemanager.asynchronous.asynctasks.Task
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.FTP_URI_PREFIX
+import org.apache.commons.net.ftp.FTPClient
+import org.json.JSONObject
+import java.net.ConnectException
+import java.net.SocketException
+import java.net.SocketTimeoutException
+
+class FtpAuthenticationTask(
+    private val protocol: String,
+    private val host: String,
+    private val port: Int,
+    private val certInfo: JSONObject?,
+    private val username: String,
+    private val password: String?
+) : Task<FTPClient, FtpAuthenticationTaskCallable> {
+
+    override fun getTask(): FtpAuthenticationTaskCallable {
+        return if (protocol == FTP_URI_PREFIX) {
+            FtpAuthenticationTaskCallable(
+                host,
+                port,
+                username,
+                password ?: ""
+            )
+        } else {
+            FtpsAuthenticationTaskCallable(
+                host,
+                port,
+                certInfo!!,
+                username,
+                password ?: ""
+            )
+        }
+    }
+
+    @MainThread
+    override fun onError(error: Throwable) {
+        if (error is SocketException || error is SocketTimeoutException || error is ConnectException
+        ) {
+            AppConfig.toast(
+                AppConfig.getInstance(),
+                AppConfig.getInstance()
+                    .resources
+                    .getString(
+                        R.string.ssh_connect_failed,
+                        host,
+                        port,
+                        error.localizedMessage ?: error.message
+                    )
+            )
+        }
+    }
+
+    @MainThread
+    override fun onFinish(value: FTPClient) {
+        android.util.Log.d("TEST", value.toString())
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ftp/auth/FtpAuthenticationTaskCallable.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ftp/auth/FtpAuthenticationTaskCallable.kt
new file mode 100644
index 000000000..303291287
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ftp/auth/FtpAuthenticationTaskCallable.kt
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.asynchronous.asynctasks.ftp.auth
+
+import androidx.annotation.WorkerThread
+import com.amaze.filemanager.filesystem.ftp.FTPClientImpl
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.CONNECT_TIMEOUT
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.FTP_URI_PREFIX
+import net.schmizz.sshj.userauth.UserAuthException
+import org.apache.commons.net.ftp.FTPClient
+import java.util.concurrent.Callable
+
+open class FtpAuthenticationTaskCallable(
+    protected val hostname: String,
+    protected val port: Int,
+    protected val username: String,
+    protected val password: String
+) : Callable<FTPClient> {
+
+    @WorkerThread
+    override fun call(): FTPClient {
+        val ftpClient = createFTPClient()
+        ftpClient.connectTimeout = CONNECT_TIMEOUT
+        ftpClient.controlEncoding = Charsets.UTF_8.name()
+        ftpClient.connect(hostname, port)
+        val loginSuccess = if (username.isBlank() && password.isBlank()) {
+            ftpClient.login(
+                FTPClientImpl.ANONYMOUS,
+                FTPClientImpl.generateRandomEmailAddressForLogin()
+            )
+        } else {
+            ftpClient.login(username, password)
+        }
+        return if (loginSuccess) {
+            ftpClient.enterLocalPassiveMode()
+            ftpClient
+        } else {
+            throw UserAuthException("Login failed")
+        }
+    }
+
+    protected open fun createFTPClient(): FTPClient =
+        NetCopyClientConnectionPool.ftpClientFactory.create(FTP_URI_PREFIX)
+}
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ftp/auth/FtpsAuthenticationTaskCallable.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ftp/auth/FtpsAuthenticationTaskCallable.kt
new file mode 100644
index 000000000..206edcdff
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ftp/auth/FtpsAuthenticationTaskCallable.kt
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.asynchronous.asynctasks.ftp.auth
+
+import com.amaze.filemanager.filesystem.ftp.FTPClientImpl
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.FTPS_URI_PREFIX
+import com.amaze.filemanager.utils.X509CertificateUtil
+import com.amaze.filemanager.utils.X509CertificateUtil.FINGERPRINT
+import net.schmizz.sshj.userauth.UserAuthException
+import org.apache.commons.net.ftp.FTPClient
+import org.apache.commons.net.ftp.FTPSClient
+import org.json.JSONObject
+import javax.net.ssl.HostnameVerifier
+
+class FtpsAuthenticationTaskCallable(
+    hostname: String,
+    port: Int,
+    private val certInfo: JSONObject,
+    username: String,
+    password: String
+) : FtpAuthenticationTaskCallable(hostname, port, username, password) {
+
+    override fun call(): FTPClient {
+        val ftpClient = createFTPClient() as FTPSClient
+        ftpClient.connectTimeout = NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        ftpClient.controlEncoding = Charsets.UTF_8.name()
+        ftpClient.connect(hostname, port)
+        val loginSuccess = if (username.isBlank() && password.isBlank()) {
+            ftpClient.login(
+                FTPClientImpl.ANONYMOUS,
+                FTPClientImpl.generateRandomEmailAddressForLogin()
+            )
+        } else {
+            ftpClient.login(username, password)
+        }
+        return if (loginSuccess) {
+            // RFC 2228 set protection buffer size to 0
+            ftpClient.execPBSZ(0)
+            // RFC 2228 set data protection level to PRIVATE
+            ftpClient.execPROT("P")
+            ftpClient.enterLocalPassiveMode()
+            ftpClient
+        } else {
+            throw UserAuthException("Login failed")
+        }
+    }
+
+    @Suppress("LabeledExpression")
+    override fun createFTPClient(): FTPClient {
+        return (
+            NetCopyClientConnectionPool.ftpClientFactory.create(FTPS_URI_PREFIX)
+                as FTPSClient
+            ).apply {
+            this.hostnameVerifier = HostnameVerifier { _, session ->
+                return@HostnameVerifier if (session.peerCertificateChain.isNotEmpty()) {
+                    X509CertificateUtil.parse(
+                        session.peerCertificateChain.first()
+                    )[FINGERPRINT] == certInfo.get(FINGERPRINT)
+                } else {
+                    false
+                }
+            }
+        }
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ftp/hostcert/FtpsGetHostCertificateTask.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ftp/hostcert/FtpsGetHostCertificateTask.kt
new file mode 100644
index 000000000..2fa37674f
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ftp/hostcert/FtpsGetHostCertificateTask.kt
@@ -0,0 +1,39 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.asynchronous.asynctasks.ftp.hostcert
+
+import android.content.Context
+import com.amaze.filemanager.asynchronous.asynctasks.ftp.AbstractGetHostInfoTask
+import org.json.JSONObject
+import java.lang.ref.WeakReference
+
+class FtpsGetHostCertificateTask(
+    private val host: String,
+    private val port: Int,
+    context: Context,
+    callback: (JSONObject) -> Unit
+) : AbstractGetHostInfoTask<JSONObject, FtpsGetHostCertificateTaskCallable>(host, port, callback) {
+
+    val ctx: WeakReference<Context> = WeakReference(context)
+
+    override fun getTask(): FtpsGetHostCertificateTaskCallable =
+        FtpsGetHostCertificateTaskCallable(host, port)
+}
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ftp/hostcert/FtpsGetHostCertificateTaskCallable.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ftp/hostcert/FtpsGetHostCertificateTaskCallable.kt
new file mode 100644
index 000000000..0cc7c476c
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ftp/hostcert/FtpsGetHostCertificateTaskCallable.kt
@@ -0,0 +1,62 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.asynchronous.asynctasks.ftp.hostcert
+
+import androidx.annotation.WorkerThread
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.CONNECT_TIMEOUT
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.FTPS_URI_PREFIX
+import com.amaze.filemanager.utils.X509CertificateUtil
+import org.apache.commons.net.ftp.FTPSClient
+import org.json.JSONObject
+import java.util.concurrent.Callable
+import java.util.concurrent.CountDownLatch
+import javax.net.ssl.HostnameVerifier
+
+open class FtpsGetHostCertificateTaskCallable(
+    private val hostname: String,
+    private val port: Int
+) : Callable<JSONObject> {
+
+    @WorkerThread
+    override fun call(): JSONObject? {
+        val latch = CountDownLatch(1)
+        var result: JSONObject? = null
+        val ftpClient = createFTPClient()
+        ftpClient.connectTimeout = CONNECT_TIMEOUT
+        ftpClient.controlEncoding = Charsets.UTF_8.name()
+        ftpClient.hostnameVerifier = HostnameVerifier { _, session ->
+            if (session.peerCertificateChain.isNotEmpty()) {
+                val certinfo = X509CertificateUtil.parse(session.peerCertificateChain[0])
+                result = JSONObject(certinfo)
+            }
+            latch.countDown()
+            true
+        }
+        ftpClient.connect(hostname, port)
+        latch.await()
+        ftpClient.disconnect()
+        return result
+    }
+
+    protected open fun createFTPClient(): FTPSClient =
+        NetCopyClientConnectionPool.ftpClientFactory.create(FTPS_URI_PREFIX) as FTPSClient
+}
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/hashcalculator/CalculateHashSftpCallback.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/hashcalculator/CalculateHashSftpCallback.java
index b64e0826a..2430e7359 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/hashcalculator/CalculateHashSftpCallback.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/hashcalculator/CalculateHashSftpCallback.java
@@ -25,6 +25,7 @@ import java.util.Objects;
 import java.util.concurrent.Callable;
 
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientUtils;
 import com.amaze.filemanager.filesystem.ssh.SshClientSessionTemplate;
 import com.amaze.filemanager.filesystem.ssh.SshClientUtils;
 
@@ -63,7 +64,7 @@ public class CalculateHashSftpCallback implements Callable<Hash> {
     return new SshClientSessionTemplate<String>(file.getPath()) {
       @Override
       public String execute(Session session) throws IOException {
-        String path = SshClientUtils.extractRemotePathFrom(file.getPath());
+        String path = NetCopyClientUtils.INSTANCE.extractRemotePathFrom(file.getPath());
         String fullCommand = String.format(command, path);
         Session.Command cmd = session.exec(fullCommand);
         String result = new String(IOUtils.readFully(cmd.getInputStream()).toByteArray());
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/hashcalculator/CalculateHashTask.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/hashcalculator/CalculateHashTask.kt
index 8777392b3..486c2cfac 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/hashcalculator/CalculateHashTask.kt
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/hashcalculator/CalculateHashTask.kt
@@ -47,6 +47,9 @@ class CalculateHashTask(
 
     private val task: Callable<Hash> = if (file.isSftp) {
         CalculateHashSftpCallback(file)
+    } else if (file.isFtp) {
+        // Don't do this. Especially when FTPClient requires thread safety.
+        DoNothingCalculateHashCallback()
     } else {
         CalculateHashCallback(file, context)
     }
@@ -72,8 +75,8 @@ class CalculateHashTask(
         val view = view.get()
         view ?: return
 
-        val md5Text = hashes?.md5 ?: context.getString(R.string.error)
-        val shaText = hashes?.sha ?: context.getString(R.string.error)
+        val md5Text = hashes?.md5 ?: context.getString(R.string.unavailable)
+        val shaText = hashes?.sha ?: context.getString(R.string.unavailable)
 
         val md5HashText = view.findViewById<TextView>(R.id.t9)
         val sha256Text = view.findViewById<TextView>(R.id.t10)
diff --git a/app/src/main/java/com/amaze/filemanager/database/typeconverters/OpenModeTypeConverter.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/hashcalculator/DoNothingCalculateHashCallback.kt
similarity index 60%
rename from app/src/main/java/com/amaze/filemanager/database/typeconverters/OpenModeTypeConverter.java
rename to app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/hashcalculator/DoNothingCalculateHashCallback.kt
index cf6e923b3..1c5b19b6d 100644
--- a/app/src/main/java/com/amaze/filemanager/database/typeconverters/OpenModeTypeConverter.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/hashcalculator/DoNothingCalculateHashCallback.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
  * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
  * This file is part of Amaze File Manager.
@@ -18,22 +18,13 @@
  * along with this program.  If not, see <http://www.gnu.org/licenses/>.
  */
 
-package com.amaze.filemanager.database.typeconverters;
+package com.amaze.filemanager.asynchronous.asynctasks.hashcalculator
 
-import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
+import java.util.concurrent.Callable
 
-import androidx.room.TypeConverter;
-
-/** {@link TypeConverter} for {@link OpenMode} objects to database columns. */
-public class OpenModeTypeConverter {
-
-  @TypeConverter
-  public static int fromOpenMode(OpenMode from) {
-    return from.ordinal();
-  }
-
-  @TypeConverter
-  public static OpenMode fromDatabaseValue(int from) {
-    return OpenMode.getOpenMode(from);
-  }
+/**
+ * A do-nothing callback that will not perform calculations on file hashes.
+ */
+class DoNothingCalculateHashCallback : Callable<Hash> {
+    override fun call(): Hash = Hash("", "")
 }
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/GetSshHostFingerprintTask.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/GetSshHostFingerprintTask.kt
index 5e9e4b93e..8f7880382 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/GetSshHostFingerprintTask.kt
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/GetSshHostFingerprintTask.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014-2021 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
  * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
  * This file is part of Amaze File Manager.
@@ -20,121 +20,20 @@
 
 package com.amaze.filemanager.asynchronous.asynctasks.ssh
 
-import android.app.ProgressDialog
-import android.os.AsyncTask
-import android.util.Log
-import android.widget.Toast
-import com.amaze.filemanager.R
-import com.amaze.filemanager.application.AppConfig
-import com.amaze.filemanager.asynchronous.asynctasks.AsyncTaskResult
-import com.amaze.filemanager.filesystem.ssh.CustomSshJConfig
-import com.amaze.filemanager.filesystem.ssh.SshClientUtils
-import com.amaze.filemanager.filesystem.ssh.SshConnectionPool
-import com.amaze.filemanager.filesystem.ssh.SshConnectionPool.SSH_CONNECT_TIMEOUT
-import net.schmizz.sshj.SSHClient
-import net.schmizz.sshj.transport.verification.HostKeyVerifier
-import java.net.SocketException
-import java.net.SocketTimeoutException
+import com.amaze.filemanager.asynchronous.asynctasks.ftp.AbstractGetHostInfoTask
 import java.security.PublicKey
-import java.util.Collections
-import java.util.concurrent.CountDownLatch
-import java.util.concurrent.atomic.AtomicReference
 
-/**
- * [AsyncTask] to obtain SSH host fingerprint.
- *
- *
- * It works by adding a [HostKeyVerifier] that accepts all SSH host keys, then obtain the
- * key shown by server, and return to the task's caller.
- *
- *
- * [CountDownLatch] with [AtomicReference] combo is used to ensure SSH host key is
- * obtained successfully on returning to the task caller.
- *
- *
- * Mainly used by [com.amaze.filemanager.ui.dialogs.SftpConnectDialog] on saving SSH
- * connection settings.
- *
- * @see HostKeyVerifier
- *
- * @see SSHClient.addHostKeyVerifier
- * @see com.amaze.filemanager.ui.dialogs.SftpConnectDialog.onCreateDialog
- */
 class GetSshHostFingerprintTask(
     private val hostname: String,
     private val port: Int,
-    private val callback: AsyncTaskResult.Callback<AsyncTaskResult<PublicKey>>
-) :
-    AsyncTask<Void, Void, AsyncTaskResult<PublicKey>>() {
-    private var progressDialog: ProgressDialog? = null
-
-    override fun doInBackground(vararg params: Void): AsyncTaskResult<PublicKey> {
-        val holder = AtomicReference<AsyncTaskResult<PublicKey>>()
-        val latch = CountDownLatch(1)
-        val sshClient = SshConnectionPool.sshClientFactory.create(CustomSshJConfig()).also {
-            it.connectTimeout = SSH_CONNECT_TIMEOUT
-            it.addHostKeyVerifier(object : HostKeyVerifier {
-                override fun verify(hostname: String?, port: Int, key: PublicKey?): Boolean {
-                    holder.set(AsyncTaskResult(key))
-                    latch.countDown()
-                    return true
-                }
-
-                override fun findExistingAlgorithms(
-                    hostname: String?,
-                    port: Int
-                ): MutableList<String> = Collections.emptyList()
-            })
-        }
-        return runCatching {
-            sshClient.connect(hostname, port)
-            latch.await()
-            holder.get()
-        }.onFailure {
-            Log.e(TAG, "Unable to connect to [$hostname:$port]", it)
-            latch.countDown()
-        }.getOrElse {
-            holder.set(AsyncTaskResult(it))
-            holder.get()
-        }.also {
-            SshClientUtils.tryDisconnect(sshClient)
-        }
-    }
-
-    override fun onPreExecute() {
-        progressDialog = ProgressDialog.show(
-            AppConfig.getInstance().mainActivityContext,
-            "",
-            AppConfig.getInstance().resources.getString(R.string.processing)
-        )
-    }
-
-    override fun onPostExecute(result: AsyncTaskResult<PublicKey>) {
-        progressDialog!!.dismiss()
-        if (result.exception != null) {
-            if (SocketException::class.java.isAssignableFrom(result.exception.javaClass) ||
-                SocketTimeoutException::class.java
-                    .isAssignableFrom(result.exception.javaClass)
-            ) {
-                Toast.makeText(
-                    AppConfig.getInstance(),
-                    AppConfig.getInstance()
-                        .resources
-                        .getString(
-                            R.string.ssh_connect_failed,
-                            hostname,
-                            port,
-                            result.exception.localizedMessage
-                        ),
-                    Toast.LENGTH_LONG
-                ).show()
-            }
-        } else {
-            callback.onResult(result)
-        }
-    }
-
-    companion object {
-        private val TAG = GetSshHostFingerprintTask::class.java.simpleName
-    }
+    private val firstContact: Boolean,
+    callback: (PublicKey) -> Unit
+) : AbstractGetHostInfoTask<PublicKey, GetSshHostFingerprintTaskCallable>(
+    hostname,
+    port,
+    callback
+) {
+
+    override fun getTask(): GetSshHostFingerprintTaskCallable =
+        GetSshHostFingerprintTaskCallable(hostname, port, firstContact)
 }
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/GetSshHostFingerprintTaskCallable.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/GetSshHostFingerprintTaskCallable.kt
new file mode 100644
index 000000000..f2b6a806d
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/GetSshHostFingerprintTaskCallable.kt
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.asynchronous.asynctasks.ssh
+
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool
+import com.amaze.filemanager.filesystem.ssh.CustomSshJConfig
+import com.amaze.filemanager.filesystem.ssh.SshClientUtils
+import net.schmizz.sshj.transport.verification.HostKeyVerifier
+import org.slf4j.Logger
+import org.slf4j.LoggerFactory
+import java.security.PublicKey
+import java.util.*
+import java.util.concurrent.Callable
+import java.util.concurrent.CountDownLatch
+
+class GetSshHostFingerprintTaskCallable(
+    private val hostname: String,
+    private val port: Int,
+    private val firstContact: Boolean = false
+) : Callable<PublicKey> {
+
+    companion object {
+        @JvmStatic
+        private val logger: Logger = LoggerFactory.getLogger(
+            GetSshHostFingerprintTaskCallable::class.java
+        )
+    }
+
+    override fun call(): PublicKey {
+        var holder: PublicKey? = null
+        val latch = CountDownLatch(1)
+        val sshClient = NetCopyClientConnectionPool.sshClientFactory
+            .create(CustomSshJConfig()).also {
+                it.connectTimeout = NetCopyClientConnectionPool.CONNECT_TIMEOUT
+                it.addHostKeyVerifier(object : HostKeyVerifier {
+                    override fun verify(hostname: String?, port: Int, key: PublicKey?): Boolean {
+                        holder = key
+                        latch.countDown()
+                        return true
+                    }
+                    override fun findExistingAlgorithms(
+                        hostname: String?,
+                        port: Int
+                    ): MutableList<String> = Collections.emptyList()
+                })
+            }
+        return runCatching {
+            sshClient.connect(hostname, port)
+            latch.await()
+            holder!!
+        }.onFailure {
+            if (!firstContact) {
+                logger.error("Unable to connect to [$hostname:$port]", it)
+            }
+            latch.countDown()
+        }.getOrThrow().also {
+            SshClientUtils.tryDisconnect(sshClient)
+        }
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/PemToKeyPairTask.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/PemToKeyPairTask.kt
index 88edc470e..aa15cc986 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/PemToKeyPairTask.kt
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/PemToKeyPairTask.kt
@@ -62,7 +62,7 @@ import java.security.KeyPair
  *
  * @see PuTTYKeyFile
  *
- * @see com.amaze.filemanager.filesystem.ssh.SshConnectionPool.create
+ * @see com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.create
  * @see net.schmizz.sshj.SSHClient.authPublickey
  */
 class PemToKeyPairTask(
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/SshAuthenticationTask.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/SshAuthenticationTask.kt
index 09290172a..d99296328 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/SshAuthenticationTask.kt
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/SshAuthenticationTask.kt
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014-2021 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
  * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
  *
  * This file is part of Amaze File Manager.
@@ -21,145 +21,75 @@
 package com.amaze.filemanager.asynchronous.asynctasks.ssh
 
 import android.app.AlertDialog
-import android.os.AsyncTask
-import android.widget.Toast
+import androidx.annotation.MainThread
 import com.amaze.filemanager.R
 import com.amaze.filemanager.application.AppConfig
-import com.amaze.filemanager.asynchronous.asynctasks.AsyncTaskResult
-import com.amaze.filemanager.filesystem.ssh.CustomSshJConfig
-import com.amaze.filemanager.filesystem.ssh.SshConnectionPool
-import com.amaze.filemanager.filesystem.ssh.SshConnectionPool.SSH_CONNECT_TIMEOUT
+import com.amaze.filemanager.asynchronous.asynctasks.Task
 import net.schmizz.sshj.SSHClient
 import net.schmizz.sshj.common.DisconnectReason
-import net.schmizz.sshj.common.KeyType
 import net.schmizz.sshj.transport.TransportException
-import net.schmizz.sshj.userauth.keyprovider.KeyProvider
-import org.slf4j.Logger
-import org.slf4j.LoggerFactory
+import java.net.ConnectException
 import java.net.SocketException
 import java.net.SocketTimeoutException
 import java.security.KeyPair
-import java.security.PrivateKey
-import java.security.PublicKey
 
-/**
- * [AsyncTask] for authenticating with SSH server to verify if parameters are correct.
- *
- *
- * Used by [com.amaze.filemanager.ui.dialogs.SftpConnectDialog].
- *
- * @see SSHClient
- *
- * @see SSHClient.authPassword
- * @see SSHClient.authPublickey
- * @see com.amaze.filemanager.ui.dialogs.SftpConnectDialog.authenticateAndSaveSetup
- * @see com.amaze.filemanager.filesystem.ssh.SshConnectionPool.create
- */
 class SshAuthenticationTask(
-    /**
-     * Constructor.
-     *
-     * @param hostname hostname, required
-     * @param port port, must be unsigned integer
-     * @param hostKey SSH host fingerprint, required
-     * @param username login username, required
-     * @param password login password, required if using password authentication
-     * @param privateKey login [KeyPair], required if using key-based authentication
-     */
     private val hostname: String,
     private val port: Int,
     private val hostKey: String,
     private val username: String,
     private val password: String? = null,
     private val privateKey: KeyPair? = null
-) : AsyncTask<Void, Void, AsyncTaskResult<SSHClient>>() {
-
-    private val log: Logger = LoggerFactory.getLogger(SshAuthenticationTask::class.java)
-
-    override fun doInBackground(vararg params: Void): AsyncTaskResult<SSHClient> {
-        val sshClient = SshConnectionPool.sshClientFactory.create(CustomSshJConfig()).also {
-            it.addHostKeyVerifier(hostKey)
-            it.connectTimeout = SSH_CONNECT_TIMEOUT
-        }
-        return runCatching {
-            sshClient.connect(hostname, port)
-            if (true == password?.isNotEmpty()) {
-                sshClient.authPassword(username, password)
-                AsyncTaskResult(sshClient)
-            } else {
-                sshClient.authPublickey(
-                    username,
-                    object : KeyProvider {
-                        override fun getPrivate(): PrivateKey {
-                            return privateKey!!.private
-                        }
+) : Task<SSHClient, SshAuthenticationTaskCallable> {
 
-                        override fun getPublic(): PublicKey {
-                            return privateKey!!.public
-                        }
+    override fun getTask(): SshAuthenticationTaskCallable =
+        SshAuthenticationTaskCallable(hostname, port, hostKey, username, password, privateKey)
 
-                        override fun getType(): KeyType {
-                            return KeyType.fromKey(public)
-                        }
+    @MainThread
+    override fun onError(error: Throwable) {
+        if (SocketException::class.java.isAssignableFrom(error.javaClass) ||
+            ConnectException::class.java.isAssignableFrom(error.javaClass) ||
+            SocketTimeoutException::class.java
+                .isAssignableFrom(error.javaClass)
+        ) {
+            AppConfig.toast(
+                AppConfig.getInstance(),
+                AppConfig.getInstance()
+                    .resources
+                    .getString(
+                        R.string.ssh_connect_failed,
+                        hostname,
+                        port,
+                        error.localizedMessage ?: error.message
+                    )
+            )
+        } else if (TransportException::class.java
+            .isAssignableFrom(error.javaClass)
+        ) {
+            val disconnectReason =
+                TransportException::class.java.cast(error)!!.disconnectReason
+            if (DisconnectReason.HOST_KEY_NOT_VERIFIABLE == disconnectReason) {
+                AlertDialog.Builder(AppConfig.getInstance().mainActivityContext)
+                    .setTitle(R.string.ssh_connect_failed_host_key_changed_title)
+                    .setMessage(R.string.ssh_connect_failed_host_key_changed_message)
+                    .setPositiveButton(R.string.ok) { dialog, _ ->
+                        dialog.dismiss()
                     }
-                )
-                AsyncTaskResult(sshClient)
-            }
-        }.getOrElse {
-            log.warn("failed to authenticate ssh connection", it)
-            AsyncTaskResult(it)
-        }
-    }
-
-    // If authentication failed, use Toast to notify user.
-    override fun onPostExecute(result: AsyncTaskResult<SSHClient>) {
-        if (result.exception != null) {
-            if (SocketException::class.java.isAssignableFrom(result.exception.javaClass) ||
-                SocketTimeoutException::class.java
-                    .isAssignableFrom(result.exception.javaClass)
-            ) {
-                Toast.makeText(
-                    AppConfig.getInstance(),
-                    AppConfig.getInstance()
-                        .resources
-                        .getString(
-                            R.string.ssh_connect_failed,
-                            hostname,
-                            port,
-                            result.exception.localizedMessage ?: result.exception.message
-                        ),
-                    Toast.LENGTH_LONG
-                )
-                    .show()
-            } else if (TransportException::class.java
-                .isAssignableFrom(result.exception.javaClass)
-            ) {
-                val disconnectReason =
-                    TransportException::class.java.cast(result.exception)!!.disconnectReason
-                if (DisconnectReason.HOST_KEY_NOT_VERIFIABLE == disconnectReason) {
-                    AlertDialog.Builder(AppConfig.getInstance().mainActivityContext)
-                        .setTitle(R.string.ssh_connect_failed_host_key_changed_title)
-                        .setMessage(R.string.ssh_connect_failed_host_key_changed_message)
-                        .setPositiveButton(R.string.ok) { dialog, _ ->
-                            dialog.dismiss()
-                        }
-                        .show()
-                }
-            } else if (password != null) {
-                Toast.makeText(
-                    AppConfig.getInstance(),
-                    R.string.ssh_authentication_failure_password,
-                    Toast.LENGTH_LONG
-                )
-                    .show()
-            } else if (privateKey != null) {
-                Toast.makeText(
-                    AppConfig.getInstance(),
-                    R.string.ssh_authentication_failure_key,
-                    Toast.LENGTH_LONG
-                )
                     .show()
             }
+        } else if (password != null) {
+            AppConfig.toast(
+                AppConfig.getInstance(),
+                R.string.ssh_authentication_failure_password
+            )
+        } else if (privateKey != null) {
+            AppConfig.toast(
+                AppConfig.getInstance(),
+                R.string.ssh_authentication_failure_key
+            )
         }
     }
+
+    @MainThread
+    override fun onFinish(value: SSHClient) = Unit
 }
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/SshAuthenticationTaskCallable.kt b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/SshAuthenticationTaskCallable.kt
new file mode 100644
index 000000000..4d1c15c33
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/SshAuthenticationTaskCallable.kt
@@ -0,0 +1,76 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.asynchronous.asynctasks.ssh
+
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool
+import com.amaze.filemanager.filesystem.ssh.CustomSshJConfig
+import net.schmizz.sshj.SSHClient
+import net.schmizz.sshj.common.KeyType
+import net.schmizz.sshj.userauth.keyprovider.KeyProvider
+import java.security.KeyPair
+import java.security.PrivateKey
+import java.security.PublicKey
+import java.util.concurrent.Callable
+
+class SshAuthenticationTaskCallable(
+    private val hostname: String,
+    private val port: Int,
+    private val hostKey: String,
+    private val username: String,
+    private val password: String? = null,
+    private val privateKey: KeyPair? = null
+) : Callable<SSHClient> {
+
+    init {
+        require(
+            true == password?.isNotEmpty() || privateKey != null
+        ) {
+            "Must provide either password or privateKey"
+        }
+    }
+
+    override fun call(): SSHClient {
+        val sshClient = NetCopyClientConnectionPool.sshClientFactory
+            .create(CustomSshJConfig()).also {
+                it.addHostKeyVerifier(hostKey)
+                it.connectTimeout = NetCopyClientConnectionPool.CONNECT_TIMEOUT
+            }
+        return run {
+            sshClient.connect(hostname, port)
+            if (privateKey != null) {
+                sshClient.authPublickey(
+                    username,
+                    object : KeyProvider {
+                        override fun getPrivate(): PrivateKey = privateKey.private
+
+                        override fun getPublic(): PublicKey = privateKey.public
+
+                        override fun getType(): KeyType = KeyType.fromKey(public)
+                    }
+                )
+                sshClient
+            } else {
+                sshClient.authPassword(username, password)
+                sshClient
+            }
+        }
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
index ccb7c8bf4..9cc5c8de3 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
@@ -405,7 +405,7 @@ public class CopyService extends AbstractProgressiveService {
                 break;
               }
             } catch (Exception e) {
-              LOG.error("Got exception checkout: " + f1.getPath());
+              LOG.error("Got exception checkout: " + f1.getPath(), e);
 
               failedFOps.add(sourceFiles.get(i));
               for (int j = i + 1; j < sourceFiles.size(); j++) failedFOps.add(sourceFiles.get(j));
diff --git a/app/src/main/java/com/amaze/filemanager/database/UtilitiesDatabase.java b/app/src/main/java/com/amaze/filemanager/database/UtilitiesDatabase.java
deleted file mode 100644
index adcb4bd15..000000000
--- a/app/src/main/java/com/amaze/filemanager/database/UtilitiesDatabase.java
+++ /dev/null
@@ -1,400 +0,0 @@
-/*
- * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
- * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
- *
- * This file is part of Amaze File Manager.
- *
- * Amaze File Manager is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.amaze.filemanager.database;
-
-import static com.amaze.filemanager.database.UtilitiesDatabase.DATABASE_VERSION;
-
-import com.amaze.filemanager.database.daos.BookmarkEntryDao;
-import com.amaze.filemanager.database.daos.GridEntryDao;
-import com.amaze.filemanager.database.daos.HiddenEntryDao;
-import com.amaze.filemanager.database.daos.HistoryEntryDao;
-import com.amaze.filemanager.database.daos.ListEntryDao;
-import com.amaze.filemanager.database.daos.SftpEntryDao;
-import com.amaze.filemanager.database.daos.SmbEntryDao;
-import com.amaze.filemanager.database.models.utilities.Bookmark;
-import com.amaze.filemanager.database.models.utilities.Grid;
-import com.amaze.filemanager.database.models.utilities.Hidden;
-import com.amaze.filemanager.database.models.utilities.History;
-import com.amaze.filemanager.database.models.utilities.List;
-import com.amaze.filemanager.database.models.utilities.SftpEntry;
-import com.amaze.filemanager.database.models.utilities.SmbEntry;
-
-import android.content.Context;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.VisibleForTesting;
-import androidx.arch.core.util.Function;
-import androidx.room.Database;
-import androidx.room.Room;
-import androidx.room.RoomDatabase;
-import androidx.room.migration.Migration;
-import androidx.sqlite.db.SupportSQLiteDatabase;
-
-/**
- * Repository for {@link Bookmark}, {@link Grid}, {@link Hidden}, {@link History}, {@link List},
- * {@link SmbEntry}, {@link SftpEntry} objects in utilities.db in Amaze.
- *
- * @see RoomDatabase
- */
-@Database(
-    entities = {
-      Bookmark.class,
-      Grid.class,
-      Hidden.class,
-      History.class,
-      List.class,
-      SmbEntry.class,
-      SftpEntry.class
-    },
-    version = DATABASE_VERSION,
-    exportSchema = false)
-public abstract class UtilitiesDatabase extends RoomDatabase {
-
-  private static final String DATABASE_NAME = "utilities.db";
-  protected static final int DATABASE_VERSION = 5;
-
-  public static final String TABLE_HISTORY = "history";
-  public static final String TABLE_HIDDEN = "hidden";
-  public static final String TABLE_LIST = "list";
-  public static final String TABLE_GRID = "grid";
-  public static final String TABLE_BOOKMARKS = "bookmarks";
-  public static final String TABLE_SMB = "smb";
-  public static final String TABLE_SFTP = "sftp";
-
-  public static final String COLUMN_ID = "_id";
-  public static final String COLUMN_PATH = "path";
-  public static final String COLUMN_NAME = "name";
-  public static final String COLUMN_HOST_PUBKEY = "pub_key";
-  public static final String COLUMN_PRIVATE_KEY_NAME = "ssh_key_name";
-  public static final String COLUMN_PRIVATE_KEY = "ssh_key";
-
-  @VisibleForTesting
-  public static Function<Context, Builder<UtilitiesDatabase>> overrideDatabaseBuilder = null;
-
-  private static final String TEMP_TABLE_PREFIX = "temp_";
-
-  private static final String queryHistory =
-      "CREATE TABLE IF NOT EXISTS "
-          + TABLE_HISTORY
-          + " ("
-          + COLUMN_ID
-          + " INTEGER PRIMARY KEY,"
-          + COLUMN_PATH
-          + " TEXT UNIQUE"
-          + ");";
-
-  private static final String queryHidden =
-      "CREATE TABLE IF NOT EXISTS "
-          + TABLE_HIDDEN
-          + " ("
-          + COLUMN_ID
-          + " INTEGER PRIMARY KEY,"
-          + COLUMN_PATH
-          + " TEXT UNIQUE"
-          + ");";
-
-  private static final String queryList =
-      "CREATE TABLE IF NOT EXISTS "
-          + TABLE_LIST
-          + " ("
-          + COLUMN_ID
-          + " INTEGER PRIMARY KEY,"
-          + COLUMN_PATH
-          + " TEXT UNIQUE"
-          + ");";
-
-  private static final String queryGrid =
-      "CREATE TABLE IF NOT EXISTS "
-          + TABLE_GRID
-          + " ("
-          + COLUMN_ID
-          + " INTEGER PRIMARY KEY,"
-          + COLUMN_PATH
-          + " TEXT UNIQUE"
-          + ");";
-
-  private static final String queryBookmarks =
-      "CREATE TABLE IF NOT EXISTS "
-          + TABLE_BOOKMARKS
-          + " ("
-          + COLUMN_ID
-          + " INTEGER PRIMARY KEY,"
-          + COLUMN_NAME
-          + " TEXT,"
-          + COLUMN_PATH
-          + " TEXT UNIQUE"
-          + ");";
-
-  private static final String querySmb =
-      "CREATE TABLE IF NOT EXISTS "
-          + TABLE_SMB
-          + " ("
-          + COLUMN_ID
-          + " INTEGER PRIMARY KEY,"
-          + COLUMN_NAME
-          + " TEXT,"
-          + COLUMN_PATH
-          + " TEXT UNIQUE"
-          + ");";
-
-  private static final String querySftp =
-      "CREATE TABLE IF NOT EXISTS "
-          + TABLE_SFTP
-          + " ("
-          + COLUMN_ID
-          + " INTEGER PRIMARY KEY,"
-          + COLUMN_NAME
-          + " TEXT,"
-          + COLUMN_PATH
-          + " TEXT UNIQUE,"
-          + COLUMN_HOST_PUBKEY
-          + " TEXT,"
-          + COLUMN_PRIVATE_KEY_NAME
-          + " TEXT,"
-          + COLUMN_PRIVATE_KEY
-          + " TEXT"
-          + ");";
-
-  private static final Migration MIGRATION_1_2 =
-      new Migration(1, 2) {
-        @Override
-        public void migrate(@NonNull SupportSQLiteDatabase database) {
-          database.execSQL(
-              "CREATE TABLE IF NOT EXISTS "
-                  + TABLE_SFTP
-                  + " ("
-                  + COLUMN_ID
-                  + " INTEGER PRIMARY KEY,"
-                  + COLUMN_NAME
-                  + " TEXT,"
-                  + COLUMN_PATH
-                  + " TEXT UNIQUE,"
-                  + COLUMN_HOST_PUBKEY
-                  + " TEXT,"
-                  + COLUMN_PRIVATE_KEY_NAME
-                  + " TEXT,"
-                  + COLUMN_PRIVATE_KEY
-                  + " TEXT"
-                  + ");");
-        }
-      };
-
-  private static final Migration MIGRATION_2_3 =
-      new Migration(2, 3) {
-        @Override
-        public void migrate(@NonNull SupportSQLiteDatabase database) {
-          String backupTable = TEMP_TABLE_PREFIX + TABLE_HISTORY;
-          database.execSQL(queryHistory.replace(TABLE_HISTORY, backupTable));
-          database.execSQL(
-              "INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_HISTORY + " group by path;");
-          database.execSQL("DROP TABLE " + TABLE_HISTORY + ";");
-          database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_HISTORY + ";");
-
-          backupTable = TEMP_TABLE_PREFIX + TABLE_HIDDEN;
-          database.execSQL(queryHidden.replace(TABLE_HIDDEN, backupTable));
-          database.execSQL(
-              "INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_HIDDEN + " group by path;");
-          database.execSQL("DROP TABLE " + TABLE_HIDDEN + ";");
-          database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_HIDDEN + ";");
-
-          backupTable = TEMP_TABLE_PREFIX + TABLE_LIST;
-          database.execSQL(queryList.replace(TABLE_LIST, backupTable));
-          database.execSQL(
-              "INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_LIST + " group by path;");
-          database.execSQL("DROP TABLE " + TABLE_LIST + ";");
-          database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_LIST + ";");
-
-          backupTable = TEMP_TABLE_PREFIX + TABLE_GRID;
-          database.execSQL(queryGrid.replace(TABLE_GRID, backupTable));
-          database.execSQL(
-              "INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_GRID + " group by path;");
-          database.execSQL("DROP TABLE " + TABLE_GRID + ";");
-          database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_GRID + ";");
-
-          backupTable = TEMP_TABLE_PREFIX + TABLE_BOOKMARKS;
-          database.execSQL(queryBookmarks.replace(TABLE_BOOKMARKS, backupTable));
-          database.execSQL(
-              "INSERT INTO "
-                  + backupTable
-                  + " SELECT * FROM "
-                  + TABLE_BOOKMARKS
-                  + " group by path;");
-          database.execSQL("DROP TABLE " + TABLE_BOOKMARKS + ";");
-          database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_BOOKMARKS + ";");
-
-          backupTable = TEMP_TABLE_PREFIX + TABLE_SMB;
-          database.execSQL(querySmb.replace(TABLE_SMB, backupTable));
-          database.execSQL(
-              "INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_SMB + " group by path;");
-          database.execSQL("DROP TABLE " + TABLE_SMB + ";");
-          database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_SMB + ";");
-
-          backupTable = TEMP_TABLE_PREFIX + TABLE_SFTP;
-          database.execSQL(querySftp.replace(TABLE_SFTP, backupTable));
-          database.execSQL(
-              "INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_SFTP + " group by path;");
-          database.execSQL("DROP TABLE " + TABLE_SFTP + ";");
-          database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_SFTP + ";");
-        }
-      };
-
-  private static final Migration MIGRATION_3_4 =
-      new Migration(3, 4) {
-        @Override
-        public void migrate(@NonNull SupportSQLiteDatabase database) {
-          String backupTable = TEMP_TABLE_PREFIX + TABLE_HISTORY;
-          database.execSQL(
-              queryHistory
-                  .replace(TABLE_HISTORY, backupTable)
-                  .replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,"));
-          database.execSQL(
-              "INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_HISTORY + " group by path;");
-          database.execSQL("DROP TABLE " + TABLE_HISTORY + ";");
-          database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_HISTORY + ";");
-
-          backupTable = TEMP_TABLE_PREFIX + TABLE_HIDDEN;
-          database.execSQL(
-              queryHidden
-                  .replace(TABLE_HIDDEN, backupTable)
-                  .replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,"));
-          database.execSQL(
-              "INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_HIDDEN + " group by path;");
-          database.execSQL("DROP TABLE " + TABLE_HIDDEN + ";");
-          database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_HIDDEN + ";");
-
-          backupTable = TEMP_TABLE_PREFIX + TABLE_LIST;
-          database.execSQL(
-              queryList
-                  .replace(TABLE_LIST, backupTable)
-                  .replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,"));
-          database.execSQL(
-              "INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_LIST + " group by path;");
-          database.execSQL("DROP TABLE " + TABLE_LIST + ";");
-          database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_LIST + ";");
-
-          backupTable = TEMP_TABLE_PREFIX + TABLE_GRID;
-          database.execSQL(
-              queryGrid
-                  .replace(TABLE_GRID, backupTable)
-                  .replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,"));
-          database.execSQL(
-              "INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_GRID + " group by path;");
-          database.execSQL("DROP TABLE " + TABLE_GRID + ";");
-          database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_GRID + ";");
-
-          backupTable = TEMP_TABLE_PREFIX + TABLE_BOOKMARKS;
-          database.execSQL(
-              queryBookmarks
-                  .replace(TABLE_BOOKMARKS, backupTable)
-                  .replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,"));
-          database.execSQL(
-              "INSERT INTO "
-                  + backupTable
-                  + " SELECT * FROM "
-                  + TABLE_BOOKMARKS
-                  + " group by path;");
-          database.execSQL("DROP TABLE " + TABLE_BOOKMARKS + ";");
-          database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_BOOKMARKS + ";");
-
-          backupTable = TEMP_TABLE_PREFIX + TABLE_SMB;
-          database.execSQL(
-              querySmb
-                  .replace(TABLE_SMB, backupTable)
-                  .replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,"));
-          database.execSQL(
-              "INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_SMB + " group by path;");
-          database.execSQL("DROP TABLE " + TABLE_SMB + ";");
-          database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_SMB + ";");
-
-          backupTable = TEMP_TABLE_PREFIX + TABLE_SFTP;
-          database.execSQL(
-              querySftp
-                  .replace(TABLE_SFTP, backupTable)
-                  .replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,"));
-          database.execSQL(
-              "INSERT INTO " + backupTable + " SELECT * FROM " + TABLE_SFTP + " group by path;");
-          database.execSQL("DROP TABLE " + TABLE_SFTP + ";");
-          database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_SFTP + ";");
-        }
-      };
-
-  private static final Migration MIGRATION_4_5 =
-      new Migration(4, DATABASE_VERSION) {
-        @Override
-        public void migrate(@NonNull SupportSQLiteDatabase database) {
-          String backupTable = TEMP_TABLE_PREFIX + TABLE_BOOKMARKS;
-          database.execSQL(
-              queryBookmarks
-                  .replace(TABLE_BOOKMARKS, backupTable)
-                  .replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,"));
-          database.execSQL(
-              "INSERT INTO "
-                  + backupTable
-                  + "("
-                  + COLUMN_NAME
-                  + ","
-                  + COLUMN_PATH
-                  + ") SELECT DISTINCT("
-                  + COLUMN_NAME
-                  + "), "
-                  + COLUMN_PATH
-                  + " FROM "
-                  + TABLE_BOOKMARKS);
-          database.execSQL("DROP TABLE " + TABLE_BOOKMARKS + ";");
-          database.execSQL("ALTER TABLE " + backupTable + " RENAME TO " + TABLE_BOOKMARKS + ";");
-
-          database.execSQL(
-              "CREATE UNIQUE INDEX 'bookmarks_idx' ON "
-                  + TABLE_BOOKMARKS
-                  + "("
-                  + COLUMN_NAME
-                  + ", "
-                  + COLUMN_PATH
-                  + ");");
-        }
-      };
-
-  protected abstract HiddenEntryDao hiddenEntryDao();
-
-  protected abstract GridEntryDao gridEntryDao();
-
-  protected abstract ListEntryDao listEntryDao();
-
-  protected abstract HistoryEntryDao historyEntryDao();
-
-  protected abstract BookmarkEntryDao bookmarkEntryDao();
-
-  protected abstract SmbEntryDao smbEntryDao();
-
-  protected abstract SftpEntryDao sftpEntryDao();
-
-  public static UtilitiesDatabase initialize(@NonNull Context context) {
-    Builder<UtilitiesDatabase> builder =
-        (overrideDatabaseBuilder == null)
-            ? Room.databaseBuilder(context, UtilitiesDatabase.class, DATABASE_NAME)
-            : overrideDatabaseBuilder.apply(context);
-
-    return builder
-        .allowMainThreadQueries()
-        .addMigrations(MIGRATION_1_2, MIGRATION_2_3, MIGRATION_3_4, MIGRATION_4_5)
-        .build();
-  }
-}
diff --git a/app/src/main/java/com/amaze/filemanager/database/UtilitiesDatabase.kt b/app/src/main/java/com/amaze/filemanager/database/UtilitiesDatabase.kt
new file mode 100644
index 000000000..82ef29979
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/UtilitiesDatabase.kt
@@ -0,0 +1,506 @@
+/*
+ * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database
+
+import android.content.Context
+import android.text.TextUtils
+import android.util.Base64
+import androidx.annotation.VisibleForTesting
+import androidx.room.Database
+import androidx.room.Room
+import androidx.room.RoomDatabase
+import androidx.room.migration.Migration
+import androidx.sqlite.db.SupportSQLiteDatabase
+import com.amaze.filemanager.application.AppConfig
+import com.amaze.filemanager.database.daos.BookmarkEntryDao
+import com.amaze.filemanager.database.daos.GridEntryDao
+import com.amaze.filemanager.database.daos.HiddenEntryDao
+import com.amaze.filemanager.database.daos.HistoryEntryDao
+import com.amaze.filemanager.database.daos.ListEntryDao
+import com.amaze.filemanager.database.daos.SftpEntryDao
+import com.amaze.filemanager.database.daos.SmbEntryDao
+import com.amaze.filemanager.database.models.utilities.Bookmark
+import com.amaze.filemanager.database.models.utilities.Grid
+import com.amaze.filemanager.database.models.utilities.Hidden
+import com.amaze.filemanager.database.models.utilities.History
+import com.amaze.filemanager.database.models.utilities.SftpEntry
+import com.amaze.filemanager.database.models.utilities.SmbEntry
+import com.amaze.filemanager.utils.PasswordUtil.decryptPassword
+import com.amaze.filemanager.utils.PasswordUtil.encryptPassword
+import org.slf4j.LoggerFactory
+import java.io.IOException
+import java.security.GeneralSecurityException
+
+/**
+ * Repository for [Bookmark], [Grid], [Hidden], [History], [List],
+ * [SmbEntry], [SftpEntry] objects in utilities.db in Amaze.
+ *
+ * @see RoomDatabase
+ */
+@Database(
+    entities = [
+        Bookmark::class,
+        Grid::class,
+        Hidden::class,
+        History::class,
+        com.amaze.filemanager.database.models.utilities.List::class,
+        SmbEntry::class,
+        SftpEntry::class
+    ],
+    version = UtilitiesDatabase.DATABASE_VERSION,
+    exportSchema = false
+)
+@Suppress("StringLiteralDuplication", "ComplexMethod", "LongMethod")
+abstract class UtilitiesDatabase : RoomDatabase() {
+
+    /**
+     * Returns DAO for [Hidden] objects.
+     */
+    abstract fun hiddenEntryDao(): HiddenEntryDao
+
+    /**
+     * Returns DAO for [Grid] objects.
+     */
+    abstract fun gridEntryDao(): GridEntryDao
+
+    /**
+     * Returns DAO for [com.amaze.filemanager.database.models.utilities.List] objects.
+     */
+    abstract fun listEntryDao(): ListEntryDao
+
+    /**
+     * Returns DAO for [History] objects.
+     */
+    abstract fun historyEntryDao(): HistoryEntryDao
+
+    /**
+     * Returns DAO for [Bookmark] objects.
+     */
+    abstract fun bookmarkEntryDao(): BookmarkEntryDao
+
+    /**
+     * Returns DAO for [SmbEntry] objects.
+     */
+    abstract fun smbEntryDao(): SmbEntryDao
+
+    /**
+     * Returns DAO for [SftpEntry] objects.
+     */
+    abstract fun sftpEntryDao(): SftpEntryDao
+
+    companion object {
+        private val logger = LoggerFactory.getLogger(UtilitiesDatabase::class.java)
+        private const val DATABASE_NAME = "utilities.db"
+        const val DATABASE_VERSION = 6
+        const val TABLE_HISTORY = "history"
+        const val TABLE_HIDDEN = "hidden"
+        const val TABLE_LIST = "list"
+        const val TABLE_GRID = "grid"
+        const val TABLE_BOOKMARKS = "bookmarks"
+        const val TABLE_SMB = "smb"
+        const val TABLE_SFTP = "sftp"
+        const val COLUMN_ID = "_id"
+        const val COLUMN_PATH = "path"
+        const val COLUMN_NAME = "name"
+        const val COLUMN_HOST_PUBKEY = "pub_key"
+        const val COLUMN_PRIVATE_KEY_NAME = "ssh_key_name"
+        const val COLUMN_PRIVATE_KEY = "ssh_key"
+
+        @VisibleForTesting
+        var overrideDatabaseBuilder: ((Context) -> RoomDatabase.Builder<UtilitiesDatabase>)? = null
+
+        private const val TEMP_TABLE_PREFIX = "temp_"
+        private const val queryHistory = (
+            "CREATE TABLE IF NOT EXISTS " +
+                TABLE_HISTORY +
+                " (" +
+                COLUMN_ID +
+                " INTEGER PRIMARY KEY," +
+                COLUMN_PATH +
+                " TEXT UNIQUE" +
+                ");"
+            )
+        private const val queryHidden = (
+            "CREATE TABLE IF NOT EXISTS " +
+                TABLE_HIDDEN +
+                " (" +
+                COLUMN_ID +
+                " INTEGER PRIMARY KEY," +
+                COLUMN_PATH +
+                " TEXT UNIQUE" +
+                ");"
+            )
+        private const val queryList = (
+            "CREATE TABLE IF NOT EXISTS " +
+                TABLE_LIST +
+                " (" +
+                COLUMN_ID +
+                " INTEGER PRIMARY KEY," +
+                COLUMN_PATH +
+                " TEXT UNIQUE" +
+                ");"
+            )
+        private const val queryGrid = (
+            "CREATE TABLE IF NOT EXISTS " +
+                TABLE_GRID +
+                " (" +
+                COLUMN_ID +
+                " INTEGER PRIMARY KEY," +
+                COLUMN_PATH +
+                " TEXT UNIQUE" +
+                ");"
+            )
+        private const val queryBookmarks = (
+            "CREATE TABLE IF NOT EXISTS " +
+                TABLE_BOOKMARKS +
+                " (" +
+                COLUMN_ID +
+                " INTEGER PRIMARY KEY," +
+                COLUMN_NAME +
+                " TEXT," +
+                COLUMN_PATH +
+                " TEXT UNIQUE" +
+                ");"
+            )
+        private const val querySmb = (
+            "CREATE TABLE IF NOT EXISTS " +
+                TABLE_SMB +
+                " (" +
+                COLUMN_ID +
+                " INTEGER PRIMARY KEY," +
+                COLUMN_NAME +
+                " TEXT," +
+                COLUMN_PATH +
+                " TEXT UNIQUE" +
+                ");"
+            )
+        private const val querySftp = (
+            "CREATE TABLE IF NOT EXISTS " +
+                TABLE_SFTP +
+                " (" +
+                COLUMN_ID +
+                " INTEGER PRIMARY KEY," +
+                COLUMN_NAME +
+                " TEXT," +
+                COLUMN_PATH +
+                " TEXT UNIQUE," +
+                COLUMN_HOST_PUBKEY +
+                " TEXT," +
+                COLUMN_PRIVATE_KEY_NAME +
+                " TEXT," +
+                COLUMN_PRIVATE_KEY +
+                " TEXT" +
+                ");"
+            )
+
+        internal val MIGRATION_1_2: Migration = object : Migration(1, 2) {
+            override fun migrate(database: SupportSQLiteDatabase) {
+                database.execSQL(
+                    "CREATE TABLE IF NOT EXISTS " +
+                        TABLE_SFTP +
+                        " (" +
+                        COLUMN_ID +
+                        " INTEGER PRIMARY KEY," +
+                        COLUMN_NAME +
+                        " TEXT," +
+                        COLUMN_PATH +
+                        " TEXT UNIQUE," +
+                        COLUMN_HOST_PUBKEY +
+                        " TEXT," +
+                        COLUMN_PRIVATE_KEY_NAME +
+                        " TEXT," +
+                        COLUMN_PRIVATE_KEY +
+                        " TEXT" +
+                        ");"
+                )
+            }
+        }
+
+        internal val MIGRATION_2_3: Migration = object : Migration(2, 3) {
+            override fun migrate(database: SupportSQLiteDatabase) {
+                var backupTable = TEMP_TABLE_PREFIX + TABLE_HISTORY
+                database.execSQL(queryHistory.replace(TABLE_HISTORY, backupTable))
+                database.execSQL(
+                    "INSERT INTO $backupTable SELECT * FROM $TABLE_HISTORY group by path;"
+                )
+                database.execSQL("DROP TABLE $TABLE_HISTORY;")
+                database.execSQL("ALTER TABLE $backupTable RENAME TO $TABLE_HISTORY;")
+                backupTable = TEMP_TABLE_PREFIX + TABLE_HIDDEN
+                database.execSQL(queryHidden.replace(TABLE_HIDDEN, backupTable))
+                database.execSQL(
+                    "INSERT INTO $backupTable SELECT * FROM $TABLE_HIDDEN group by path;"
+                )
+                database.execSQL("DROP TABLE $TABLE_HIDDEN;")
+                database.execSQL("ALTER TABLE $backupTable RENAME TO $TABLE_HIDDEN;")
+                backupTable = TEMP_TABLE_PREFIX + TABLE_LIST
+                database.execSQL(queryList.replace(TABLE_LIST, backupTable))
+                database.execSQL(
+                    "INSERT INTO $backupTable SELECT * FROM $TABLE_LIST group by path;"
+                )
+                database.execSQL("DROP TABLE $TABLE_LIST;")
+                database.execSQL("ALTER TABLE $backupTable RENAME TO $TABLE_LIST;")
+                backupTable = TEMP_TABLE_PREFIX + TABLE_GRID
+                database.execSQL(queryGrid.replace(TABLE_GRID, backupTable))
+                database.execSQL(
+                    "INSERT INTO $backupTable SELECT * FROM $TABLE_GRID group by path;"
+                )
+                database.execSQL("DROP TABLE $TABLE_GRID;")
+                database.execSQL("ALTER TABLE $backupTable RENAME TO $TABLE_GRID;")
+                backupTable = TEMP_TABLE_PREFIX + TABLE_BOOKMARKS
+                database.execSQL(queryBookmarks.replace(TABLE_BOOKMARKS, backupTable))
+                database.execSQL(
+                    "INSERT INTO " +
+                        backupTable +
+                        " SELECT * FROM " +
+                        TABLE_BOOKMARKS +
+                        " group by path;"
+                )
+                database.execSQL("DROP TABLE $TABLE_BOOKMARKS;")
+                database.execSQL("ALTER TABLE $backupTable RENAME TO $TABLE_BOOKMARKS;")
+                backupTable = TEMP_TABLE_PREFIX + TABLE_SMB
+                database.execSQL(querySmb.replace(TABLE_SMB, backupTable))
+                database.execSQL(
+                    "INSERT INTO $backupTable SELECT * FROM $TABLE_SMB group by path;"
+                )
+                database.execSQL("DROP TABLE $TABLE_SMB;")
+                database.execSQL("ALTER TABLE $backupTable RENAME TO $TABLE_SMB;")
+                backupTable = TEMP_TABLE_PREFIX + TABLE_SFTP
+                database.execSQL(querySftp.replace(TABLE_SFTP, backupTable))
+                database.execSQL(
+                    "INSERT INTO $backupTable SELECT * FROM $TABLE_SFTP group by path;"
+                )
+                database.execSQL("DROP TABLE $TABLE_SFTP;")
+                database.execSQL("ALTER TABLE $backupTable RENAME TO $TABLE_SFTP;")
+            }
+        }
+
+        internal val MIGRATION_3_4: Migration = object : Migration(3, 4) {
+            override fun migrate(database: SupportSQLiteDatabase) {
+                var backupTable = TEMP_TABLE_PREFIX + TABLE_HISTORY
+                database.execSQL(
+                    queryHistory
+                        .replace(TABLE_HISTORY, backupTable)
+                        .replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,")
+                )
+                database.execSQL(
+                    "INSERT INTO $backupTable SELECT * FROM $TABLE_HISTORY group by path;"
+                )
+                database.execSQL("DROP TABLE $TABLE_HISTORY;")
+                database.execSQL("ALTER TABLE $backupTable RENAME TO $TABLE_HISTORY;")
+                backupTable = TEMP_TABLE_PREFIX + TABLE_HIDDEN
+                database.execSQL(
+                    queryHidden
+                        .replace(TABLE_HIDDEN, backupTable)
+                        .replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,")
+                )
+                database.execSQL(
+                    "INSERT INTO $backupTable SELECT * FROM $TABLE_HIDDEN group by path;"
+                )
+                database.execSQL("DROP TABLE $TABLE_HIDDEN;")
+                database.execSQL("ALTER TABLE $backupTable RENAME TO $TABLE_HIDDEN;")
+                backupTable = TEMP_TABLE_PREFIX + TABLE_LIST
+                database.execSQL(
+                    queryList
+                        .replace(TABLE_LIST, backupTable)
+                        .replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,")
+                )
+                database.execSQL(
+                    "INSERT INTO $backupTable SELECT * FROM $TABLE_LIST group by path;"
+                )
+                database.execSQL("DROP TABLE $TABLE_LIST;")
+                database.execSQL("ALTER TABLE $backupTable RENAME TO $TABLE_LIST;")
+                backupTable = TEMP_TABLE_PREFIX + TABLE_GRID
+                database.execSQL(
+                    queryGrid
+                        .replace(TABLE_GRID, backupTable)
+                        .replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,")
+                )
+                database.execSQL(
+                    "INSERT INTO $backupTable SELECT * FROM $TABLE_GRID group by path;"
+                )
+                database.execSQL("DROP TABLE $TABLE_GRID;")
+                database.execSQL("ALTER TABLE $backupTable RENAME TO $TABLE_GRID;")
+                backupTable = TEMP_TABLE_PREFIX + TABLE_BOOKMARKS
+                database.execSQL(
+                    queryBookmarks
+                        .replace(TABLE_BOOKMARKS, backupTable)
+                        .replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,")
+                )
+                database.execSQL(
+                    "INSERT INTO " +
+                        backupTable +
+                        " SELECT * FROM " +
+                        TABLE_BOOKMARKS +
+                        " group by path;"
+                )
+                database.execSQL("DROP TABLE $TABLE_BOOKMARKS;")
+                database.execSQL("ALTER TABLE $backupTable RENAME TO $TABLE_BOOKMARKS;")
+                backupTable = TEMP_TABLE_PREFIX + TABLE_SMB
+                database.execSQL(
+                    querySmb
+                        .replace(TABLE_SMB, backupTable)
+                        .replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,")
+                )
+                database.execSQL(
+                    "INSERT INTO $backupTable SELECT * FROM $TABLE_SMB group by path;"
+                )
+                database.execSQL("DROP TABLE $TABLE_SMB;")
+                database.execSQL("ALTER TABLE $backupTable RENAME TO $TABLE_SMB;")
+                backupTable = TEMP_TABLE_PREFIX + TABLE_SFTP
+                database.execSQL(
+                    querySftp
+                        .replace(TABLE_SFTP, backupTable)
+                        .replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,")
+                )
+                database.execSQL(
+                    "INSERT INTO $backupTable SELECT * FROM $TABLE_SFTP group by path;"
+                )
+                database.execSQL("DROP TABLE $TABLE_SFTP;")
+                database.execSQL("ALTER TABLE $backupTable RENAME TO $TABLE_SFTP;")
+            }
+        }
+
+        internal val MIGRATION_4_5: Migration = object : Migration(4, 5) {
+            override fun migrate(database: SupportSQLiteDatabase) {
+                val backupTable = TEMP_TABLE_PREFIX + TABLE_BOOKMARKS
+                database.execSQL(
+                    queryBookmarks
+                        .replace(TABLE_BOOKMARKS, backupTable)
+                        .replace("PRIMARY KEY,", "PRIMARY KEY NOT NULL,")
+                )
+                database.execSQL(
+                    "INSERT INTO " +
+                        backupTable +
+                        "(" +
+                        COLUMN_NAME +
+                        "," +
+                        COLUMN_PATH +
+                        ") SELECT DISTINCT(" +
+                        COLUMN_NAME +
+                        "), " +
+                        COLUMN_PATH +
+                        " FROM " +
+                        TABLE_BOOKMARKS
+                )
+                database.execSQL("DROP TABLE $TABLE_BOOKMARKS;")
+                database.execSQL("ALTER TABLE $backupTable RENAME TO $TABLE_BOOKMARKS;")
+                database.execSQL(
+                    "CREATE UNIQUE INDEX 'bookmarks_idx' ON " +
+                        TABLE_BOOKMARKS +
+                        "(" +
+                        COLUMN_NAME +
+                        ", " +
+                        COLUMN_PATH +
+                        ");"
+                )
+            }
+        }
+
+        private fun migratePasswordInUris(
+            database: SupportSQLiteDatabase,
+            tableName: String
+        ): List<String> {
+            val updateSqls: MutableList<String> = ArrayList()
+            val cursor =
+                database.query("SELECT $COLUMN_NAME, $COLUMN_PATH FROM $tableName")
+            while (cursor.moveToNext()) {
+                val name = cursor.getString(0)
+                val oldPath = cursor.getString(1)
+                val userCredentials =
+                    oldPath.substring(oldPath.indexOf("://") + 3, oldPath.lastIndexOf('@'))
+                if (userCredentials.contains(":")) {
+                    val password = userCredentials.substring(userCredentials.lastIndexOf(':') + 1)
+                    if (!TextUtils.isEmpty(password)) {
+                        try {
+                            val oldPassword = decryptPassword(
+                                AppConfig.getInstance(),
+                                password,
+                                Base64.DEFAULT
+                            )
+                            val newPassword = encryptPassword(
+                                AppConfig.getInstance(),
+                                oldPassword,
+                                Base64.URL_SAFE
+                            )
+                            val newPath = oldPath.replace(password, newPassword!!)
+                            updateSqls.add(
+                                "UPDATE " +
+                                    tableName +
+                                    " SET PATH = '" +
+                                    newPath +
+                                    "' WHERE " +
+                                    COLUMN_NAME +
+                                    "='" +
+                                    name +
+                                    "' AND " +
+                                    COLUMN_PATH +
+                                    "='" +
+                                    oldPath +
+                                    "'"
+                            )
+                        } catch (e: GeneralSecurityException) {
+                            logger.error("Error migrating database records")
+                        } catch (e: IOException) {
+                            logger.error("Error migrating database records")
+                        }
+                    }
+                }
+            }
+            cursor.close()
+            return updateSqls
+        }
+
+        internal val MIGRATION_5_6: Migration = object : Migration(5, DATABASE_VERSION) {
+            override fun migrate(database: SupportSQLiteDatabase) {
+                val updateSqls: MutableList<String> = ArrayList()
+                updateSqls.addAll(migratePasswordInUris(database, TABLE_SMB))
+                updateSqls.addAll(migratePasswordInUris(database, TABLE_SFTP))
+                for (updateSql in updateSqls) {
+                    database.execSQL(updateSql)
+                }
+            }
+        }
+
+        /**
+         * Initialize the database. Optionally, may provide a custom way to create the database
+         * with supplied [Context].
+         */
+        @JvmStatic
+        fun initialize(context: Context): UtilitiesDatabase {
+            val builder: Builder<UtilitiesDatabase> =
+                overrideDatabaseBuilder?.invoke(context) ?: Room.databaseBuilder(
+                    context,
+                    UtilitiesDatabase::class.java,
+                    DATABASE_NAME
+                )
+            return builder
+                .allowMainThreadQueries()
+                .addMigrations(
+                    MIGRATION_1_2,
+                    MIGRATION_2_3,
+                    MIGRATION_3_4,
+                    MIGRATION_4_5,
+                    MIGRATION_5_6
+                )
+                .build()
+        }
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.kt b/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.kt
index c01b9283a..564ff7285 100644
--- a/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.kt
+++ b/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.kt
@@ -193,7 +193,7 @@ class UtilsHandler(
         connectionName: String,
         oldConnectionName: String,
         path: String,
-        hostKey: String,
+        hostKey: String?,
         sshKeyName: String?,
         sshKey: String?
     ) {
@@ -347,16 +347,16 @@ class UtilsHandler(
     /**
      * Returns SSH host key of specified URI.
      */
-    fun getSshHostKey(uri: String): String? =
+    fun getRemoteHostKey(uri: String): String? =
         runCatching {
             utilitiesDatabase
                 .sftpEntryDao()
-                .getSshHostKey(uri)
+                .getRemoteHostKey(uri)
                 .subscribeOn(Schedulers.io())
                 .blockingGet()
         }.onFailure {
             if (BuildConfig.DEBUG) {
-                log.error("Error getting public key for URI [$uri]", it)
+                log.warn("Error getting public key for URI [$uri]", it)
             }
         }.getOrNull()
 
diff --git a/app/src/main/java/com/amaze/filemanager/database/daos/SftpEntryDao.java b/app/src/main/java/com/amaze/filemanager/database/daos/SftpEntryDao.java
index 363fbd340..babf1cca4 100644
--- a/app/src/main/java/com/amaze/filemanager/database/daos/SftpEntryDao.java
+++ b/app/src/main/java/com/amaze/filemanager/database/daos/SftpEntryDao.java
@@ -75,7 +75,7 @@ public interface SftpEntryDao {
 
   @Query(
       "SELECT " + COLUMN_HOST_PUBKEY + " FROM " + TABLE_SFTP + " WHERE " + COLUMN_PATH + " = :uri")
-  Single<String> getSshHostKey(String uri);
+  Single<String> getRemoteHostKey(String uri);
 
   @Query(
       "SELECT "
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/OperationData.java b/app/src/main/java/com/amaze/filemanager/database/models/OperationData.java
index 2cc3bc179..b486238cf 100644
--- a/app/src/main/java/com/amaze/filemanager/database/models/OperationData.java
+++ b/app/src/main/java/com/amaze/filemanager/database/models/OperationData.java
@@ -98,6 +98,7 @@ public class OperationData {
     this.sshKey = sshKey;
   }
 
+  @NonNull
   @Override
   public String toString() {
     StringBuilder sb =
diff --git a/app/src/main/java/com/amaze/filemanager/database/models/utilities/SftpEntry.java b/app/src/main/java/com/amaze/filemanager/database/models/utilities/SftpEntry.java
index e42401fed..964663b85 100644
--- a/app/src/main/java/com/amaze/filemanager/database/models/utilities/SftpEntry.java
+++ b/app/src/main/java/com/amaze/filemanager/database/models/utilities/SftpEntry.java
@@ -24,6 +24,7 @@ import com.amaze.filemanager.database.UtilitiesDatabase;
 
 import android.text.TextUtils;
 
+import androidx.annotation.NonNull;
 import androidx.room.ColumnInfo;
 import androidx.room.Entity;
 
@@ -51,6 +52,7 @@ public class SftpEntry extends OperationDataWithName {
     this.sshKey = sshKey;
   }
 
+  @NonNull
   @Override
   public String toString() {
     StringBuilder sb = new StringBuilder(super.toString());
diff --git a/app/src/main/java/com/amaze/filemanager/database/typeconverters/EncryptedStringTypeConverter.java b/app/src/main/java/com/amaze/filemanager/database/typeconverters/EncryptedStringTypeConverter.java
deleted file mode 100644
index 679c2c8b8..000000000
--- a/app/src/main/java/com/amaze/filemanager/database/typeconverters/EncryptedStringTypeConverter.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
- * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
- *
- * This file is part of Amaze File Manager.
- *
- * Amaze File Manager is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.amaze.filemanager.database.typeconverters;
-
-import com.amaze.filemanager.application.AppConfig;
-import com.amaze.filemanager.database.models.StringWrapper;
-import com.amaze.filemanager.utils.PasswordUtil;
-
-import android.content.Context;
-
-import androidx.room.TypeConverter;
-
-/**
- * {@link TypeConverter} for password strings encrypted by {@link PasswordUtil}.
- *
- * @see StringWrapper
- * @see PasswordUtil#encryptPassword(Context, String)
- * @see PasswordUtil#decryptPassword(Context, String)
- */
-public class EncryptedStringTypeConverter {
-
-  private static final String TAG = EncryptedStringTypeConverter.class.getSimpleName();
-
-  @TypeConverter
-  public static StringWrapper toPassword(String encryptedStringEntryInDb) {
-    try {
-      return new StringWrapper(
-          PasswordUtil.INSTANCE.decryptPassword(AppConfig.getInstance(), encryptedStringEntryInDb));
-    } catch (Exception e) {
-      android.util.Log.e(TAG, "Error decrypting password", e);
-      return new StringWrapper(encryptedStringEntryInDb);
-    }
-  }
-
-  @TypeConverter
-  public static String fromPassword(StringWrapper unencryptedPasswordString) {
-    try {
-      return PasswordUtil.INSTANCE.encryptPassword(
-          AppConfig.getInstance(), unencryptedPasswordString.value);
-    } catch (Exception e) {
-      android.util.Log.e(TAG, "Error encrypting password", e);
-      return unencryptedPasswordString.value;
-    }
-  }
-}
diff --git a/app/src/main/java/com/amaze/filemanager/database/typeconverters/EncryptedStringTypeConverter.kt b/app/src/main/java/com/amaze/filemanager/database/typeconverters/EncryptedStringTypeConverter.kt
new file mode 100644
index 000000000..ccf8bd867
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/typeconverters/EncryptedStringTypeConverter.kt
@@ -0,0 +1,78 @@
+/*
+ * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.typeconverters
+
+import android.util.Log
+import androidx.room.TypeConverter
+import com.amaze.filemanager.application.AppConfig
+import com.amaze.filemanager.database.models.StringWrapper
+import com.amaze.filemanager.utils.PasswordUtil
+import com.amaze.filemanager.utils.PasswordUtil.decryptPassword
+import com.amaze.filemanager.utils.PasswordUtil.encryptPassword
+
+/**
+ * [TypeConverter] for password strings encrypted by [PasswordUtil].
+ *
+ * @see StringWrapper
+ *
+ * @see PasswordUtil.encryptPassword
+ * @see PasswordUtil.decryptPassword
+ */
+object EncryptedStringTypeConverter {
+
+    @JvmStatic
+    private val TAG = EncryptedStringTypeConverter::class.java.simpleName
+
+    /**
+     * Converts value in database to string.
+     */
+    @JvmStatic
+    @TypeConverter
+    fun toPassword(encryptedStringEntryInDb: String): StringWrapper {
+        return runCatching {
+            StringWrapper(
+                decryptPassword(AppConfig.getInstance(), encryptedStringEntryInDb)
+            )
+        }.onFailure {
+            Log.e(TAG, "Error decrypting password", it)
+        }.getOrElse {
+            StringWrapper(encryptedStringEntryInDb)
+        }
+    }
+
+    /**
+     * Encrypt given password in plaintext for storage in database.
+     */
+    @JvmStatic
+    @TypeConverter
+    fun fromPassword(unencryptedPasswordString: StringWrapper): String? {
+        return runCatching {
+            encryptPassword(
+                AppConfig.getInstance(),
+                unencryptedPasswordString.value
+            )
+        }.onFailure {
+            Log.e(TAG, "Error encrypting password", it)
+        }.getOrElse {
+            unencryptedPasswordString.value
+        }
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/database/typeconverters/OpenModeTypeConverter.kt b/app/src/main/java/com/amaze/filemanager/database/typeconverters/OpenModeTypeConverter.kt
new file mode 100644
index 000000000..970cf04a4
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/database/typeconverters/OpenModeTypeConverter.kt
@@ -0,0 +1,46 @@
+/*
+ * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database.typeconverters
+
+import androidx.room.TypeConverter
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
+
+/** [TypeConverter] for [OpenMode] objects to database columns.  */
+object OpenModeTypeConverter {
+
+    /**
+     * Convert given [OpenMode] to integer constant for database storage.
+     */
+    @JvmStatic
+    @TypeConverter
+    fun fromOpenMode(from: OpenMode): Int {
+        return from.ordinal
+    }
+
+    /**
+     * Convert value in database to [OpenMode].
+     */
+    @JvmStatic
+    @TypeConverter
+    fun fromDatabaseValue(from: Int): OpenMode {
+        return OpenMode.getOpenMode(from)
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/FileProperties.kt b/app/src/main/java/com/amaze/filemanager/filesystem/FileProperties.kt
index 3f71cce06..90b4d4df1 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/FileProperties.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/FileProperties.kt
@@ -32,8 +32,8 @@ import com.amaze.filemanager.application.AppConfig
 import com.amaze.filemanager.database.CloudHandler
 import com.amaze.filemanager.filesystem.DeleteOperation.deleteFile
 import com.amaze.filemanager.filesystem.ExternalSdCardOperation.isOnExtSdCard
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool
 import com.amaze.filemanager.filesystem.smb.CifsContexts
-import com.amaze.filemanager.filesystem.ssh.SshConnectionPool
 import com.amaze.filemanager.utils.OTGUtil
 import org.slf4j.Logger
 import org.slf4j.LoggerFactory
@@ -160,7 +160,9 @@ object FileProperties {
     fun checkFolder(f: String?, context: Context): Int {
         if (f == null) return 0
         if (f.startsWith(CifsContexts.SMB_URI_PREFIX) ||
-            f.startsWith(SshConnectionPool.SSH_URI_PREFIX) ||
+            f.startsWith(NetCopyClientConnectionPool.SSH_URI_PREFIX) ||
+            f.startsWith(NetCopyClientConnectionPool.FTP_URI_PREFIX) ||
+            f.startsWith(NetCopyClientConnectionPool.FTPS_URI_PREFIX) ||
             f.startsWith(OTGUtil.PREFIX_OTG) ||
             f.startsWith(CloudHandler.CLOUD_PREFIX_BOX) ||
             f.startsWith(CloudHandler.CLOUD_PREFIX_GOOGLE_DRIVE) ||
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/HybridFile.java b/app/src/main/java/com/amaze/filemanager/filesystem/HybridFile.java
index c0c30aa54..04de8562d 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/HybridFile.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/HybridFile.java
@@ -20,23 +20,35 @@
 
 package com.amaze.filemanager.filesystem;
 
+import static com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.FTPS_URI_PREFIX;
+import static com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.FTP_URI_PREFIX;
+import static com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.SSH_URI_PREFIX;
 import static com.amaze.filemanager.filesystem.smb.CifsContexts.SMB_URI_PREFIX;
-import static com.amaze.filemanager.filesystem.ssh.SshConnectionPool.SSH_URI_PREFIX;
 
 import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileNotFoundException;
+import java.io.FileOutputStream;
 import java.io.IOException;
 import java.io.InputStream;
 import java.io.OutputStream;
+import java.io.UnsupportedEncodingException;
 import java.net.MalformedURLException;
+import java.net.URLDecoder;
 import java.security.MessageDigest;
 import java.security.NoSuchAlgorithmException;
+import java.text.DateFormat;
+import java.text.SimpleDateFormat;
 import java.util.ArrayList;
+import java.util.Calendar;
 import java.util.EnumSet;
+import java.util.Locale;
 import java.util.concurrent.atomic.AtomicLong;
 import java.util.concurrent.atomic.AtomicReference;
 
+import org.apache.commons.net.ftp.FTP;
+import org.apache.commons.net.ftp.FTPClient;
+import org.apache.commons.net.ftp.FTPFile;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -52,13 +64,17 @@ import com.amaze.filemanager.fileoperations.filesystem.root.NativeOperations;
 import com.amaze.filemanager.filesystem.cloud.CloudUtil;
 import com.amaze.filemanager.filesystem.files.FileUtils;
 import com.amaze.filemanager.filesystem.files.GenericCopyUtil;
+import com.amaze.filemanager.filesystem.ftp.ExtensionsKt;
+import com.amaze.filemanager.filesystem.ftp.FTPClientImpl;
+import com.amaze.filemanager.filesystem.ftp.FtpClientTemplate;
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool;
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientUtils;
 import com.amaze.filemanager.filesystem.root.DeleteFileCommand;
 import com.amaze.filemanager.filesystem.root.ListFilesCommand;
 import com.amaze.filemanager.filesystem.ssh.SFtpClientTemplate;
 import com.amaze.filemanager.filesystem.ssh.SshClientSessionTemplate;
 import com.amaze.filemanager.filesystem.ssh.SshClientTemplate;
 import com.amaze.filemanager.filesystem.ssh.SshClientUtils;
-import com.amaze.filemanager.filesystem.ssh.SshConnectionPool;
 import com.amaze.filemanager.filesystem.ssh.Statvfs;
 import com.amaze.filemanager.ui.activities.MainActivity;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
@@ -91,6 +107,7 @@ import io.reactivex.disposables.Disposable;
 import io.reactivex.schedulers.Schedulers;
 import jcifs.smb.SmbException;
 import jcifs.smb.SmbFile;
+import kotlin.io.ByteStreamsKt;
 import net.schmizz.sshj.SSHClient;
 import net.schmizz.sshj.common.Buffer;
 import net.schmizz.sshj.common.IOUtils;
@@ -146,6 +163,8 @@ public class HybridFile {
       mode = OpenMode.SFTP;
     } else if (path.startsWith(OTGUtil.PREFIX_OTG)) {
       mode = OpenMode.OTG;
+    } else if (path.startsWith(FTP_URI_PREFIX) || path.startsWith(FTPS_URI_PREFIX)) {
+      mode = OpenMode.FTP;
     } else if (path.startsWith(DOCUMENT_FILE_PREFIX)) {
       mode = OpenMode.DOCUMENT_FILE;
     } else if (isCustomPath()) {
@@ -217,6 +236,10 @@ public class HybridFile {
     return mode == OpenMode.OTG;
   }
 
+  public boolean isFtp() {
+    return mode == OpenMode.FTP;
+  }
+
   public boolean isDocumentFile() {
     return mode == OpenMode.DOCUMENT_FILE;
   }
@@ -269,11 +292,11 @@ public class HybridFile {
     switch (mode) {
       case SFTP:
         final Long returnValue =
-            SshClientUtils.execute(
-                new SFtpClientTemplate<Long>(path) {
+            NetCopyClientUtils.INSTANCE.execute(
+                new SFtpClientTemplate<Long>(path, false) {
                   @Override
                   public Long execute(@NonNull SFTPClient client) throws IOException {
-                    return client.mtime(SshClientUtils.extractRemotePathFrom(path));
+                    return client.mtime(NetCopyClientUtils.INSTANCE.extractRemotePathFrom(path));
                   }
                 });
 
@@ -293,6 +316,11 @@ public class HybridFile {
           }
         }
         break;
+      case FTP:
+        FTPFile ftpFile = getFtpFile();
+        return ftpFile != null ? ftpFile.getTimestamp().getTimeInMillis() : 0L;
+      case NFS:
+        break;
       case FILE:
         return getFile().lastModified();
       case DOCUMENT_FILE:
@@ -312,11 +340,11 @@ public class HybridFile {
         if (this instanceof HybridFileParcelable) {
           return ((HybridFileParcelable) this).getSize();
         } else {
-          return SshClientUtils.execute(
-              new SFtpClientTemplate<Long>(path) {
+          return NetCopyClientUtils.INSTANCE.execute(
+              new SFtpClientTemplate<Long>(path, false) {
                 @Override
                 public Long execute(@NonNull SFTPClient client) throws IOException {
-                  return client.size(SshClientUtils.extractRemotePathFrom(path));
+                  return client.size(NetCopyClientUtils.INSTANCE.extractRemotePathFrom(path));
                 }
               });
         }
@@ -339,6 +367,11 @@ public class HybridFile {
                 .subscribeOn(Schedulers.io())
                 .blockingGet();
         return s;
+      case FTP:
+        FTPFile ftpFile = getFtpFile();
+        s = ftpFile != null ? ftpFile.getSize() : 0L;
+        return s;
+      case NFS:
       case FILE:
         s = getFile().length();
         return s;
@@ -372,8 +405,17 @@ public class HybridFile {
     return s;
   }
 
+  /**
+   * Path accessor. Avoid direct access to path since path may have been URL encoded.
+   *
+   * @return URL decoded path
+   */
   public String getPath() {
-    return path;
+    try {
+      return URLDecoder.decode(path, "UTF-8");
+    } catch (UnsupportedEncodingException ignored) {
+      return path;
+    }
   }
 
   public String getSimpleName() {
@@ -418,7 +460,11 @@ public class HybridFile {
           return "";
         }
 
-        String _path = path;
+        String _path = null;
+        try {
+          _path = URLDecoder.decode(path, "UTF-8");
+        } catch (UnsupportedEncodingException ignored) {
+        }
         if (path.endsWith("/")) {
           _path = path.substring(0, path.length() - 1);
         }
@@ -449,6 +495,23 @@ public class HybridFile {
     }
   }
 
+  @Nullable
+  public FTPFile getFtpFile() {
+    return NetCopyClientUtils.INSTANCE.execute(
+        new FtpClientTemplate<FTPFile>(path, false) {
+          public FTPFile executeWithFtpClient(@NonNull FTPClient ftpClient) throws IOException {
+            String path =
+                NetCopyClientUtils.INSTANCE.extractRemotePathFrom(
+                    getParent(AppConfig.getInstance()));
+            ftpClient.changeWorkingDirectory(path);
+            for (FTPFile ftpFile : ftpClient.listFiles()) {
+              if (ftpFile.getName().equals(getName(AppConfig.getInstance()))) return ftpFile;
+            }
+            return null;
+          }
+        });
+  }
+
   public boolean isCustomPath() {
     return path.equals("0")
         || path.equals("1")
@@ -473,25 +536,17 @@ public class HybridFile {
         return getFile().getParent();
       case SFTP:
       default:
-        if (path.length() == getName(context).length()) {
+        if (getPath().length() == getName(context).length()) {
           return null;
         }
 
         int start = 0;
-        int end = path.length() - getName(context).length() - 1;
+        int end = getPath().length() - getName(context).length() - 1;
 
-        return path.substring(start, end);
+        return getPath().substring(start, end);
     }
   }
 
-  public String getParentName() {
-    StringBuilder builder = new StringBuilder(path);
-    StringBuilder parentPath =
-        new StringBuilder(builder.substring(0, builder.length() - (getSimpleName().length() + 1)));
-    String parentName = parentPath.substring(parentPath.lastIndexOf("/") + 1, parentPath.length());
-    return parentName;
-  }
-
   /**
    * Whether this object refers to a directory or file, handles all types of files
    *
@@ -501,6 +556,7 @@ public class HybridFile {
     boolean isDirectory;
     switch (mode) {
       case SFTP:
+      case FTP:
         return isDirectory(AppConfig.getInstance());
       case SMB:
         SmbFile smbFile = getSmbFile();
@@ -511,9 +567,6 @@ public class HybridFile {
           isDirectory = false;
         }
         break;
-      case FILE:
-        isDirectory = getFile().isDirectory();
-        break;
       case ROOT:
         isDirectory = NativeOperations.isDirectory(path);
         break;
@@ -524,6 +577,7 @@ public class HybridFile {
         // you need to manually call {@link RootHelper#getDocumentFile() method
         isDirectory = false;
         break;
+      case FILE:
       default:
         isDirectory = getFile().isDirectory();
         break;
@@ -536,13 +590,13 @@ public class HybridFile {
     switch (mode) {
       case SFTP:
         final Boolean returnValue =
-            SshClientUtils.<Boolean>execute(
-                new SFtpClientTemplate<Boolean>(path) {
+            NetCopyClientUtils.INSTANCE.<SSHClient, Boolean>execute(
+                new SFtpClientTemplate<Boolean>(path, false) {
                   @Override
-                  public Boolean execute(SFTPClient client) {
+                  public Boolean execute(@NonNull SFTPClient client) {
                     try {
                       return client
-                          .stat(SshClientUtils.extractRemotePathFrom(path))
+                          .stat(NetCopyClientUtils.INSTANCE.extractRemotePathFrom(path))
                           .getType()
                           .equals(FileMode.Type.DIRECTORY);
                     } catch (IOException notFound) {
@@ -569,6 +623,10 @@ public class HybridFile {
           LOG.warn("failed to get isDirectory with context for smb file", e);
         }
         break;
+      case FTP:
+        FTPFile ftpFile = getFtpFile();
+        isDirectory = ftpFile != null && ftpFile.isDirectory();
+        break;
       case FILE:
         isDirectory = getFile().isDirectory();
         break;
@@ -610,6 +668,7 @@ public class HybridFile {
 
     switch (mode) {
       case SFTP:
+      case FTP:
         return folderSize(AppConfig.getInstance());
       case SMB:
         SmbFile smbFile = getSmbFile();
@@ -631,16 +690,16 @@ public class HybridFile {
   /** Helper method to get length of folder in an otg */
   public long folderSize(Context context) {
 
-    long size = 0l;
+    long size = 0L;
 
     switch (mode) {
       case SFTP:
         final Long returnValue =
-            SshClientUtils.<Long>execute(
-                new SFtpClientTemplate<Long>(path) {
+            NetCopyClientUtils.INSTANCE.<SSHClient, Long>execute(
+                new SFtpClientTemplate<Long>(path, false) {
                   @Override
-                  public Long execute(SFTPClient client) throws IOException {
-                    return client.size(SshClientUtils.extractRemotePathFrom(path));
+                  public Long execute(@NonNull SFTPClient client) throws IOException {
+                    return client.size(NetCopyClientUtils.INSTANCE.extractRemotePathFrom(path));
                   }
                 });
 
@@ -680,6 +739,8 @@ public class HybridFile {
             FileUtils.folderSizeCloud(
                 mode, dataUtils.getAccount(mode).getMetadata(CloudUtil.stripPath(mode, path)));
         break;
+      case FTP:
+
       default:
         return 0l;
     }
@@ -712,8 +773,8 @@ public class HybridFile {
         break;
       case SFTP:
         final Long returnValue =
-            SshClientUtils.<Long>execute(
-                new SFtpClientTemplate<Long>(path) {
+            NetCopyClientUtils.INSTANCE.<SSHClient, Long>execute(
+                new SFtpClientTemplate<Long>(path, false) {
                   @Override
                   public Long execute(@NonNull SFTPClient client) throws IOException {
                     try {
@@ -724,7 +785,8 @@ public class HybridFile {
                                   .getSFTPEngine()
                                   .request(
                                       Statvfs.request(
-                                          client, SshClientUtils.extractRemotePathFrom(path)))
+                                          client,
+                                          NetCopyClientUtils.INSTANCE.extractRemotePathFrom(path)))
                                   .retrieve());
                       return response.diskFreeSpace();
                     } catch (SFTPException e) {
@@ -747,6 +809,23 @@ public class HybridFile {
         size =
             FileProperties.getDeviceStorageRemainingSpace(SafRootHolder.INSTANCE.getVolumeLabel());
         break;
+      case FTP:
+        /*
+         * Quirk, or dirty trick.
+         *
+         * I think 99.9% FTP servers in this world will not report their disk's remaining space,
+         * simply because they are not Serv-U (using AVBL command) or IIS (extended LIST command on
+         * it own). But it doesn't make sense to simply block write to FTP servers either, hence
+         * this value Integer.MAX_VALUE = 2048MB, which should be suitable for 99% of the cases.
+         *
+         * File sizes bigger than this, either Android device (unless TV boxes) would have
+         * difficulty to handle, either client and server side. In that case I shall recommend you
+         * to send it in splits, or just move to better transmission mechanism, like WiFi Direct
+         * as provided by Amaze File Utilities ;)
+         *
+         * - TranceLove
+         */
+        size = Integer.MAX_VALUE;
       case OTG:
         // TODO: Get free space from OTG when {@link DocumentFile} API adds support
         break;
@@ -780,8 +859,8 @@ public class HybridFile {
         break;
       case SFTP:
         final Long returnValue =
-            SshClientUtils.<Long>execute(
-                new SFtpClientTemplate<Long>(path) {
+            NetCopyClientUtils.INSTANCE.<SSHClient, Long>execute(
+                new SFtpClientTemplate<Long>(path, false) {
                   @Override
                   public Long execute(@NonNull SFTPClient client) throws IOException {
                     try {
@@ -792,7 +871,8 @@ public class HybridFile {
                                   .getSFTPEngine()
                                   .request(
                                       Statvfs.request(
-                                          client, SshClientUtils.extractRemotePathFrom(path)))
+                                          client,
+                                          NetCopyClientUtils.INSTANCE.extractRemotePathFrom(path)))
                                   .retrieve());
                       return response.diskSize();
                     } catch (SFTPException e) {
@@ -819,6 +899,8 @@ public class HybridFile {
       case DOCUMENT_FILE:
         size = getDocumentFile(false).length();
         break;
+      case FTP:
+        size = 0L;
     }
     return size;
   }
@@ -827,13 +909,13 @@ public class HybridFile {
   public void forEachChildrenFile(Context context, boolean isRoot, OnFileFound onFileFound) {
     switch (mode) {
       case SFTP:
-        SshClientUtils.<Boolean>execute(
-            new SFtpClientTemplate<Boolean>(path) {
+        NetCopyClientUtils.INSTANCE.<SSHClient, Boolean>execute(
+            new SFtpClientTemplate<Boolean>(path, false) {
               @Override
-              public Boolean execute(SFTPClient client) {
+              public Boolean execute(@NonNull SFTPClient client) {
                 try {
                   for (RemoteResourceInfo info :
-                      client.ls(SshClientUtils.extractRemotePathFrom(path))) {
+                      client.ls(NetCopyClientUtils.INSTANCE.extractRemotePathFrom(path))) {
                     boolean isDirectory = false;
                     try {
                       isDirectory = SshClientUtils.isDirectory(client, info);
@@ -877,6 +959,21 @@ public class HybridFile {
           LOG.warn("failed to get children file for smb file", e);
         }
         break;
+      case FTP:
+        String thisPath = NetCopyClientUtils.INSTANCE.extractRemotePathFrom(path);
+        FTPFile[] ftpFiles =
+            NetCopyClientUtils.INSTANCE.execute(
+                new FtpClientTemplate<FTPFile[]>(path, false) {
+                  public FTPFile[] executeWithFtpClient(@NonNull FTPClient ftpClient)
+                      throws IOException {
+                    ftpClient.changeWorkingDirectory(thisPath);
+                    return ftpClient.listFiles();
+                  }
+                });
+        for (FTPFile ftpFile : ftpFiles) {
+          onFileFound.onFileFound(new HybridFileParcelable(path, ftpFile));
+        }
+        break;
       case OTG:
         OTGUtil.getDocumentFiles(path, context, onFileFound);
         break;
@@ -914,87 +1011,21 @@ public class HybridFile {
    */
   public ArrayList<HybridFileParcelable> listFiles(Context context, boolean isRoot) {
     ArrayList<HybridFileParcelable> arrayList = new ArrayList<>();
-    switch (mode) {
-      case SFTP:
-        arrayList =
-            SshClientUtils.execute(
-                new SFtpClientTemplate<ArrayList<HybridFileParcelable>>(path) {
-                  @Override
-                  public ArrayList<HybridFileParcelable> execute(SFTPClient client) {
-                    ArrayList<HybridFileParcelable> retval = new ArrayList<>();
-                    try {
-                      for (RemoteResourceInfo info :
-                          client.ls(SshClientUtils.extractRemotePathFrom(path))) {
-                        boolean isDirectory = false;
-                        try {
-                          isDirectory = SshClientUtils.isDirectory(client, info);
-                        } catch (IOException ifBrokenSymlink) {
-                          LOG.warn("IOException checking isDirectory(): " + info.getPath());
-                          continue;
-                        }
-                        HybridFileParcelable f = new HybridFileParcelable(path, isDirectory, info);
-                        retval.add(f);
-                      }
-                    } catch (IOException e) {
-                      LOG.warn("IOException", e);
-                    }
-                    return retval;
-                  }
-                });
-        break;
-      case SMB:
-        try {
-          SmbFile smbFile = getSmbFile();
-          if (smbFile != null) {
-            for (SmbFile smbFile1 : smbFile.listFiles()) {
-              HybridFileParcelable baseFile = new HybridFileParcelable(smbFile1);
-              arrayList.add(baseFile);
-            }
-          }
-        } catch (SmbException e) {
-          arrayList.clear();
-          LOG.warn("failed to list files smb file", e);
-        }
-        break;
-      case OTG:
-        arrayList = OTGUtil.getDocumentFilesList(path, context);
-        break;
-      case DOCUMENT_FILE:
-        final ArrayList<HybridFileParcelable> hybridFileParcelables = new ArrayList<>();
-        OTGUtil.getDocumentFiles(
-            SafRootHolder.getUriRoot(),
-            path,
-            context,
-            OpenMode.DOCUMENT_FILE,
-            file -> hybridFileParcelables.add(file));
-        arrayList = hybridFileParcelables;
-        break;
-      case DROPBOX:
-      case BOX:
-      case GDRIVE:
-      case ONEDRIVE:
-        try {
-          arrayList = CloudUtil.listFiles(path, dataUtils.getAccount(mode), mode);
-        } catch (CloudPluginException e) {
-          LOG.warn("failed to list files for cloud file", e);
-          arrayList = new ArrayList<>();
-        }
-        break;
-      default:
-        arrayList = RootHelper.getFilesList(path, isRoot, true);
-    }
-
+    forEachChildrenFile(context, isRoot, arrayList::add);
     return arrayList;
   }
 
   public String getReadablePath(String path) {
-    if (isSftp() || isSmb()) return parseAndFormatUriForDisplay(path);
+    if (isSftp() || isSmb() || isFtp()) return parseAndFormatUriForDisplay(path);
     else return path;
   }
 
   public static String parseAndFormatUriForDisplay(@NonNull String uriString) {
-    if (uriString.startsWith(SSH_URI_PREFIX)) {
-      SshConnectionPool.ConnectionInfo connInfo = new SshConnectionPool.ConnectionInfo(uriString);
+    if (uriString.startsWith(SSH_URI_PREFIX)
+        || uriString.startsWith(FTP_URI_PREFIX)
+        || uriString.startsWith(FTPS_URI_PREFIX)) {
+      NetCopyClientConnectionPool.ConnectionInfo connInfo =
+          new NetCopyClientConnectionPool.ConnectionInfo(uriString);
       return connInfo.toString();
     } else {
       Uri uri = Uri.parse(uriString);
@@ -1008,49 +1039,19 @@ public class HybridFile {
   }
 
   /**
-   * Handles getting input stream for various {@link OpenMode}
-   *
    * @deprecated use {@link #getInputStream(Context)} which allows handling content resolver
    */
   @Nullable
   public InputStream getInputStream() {
-    InputStream inputStream;
-    if (isSftp()) {
-      return SshClientUtils.execute(
-          new SFtpClientTemplate<InputStream>(path) {
-            @Override
-            public InputStream execute(SFTPClient client) throws IOException {
-              final RemoteFile rf = client.open(SshClientUtils.extractRemotePathFrom(path));
-              return rf.new RemoteFileInputStream() {
-                @Override
-                public void close() throws IOException {
-                  try {
-                    super.close();
-                  } finally {
-                    rf.close();
-                  }
-                }
-              };
-            }
-          });
-    } else if (isSmb()) {
-      try {
-        inputStream = getSmbFile().getInputStream();
-      } catch (IOException e) {
-        inputStream = null;
-        LOG.warn("failed to get input stream for smb file", e);
-      }
-    } else {
-      try {
-        inputStream = new FileInputStream(path);
-      } catch (FileNotFoundException e) {
-        inputStream = null;
-        LOG.warn("failed to get input stream for file", e);
-      }
-    }
-    return inputStream;
+    return getInputStream(AppConfig.getInstance());
   }
 
+  /**
+   * Handles getting input stream for various {@link OpenMode}
+   *
+   * @param context
+   * @return
+   */
   @Nullable
   public InputStream getInputStream(Context context) {
     InputStream inputStream;
@@ -1061,8 +1062,9 @@ public class HybridFile {
             SshClientUtils.execute(
                 new SFtpClientTemplate<InputStream>(path, false) {
                   @Override
-                  public InputStream execute(final SFTPClient client) throws IOException {
-                    final RemoteFile rf = client.open(SshClientUtils.extractRemotePathFrom(path));
+                  public InputStream execute(@NonNull final SFTPClient client) throws IOException {
+                    final RemoteFile rf =
+                        client.open(NetCopyClientUtils.INSTANCE.extractRemotePathFrom(path));
                     return rf.new RemoteFileInputStream() {
                       @Override
                       public void close() throws IOException {
@@ -1085,6 +1087,37 @@ public class HybridFile {
           LOG.warn("failed to get input stream for smb file", e);
         }
         break;
+      case FTP:
+        inputStream =
+            NetCopyClientUtils.INSTANCE.execute(
+                new FtpClientTemplate<InputStream>(path, false) {
+                  public InputStream executeWithFtpClient(@NonNull FTPClient ftpClient)
+                      throws IOException {
+                    String parent = getParent(AppConfig.getInstance());
+                    /*
+                     * Use temp file to hold the FTP file.
+                     *
+                     * Due to the single thread nature of FTPClient, it is not possible to open
+                     * both input and output streams on the same FTP server on the same time.
+                     * Hence have to use placeholder temp file to hold contents for freeing out
+                     * the thread for output stream. - TranceLove
+                     */
+                    File tmpFile = File.createTempFile("ftp-transfer_", ".tmp");
+                    tmpFile.deleteOnExit();
+                    ftpClient.changeWorkingDirectory(
+                        NetCopyClientUtils.INSTANCE.extractRemotePathFrom(parent));
+                    ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
+                    InputStream fin =
+                        ftpClient.retrieveFileStream(getName(AppConfig.getInstance()));
+                    FileOutputStream fout = new FileOutputStream(tmpFile);
+                    ByteStreamsKt.copyTo(fin, fout, GenericCopyUtil.DEFAULT_BUFFER_SIZE);
+                    fin.close();
+                    fout.close();
+                    ftpClient.completePendingCommand();
+                    return FTPClientImpl.wrap(tmpFile);
+                  }
+                });
+        break;
       case DOCUMENT_FILE:
         ContentResolver contentResolver = context.getContentResolver();
         DocumentFile documentSourceFile = getDocumentFile(false);
@@ -1130,14 +1163,15 @@ public class HybridFile {
     OutputStream outputStream;
     switch (mode) {
       case SFTP:
-        return SshClientUtils.execute(
+        return NetCopyClientUtils.INSTANCE.execute(
             new SshClientTemplate<OutputStream>(path, false) {
               @Override
-              public OutputStream execute(final SSHClient ssh) throws IOException {
+              public OutputStream executeWithSSHClient(@NonNull final SSHClient ssh)
+                  throws IOException {
                 final SFTPClient client = ssh.newSFTPClient();
                 final RemoteFile rf =
                     client.open(
-                        SshClientUtils.extractRemotePathFrom(path),
+                        NetCopyClientUtils.INSTANCE.extractRemotePathFrom(path),
                         EnumSet.of(
                             net.schmizz.sshj.sftp.OpenMode.WRITE,
                             net.schmizz.sshj.sftp.OpenMode.CREAT));
@@ -1158,6 +1192,23 @@ public class HybridFile {
                 };
               }
             });
+      case FTP:
+        outputStream =
+            NetCopyClientUtils.INSTANCE.execute(
+                new FtpClientTemplate<OutputStream>(path, false) {
+                  public OutputStream executeWithFtpClient(@NonNull FTPClient ftpClient)
+                      throws IOException {
+                    ftpClient.setFileType(FTP.BINARY_FILE_TYPE);
+                    String remotePath = NetCopyClientUtils.INSTANCE.extractRemotePathFrom(path);
+                    OutputStream outputStream = ftpClient.storeFileStream(remotePath);
+                    if (outputStream != null) {
+                      return FTPClientImpl.wrap(outputStream, ftpClient);
+                    } else {
+                      return null;
+                    }
+                  }
+                });
+        return outputStream;
       case SMB:
         try {
           outputStream = getSmbFile().getOutputStream();
@@ -1201,22 +1252,21 @@ public class HybridFile {
     boolean exists = false;
     if (isSftp()) {
       final Boolean executionReturn =
-          SshClientUtils.<Boolean>execute(
-              new SFtpClientTemplate<Boolean>(path) {
+          NetCopyClientUtils.INSTANCE.<SSHClient, Boolean>execute(
+              new SFtpClientTemplate<Boolean>(path, false) {
                 @Override
                 public Boolean execute(SFTPClient client) throws IOException {
                   try {
-                    return client.stat(SshClientUtils.extractRemotePathFrom(path)) != null;
+                    return client.stat(NetCopyClientUtils.INSTANCE.extractRemotePathFrom(path))
+                        != null;
                   } catch (SFTPException notFound) {
                     return false;
                   }
                 }
               });
-
       if (executionReturn == null) {
         LOG.error("Error obtaining existance of file over SFTP");
       }
-
       //noinspection SimplifiableConditionalExpression
       exists = executionReturn == null ? false : executionReturn;
     } else if (isSmb()) {
@@ -1227,6 +1277,11 @@ public class HybridFile {
         LOG.warn("failed to find existence for smb file", e);
         exists = false;
       }
+    } else if (isFtp()) {
+      if (getPath().equals("/")) exists = true;
+      else {
+        exists = getFtpFile() != null;
+      }
     } else if (isDropBoxFile()) {
       CloudStorage cloudStorageDropbox = dataUtils.getAccount(OpenMode.DROPBOX);
       exists = cloudStorageDropbox.exists(CloudUtil.stripPath(OpenMode.DROPBOX, path));
@@ -1282,7 +1337,8 @@ public class HybridFile {
         && !isGoogleDriveFile()
         && !isDropBoxFile()
         && !isBoxFile()
-        && !isSftp();
+        && !isSftp()
+        && !isFtp();
   }
 
   public boolean setLastModified(final long date) {
@@ -1299,19 +1355,35 @@ public class HybridFile {
         LOG.warn("failed to get last modified for smb file", e);
         return false;
       }
+    } else if (isFtp()) {
+      return Boolean.TRUE.equals(
+          NetCopyClientUtils.INSTANCE.execute(
+              new FtpClientTemplate<Boolean>(path, false) {
+                public Boolean executeWithFtpClient(@NonNull FTPClient ftpClient)
+                    throws IOException {
+                  Calendar calendar = Calendar.getInstance();
+                  calendar.setTimeInMillis(date);
+                  DateFormat df = new SimpleDateFormat("yyyyMMddHHmmss", Locale.US);
+                  df.setCalendar(calendar);
+                  return ftpClient.setModificationTime(
+                      NetCopyClientUtils.INSTANCE.extractRemotePathFrom(path),
+                      df.format(calendar.getTime()));
+                }
+              }));
+    } else {
+      File f = getFile();
+      return f.setLastModified(date);
     }
-    File f = getFile();
-    return f.setLastModified(date);
   }
 
   public void mkdir(Context context) {
     if (isSftp()) {
-      SshClientUtils.execute(
-          new SFtpClientTemplate<Void>(path) {
+      NetCopyClientUtils.INSTANCE.execute(
+          new SFtpClientTemplate<Void>(path, false) {
             @Override
             public Void execute(@NonNull SFTPClient client) {
               try {
-                client.mkdir(SshClientUtils.extractRemotePathFrom(path));
+                client.mkdir(NetCopyClientUtils.INSTANCE.extractRemotePathFrom(path));
               } catch (IOException e) {
                 LOG.error("Error making directory over SFTP", e);
               }
@@ -1319,6 +1391,15 @@ public class HybridFile {
               return null;
             }
           });
+    } else if (isFtp()) {
+      NetCopyClientUtils.INSTANCE.execute(
+          new FtpClientTemplate<Boolean>(getPath(), false) {
+            public Boolean executeWithFtpClient(@NonNull FTPClient ftpClient) throws IOException {
+              ExtensionsKt.makeDirectoryTree(
+                  ftpClient, NetCopyClientUtils.INSTANCE.extractRemotePathFrom(getPath()));
+              return true;
+            }
+          });
     } else if (isSmb()) {
       try {
         getSmbFile().mkdirs();
@@ -1359,17 +1440,29 @@ public class HybridFile {
       throws ShellNotRunningException, SmbException {
     if (isSftp()) {
       Boolean retval =
-          SshClientUtils.<Boolean>execute(
-              new SFtpClientTemplate(path) {
+          NetCopyClientUtils.INSTANCE.<SSHClient, Boolean>execute(
+              new SFtpClientTemplate<Boolean>(path, false) {
                 @Override
                 public Boolean execute(@NonNull SFTPClient client) throws IOException {
-                  String _path = SshClientUtils.extractRemotePathFrom(path);
+                  String _path = NetCopyClientUtils.INSTANCE.extractRemotePathFrom(path);
                   if (isDirectory(AppConfig.getInstance())) client.rmdir(_path);
                   else client.rm(_path);
                   return client.statExistence(_path) == null;
                 }
               });
       return retval != null && retval;
+    } else if (isFtp()) {
+      Boolean retval =
+          NetCopyClientUtils.INSTANCE.<FTPClient, Boolean>execute(
+              new FtpClientTemplate<Boolean>(path, false) {
+                @Override
+                public Boolean executeWithFtpClient(@NonNull FTPClient ftpClient)
+                    throws IOException {
+                  return ftpClient.deleteFile(
+                      NetCopyClientUtils.INSTANCE.extractRemotePathFrom(path));
+                }
+              });
+      return retval != null && retval;
     } else if (isSmb()) {
       try {
         getSmbFile().delete();
@@ -1459,7 +1552,7 @@ public class HybridFile {
           new AtomicReference<>(activity.getString(R.string.calculating));
       AtomicReference<String> pathToDisplay = new AtomicReference<>();
       pathToDisplay.set(path);
-      if (isSftp() || isSmb()) {
+      if (isSftp() || isSmb() || isFtp()) {
         LOG.debug("convert authorised path to simple path for display");
         pathToDisplay.set(parseAndFormatUriForDisplay(path));
       }
@@ -1613,7 +1706,7 @@ public class HybridFile {
     return new SshClientSessionTemplate<String>(path) {
       @Override
       public String execute(Session session) throws IOException {
-        String extractedPath = SshClientUtils.extractRemotePathFrom(path);
+        String extractedPath = NetCopyClientUtils.INSTANCE.extractRemotePathFrom(path);
         String fullCommand = String.format(command, extractedPath);
         Session.Command cmd = session.exec(fullCommand);
         String result = new String(IOUtils.readFully(cmd.getInputStream()).toByteArray());
@@ -1651,12 +1744,13 @@ public class HybridFile {
         FileUtils.launchSMB(this, activity);
         break;
       case SFTP:
+      case FTP:
         Toast.makeText(
                 activity,
                 activity.getResources().getString(R.string.please_wait),
                 Toast.LENGTH_LONG)
             .show();
-        SshClientUtils.launchSftp(this, activity);
+        SshClientUtils.launchFtp(this, activity);
         break;
       case OTG:
         FileUtils.openFile(
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/HybridFileParcelable.java b/app/src/main/java/com/amaze/filemanager/filesystem/HybridFileParcelable.java
index c020e39ad..50928e1e6 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/HybridFileParcelable.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/HybridFileParcelable.java
@@ -22,10 +22,12 @@ package com.amaze.filemanager.filesystem;
 
 import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.DOCUMENT_FILE;
 
+import org.apache.commons.net.ftp.FTPFile;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
+import com.amaze.filemanager.filesystem.ftp.ExtensionsKt;
 import com.amaze.filemanager.utils.Utils;
 
 import android.content.ContentResolver;
@@ -74,6 +76,18 @@ public class HybridFileParcelable extends HybridFile implements Parcelable {
     setSize(smbFile.isDirectory() ? 0 : smbFile.length());
   }
 
+  public HybridFileParcelable(String path, FTPFile ftpFile) {
+    super(
+        OpenMode.FTP,
+        path + (ftpFile.getName().startsWith("/") ? ftpFile.getName() : "/" + ftpFile.getName()));
+    setName(ftpFile.getName());
+    setDirectory(ftpFile.getType() == FTPFile.DIRECTORY_TYPE);
+    setDate(ftpFile.getTimestamp().getTimeInMillis());
+    setSize(ftpFile.getSize());
+    setPermission(
+        Integer.toString(FilePermission.toMask(ExtensionsKt.toFilePermissions(ftpFile)), 8));
+  }
+
   /** Constructor for sshj {@link RemoteResourceInfo}. */
   public HybridFileParcelable(String path, boolean isDirectory, RemoteResourceInfo sshFile) {
     super(OpenMode.SFTP, String.format("%s/%s", path, sshFile.getName()));
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java b/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java
index cd12ba911..4e17a514d 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java
@@ -32,6 +32,7 @@ import java.net.URL;
 import java.util.ArrayList;
 import java.util.concurrent.Executor;
 
+import org.apache.commons.net.ftp.FTPClient;
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
@@ -40,11 +41,12 @@ import com.amaze.filemanager.fileoperations.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.filesystem.cloud.CloudUtil;
 import com.amaze.filemanager.filesystem.files.FileUtils;
+import com.amaze.filemanager.filesystem.ftp.FtpClientTemplate;
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientUtils;
 import com.amaze.filemanager.filesystem.root.MakeDirectoryCommand;
 import com.amaze.filemanager.filesystem.root.MakeFileCommand;
 import com.amaze.filemanager.filesystem.root.RenameFileCommand;
 import com.amaze.filemanager.filesystem.ssh.SFtpClientTemplate;
-import com.amaze.filemanager.filesystem.ssh.SshClientUtils;
 import com.amaze.filemanager.utils.DataUtils;
 import com.amaze.filemanager.utils.OTGUtil;
 import com.cloudrail.si.interfaces.CloudStorage;
@@ -146,8 +148,14 @@ public class Operations {
           errorCallBack.exists(file);
           return null;
         }
-        if (file.isSftp()) {
+
+        if (file.isSftp() || file.isFtp()) {
           file.mkdir(context);
+          /*
+          FIXME: throw Exceptions from HybridFile.mkdir() so errorCallback can throw Exceptions
+           here
+           */
+          errorCallBack.done(file, true);
           return null;
         }
         if (file.isSmb()) {
@@ -160,14 +168,16 @@ public class Operations {
           }
           errorCallBack.done(file, file.exists());
           return null;
-        } else if (file.isOtgFile()) {
+        }
+        if (file.isOtgFile()) {
           if (checkOtgNewFileExists(file, context)) {
             errorCallBack.exists(file);
             return null;
           }
           safCreateDirectory.apply(OTGUtil.getDocumentFile(parentFile.getPath(), context, false));
           return null;
-        } else if (file.isDocumentFile()) {
+        }
+        if (file.isDocumentFile()) {
           if (checkDocumentFileNewFileExists(file, context)) {
             errorCallBack.exists(file);
             return null;
@@ -289,7 +299,7 @@ public class Operations {
           errorCallBack.exists(file);
           return null;
         }
-        if (file.isSftp()) {
+        if (file.isSftp() || file.isFtp()) {
           OutputStream out = file.getOutputStream(context);
           if (out == null) {
             errorCallBack.done(file, false);
@@ -488,14 +498,14 @@ public class Operations {
           }
           return null;
         } else if (oldFile.isSftp()) {
-          SshClientUtils.execute(
-              new SFtpClientTemplate<Void>(oldFile.getPath()) {
+          NetCopyClientUtils.INSTANCE.execute(
+              new SFtpClientTemplate<Void>(oldFile.getPath(), false) {
                 @Override
                 public Void execute(@NonNull SFTPClient client) {
                   try {
                     client.rename(
-                        SshClientUtils.extractRemotePathFrom(oldFile.getPath()),
-                        SshClientUtils.extractRemotePathFrom(newFile.getPath()));
+                        NetCopyClientUtils.INSTANCE.extractRemotePathFrom(oldFile.getPath()),
+                        NetCopyClientUtils.INSTANCE.extractRemotePathFrom(newFile.getPath()));
                     errorCallBack.done(newFile, true);
                   } catch (IOException e) {
                     String errmsg =
@@ -522,6 +532,19 @@ public class Operations {
                   return null;
                 }
               });
+        } else if (oldFile.isFtp()) {
+          NetCopyClientUtils.INSTANCE.execute(
+              new FtpClientTemplate<Boolean>(oldFile.getPath(), false) {
+                public Boolean executeWithFtpClient(@NonNull FTPClient ftpClient)
+                    throws IOException {
+                  boolean result =
+                      ftpClient.rename(
+                          NetCopyClientUtils.INSTANCE.extractRemotePathFrom(oldFile.getPath()),
+                          NetCopyClientUtils.INSTANCE.extractRemotePathFrom(newFile.getPath()));
+                  errorCallBack.done(newFile, result);
+                  return result;
+                }
+              });
         } else if (oldFile.isDropBoxFile()) {
           CloudStorage cloudStorageDropbox = dataUtils.getAccount(OpenMode.DROPBOX);
           try {
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/cloud/CloudUtil.java b/app/src/main/java/com/amaze/filemanager/filesystem/cloud/CloudUtil.java
index b5e40dd46..f83449dc5 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/cloud/CloudUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/cloud/CloudUtil.java
@@ -39,8 +39,6 @@ import com.amaze.filemanager.fileoperations.filesystem.OpenMode;
 import com.amaze.filemanager.fileoperations.filesystem.cloud.CloudStreamer;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
-import com.amaze.filemanager.filesystem.ssh.SFtpClientTemplate;
-import com.amaze.filemanager.filesystem.ssh.SshClientUtils;
 import com.amaze.filemanager.ui.activities.MainActivity;
 import com.amaze.filemanager.ui.icons.MimeTypes;
 import com.amaze.filemanager.utils.DataUtils;
@@ -63,9 +61,6 @@ import android.widget.Toast;
 import androidx.annotation.Nullable;
 import androidx.documentfile.provider.DocumentFile;
 
-import net.schmizz.sshj.sftp.RemoteFile;
-import net.schmizz.sshj.sftp.SFTPClient;
-
 /**
  * Created by vishal on 19/4/17.
  *
@@ -265,26 +260,12 @@ public class CloudUtil {
 
     switch (hybridFile.getMode()) {
       case SFTP:
-        inputStream =
-            SshClientUtils.execute(
-                new SFtpClientTemplate<InputStream>(hybridFile.getPath(), false) {
-                  @Override
-                  public InputStream execute(final SFTPClient client) throws IOException {
-                    final RemoteFile rf =
-                        client.open(SshClientUtils.extractRemotePathFrom(hybridFile.getPath()));
-                    return rf.new RemoteFileInputStream() {
-                      @Override
-                      public void close() throws IOException {
-                        try {
-                          super.close();
-                        } finally {
-                          rf.close();
-                          client.close();
-                        }
-                      }
-                    };
-                  }
-                });
+        inputStream = hybridFile.getInputStream(context);
+        break;
+      case FTP:
+        // Until we find a way to properly handle threading issues with thread unsafe FTPClient,
+        // we refrain from loading any files via FTP as file thumbnail. - TranceLove
+        inputStream = null;
         break;
       case SMB:
         try {
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/SevenZipExtractor.kt b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/SevenZipExtractor.kt
index c2fb0a081..c5e6528d9 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/SevenZipExtractor.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/compressed/extractcontents/helpers/SevenZipExtractor.kt
@@ -21,7 +21,6 @@
 package com.amaze.filemanager.filesystem.compressed.extractcontents.helpers
 
 import android.content.Context
-import android.util.Log
 import com.amaze.filemanager.R
 import com.amaze.filemanager.application.AppConfig
 import com.amaze.filemanager.fileoperations.filesystem.compressed.ArchivePasswordCache
@@ -33,11 +32,12 @@ import com.amaze.filemanager.filesystem.compressed.sevenz.SevenZArchiveEntry
 import com.amaze.filemanager.filesystem.compressed.sevenz.SevenZFile
 import com.amaze.filemanager.filesystem.files.GenericCopyUtil
 import org.apache.commons.compress.PasswordRequiredException
+import org.slf4j.Logger
+import org.slf4j.LoggerFactory
 import org.tukaani.xz.CorruptedInputException
 import java.io.BufferedOutputStream
 import java.io.File
 import java.io.IOException
-import java.lang.UnsupportedOperationException
 
 class SevenZipExtractor(
     context: Context,
@@ -48,6 +48,11 @@ class SevenZipExtractor(
 ) :
     Extractor(context, filePath, outputPath, listener, updatePosition) {
 
+    companion object {
+        @JvmStatic
+        private val LOG: Logger = LoggerFactory.getLogger(SevenZipExtractor::class.java)
+    }
+
     @Throws(IOException::class)
     override fun extractWithFilter(filter: Filter) {
         var totalBytes: Long = 0
@@ -133,7 +138,7 @@ class SevenZipExtractor(
                 val lastModifiedDate = try {
                     entry.lastModifiedDate.time
                 } catch (e: UnsupportedOperationException) {
-                    Log.w(javaClass.simpleName, "Unable to get modified date for 7zip file")
+                    LOG.warn("Unable to get modified date for 7zip file")
                     System.currentTimeMillis()
                 }
                 outputFile.setLastModified(lastModifiedDate)
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/files/EncryptDecryptUtils.java b/app/src/main/java/com/amaze/filemanager/filesystem/files/EncryptDecryptUtils.java
index f497f531b..b2418779c 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/files/EncryptDecryptUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/files/EncryptDecryptUtils.java
@@ -49,6 +49,7 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.SharedPreferences;
 import android.os.Build;
+import android.util.Base64;
 import android.widget.EditText;
 import android.widget.Toast;
 
@@ -195,7 +196,8 @@ public class EncryptDecryptUtils {
                     c,
                     preferences1.getString(
                         PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD,
-                        PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD_DEFAULT)),
+                        PreferencesConstants.PREFERENCE_CRYPT_MASTER_PASSWORD_DEFAULT),
+                    Base64.DEFAULT),
                 decryptButtonCallbackInterface);
           } catch (GeneralSecurityException | IOException e) {
             LOG.warn("failed to show decrypt dialog, e");
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/files/FileUtils.java b/app/src/main/java/com/amaze/filemanager/filesystem/files/FileUtils.java
index 370306c32..a564a636f 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/files/FileUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/files/FileUtils.java
@@ -30,6 +30,7 @@ import java.util.Collections;
 import java.util.Date;
 import java.util.LinkedList;
 import java.util.List;
+import java.util.concurrent.Callable;
 import java.util.concurrent.atomic.AtomicLong;
 
 import org.slf4j.Logger;
@@ -70,6 +71,7 @@ import com.googlecode.concurrenttrees.radix.node.concrete.voidvalue.VoidValue;
 import android.Manifest;
 import android.animation.Animator;
 import android.animation.AnimatorListenerAdapter;
+import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.content.ActivityNotFoundException;
 import android.content.Context;
@@ -90,6 +92,8 @@ import androidx.core.content.FileProvider;
 import androidx.core.util.Pair;
 import androidx.documentfile.provider.DocumentFile;
 
+import io.reactivex.Flowable;
+import io.reactivex.schedulers.Schedulers;
 import jcifs.smb.SmbFile;
 import kotlin.collections.ArraysKt;
 import net.schmizz.sshj.sftp.RemoteResourceInfo;
@@ -222,21 +226,25 @@ public class FileUtils {
    * @param hybridFiles
    * @param context
    */
+  @SuppressLint("CheckResult")
   public static void scanFile(@NonNull Context context, @NonNull HybridFile[] hybridFiles) {
-    AsyncTask.execute(
-        () -> {
-          if (hybridFiles[0].exists(context) && hybridFiles[0].isLocal()) {
-            String[] paths = new String[hybridFiles.length];
-            for (int i = 0; i < hybridFiles.length; i++) {
-              HybridFile hybridFile = hybridFiles[i];
-              paths[i] = hybridFile.getPath();
-            }
-            MediaScannerConnection.scanFile(context, paths, null, null);
-          }
-          for (HybridFile hybridFile : hybridFiles) {
-            scanFile(hybridFile, context);
-          }
-        });
+    Flowable.fromCallable(
+            (Callable<Void>)
+                () -> {
+                  if (hybridFiles[0].exists(context) && hybridFiles[0].isLocal()) {
+                    String[] paths = new String[hybridFiles.length];
+                    for (int i = 0; i < hybridFiles.length; i++) {
+                      HybridFile hybridFile = hybridFiles[i];
+                      paths[i] = hybridFile.getPath();
+                    }
+                    MediaScannerConnection.scanFile(context, paths, null, null);
+                  }
+                  for (HybridFile hybridFile : hybridFiles) {
+                    scanFile(hybridFile, context);
+                  }
+                  return null;
+                })
+        .subscribeOn(Schedulers.io());
   }
 
   /**
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/files/GenericCopyUtil.java b/app/src/main/java/com/amaze/filemanager/filesystem/files/GenericCopyUtil.java
index b5d916875..068d6a95f 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/files/GenericCopyUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/files/GenericCopyUtil.java
@@ -68,9 +68,10 @@ public class GenericCopyUtil {
 
   private HybridFileParcelable mSourceFile;
   private HybridFile mTargetFile;
-  private Context mContext; // context needed to find the DocumentFile in otg/sd card
-  private DataUtils dataUtils = DataUtils.getInstance();
-  private ProgressHandler progressHandler;
+  private final Context mContext; // context needed to find the DocumentFile in otg/sd card
+  private final DataUtils dataUtils = DataUtils.getInstance();
+  private final ProgressHandler progressHandler;
+
   public static final String PATH_FILE_DESCRIPTOR = "/proc/self/fd/";
 
   public static final int DEFAULT_BUFFER_SIZE = 8192;
@@ -124,7 +125,7 @@ public class GenericCopyUtil {
         bufferedInputStream =
             new BufferedInputStream(
                 contentResolver.openInputStream(documentSourceFile.getUri()), DEFAULT_BUFFER_SIZE);
-      } else if (mSourceFile.isSmb() || mSourceFile.isSftp()) {
+      } else if (mSourceFile.isSmb() || mSourceFile.isSftp() || mSourceFile.isFtp()) {
         bufferedInputStream =
             new BufferedInputStream(mSourceFile.getInputStream(mContext), DEFAULT_TRANSFER_QUANTUM);
       } else if (mSourceFile.isDropBoxFile()
@@ -189,7 +190,7 @@ public class GenericCopyUtil {
         bufferedOutputStream =
             new BufferedOutputStream(
                 contentResolver.openOutputStream(documentTargetFile.getUri()), DEFAULT_BUFFER_SIZE);
-      } else if (mTargetFile.isSftp() || mTargetFile.isSmb()) {
+      } else if (mTargetFile.isFtp() || mTargetFile.isSftp() || mTargetFile.isSmb()) {
         bufferedOutputStream =
             new BufferedOutputStream(
                 mTargetFile.getOutputStream(mContext), DEFAULT_TRANSFER_QUANTUM);
@@ -253,10 +254,15 @@ public class GenericCopyUtil {
     } finally {
 
       try {
-        if (inChannel != null) inChannel.close();
-        if (outChannel != null) outChannel.close();
-        if (bufferedInputStream != null) bufferedInputStream.close();
-        if (bufferedOutputStream != null) bufferedOutputStream.close();
+        if (inChannel != null && inChannel.isOpen()) inChannel.close();
+        if (outChannel != null && outChannel.isOpen()) outChannel.close();
+        /*
+         * It does seems closing the inChannel/outChannel is already sufficient closing the below
+         * bufferedInputStream and bufferedOutputStream instances. These 2 lines prevented FTP
+         * copy from working, especially on Android 9 - TranceLove
+         */
+        //        if (bufferedInputStream != null) bufferedInputStream.close();
+        //        if (bufferedOutputStream != null) bufferedOutputStream.close();
       } catch (IOException e) {
         LOG.warn("failed to close stream after copying", e);
         // failure in closing stream
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ftp/Extensions.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ftp/Extensions.kt
new file mode 100644
index 000000000..01575e1fe
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ftp/Extensions.kt
@@ -0,0 +1,119 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.filesystem.ftp
+
+import net.schmizz.sshj.xfer.FilePermission
+import org.apache.commons.net.ftp.FTPClient
+import org.apache.commons.net.ftp.FTPFile
+import org.apache.commons.net.ftp.FTPFile.*
+import org.apache.commons.net.ftp.FTPReply
+import java.io.IOException
+
+/**
+ * @see https://stackoverflow.com/a/7606723
+ */
+@Throws(IOException::class)
+fun FTPClient.makeDirectoryTree(dirTree: String) {
+    if (dirTree == "/") {
+        return
+    }
+
+    changeWorkingDirectory("/")
+    var dirExists = true
+    // Tokenize the string and attempt to change into each directory level.
+    // If you cannot, then start creating.
+    val directories = dirTree.split('/')
+    for (dir in directories) {
+        if (dir.isNotEmpty()) {
+            if (dirExists) {
+                dirExists = changeWorkingDirectory(dir)
+            }
+            if (!dirExists) {
+                if (!makeDirectory(dir)) {
+                    throw IOException(
+                        "Unable to create remote directory '$dir'. Error='$replyString'"
+                    )
+                }
+                if (!changeWorkingDirectory(dir)) {
+                    throw IOException(
+                        "Unable to change into newly created remote directory '$dir'. " +
+                            "Error='$replyString'"
+                    )
+                }
+            }
+        }
+    }
+}
+
+/**
+ * Try to ask server for space available, if it supports use of AVBL command.
+ *
+ * @param path Path to check for space available.
+ */
+fun FTPClient.getSpaceAvailable(path: String = "/"): Long {
+    if (hasFeature("AVBL")) {
+        val result = sendCommand("AVBL", path)
+        if (result == FTPReply.FILE_STATUS) {
+            // skip the return code (e.g. 213) and the space
+            return getReplyString().substring(4).toLong()
+        } else {
+            return -1L
+        }
+    } else {
+        return -1L
+    }
+}
+
+/**
+ * Translate FTPFile's permission to Set of [FilePermission].
+ */
+fun FTPFile.toFilePermissions(): Set<FilePermission> {
+    val retval = HashSet<FilePermission>()
+    // Got a better and smarter idea?
+    if (hasPermission(USER_ACCESS, READ_PERMISSION)) {
+        retval.add(FilePermission.USR_R)
+    }
+    if (hasPermission(USER_ACCESS, WRITE_PERMISSION)) {
+        retval.add(FilePermission.USR_W)
+    }
+    if (hasPermission(USER_ACCESS, EXECUTE_PERMISSION)) {
+        retval.add(FilePermission.USR_X)
+    }
+    if (hasPermission(GROUP_ACCESS, READ_PERMISSION)) {
+        retval.add(FilePermission.GRP_R)
+    }
+    if (hasPermission(GROUP_ACCESS, WRITE_PERMISSION)) {
+        retval.add(FilePermission.GRP_W)
+    }
+    if (hasPermission(GROUP_ACCESS, EXECUTE_PERMISSION)) {
+        retval.add(FilePermission.GRP_X)
+    }
+    if (hasPermission(WORLD_ACCESS, READ_PERMISSION)) {
+        retval.add(FilePermission.OTH_R)
+    }
+    if (hasPermission(WORLD_ACCESS, WRITE_PERMISSION)) {
+        retval.add(FilePermission.OTH_W)
+    }
+    if (hasPermission(WORLD_ACCESS, EXECUTE_PERMISSION)) {
+        retval.add(FilePermission.OTH_X)
+    }
+    return retval
+}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ftp/FTPClientImpl.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ftp/FTPClientImpl.kt
new file mode 100644
index 000000000..823942c9c
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ftp/FTPClientImpl.kt
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2014-2021 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.filesystem.ftp
+
+import org.apache.commons.net.ftp.FTPClient
+import org.slf4j.Logger
+import org.slf4j.LoggerFactory
+import java.io.File
+import java.io.FileInputStream
+import java.io.InputStream
+import java.io.OutputStream
+import kotlin.random.Random
+
+class FTPClientImpl(private val ftpClient: FTPClient) : NetCopyClient<FTPClient> {
+
+    companion object {
+        @JvmStatic
+        private val logger: Logger = LoggerFactory.getLogger(FTPClientImpl::class.java)
+
+        @JvmStatic
+        val ANONYMOUS = "anonymous"
+
+        private const val ALPHABET = "abcdefghijklmnopqrstuvwxyz1234567890"
+
+        @JvmStatic
+        private fun randomString(strlen: Int) = (1..strlen)
+            .map { Random.nextInt(0, ALPHABET.length) }
+            .map(ALPHABET::get)
+            .joinToString("")
+
+        /**
+         * Generate random email address for anonymous FTP login.
+         */
+        @JvmStatic
+        fun generateRandomEmailAddressForLogin(
+            usernameLen: Int = 8,
+            domainPrefixLen: Int = 5,
+            domainSuffixLen: Int = 3
+        ): String {
+            val username = randomString(usernameLen)
+            val domainPrefix = randomString(domainPrefixLen)
+            val domainSuffix = randomString(domainSuffixLen)
+
+            return "$username@$domainPrefix.$domainSuffix"
+        }
+
+        /**
+         * Wraps an an temporary [File] returned by [FTPClient.retrieveFileStream].
+         * Most important part is to do [File.delete] when the reading is done.
+         */
+        @JvmStatic
+        fun wrap(inputFile: File) = object : InputStream() {
+            private val inputStream = FileInputStream(inputFile)
+            override fun read() = inputStream.read()
+            override fun read(b: ByteArray?): Int = inputStream.read(b)
+            override fun read(b: ByteArray?, off: Int, len: Int): Int =
+                inputStream.read(b, off, len)
+            override fun reset() = inputStream.reset()
+            override fun available(): Int = inputStream.available()
+            override fun close() {
+                inputStream.close()
+                inputFile.delete()
+            }
+            override fun markSupported(): Boolean = inputStream.markSupported()
+            override fun mark(readlimit: Int) = inputStream.mark(readlimit)
+            override fun skip(n: Long): Long = inputStream.skip(n)
+        }
+
+        /**
+         * Wraps an [OutputStream] returned by [FTPClient.storeFileStream].
+         * Most important part is to do [FTPClient.completePendingCommand] on [OutputStream.close].
+         */
+        @JvmStatic
+        fun wrap(outputStream: OutputStream, ftpClient: FTPClient) = object : OutputStream() {
+            override fun write(b: Int) = outputStream.write(b)
+            override fun write(b: ByteArray?) = outputStream.write(b)
+            override fun write(b: ByteArray?, off: Int, len: Int) =
+                outputStream.write(b, off, len)
+            override fun flush() = outputStream.flush()
+            override fun close() {
+                outputStream.close()
+                ftpClient.completePendingCommand()
+            }
+        }
+    }
+
+    override fun getClientImpl() = ftpClient
+
+    override fun isConnectionValid(): Boolean = ftpClient.isAvailable
+
+    override fun isRequireThreadSafety(): Boolean = true
+
+    override fun expire() {
+        ftpClient.disconnect()
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ftp/FtpClientTemplate.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ftp/FtpClientTemplate.kt
new file mode 100644
index 000000000..1aa1a0130
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ftp/FtpClientTemplate.kt
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2014-2021 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.filesystem.ftp
+
+import org.apache.commons.net.ftp.FTPClient
+import java.io.IOException
+
+/**
+ * Template class for executing actions with [NetCopyClient] while leave the complexities of
+ * handling connection setup/teardown to [NetCopyClientUtils].
+ */
+abstract class FtpClientTemplate<T>(url: String, closeClientOnFinish: Boolean = true) :
+    NetCopyClientTemplate<FTPClient, T>(url, closeClientOnFinish) {
+
+    @Throws(IOException::class)
+    final override fun execute(client: NetCopyClient<FTPClient>): T? {
+        val ftpClient: FTPClient = client.getClientImpl()
+        return executeWithFtpClient(ftpClient)
+    }
+
+    /**
+     * Implement logic here.
+     *
+     * @param client [FTPClient] instance, with connection opened and authenticated
+     * @param <T> Requested return type
+     * @return Result of the execution of the type requested </T>
+     **/
+    @Throws(IOException::class)
+    abstract fun executeWithFtpClient(ftpClient: FTPClient): T?
+}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ftp/NetCopyClient.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ftp/NetCopyClient.kt
new file mode 100644
index 000000000..4fd1dcc53
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ftp/NetCopyClient.kt
@@ -0,0 +1,49 @@
+/*
+ * Copyright (C) 2014-2021 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.filesystem.ftp
+
+/**
+ * Base interface for defining client class that interacts with a remote server.
+ */
+interface NetCopyClient<T> {
+
+    /**
+     * Returns the physical client implementation.
+     */
+    fun getClientImpl(): T
+
+    /**
+     * Answers if the connection of the underlying client is still valid.
+     */
+    fun isConnectionValid(): Boolean
+
+    /**
+     * Answers if the client returned by [getClientImpl] requires thread safety.
+     *
+     * [NetCopyClientUtils.execute] will see this flag and enforce locking as necessary.
+     */
+    fun isRequireThreadSafety(): Boolean = false
+
+    /**
+     * Implement logic to expire the underlying connection if it went stale, timeout, etc.
+     */
+    fun expire(): Unit
+}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ftp/NetCopyClientConnectionPool.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ftp/NetCopyClientConnectionPool.kt
new file mode 100644
index 000000000..56374a669
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ftp/NetCopyClientConnectionPool.kt
@@ -0,0 +1,533 @@
+/*
+ * Copyright (C) 2014-2021 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.filesystem.ftp
+
+import android.annotation.SuppressLint
+import com.amaze.filemanager.application.AppConfig
+import com.amaze.filemanager.asynchronous.asynctasks.ftp.auth.FtpAuthenticationTask
+import com.amaze.filemanager.asynchronous.asynctasks.ssh.PemToKeyPairTask
+import com.amaze.filemanager.asynchronous.asynctasks.ssh.SshAuthenticationTask
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientUtils.extractBaseUriFrom
+import com.amaze.filemanager.utils.PasswordUtil
+import io.reactivex.Flowable
+import io.reactivex.Maybe
+import io.reactivex.Single
+import io.reactivex.schedulers.Schedulers
+import net.schmizz.sshj.Config
+import net.schmizz.sshj.SSHClient
+import org.apache.commons.net.ftp.FTPClient
+import org.apache.commons.net.ftp.FTPSClient
+import org.json.JSONObject
+import org.slf4j.Logger
+import org.slf4j.LoggerFactory
+import java.security.KeyPair
+import java.util.*
+import java.util.concurrent.Callable
+import java.util.concurrent.ConcurrentHashMap
+import java.util.concurrent.CountDownLatch
+import java.util.concurrent.atomic.AtomicReference
+
+object NetCopyClientConnectionPool {
+
+    const val FTP_DEFAULT_PORT = 21
+    const val FTPS_DEFAULT_PORT = 990
+    const val SSH_DEFAULT_PORT = 22
+    const val FTP_URI_PREFIX = "ftp://"
+    const val FTPS_URI_PREFIX = "ftps://"
+    const val SSH_URI_PREFIX = "ssh://"
+    const val CONNECT_TIMEOUT = 30000
+    const val AT = '@'
+    const val SLASH = '/'
+    const val COLON = ':'
+
+    private var connections: MutableMap<String, NetCopyClient<*>> = ConcurrentHashMap()
+
+    @JvmStatic
+    private val LOG: Logger = LoggerFactory.getLogger(NetCopyClientConnectionPool::class.java)
+
+    @JvmField
+    var sshClientFactory: SSHClientFactory = DefaultSSHClientFactory()
+
+    @JvmField
+    var ftpClientFactory: FTPClientFactory = DefaultFTPClientFactory()
+
+    /**
+     * Obtain a [NetCopyClient] connection from the underlying connection pool.
+     *
+     *
+     * Beneath it will return the connection if it exists; otherwise it will create a new one and
+     * put it into the connection pool.
+     *
+     * @param url SSH connection URL, in the form of `
+     * ssh://<username>:<password>@<host>:<port>` or `
+     * ssh://<username>@<host>:<port>`
+     * @return [NetCopyClient] connection, already opened and authenticated
+     * @throws IOException IOExceptions that occur during connection setup
+     */
+    fun <ClientType> getConnection(url: String): NetCopyClient<ClientType>? {
+        var client = connections[url]
+        if (client == null) {
+            client = createNetCopyClient.invoke(url)
+            if (client != null) {
+                connections[extractBaseUriFrom(url)] = client
+            }
+        } else {
+            if (!validate(client)) {
+                LOG.debug("Connection no longer usable. Reconnecting...")
+                expire(client)
+                connections.remove(url)
+                client = createNetCopyClient.invoke(url)
+                if (client != null) {
+                    connections[extractBaseUriFrom(url)] = client
+                }
+            }
+        }
+        return if (client != null) {
+            client as NetCopyClient<ClientType>?
+        } else {
+            null
+        }
+    }
+
+    /**
+     * Obtain a [NetCopyClient] connection from the underlying connection pool.
+     *
+     *
+     * Beneath it will return the connection if it exists; otherwise it will create a new one and
+     * put it into the connection pool.
+     *
+     *
+     * Different from [.getConnection] above, this accepts broken down parameters as
+     * convenience method during setting up SCP/SFTP connection.
+     *
+     * @param protocol server protocol, required
+     * @param host host name/IP, required
+     * @param port remote server port, required
+     * @param hostFingerprint expected host fingerprint, required
+     * @param username username, required
+     * @param password password, required if using password to authenticate
+     * @param keyPair [KeyPair], required if using key-based authentication
+     * @return [NetCopyClient] connection
+     */
+    @Suppress("LongParameterList")
+    fun getConnection(
+        protocol: String,
+        host: String,
+        port: Int,
+        hostFingerprint: String? = null,
+        username: String,
+        password: String? = null,
+        keyPair: KeyPair? = null
+    ): NetCopyClient<*>? {
+        val url = NetCopyClientUtils.deriveUriFrom(
+            protocol,
+            host,
+            port,
+            "",
+            username,
+            password,
+            keyPair
+        )
+        var client = connections[url]
+        if (client == null) {
+            client = createNetCopyClientInternal(
+                protocol,
+                host,
+                port,
+                hostFingerprint,
+                username,
+                password,
+                keyPair
+            )
+            if (client != null) connections[url] = client
+        } else {
+            if (!validate(client)) {
+                LOG.debug("Connection no longer usable. Reconnecting...")
+                expire(client)
+                connections.remove(url)
+                client = createNetCopyClient(url)
+                if (client != null) connections[url] = client
+            }
+        }
+        return client
+    }
+
+    private val createNetCopyClient: (String) -> NetCopyClient<*>? = { url ->
+        if (url.startsWith(SSH_URI_PREFIX)) {
+            createSshClient(url)
+        } else {
+            createFtpClient(url)
+        }
+    }
+
+    private val createNetCopyClientInternal: (
+        String,
+        String,
+        Int,
+        String?,
+        String,
+        String?,
+        KeyPair?
+    ) -> NetCopyClient<*>? = { protocol, host, port, hostFingerprint, username, password, keyPair ->
+        if (protocol == SSH_URI_PREFIX) {
+            createSshClient(host, port, hostFingerprint!!, username, password, keyPair)
+        } else {
+            createFtpClient(
+                protocol,
+                host,
+                port,
+                hostFingerprint?.let { JSONObject(it) },
+                username,
+                password
+            )
+        }
+    }
+
+    /**
+     * Remove specified connection from connection pool. Disconnects from server before removing.
+     *
+     * For updating SSH/FTP connection settings.
+     *
+     * This method will silently end without feedback if the specified connection URI does not
+     * exist in the connection pool.
+     *
+     * @param url SSH connection URI
+     */
+    @SuppressLint("CheckResult")
+    fun removeConnection(url: String, callback: () -> Unit) {
+        Maybe.fromCallable(AsyncRemoveConnection(url))
+            .subscribeOn(Schedulers.io())
+            .subscribe { callback.invoke() }
+    }
+
+    /**
+     * Kill any connection that is still in place. Used by MainActivity.
+     *
+     * @see MainActivity.onDestroy
+     * @see MainActivity.exit
+     */
+    fun shutdown() {
+        AppConfig.getInstance().runInBackground {
+            if (connections.isNotEmpty()) {
+                connections.values.forEach {
+                    it.expire()
+                }
+                connections.clear()
+            }
+        }
+    }
+
+    private fun validate(client: NetCopyClient<*>): Boolean {
+        return Single.fromCallable {
+            client.isConnectionValid()
+        }.subscribeOn(NetCopyClientUtils.getScheduler(client)).blockingGet()
+    }
+
+    private fun expire(client: NetCopyClient<*>) = Flowable.fromCallable {
+        client.expire()
+    }.subscribeOn(NetCopyClientUtils.getScheduler(client))
+
+    // Logic for creating SSH connection. Depends on password existence in given Uri password or
+    // key-based authentication
+    @Suppress("TooGenericExceptionThrown")
+    private fun createSshClient(url: String): NetCopyClient<SSHClient>? {
+        val connInfo = ConnectionInfo(url)
+        val utilsHandler = AppConfig.getInstance().utilsHandler
+        val pem = utilsHandler.getSshAuthPrivateKey(url)
+        val keyPair = AtomicReference<KeyPair?>(null)
+        if (true == pem?.isNotEmpty()) {
+            keyPair.set(
+                PemToKeyPairTask(
+                    pem
+                ) { }.execute().get()
+            )
+        }
+        val hostKey = utilsHandler.getRemoteHostKey(url) ?: return null
+        return createSshClientInternal(
+            connInfo.host,
+            connInfo.port,
+            hostKey,
+            connInfo.username,
+            connInfo.password,
+            keyPair.get()
+        )
+    }
+
+    @Suppress("LongParameterList")
+    private fun createSshClient(
+        host: String,
+        port: Int,
+        hostKey: String,
+        username: String,
+        password: String?,
+        keyPair: KeyPair?
+    ): NetCopyClient<SSHClient>? {
+        return createSshClientInternal(
+            host,
+            port,
+            hostKey,
+            username,
+            password,
+            keyPair
+        )
+    }
+
+    @Suppress("LongParameterList")
+    private fun createSshClientInternal(
+        host: String,
+        port: Int,
+        hostKey: String,
+        username: String,
+        password: String?,
+        keyPair: KeyPair?
+    ): NetCopyClient<SSHClient>? {
+        val task = SshAuthenticationTask(
+            hostname = host,
+            port = port,
+            hostKey = hostKey,
+            username = username,
+            password = password,
+            privateKey = keyPair
+        )
+        val latch = CountDownLatch(1)
+        var retval: SSHClient? = null
+        Maybe.fromCallable(task.getTask())
+            .subscribeOn(Schedulers.io())
+            .subscribe({
+                retval = it
+                latch.countDown()
+            }, {
+                latch.countDown()
+                task.onError(it)
+            })
+        latch.await()
+        return retval?.let {
+            SSHClientImpl(it)
+        }
+    }
+
+    private fun createFtpClient(url: String): NetCopyClient<FTPClient>? {
+        ConnectionInfo(url).run {
+            val certInfo = if (FTPS_URI_PREFIX == prefix) {
+                AppConfig.getInstance().utilsHandler.getRemoteHostKey(url)
+            } else {
+                null
+            }
+            return createFtpClient(
+                prefix,
+                host,
+                port,
+                certInfo?.let { JSONObject(it) },
+                username,
+                password
+            )
+        }
+    }
+
+    @Suppress("LongParameterList")
+    private fun createFtpClient(
+        protocol: String,
+        host: String,
+        port: Int,
+        certInfo: JSONObject?,
+        username: String,
+        password: String?
+    ): NetCopyClient<FTPClient>? {
+        val task = FtpAuthenticationTask(
+            protocol,
+            host,
+            port,
+            certInfo,
+            username,
+            password
+        )
+        val latch = CountDownLatch(1)
+        var result: FTPClient? = null
+        Single.fromCallable(task.getTask())
+            .subscribeOn(Schedulers.io())
+            .subscribe({
+                result = it
+                latch.countDown()
+            }, {
+                latch.countDown()
+                task.onError(it)
+            })
+        latch.await()
+        return result?.let { ftpClient ->
+            FTPClientImpl(ftpClient)
+        }
+    }
+
+    /**
+     * Container object for SSH URI, encapsulating logic for splitting information from given URI.
+     * `Uri.parse()` only parse URI that is compliant to RFC2396, but we have to deal with
+     * URI that is not compliant, since usernames and/or strong passwords usually have special
+     * characters included, like `ssh://user@example.com:P@##w0rd@127.0.0.1:22`.
+     *
+     * A design decision to keep database schema slim, by the way... -TranceLove
+     */
+    internal class ConnectionInfo(url: String) {
+        val prefix: String
+        val host: String
+        val port: Int
+        val username: String
+        val password: String?
+        var defaultPath: String? = null
+        var queryString: String? = null
+
+        // FIXME: Crude assumption
+        init {
+            require(
+                url.startsWith(SSH_URI_PREFIX) or
+                    url.startsWith(FTP_URI_PREFIX) or
+                    url.startsWith(FTPS_URI_PREFIX)
+            ) {
+                "Argument is not a SSH URI: $url"
+            }
+            host = if (url.contains(AT)) {
+                url.substring(url.lastIndexOf(AT) + 1, url.lastIndexOf(COLON))
+            } else {
+                url.substring(url.lastIndexOf("//") + 2, url.lastIndexOf(COLON))
+            }
+            val portAndPath = url.substring(url.lastIndexOf(COLON) + 1)
+            var port: Int
+            if (portAndPath.contains(SLASH)) {
+                port = portAndPath.substring(0, portAndPath.indexOf(SLASH)).toInt()
+                defaultPath = portAndPath.substring(portAndPath.indexOf(SLASH))
+            } else {
+                port = portAndPath.toInt()
+                defaultPath = null
+            }
+            // If the uri is fetched from the app's database storage, we assume it will never be empty
+            prefix = when {
+                url.startsWith(SSH_URI_PREFIX) -> SSH_URI_PREFIX
+                url.startsWith(FTPS_URI_PREFIX) -> FTPS_URI_PREFIX
+                else -> FTP_URI_PREFIX
+            }
+            if (prefix != SSH_URI_PREFIX && !url.contains(AT)) {
+                username = ""
+                password = ""
+            } else {
+                val authString = url.substring(prefix.length, url.lastIndexOf(AT))
+                val userInfo = authString.split(":").toTypedArray()
+                username = userInfo[0]
+                password = if (userInfo.size > 1) {
+                    runCatching {
+                        PasswordUtil.decryptPassword(AppConfig.getInstance(), userInfo[1])
+                    }.getOrElse {
+                        /* Hack. It should only happen after creating new SSH connection settings
+                         * and plain text password is sent in.
+                         *
+                         * Possible to encrypt password there as alternate solution.
+                         */
+                        userInfo[1]
+                    }
+                } else {
+                    null
+                }
+            }
+            if (port < 0) port = if (url.startsWith(SSH_URI_PREFIX)) {
+                SSH_DEFAULT_PORT
+            } else {
+                FTP_DEFAULT_PORT
+            }
+            this.port = port
+            this.queryString = if (url.contains('?')) {
+                url.substringAfter('?')
+            } else {
+                null
+            }
+        }
+
+        override fun toString(): String {
+            return if (username != "") {
+                "$prefix$username@$host:$port${defaultPath ?: ""}"
+            } else {
+                "$prefix$host:$port${defaultPath ?: ""}"
+            }
+        }
+    }
+
+    class AsyncRemoveConnection internal constructor(
+        private val url: String
+    ) : Callable<Unit> {
+
+        override fun call() {
+            extractBaseUriFrom(url).run {
+                if (connections.containsKey(this)) {
+                    connections[this]?.expire()
+                    connections.remove(this)
+                }
+            }
+        }
+    }
+
+    /**
+     * Interface defining a factory class for creating [SSHClient] instances.
+     *
+     * In normal usage you won't need this; will be useful however when writing tests concerning
+     * SSHClient, that mocked instances can be returned so tests can be run without a real SSH
+     * server.
+     */
+    interface SSHClientFactory {
+        /**
+         * Implement this to return [SSHClient] instances.
+         */
+        fun create(config: Config): SSHClient
+    }
+
+    /**
+     * Interface defining a factory class for creating [FTPClient] instances.
+     *
+     * In normal usage you won't need this; will be useful however when writing tests concerning
+     * FTPClient, that mocked instances can be returned so tests can be run without a real FTP
+     * server.
+     */
+    interface FTPClientFactory {
+        /**
+         * Implement this to return [FTPClient] instances.
+         */
+        fun create(uri: String): FTPClient
+    }
+
+    /** Default [SSHClientFactory] implementation.  */
+    internal class DefaultSSHClientFactory : SSHClientFactory {
+        override fun create(config: Config): SSHClient {
+            return SSHClient(config)
+        }
+    }
+
+    internal class DefaultFTPClientFactory : FTPClientFactory {
+        override fun create(uri: String): FTPClient {
+            return (
+                if (uri.startsWith(FTPS_URI_PREFIX)) {
+                    FTPSClient("TLS", true)
+                } else {
+                    FTPClient()
+                }
+                ).also {
+                it.addProtocolCommandListener(Slf4jPrintCommandListener())
+                it.connectTimeout = CONNECT_TIMEOUT
+                it.controlEncoding = Charsets.UTF_8.name()
+            }
+        }
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ftp/NetCopyClientTemplate.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ftp/NetCopyClientTemplate.kt
new file mode 100644
index 000000000..af3a6660f
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ftp/NetCopyClientTemplate.kt
@@ -0,0 +1,47 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.filesystem.ftp
+
+import java.io.IOException
+
+abstract class NetCopyClientTemplate<ClientType, T>
+
+/**
+ * Constructor, with closeClientOnFinish set to true (that the connection must close after `
+ * execute`.
+ *
+ * @param url SSH connection URL, in the form of `
+ * ssh://<username>:<password>@<host>:<port>` or `
+ * ssh://<username>@<host>:<port>`
+ */
+@JvmOverloads
+constructor(@JvmField val url: String, @JvmField val closeClientOnFinish: Boolean = true) {
+
+    /**
+     * Implement logic here.
+     *
+     * @param client [NetCopyClient] instance, with connection opened and authenticated
+     * @param <T> Requested return type
+     * @return Result of the execution of the type requested </T>
+     **/
+    @Throws(IOException::class)
+    abstract fun execute(client: NetCopyClient<ClientType>): T?
+}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ftp/NetCopyClientUtils.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ftp/NetCopyClientUtils.kt
new file mode 100644
index 000000000..ae9c25845
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ftp/NetCopyClientUtils.kt
@@ -0,0 +1,286 @@
+/*
+ * Copyright (C) 2014-2021 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.filesystem.ftp
+
+import androidx.annotation.VisibleForTesting
+import androidx.annotation.WorkerThread
+import com.amaze.filemanager.application.AppConfig
+import com.amaze.filemanager.fileoperations.filesystem.DOESNT_EXIST
+import com.amaze.filemanager.fileoperations.filesystem.FolderState
+import com.amaze.filemanager.fileoperations.filesystem.WRITABLE_ON_REMOTE
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.AT
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.COLON
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.SLASH
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.SSH_URI_PREFIX
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.getConnection
+import com.amaze.filemanager.filesystem.ssh.SFtpClientTemplate
+import com.amaze.filemanager.utils.SmbUtil
+import io.reactivex.Maybe
+import io.reactivex.Scheduler
+import io.reactivex.schedulers.Schedulers
+import net.schmizz.sshj.sftp.SFTPClient
+import org.apache.commons.net.ftp.FTPClient
+import org.apache.commons.net.ftp.FTPReply
+import org.slf4j.LoggerFactory
+import java.io.IOException
+import java.net.URLDecoder
+import java.security.GeneralSecurityException
+import java.security.KeyPair
+
+object NetCopyClientUtils {
+
+    @JvmStatic
+    private val LOG = LoggerFactory.getLogger(NetCopyClientUtils::class.java)
+
+    /**
+     * Lambda to determine the [Scheduler] to use.
+     * Default is [Schedulers.io] while [Schedulers.single] is used when thread safety is required.
+     */
+    @JvmStatic
+    var getScheduler: (NetCopyClient<*>) -> Scheduler = {
+        if (it.isRequireThreadSafety()) {
+            Schedulers.single()
+        } else {
+            Schedulers.io()
+        }
+    }
+        // Allow test cases to override the Scheduler to use, or deadlocks will occur
+        // because tests are run in parallel
+        @VisibleForTesting set
+
+    /**
+     * Execute the given NetCopyClientTemplate.
+     *
+     * This template pattern is borrowed from Spring Framework, to simplify code on operations
+     * using SftpClientTemplate.
+     *
+     * @param template [NetCopyClientTemplate] to execute
+     * @param <T> Type of return value
+     * @return Template execution results
+     */
+    @WorkerThread
+    fun <ClientType, T> execute(
+        template: NetCopyClientTemplate<ClientType, T>
+    ): T? {
+        var client = getConnection<ClientType>(extractBaseUriFrom(template.url))
+        if (client == null) {
+            client = getConnection(template.url)
+        }
+        var retval: T? = null
+        if (client != null) {
+            retval = runCatching {
+                Maybe.fromCallable {
+                    template.execute(client)
+                }.subscribeOn(getScheduler.invoke(client)).blockingGet()
+            }.onFailure {
+                LOG.error("Error executing template method", it)
+            }.also {
+                if (template.closeClientOnFinish) {
+                    tryDisconnect(client)
+                }
+            }.getOrNull()
+        }
+        return retval
+    }
+
+    /**
+     * Convenience method to call [SmbUtil.getSmbEncryptedPath] if the given
+     * SSH URL contains the password (assuming the password is encrypted).
+     *
+     * @param fullUri SSH URL
+     * @return SSH URL with the password (if exists) encrypted
+     */
+    fun encryptFtpPathAsNecessary(fullUri: String): String {
+        val prefix = fullUri.substring(0, fullUri.indexOf("://") + 3)
+        val uriWithoutProtocol: String = fullUri.substring(prefix.length)
+        return if (uriWithoutProtocol.substringBefore(AT).indexOf(COLON) > 0) {
+            SmbUtil.getSmbEncryptedPath(
+                AppConfig.getInstance(),
+                fullUri
+            ).replace("\n", "")
+        } else {
+            fullUri
+        }
+    }
+
+    /**
+     * Convenience method to call [SmbUtil.getSmbDecryptedPath] if the given
+     * SSH URL contains the password (assuming the password is encrypted).
+     *
+     * @param fullUri SSH URL
+     * @return SSH URL with the password (if exists) decrypted
+     */
+    fun decryptFtpPathAsNecessary(fullUri: String): String? {
+        val prefix = fullUri.substring(0, fullUri.indexOf("://") + 3)
+        val uriWithoutProtocol: String = fullUri.substring(prefix.length)
+        return try {
+            if (uriWithoutProtocol.lastIndexOf(COLON) > 0) SmbUtil.getSmbDecryptedPath(
+                AppConfig.getInstance(),
+                fullUri
+            ) else fullUri
+        } catch (e: IOException) {
+            LOG.error("Error decrypting path", e)
+            fullUri
+        } catch (e: GeneralSecurityException) {
+            LOG.error("Error decrypting path", e)
+            fullUri
+        }
+    }
+
+    /**
+     * Convenience method to extract the Base URL from the given SSH URL.
+     *
+     *
+     * For example, given `ssh://user:password@127.0.0.1:22/home/user/foo/bar`, this
+     * method returns `ssh://user:password@127.0.0.1:22`.
+     *
+     * @param fullUri Full SSH URL
+     * @return The remote path part of the full SSH URL
+     */
+    fun extractBaseUriFrom(fullUri: String): String {
+        val prefix = fullUri.substring(0, fullUri.indexOf("://") + 3)
+        val uriWithoutProtocol: String = fullUri.substring(prefix.length)
+        val credentials: String
+        val hostAndPath: String
+        if (uriWithoutProtocol.contains(AT)) {
+            credentials = uriWithoutProtocol.substring(0, uriWithoutProtocol.lastIndexOf(AT))
+            hostAndPath = uriWithoutProtocol.substring(uriWithoutProtocol.lastIndexOf(AT) + 1)
+        } else {
+            credentials = ""
+            hostAndPath = uriWithoutProtocol
+        }
+        return if (hostAndPath.indexOf(SLASH) == -1) {
+            fullUri
+        } else {
+            val host = hostAndPath.substring(0, hostAndPath.indexOf(SLASH))
+            val credentialsLen = if (credentials == "") {
+                0
+            } else {
+                credentials.length + 1
+            }
+            fullUri.substring(
+                0,
+                prefix.length + credentialsLen + host.length
+            )
+        }
+    }
+
+    /**
+     * Convenience method to extract the remote path from the given SSH URL.
+     *
+     *
+     * For example, given `ssh://user:password@127.0.0.1:22/home/user/foo/bar`, this
+     * method returns `/home/user/foo/bar`.
+     *
+     * @param fullUri Full SSH URL
+     * @return The remote path part of the full SSH URL
+     */
+    fun extractRemotePathFrom(fullUri: String): String {
+        if (fullUri.contains(AT)) {
+            val hostPath = fullUri.substring(fullUri.lastIndexOf(AT))
+            return if (hostPath.indexOf(SLASH) == -1) {
+                SLASH.toString()
+            } else {
+                URLDecoder.decode(
+                    hostPath.substring(hostPath.indexOf(SLASH)),
+                    Charsets.UTF_8.name()
+                )
+            }
+        } else {
+            val hostAndPath = fullUri.substringAfter("://")
+            return if (hostAndPath.contains(SLASH)) {
+                hostAndPath.substring(hostAndPath.indexOf(SLASH))
+            } else {
+                SLASH.toString()
+            }
+        }
+    }
+
+    /**
+     * Disconnects the given [NetCopyClient] but wrap all exceptions beneath, so callers are free
+     * from the hassles of handling thrown exceptions.
+     *
+     * @param client [NetCopyClient] instance
+     */
+    private fun tryDisconnect(client: NetCopyClient<*>) {
+        if (client.isConnectionValid()) {
+            client.expire()
+        }
+    }
+
+    /**
+     * Decide the SSH URL depends on password/selected KeyPair.
+     */
+    @Suppress("LongParameterList")
+    fun deriveUriFrom(
+        prefix: String,
+        hostname: String,
+        port: Int,
+        defaultPath: String? = null,
+        username: String,
+        password: String? = null,
+        selectedParsedKeyPair: KeyPair? = null
+    ): String {
+        // FIXME: should be caller's responsibility
+        var pathSuffix = defaultPath
+        if (pathSuffix == null) pathSuffix = SLASH.toString()
+        return if (selectedParsedKeyPair != null) {
+            "$prefix$username@$hostname:$port$pathSuffix"
+        } else if (username == "" && (password == "" || password == null)) {
+            "$prefix$hostname:$port$pathSuffix"
+        } else {
+            "$prefix$username:$password@$hostname:$port$pathSuffix"
+        }
+    }
+
+    /**
+     * Check folder existence on remote.
+     */
+    @FolderState
+    fun checkFolder(path: String): Int {
+        val template: NetCopyClientTemplate<*, Int> = if (path.startsWith(SSH_URI_PREFIX)) {
+            object : SFtpClientTemplate<Int>(extractBaseUriFrom(path), false) {
+                @FolderState
+                @Throws(IOException::class)
+                override fun execute(client: SFTPClient): Int {
+                    return if (client.statExistence(extractRemotePathFrom(path)) == null) {
+                        WRITABLE_ON_REMOTE
+                    } else {
+                        DOESNT_EXIST
+                    }
+                }
+            }
+        } else {
+            object : FtpClientTemplate<Int>(extractBaseUriFrom(path), false) {
+                override fun executeWithFtpClient(ftpClient: FTPClient): Int {
+                    return if (ftpClient.stat(extractRemotePathFrom(path))
+                        == FTPReply.DIRECTORY_STATUS
+                    ) {
+                        WRITABLE_ON_REMOTE
+                    } else {
+                        DOESNT_EXIST
+                    }
+                }
+            }
+        }
+        return execute(template) ?: DOESNT_EXIST
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ftp/SSHClientImpl.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ftp/SSHClientImpl.kt
new file mode 100644
index 000000000..ad2bf887c
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ftp/SSHClientImpl.kt
@@ -0,0 +1,48 @@
+/*
+ * Copyright (C) 2014-2021 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.filesystem.ftp
+
+import net.schmizz.sshj.SSHClient
+import org.slf4j.Logger
+import org.slf4j.LoggerFactory
+
+class SSHClientImpl(private val sshClient: SSHClient) : NetCopyClient<SSHClient> {
+
+    companion object {
+        @JvmStatic
+        private val logger: Logger = LoggerFactory.getLogger(SSHClientImpl::class.java)
+    }
+
+    override fun getClientImpl() = sshClient
+
+    override fun isConnectionValid(): Boolean =
+        sshClient.isConnected && sshClient.isAuthenticated
+
+    override fun expire() {
+        if (sshClient.isConnected) {
+            runCatching {
+                sshClient.disconnect()
+            }.onFailure {
+                logger.warn("Error closing SSHClient connection", it)
+            }
+        }
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ftp/Slf4jPrintCommandListener.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ftp/Slf4jPrintCommandListener.kt
new file mode 100644
index 000000000..18167640f
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ftp/Slf4jPrintCommandListener.kt
@@ -0,0 +1,97 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.filesystem.ftp
+
+import org.apache.commons.net.ProtocolCommandEvent
+import org.apache.commons.net.ProtocolCommandListener
+import org.apache.commons.net.SocketClient
+import org.slf4j.Logger
+import org.slf4j.LoggerFactory
+import org.slf4j.event.Level
+
+/**
+ * [ProtocolCommandListener] that logs output to a slf4j [Logger].
+ *
+ * Can adjust the logger level by specifying the [loggerLevel] parameter.
+ */
+internal class Slf4jPrintCommandListener(
+    private val nologin: Boolean = true,
+    private val eolMarker: Char = 0.toChar(),
+    private val directionMarker: Boolean = false,
+    private val loggerLevel: Level = Level.DEBUG
+) :
+    ProtocolCommandListener {
+
+    private val logger: Logger = LoggerFactory.getLogger(SocketClient::class.java)
+
+    private val logMessage: (String) -> Unit = { msg ->
+        when (loggerLevel) {
+            Level.INFO -> logger.info(msg)
+            Level.DEBUG -> logger.debug(msg)
+            Level.ERROR -> logger.error(msg)
+            Level.WARN -> logger.warn(msg)
+            Level.TRACE -> logger.trace(msg)
+        }
+    }
+
+    override fun protocolCommandSent(event: ProtocolCommandEvent) {
+        val sb = StringBuilder()
+        if (directionMarker) {
+            sb.append("> ")
+        }
+        if (nologin) {
+            val cmd = event.command
+            if ("PASS".equals(cmd, ignoreCase = true) || "USER".equals(cmd, ignoreCase = true)) {
+                sb.append(cmd)
+                sb.append(" *******") // Don't bother with EOL marker for this!
+            } else {
+                sb.append(getPrintableString(event.message))
+            }
+        } else {
+            sb.append(getPrintableString(event.message))
+        }
+        logMessage.invoke(sb.toString())
+    }
+
+    override fun protocolReplyReceived(event: ProtocolCommandEvent) {
+        val msg = if (directionMarker) {
+            "< ${event.message}"
+        } else {
+            event.message
+        }
+        logMessage.invoke(msg)
+    }
+
+    private fun getPrintableString(msg: String): String {
+        if (eolMarker.code == 0) {
+            return msg
+        }
+        val pos = msg.indexOf(SocketClient.NETASCII_EOL)
+        if (pos > 0) {
+            val sb = StringBuilder()
+            sb.append(msg.substring(0, pos))
+            sb.append(eolMarker)
+            sb.append(msg.substring(pos))
+            return sb.toString()
+        }
+        return msg
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SFtpClientTemplate.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SFtpClientTemplate.kt
index 365f00ef3..046929bdd 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SFtpClientTemplate.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SFtpClientTemplate.kt
@@ -20,22 +20,40 @@
 
 package com.amaze.filemanager.filesystem.ssh
 
+import net.schmizz.sshj.SSHClient
 import net.schmizz.sshj.sftp.SFTPClient
+import org.slf4j.Logger
+import org.slf4j.LoggerFactory
 import java.io.IOException
 
 /**
  * Template class for executing actions with [SFTPClient] while leave the complexities of
  * handling connection and session setup/teardown to [SshClientUtils].
  */
-abstract class SFtpClientTemplate<T>
-/**
- * If closeClientOnFinish is set to true, calling code needs to handle closing of [ ] session.
- *
- * @param url SSH connection URL, in the form of `
- * ssh://<username>:<password>@<host>:<port>` or `
- * ssh://<username>@<host>:<port>`
- */ @JvmOverloads
-constructor(@JvmField val url: String, @JvmField val closeClientOnFinish: Boolean = true) {
+abstract class SFtpClientTemplate<T>(url: String, closeClientOnFinish: Boolean = true) :
+    SshClientTemplate<T>(url, closeClientOnFinish) {
+
+    private val LOG: Logger = LoggerFactory.getLogger(javaClass)
+
+    override fun executeWithSSHClient(sshClient: SSHClient): T? {
+        var sftpClient: SFTPClient? = null
+        var retval: T? = null
+        try {
+            sftpClient = sshClient.newSFTPClient()
+            retval = execute(sftpClient)
+        } catch (e: IOException) {
+            LOG.error("Error executing template method", e)
+        } finally {
+            if (sftpClient != null && closeClientOnFinish) {
+                try {
+                    sftpClient.close()
+                } catch (e: IOException) {
+                    LOG.warn("Error closing SFTP client", e)
+                }
+            }
+        }
+        return retval
+    }
 
     /**
      * Implement logic here.
@@ -46,5 +64,5 @@ constructor(@JvmField val url: String, @JvmField val closeClientOnFinish: Boolea
      * @return Result of the execution of the type requested
      */
     @Throws(IOException::class)
-    abstract fun execute(client: SFTPClient): T
+    abstract fun execute(client: SFTPClient): T?
 }
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientTemplate.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientTemplate.kt
index 96077f2af..2d56ac0be 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientTemplate.kt
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientTemplate.kt
@@ -20,7 +20,8 @@
 
 package com.amaze.filemanager.filesystem.ssh
 
-import androidx.annotation.Nullable
+import com.amaze.filemanager.filesystem.ftp.NetCopyClient
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientTemplate
 import net.schmizz.sshj.SSHClient
 import java.io.IOException
 
@@ -28,17 +29,14 @@ import java.io.IOException
  * Template class for executing actions with [SSHClient] while leave the complexities of
  * handling connection setup/teardown to [SshClientUtils].
  */
-abstract class SshClientTemplate<T>
-/**
- * Constructor, with closeClientOnFinish set to true (that the connection must close after `
- * execute`.
- *
- * @param url SSH connection URL, in the form of `
- * ssh://<username>:<password>@<host>:<port>` or `
- * ssh://<username>@<host>:<port>`
- */
-@JvmOverloads
-constructor(@JvmField val url: String, @JvmField val closeClientOnFinish: Boolean = true) {
+abstract class SshClientTemplate<T>(url: String, closeClientOnFinish: Boolean = true) :
+    NetCopyClientTemplate<SSHClient, T>(url, closeClientOnFinish) {
+
+    @Throws(IOException::class)
+    final override fun execute(client: NetCopyClient<SSHClient>): T? {
+        val sshClient: SSHClient = client.getClientImpl()
+        return executeWithSSHClient(sshClient)
+    }
 
     /**
      * Implement logic here.
@@ -48,6 +46,5 @@ constructor(@JvmField val url: String, @JvmField val closeClientOnFinish: Boolea
      * @return Result of the execution of the type requested
      </T> */
     @Throws(IOException::class)
-    @Nullable
-    abstract fun execute(client: SSHClient): T
+    abstract fun executeWithSSHClient(client: SSHClient): T?
 }
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientUtils.java b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientUtils.java
index 750035467..8af4363fa 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshClientUtils.java
@@ -20,14 +20,8 @@
 
 package com.amaze.filemanager.filesystem.ssh;
 
-import static com.amaze.filemanager.fileoperations.filesystem.FolderStateKt.DOESNT_EXIST;
-import static com.amaze.filemanager.fileoperations.filesystem.FolderStateKt.WRITABLE_ON_REMOTE;
-import static com.amaze.filemanager.filesystem.ssh.SshConnectionPool.SSH_URI_PREFIX;
-
 import java.io.File;
 import java.io.IOException;
-import java.security.GeneralSecurityException;
-import java.security.KeyPair;
 import java.util.ArrayList;
 import java.util.List;
 
@@ -35,16 +29,13 @@ import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.application.AppConfig;
-import com.amaze.filemanager.fileoperations.filesystem.FolderState;
 import com.amaze.filemanager.fileoperations.filesystem.cloud.CloudStreamer;
 import com.amaze.filemanager.filesystem.HybridFile;
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientUtils;
 import com.amaze.filemanager.ui.activities.MainActivity;
 import com.amaze.filemanager.ui.icons.MimeTypes;
-import com.amaze.filemanager.utils.SmbUtil;
 
 import android.content.ActivityNotFoundException;
-import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageManager;
 import android.content.pm.ResolveInfo;
@@ -54,8 +45,6 @@ import android.widget.Toast;
 import androidx.annotation.NonNull;
 import androidx.annotation.Nullable;
 
-import io.reactivex.Single;
-import io.reactivex.schedulers.Schedulers;
 import net.schmizz.sshj.SSHClient;
 import net.schmizz.sshj.connection.channel.direct.Session;
 import net.schmizz.sshj.sftp.FileAttributes;
@@ -67,40 +56,6 @@ public abstract class SshClientUtils {
 
   private static final Logger LOG = LoggerFactory.getLogger(SshClientUtils.class);
 
-  /**
-   * Execute the given SshClientTemplate.
-   *
-   * <p>This template pattern is borrowed from Spring Framework, to simplify code on operations
-   * using SftpClientTemplate.
-   *
-   * @param template {@link SshClientTemplate} to execute
-   * @param <T> Type of return value
-   * @return Template execution results
-   */
-  public static <T> T execute(@NonNull SshClientTemplate<T> template) {
-    SSHClient client = SshConnectionPool.INSTANCE.getConnection(extractBaseUriFrom(template.url));
-    if (client == null) {
-      client = SshConnectionPool.INSTANCE.getConnection(template.url);
-    }
-    T retval = null;
-    if (client != null) {
-      final SSHClient _client = client;
-      try {
-        retval =
-            Single.fromCallable(() -> template.execute(_client))
-                .subscribeOn(Schedulers.io())
-                .blockingGet();
-      } catch (Exception e) {
-        LOG.error("Error executing template method", e);
-      } finally {
-        if (template.closeClientOnFinish) {
-          tryDisconnect(client);
-        }
-      }
-    }
-    return retval;
-  }
-
   /**
    * Execute the given template with SshClientTemplate.
    *
@@ -109,14 +64,14 @@ public abstract class SshClientUtils {
    * @return Template execution results
    */
   public static <T> T execute(@NonNull final SshClientSessionTemplate<T> template) {
-    return execute(
+    return NetCopyClientUtils.INSTANCE.execute(
         new SshClientTemplate<T>(template.url, false) {
           @Override
-          public T execute(SSHClient client) {
+          public T executeWithSSHClient(@NonNull SSHClient sshClient) {
             Session session = null;
             T retval = null;
             try {
-              session = client.startSession();
+              session = sshClient.startSession();
               retval = template.execute(session);
             } catch (IOException e) {
               LOG.error("Error executing template method", e);
@@ -143,15 +98,15 @@ public abstract class SshClientUtils {
    */
   @Nullable
   public static <T> T execute(@NonNull final SFtpClientTemplate<T> template) {
-    final SshClientTemplate<T> sshClient =
+    final SshClientTemplate<T> ftpClientTemplate =
         new SshClientTemplate<T>(template.url, false) {
           @Override
           @Nullable
-          public T execute(SSHClient client) {
+          public T executeWithSSHClient(SSHClient sshClient) {
             SFTPClient sftpClient = null;
             T retval = null;
             try {
-              sftpClient = client.newSFTPClient();
+              sftpClient = sshClient.newSFTPClient();
               retval = template.execute(sftpClient);
             } catch (IOException e) {
               LOG.error("Error executing template method", e);
@@ -168,83 +123,7 @@ public abstract class SshClientUtils {
           }
         };
 
-    return execute(sshClient);
-  }
-
-  /**
-   * Convenience method to call {@link SmbUtil#getSmbEncryptedPath(Context, String)} if the given
-   * SSH URL contains the password (assuming the password is encrypted).
-   *
-   * @param fullUri SSH URL
-   * @return SSH URL with the password (if exists) encrypted
-   */
-  public static String encryptSshPathAsNecessary(@NonNull String fullUri) {
-    String uriWithoutProtocol =
-        fullUri.substring(SSH_URI_PREFIX.length(), fullUri.lastIndexOf('@'));
-    try {
-      return (uriWithoutProtocol.lastIndexOf(':') > 0)
-          ? SmbUtil.getSmbEncryptedPath(AppConfig.getInstance(), fullUri).replace("\n", "")
-          : fullUri;
-    } catch (IOException | GeneralSecurityException e) {
-      LOG.error("Error encrypting path", e);
-      return fullUri;
-    }
-  }
-
-  /**
-   * Convenience method to call {@link SmbUtil#getSmbDecryptedPath(Context, String)} if the given
-   * SSH URL contains the password (assuming the password is encrypted).
-   *
-   * @param fullUri SSH URL
-   * @return SSH URL with the password (if exists) decrypted
-   */
-  public static String decryptSshPathAsNecessary(@NonNull String fullUri) {
-    String uriWithoutProtocol =
-        fullUri.substring(SSH_URI_PREFIX.length(), fullUri.lastIndexOf('@'));
-    try {
-      return (uriWithoutProtocol.lastIndexOf(':') > 0)
-          ? SmbUtil.getSmbDecryptedPath(AppConfig.getInstance(), fullUri)
-          : fullUri;
-    } catch (IOException | GeneralSecurityException e) {
-      LOG.error("Error decrypting path", e);
-      return fullUri;
-    }
-  }
-
-  /**
-   * Convenience method to extract the Base URL from the given SSH URL.
-   *
-   * <p>For example, given <code>ssh://user:password@127.0.0.1:22/home/user/foo/bar</code>, this
-   * method returns <code>ssh://user:password@127.0.0.1:22</code>.
-   *
-   * @param fullUri Full SSH URL
-   * @return The remote path part of the full SSH URL
-   */
-  public static String extractBaseUriFrom(@NonNull String fullUri) {
-    String uriWithoutProtocol = fullUri.substring(SSH_URI_PREFIX.length());
-    String credentials = uriWithoutProtocol.substring(0, uriWithoutProtocol.lastIndexOf('@'));
-    String hostAndPath = uriWithoutProtocol.substring(uriWithoutProtocol.lastIndexOf('@') + 1);
-    if (hostAndPath.indexOf('/') == -1) {
-      return fullUri;
-    } else {
-      String host = hostAndPath.substring(0, hostAndPath.indexOf('/'));
-      return fullUri.substring(
-          0, SSH_URI_PREFIX.length() + credentials.length() + 1 + host.length());
-    }
-  }
-
-  /**
-   * Convenience method to extract the remote path from the given SSH URL.
-   *
-   * <p>For example, given <code>ssh://user:password@127.0.0.1:22/home/user/foo/bar</code>, this
-   * method returns <code>/home/user/foo/bar</code>.
-   *
-   * @param fullUri Full SSH URL
-   * @return The remote path part of the full SSH URL
-   */
-  public static String extractRemotePathFrom(@NonNull String fullUri) {
-    String hostPath = fullUri.substring(fullUri.lastIndexOf('@'));
-    return hostPath.indexOf('/') == -1 ? "/" : hostPath.substring(hostPath.indexOf('/'));
+    return NetCopyClientUtils.INSTANCE.execute(ftpClientTemplate);
   }
 
   /**
@@ -289,28 +168,28 @@ public abstract class SshClientUtils {
     }
   }
 
-  public static void launchSftp(final HybridFile baseFile, final MainActivity activity) {
+  public static void launchFtp(final HybridFile baseFile, final MainActivity activity) {
     final CloudStreamer streamer = CloudStreamer.getInstance();
 
     new Thread(
             () -> {
               try {
+                boolean isDirectory = baseFile.isDirectory(activity);
+                long fileLength = baseFile.length(activity);
                 streamer.setStreamSrc(
-                    baseFile.getInputStream(activity),
-                    baseFile.getName(activity),
-                    baseFile.length(activity));
+                    baseFile.getInputStream(activity), baseFile.getName(activity), fileLength);
                 activity.runOnUiThread(
                     () -> {
                       try {
                         File file =
-                            new File(SshClientUtils.extractRemotePathFrom(baseFile.getPath()));
+                            new File(
+                                NetCopyClientUtils.INSTANCE.extractRemotePathFrom(
+                                    baseFile.getPath()));
                         Uri uri =
                             Uri.parse(CloudStreamer.URL + Uri.fromFile(file).getEncodedPath());
                         Intent i = new Intent(Intent.ACTION_VIEW);
                         i.setDataAndType(
-                            uri,
-                            MimeTypes.getMimeType(
-                                baseFile.getPath(), baseFile.isDirectory(activity)));
+                            uri, MimeTypes.getMimeType(baseFile.getPath(), isDirectory));
                         PackageManager packageManager = activity.getPackageManager();
                         List<ResolveInfo> resInfos = packageManager.queryIntentActivities(i, 0);
                         if (resInfos != null && resInfos.size() > 0) activity.startActivity(i);
@@ -331,22 +210,6 @@ public abstract class SshClientUtils {
         .start();
   }
 
-  // Decide the SSH URL depends on password/selected KeyPair
-  public static String deriveSftpPathFrom(
-      @NonNull String hostname,
-      int port,
-      @Nullable String defaultPath,
-      @NonNull String username,
-      @Nullable String password,
-      @Nullable KeyPair selectedParsedKeyPair) {
-    // FIXME: should be caller's responsibility
-    String pathSuffix = defaultPath;
-    if (pathSuffix == null) pathSuffix = "/";
-    return (selectedParsedKeyPair != null || password == null)
-        ? String.format("ssh://%s@%s:%d%s", username, hostname, port, pathSuffix)
-        : String.format("ssh://%s:%s@%s:%d%s", username, password, hostname, port, pathSuffix);
-  }
-
   public static boolean isDirectory(@NonNull SFTPClient client, @NonNull RemoteResourceInfo info)
       throws IOException {
     boolean isDirectory = info.isDirectory();
@@ -361,21 +224,4 @@ public abstract class SshClientUtils {
     }
     return isDirectory;
   }
-
-  public static @FolderState int checkFolder(@NonNull String path) {
-    return Single.fromCallable(
-            () ->
-                execute(
-                    new SFtpClientTemplate<Integer>(extractBaseUriFrom(path)) {
-                      @Override
-                      public @FolderState Integer execute(@NonNull SFTPClient client)
-                          throws IOException {
-                        return (client.statExistence(extractRemotePathFrom(path)) == null)
-                            ? WRITABLE_ON_REMOTE
-                            : DOESNT_EXIST;
-                      }
-                    }))
-        .subscribeOn(Schedulers.io())
-        .blockingGet();
-  }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPool.kt b/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPool.kt
deleted file mode 100644
index 564b2755a..000000000
--- a/app/src/main/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPool.kt
+++ /dev/null
@@ -1,324 +0,0 @@
-/*
- * Copyright (C) 2014-2021 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
- * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
- *
- * This file is part of Amaze File Manager.
- *
- * Amaze File Manager is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.amaze.filemanager.filesystem.ssh
-
-import android.os.AsyncTask
-import android.util.Log
-import com.amaze.filemanager.application.AppConfig
-import com.amaze.filemanager.asynchronous.asynctasks.ssh.PemToKeyPairTask
-import com.amaze.filemanager.asynchronous.asynctasks.ssh.SshAuthenticationTask
-import com.amaze.filemanager.filesystem.ssh.SshClientUtils.extractBaseUriFrom
-import com.amaze.filemanager.utils.PasswordUtil
-import net.schmizz.sshj.Config
-import net.schmizz.sshj.SSHClient
-import java.security.KeyPair
-import java.util.concurrent.ConcurrentHashMap
-import java.util.concurrent.ExecutionException
-import java.util.concurrent.atomic.AtomicReference
-
-/**
- * Poor man's implementation of SSH connection pool.
- *
- *
- * It uses a [ConcurrentHashMap] to hold the opened SSH connections; all code that uses
- * [SSHClient] can ask for connection here with `getConnection(url)`.
- */
-object SshConnectionPool {
-
-    const val SSH_DEFAULT_PORT = 22
-    const val SSH_URI_PREFIX = "ssh://"
-    const val SSH_CONNECT_TIMEOUT = 30000
-
-    private val TAG = SshConnectionPool::class.java.simpleName
-
-    private var connections: MutableMap<String, SSHClient> = ConcurrentHashMap()
-
-    @JvmField
-    var sshClientFactory: SSHClientFactory = DefaultSSHClientFactory()
-
-    /**
-     * Remove a SSH connection from connection pool. Disconnects from server before removing.
-     *
-     *
-     * For updating SSH connection settings.
-     *
-     *
-     * This method will silently end without feedback if the specified SSH connection URI does not
-     * exist in the connection pool.
-     *
-     * @param url SSH connection URI
-     */
-    fun removeConnection(url: String, callback: Runnable) {
-        AsyncRemoveConnection(url, callback).execute()
-    }
-
-    /**
-     * Obtain a [SSHClient] connection from the underlying connection pool.
-     *
-     *
-     * Beneath it will return the connection if it exists; otherwise it will create a new one and
-     * put it into the connection pool.
-     *
-     * @param url SSH connection URL, in the form of `
-     * ssh://<username>:<password>@<host>:<port>` or `
-     * ssh://<username>@<host>:<port>`
-     * @return [SSHClient] connection, already opened and authenticated
-     * @throws IOException IOExceptions that occur during connection setup
-     */
-    fun getConnection(url: String): SSHClient? {
-        var client = connections[url]
-        if (client == null) {
-            client = create(url)
-            if (client != null) {
-                connections[extractBaseUriFrom(url)] = client
-            }
-        } else {
-            if (!validate(client)) {
-                Log.d(TAG, "Connection no longer usable. Reconnecting...")
-                expire(client)
-                connections.remove(url)
-                client = create(url)
-                if (client != null) {
-                    connections[extractBaseUriFrom(url)] = client
-                }
-            }
-        }
-        return client
-    }
-
-    /**
-     * Obtain a [SSHClient] connection from the underlying connection pool.
-     *
-     *
-     * Beneath it will return the connection if it exists; otherwise it will create a new one and
-     * put it into the connection pool.
-     *
-     *
-     * Different from [.getConnection] above, this accepts broken down parameters as
-     * convenience method during setting up SCP/SFTP connection.
-     *
-     * @param host host name/IP, required
-     * @param port SSH server port, required
-     * @param hostFingerprint expected host fingerprint, required
-     * @param username username, required
-     * @param password password, required if using password to authenticate
-     * @param keyPair [KeyPair], required if using key-based authentication
-     * @return [SSHClient] connection
-     */
-    @Suppress("LongParameterList")
-    fun getConnection(
-        host: String,
-        port: Int,
-        hostFingerprint: String,
-        username: String,
-        password: String?,
-        keyPair: KeyPair?
-    ): SSHClient? {
-        val url = SshClientUtils.deriveSftpPathFrom(host, port, "", username, password, keyPair)
-        var client = connections[url]
-        if (client == null) {
-            client = create(host, port, hostFingerprint, username, password, keyPair)
-            if (client != null) connections[url] = client
-        } else {
-            if (!validate(client)) {
-                Log.d(TAG, "Connection no longer usable. Reconnecting...")
-                expire(client)
-                connections.remove(url)
-                client = create(host, port, hostFingerprint, username, password, keyPair)
-                if (client != null) connections[url] = client
-            }
-        }
-        return client
-    }
-
-    /**
-     * Kill any connection that is still in place. Used by [ ].
-     *
-     * @see MainActivity.onDestroy
-     * @see MainActivity.exit
-     */
-    fun shutdown() {
-        AppConfig.getInstance()
-            .runInBackground {
-                if (!connections.isEmpty()) {
-                    for (connection in connections.values) {
-                        SshClientUtils.tryDisconnect(connection)
-                    }
-                    connections.clear()
-                }
-            }
-    }
-
-    // Logic for creating SSH connection. Depends on password existence in given Uri password or
-    // key-based authentication
-    @Suppress("TooGenericExceptionThrown")
-    private fun create(url: String): SSHClient? {
-        val connInfo = ConnectionInfo(url)
-        val utilsHandler = AppConfig.getInstance().utilsHandler
-        val pem = utilsHandler.getSshAuthPrivateKey(url)
-        val keyPair = AtomicReference<KeyPair?>(null)
-        if (true == pem?.isNotEmpty()) {
-            keyPair.set(
-                PemToKeyPairTask(
-                    pem
-                ) { }.execute().get()
-            )
-        }
-        val hostKey = utilsHandler.getSshHostKey(url) ?: return null
-        return create(
-            connInfo.host,
-            connInfo.port,
-            hostKey,
-            connInfo.username,
-            connInfo.password,
-            keyPair.get()
-        )
-    }
-
-    @Suppress("LongParameterList")
-    private fun create(
-        host: String,
-        port: Int,
-        hostKey: String,
-        username: String,
-        password: String?,
-        keyPair: KeyPair?
-    ): SSHClient? {
-        return try {
-            val taskResult = SshAuthenticationTask(
-                hostname = host,
-                port = port,
-                hostKey = hostKey,
-                username = username,
-                password = password,
-                privateKey = keyPair
-            ).execute().get()
-            taskResult.result
-        } catch (e: InterruptedException) {
-            // FIXME: proper handling
-            throw RuntimeException(e)
-        } catch (e: ExecutionException) {
-            // FIXME: proper handling
-            throw RuntimeException(e)
-        }
-    }
-
-    private fun validate(client: SSHClient): Boolean {
-        return client.isConnected && client.isAuthenticated
-    }
-
-    private fun expire(client: SSHClient) {
-        SshClientUtils.tryDisconnect(client)
-    }
-
-    /**
-     * Container object for SSH URI, encapsulating logic for splitting information from given URI.
-     * `Uri.parse()` only parse URI that is compliant to RFC2396, but we have to deal with
-     * URI that is not compliant, since usernames and/or strong passwords usually have special
-     * characters included, like `ssh://user@example.com:P@##w0rd@127.0.0.1:22`.
-     *
-     *
-     * A design decision to keep database schema slim, by the way... -TranceLove
-     */
-    class ConnectionInfo(url: String) {
-        val host: String
-        val port: Int
-        val username: String
-        val password: String?
-        var defaultPath: String? = null
-
-        // FIXME: Crude assumption
-        init {
-            require(url.startsWith(SSH_URI_PREFIX)) { "Argument is not a SSH URI: $url" }
-            host = url.substring(url.lastIndexOf('@') + 1, url.lastIndexOf(':'))
-            val portAndPath = url.substring(url.lastIndexOf(':') + 1)
-            var port = SSH_DEFAULT_PORT
-            if (portAndPath.contains("/")) {
-                port = portAndPath.substring(0, portAndPath.indexOf('/')).toInt()
-                defaultPath = portAndPath.substring(portAndPath.indexOf('/'))
-            } else {
-                port = portAndPath.toInt()
-                defaultPath = null
-            }
-            // If the uri is fetched from the app's database storage, we assume it will never be empty
-            val authString = url.substring(SSH_URI_PREFIX.length, url.lastIndexOf('@'))
-            val userInfo = authString.split(":").toTypedArray()
-            username = userInfo[0]
-            password = if (userInfo.size > 1) {
-                runCatching {
-                    PasswordUtil.decryptPassword(AppConfig.getInstance(), userInfo[1])!!
-                }.getOrElse {
-                    /* Hack. It should only happen after creating new SSH connection settings
-                     * and plain text password is sent in.
-                     *
-                     * Possible to encrypt password there as alternate solution.
-                     */
-                    userInfo[1]
-                }
-            } else {
-                null
-            }
-            if (port < 0) port = SSH_DEFAULT_PORT
-            this.port = port
-        }
-
-        override fun toString(): String {
-            return "${SSH_URI_PREFIX}$username@$host:$port${defaultPath ?: ""}"
-        }
-    }
-
-    class AsyncRemoveConnection internal constructor(
-        private var url: String,
-        private val callback: Runnable?
-    ) : AsyncTask<Unit, Unit, Unit>() {
-
-        override fun doInBackground(vararg params: Unit) {
-            url = SshClientUtils.extractBaseUriFrom(url)
-            if (connections.containsKey(url)) {
-                SshClientUtils.tryDisconnect(connections.remove(url))
-            }
-        }
-
-        override fun onPostExecute(aVoid: Unit) {
-            callback?.run()
-        }
-    }
-
-    /**
-     * Interface defining a factory class for creating [SSHClient] instances.
-     *
-     * In normal usage you won't need this; will be useful however when writing tests concerning
-     * SSHClient, that mocked instances can be returned so tests can be run without a real SSH server.
-     */
-    interface SSHClientFactory {
-        /**
-         * Implement this to return [SSHClient] instances.
-         */
-        fun create(config: Config?): SSHClient
-    }
-
-    /** Default [SSHClientFactory] implementation.  */
-    internal class DefaultSSHClientFactory : SSHClientFactory {
-        override fun create(config: Config?): SSHClient {
-            return SSHClient(config)
-        }
-    }
-}
diff --git a/app/src/main/java/com/amaze/filemanager/ui/activities/MainActivity.java b/app/src/main/java/com/amaze/filemanager/ui/activities/MainActivity.java
index ef78934b0..e3abdbb94 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/activities/MainActivity.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/activities/MainActivity.java
@@ -46,6 +46,7 @@ import static com.amaze.filemanager.ui.dialogs.SftpConnectDialog.ARG_KEYPAIR_NAM
 import static com.amaze.filemanager.ui.dialogs.SftpConnectDialog.ARG_NAME;
 import static com.amaze.filemanager.ui.dialogs.SftpConnectDialog.ARG_PASSWORD;
 import static com.amaze.filemanager.ui.dialogs.SftpConnectDialog.ARG_PORT;
+import static com.amaze.filemanager.ui.dialogs.SftpConnectDialog.ARG_PROTOCOL;
 import static com.amaze.filemanager.ui.dialogs.SftpConnectDialog.ARG_USERNAME;
 import static com.amaze.filemanager.ui.fragments.FtpServerFragment.REQUEST_CODE_SAF_FTP;
 import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_BOOKMARKS_ADDED;
@@ -98,8 +99,8 @@ import com.amaze.filemanager.filesystem.MakeFileOperation;
 import com.amaze.filemanager.filesystem.PasteHelper;
 import com.amaze.filemanager.filesystem.RootHelper;
 import com.amaze.filemanager.filesystem.files.FileUtils;
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool;
 import com.amaze.filemanager.filesystem.ssh.SshClientUtils;
-import com.amaze.filemanager.filesystem.ssh.SshConnectionPool;
 import com.amaze.filemanager.ui.ExtensionsKt;
 import com.amaze.filemanager.ui.activities.superclasses.PermissionsActivity;
 import com.amaze.filemanager.ui.dialogs.AlertDialog;
@@ -148,6 +149,7 @@ import com.leinardi.android.speeddial.SpeedDialView;
 import com.readystatesoftware.systembartint.SystemBarTintManager;
 import com.topjohnwu.superuser.Shell;
 
+import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.BroadcastReceiver;
@@ -196,6 +198,7 @@ import androidx.loader.content.Loader;
 
 import io.reactivex.Completable;
 import io.reactivex.CompletableObserver;
+import io.reactivex.Flowable;
 import io.reactivex.android.schedulers.AndroidSchedulers;
 import io.reactivex.disposables.Disposable;
 import io.reactivex.schedulers.Schedulers;
@@ -934,7 +937,7 @@ public class MainActivity extends PermissionsActivity
 
   public void exit() {
     if (backPressedToExitOnce) {
-      SshConnectionPool.INSTANCE.shutdown();
+      NetCopyClientConnectionPool.INSTANCE.shutdown();
       finish();
       if (isRootExplorer()) {
         closeInteractiveShell();
@@ -1404,7 +1407,7 @@ public class MainActivity extends PermissionsActivity
     // TODO: 6/5/2017 Android may choose to not call this method before destruction
     // TODO: https://developer.android.com/reference/android/app/Activity.html#onDestroy%28%29
     closeInteractiveShell();
-    SshConnectionPool.INSTANCE.shutdown();
+    NetCopyClientConnectionPool.INSTANCE.shutdown();
     if (drawer != null && drawer.getBilling() != null) {
       drawer.getBilling().destroyBillingInstance();
     }
@@ -1955,33 +1958,44 @@ public class MainActivity extends PermissionsActivity
     smbConnectDialog.show(getFragmentManager(), "smbdailog");
   }
 
+  @SuppressLint("CheckResult")
   public void showSftpDialog(String name, String path, boolean edit) {
     if (path.length() > 0 && name.length() == 0) {
       int i = dataUtils.containsServer(new String[] {name, path});
       if (i != -1) name = dataUtils.getServers().get(i)[0];
     }
     SftpConnectDialog sftpConnectDialog = new SftpConnectDialog();
-    SshConnectionPool.ConnectionInfo connInfo = new SshConnectionPool.ConnectionInfo(path);
-
-    Bundle bundle = new Bundle();
-    bundle.putString(ARG_NAME, name);
-    bundle.putString(ARG_ADDRESS, connInfo.getHost());
-    bundle.putInt(ARG_PORT, connInfo.getPort());
-    if (!TextUtils.isEmpty(connInfo.getDefaultPath())) {
-      bundle.putString(ARG_DEFAULT_PATH, connInfo.getDefaultPath());
-    }
-    bundle.putString(ARG_USERNAME, connInfo.getUsername());
+    String finalName = name;
+    Flowable.fromCallable(() -> new NetCopyClientConnectionPool.ConnectionInfo(path))
+        .flatMap(
+            connectionInfo -> {
+              Bundle retval = new Bundle();
+              retval.putString(ARG_PROTOCOL, connectionInfo.getPrefix());
+              retval.putString(ARG_NAME, finalName);
+              retval.putString(ARG_ADDRESS, connectionInfo.getHost());
+              retval.putInt(ARG_PORT, connectionInfo.getPort());
+              if (!TextUtils.isEmpty(connectionInfo.getDefaultPath())) {
+                retval.putString(ARG_DEFAULT_PATH, connectionInfo.getDefaultPath());
+              }
+              retval.putString(ARG_USERNAME, connectionInfo.getUsername());
 
-    if (connInfo.getPassword() == null) {
-      bundle.putBoolean(ARG_HAS_PASSWORD, false);
-      bundle.putString(ARG_KEYPAIR_NAME, utilsHandler.getSshAuthPrivateKeyName(path));
-    } else {
-      bundle.putBoolean(ARG_HAS_PASSWORD, true);
-      bundle.putString(ARG_PASSWORD, connInfo.getPassword());
-    }
-    bundle.putBoolean(ARG_EDIT, edit);
-    sftpConnectDialog.setArguments(bundle);
-    sftpConnectDialog.show(getSupportFragmentManager(), "sftpdialog");
+              if (connectionInfo.getPassword() == null) {
+                retval.putBoolean(ARG_HAS_PASSWORD, false);
+                retval.putString(ARG_KEYPAIR_NAME, utilsHandler.getSshAuthPrivateKeyName(path));
+              } else {
+                retval.putBoolean(ARG_HAS_PASSWORD, true);
+                retval.putString(ARG_PASSWORD, connectionInfo.getPassword());
+              }
+              retval.putBoolean(ARG_EDIT, edit);
+              return Flowable.just(retval);
+            })
+        .subscribeOn(Schedulers.computation())
+        .subscribe(
+            bundle -> {
+              sftpConnectDialog.setArguments(bundle);
+              sftpConnectDialog.setCancelable(true);
+              sftpConnectDialog.show(getSupportFragmentManager(), "sftpdialog");
+            });
   }
 
   /**
@@ -2048,33 +2062,41 @@ public class MainActivity extends PermissionsActivity
 
   @Override
   public void deleteConnection(final String name, final String path) {
-
     int i = dataUtils.containsServer(new String[] {name, path});
     if (i != -1) {
       dataUtils.removeServer(i);
-
-      AppConfig.getInstance()
-          .runInBackground(
+      Flowable.fromCallable(
               () -> {
                 utilsHandler.removeFromDatabase(
                     new OperationData(UtilsHandler.Operation.SMB, name, path));
-              });
-      // grid.removePath(name, path, DataUtils.SMB);
-      drawer.refreshDrawer();
+                return true;
+              })
+          .subscribeOn(Schedulers.io())
+          .subscribe(o -> drawer.refreshDrawer());
     }
   }
 
   @Override
   public void delete(String title, String path) {
-    utilsHandler.removeFromDatabase(
-        new OperationData(UtilsHandler.Operation.BOOKMARKS, title, path));
-    drawer.refreshDrawer();
+    Flowable.fromCallable(
+            () -> {
+              utilsHandler.removeFromDatabase(
+                  new OperationData(UtilsHandler.Operation.BOOKMARKS, title, path));
+              return true;
+            })
+        .subscribeOn(Schedulers.io())
+        .subscribe(o -> drawer.refreshDrawer());
   }
 
   @Override
   public void modify(String oldpath, String oldname, String newPath, String newname) {
-    utilsHandler.renameBookmark(oldname, oldpath, newname, newPath);
-    drawer.refreshDrawer();
+    Flowable.fromCallable(
+            () -> {
+              utilsHandler.renameBookmark(oldname, oldpath, newname, newPath);
+              return true;
+            })
+        .subscribeOn(Schedulers.io())
+        .subscribe(o -> drawer.refreshDrawer());
   }
 
   @Override
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/SftpConnectDialog.kt b/app/src/main/java/com/amaze/filemanager/ui/dialogs/SftpConnectDialog.kt
index def640b1c..da06a8333 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/SftpConnectDialog.kt
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/SftpConnectDialog.kt
@@ -33,6 +33,8 @@ import android.text.TextUtils
 import android.text.TextWatcher
 import android.view.LayoutInflater
 import android.view.View
+import android.widget.AdapterView
+import android.widget.ArrayAdapter
 import androidx.activity.result.contract.ActivityResultContracts
 import androidx.core.text.isDigitsOnly
 import androidx.fragment.app.DialogFragment
@@ -41,15 +43,19 @@ import com.afollestad.materialdialogs.MaterialDialog
 import com.afollestad.materialdialogs.internal.MDButton
 import com.amaze.filemanager.R
 import com.amaze.filemanager.application.AppConfig
-import com.amaze.filemanager.asynchronous.asynctasks.AsyncTaskResult
+import com.amaze.filemanager.asynchronous.asynctasks.ftp.AbstractGetHostInfoTask
+import com.amaze.filemanager.asynchronous.asynctasks.ftp.hostcert.FtpsGetHostCertificateTask
 import com.amaze.filemanager.asynchronous.asynctasks.ssh.GetSshHostFingerprintTask
 import com.amaze.filemanager.asynchronous.asynctasks.ssh.PemToKeyPairTask
 import com.amaze.filemanager.database.UtilsHandler
 import com.amaze.filemanager.database.models.OperationData
 import com.amaze.filemanager.databinding.SftpDialogBinding
 import com.amaze.filemanager.fileoperations.filesystem.OpenMode
-import com.amaze.filemanager.filesystem.ssh.SshClientUtils
-import com.amaze.filemanager.filesystem.ssh.SshConnectionPool
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.FTPS_URI_PREFIX
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.FTP_URI_PREFIX
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.SSH_URI_PREFIX
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientUtils
 import com.amaze.filemanager.ui.activities.MainActivity
 import com.amaze.filemanager.ui.activities.superclasses.ThemedActivity
 import com.amaze.filemanager.ui.icons.MimeTypes
@@ -58,8 +64,13 @@ import com.amaze.filemanager.utils.BookSorter
 import com.amaze.filemanager.utils.DataUtils
 import com.amaze.filemanager.utils.MinMaxInputFilter
 import com.amaze.filemanager.utils.SimpleTextWatcher
+import com.amaze.filemanager.utils.X509CertificateUtil.FINGERPRINT
 import com.google.android.material.snackbar.Snackbar
+import io.reactivex.Single
+import io.reactivex.android.schedulers.AndroidSchedulers
+import io.reactivex.schedulers.Schedulers
 import net.schmizz.sshj.common.SecurityUtils
+import org.json.JSONObject
 import org.slf4j.Logger
 import org.slf4j.LoggerFactory
 import java.io.BufferedReader
@@ -67,16 +78,21 @@ import java.lang.ref.WeakReference
 import java.security.KeyPair
 import java.security.PublicKey
 import java.util.*
+import java.util.concurrent.Callable
 
 /** SSH/SFTP connection setup dialog.  */
 class SftpConnectDialog : DialogFragment() {
-    private val log: Logger = LoggerFactory.getLogger(SftpConnectDialog::class.java)
 
     companion object {
+
+        @JvmStatic
+        private val log: Logger = LoggerFactory.getLogger(SftpConnectDialog::class.java)
+
         const val ARG_NAME = "name"
         const val ARG_EDIT = "edit"
         const val ARG_ADDRESS = "address"
         const val ARG_PORT = "port"
+        const val ARG_PROTOCOL = "protocol"
         const val ARG_USERNAME = "username"
         const val ARG_PASSWORD = "password"
         const val ARG_DEFAULT_PATH = "defaultPath"
@@ -86,27 +102,18 @@ class SftpConnectDialog : DialogFragment() {
         private val VALID_PORT_RANGE = IntRange(1, 65535)
     }
 
-    private var ctx: WeakReference<Context>? = null
+    lateinit var ctx: WeakReference<Context>
     private var selectedPem: Uri? = null
     private var selectedParsedKeyPair: KeyPair? = null
     private var selectedParsedKeyPairName: String? = null
     private var oldPath: String? = null
 
-    private var _binding: SftpDialogBinding? = null
-
-    // This property is only valid between onCreateView and
-    // onDestroyView.
-    private val binding get() = _binding!!
-
-    override fun onDestroyView() {
-        super.onDestroyView()
-        _binding = null
-    }
+    lateinit var binding: SftpDialogBinding
 
     @Suppress("ComplexMethod")
     override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
         ctx = WeakReference(activity)
-        _binding = SftpDialogBinding.inflate(LayoutInflater.from(context))
+        binding = SftpDialogBinding.inflate(LayoutInflater.from(context))
         val utilsProvider: UtilitiesProvider = AppConfig.getInstance().utilsProvider
         val edit = requireArguments().getBoolean(ARG_EDIT, false)
 
@@ -119,11 +126,11 @@ class SftpConnectDialog : DialogFragment() {
             val intent = Intent()
                 .setType(MimeTypes.ALL_MIME_TYPES)
                 .setAction(Intent.ACTION_GET_CONTENT)
-            activityResultHandler.launch(intent)
+            activityResultHandlerForPemSelection.launch(intent)
         }
 
         // Define action for buttons
-        val dialogBuilder = MaterialDialog.Builder(ctx!!.get()!!)
+        val dialogBuilder = MaterialDialog.Builder(ctx.get()!!)
             .title(R.string.scp_connection)
             .autoDismiss(false)
             .customView(binding.root, true)
@@ -166,13 +173,61 @@ class SftpConnectDialog : DialogFragment() {
                 }
             }
         }
+        protocolDropDown.adapter = ArrayAdapter(
+            requireContext(),
+            android.R.layout.simple_spinner_dropdown_item,
+            requireContext().resources.getStringArray(R.array.ftpProtocols)
+        )
+        chkFtpAnonymous.setOnCheckedChangeListener { _, isChecked ->
+            usernameET.isEnabled = !isChecked
+            passwordET.isEnabled = !isChecked
+            if (isChecked) {
+                usernameET.setText("")
+                passwordET.setText("")
+            }
+        }
 
         // If it's new connection setup, set some default values
         // Otherwise, use given Bundle instance for filling in the blanks
         if (!edit) {
             connectionET.setText(R.string.scp_connection)
-            portET.setText(SshConnectionPool.SSH_DEFAULT_PORT.toString())
+            portET.setText(NetCopyClientConnectionPool.SSH_DEFAULT_PORT.toString())
+            protocolDropDown.onItemSelectedListener = object : AdapterView.OnItemSelectedListener {
+                override fun onItemSelected(
+                    parent: AdapterView<*>?,
+                    view: View?,
+                    position: Int,
+                    id: Long
+                ) {
+                    portET.setText(
+                        when (position) {
+                            1 -> NetCopyClientConnectionPool.FTP_DEFAULT_PORT.toString()
+                            2 -> NetCopyClientConnectionPool.FTPS_DEFAULT_PORT.toString()
+                            else -> NetCopyClientConnectionPool.SSH_DEFAULT_PORT.toString()
+                        }
+                    )
+                    chkFtpAnonymous.visibility = when (position) {
+                        0 -> View.GONE
+                        else -> View.VISIBLE
+                    }
+                    if (position == 0) {
+                        chkFtpAnonymous.isChecked = false
+                    }
+                    selectPemBTN.visibility = when (position) {
+                        0 -> View.VISIBLE
+                        else -> View.GONE
+                    }
+                }
+                override fun onNothingSelected(parent: AdapterView<*>?) = Unit
+            }
         } else {
+            protocolDropDown.setSelection(
+                when (requireArguments().getString(ARG_PROTOCOL)) {
+                    FTP_URI_PREFIX -> 1
+                    FTPS_URI_PREFIX -> 2
+                    else -> 0
+                }
+            )
             connectionET.setText(requireArguments().getString(ARG_NAME))
             ipET.setText(requireArguments().getString(ARG_ADDRESS))
             portET.setText(requireArguments().getInt(ARG_PORT).toString())
@@ -184,8 +239,9 @@ class SftpConnectDialog : DialogFragment() {
                 selectedParsedKeyPairName = requireArguments().getString(ARG_KEYPAIR_NAME)
                 selectPemBTN.text = selectedParsedKeyPairName
             }
-            oldPath = SshClientUtils.encryptSshPathAsNecessary(
-                SshClientUtils.deriveSftpPathFrom(
+            oldPath = NetCopyClientUtils.encryptFtpPathAsNecessary(
+                NetCopyClientUtils.deriveUriFrom(
+                    requireArguments().getString(ARG_PROTOCOL)!!,
                     requireArguments().getString(ARG_ADDRESS)!!,
                     requireArguments().getInt(ARG_PORT),
                     requireArguments().getString(ARG_DEFAULT_PATH, ""),
@@ -204,8 +260,9 @@ class SftpConnectDialog : DialogFragment() {
             dialogBuilder
                 .negativeText(R.string.delete)
                 .onNegative { dialog: MaterialDialog, _: DialogAction? ->
-                    val path = SshClientUtils.encryptSshPathAsNecessary(
-                        SshClientUtils.deriveSftpPathFrom(
+                    val path = NetCopyClientUtils.encryptFtpPathAsNecessary(
+                        NetCopyClientUtils.deriveUriFrom(
+                            getProtocolPrefixFromDropdownSelection(),
                             hostname,
                             port,
                             defaultPath,
@@ -260,11 +317,16 @@ class SftpConnectDialog : DialogFragment() {
                 } else {
                     true == binding.passwordET.text?.isNotEmpty() || selectedParsedKeyPair != null
                 }
-                okBTN.isEnabled = true == binding.connectionET.text?.isNotEmpty() &&
-                    true == binding.ipET.text?.isNotEmpty() &&
-                    port in VALID_PORT_RANGE &&
-                    true == binding.usernameET.text?.isNotEmpty() &&
-                    hasCredential
+                okBTN.isEnabled = (
+                    true == binding.connectionET.text?.isNotEmpty() &&
+                        true == binding.ipET.text?.isNotEmpty() &&
+                        port in VALID_PORT_RANGE &&
+                        true == binding.usernameET.text?.isNotEmpty() &&
+                        hasCredential
+                    ) || (
+                    binding.chkFtpAnonymous.isChecked &&
+                        binding.protocolDropDown.selectedItemPosition > 0
+                    )
             }
         }
     }
@@ -273,126 +335,242 @@ class SftpConnectDialog : DialogFragment() {
         MaterialDialog.SingleButtonCallback =
         MaterialDialog.SingleButtonCallback { _, _ ->
             createConnectionSettings().run {
-                // Get original SSH host key
-                AppConfig.getInstance().utilsHandler.getSshHostKey(
-                    SshClientUtils.deriveSftpPathFrom(
-                        hostname,
-                        port,
-                        defaultPath,
-                        username,
-                        arguments?.getString(ARG_PASSWORD, null),
-                        selectedParsedKeyPair
-                    )
-                )?.let { sshHostKey ->
-                    SshConnectionPool.removeConnection(
-                        SshClientUtils.deriveSftpPathFrom(
-                            hostname,
-                            port,
-                            defaultPath,
-                            username,
-                            password,
-                            selectedParsedKeyPair
-                        )
-                    ) {
-                        reconnectToServerToVerifyHostFingerprint(
+                when (prefix) {
+                    FTP_URI_PREFIX -> positiveButtonForFtp(this, edit)
+                    else -> positiveButtonForSftp(this, edit)
+                }
+            }
+        }
+
+    private fun positiveButtonForFtp(connectionSettings: ConnectionSettings, edit: Boolean) {
+        connectionSettings.run {
+            authenticateAndSaveSetup(connectionSettings = connectionSettings, isEdit = edit)
+        }
+    }
+
+    /*
+     * for SSH and FTPS, get host's cert/public key fingerprint.
+     */
+    private fun positiveButtonForSftp(connectionSettings: ConnectionSettings, edit: Boolean) {
+        connectionSettings.run {
+            // Get original SSH host key
+            AppConfig.getInstance().utilsHandler.getRemoteHostKey(
+                NetCopyClientUtils.deriveUriFrom(
+                    prefix,
+                    hostname,
+                    port,
+                    defaultPath,
+                    username,
+                    arguments?.getString(ARG_PASSWORD, null),
+                    selectedParsedKeyPair
+                )
+            )?.let { sshHostKey ->
+                NetCopyClientConnectionPool.removeConnection(
+                    this.toUriString()
+                ) {
+                    if (prefix == FTPS_URI_PREFIX) {
+                        reconnectToFtpsServerToVerifyHostFingerprint(
                             this,
-                            sshHostKey,
+                            JSONObject(sshHostKey),
                             edit
                         )
+                    } else {
+                        reconnectToSshServerToVerifyHostFingerprint(this, sshHostKey, edit)
                     }
-                } ?: firstConnectToServer(this, edit)
+                }
+            } ?: run {
+                if (prefix == FTPS_URI_PREFIX) {
+                    firstConnectToFtpsServer(this, edit)
+                } else {
+                    firstConnectToSftpServer(this, edit)
+                }
             }
         }
+    }
+
+    /*
+     * Used by firstConnectToFtpsServer() and firstConnectToSftpServer().
+     */
+    private val createFirstConnectCallback:
+        (Boolean, ConnectionSettings, String, String, String, JSONObject?) -> Unit = {
+                edit,
+                connectionSettings,
+                hostAndPort,
+                hostKeyAlgorithm,
+                hostKeyFingerprint,
+                hostInfo ->
+            AlertDialog.Builder(ctx.get())
+                .setTitle(R.string.ssh_host_key_verification_prompt_title)
+                .setMessage(
+                    getString(
+                        R.string.ssh_host_key_verification_prompt,
+                        hostAndPort,
+                        hostKeyAlgorithm,
+                        hostKeyFingerprint
+                    )
+                ).setCancelable(true)
+                .setPositiveButton(R.string.yes) {
+                        dialog1: DialogInterface, _: Int ->
+                    // This closes the host fingerprint verification dialog
+                    dialog1.dismiss()
+                    if (authenticateAndSaveSetup(
+                            connectionSettings,
+                            hostInfo?.toString() ?: hostKeyFingerprint,
+                            edit
+                        )
+                    ) {
+                        dialog1.dismiss()
+                        log.debug("Saved setup")
+                        dismiss()
+                    }
+                }.setNegativeButton(R.string.no) {
+                        dialog1: DialogInterface, _: Int ->
+                    dialog1.dismiss()
+                }.show()
+        }
 
-    private fun firstConnectToServer(
+    private fun firstConnectToFtpsServer(
         connectionSettings: ConnectionSettings,
         edit: Boolean
     ) = connectionSettings.run {
-        GetSshHostFingerprintTask(
-            hostname,
-            port
-        ) { taskResult: AsyncTaskResult<PublicKey> ->
-            taskResult.result?.run {
-                val hostKeyFingerprint = SecurityUtils.getFingerprint(this)
-                val hostAndPort = StringBuilder(hostname).also {
-                    if (port != SshConnectionPool.SSH_DEFAULT_PORT && port > 0) {
-                        it.append(':').append(port)
-                    }
-                }.toString()
-                AlertDialog.Builder(ctx!!.get())
-                    .setTitle(R.string.ssh_host_key_verification_prompt_title)
-                    .setMessage(
-                        getString(
-                            R.string.ssh_host_key_verification_prompt,
-                            hostAndPort,
-                            algorithm,
-                            hostKeyFingerprint
-                        )
-                    ).setCancelable(true)
-                    .setPositiveButton(R.string.yes) {
-                            dialog1: DialogInterface, _: Int ->
-                        // This closes the host fingerprint verification dialog
-                        dialog1.dismiss()
-                        if (authenticateAndSaveSetup(
-                                connectionSettings,
-                                hostKeyFingerprint,
-                                edit
-                            )
-                        ) {
-                            dialog1.dismiss()
-                            log.debug("Saved setup")
-                            dismiss()
+        connectToSecureServerInternal(
+            FtpsGetHostCertificateTask(
+                hostname,
+                port,
+                requireContext()
+            ) { hostInfo ->
+                createFirstConnectCallback.invoke(
+                    edit,
+                    this,
+                    StringBuilder(hostname).also {
+                        if (port != NetCopyClientConnectionPool.FTPS_DEFAULT_PORT && port > 0) {
+                            it.append(':').append(port)
+                        }
+                    }.toString(),
+                    "SHA-256",
+                    hostInfo.getString(FINGERPRINT),
+                    hostInfo
+                )
+            }
+        )
+    }
+
+    private fun firstConnectToSftpServer(
+        connectionSettings: ConnectionSettings,
+        edit: Boolean
+    ) = connectionSettings.run {
+        connectToSecureServerInternal(
+            GetSshHostFingerprintTask(
+                hostname,
+                port,
+                true
+            ) { hostKey: PublicKey ->
+                createFirstConnectCallback.invoke(
+                    edit,
+                    this,
+                    StringBuilder(hostname).also {
+                        if (port != NetCopyClientConnectionPool.SSH_DEFAULT_PORT && port > 0) {
+                            it.append(':').append(port)
                         }
-                    }.setNegativeButton(R.string.no) {
+                    }.toString(),
+                    hostKey.algorithm,
+                    SecurityUtils.getFingerprint(hostKey),
+                    null
+                )
+            }
+        )
+    }
+
+    private val createReconnectSecureServerCallback:
+        (ConnectionSettings, String, String, () -> Boolean, Boolean) -> Unit = {
+                connectionSettings, oldHostIdentity, newHostIdentity, hostIdentityIsValid, edit ->
+            if (hostIdentityIsValid.invoke()) {
+                authenticateAndSaveSetup(
+                    connectionSettings,
+                    oldHostIdentity,
+                    edit
+                )
+            } else {
+                AlertDialog.Builder(ctx.get())
+                    .setTitle(
+                        R.string.ssh_connect_failed_host_key_changed_title
+                    ).setMessage(
+                        R.string.ssh_connect_failed_host_key_changed_prompt
+                    ).setPositiveButton(
+                        R.string.update_host_key
+                    ) { _: DialogInterface?, _: Int ->
+                        authenticateAndSaveSetup(
+                            connectionSettings,
+                            newHostIdentity,
+                            edit
+                        )
+                    }.setNegativeButton(R.string.cancel_recommended) {
                             dialog1: DialogInterface, _: Int ->
                         dialog1.dismiss()
                     }.show()
             }
-        }.execute()
-    }
+        }
 
-    private fun reconnectToServerToVerifyHostFingerprint(
+    private fun reconnectToSshServerToVerifyHostFingerprint(
         connectionSettings: ConnectionSettings,
         sshHostKey: String,
         edit: Boolean
     ) {
         connectionSettings.run {
-            GetSshHostFingerprintTask(hostname, port) {
-                    taskResult: AsyncTaskResult<PublicKey> ->
-                taskResult.result?.let { hostKey ->
-                    val hostKeyFingerprint = SecurityUtils.getFingerprint(hostKey)
-                    if (hostKeyFingerprint == sshHostKey) {
-                        authenticateAndSaveSetup(
+            connectToSecureServerInternal(
+                GetSshHostFingerprintTask(hostname, port, false) {
+                        currentHostKey: PublicKey ->
+                    SecurityUtils.getFingerprint(currentHostKey).let {
+                            currentHostKeyFingerprint ->
+                        createReconnectSecureServerCallback(
                             connectionSettings,
                             sshHostKey,
+                            currentHostKeyFingerprint,
+                            { currentHostKeyFingerprint == sshHostKey },
                             edit
                         )
-                    } else {
-                        AlertDialog.Builder(ctx!!.get())
-                            .setTitle(
-                                R.string.ssh_connect_failed_host_key_changed_title
-                            ).setMessage(
-                                R.string.ssh_connect_failed_host_key_changed_prompt
-                            ).setPositiveButton(
-                                R.string.update_host_key
-                            ) { _: DialogInterface?, _: Int ->
-                                authenticateAndSaveSetup(
-                                    connectionSettings,
-                                    hostKeyFingerprint,
-                                    edit
-                                )
-                            }.setNegativeButton(R.string.cancel_recommended) {
-                                    dialog1: DialogInterface, _: Int ->
-                                dialog1.dismiss()
-                            }.show()
                     }
                 }
-            }.execute()
+            )
         }
     }
 
+    private fun reconnectToFtpsServerToVerifyHostFingerprint(
+        connectionSettings: ConnectionSettings,
+        ftpsHostInfo: JSONObject,
+        edit: Boolean
+    ) {
+        connectionSettings.run {
+            connectToSecureServerInternal(
+                FtpsGetHostCertificateTask(
+                    hostname,
+                    port,
+                    requireContext()
+                ) { hostInfo: JSONObject ->
+                    createReconnectSecureServerCallback(
+                        connectionSettings,
+                        ftpsHostInfo.toString(),
+                        hostInfo.toString(),
+                        { ftpsHostInfo.getString(FINGERPRINT) == hostInfo.getString(FINGERPRINT) },
+                        edit
+                    )
+                }
+            )
+        }
+    }
+
+    private fun <V, T : Callable<V>> connectToSecureServerInternal(
+        task: AbstractGetHostInfoTask<V, T>
+    ) {
+        Single.fromCallable(task.getTask())
+            .subscribeOn(Schedulers.io())
+            .observeOn(AndroidSchedulers.mainThread())
+            .doOnSubscribe { task.onPreExecute() }
+            .subscribe(task::onFinish, task::onError)
+    }
+
     @Suppress("LabeledExpression")
-    private val activityResultHandler = registerForActivityResult(
+    private val activityResultHandlerForPemSelection = registerForActivityResult(
         ActivityResultContracts.StartActivityForResult()
     ) {
         if (Activity.RESULT_OK == it.resultCode) {
@@ -424,20 +602,13 @@ class SftpConnectDialog : DialogFragment() {
 
     private fun authenticateAndSaveSetup(
         connectionSettings: ConnectionSettings,
-        hostKeyFingerprint: String,
+        hostKeyFingerprint: String? = null,
         isEdit: Boolean
     ): Boolean = connectionSettings.run {
-        val path = SshClientUtils.deriveSftpPathFrom(
-            hostname,
-            port,
-            defaultPath,
-            username,
-            password,
-            selectedParsedKeyPair
-        )
-        val encryptedPath = SshClientUtils.encryptSshPathAsNecessary(path)
+        val path = this.toUriString()
+        val encryptedPath = NetCopyClientUtils.encryptFtpPathAsNecessary(path)
         return if (!isEdit) {
-            saveSshConnection(
+            saveFtpConnectionAndLoadlist(
                 connectionSettings,
                 hostKeyFingerprint,
                 path,
@@ -446,7 +617,7 @@ class SftpConnectDialog : DialogFragment() {
                 selectedParsedKeyPair
             )
         } else {
-            updateSshConnection(
+            updateFtpConnection(
                 connectionName,
                 hostKeyFingerprint,
                 encryptedPath
@@ -454,9 +625,10 @@ class SftpConnectDialog : DialogFragment() {
         }
     }
 
-    private fun saveSshConnection(
+    @Suppress("LongParameterList")
+    private fun saveFtpConnectionAndLoadlist(
         connectionSettings: ConnectionSettings,
-        hostKeyFingerprint: String,
+        hostKeyFingerprint: String?,
         path: String,
         encryptedPath: String,
         selectedParsedKeyPairName: String?,
@@ -464,7 +636,8 @@ class SftpConnectDialog : DialogFragment() {
     ): Boolean {
         connectionSettings.run {
             return runCatching {
-                SshConnectionPool.getConnection(
+                NetCopyClientConnectionPool.getConnection(
+                    prefix,
                     hostname,
                     port,
                     hostKeyFingerprint,
@@ -486,7 +659,15 @@ class SftpConnectDialog : DialogFragment() {
                             )
                         )
                         val ma = (activity as MainActivity).currentMainFragment
-                        ma?.loadlist(path, false, OpenMode.SFTP)
+                        ma?.loadlist(
+                            path,
+                            false,
+                            if (prefix == SSH_URI_PREFIX) {
+                                OpenMode.SFTP
+                            } else {
+                                OpenMode.FTP
+                            }
+                        )
                         dismiss()
                     } else {
                         Snackbar.make(
@@ -499,14 +680,15 @@ class SftpConnectDialog : DialogFragment() {
                     true
                 } ?: false
             }.getOrElse {
+                log.warn("Problem getting connection and load file list", it)
                 false
             }
         }
     }
 
-    private fun updateSshConnection(
+    private fun updateFtpConnection(
         connectionName: String,
-        hostKeyFingerprint: String,
+        hostKeyFingerprint: String?,
         encryptedPath: String
     ): Boolean {
         DataUtils.getInstance().removeServer(DataUtils.getInstance().containsServer(oldPath))
@@ -536,7 +718,16 @@ class SftpConnectDialog : DialogFragment() {
         }.getOrNull()
     }
 
+    private fun getProtocolPrefixFromDropdownSelection(): String {
+        return when (binding.protocolDropDown.selectedItem.toString()) {
+            requireContext().getString(R.string.protocol_ftp) -> FTP_URI_PREFIX
+            requireContext().getString(R.string.protocol_ftps) -> FTPS_URI_PREFIX
+            else -> SSH_URI_PREFIX
+        }
+    }
+
     private data class ConnectionSettings(
+        val prefix: String,
         val connectionName: String,
         val hostname: String,
         val port: Int,
@@ -545,10 +736,21 @@ class SftpConnectDialog : DialogFragment() {
         val password: String? = null,
         val selectedParsedKeyPairName: String? = null,
         val selectedParsedKeyPair: KeyPair? = null
-    )
+    ) {
+        fun toUriString() = NetCopyClientUtils.deriveUriFrom(
+            prefix,
+            hostname,
+            port,
+            defaultPath,
+            username,
+            password,
+            selectedParsedKeyPair
+        )
+    }
 
     private fun createConnectionSettings() =
         ConnectionSettings(
+            prefix = getProtocolPrefixFromDropdownSelection(),
             connectionName = binding.connectionET.text.toString(),
             hostname = binding.ipET.text.toString(),
             port = binding.portET.text.toString().toInt(),
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbConnectDialog.java b/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbConnectDialog.java
index 334410375..1959c6ef3 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbConnectDialog.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbConnectDialog.java
@@ -23,13 +23,11 @@ package com.amaze.filemanager.ui.dialogs;
 import static com.amaze.filemanager.filesystem.smb.CifsContexts.SMB_URI_PREFIX;
 import static com.amaze.filemanager.utils.SmbUtil.PARAM_DISABLE_IPC_SIGNING_CHECK;
 
-import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.net.URLDecoder;
 import java.net.URLEncoder;
-import java.security.GeneralSecurityException;
 
 import org.slf4j.Logger;
 import org.slf4j.LoggerFactory;
@@ -326,7 +324,7 @@ public class SmbConnectDialog extends DialogFragment {
                   conName.getText().toString(),
                   SmbUtil.getSmbEncryptedPath(getActivity(), smbFile.getPath())
                 };
-          } catch (GeneralSecurityException | IOException e) {
+          } catch (Exception e) {
             LOG.warn("failed to load smb dialog info", e);
             Toast.makeText(getActivity(), getString(R.string.error), Toast.LENGTH_LONG).show();
             return;
diff --git a/app/src/main/java/com/amaze/filemanager/ui/fragments/MainFragment.java b/app/src/main/java/com/amaze/filemanager/ui/fragments/MainFragment.java
index c0b43a6f4..00519f05a 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/fragments/MainFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/fragments/MainFragment.java
@@ -24,7 +24,7 @@ import static android.os.Build.VERSION.SDK_INT;
 import static android.os.Build.VERSION_CODES.JELLY_BEAN;
 import static android.os.Build.VERSION_CODES.JELLY_BEAN_MR2;
 import static android.os.Build.VERSION_CODES.Q;
-import static com.amaze.filemanager.filesystem.ssh.SshConnectionPool.SSH_URI_PREFIX;
+import static com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.SSH_URI_PREFIX;
 import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_DIVIDERS;
 import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_GOBACK_BUTTON;
 import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_HIDDENFILES;
@@ -1018,6 +1018,18 @@ public class MainFragment extends Fragment
               loadlist(
                   currentFile.getParent(getContext()), true, mainFragmentViewModel.getOpenMode());
             }
+          } else if (OpenMode.FTP.equals(mainFragmentViewModel.getOpenMode())) {
+            if (mainFragmentViewModel.getCurrentPath() != null) {
+              String parent = currentFile.getParent(getContext());
+              // Hack.
+              if (parent != null && parent.contains("://")) {
+                loadlist(parent, true, mainFragmentViewModel.getOpenMode());
+              } else {
+                loadlist(mainFragmentViewModel.getHome(), false, OpenMode.FILE);
+              }
+            } else {
+              loadlist(mainFragmentViewModel.getHome(), false, OpenMode.FILE);
+            }
           } else if (("/").equals(mainFragmentViewModel.getCurrentPath())
               || (mainFragmentViewModel.getHome() != null
                   && mainFragmentViewModel.getHome().equals(mainFragmentViewModel.getCurrentPath()))
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/appbar/BottomBar.java b/app/src/main/java/com/amaze/filemanager/ui/views/appbar/BottomBar.java
index b113ff9b8..7b76b94eb 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/views/appbar/BottomBar.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/views/appbar/BottomBar.java
@@ -375,6 +375,7 @@ public class BottomBar implements View.OnTouchListener {
     switch (openmode) {
       case SFTP:
       case SMB:
+      case FTP:
         newPath = HybridFile.parseAndFormatUriForDisplay(news);
         break;
       case OTG:
diff --git a/app/src/main/java/com/amaze/filemanager/ui/views/drawer/Drawer.java b/app/src/main/java/com/amaze/filemanager/ui/views/drawer/Drawer.java
index 0cbe16eef..4b79d9782 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/views/drawer/Drawer.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/views/drawer/Drawer.java
@@ -21,6 +21,9 @@
 package com.amaze.filemanager.ui.views.drawer;
 
 import static android.os.Build.VERSION.SDK_INT;
+import static com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.FTPS_URI_PREFIX;
+import static com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.FTP_URI_PREFIX;
+import static com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.SSH_URI_PREFIX;
 import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_SIDEBAR_FOLDERS;
 import static com.amaze.filemanager.ui.fragments.preferencefragments.PreferencesConstants.PREFERENCE_SHOW_SIDEBAR_QUICKACCESSES;
 
@@ -847,7 +850,9 @@ public class Drawer implements NavigationView.OnNavigationItemSelectedListener {
           mainActivity.renameBookmark(title, path);
         } else if (path.startsWith("smb:/")) {
           mainActivity.showSMBDialog(title, path, true);
-        } else if (path.startsWith("ssh:/")) {
+        } else if (path.startsWith(SSH_URI_PREFIX)
+            || path.startsWith(FTP_URI_PREFIX)
+            || path.startsWith(FTPS_URI_PREFIX)) {
           mainActivity.showSftpDialog(title, path, true);
         } else if (path.startsWith(CloudHandler.CLOUD_PREFIX_DROPBOX)) {
           GeneralDialogCreation.showCloudDialog(
diff --git a/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java b/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
index fe707f7ae..edcf0f4b4 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/MainActivityHelper.java
@@ -57,7 +57,7 @@ import com.amaze.filemanager.filesystem.compressed.CompressedHelper;
 import com.amaze.filemanager.filesystem.compressed.showcontents.Decompressor;
 import com.amaze.filemanager.filesystem.files.CryptUtil;
 import com.amaze.filemanager.filesystem.files.FileUtils;
-import com.amaze.filemanager.filesystem.ssh.SshClientUtils;
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientUtils;
 import com.amaze.filemanager.ui.activities.MainActivity;
 import com.amaze.filemanager.ui.dialogs.GeneralDialogCreation;
 import com.amaze.filemanager.ui.fragments.MainFragment;
@@ -438,8 +438,9 @@ public class MainActivityHelper {
   public @FolderState int checkFolder(final String path, OpenMode openMode, Context context) {
     if (OpenMode.SMB.equals(openMode)) {
       return SmbUtil.checkFolder(path);
-    } else if (OpenMode.SFTP.equals(openMode)) {
-      return SshClientUtils.checkFolder(path);
+    } else if (OpenMode.SFTP.equals(openMode) || OpenMode.FTP.equals(openMode)) {
+      int result = NetCopyClientUtils.INSTANCE.checkFolder(path);
+      return result;
     } else if (OpenMode.DOCUMENT_FILE.equals(openMode)) {
       DocumentFile d =
           DocumentFile.fromTreeUri(AppConfig.getInstance(), SafRootHolder.getUriRoot());
@@ -665,8 +666,8 @@ public class MainActivityHelper {
 
   public void deleteFiles(ArrayList<HybridFileParcelable> files) {
     if (files == null || files.size() == 0) return;
-    if (files.get(0).isSmb()) {
-      new DeleteTask(mainActivity).execute((files));
+    if (files.get(0).isSmb() || files.get(0).isFtp()) {
+      new DeleteTask(mainActivity).execute(files);
       return;
     }
     @FolderState
diff --git a/app/src/main/java/com/amaze/filemanager/utils/OTGUtil.kt b/app/src/main/java/com/amaze/filemanager/utils/OTGUtil.kt
index 6b2dcb758..86409d78e 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/OTGUtil.kt
+++ b/app/src/main/java/com/amaze/filemanager/utils/OTGUtil.kt
@@ -37,7 +37,6 @@ import com.amaze.filemanager.fileoperations.filesystem.usb.SingletonUsbOtg
 import com.amaze.filemanager.fileoperations.filesystem.usb.UsbOtgRepresentation
 import com.amaze.filemanager.filesystem.HybridFileParcelable
 import com.amaze.filemanager.filesystem.RootHelper
-import kotlin.collections.ArrayList
 
 /** Created by Vishal on 27-04-2017.  */
 object OTGUtil {
@@ -206,33 +205,32 @@ object OTGUtil {
         val usbManager = context.getSystemService(Context.USB_SERVICE) as? UsbManager
         val devices = usbManager?.deviceList ?: mapOf()
         return devices.mapNotNullTo(
-            ArrayList(),
-            { entry ->
-                val device = entry.value
-                var retval: UsbOtgRepresentation? = null
-                for (i in 0 until device.interfaceCount) {
-                    if (device.getInterface(i).interfaceClass
-                        == UsbConstants.USB_CLASS_MASS_STORAGE
-                    ) {
-                        var serial: String? = null
-                        if (SDK_INT >= LOLLIPOP) {
-                            try {
-                                serial = device.serialNumber
-                            } catch (ifPermissionDenied: SecurityException) {
-                                // May happen when device is running Android 10 or above.
-                                Log.w(
-                                    TAG,
-                                    "Permission denied reading serial number of device " +
-                                        "${device.vendorId}:${device.productId}",
-                                    ifPermissionDenied
-                                )
-                            }
+            ArrayList()
+        ) { entry ->
+            val device = entry.value
+            var retval: UsbOtgRepresentation? = null
+            for (i in 0 until device.interfaceCount) {
+                if (device.getInterface(i).interfaceClass
+                    == UsbConstants.USB_CLASS_MASS_STORAGE
+                ) {
+                    var serial: String? = null
+                    if (SDK_INT >= LOLLIPOP) {
+                        try {
+                            serial = device.serialNumber
+                        } catch (ifPermissionDenied: SecurityException) {
+                            // May happen when device is running Android 10 or above.
+                            Log.w(
+                                TAG,
+                                "Permission denied reading serial number of device " +
+                                    "${device.vendorId}:${device.productId}",
+                                ifPermissionDenied
+                            )
                         }
-                        retval = UsbOtgRepresentation(device.productId, device.vendorId, serial)
                     }
+                    retval = UsbOtgRepresentation(device.productId, device.vendorId, serial)
                 }
-                retval
             }
-        )
+            retval
+        }
     }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/PasswordUtil.kt b/app/src/main/java/com/amaze/filemanager/utils/PasswordUtil.kt
index 7a88bd931..54b53158f 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/PasswordUtil.kt
+++ b/app/src/main/java/com/amaze/filemanager/utils/PasswordUtil.kt
@@ -44,12 +44,12 @@ object PasswordUtil {
         GeneralSecurityException::class,
         IOException::class
     )
-    private fun aesEncryptPassword(plainTextPassword: String): String? {
+    private fun aesEncryptPassword(plainTextPassword: String, base64Options: Int): String? {
         val cipher = Cipher.getInstance(CryptUtil.ALGO_AES)
         val gcmParameterSpec = GCMParameterSpec(128, IV.toByteArray())
         cipher.init(Cipher.ENCRYPT_MODE, SecretKeygen.getSecretKey(), gcmParameterSpec)
         val encodedBytes = cipher.doFinal(plainTextPassword.toByteArray())
-        return Base64.encodeToString(encodedBytes, Base64.DEFAULT)
+        return Base64.encodeToString(encodedBytes, base64Options)
     }
 
     /** Helper method to decrypt cipher text password  */
@@ -58,11 +58,11 @@ object PasswordUtil {
         GeneralSecurityException::class,
         IOException::class
     )
-    private fun aesDecryptPassword(cipherPassword: String): String {
+    private fun aesDecryptPassword(cipherPassword: String, base64Options: Int): String {
         val cipher = Cipher.getInstance(CryptUtil.ALGO_AES)
         val gcmParameterSpec = GCMParameterSpec(128, IV.toByteArray())
         cipher.init(Cipher.DECRYPT_MODE, SecretKeygen.getSecretKey(), gcmParameterSpec)
-        val decryptedBytes = cipher.doFinal(Base64.decode(cipherPassword, Base64.DEFAULT))
+        val decryptedBytes = cipher.doFinal(Base64.decode(cipherPassword, base64Options))
         return String(decryptedBytes)
     }
 
@@ -71,11 +71,15 @@ object PasswordUtil {
         GeneralSecurityException::class,
         IOException::class
     )
-    private fun rsaEncryptPassword(context: Context, password: String): String? {
+    private fun rsaEncryptPassword(
+        context: Context,
+        password: String,
+        base64Options: Int
+    ): String? {
         val cipher = Cipher.getInstance(CryptUtil.ALGO_AES)
         val ivParameterSpec = IvParameterSpec(IV.toByteArray())
         cipher.init(Cipher.ENCRYPT_MODE, SecretKeygen.getSecretKey(), ivParameterSpec)
-        return Base64.encodeToString(cipher.doFinal(password.toByteArray()), Base64.DEFAULT)
+        return Base64.encodeToString(cipher.doFinal(password.toByteArray()), base64Options)
     }
 
     @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
@@ -83,31 +87,43 @@ object PasswordUtil {
         GeneralSecurityException::class,
         IOException::class
     )
-    private fun rsaDecryptPassword(context: Context, cipherText: String): String {
+    private fun rsaDecryptPassword(
+        context: Context,
+        cipherText: String,
+        base64Options: Int
+    ): String {
         val cipher = Cipher.getInstance(CryptUtil.ALGO_AES)
         val ivParameterSpec = IvParameterSpec(IV.toByteArray())
         cipher.init(Cipher.DECRYPT_MODE, SecretKeygen.getSecretKey(), ivParameterSpec)
-        val decryptedBytes = cipher.doFinal(Base64.decode(cipherText, Base64.DEFAULT))
+        val decryptedBytes = cipher.doFinal(Base64.decode(cipherText, base64Options))
         return String(decryptedBytes)
     }
 
     /** Method handles encryption of plain text on various APIs  */
     @Throws(GeneralSecurityException::class, IOException::class)
-    fun encryptPassword(context: Context, plainText: String): String? {
+    fun encryptPassword(
+        context: Context,
+        plainText: String,
+        base64Options: Int = Base64.URL_SAFE
+    ): String? {
         return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-            aesEncryptPassword(plainText)
+            aesEncryptPassword(plainText, base64Options)
         } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
-            rsaEncryptPassword(context, plainText)
+            rsaEncryptPassword(context, plainText, base64Options)
         } else plainText
     }
 
     /** Method handles decryption of cipher text on various APIs  */
     @Throws(GeneralSecurityException::class, IOException::class)
-    fun decryptPassword(context: Context, cipherText: String): String {
+    fun decryptPassword(
+        context: Context,
+        cipherText: String,
+        base64Options: Int = Base64.URL_SAFE
+    ): String {
         return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-            aesDecryptPassword(cipherText)
+            aesDecryptPassword(cipherText, base64Options)
         } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
-            rsaDecryptPassword(context, cipherText)
+            rsaDecryptPassword(context, cipherText, base64Options)
         } else cipherText
     }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.java b/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.java
deleted file mode 100644
index 88e597e7f..000000000
--- a/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*
- * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
- * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
- *
- * This file is part of Amaze File Manager.
- *
- * Amaze File Manager is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.amaze.filemanager.utils;
-
-import static com.amaze.filemanager.fileoperations.filesystem.FolderStateKt.DOESNT_EXIST;
-import static com.amaze.filemanager.fileoperations.filesystem.FolderStateKt.WRITABLE_ON_REMOTE;
-
-import java.io.File;
-import java.io.IOException;
-import java.net.MalformedURLException;
-import java.security.GeneralSecurityException;
-
-import com.amaze.filemanager.filesystem.smb.CifsContexts;
-
-import android.content.Context;
-import android.net.Uri;
-import android.text.TextUtils;
-import android.util.Log;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import io.reactivex.Single;
-import io.reactivex.schedulers.Schedulers;
-import jcifs.smb.NtlmPasswordAuthenticator;
-import jcifs.smb.SmbException;
-import jcifs.smb.SmbFile;
-
-/**
- * Created by Vishal on 30-05-2017.
- *
- * <p>Class provides various utility methods for SMB client
- */
-public class SmbUtil {
-
-  private static final String TAG = SmbUtil.class.getSimpleName();
-
-  public static final String PARAM_DISABLE_IPC_SIGNING_CHECK = "disableIpcSigningCheck";
-
-  private SmbUtil() {
-    // empty constructor to prevent instantiation
-  }
-
-  /** Parse path to decrypt smb password */
-  public static String getSmbDecryptedPath(Context context, String path)
-      throws GeneralSecurityException, IOException {
-    if (!(path.contains(":") && path.contains("@"))) {
-      // smb path doesn't have any credentials
-      return path;
-    }
-
-    StringBuilder buffer = new StringBuilder();
-
-    buffer.append(path.substring(0, path.indexOf(":", 4) + 1));
-    String encryptedPassword = path.substring(path.indexOf(":", 4) + 1, path.lastIndexOf("@"));
-
-    if (!TextUtils.isEmpty(encryptedPassword)) {
-      String decryptedPassword = PasswordUtil.INSTANCE.decryptPassword(context, encryptedPassword);
-      buffer.append(decryptedPassword);
-    }
-    buffer.append(path.substring(path.lastIndexOf("@")));
-
-    return buffer.toString();
-  }
-
-  /** Parse path to encrypt smb password */
-  public static String getSmbEncryptedPath(Context context, String path)
-      throws GeneralSecurityException, IOException {
-    if (!(path.contains(":") && path.contains("@"))) {
-      // smb path doesn't have any credentials
-      return path;
-    }
-
-    StringBuilder buffer = new StringBuilder();
-    buffer.append(path.substring(0, path.indexOf(":", 4) + 1));
-    String decryptedPassword = path.substring(path.indexOf(":", 4) + 1, path.lastIndexOf("@"));
-
-    if (!TextUtils.isEmpty(decryptedPassword)) {
-      String encryptPassword = PasswordUtil.INSTANCE.encryptPassword(context, decryptedPassword);
-      buffer.append(encryptPassword);
-    }
-    buffer.append(path.substring(path.lastIndexOf("@")));
-
-    return buffer.toString();
-  }
-
-  public static SmbFile create(String path) throws MalformedURLException {
-    Uri uri = Uri.parse(path);
-    boolean disableIpcSigningCheck =
-        Boolean.parseBoolean(uri.getQueryParameter(PARAM_DISABLE_IPC_SIGNING_CHECK));
-    String userInfo = uri.getUserInfo();
-    return new SmbFile(
-        path.indexOf('?') < 0 ? path : path.substring(0, path.indexOf('?')),
-        CifsContexts.createWithDisableIpcSigningCheck(path, disableIpcSigningCheck)
-            .withCredentials(createFrom(userInfo)));
-  }
-
-  /**
-   * Create {@link NtlmPasswordAuthenticator} from given userInfo parameter.
-   *
-   * <p>Logic borrowed directly from jcifs-ng's own code. They should make that protected
-   * constructor public...
-   *
-   * @param userInfo authentication string, must be already URL decoded. {@link Uri} shall do this
-   *     for you already
-   * @return {@link NtlmPasswordAuthenticator} instance
-   */
-  protected static @NonNull NtlmPasswordAuthenticator createFrom(@Nullable String userInfo) {
-    if (!TextUtils.isEmpty(userInfo)) {
-      String dom = null;
-      String user = null;
-      String pass = null;
-      int i;
-      int u;
-      int end = userInfo.length();
-      for (i = 0, u = 0; i < end; i++) {
-        char c = userInfo.charAt(i);
-        if (c == ';') {
-          dom = userInfo.substring(0, i);
-          u = i + 1;
-        } else if (c == ':') {
-          pass = userInfo.substring(i + 1);
-          break;
-        }
-      }
-      user = userInfo.substring(u, i);
-      return new NtlmPasswordAuthenticator(dom, user, pass);
-    } else {
-      return new NtlmPasswordAuthenticator();
-    }
-  }
-
-  /**
-   * SMB version of {@link MainActivityHelper#checkFolder(File, Context)}.
-   *
-   * @param path SMB path
-   * @return {@link com.amaze.filemanager.filesystem.FolderStateKt#DOESNT_EXIST} if specified SMB
-   *     path doesn't exist on server, else {@link
-   *     com.amaze.filemanager.filesystem.FolderStateKt#WRITABLE_ON_REMOTE}
-   */
-  public static int checkFolder(@NonNull String path) {
-    return Single.fromCallable(
-            () -> {
-              try {
-                SmbFile smbFile = create(path);
-                if (!smbFile.exists() || !smbFile.isDirectory()) return DOESNT_EXIST;
-              } catch (SmbException | MalformedURLException e) {
-                Log.w(TAG, "Error checking folder existence, assuming not exist", e);
-                return DOESNT_EXIST;
-              }
-              return WRITABLE_ON_REMOTE;
-            })
-        .subscribeOn(Schedulers.io())
-        .blockingGet();
-  }
-}
diff --git a/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.kt b/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.kt
new file mode 100644
index 000000000..88c3e28eb
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.kt
@@ -0,0 +1,172 @@
+/*
+ * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.utils
+
+import android.content.Context
+import android.net.Uri
+import android.text.TextUtils
+import android.util.Log
+import com.amaze.filemanager.fileoperations.filesystem.DOESNT_EXIST
+import com.amaze.filemanager.fileoperations.filesystem.WRITABLE_ON_REMOTE
+import com.amaze.filemanager.filesystem.smb.CifsContexts.createWithDisableIpcSigningCheck
+import io.reactivex.Single
+import io.reactivex.schedulers.Schedulers
+import jcifs.smb.NtlmPasswordAuthenticator
+import jcifs.smb.SmbException
+import jcifs.smb.SmbFile
+import java.net.MalformedURLException
+
+/**
+ * Created by Vishal on 30-05-2017.
+ *
+ *
+ * Class provides various utility methods for SMB client
+ */
+object SmbUtil {
+
+    private const val TAG = "SmbUtil"
+    const val PARAM_DISABLE_IPC_SIGNING_CHECK = "disableIpcSigningCheck"
+
+    /** Parse path to decrypt smb password  */
+    @JvmStatic
+    fun getSmbDecryptedPath(context: Context, path: String): String {
+        if (!(path.contains(":") && path.contains("@"))) {
+            // smb path doesn't have any credentials
+            return path
+        }
+        val buffer = StringBuilder()
+        val protocolPrefix = path.substringBefore("//")
+        val usernamePasswordSeparatorPos = path.indexOf(":", protocolPrefix.length) + 1
+        buffer.append(path.substring(0, usernamePasswordSeparatorPos))
+        val encryptedPassword = path.substring(usernamePasswordSeparatorPos, path.lastIndexOf("@"))
+        if (!TextUtils.isEmpty(encryptedPassword)) {
+            val decryptedPassword = PasswordUtil.decryptPassword(context, encryptedPassword)
+            buffer.append(decryptedPassword)
+        }
+        buffer.append(path.substring(path.lastIndexOf("@")))
+        return buffer.toString()
+    }
+
+    /** Parse path to encrypt smb password  */
+    @JvmStatic
+    fun getSmbEncryptedPath(context: Context, path: String): String {
+        if (!(path.contains(":") && path.contains("@"))) {
+            // smb path doesn't have any credentials
+            return path
+        }
+        val buffer = StringBuilder()
+        // From index zero to user name including colon
+        val protocolPrefix = path.substringBefore("//")
+        val usernamePasswordSeparatorPos = path.indexOf(":", protocolPrefix.length) + 1
+        buffer.append(path.substring(0, usernamePasswordSeparatorPos))
+        val decryptedPassword = path.substring(usernamePasswordSeparatorPos, path.lastIndexOf("@"))
+        if (!TextUtils.isEmpty(decryptedPassword)) {
+            val encryptPassword = PasswordUtil.encryptPassword(context, decryptedPassword)
+            buffer.append(encryptPassword)
+        }
+        buffer.append(path.substring(path.lastIndexOf("@")))
+        return buffer.toString()
+    }
+
+    /**
+     * Factory method to return [SmbFile] from given path.
+     */
+    @JvmStatic
+    @Throws(MalformedURLException::class)
+    fun create(path: String): SmbFile {
+        val uri = Uri.parse(path)
+        val disableIpcSigningCheck = uri.getQueryParameter(
+            PARAM_DISABLE_IPC_SIGNING_CHECK
+        ).toBoolean()
+
+        val userInfo = uri.userInfo
+        return SmbFile(
+            if (path.indexOf('?') < 0) path else path.substring(0, path.indexOf('?')),
+            createWithDisableIpcSigningCheck(path, disableIpcSigningCheck)
+                .withCredentials(createFrom(userInfo))
+        )
+    }
+
+    /**
+     * Create [NtlmPasswordAuthenticator] from given userInfo parameter.
+     *
+     *
+     * Logic borrowed directly from jcifs-ng's own code. They should make that protected
+     * constructor public...
+     *
+     * @param userInfo authentication string, must be already URL decoded. [Uri] shall do this
+     * for you already
+     * @return [NtlmPasswordAuthenticator] instance
+     */
+    fun createFrom(userInfo: String?): NtlmPasswordAuthenticator {
+        return if (!TextUtils.isEmpty(userInfo)) {
+            var dom: String? = null
+            var user: String? = null
+            var pass: String? = null
+            var i: Int
+            var u: Int
+            val end = userInfo!!.length
+            i = 0
+            u = 0
+            while (i < end) {
+                val c = userInfo[i]
+                if (c == ';') {
+                    dom = userInfo.substring(0, i)
+                    u = i + 1
+                } else if (c == ':') {
+                    pass = userInfo.substring(i + 1)
+                    break
+                }
+                i++
+            }
+            user = userInfo.substring(u, i)
+            NtlmPasswordAuthenticator(dom, user, pass)
+        } else {
+            NtlmPasswordAuthenticator()
+        }
+    }
+
+    /**
+     * SMB version of [MainActivityHelper.checkFolder].
+     *
+     * @param path SMB path
+     * @return [com.amaze.filemanager.filesystem.FolderStateKt.DOESNT_EXIST] if specified SMB
+     * path doesn't exist on server, else [com.amaze.filemanager.filesystem.FolderStateKt.WRITABLE_ON_REMOTE]
+     */
+    @Suppress("LabeledExpression")
+    @JvmStatic
+    fun checkFolder(path: String): Int {
+        return Single.fromCallable {
+            try {
+                val smbFile = create(path)
+                if (!smbFile.exists() || !smbFile.isDirectory) return@fromCallable DOESNT_EXIST
+            } catch (e: SmbException) {
+                Log.w(TAG, "Error checking folder existence, assuming not exist", e)
+                return@fromCallable DOESNT_EXIST
+            } catch (e: MalformedURLException) {
+                Log.w(TAG, "Error checking folder existence, assuming not exist", e)
+                return@fromCallable DOESNT_EXIST
+            }
+            WRITABLE_ON_REMOTE
+        }.subscribeOn(Schedulers.io())
+            .blockingGet()
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/utils/X509CertificateUtil.kt b/app/src/main/java/com/amaze/filemanager/utils/X509CertificateUtil.kt
new file mode 100644
index 000000000..e2d14e9eb
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/utils/X509CertificateUtil.kt
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.utils
+
+import net.schmizz.sshj.common.ByteArrayUtils
+import org.json.JSONObject
+import java.security.MessageDigest
+import java.util.*
+
+object X509CertificateUtil {
+
+    const val SUBJECT = "subject"
+    const val ISSUER = "issuer"
+    const val SERIAL = "serial"
+    const val FINGERPRINT = "sha256Fingerprint"
+
+    private fun colonSeparatedHex(array: ByteArray) =
+        ByteArrayUtils.toHex(array).chunked(2).joinToString(":")
+
+    /**
+     * Parse a [javax.security.cert.X509Certificate] and return part of its information in a JSON object.
+     *
+     * Includes the certificate's subject, issuer, serial number and SHA-256 fingerprint.
+     *
+     * @param certificate [javax.security.cert.X509Certificate]
+     * @return [JSONObject]
+     */
+    fun parse(certificate: javax.security.cert.X509Certificate): Map<String, String> {
+        val retval = WeakHashMap<String, String>()
+        retval[SUBJECT] = certificate.subjectDN.name
+        retval[ISSUER] = certificate.issuerDN.name
+        retval[SERIAL] = colonSeparatedHex(certificate.serialNumber.toByteArray())
+        retval[FINGERPRINT] = MessageDigest.getInstance("sha-256").run {
+            colonSeparatedHex(digest(certificate.encoded))
+        }
+        return retval
+    }
+
+    /**
+     * Parse a [java.security.cert.X509Certificate] and return part of its information in a JSON object.
+     *
+     * Includes the certificate's subject, issuer, serial number and SHA-256 fingerprint.
+     *
+     * @param certificate [java.security.cert.X509Certificate]
+     * @return [JSONObject]
+     */
+    fun parse(certificate: java.security.cert.X509Certificate): Map<String, String> {
+        val retval = WeakHashMap<String, String>()
+        retval[SUBJECT] = certificate.subjectDN.name
+        retval[ISSUER] = certificate.issuerDN.name
+        retval[SERIAL] = colonSeparatedHex(certificate.serialNumber.toByteArray())
+        retval[FINGERPRINT] = MessageDigest.getInstance("sha-256").run {
+            colonSeparatedHex(digest(certificate.encoded))
+        }
+        return retval
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/SshAuthenticationTaskTest.kt b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/SshAuthenticationTaskTest.kt
index d0c7e7a51..f5257d2e3 100644
--- a/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/SshAuthenticationTaskTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/asynchronous/asynctasks/ssh/SshAuthenticationTaskTest.kt
@@ -24,31 +24,41 @@ import android.content.Context
 import android.os.Build.VERSION_CODES.JELLY_BEAN
 import android.os.Build.VERSION_CODES.KITKAT
 import android.os.Build.VERSION_CODES.P
-import android.os.Looper
 import androidx.test.core.app.ApplicationProvider
 import androidx.test.ext.junit.runners.AndroidJUnit4
 import com.amaze.filemanager.R
-import com.amaze.filemanager.filesystem.ssh.SshConnectionPool
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool
 import com.amaze.filemanager.filesystem.ssh.test.TestKeyProvider
 import com.amaze.filemanager.shadows.ShadowMultiDex
+import io.reactivex.Single
 import io.reactivex.android.plugins.RxAndroidPlugins
+import io.reactivex.android.schedulers.AndroidSchedulers
 import io.reactivex.plugins.RxJavaPlugins
 import io.reactivex.schedulers.Schedulers
 import net.schmizz.sshj.SSHClient
 import net.schmizz.sshj.common.DisconnectReason
 import net.schmizz.sshj.userauth.UserAuthException
 import net.schmizz.sshj.userauth.keyprovider.KeyProvider
-import org.junit.Assert.*
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertNotNull
+import org.junit.Assert.assertNull
+import org.junit.Assert.assertTrue
+import org.junit.Assert.fail
 import org.junit.Before
 import org.junit.Test
 import org.junit.runner.RunWith
-import org.mockito.Mockito.*
-import org.robolectric.Shadows
-import org.robolectric.android.util.concurrent.InlineExecutorService
+import org.mockito.Mockito.any
+import org.mockito.Mockito.anyInt
+import org.mockito.Mockito.anyString
+import org.mockito.Mockito.doNothing
+import org.mockito.Mockito.doThrow
+import org.mockito.Mockito.eq
+import org.mockito.Mockito.mock
+import org.mockito.Mockito.`when`
 import org.robolectric.annotation.Config
-import org.robolectric.shadows.ShadowPausedAsyncTask
 import org.robolectric.shadows.ShadowToast
 import java.net.SocketException
+import java.util.concurrent.CountDownLatch
 
 @RunWith(AndroidJUnit4::class)
 @Config(shadows = [ShadowMultiDex::class], sdk = [JELLY_BEAN, KITKAT, P])
@@ -60,7 +70,6 @@ class SshAuthenticationTaskTest {
      */
     @Before
     fun setUp() {
-        ShadowPausedAsyncTask.overrideExecutor(InlineExecutorService())
         RxJavaPlugins.reset()
         RxJavaPlugins.setIoSchedulerHandler { Schedulers.trampoline() }
         RxAndroidPlugins.reset()
@@ -81,18 +90,32 @@ class SshAuthenticationTaskTest {
             `when`(isAuthenticated).thenReturn(true)
         }
         prepareSshConnectionPool(sshClient)
-        val result = SshAuthenticationTask(
+        val task = SshAuthenticationTask(
             hostKey = "",
             hostname = "127.0.0.1",
             port = 22222,
             username = "user",
             password = "password"
-        ).execute().get()
-        Shadows.shadowOf(Looper.getMainLooper()).idle()
-        assertNotNull(result.result)
-        assertTrue(result.result.isAuthenticated)
-        assertTrue(result.result.isConnected)
-        assertNull(result.exception)
+        )
+        val latch = CountDownLatch(1)
+        var e: Throwable? = null
+        var result: SSHClient? = null
+        Single.fromCallable(task.getTask())
+            .subscribeOn(Schedulers.io())
+            .observeOn(AndroidSchedulers.mainThread())
+            .subscribe({
+                task.onFinish(it)
+                result = it
+                latch.countDown()
+            }, {
+                task.onError(it)
+                e = it
+                latch.countDown()
+            })
+        result?.run {
+            assertTrue(isAuthenticated)
+            assertTrue(isConnected)
+        } ?: fail("Null SSHClient")
     }
 
     /**
@@ -110,16 +133,31 @@ class SshAuthenticationTaskTest {
             `when`(isAuthenticated).thenReturn(true)
         }
         prepareSshConnectionPool(sshClient)
-        val result = SshAuthenticationTask(
+        val task = SshAuthenticationTask(
             hostKey = "",
             hostname = "127.0.0.1",
             port = 22222,
             username = "user",
             password = "password"
-        ).execute().get()
-        Shadows.shadowOf(Looper.getMainLooper()).idle()
-        assertNull(result.result)
-        assertNotNull(result.exception)
+        )
+        val latch = CountDownLatch(1)
+        var e: Throwable? = null
+        var result: SSHClient? = null
+        Single.fromCallable(task.getTask())
+            .subscribeOn(Schedulers.io())
+            .observeOn(AndroidSchedulers.mainThread())
+            .subscribe({
+                task.onFinish(it)
+                result = it
+                latch.countDown()
+            }, {
+                task.onError(it)
+                e = it
+                latch.countDown()
+            })
+        latch.await()
+        assertNull(result)
+        assertNotNull(e)
         assertNotNull(ShadowToast.getLatestToast())
         assertEquals(
             ApplicationProvider
@@ -144,18 +182,32 @@ class SshAuthenticationTaskTest {
             `when`(isAuthenticated).thenReturn(true)
         }
         prepareSshConnectionPool(sshClient)
-        val result = SshAuthenticationTask(
+        val task = SshAuthenticationTask(
             hostKey = "",
             hostname = "127.0.0.1",
             port = 22222,
             username = "user",
             privateKey = keyProvider.keyPair
-        ).execute().get()
-        Shadows.shadowOf(Looper.getMainLooper()).idle()
-        assertNotNull(result.result)
-        assertTrue(result.result.isAuthenticated)
-        assertTrue(result.result.isConnected)
-        assertNull(result.exception)
+        )
+        val latch = CountDownLatch(1)
+        var e: Throwable? = null
+        var result: SSHClient? = null
+        Single.fromCallable(task.getTask())
+            .subscribeOn(Schedulers.io())
+            .observeOn(AndroidSchedulers.mainThread())
+            .subscribe({
+                task.onFinish(it)
+                result = it
+                latch.countDown()
+            }, {
+                task.onError(it)
+                e = it
+                latch.countDown()
+            })
+        result?.run {
+            assertTrue(isAuthenticated)
+            assertTrue(isConnected)
+        } ?: fail("Null SSHClient")
     }
 
     /**
@@ -175,16 +227,31 @@ class SshAuthenticationTaskTest {
             `when`(isAuthenticated).thenReturn(true)
         }
         prepareSshConnectionPool(sshClient)
-        val result = SshAuthenticationTask(
+        val task = SshAuthenticationTask(
             hostKey = "",
             hostname = "127.0.0.1",
             port = 22222,
             username = "user",
             privateKey = keyProvider.keyPair
-        ).execute().get()
-        Shadows.shadowOf(Looper.getMainLooper()).idle()
-        assertNull(result.result)
-        assertNotNull(result.exception)
+        )
+        val latch = CountDownLatch(1)
+        var e: Throwable? = null
+        var result: SSHClient? = null
+        Single.fromCallable(task.getTask())
+            .subscribeOn(Schedulers.io())
+            .observeOn(AndroidSchedulers.mainThread())
+            .subscribe({
+                task.onFinish(it)
+                result = it
+                latch.countDown()
+            }, {
+                task.onError(it)
+                e = it
+                latch.countDown()
+            })
+        latch.await()
+        assertNull(result)
+        assertNotNull(e)
         assertNotNull(ShadowToast.getLatestToast())
         assertEquals(
             ApplicationProvider
@@ -210,16 +277,30 @@ class SshAuthenticationTaskTest {
             `when`(isAuthenticated).thenReturn(true)
         }
         prepareSshConnectionPool(sshClient)
-        val result = SshAuthenticationTask(
+        val task = SshAuthenticationTask(
             hostKey = "",
             hostname = "127.0.0.1",
             port = 22222,
             username = "user",
             password = "password"
-        ).execute().get()
-        Shadows.shadowOf(Looper.getMainLooper()).idle()
-        assertNull(result.result)
-        assertNotNull(result.exception)
+        )
+        val latch = CountDownLatch(1)
+        var e: Throwable? = null
+        var result: SSHClient? = null
+        Single.fromCallable(task.getTask())
+            .subscribeOn(Schedulers.io())
+            .observeOn(AndroidSchedulers.mainThread())
+            .subscribe({
+                task.onFinish(it)
+                result = it
+                latch.countDown()
+            }, {
+                task.onError(it)
+                e = it
+                latch.countDown()
+            })
+        assertNull(result)
+        assertNotNull(e)
         assertNotNull(ShadowToast.getLatestToast())
         assertEquals(
             ApplicationProvider
@@ -240,18 +321,19 @@ class SshAuthenticationTaskTest {
          * was not working in the case of Operations.rename() due to the threading model
          * Robolectric imposed. So we are injecting the SSHClient here by force.
          */
-        SshConnectionPool::class.java.getDeclaredField("connections").run {
+        NetCopyClientConnectionPool::class.java.getDeclaredField("connections").run {
             this.isAccessible = true
             this.set(
-                SshConnectionPool,
+                NetCopyClientConnectionPool,
                 mutableMapOf(
                     Pair("ssh://user:password@127.0.0.1:22222", sshClient)
                 )
             )
         }
 
-        SshConnectionPool.sshClientFactory = object : SshConnectionPool.SSHClientFactory {
-            override fun create(config: net.schmizz.sshj.Config?): SSHClient = sshClient
+        NetCopyClientConnectionPool.sshClientFactory = object :
+            NetCopyClientConnectionPool.SSHClientFactory {
+            override fun create(config: net.schmizz.sshj.Config): SSHClient = sshClient
         }
     }
 }
diff --git a/app/src/test/java/com/amaze/filemanager/database/UtilitiesDatabaseMigrationTest.kt b/app/src/test/java/com/amaze/filemanager/database/UtilitiesDatabaseMigrationTest.kt
new file mode 100644
index 000000000..fe79205e7
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/database/UtilitiesDatabaseMigrationTest.kt
@@ -0,0 +1,165 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.database
+
+import android.os.Build.VERSION_CODES.JELLY_BEAN
+import android.os.Build.VERSION_CODES.KITKAT
+import android.os.Build.VERSION_CODES.P
+import android.util.Base64
+import androidx.room.Room
+import androidx.sqlite.db.SupportSQLiteDatabase
+import androidx.sqlite.db.framework.FrameworkSQLiteOpenHelperFactory
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.platform.app.InstrumentationRegistry
+import com.amaze.filemanager.database.UtilitiesDatabase.Companion.COLUMN_HOST_PUBKEY
+import com.amaze.filemanager.database.UtilitiesDatabase.Companion.COLUMN_NAME
+import com.amaze.filemanager.database.UtilitiesDatabase.Companion.COLUMN_PATH
+import com.amaze.filemanager.database.UtilitiesDatabase.Companion.COLUMN_PRIVATE_KEY
+import com.amaze.filemanager.database.UtilitiesDatabase.Companion.COLUMN_PRIVATE_KEY_NAME
+import com.amaze.filemanager.database.UtilitiesDatabase.Companion.TABLE_SFTP
+import com.amaze.filemanager.database.UtilitiesDatabase.Companion.TABLE_SMB
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientUtils
+import com.amaze.filemanager.shadows.ShadowMultiDex
+import com.amaze.filemanager.test.ShadowPasswordUtil
+import com.amaze.filemanager.utils.PasswordUtil
+import com.amaze.filemanager.utils.SmbUtil
+import org.junit.Assert.assertEquals
+import org.junit.Assert.fail
+import org.junit.Rule
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.annotation.Config
+
+/**
+ * Test [UtilitiesDatabase] migration.
+ */
+@RunWith(AndroidJUnit4::class)
+@Config(
+    shadows = [ShadowMultiDex::class, ShadowPasswordUtil::class],
+    sdk = [JELLY_BEAN, KITKAT, P]
+)
+class UtilitiesDatabaseMigrationTest {
+
+    companion object {
+        private const val TEST_DB = "utilities-test"
+    }
+
+    @Rule
+    @JvmField
+    val helper = MigrationTestHelper(
+        InstrumentationRegistry.getInstrumentation(),
+        UtilitiesDatabase::class.java.canonicalName,
+        FrameworkSQLiteOpenHelperFactory()
+    )
+
+    /**
+     * Sanity check for all migrations.
+     */
+    @Test
+    fun migrateAll() {
+        val db = helper.createDatabase(TEST_DB, 1)
+        db.close()
+
+        val utilitiesDatabase = Room.databaseBuilder(
+            InstrumentationRegistry.getInstrumentation().targetContext,
+            UtilitiesDatabase::class.java,
+            TEST_DB
+        )
+            .allowMainThreadQueries()
+            .addMigrations(
+                UtilitiesDatabase.MIGRATION_1_2,
+                UtilitiesDatabase.MIGRATION_2_3,
+                UtilitiesDatabase.MIGRATION_3_4,
+                UtilitiesDatabase.MIGRATION_4_5,
+                UtilitiesDatabase.MIGRATION_5_6
+            )
+            .build()
+        utilitiesDatabase.openHelper.writableDatabase
+        utilitiesDatabase.close()
+    }
+
+    /**
+     * Version 5 migrate to 6 test - test password are migrated without problem
+     */
+    @Test
+    @Suppress("ComplexMethod", "LongMethod", "StringLiteralDuplication")
+    fun testMigrationFrom5To6() {
+        val db: SupportSQLiteDatabase =
+            helper.createDatabase(TEST_DB, 5)
+        val password1 = PasswordUtil.encryptPassword(
+            InstrumentationRegistry.getInstrumentation().targetContext,
+            "passw0rd",
+            Base64.DEFAULT
+        )
+        val password2 = PasswordUtil.encryptPassword(
+            InstrumentationRegistry.getInstrumentation().targetContext,
+            "\\password/%&*()",
+            Base64.DEFAULT
+        )
+        db.execSQL(
+            "INSERT INTO $TABLE_SMB ($COLUMN_NAME, $COLUMN_PATH) " +
+                "VALUES ('test', 'smb://user:$password1@127.0.0.1/user')"
+        )
+        db.execSQL(
+            "INSERT INTO $TABLE_SFTP ($COLUMN_NAME, $COLUMN_PATH, $COLUMN_HOST_PUBKEY) " +
+                "VALUES ('test password', 'ssh://user:$password2@10.0.0.1', '12345678')"
+        )
+        db.execSQL(
+            "INSERT INTO $TABLE_SFTP ($COLUMN_NAME, $COLUMN_PATH, $COLUMN_HOST_PUBKEY, " +
+                "$COLUMN_PRIVATE_KEY_NAME, $COLUMN_PRIVATE_KEY) " +
+                "VALUES ('test no password', 'ssh://user@10.0.0.2', '1234'," +
+                " 'test private key', 'abcd')"
+        )
+        db.close()
+
+        val utilitiesDatabase = Room.databaseBuilder(
+            InstrumentationRegistry.getInstrumentation().targetContext,
+            UtilitiesDatabase::class.java,
+            TEST_DB
+        )
+            .addMigrations(UtilitiesDatabase.MIGRATION_5_6)
+            .allowMainThreadQueries()
+            .build()
+        utilitiesDatabase.openHelper.writableDatabase
+        val smbEntry = utilitiesDatabase.smbEntryDao().list().blockingGet().first()
+        assertEquals(
+            "smb://user:passw0rd@127.0.0.1/user",
+            SmbUtil.getSmbDecryptedPath(
+                InstrumentationRegistry.getInstrumentation().targetContext,
+                smbEntry.path
+            )
+        )
+        val sftpEntries = utilitiesDatabase.sftpEntryDao().list().blockingGet()
+        sftpEntries.find { it.name == "test password" }?.run {
+            assertEquals(
+                "ssh://user:\\password/%&*()@10.0.0.1",
+                NetCopyClientUtils.decryptFtpPathAsNecessary(this.path)
+            )
+        } ?: fail("test password entry not found")
+        sftpEntries.find { it.name == "test no password" }?.run {
+            assertEquals(
+                "ssh://user@10.0.0.2",
+                NetCopyClientUtils.decryptFtpPathAsNecessary(this.path)
+            )
+        } ?: fail("test no password entry not found")
+        utilitiesDatabase.close()
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/database/UtilsHandlerTest.kt b/app/src/test/java/com/amaze/filemanager/database/UtilsHandlerTest.kt
index 3e92419b9..52be6456d 100644
--- a/app/src/test/java/com/amaze/filemanager/database/UtilsHandlerTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/database/UtilsHandlerTest.kt
@@ -29,7 +29,6 @@ import android.os.Environment.DIRECTORY_DOWNLOADS
 import android.os.Environment.DIRECTORY_MOVIES
 import android.os.Environment.DIRECTORY_MUSIC
 import android.os.Environment.DIRECTORY_PICTURES
-import androidx.arch.core.util.Function
 import androidx.room.Room
 import androidx.test.ext.junit.runners.AndroidJUnit4
 import com.amaze.filemanager.application.AppConfig
@@ -65,7 +64,7 @@ class UtilsHandlerTest {
         @BeforeClass
         @JvmStatic
         fun bootstrap() {
-            UtilitiesDatabase.overrideDatabaseBuilder = Function { context ->
+            UtilitiesDatabase.overrideDatabaseBuilder = { context ->
                 Room.inMemoryDatabaseBuilder(context, UtilitiesDatabase::class.java)
             }
         }
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/HybridFileTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/HybridFileTest.kt
index 5e52d3391..83ec4ceb8 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/HybridFileTest.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/HybridFileTest.kt
@@ -25,12 +25,14 @@ import android.os.Build.VERSION_CODES.KITKAT
 import android.os.Build.VERSION_CODES.P
 import androidx.test.core.app.ApplicationProvider
 import androidx.test.ext.junit.runners.AndroidJUnit4
+import com.amaze.filemanager.application.AppConfig
 import com.amaze.filemanager.fileoperations.filesystem.OpenMode
 import com.amaze.filemanager.shadows.ShadowMultiDex
 import org.junit.Assert.assertEquals
 import org.junit.Test
 import org.junit.runner.RunWith
 import org.robolectric.annotation.Config
+import java.net.URLDecoder
 import kotlin.random.Random
 
 @RunWith(AndroidJUnit4::class)
@@ -38,7 +40,7 @@ import kotlin.random.Random
 class HybridFileTest {
 
     /**
-     * Test []
+     * Test [HybridFile.getParent]
      */
     @Test
     fun testGetParentGeneric() {
@@ -79,4 +81,37 @@ class HybridFileTest {
             file.getParent(ApplicationProvider.getApplicationContext())
         )
     }
+
+    /**
+     * Test [HybridFile.getName]
+     */
+    @Test
+    fun testGetName() {
+        for (
+            name: String in arrayOf(
+                "newfolder",
+                "new folder 2",
+                "new%20folder%203",
+                ""
+            )
+        ) {
+            val file = HybridFile(OpenMode.FTP, "ftp://user:password@127.0.0.1/$name")
+            assertEquals(
+                URLDecoder.decode(name, Charsets.UTF_8.name()),
+                file.getName(AppConfig.getInstance())
+            )
+        }
+    }
+
+    /**
+     * Test [HybridFile.getName] for files having space in name
+     */
+    @Test
+    fun testGetName2() {
+        val file = HybridFile(
+            OpenMode.FTP,
+            "ftp://user:password@127.0.0.1:22222/multiple/levels/down the pipe"
+        )
+        assertEquals("down the pipe", file.getName(AppConfig.getInstance()))
+    }
 }
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/OperationsTest.java b/app/src/test/java/com/amaze/filemanager/filesystem/OperationsTest.java
index 41fcddddc..84da62de0 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/OperationsTest.java
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/OperationsTest.java
@@ -372,7 +372,7 @@ public class OperationsTest {
     assertTrue(assertFlag.get());
   }
 
-  private abstract class AbstractErrorCallback implements Operations.ErrorCallBack {
+  public abstract static class AbstractErrorCallback implements Operations.ErrorCallBack {
     @Override
     public void exists(HybridFile file) {}
 
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ftp/FtpHybridFileAnonymousLoginTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/ftp/FtpHybridFileAnonymousLoginTest.kt
new file mode 100644
index 000000000..16484b3c7
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/ftp/FtpHybridFileAnonymousLoginTest.kt
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.filesystem.ftp
+
+import android.os.Environment
+import com.amaze.filemanager.filesystem.ssh.test.TestUtils
+import org.apache.ftpserver.ConnectionConfigFactory
+import org.apache.ftpserver.FtpServerFactory
+import org.apache.ftpserver.usermanager.impl.BaseUser
+import org.apache.ftpserver.usermanager.impl.WritePermission
+
+/**
+ * Test [HybridFile] FTP protocol handling with anonymous logins.
+ */
+class FtpHybridFileAnonymousLoginTest : FtpHybridFileTest() {
+
+    override val ftpPort: Int
+        get() = PORT
+    override val ftpUrl: String
+        get() = NetCopyClientUtils.encryptFtpPathAsNecessary(
+            "${ftpPrefix}127.0.0.1:$ftpPort"
+        )
+
+    override fun saveConnectionSettings() {
+        TestUtils.saveFtpConnectionSettings("", "")
+    }
+
+    companion object {
+
+        private const val PORT = 2223
+
+        /**
+         * Extracted [FtpServerFactory] with anonymous login support into separate factory method.
+         */
+        @JvmStatic
+        fun createAnonymousFtpServerFactory(): FtpServerFactory = FtpServerFactory().also {
+            val connectionConfigFactory = ConnectionConfigFactory()
+            connectionConfigFactory.isAnonymousLoginEnabled = true
+            val user = BaseUser()
+            user.name = FTPClientImpl.ANONYMOUS
+            user.homeDirectory = Environment.getExternalStorageDirectory().absolutePath
+            user.authorities = listOf(WritePermission())
+            it.userManager.save(user)
+            it.connectionConfig = connectionConfigFactory.createConnectionConfig()
+        }
+    }
+
+    override fun createFtpServerFactory(): FtpServerFactory {
+        return createAnonymousFtpServerFactory().also {
+            it.addListener(
+                "default",
+                createDefaultFtpServerListener()
+            )
+        }
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ftp/FtpHybridFileTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/ftp/FtpHybridFileTest.kt
new file mode 100644
index 000000000..5532759ef
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/ftp/FtpHybridFileTest.kt
@@ -0,0 +1,347 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.filesystem.ftp
+
+import android.os.Build.VERSION_CODES.P
+import android.os.Environment
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import androidx.test.filters.FlakyTest
+import com.amaze.filemanager.application.AppConfig
+import com.amaze.filemanager.asynchronous.services.FtpServiceAndroidFileSystemIntegrationTest
+import com.amaze.filemanager.fileoperations.filesystem.OpenMode
+import com.amaze.filemanager.filesystem.HybridFile
+import com.amaze.filemanager.filesystem.Operations
+import com.amaze.filemanager.filesystem.OperationsTest
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.FTP_URI_PREFIX
+import com.amaze.filemanager.filesystem.ssh.test.TestUtils
+import com.amaze.filemanager.shadows.ShadowMultiDex
+import com.amaze.filemanager.test.ShadowPasswordUtil
+import io.reactivex.android.plugins.RxAndroidPlugins
+import io.reactivex.plugins.RxJavaPlugins
+import io.reactivex.schedulers.Schedulers
+import org.apache.commons.net.ftp.FTPClient
+import org.apache.ftpserver.ConnectionConfigFactory
+import org.apache.ftpserver.FtpServer
+import org.apache.ftpserver.FtpServerFactory
+import org.apache.ftpserver.listener.Listener
+import org.apache.ftpserver.listener.ListenerFactory
+import org.apache.ftpserver.usermanager.impl.BaseUser
+import org.apache.ftpserver.usermanager.impl.WritePermission
+import org.awaitility.Awaitility.await
+import org.junit.*
+import org.junit.Assert.*
+import org.junit.runner.RunWith
+import org.robolectric.annotation.Config
+import java.io.File
+import java.net.InetAddress.getLoopbackAddress
+import java.net.InetSocketAddress
+import java.net.Socket
+import java.net.SocketException
+import java.util.concurrent.CountDownLatch
+import java.util.concurrent.TimeUnit
+
+@RunWith(AndroidJUnit4::class)
+@Config(
+    sdk = [P],
+    shadows = [ShadowPasswordUtil::class, ShadowMultiDex::class]
+)
+@Suppress("StringLiteralDuplication")
+open class FtpHybridFileTest {
+
+    protected lateinit var tmpFile: File
+    protected lateinit var hybridFile: HybridFile
+    protected lateinit var ftpServer: FtpServer
+
+    protected open val ftpPrefix: String
+        get() = FTP_URI_PREFIX
+
+    /**
+     * Workaround. Tests are being run in parallel, hence different FTP server integration
+     * tests will need a different port to prevent port in use exceptions.
+     */
+    protected open val ftpPort: Int
+        get() = PORT
+    protected open val ftpUrl: String
+        get() = NetCopyClientUtils.encryptFtpPathAsNecessary(
+            "${ftpPrefix}$USERNAME:$PASSWORD@127.0.0.1:$ftpPort"
+        )
+
+    companion object {
+        const val USERNAME = "ftpuser"
+        const val PASSWORD = "passw0rD"
+
+        private const val PORT = 2221
+    }
+
+    /**
+     * Setup FTP server for testing.
+     *
+     * Just like [AbstractSftpServerTest], have to use setUp and tearDown instead of static init/
+     * destroy methods for tests to work.
+     */
+    @Before
+    open fun setUp() {
+        RxJavaPlugins.reset()
+        RxJavaPlugins.setIoSchedulerHandler {
+            Schedulers.trampoline()
+        }
+        RxAndroidPlugins.reset()
+        RxAndroidPlugins.setInitMainThreadSchedulerHandler {
+            Schedulers.trampoline()
+        }
+        NetCopyClientUtils.getScheduler = {
+            Schedulers.trampoline()
+        }
+        Environment.getExternalStorageDirectory().run {
+            FtpServiceAndroidFileSystemIntegrationTest.directories.forEach { dir ->
+                File(this, dir).mkdirs()
+            }
+        }
+        tmpFile = File.createTempFile("test", ".bin")
+        tmpFile.deleteOnExit()
+        ftpServer = createFtpServerFactory().createServer()
+        ftpServer.start()
+        saveConnectionSettings()
+        await().atMost(30, TimeUnit.SECONDS).until { isServerReady() }
+        val verify = createConnection()
+        verify?.run {
+            assertTrue(this is FTPClientImpl)
+            assertNotNull(getClientImpl())
+            hybridFile = HybridFile(OpenMode.FTP, ftpUrl)
+            assertTrue(hybridFile.isFtp)
+        } ?: fail(
+            "Unable to obtain connection.\n" +
+                "\n" +
+                " Was trying $ftpUrl, FTP server is running at " +
+                getLoopbackAddress().hostAddress +
+                " and port $ftpPort"
+        )
+    }
+
+    /**
+     * Shutdown FTP server.
+     */
+    @After
+    fun tearDown() {
+        if (!ftpServer.isStopped) {
+            ftpServer.stop()
+        }
+        if (tmpFile.exists()) {
+            tmpFile.delete()
+        }
+        NetCopyClientConnectionPool.shutdown()
+    }
+
+//    /**
+//     * Test list files
+//     *
+//     * @see HybridFile.forEachChildrenFile
+//     * @see HybridFile.listFiles
+//     */
+//    @Test
+//    @FlakyTest()
+//    fun testListFile() {
+//        val files = hybridFile.listFiles(AppConfig.getInstance(), false)
+//        assertEquals(FtpServiceAndroidFileSystemIntegrationTest.directories.size, files.size)
+//    }
+//
+//    /**
+//     * Test create file
+//     *
+//     * @see Operations.mkfile
+//     */
+//    @Test
+//    @FlakyTest()
+//    fun testMkFile() {
+//        val newFile = HybridFile(OpenMode.FTP, "$ftpUrl/${tmpFile.name}")
+//        val latch = CountDownLatch(1)
+//        Operations.mkfile(
+//            hybridFile,
+//            newFile,
+//            AppConfig.getInstance(),
+//            false,
+//            object : OperationsTest.AbstractErrorCallback() {
+//                override fun done(file: HybridFile?, b: Boolean) {
+//                    assertTrue(true == file?.exists())
+//                    assertEquals(newFile.path, file?.path)
+//                    assertNotNull(file?.ftpFile)
+//                    latch.countDown()
+//                }
+//            }
+//        )
+//        latch.await()
+//    }
+//
+//    /**
+//     * Test rename file
+//     *
+//     * @see Operations.rename
+//     */
+//    @Test
+//    @FlakyTest()
+//    fun testRenameFile() {
+//        val oldFile = HybridFile(OpenMode.FTP, "$ftpUrl/${tmpFile.name}")
+//        val newFile = HybridFile(OpenMode.FTP, "$ftpUrl/${tmpFile.name}-new")
+//        var latch = CountDownLatch(1)
+//        Operations.mkfile(
+//            hybridFile,
+//            oldFile,
+//            AppConfig.getInstance(),
+//            false,
+//            object : OperationsTest.AbstractErrorCallback() {
+//                override fun done(file: HybridFile?, b: Boolean) {
+//                    assertTrue(true == file?.exists())
+//                    assertEquals(oldFile.path, file?.path)
+//                    assertNotNull(file?.ftpFile)
+//                    latch.countDown()
+//                }
+//            }
+//        )
+//        latch.await()
+//        latch = CountDownLatch(1)
+//        Operations.rename(
+//            oldFile,
+//            newFile,
+//            false,
+//            AppConfig.getInstance(),
+//            object : OperationsTest.AbstractErrorCallback() {
+//                override fun done(file: HybridFile?, b: Boolean) {
+//                    assertTrue(true == file?.exists())
+//                    assertFalse(oldFile.exists())
+//                    assertTrue(newFile.exists())
+//                    assertEquals(newFile.path, file?.path)
+//                    assertNotNull(file?.ftpFile)
+//                    latch.countDown()
+//                }
+//            }
+//        )
+//        latch.await()
+//    }
+//
+//    /**
+//     * Test file I/O.
+//     *
+//     * @see HybridFile.getOutputStream
+//     * @see HybridFile.getInputStream
+//     */
+//    @Test
+//    @FlakyTest()
+//    fun testFileIO() {
+//        val randomBytes = Random(System.currentTimeMillis()).nextBytes(32)
+//        val f = HybridFile(
+//            OpenMode.FTP,
+//            "$ftpUrl/${tmpFile.name}"
+//        )
+//        f.getOutputStream(AppConfig.getInstance())?.run {
+//            ByteArrayInputStream(randomBytes).copyTo(this)
+//            this.close()
+//        } ?: fail("Unable to get OutputStream")
+//        await().atMost(10, TimeUnit.SECONDS).until {
+//            randomBytes.size.toLong() == f.length(AppConfig.getInstance())
+//        }
+//        f.getInputStream(AppConfig.getInstance())?.run {
+//            val verify = this.readBytes()
+//            assertArrayEquals(randomBytes, verify)
+//        } ?: fail("Unable to get InputStream")
+//    }
+
+    /**
+     * Test create dir.
+     *
+     * @see Operations.mkdir
+     */
+    @Test
+    @FlakyTest()
+    fun testMkdir() {
+        for (
+            dir: String in arrayOf(
+//                "newfolder",
+//                "new folder 2",
+                "new%20folder%203",
+                "",
+                "multiple/levels/down the pipe"
+            )
+        ) {
+            val newFile = HybridFile(OpenMode.FTP, "$ftpUrl/$dir")
+            val latch = CountDownLatch(1)
+            Operations.mkdir(
+                hybridFile,
+                newFile,
+                AppConfig.getInstance(),
+                false,
+                object : OperationsTest.AbstractErrorCallback() {
+                    override fun done(file: HybridFile?, b: Boolean) {
+                        assertTrue(true == file?.exists())
+                        assertEquals(newFile.path, file?.path)
+                        latch.countDown()
+                    }
+                }
+            )
+            latch.await()
+        }
+    }
+
+    protected open fun beforeCreateFtpServer() = Unit
+
+    protected open fun saveConnectionSettings() =
+        TestUtils.saveFtpConnectionSettings(USERNAME, PASSWORD)
+
+    protected open fun createConnection(): NetCopyClient<FTPClient>? {
+        return NetCopyClientConnectionPool.getConnection(ftpUrl)
+    }
+
+    protected open fun createFtpServerFactory(): FtpServerFactory {
+        return FtpServerFactory().also {
+            val connectionConfigFactory = ConnectionConfigFactory()
+            val user = BaseUser()
+            user.name = USERNAME
+            user.password = PASSWORD
+            user.homeDirectory = Environment.getExternalStorageDirectory().absolutePath
+            user.authorities = listOf(WritePermission())
+            it.userManager.save(user)
+            it.connectionConfig = connectionConfigFactory.createConnectionConfig()
+            it.addListener(
+                "default",
+                createDefaultFtpServerListener()
+            )
+        }
+    }
+
+    protected open fun createDefaultFtpServerListener(): Listener {
+        return ListenerFactory().apply {
+            port = ftpPort
+            serverAddress = "127.0.0.1"
+        }.createListener()
+    }
+
+    private fun isServerReady(): Boolean {
+        return Socket().let {
+            try {
+                it.connect(InetSocketAddress("127.0.0.1", ftpPort))
+                true
+            } catch (e: SocketException) {
+                false
+            } finally {
+                it.close()
+            }
+        }
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ftp/FtpsHybridFileAnonymousLoginTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/ftp/FtpsHybridFileAnonymousLoginTest.kt
new file mode 100644
index 000000000..9585a500a
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/ftp/FtpsHybridFileAnonymousLoginTest.kt
@@ -0,0 +1,54 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.filesystem.ftp
+
+import com.amaze.filemanager.filesystem.ssh.test.TestUtils
+import org.apache.ftpserver.FtpServerFactory
+import org.junit.Ignore
+
+/**
+ * Test [HybridFile] FTP protocol over secure connection handling with anonymous logins.
+ */
+@Ignore
+class FtpsHybridFileAnonymousLoginTest : FtpsHybridFileTest() {
+
+    override val ftpPort: Int
+        get() = PORT
+    override val ftpUrl: String
+        get() = NetCopyClientUtils.encryptFtpPathAsNecessary(
+            "${ftpPrefix}127.0.0.1:$ftpPort"
+        )
+
+    companion object {
+        private const val PORT = 2224
+    }
+
+    override fun saveConnectionSettings() =
+        TestUtils.saveFtpConnectionSettings("", "", certInfo, PORT)
+
+    override fun createFtpServerFactory(): FtpServerFactory =
+        FtpHybridFileAnonymousLoginTest.createAnonymousFtpServerFactory().also {
+            it.addListener(
+                "default",
+                createDefaultFtpServerListener()
+            )
+        }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ftp/FtpsHybridFileTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/ftp/FtpsHybridFileTest.kt
new file mode 100644
index 000000000..0cda1778a
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/ftp/FtpsHybridFileTest.kt
@@ -0,0 +1,94 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.filesystem.ftp
+
+import com.amaze.filemanager.BuildConfig
+import com.amaze.filemanager.R
+import com.amaze.filemanager.application.AppConfig
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.FTPS_URI_PREFIX
+import com.amaze.filemanager.filesystem.ssh.test.TestUtils
+import com.amaze.filemanager.utils.X509CertificateUtil
+import org.apache.ftpserver.listener.Listener
+import org.apache.ftpserver.listener.ListenerFactory
+import org.apache.ftpserver.ssl.ClientAuth
+import org.apache.ftpserver.ssl.impl.DefaultSslConfiguration
+import org.json.JSONObject
+import org.junit.Ignore
+import java.security.KeyStore
+import javax.net.ssl.KeyManagerFactory
+import javax.net.ssl.TrustManagerFactory
+import javax.security.cert.X509Certificate
+
+@Ignore
+open class FtpsHybridFileTest : FtpHybridFileTest() {
+
+    private lateinit var keyStore: KeyStore
+    private lateinit var keyStorePassword: CharArray
+    protected lateinit var certInfo: JSONObject
+
+    override val ftpPrefix: String
+        get() = FTPS_URI_PREFIX
+    override val ftpPort: Int
+        get() = PORT
+
+    companion object {
+        private const val PORT = 2222
+    }
+
+    override fun setUp() {
+        keyStore = KeyStore.getInstance("BKS")
+        keyStorePassword = BuildConfig.FTP_SERVER_KEYSTORE_PASSWORD.toCharArray()
+        keyStore.load(
+            AppConfig.getInstance().resources.openRawResource(R.raw.key),
+            keyStorePassword
+        )
+        certInfo = JSONObject(
+            X509CertificateUtil.parse(
+                X509Certificate.getInstance(keyStore.getCertificate("ftpserver").encoded)
+            )
+        )
+        super.setUp()
+    }
+
+    override fun saveConnectionSettings() =
+        TestUtils.saveFtpConnectionSettings(USERNAME, PASSWORD, certInfo, PORT)
+
+    override fun createDefaultFtpServerListener(): Listener {
+        val keyManagerFactory = KeyManagerFactory
+            .getInstance(KeyManagerFactory.getDefaultAlgorithm())
+        keyManagerFactory.init(keyStore, keyStorePassword)
+        val trustManagerFactory = TrustManagerFactory
+            .getInstance(TrustManagerFactory.getDefaultAlgorithm())
+        trustManagerFactory.init(keyStore)
+        return ListenerFactory().apply {
+            sslConfiguration = DefaultSslConfiguration(
+                keyManagerFactory,
+                trustManagerFactory,
+                ClientAuth.WANT,
+                "TLSv1.2",
+                null,
+                "ftpserver"
+            )
+            isImplicitSsl = true
+            port = ftpPort
+        }.createListener()
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ftp/NetCopyClientConnectionPoolFtpTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/ftp/NetCopyClientConnectionPoolFtpTest.kt
new file mode 100644
index 000000000..2103f4c84
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/ftp/NetCopyClientConnectionPoolFtpTest.kt
@@ -0,0 +1,463 @@
+/*
+ * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.filesystem.ftp
+
+import android.os.Build.VERSION_CODES.JELLY_BEAN
+import android.os.Build.VERSION_CODES.KITKAT
+import android.os.Build.VERSION_CODES.P
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.FTP_URI_PREFIX
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.getConnection
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.shutdown
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientUtils.encryptFtpPathAsNecessary
+import com.amaze.filemanager.filesystem.ssh.test.TestUtils
+import com.amaze.filemanager.shadows.ShadowMultiDex
+import com.amaze.filemanager.test.ShadowPasswordUtil
+import io.reactivex.android.plugins.RxAndroidPlugins
+import io.reactivex.plugins.RxJavaPlugins
+import io.reactivex.schedulers.Schedulers
+import org.apache.commons.net.ftp.FTPClient
+import org.junit.After
+import org.junit.Assert.assertNotNull
+import org.junit.Assert.assertNull
+import org.junit.BeforeClass
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.AdditionalMatchers.not
+import org.mockito.Mockito
+import org.mockito.Mockito.atMostOnce
+import org.mockito.Mockito.`when`
+import org.mockito.kotlin.atLeastOnce
+import org.mockito.kotlin.doNothing
+import org.mockito.kotlin.eq
+import org.mockito.kotlin.times
+import org.mockito.kotlin.verify
+import org.robolectric.annotation.Config
+import org.robolectric.shadows.ShadowSQLiteConnection
+import java.io.IOException
+
+/**
+ * Unit tests for [NetCopyClientConnectionPool] with FTP connections.
+ */
+@Suppress("LargeClass", "StringLiteralDuplication")
+@RunWith(AndroidJUnit4::class)
+@Config(
+    shadows = [ShadowMultiDex::class, ShadowPasswordUtil::class],
+    sdk = [JELLY_BEAN, KITKAT, P]
+)
+class NetCopyClientConnectionPoolFtpTest {
+
+    /**
+     * Post test cleanup.
+     */
+    @After
+    fun tearDown() {
+        shutdown()
+        ShadowSQLiteConnection.reset()
+    }
+
+    /**
+     * Test getting connections with username and password.
+     */
+    @Test
+    fun testGetConnectionWithUsernameAndPassword() {
+        val mock = createFTPClient("testuser", "testpassword")
+        assertNotNull(
+            getConnection(
+                protocol = FTP_URI_PREFIX,
+                host = HOST,
+                port = PORT,
+                username = "testuser",
+                password = "testpassword"
+            )
+        )
+        assertNull(
+            getConnection(
+                protocol = FTP_URI_PREFIX,
+                host = HOST,
+                port = PORT,
+                username = "invaliduser",
+                password = "invalidpassword"
+            )
+        )
+        verify(mock, times(2)).connect(HOST, PORT)
+        verify(mock).login("testuser", "testpassword")
+        verify(mock).login("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with an URL/URI.
+     */
+    @Test
+    fun testGetConnectionWithUrl() {
+        val validPassword = "testpassword"
+        val mock = createFTPClient("testuser", validPassword)
+        TestUtils.saveFtpConnectionSettings("testuser", validPassword)
+        assertNotNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://testuser:testpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce()).connectTimeout = NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).login("testuser", "testpassword")
+        verify(mock, atMostOnce()).login("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI having complex password (case 1)
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testGetConnectionWithUrlHavingComplexPassword1() {
+        val validPassword = "testP@ssw0rd"
+        val mock = createFTPClient("testuser", validPassword)
+        TestUtils.saveFtpConnectionSettings("testuser", validPassword)
+        assertNotNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://testuser:testP@ssw0rd@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce()).connectTimeout = NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).login("testuser", validPassword)
+        verify(mock, atMostOnce()).login("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI having complex password (case 2)
+     */
+    @Test
+    fun testGetConnectionWithUrlHavingComplexPassword2() {
+        val validPassword = "testP@##word"
+        val mock = createFTPClient("testuser", validPassword)
+        TestUtils.saveFtpConnectionSettings("testuser", validPassword)
+        assertNotNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://testuser:testP@##word@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce()).connectTimeout = NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).login("testuser", validPassword)
+        verify(mock, atMostOnce()).login("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI having complex credentials (case 1)
+     */
+    @Test
+    fun testGetConnectionWithUrlHavingComplexCredential1() {
+        val validPassword = "testP@##word"
+        val mock = createFTPClient("testuser", validPassword)
+        TestUtils.saveFtpConnectionSettings("testuser", validPassword)
+        assertNotNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://testuser:testP@##word@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce()).connectTimeout = NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).login("testuser", validPassword)
+        verify(mock, atMostOnce()).login("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI having complex credentials (case 2)
+     */
+    @Test
+    fun testGetConnectionWithUrlHavingComplexCredential2() {
+        val validPassword = "testP@##word"
+        val mock = createFTPClient("testuser", validPassword)
+        TestUtils.saveFtpConnectionSettings("testuser", validPassword)
+        assertNotNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://testuser:testP@##word@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce()).connectTimeout = NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).login("testuser", validPassword)
+        verify(mock, atMostOnce()).login("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI having complex credentials (case 3)
+     */
+    @Test
+    fun testGetConnectionWithUrlHavingComplexCredential3() {
+        val validUsername = "test@example.com"
+        val validPassword = "testP@ssw0rd"
+        val mock = createFTPClient(validUsername, validPassword)
+        TestUtils.saveFtpConnectionSettings(validUsername, validPassword)
+        assertNotNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://test@example.com:testP@ssw0rd@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce()).connectTimeout = NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).login(validUsername, validPassword)
+        verify(mock, atMostOnce()).login("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI having complex credentials (case 4)
+     */
+    @Test
+    fun testGetConnectionWithUrlHavingComplexCredential4() {
+        val validUsername = "test@example.com"
+        val validPassword = "testP@ssw0##$"
+        val mock = createFTPClient(validUsername, validPassword)
+        TestUtils.saveFtpConnectionSettings(validUsername, validPassword)
+        assertNotNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://test@example.com:testP@ssw0##$@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce()).connectTimeout = NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).login(validUsername, validPassword)
+        verify(mock, atMostOnce()).login("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI having minus sign in password (case 1)
+     */
+    @Test
+    fun testGetConnectionWithUrlHavingMinusSignInPassword1() {
+        val validUsername = "test@example.com"
+        val validPassword = "abcd-efgh"
+        val mock = createFTPClient(validUsername, validPassword)
+        TestUtils.saveFtpConnectionSettings(validUsername, validPassword)
+        assertNotNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://test@example.com:abcd-efgh@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce()).connectTimeout = NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).login(validUsername, validPassword)
+        verify(mock, atMostOnce()).login("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI having minus sign in password (case 2)
+     */
+    @Test
+    fun testGetConnectionWithUrlHavingMinusSignInPassword2() {
+        val validUsername = "test@example.com"
+        val validPassword = "---------------"
+        val mock = createFTPClient(validUsername, validPassword)
+        TestUtils.saveFtpConnectionSettings(validUsername, validPassword)
+        assertNotNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://test@example.com:---------------@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce()).connectTimeout = NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).login(validUsername, validPassword)
+        verify(mock, atMostOnce()).login("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI having minus sign in password (case 3)
+     */
+    @Test
+    fun testGetConnectionWithUrlHavingMinusSignInPassword3() {
+        val validUsername = "test@example.com"
+        val validPassword = "--agdiuhdpost15"
+        val mock = createFTPClient(validUsername, validPassword)
+        TestUtils.saveFtpConnectionSettings(validUsername, validPassword)
+        assertNotNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://test@example.com:--agdiuhdpost15@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce()).connectTimeout = NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).login(validUsername, validPassword)
+        verify(mock, atMostOnce()).login("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI having minus sign in password (case 4)
+     */
+    @Test
+    fun testGetConnectionWithUrlHavingMinusSignInPassword4() {
+        val validUsername = "test@example.com"
+        val validPassword = "t-h-i-s-i-s-p-a-s-s-w-o-r-d-"
+        val mock = createFTPClient(validUsername, validPassword)
+        TestUtils.saveFtpConnectionSettings(validUsername, validPassword)
+        assertNotNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://test@example.com:t-h-i-s-i-s-p-a-s-s-w-o-r-d-@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<FTPClient>(
+                encryptFtpPathAsNecessary(
+                    "ftp://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce()).connectTimeout = NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).login(validUsername, validPassword)
+        verify(mock, atMostOnce()).login("invaliduser", "invalidpassword")
+    }
+
+    private fun createFTPClient(validUsername: String, validPassword: String): FTPClient {
+        val mock = Mockito.mock(FTPClient::class.java)
+        doNothing().`when`(mock).connect(HOST, PORT)
+        doNothing().`when`(mock).disconnect()
+        `when`(mock.login(validUsername, validPassword)).thenReturn(true)
+        `when`(
+            mock.login(
+                not(eq(validUsername)),
+                not(
+                    eq(validPassword)
+                )
+            )
+        ).thenReturn(false)
+        // reset(mock);
+        NetCopyClientConnectionPool.ftpClientFactory =
+            object : NetCopyClientConnectionPool.FTPClientFactory {
+                override fun create(uri: String): FTPClient = mock
+            }
+        return mock
+    }
+
+    companion object {
+
+        const val HOST = "127.0.0.1"
+        const val PORT = 22222
+
+        /**
+         * Bootstrap the unit test
+         */
+        @BeforeClass
+        @JvmStatic
+        fun bootstrap() {
+            RxJavaPlugins.reset()
+            RxJavaPlugins.setIoSchedulerHandler {
+                Schedulers.trampoline()
+            }
+            RxAndroidPlugins.reset()
+            RxAndroidPlugins.setInitMainThreadSchedulerHandler {
+                Schedulers.trampoline()
+            }
+        }
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ftp/NetCopyClientUtilTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/ftp/NetCopyClientUtilTest.kt
new file mode 100644
index 000000000..83ad4dc7a
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/ftp/NetCopyClientUtilTest.kt
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.filesystem.ftp
+
+import org.junit.Assert.assertEquals
+import org.junit.Test
+
+@Suppress("StringLiteralDuplication")
+class NetCopyClientUtilTest {
+    /**
+     * Test [NetCopyClientUtils.extractRemotePathFrom].
+     */
+    @Test
+    fun testExtractRemotePathFromUri() {
+        assertEquals(
+            "/home/user/foo/bar",
+            NetCopyClientUtils.extractRemotePathFrom(
+                "ssh://user:password@127.0.0.1:22/home/user/foo/bar"
+            )
+        )
+        assertEquals(
+            "/",
+            NetCopyClientUtils.extractRemotePathFrom("ssh://user:password@127.0.0.1:22/")
+        )
+        assertEquals(
+            "/",
+            NetCopyClientUtils.extractRemotePathFrom("ssh://user:password@127.0.0.1:22")
+        )
+        assertEquals(
+            "/",
+            NetCopyClientUtils.extractRemotePathFrom("ssh://root:a8/875dbc-==@127.0.0.1:9899")
+        )
+        assertEquals(
+            "/root/.config",
+            NetCopyClientUtils.extractRemotePathFrom(
+                "ssh://root:a8/875dbc-==@127.0.0.1:9899/root/.config"
+            )
+        )
+        assertEquals(
+            "/Incoming/shared",
+            NetCopyClientUtils.extractRemotePathFrom("ftp://127.0.0.1:2211/Incoming/shared")
+        )
+        assertEquals(
+            "/pub/notice.txt",
+            NetCopyClientUtils.extractRemotePathFrom("ftp://127.0.0.1:2211/pub/notice.txt")
+        )
+    }
+
+    /**
+     * Test [NetCopyClientUtils.extractRemotePathFrom].
+     */
+    @Test
+    fun testExtractBaseUriFromUri() {
+        assertEquals(
+            "ssh://root@127.0.0.1",
+            NetCopyClientUtils.extractBaseUriFrom("ssh://root@127.0.0.1")
+        )
+        assertEquals(
+            "ssh://root@127.0.0.1:2233",
+            NetCopyClientUtils.extractBaseUriFrom("ssh://root@127.0.0.1:2233")
+        )
+        assertEquals(
+            "ssh://root@127.0.0.1",
+            NetCopyClientUtils.extractBaseUriFrom("ssh://root@127.0.0.1/root/.config")
+        )
+        assertEquals(
+            "ssh://root:password@127.0.0.1",
+            NetCopyClientUtils.extractBaseUriFrom("ssh://root:password@127.0.0.1")
+        )
+        assertEquals(
+            "ssh://root:password@127.0.0.1:3456",
+            NetCopyClientUtils.extractBaseUriFrom("ssh://root:password@127.0.0.1:3456/root/.config")
+        )
+        assertEquals(
+            "ssh://root:a8/875dbc-==@127.0.0.1:9899",
+            NetCopyClientUtils.extractBaseUriFrom("ssh://root:a8/875dbc-==@127.0.0.1:9899")
+        )
+        assertEquals(
+            "ssh://root:a8/875dbc-==@127.0.0.1:9899",
+            NetCopyClientUtils.extractBaseUriFrom(
+                "ssh://root:a8/875dbc-==@127.0.0.1:9899/root/.config"
+            )
+        )
+        assertEquals(
+            "ftp://127.0.0.1:2211",
+            NetCopyClientUtils.extractBaseUriFrom("ftp://127.0.0.1:2211")
+        )
+        assertEquals(
+            "ftp://127.0.0.1:2211",
+            NetCopyClientUtils.extractBaseUriFrom("ftp://127.0.0.1:2211/Incoming/shared")
+        )
+        assertEquals(
+            "ftp://127.0.0.1:2211",
+            NetCopyClientUtils.extractBaseUriFrom("ftp://127.0.0.1:2211/pub/notice.txt")
+        )
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/AbstractSftpServerTest.java b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/AbstractSftpServerTest.java
index 6ce607a1f..71af20c96 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/AbstractSftpServerTest.java
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/AbstractSftpServerTest.java
@@ -23,11 +23,12 @@ package com.amaze.filemanager.filesystem.ssh;
 import static android.os.Build.VERSION_CODES.JELLY_BEAN;
 import static android.os.Build.VERSION_CODES.KITKAT;
 import static android.os.Build.VERSION_CODES.P;
+import static com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.SSH_URI_PREFIX;
 
 import java.io.IOException;
 import java.net.BindException;
 import java.nio.file.Paths;
-import java.util.Arrays;
+import java.util.Collections;
 
 import org.apache.sshd.common.config.keys.KeyUtils;
 import org.apache.sshd.common.file.FileSystemFactory;
@@ -42,6 +43,7 @@ import org.junit.BeforeClass;
 import org.junit.runner.RunWith;
 import org.robolectric.annotation.Config;
 
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool;
 import com.amaze.filemanager.filesystem.ssh.test.TestKeyProvider;
 import com.amaze.filemanager.shadows.ShadowMultiDex;
 
@@ -49,6 +51,10 @@ import android.os.Environment;
 
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 
+import io.reactivex.android.plugins.RxAndroidPlugins;
+import io.reactivex.plugins.RxJavaPlugins;
+import io.reactivex.schedulers.Schedulers;
+
 @RunWith(AndroidJUnit4.class)
 @Config(
     shadows = {ShadowMultiDex.class},
@@ -64,6 +70,11 @@ public abstract class AbstractSftpServerTest {
   @BeforeClass
   public static void bootstrap() throws Exception {
     hostKeyProvider = new TestKeyProvider();
+
+    RxJavaPlugins.reset();
+    RxJavaPlugins.setIoSchedulerHandler(scheduler -> Schedulers.trampoline());
+    RxAndroidPlugins.reset();
+    RxAndroidPlugins.setInitMainThreadSchedulerHandler(scheduler -> Schedulers.trampoline());
   }
 
   @Before
@@ -78,7 +89,7 @@ public abstract class AbstractSftpServerTest {
 
   @After
   public void tearDown() throws IOException {
-    SshConnectionPool.INSTANCE.shutdown();
+    NetCopyClientConnectionPool.INSTANCE.shutdown();
     if (server != null && server.isOpen()) {
       server.stop(true);
     }
@@ -86,8 +97,8 @@ public abstract class AbstractSftpServerTest {
 
   protected final void prepareSshConnection() {
     String hostFingerprint = KeyUtils.getFingerPrint(hostKeyProvider.getKeyPair().getPublic());
-    SshConnectionPool.INSTANCE.getConnection(
-        "127.0.0.1", serverPort, hostFingerprint, "testuser", "testpassword", null);
+    NetCopyClientConnectionPool.INSTANCE.getConnection(
+        SSH_URI_PREFIX, "127.0.0.1", serverPort, hostFingerprint, "testuser", "testpassword", null);
   }
 
   protected final int createSshServer(FileSystemFactory fileSystemFactory, int startPort)
@@ -100,7 +111,7 @@ public abstract class AbstractSftpServerTest {
     server.setHost("127.0.0.1");
     server.setKeyPairProvider(hostKeyProvider);
     server.setCommandFactory(new ScpCommandFactory());
-    server.setSubsystemFactories(Arrays.asList(new SftpSubsystemFactory()));
+    server.setSubsystemFactories(Collections.singletonList(new SftpSubsystemFactory()));
     server.setPasswordAuthenticator(
         ((username, password, session) ->
             username.equals("testuser") && password.equals("testpassword")));
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/NetCopyClientConnectionPoolSshTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/NetCopyClientConnectionPoolSshTest.kt
new file mode 100644
index 000000000..f65799ae0
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/NetCopyClientConnectionPoolSshTest.kt
@@ -0,0 +1,831 @@
+/*
+ * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.filesystem.ssh
+
+import android.os.Build.VERSION_CODES.JELLY_BEAN
+import android.os.Build.VERSION_CODES.KITKAT
+import android.os.Build.VERSION_CODES.P
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.SSHClientFactory
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.SSH_URI_PREFIX
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.getConnection
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.shutdown
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientUtils.encryptFtpPathAsNecessary
+import com.amaze.filemanager.filesystem.ssh.test.TestUtils
+import com.amaze.filemanager.shadows.ShadowMultiDex
+import com.amaze.filemanager.test.ShadowPasswordUtil
+import com.amaze.filemanager.utils.Utils
+import io.reactivex.android.plugins.RxAndroidPlugins
+import io.reactivex.plugins.RxJavaPlugins
+import io.reactivex.schedulers.Schedulers
+import net.schmizz.sshj.SSHClient
+import net.schmizz.sshj.common.KeyType
+import net.schmizz.sshj.common.SecurityUtils
+import net.schmizz.sshj.userauth.UserAuthException
+import net.schmizz.sshj.userauth.keyprovider.KeyProvider
+import org.junit.After
+import org.junit.Assert.assertNotNull
+import org.junit.Assert.assertNull
+import org.junit.BeforeClass
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.mockito.AdditionalMatchers.not
+import org.mockito.Mockito
+import org.mockito.Mockito.`when`
+import org.mockito.kotlin.atLeastOnce
+import org.mockito.kotlin.doNothing
+import org.mockito.kotlin.doThrow
+import org.mockito.kotlin.eq
+import org.mockito.kotlin.never
+import org.mockito.kotlin.times
+import org.mockito.kotlin.verify
+import org.robolectric.annotation.Config
+import org.robolectric.shadows.ShadowSQLiteConnection
+import java.io.IOException
+import java.security.KeyPair
+
+/**
+ * Tests for [NetCopyClientConnectionPool] with SSH connections.
+ */
+@Suppress("LargeClass", "StringLiteralDuplication")
+@RunWith(AndroidJUnit4::class)
+@Config(
+    shadows = [ShadowMultiDex::class, ShadowPasswordUtil::class],
+    sdk = [JELLY_BEAN, KITKAT, P]
+)
+class NetCopyClientConnectionPoolSshTest {
+
+    /**
+     * Post test cleanup.
+     */
+    @After
+    fun tearDown() {
+        shutdown()
+        ShadowSQLiteConnection.reset()
+    }
+
+    /**
+     * Test getting connections with username and password.
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testGetConnectionWithUsernameAndPassword() {
+        val mock = createSshServer("testuser", "testpassword")
+        assertNotNull(
+            getConnection(
+                SSH_URI_PREFIX,
+                HOST,
+                PORT,
+                SecurityUtils.getFingerprint(hostKeyPair.public),
+                "testuser",
+                "testpassword",
+                null
+            )
+        )
+        assertNull(
+            getConnection(
+                SSH_URI_PREFIX,
+                HOST,
+                PORT,
+                SecurityUtils.getFingerprint(hostKeyPair.public),
+                "invaliduser",
+                "invalidpassword",
+                null
+            )
+        )
+        verify(mock, times(2))
+            .addHostKeyVerifier(
+                SecurityUtils.getFingerprint(
+                    hostKeyPair.public
+                )
+            )
+        verify(mock, times(2)).connect(HOST, PORT)
+        verify(mock).authPassword("testuser", "testpassword")
+        verify(mock).authPassword("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connections with username and key authentication.
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testGetConnectionWithUsernameAndKey() {
+        val mock = createSshServer("testuser", null)
+        assertNotNull(
+            getConnection(
+                SSH_URI_PREFIX,
+                HOST,
+                PORT,
+                SecurityUtils.getFingerprint(hostKeyPair.public),
+                "testuser",
+                null,
+                userKeyPair
+            )
+        )
+        shutdown()
+        assertNull(
+            getConnection(
+                SSH_URI_PREFIX,
+                HOST,
+                PORT,
+                SecurityUtils.getFingerprint(hostKeyPair.public),
+                "invaliduser",
+                null,
+                userKeyPair
+            )
+        )
+        verify(mock, times(2))
+            .addHostKeyVerifier(
+                SecurityUtils.getFingerprint(
+                    hostKeyPair.public
+                )
+            )
+        verify(mock, times(2)).connect(HOST, PORT)
+        verify(mock).authPublickey("testuser", sshKeyProvider)
+        verify(mock).authPublickey("invaliduser", sshKeyProvider)
+    }
+
+    /**
+     * Test getting connection with an URL/URI.
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testGetConnectionWithUrl() {
+        val validPassword = "testpassword"
+        val mock = createSshServer("testuser", validPassword)
+        TestUtils.saveSshConnectionSettings(
+            hostKeyPair,
+            "testuser",
+            validPassword,
+            null
+        )
+        assertNotNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://testuser:testpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce())
+            .addHostKeyVerifier(
+                SecurityUtils.getFingerprint(
+                    hostKeyPair.public
+                )
+            )
+        verify(mock, atLeastOnce()).connectTimeout =
+            NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).authPassword("testuser", "testpassword")
+        // invalid username won't give host key. Should never called this
+        verify(mock, never()).authPassword("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL(URI) having path to directory. It should return the same
+     * connection without path to directory.
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testGetConnectionWithUrlHavingSubpath() {
+        val validPassword = "testpassword"
+        val mock = createSshServer("testuser", validPassword)
+        TestUtils.saveSshConnectionSettings(
+            hostKeyPair,
+            "testuser",
+            validPassword,
+            null,
+            "/home/testuser"
+        )
+        assertNotNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://testuser:testpassword@127.0.0.1:22222/home/testuser"
+                )
+            )
+        )
+        assertNotNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://testuser:testpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://invaliduser:invalidpassword@127.0.0.1:22222/home/testuser"
+                )
+            )
+        )
+        assertNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, Mockito.atLeastOnce())
+            .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.public))
+        verify(mock, Mockito.atLeastOnce()).connectTimeout =
+            NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, Mockito.atLeastOnce()).connect("127.0.0.1", 22222)
+        verify(mock).authPassword("testuser", "testpassword")
+        // invalid username won't give host key. Should never called this
+        verify(mock, Mockito.never()).authPassword("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI using key authentication.
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testGetConnectionWithUrlAndKeyAuth() {
+        val mock = createSshServer("testuser", null)
+        TestUtils.saveSshConnectionSettings(
+            hostKeyPair,
+            "testuser",
+            null,
+            userKeyPair.private
+        )
+        assertNotNull(getConnection<SSHClient>("ssh://testuser@127.0.0.1:22222"))
+        assertNull(getConnection<SSHClient>("ssh://invaliduser@127.0.0.1:22222"))
+        verify(mock, atLeastOnce())
+            .addHostKeyVerifier(
+                SecurityUtils.getFingerprint(
+                    hostKeyPair.public
+                )
+            )
+        verify(mock, atLeastOnce()).connectTimeout =
+            NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).authPublickey("testuser", sshKeyProvider)
+        // invalid username won't give host key. Should never called this
+        verify(mock, never()).authPublickey("invaliduser", sshKeyProvider)
+    }
+
+    /**
+     * Test getting connection with URL(URI) having path to directory using key authentication.
+     * It should return the same connection without path to directory.
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testGetConnectionWithUrlAndKeyAuthHavingSubpath() {
+        val mock = createSshServer("testuser", null)
+        TestUtils.saveSshConnectionSettings(
+            hostKeyPair,
+            "testuser",
+            null,
+            userKeyPair.private,
+            "/home/testuser"
+        )
+        assertNotNull(getConnection<SSHClient>("ssh://testuser@127.0.0.1:22222/home/testuser"))
+        assertNotNull(getConnection<SSHClient>("ssh://testuser@127.0.0.1:22222"))
+        assertNull(getConnection<SSHClient>("ssh://invaliduser@127.0.0.1:22222/home/testuser"))
+        assertNull(getConnection<SSHClient>("ssh://invaliduser@127.0.0.1:22222"))
+        verify(mock, Mockito.atLeastOnce())
+            .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.public))
+        verify(mock, Mockito.atLeastOnce()).connectTimeout =
+            NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, Mockito.atLeastOnce()).connect("127.0.0.1", 22222)
+        verify(mock).authPublickey("testuser", sshKeyProvider)
+        // invalid username won't give host key. Should never called this
+        verify(mock, Mockito.never())
+            .authPublickey("invaliduser", sshKeyProvider)
+    }
+
+    /**
+     * Test getting connection with URL/URI having complex password (case 1)
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testGetConnectionWithUrlHavingComplexPassword1() {
+        val validPassword = "testP@ssw0rd"
+        val mock = createSshServer("testuser", validPassword)
+        TestUtils.saveSshConnectionSettings(
+            hostKeyPair,
+            "testuser",
+            validPassword,
+            null
+        )
+        assertNotNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://testuser:testP@ssw0rd@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce())
+            .addHostKeyVerifier(
+                SecurityUtils.getFingerprint(
+                    hostKeyPair.public
+                )
+            )
+        verify(mock, atLeastOnce()).connectTimeout =
+            NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).authPassword("testuser", validPassword)
+        // invalid username won't give host key. Should never called this
+        verify(mock, never()).authPassword("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI having complex password (case 2)
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testGetConnectionWithUrlHavingComplexPassword2() {
+        val validPassword = "testP@##word"
+        val mock = createSshServer("testuser", validPassword)
+        TestUtils.saveSshConnectionSettings(
+            hostKeyPair,
+            "testuser",
+            validPassword,
+            null
+        )
+        assertNotNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://testuser:testP@##word@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce())
+            .addHostKeyVerifier(
+                SecurityUtils.getFingerprint(
+                    hostKeyPair.public
+                )
+            )
+        verify(mock, atLeastOnce()).connectTimeout =
+            NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).authPassword("testuser", validPassword)
+        // invalid username won't give host key. Should never called this
+        verify(mock, never()).authPassword("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI having complex credentials (case 1)
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testGetConnectionWithUrlHavingComplexCredential1() {
+        val validPassword = "testP@##word"
+        val mock = createSshServer("testuser", validPassword)
+        TestUtils.saveSshConnectionSettings(
+            hostKeyPair,
+            "testuser",
+            validPassword,
+            null
+        )
+        assertNotNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://testuser:testP@##word@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce())
+            .addHostKeyVerifier(
+                SecurityUtils.getFingerprint(
+                    hostKeyPair.public
+                )
+            )
+        verify(mock, atLeastOnce()).connectTimeout =
+            NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).authPassword("testuser", validPassword)
+        // invalid username won't give host key. Should never called this
+        verify(mock, never()).authPassword("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI having complex credentials (case 2)
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testGetConnectionWithUrlHavingComplexCredential2() {
+        val validPassword = "testP@##word"
+        val mock = createSshServer("testuser", validPassword)
+        TestUtils.saveSshConnectionSettings(
+            hostKeyPair,
+            "testuser",
+            validPassword,
+            null
+        )
+        assertNotNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://testuser:testP@##word@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce())
+            .addHostKeyVerifier(
+                SecurityUtils.getFingerprint(
+                    hostKeyPair.public
+                )
+            )
+        verify(mock, atLeastOnce()).connectTimeout =
+            NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).authPassword("testuser", validPassword)
+        // invalid username won't give host key. Should never called this
+        verify(mock, never()).authPassword("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI having complex credentials (case 3)
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testGetConnectionWithUrlHavingComplexCredential3() {
+        val validUsername = "test@example.com"
+        val validPassword = "testP@ssw0rd"
+        val mock = createSshServer(validUsername, validPassword)
+        TestUtils.saveSshConnectionSettings(
+            hostKeyPair,
+            validUsername,
+            validPassword,
+            null
+        )
+        assertNotNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://test@example.com:testP@ssw0rd@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce())
+            .addHostKeyVerifier(
+                SecurityUtils.getFingerprint(
+                    hostKeyPair.public
+                )
+            )
+        verify(mock, atLeastOnce()).connectTimeout =
+            NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).authPassword(validUsername, validPassword)
+        // invalid username won't give host key. Should never called this
+        verify(mock, never()).authPassword("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI having complex credentials (case 4)
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testGetConnectionWithUrlHavingComplexCredential4() {
+        val validUsername = "test@example.com"
+        val validPassword = "testP@ssw0##$"
+        val mock = createSshServer(validUsername, validPassword)
+        TestUtils.saveSshConnectionSettings(
+            hostKeyPair,
+            validUsername,
+            validPassword,
+            null
+        )
+        assertNotNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://test@example.com:testP@ssw0##$@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce())
+            .addHostKeyVerifier(
+                SecurityUtils.getFingerprint(
+                    hostKeyPair.public
+                )
+            )
+        verify(mock, atLeastOnce()).connectTimeout =
+            NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).authPassword(validUsername, validPassword)
+        // invalid username won't give host key. Should never called this
+        verify(mock, never()).authPassword("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI having minus sign in password (case 1)
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testGetConnectionWithUrlHavingMinusSignInPassword1() {
+        val validUsername = "test@example.com"
+        val validPassword = "abcd-efgh"
+        val mock = createSshServer(validUsername, validPassword)
+        TestUtils.saveSshConnectionSettings(
+            hostKeyPair,
+            validUsername,
+            validPassword,
+            null
+        )
+        assertNotNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://test@example.com:abcd-efgh@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce())
+            .addHostKeyVerifier(
+                SecurityUtils.getFingerprint(
+                    hostKeyPair.public
+                )
+            )
+        verify(mock, atLeastOnce()).connectTimeout =
+            NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).authPassword(validUsername, validPassword)
+        // invalid username won't give host key. Should never called this
+        verify(mock, never()).authPassword("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI having minus sign in password (case 2)
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testGetConnectionWithUrlHavingMinusSignInPassword2() {
+        val validUsername = "test@example.com"
+        val validPassword = "---------------"
+        val mock = createSshServer(validUsername, validPassword)
+        TestUtils.saveSshConnectionSettings(
+            hostKeyPair,
+            validUsername,
+            validPassword,
+            null
+        )
+        assertNotNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://test@example.com:---------------@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce())
+            .addHostKeyVerifier(
+                SecurityUtils.getFingerprint(
+                    hostKeyPair.public
+                )
+            )
+        verify(mock, atLeastOnce()).connectTimeout =
+            NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).authPassword(validUsername, validPassword)
+        // invalid username won't give host key. Should never called this
+        verify(mock, never()).authPassword("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI having minus sign in password (case 3)
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testGetConnectionWithUrlHavingMinusSignInPassword3() {
+        val validUsername = "test@example.com"
+        val validPassword = "--agdiuhdpost15"
+        val mock = createSshServer(validUsername, validPassword)
+        TestUtils.saveSshConnectionSettings(
+            hostKeyPair,
+            validUsername,
+            validPassword,
+            null
+        )
+        assertNotNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://test@example.com:--agdiuhdpost15@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce())
+            .addHostKeyVerifier(
+                SecurityUtils.getFingerprint(
+                    hostKeyPair.public
+                )
+            )
+        verify(mock, atLeastOnce()).connectTimeout =
+            NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).authPassword(validUsername, validPassword)
+        // invalid username won't give host key. Should never called this
+        verify(mock, never()).authPassword("invaliduser", "invalidpassword")
+    }
+
+    /**
+     * Test getting connection with URL/URI having minus sign in password (case 4)
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testGetConnectionWithUrlHavingMinusSignInPassword4() {
+        val validUsername = "test@example.com"
+        val validPassword = "t-h-i-s-i-s-p-a-s-s-w-o-r-d-"
+        val mock = createSshServer(validUsername, validPassword)
+        TestUtils.saveSshConnectionSettings(
+            hostKeyPair,
+            validUsername,
+            validPassword,
+            null
+        )
+        assertNotNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://test@example.com:t-h-i-s-i-s-p-a-s-s-w-o-r-d-@127.0.0.1:22222"
+                )
+            )
+        )
+        assertNull(
+            getConnection<SSHClient>(
+                encryptFtpPathAsNecessary(
+                    "ssh://invaliduser:invalidpassword@127.0.0.1:22222"
+                )
+            )
+        )
+        verify(mock, atLeastOnce())
+            .addHostKeyVerifier(
+                SecurityUtils.getFingerprint(
+                    hostKeyPair.public
+                )
+            )
+        verify(mock, atLeastOnce()).connectTimeout =
+            NetCopyClientConnectionPool.CONNECT_TIMEOUT
+        verify(mock, atLeastOnce()).connect(HOST, PORT)
+        verify(mock).authPassword(validUsername, validPassword)
+        // invalid username won't give host key. Should never called this
+        verify(mock, never()).authPassword("invaliduser", "invalidpassword")
+    }
+
+    @Throws(IOException::class)
+    private fun createSshServer(validUsername: String, validPassword: String?): SSHClient {
+        val mock = Mockito.mock(SSHClient::class.java)
+        doNothing().`when`(mock).connect(HOST, PORT)
+        doNothing()
+            .`when`(mock)
+            .addHostKeyVerifier(
+                SecurityUtils.getFingerprint(
+                    hostKeyPair.public
+                )
+            )
+        doNothing().`when`(mock).disconnect()
+        if (!Utils.isNullOrEmpty(validPassword)) {
+            doNothing().`when`(mock).authPassword(validUsername, validPassword)
+            doThrow(UserAuthException("Invalid login/password"))
+                .`when`(mock)
+                .authPassword(
+                    not(eq(validUsername)),
+                    not(eq(validPassword))
+                )
+        } else {
+            doNothing().`when`(mock).authPublickey(validUsername, sshKeyProvider)
+            doThrow(UserAuthException("Invalid key"))
+                .`when`(mock)
+                .authPublickey(
+                    not(eq(validUsername)),
+                    eq(sshKeyProvider)
+                )
+        }
+        `when`(mock.isConnected).thenReturn(true)
+        `when`(mock.isAuthenticated).thenReturn(true)
+        NetCopyClientConnectionPool.sshClientFactory =
+            object : SSHClientFactory {
+                override fun create(config: net.schmizz.sshj.Config): SSHClient {
+                    return mock
+                }
+            }
+        return mock
+    }
+
+    companion object {
+
+        const val HOST = "127.0.0.1"
+        const val PORT = 22222
+
+        lateinit var hostKeyPair: KeyPair
+        lateinit var userKeyPair: KeyPair
+        lateinit var sshKeyProvider: KeyProvider
+
+        /**
+         * Bootstrap the unit test
+         */
+        @BeforeClass
+        @JvmStatic
+        fun bootstrap() {
+            hostKeyPair = TestUtils.createKeyPair()
+            userKeyPair = TestUtils.createKeyPair()
+            sshKeyProvider = object : KeyProvider {
+
+                override fun getPrivate() = userKeyPair.private
+
+                override fun getPublic() = userKeyPair.public
+
+                override fun getType() = KeyType.RSA
+
+                override fun equals(other: Any?): Boolean {
+                    return if (other !is KeyProvider) {
+                        false
+                    } else {
+                        other.private == private && other.public == public
+                    }
+                }
+            }
+            RxJavaPlugins.reset()
+            RxJavaPlugins.setIoSchedulerHandler {
+                Schedulers.trampoline()
+            }
+            RxAndroidPlugins.reset()
+            RxAndroidPlugins.setInitMainThreadSchedulerHandler {
+                Schedulers.trampoline()
+            }
+        }
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshClientUtilsTest.java b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshClientUtilsTest.java
deleted file mode 100644
index 75402a570..000000000
--- a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshClientUtilsTest.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
- * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
- *
- * This file is part of Amaze File Manager.
- *
- * Amaze File Manager is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.amaze.filemanager.filesystem.ssh;
-
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertFalse;
-import static org.junit.Assert.assertThrows;
-import static org.junit.Assert.assertTrue;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.when;
-
-import java.io.IOException;
-
-import org.junit.Test;
-
-import net.schmizz.sshj.sftp.FileAttributes;
-import net.schmizz.sshj.sftp.FileMode;
-import net.schmizz.sshj.sftp.RemoteResourceInfo;
-import net.schmizz.sshj.sftp.SFTPClient;
-
-public class SshClientUtilsTest {
-
-  @Test
-  public void testDeriveSftpPathFrom() {
-    assertEquals(
-        "ssh://root:toor@127.0.0.1:22/",
-        SshClientUtils.deriveSftpPathFrom("127.0.0.1", 22, null, "root", "toor", null));
-    assertEquals(
-        "ssh://root:toor@127.0.0.1:22",
-        SshClientUtils.deriveSftpPathFrom("127.0.0.1", 22, "", "root", "toor", null));
-  }
-
-  @Test
-  public void testIsDirectoryNormal() throws IOException {
-    RemoteResourceInfo mock = mock(RemoteResourceInfo.class);
-    when(mock.isDirectory()).thenReturn(true);
-    FileAttributes mockAttributes =
-        new FileAttributes.Builder().withType(FileMode.Type.DIRECTORY).build();
-    when(mock.getAttributes()).thenReturn(mockAttributes);
-    SFTPClient mockClient = mock(SFTPClient.class);
-    assertTrue(SshClientUtils.isDirectory(mockClient, mock));
-  }
-
-  @Test
-  public void testIsDirectoryWithFile() throws IOException {
-    RemoteResourceInfo mock = mock(RemoteResourceInfo.class);
-    when(mock.isDirectory()).thenReturn(false);
-    FileAttributes mockAttributes =
-        new FileAttributes.Builder().withType(FileMode.Type.REGULAR).build();
-    when(mock.getAttributes()).thenReturn(mockAttributes);
-    SFTPClient mockClient = mock(SFTPClient.class);
-    assertFalse(SshClientUtils.isDirectory(mockClient, mock));
-  }
-
-  @Test
-  public void testIsDirectorySymlinkNormal() throws IOException {
-    RemoteResourceInfo mock = mock(RemoteResourceInfo.class);
-    when(mock.getPath()).thenReturn("/sysroot/etc");
-    when(mock.isDirectory()).thenReturn(true);
-    FileAttributes mockAttributes =
-        new FileAttributes.Builder().withType(FileMode.Type.SYMLINK).build();
-    when(mock.getAttributes()).thenReturn(mockAttributes);
-
-    SFTPClient mockClient = mock(SFTPClient.class);
-    mockAttributes = new FileAttributes.Builder().withType(FileMode.Type.DIRECTORY).build();
-    when(mockClient.stat("/sysroot/etc")).thenReturn(mockAttributes);
-
-    assertTrue(SshClientUtils.isDirectory(mockClient, mock));
-  }
-
-  @Test
-  public void testIsDirectorySymlinkBrokenDirectory() throws IOException {
-    RemoteResourceInfo mock = mock(RemoteResourceInfo.class);
-    when(mock.getPath()).thenReturn("/sysroot/etc");
-    when(mock.isDirectory()).thenReturn(true);
-    FileAttributes mockAttributes =
-        new FileAttributes.Builder().withType(FileMode.Type.SYMLINK).build();
-    when(mock.getAttributes()).thenReturn(mockAttributes);
-
-    SFTPClient mockClient = mock(SFTPClient.class);
-    mockAttributes = new FileAttributes.Builder().withType(FileMode.Type.DIRECTORY).build();
-    when(mockClient.stat("/sysroot/etc")).thenThrow(new IOException());
-
-    assertThrows(IOException.class, () -> SshClientUtils.isDirectory(mockClient, mock));
-  }
-
-  @Test
-  public void testIsDirectorySymlinkBrokenFile() throws IOException {
-    RemoteResourceInfo mock = mock(RemoteResourceInfo.class);
-    when(mock.getPath()).thenReturn("/sysroot/etc");
-    when(mock.isDirectory()).thenReturn(false);
-    FileAttributes mockAttributes =
-        new FileAttributes.Builder().withType(FileMode.Type.SYMLINK).build();
-    when(mock.getAttributes()).thenReturn(mockAttributes);
-
-    SFTPClient mockClient = mock(SFTPClient.class);
-    mockAttributes = new FileAttributes.Builder().withType(FileMode.Type.DIRECTORY).build();
-    when(mockClient.stat("/sysroot/etc")).thenThrow(new IOException());
-
-    assertThrows(IOException.class, () -> SshClientUtils.isDirectory(mockClient, mock));
-  }
-}
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshClientUtilsTest.kt b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshClientUtilsTest.kt
new file mode 100644
index 000000000..3f12326c5
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshClientUtilsTest.kt
@@ -0,0 +1,166 @@
+/*
+ * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.filesystem.ssh
+
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.SSH_URI_PREFIX
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientUtils.deriveUriFrom
+import net.schmizz.sshj.sftp.FileAttributes
+import net.schmizz.sshj.sftp.FileMode
+import net.schmizz.sshj.sftp.RemoteResourceInfo
+import net.schmizz.sshj.sftp.SFTPClient
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertFalse
+import org.junit.Assert.assertThrows
+import org.junit.Assert.assertTrue
+import org.junit.Test
+import org.mockito.Mockito
+import org.mockito.Mockito.`when`
+import java.io.IOException
+
+/**
+ * Unit tests for [SshClientUtils].
+ */
+class SshClientUtilsTest {
+
+    companion object {
+        private const val SYSROOT_ETC = "/sysroot/etc"
+    }
+
+    /**
+     * Test [NetCopyClientUtils.deriveUriFrom].
+     */
+    @Test
+    fun testDeriveSftpPathFrom() {
+        assertEquals(
+            "ssh://root:toor@127.0.0.1:22/",
+            deriveUriFrom(
+                SSH_URI_PREFIX,
+                "127.0.0.1",
+                22,
+                null,
+                "root",
+                "toor",
+                null
+            )
+        )
+        assertEquals(
+            "ssh://root:toor@127.0.0.1:22",
+            deriveUriFrom(
+                SSH_URI_PREFIX,
+                "127.0.0.1",
+                22,
+                "",
+                "root",
+                "toor",
+                null
+            )
+        )
+    }
+
+    /**
+     * Tests [SshClientUtils.isDirectory] for normal cases.
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testIsDirectoryNormal() {
+        val mock = Mockito.mock(RemoteResourceInfo::class.java)
+        `when`(mock.isDirectory).thenReturn(true)
+        val mockAttributes = FileAttributes.Builder().withType(FileMode.Type.DIRECTORY).build()
+        `when`(mock.attributes).thenReturn(mockAttributes)
+        val mockClient = Mockito.mock(SFTPClient::class.java)
+        assertTrue(SshClientUtils.isDirectory(mockClient, mock))
+    }
+
+    /**
+     * Tests [SshClientUtils.isDirectory] with a file.
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testIsDirectoryWithFile() {
+        val mock = Mockito.mock(RemoteResourceInfo::class.java)
+        `when`(mock.isDirectory).thenReturn(false)
+        val mockAttributes = FileAttributes.Builder().withType(FileMode.Type.REGULAR).build()
+        `when`(mock.attributes).thenReturn(mockAttributes)
+        val mockClient = Mockito.mock(SFTPClient::class.java)
+        assertFalse(SshClientUtils.isDirectory(mockClient, mock))
+    }
+
+    /**
+     * Tests [SshClientUtils.isDirectory] for symlinks to directory.
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testIsDirectorySymlinkNormal() {
+        val mock = Mockito.mock(RemoteResourceInfo::class.java)
+        `when`(mock.path).thenReturn(SYSROOT_ETC)
+        `when`(mock.isDirectory).thenReturn(true)
+        var mockAttributes = FileAttributes.Builder().withType(FileMode.Type.SYMLINK).build()
+        `when`(mock.attributes).thenReturn(mockAttributes)
+        val mockClient = Mockito.mock(SFTPClient::class.java)
+        mockAttributes = FileAttributes.Builder().withType(FileMode.Type.DIRECTORY).build()
+        `when`(mockClient.stat(SYSROOT_ETC)).thenReturn(mockAttributes)
+        assertTrue(SshClientUtils.isDirectory(mockClient, mock))
+    }
+
+    /**
+     * Tests [SshClientUtils.isDirectory] for broken symlinks.
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testIsDirectorySymlinkBrokenDirectory() {
+        val mock = Mockito.mock(RemoteResourceInfo::class.java)
+        `when`(mock.path).thenReturn(SYSROOT_ETC)
+        `when`(mock.isDirectory).thenReturn(true)
+        var mockAttributes = FileAttributes.Builder().withType(FileMode.Type.SYMLINK).build()
+        `when`(mock.attributes).thenReturn(mockAttributes)
+        val mockClient = Mockito.mock(SFTPClient::class.java)
+        mockAttributes = FileAttributes.Builder().withType(FileMode.Type.DIRECTORY).build()
+        `when`(mockClient.stat(SYSROOT_ETC)).thenThrow(IOException())
+        assertThrows(IOException::class.java) {
+            SshClientUtils.isDirectory(
+                mockClient,
+                mock
+            )
+        }
+    }
+
+    /**
+     * Tests [SshClientUtils.isDirectory] for broken symlibks to file.
+     */
+    @Test
+    @Throws(IOException::class)
+    fun testIsDirectorySymlinkBrokenFile() {
+        val mock = Mockito.mock(RemoteResourceInfo::class.java)
+        `when`(mock.path).thenReturn(SYSROOT_ETC)
+        `when`(mock.isDirectory).thenReturn(false)
+        var mockAttributes = FileAttributes.Builder().withType(FileMode.Type.SYMLINK).build()
+        `when`(mock.attributes).thenReturn(mockAttributes)
+        val mockClient = Mockito.mock(SFTPClient::class.java)
+        mockAttributes = FileAttributes.Builder().withType(FileMode.Type.DIRECTORY).build()
+        `when`(mockClient.stat(SYSROOT_ETC)).thenThrow(IOException())
+        assertThrows(IOException::class.java) {
+            SshClientUtils.isDirectory(
+                mockClient,
+                mock
+            )
+        }
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPoolTest.java b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPoolTest.java
deleted file mode 100644
index 487b5173b..000000000
--- a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/SshConnectionPoolTest.java
+++ /dev/null
@@ -1,550 +0,0 @@
-/*
- * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
- * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
- *
- * This file is part of Amaze File Manager.
- *
- * Amaze File Manager is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.amaze.filemanager.filesystem.ssh;
-
-import static android.os.Build.VERSION_CODES.JELLY_BEAN;
-import static android.os.Build.VERSION_CODES.KITKAT;
-import static android.os.Build.VERSION_CODES.P;
-import static com.amaze.filemanager.filesystem.ssh.test.TestUtils.saveSshConnectionSettings;
-import static org.junit.Assert.assertNotNull;
-import static org.junit.Assert.assertNull;
-import static org.mockito.AdditionalMatchers.not;
-import static org.mockito.Matchers.eq;
-import static org.mockito.Mockito.atLeastOnce;
-import static org.mockito.Mockito.doNothing;
-import static org.mockito.Mockito.doThrow;
-import static org.mockito.Mockito.mock;
-import static org.mockito.Mockito.never;
-import static org.mockito.Mockito.times;
-import static org.mockito.Mockito.verify;
-import static org.mockito.Mockito.when;
-
-import java.io.IOException;
-import java.security.KeyPair;
-import java.security.PrivateKey;
-import java.security.PublicKey;
-
-import org.junit.After;
-import org.junit.BeforeClass;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
-import org.robolectric.shadows.ShadowSQLiteConnection;
-
-import com.amaze.filemanager.filesystem.ssh.test.TestUtils;
-import com.amaze.filemanager.shadows.ShadowMultiDex;
-import com.amaze.filemanager.test.ShadowPasswordUtil;
-import com.amaze.filemanager.utils.Utils;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-
-import io.reactivex.android.plugins.RxAndroidPlugins;
-import io.reactivex.plugins.RxJavaPlugins;
-import io.reactivex.schedulers.Schedulers;
-import net.schmizz.sshj.SSHClient;
-import net.schmizz.sshj.common.KeyType;
-import net.schmizz.sshj.common.SecurityUtils;
-import net.schmizz.sshj.userauth.UserAuthException;
-import net.schmizz.sshj.userauth.keyprovider.KeyProvider;
-
-@RunWith(AndroidJUnit4.class)
-@Config(
-    shadows = {ShadowMultiDex.class, ShadowPasswordUtil.class},
-    sdk = {JELLY_BEAN, KITKAT, P})
-public class SshConnectionPoolTest {
-
-  private static KeyPair hostKeyPair;
-
-  private static KeyPair userKeyPair;
-
-  private static KeyProvider sshKeyProvider;
-
-  @BeforeClass
-  public static void bootstrap() throws Exception {
-    hostKeyPair = TestUtils.createKeyPair();
-    userKeyPair = TestUtils.createKeyPair();
-    sshKeyProvider =
-        new KeyProvider() {
-          @Override
-          public PrivateKey getPrivate() throws IOException {
-            return userKeyPair.getPrivate();
-          }
-
-          @Override
-          public PublicKey getPublic() throws IOException {
-            return userKeyPair.getPublic();
-          }
-
-          @Override
-          public KeyType getType() throws IOException {
-            return KeyType.RSA;
-          }
-
-          @Override
-          public boolean equals(@Nullable Object obj) {
-            if (obj == null || !(obj instanceof KeyProvider)) return false;
-            else {
-              KeyProvider other = (KeyProvider) obj;
-              try {
-                return other.getPrivate().equals(getPrivate())
-                    && other.getPublic().equals(getPublic());
-              } catch (IOException shallNeverHappenHere) {
-                return false;
-              }
-            }
-          }
-        };
-    RxJavaPlugins.reset();
-    RxJavaPlugins.setIoSchedulerHandler(scheduler -> Schedulers.trampoline());
-    RxAndroidPlugins.reset();
-    RxAndroidPlugins.setInitMainThreadSchedulerHandler(scheduler -> Schedulers.trampoline());
-  }
-
-  @After
-  public void tearDown() {
-    SshConnectionPool.INSTANCE.shutdown();
-    ShadowSQLiteConnection.reset();
-  }
-
-  @Test
-  public void testGetConnectionWithUsernameAndPassword() throws IOException {
-    SSHClient mock = createSshServer("testuser", "testpassword");
-    assertNotNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            "127.0.0.1",
-            22222,
-            SecurityUtils.getFingerprint(hostKeyPair.getPublic()),
-            "testuser",
-            "testpassword",
-            null));
-    assertNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            "127.0.0.1",
-            22222,
-            SecurityUtils.getFingerprint(hostKeyPair.getPublic()),
-            "invaliduser",
-            "invalidpassword",
-            null));
-
-    verify(mock, times(2))
-        .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
-    verify(mock, times(2)).connect("127.0.0.1", 22222);
-    verify(mock).authPassword("testuser", "testpassword");
-    verify(mock).authPassword("invaliduser", "invalidpassword");
-  }
-
-  @Test
-  public void testGetConnectionWithUsernameAndKey() throws IOException {
-    SSHClient mock = createSshServer("testuser", null);
-    assertNotNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            "127.0.0.1",
-            22222,
-            SecurityUtils.getFingerprint(hostKeyPair.getPublic()),
-            "testuser",
-            null,
-            userKeyPair));
-    SshConnectionPool.INSTANCE.shutdown();
-    assertNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            "127.0.0.1",
-            22222,
-            SecurityUtils.getFingerprint(hostKeyPair.getPublic()),
-            "invaliduser",
-            null,
-            userKeyPair));
-
-    verify(mock, times(2))
-        .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
-    verify(mock, times(2)).connect("127.0.0.1", 22222);
-    verify(mock).authPublickey("testuser", sshKeyProvider);
-    verify(mock).authPublickey("invaliduser", sshKeyProvider);
-  }
-
-  @Test
-  public void testGetConnectionWithUrl() throws IOException {
-    String validPassword = "testpassword";
-    SSHClient mock = createSshServer("testuser", validPassword);
-    saveSshConnectionSettings(hostKeyPair, "testuser", validPassword, null, null);
-    assertNotNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://testuser:testpassword@127.0.0.1:22222")));
-    assertNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://invaliduser:invalidpassword@127.0.0.1:22222")));
-
-    verify(mock, atLeastOnce())
-        .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
-    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
-    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
-    verify(mock).authPassword("testuser", "testpassword");
-    // invalid username won't give host key. Should never called this
-    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
-  }
-
-  @Test
-  public void testGetConnectionWithUrlHavingSubpath() throws IOException {
-    String validPassword = "testpassword";
-    SSHClient mock = createSshServer("testuser", validPassword);
-    saveSshConnectionSettings(hostKeyPair, "testuser", validPassword, null, "/home/testuser");
-    assertNotNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://testuser:testpassword@127.0.0.1:22222/home/testuser")));
-    assertNotNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://testuser:testpassword@127.0.0.1:22222")));
-    assertNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://invaliduser:invalidpassword@127.0.0.1:22222/home/testuser")));
-    assertNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://invaliduser:invalidpassword@127.0.0.1:22222")));
-
-    verify(mock, atLeastOnce())
-        .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
-    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
-    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
-    verify(mock).authPassword("testuser", "testpassword");
-    // invalid username won't give host key. Should never called this
-    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
-  }
-
-  @Test
-  public void testGetConnectionWithUrlAndKeyAuth() throws IOException {
-    SSHClient mock = createSshServer("testuser", null);
-    saveSshConnectionSettings(hostKeyPair, "testuser", null, userKeyPair.getPrivate(), null);
-    assertNotNull(SshConnectionPool.INSTANCE.getConnection("ssh://testuser@127.0.0.1:22222"));
-    assertNull(SshConnectionPool.INSTANCE.getConnection("ssh://invaliduser@127.0.0.1:22222"));
-
-    verify(mock, atLeastOnce())
-        .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
-    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
-    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
-
-    verify(mock).authPublickey("testuser", sshKeyProvider);
-    // invalid username won't give host key. Should never called this
-    verify(mock, never()).authPublickey("invaliduser", sshKeyProvider);
-  }
-
-  @Test
-  public void testGetConnectionWithUrlAndKeyAuthHavingSubpath() throws IOException {
-    SSHClient mock = createSshServer("testuser", null);
-    saveSshConnectionSettings(
-        hostKeyPair, "testuser", null, userKeyPair.getPrivate(), "/home/testuser");
-    assertNotNull(
-        SshConnectionPool.INSTANCE.getConnection("ssh://testuser@127.0.0.1:22222/home/testuser"));
-    assertNotNull(SshConnectionPool.INSTANCE.getConnection("ssh://testuser@127.0.0.1:22222"));
-    assertNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            "ssh://invaliduser@127.0.0.1:22222/home/testuser"));
-    assertNull(SshConnectionPool.INSTANCE.getConnection("ssh://invaliduser@127.0.0.1:22222"));
-
-    verify(mock, atLeastOnce())
-        .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
-    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
-    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
-
-    verify(mock).authPublickey("testuser", sshKeyProvider);
-    // invalid username won't give host key. Should never called this
-    verify(mock, never()).authPublickey("invaliduser", sshKeyProvider);
-  }
-
-  @Test
-  public void testGetConnectionWithUrlHavingComplexPassword1() throws IOException {
-    String validPassword = "testP@ssw0rd";
-    SSHClient mock = createSshServer("testuser", validPassword);
-    saveSshConnectionSettings(hostKeyPair, "testuser", validPassword, null, null);
-    assertNotNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://testuser:testP@ssw0rd@127.0.0.1:22222")));
-    assertNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://invaliduser:invalidpassword@127.0.0.1:22222")));
-
-    verify(mock, atLeastOnce())
-        .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
-    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
-    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
-
-    verify(mock).authPassword("testuser", validPassword);
-    // invalid username won't give host key. Should never called this
-    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
-  }
-
-  @Test
-  public void testGetConnectionWithUrlHavingComplexPassword2() throws IOException {
-    String validPassword = "testP@##word";
-    SSHClient mock = createSshServer("testuser", validPassword);
-    saveSshConnectionSettings(hostKeyPair, "testuser", validPassword, null, null);
-    assertNotNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://testuser:testP@##word@127.0.0.1:22222")));
-    assertNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://invaliduser:invalidpassword@127.0.0.1:22222")));
-
-    verify(mock, atLeastOnce())
-        .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
-    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
-    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
-
-    verify(mock).authPassword("testuser", validPassword);
-    // invalid username won't give host key. Should never called this
-    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
-  }
-
-  @Test
-  public void testGetConnectionWithUrlHavingComplexCredential1() throws IOException {
-    String validPassword = "testP@##word";
-    SSHClient mock = createSshServer("testuser", validPassword);
-    saveSshConnectionSettings(hostKeyPair, "testuser", validPassword, null, null);
-    assertNotNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://testuser:testP@##word@127.0.0.1:22222")));
-    assertNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://invaliduser:invalidpassword@127.0.0.1:22222")));
-
-    verify(mock, atLeastOnce())
-        .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
-    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
-    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
-
-    verify(mock).authPassword("testuser", validPassword);
-    // invalid username won't give host key. Should never called this
-    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
-  }
-
-  @Test
-  public void testGetConnectionWithUrlHavingComplexCredential2() throws IOException {
-    String validPassword = "testP@##word";
-    SSHClient mock = createSshServer("testuser", validPassword);
-    saveSshConnectionSettings(hostKeyPair, "testuser", validPassword, null, null);
-    assertNotNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://testuser:testP@##word@127.0.0.1:22222")));
-    assertNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://invaliduser:invalidpassword@127.0.0.1:22222")));
-
-    verify(mock, atLeastOnce())
-        .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
-    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
-    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
-
-    verify(mock).authPassword("testuser", validPassword);
-    // invalid username won't give host key. Should never called this
-    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
-  }
-
-  @Test
-  public void testGetConnectionWithUrlHavingComplexCredential3() throws IOException {
-    String validUsername = "test@example.com";
-    String validPassword = "testP@ssw0rd";
-    SSHClient mock = createSshServer(validUsername, validPassword);
-    saveSshConnectionSettings(hostKeyPair, validUsername, validPassword, null, null);
-    assertNotNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://test@example.com:testP@ssw0rd@127.0.0.1:22222")));
-    assertNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://invaliduser:invalidpassword@127.0.0.1:22222")));
-
-    verify(mock, atLeastOnce())
-        .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
-    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
-    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
-
-    verify(mock).authPassword(validUsername, validPassword);
-    // invalid username won't give host key. Should never called this
-    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
-  }
-
-  @Test
-  public void testGetConnectionWithUrlHavingComplexCredential4() throws IOException {
-    String validUsername = "test@example.com";
-    String validPassword = "testP@ssw0##$";
-    SSHClient mock = createSshServer(validUsername, validPassword);
-    saveSshConnectionSettings(hostKeyPair, validUsername, validPassword, null, null);
-    assertNotNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://test@example.com:testP@ssw0##$@127.0.0.1:22222")));
-    assertNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://invaliduser:invalidpassword@127.0.0.1:22222")));
-
-    verify(mock, atLeastOnce())
-        .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
-    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
-    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
-
-    verify(mock).authPassword(validUsername, validPassword);
-    // invalid username won't give host key. Should never called this
-    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
-  }
-
-  @Test
-  public void testGetConnectionWithUrlHavingMinusSignInPassword1() throws IOException {
-    String validUsername = "test@example.com";
-    String validPassword = "abcd-efgh";
-    SSHClient mock = createSshServer(validUsername, validPassword);
-    saveSshConnectionSettings(hostKeyPair, validUsername, validPassword, null, null);
-    assertNotNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://test@example.com:abcd-efgh@127.0.0.1:22222")));
-    assertNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://invaliduser:invalidpassword@127.0.0.1:22222")));
-
-    verify(mock, atLeastOnce())
-        .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
-    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
-    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
-
-    verify(mock).authPassword(validUsername, validPassword);
-    // invalid username won't give host key. Should never called this
-    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
-  }
-
-  @Test
-  public void testGetConnectionWithUrlHavingMinusSignInPassword2() throws IOException {
-    String validUsername = "test@example.com";
-    String validPassword = "---------------";
-    SSHClient mock = createSshServer(validUsername, validPassword);
-    saveSshConnectionSettings(hostKeyPair, validUsername, validPassword, null, null);
-    assertNotNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://test@example.com:---------------@127.0.0.1:22222")));
-    assertNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://invaliduser:invalidpassword@127.0.0.1:22222")));
-
-    verify(mock, atLeastOnce())
-        .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
-    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
-    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
-
-    verify(mock).authPassword(validUsername, validPassword);
-    // invalid username won't give host key. Should never called this
-    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
-  }
-
-  @Test
-  public void testGetConnectionWithUrlHavingMinusSignInPassword3() throws IOException {
-    String validUsername = "test@example.com";
-    String validPassword = "--agdiuhdpost15";
-    SSHClient mock = createSshServer(validUsername, validPassword);
-    saveSshConnectionSettings(hostKeyPair, validUsername, validPassword, null, null);
-    assertNotNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://test@example.com:--agdiuhdpost15@127.0.0.1:22222")));
-    assertNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://invaliduser:invalidpassword@127.0.0.1:22222")));
-
-    verify(mock, atLeastOnce())
-        .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
-    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
-    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
-
-    verify(mock).authPassword(validUsername, validPassword);
-    // invalid username won't give host key. Should never called this
-    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
-  }
-
-  @Test
-  public void testGetConnectionWithUrlHavingMinusSignInPassword4() throws IOException {
-    String validUsername = "test@example.com";
-    String validPassword = "t-h-i-s-i-s-p-a-s-s-w-o-r-d-";
-    SSHClient mock = createSshServer(validUsername, validPassword);
-    saveSshConnectionSettings(hostKeyPair, validUsername, validPassword, null, null);
-    assertNotNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://test@example.com:t-h-i-s-i-s-p-a-s-s-w-o-r-d-@127.0.0.1:22222")));
-    assertNull(
-        SshConnectionPool.INSTANCE.getConnection(
-            SshClientUtils.encryptSshPathAsNecessary(
-                "ssh://invaliduser:invalidpassword@127.0.0.1:22222")));
-
-    verify(mock, atLeastOnce())
-        .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
-    verify(mock, atLeastOnce()).setConnectTimeout(SshConnectionPool.SSH_CONNECT_TIMEOUT);
-    verify(mock, atLeastOnce()).connect("127.0.0.1", 22222);
-
-    verify(mock).authPassword(validUsername, validPassword);
-    // invalid username won't give host key. Should never called this
-    verify(mock, never()).authPassword("invaliduser", "invalidpassword");
-  }
-
-  private SSHClient createSshServer(@NonNull String validUsername, @Nullable String validPassword)
-      throws IOException {
-
-    SSHClient mock = mock(SSHClient.class);
-    when(mock.isConnected()).thenReturn(true);
-    when(mock.isAuthenticated()).thenReturn(true);
-    doNothing().when(mock).connect("127.0.0.1", 22222);
-    doNothing()
-        .when(mock)
-        .addHostKeyVerifier(SecurityUtils.getFingerprint(hostKeyPair.getPublic()));
-    doNothing().when(mock).disconnect();
-    if (!Utils.isNullOrEmpty(validPassword)) {
-      doNothing().when(mock).authPassword(validUsername, validPassword);
-      doThrow(new UserAuthException("Invalid login/password"))
-          .when(mock)
-          .authPassword(not(eq(validUsername)), not(eq(validPassword)));
-    } else {
-      doNothing().when(mock).authPublickey(validUsername, sshKeyProvider);
-      doThrow(new UserAuthException("Invalid key"))
-          .when(mock)
-          .authPublickey(not(eq(validUsername)), eq(sshKeyProvider));
-    }
-    // reset(mock);
-    SshConnectionPool.sshClientFactory = config -> mock;
-    return mock;
-  }
-}
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/test/MockSshConnectionPools.kt b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/test/MockSshConnectionPools.kt
index 82d0c07bc..cea22372a 100644
--- a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/test/MockSshConnectionPools.kt
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/test/MockSshConnectionPools.kt
@@ -20,14 +20,21 @@
 
 package com.amaze.filemanager.filesystem.ssh.test
 
-import com.amaze.filemanager.filesystem.ssh.SshConnectionPool
+import com.amaze.filemanager.filesystem.ftp.NetCopyClient
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool
+import com.amaze.filemanager.filesystem.ftp.SSHClientImpl
 import net.schmizz.sshj.Config
 import net.schmizz.sshj.SSHClient
 import net.schmizz.sshj.sftp.FileAttributes
 import net.schmizz.sshj.sftp.FileMode
 import net.schmizz.sshj.sftp.SFTPClient
 import net.schmizz.sshj.sftp.SFTPException
-import org.mockito.Mockito.*
+import org.mockito.Mockito.anyInt
+import org.mockito.Mockito.anyString
+import org.mockito.Mockito.doNothing
+import org.mockito.Mockito.doThrow
+import org.mockito.Mockito.mock
+import org.mockito.Mockito.`when`
 
 object MockSshConnectionPools {
 
@@ -91,18 +98,22 @@ object MockSshConnectionPools {
          * was not working in the case of Operations.rename() due to the threading model
          * Robolectric imposed. So we are injecting the SSHClient here by force.
          */
-        SshConnectionPool::class.java.getDeclaredField("connections").run {
+        NetCopyClientConnectionPool::class.java.getDeclaredField("connections").run {
             this.isAccessible = true
             this.set(
-                SshConnectionPool,
+                NetCopyClientConnectionPool,
                 mutableMapOf(
-                    Pair<String, SSHClient>("ssh://user:password@127.0.0.1:22222", sshClient)
+                    Pair<String, NetCopyClient<SSHClient>>(
+                        "ssh://user:password@127.0.0.1:22222",
+                        SSHClientImpl(sshClient)
+                    )
                 )
             )
         }
 
-        SshConnectionPool.sshClientFactory = object : SshConnectionPool.SSHClientFactory {
-            override fun create(config: Config?): SSHClient = sshClient
+        NetCopyClientConnectionPool.sshClientFactory = object :
+            NetCopyClientConnectionPool.SSHClientFactory {
+            override fun create(config: Config): SSHClient = sshClient
         }
     }
 }
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/test/TestUtils.java b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/test/TestUtils.java
deleted file mode 100644
index 6d02655c9..000000000
--- a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/test/TestUtils.java
+++ /dev/null
@@ -1,115 +0,0 @@
-/*
- * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
- * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
- *
- * This file is part of Amaze File Manager.
- *
- * Amaze File Manager is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.amaze.filemanager.filesystem.ssh.test;
-
-import static com.amaze.filemanager.filesystem.ssh.SshConnectionPool.SSH_URI_PREFIX;
-import static org.robolectric.Shadows.shadowOf;
-
-import java.io.IOException;
-import java.io.StringWriter;
-import java.security.KeyPair;
-import java.security.KeyPairGenerator;
-import java.security.NoSuchAlgorithmException;
-import java.security.PrivateKey;
-import java.security.SecureRandom;
-
-import org.bouncycastle.openssl.jcajce.JcaPEMWriter;
-
-import com.amaze.filemanager.application.AppConfig;
-import com.amaze.filemanager.database.UtilsHandler;
-import com.amaze.filemanager.database.models.OperationData;
-import com.amaze.filemanager.filesystem.ssh.SshClientUtils;
-
-import android.os.Looper;
-import android.text.TextUtils;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-
-import net.schmizz.sshj.common.SecurityUtils;
-
-public abstract class TestUtils {
-
-  public static KeyPair createKeyPair() {
-    try {
-      KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance("RSA");
-      keyPairGenerator.initialize(1024, new SecureRandom());
-      return keyPairGenerator.generateKeyPair();
-    } catch (NoSuchAlgorithmException e) {
-      e.printStackTrace();
-      return null;
-    }
-  }
-
-  public static void saveSshConnectionSettings(
-      @NonNull KeyPair hostKeyPair,
-      @NonNull String validUsername,
-      @Nullable String validPassword,
-      @Nullable PrivateKey privateKey,
-      @Nullable String subpath) {
-
-    UtilsHandler utilsHandler = AppConfig.getInstance().getUtilsHandler();
-
-    String privateKeyContents = null;
-    if (privateKey != null) {
-      StringWriter writer = new StringWriter();
-      JcaPEMWriter jw = new JcaPEMWriter(writer);
-      try {
-        jw.writeObject(privateKey);
-        jw.flush();
-        jw.close();
-      } catch (IOException shallNeverHappen) {
-      }
-      privateKeyContents = writer.toString();
-    }
-
-    StringBuilder fullUri = new StringBuilder().append(SSH_URI_PREFIX).append(validUsername);
-
-    if (validPassword != null) fullUri.append(':').append(validPassword);
-
-    fullUri.append("@127.0.0.1:22222");
-
-    if (!TextUtils.isEmpty(subpath)) {
-      fullUri.append(subpath);
-    }
-
-    if (validPassword != null)
-      utilsHandler.saveToDatabase(
-          new OperationData(
-              UtilsHandler.Operation.SFTP,
-              SshClientUtils.encryptSshPathAsNecessary(fullUri.toString()),
-              "Test",
-              SecurityUtils.getFingerprint(hostKeyPair.getPublic()),
-              null,
-              null));
-    else
-      utilsHandler.saveToDatabase(
-          new OperationData(
-              UtilsHandler.Operation.SFTP,
-              SshClientUtils.encryptSshPathAsNecessary(fullUri.toString()),
-              "Test",
-              SecurityUtils.getFingerprint(hostKeyPair.getPublic()),
-              "id_rsa",
-              privateKeyContents));
-
-    shadowOf(Looper.getMainLooper()).idle();
-  }
-}
diff --git a/app/src/test/java/com/amaze/filemanager/filesystem/ssh/test/TestUtils.kt b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/test/TestUtils.kt
new file mode 100644
index 000000000..8386ba6e5
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/filesystem/ssh/test/TestUtils.kt
@@ -0,0 +1,144 @@
+/*
+ * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.filesystem.ssh.test
+
+import android.os.Looper
+import com.amaze.filemanager.application.AppConfig
+import com.amaze.filemanager.database.UtilsHandler
+import com.amaze.filemanager.database.models.OperationData
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.FTPS_URI_PREFIX
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.FTP_URI_PREFIX
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPool.SSH_URI_PREFIX
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientConnectionPoolFtpTest
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientUtils.encryptFtpPathAsNecessary
+import com.amaze.filemanager.filesystem.ssh.NetCopyClientConnectionPoolSshTest
+import net.schmizz.sshj.common.SecurityUtils
+import org.bouncycastle.openssl.jcajce.JcaPEMWriter
+import org.json.JSONObject
+import org.robolectric.Shadows
+import java.io.StringWriter
+import java.security.KeyPair
+import java.security.KeyPairGenerator
+import java.security.PrivateKey
+import java.security.SecureRandom
+
+/**
+ * Test support util methods.
+ */
+object TestUtils {
+
+    /**
+     * Generate a [KeyPair] for testing.
+     */
+    fun createKeyPair(): KeyPair {
+        val keyPairGenerator = KeyPairGenerator.getInstance("RSA")
+        keyPairGenerator.initialize(1024, SecureRandom())
+        return keyPairGenerator.generateKeyPair()
+    }
+
+    /**
+     * Save FTP connection settings to database.
+     */
+    fun saveFtpConnectionSettings(
+        validUsername: String,
+        validPassword: String,
+        certInfo: JSONObject? = null,
+        port: Int = NetCopyClientConnectionPoolFtpTest.PORT
+    ) {
+        val utilsHandler = AppConfig.getInstance().utilsHandler
+        val fullUri: StringBuilder = StringBuilder().append(
+            if (certInfo != null) {
+                FTPS_URI_PREFIX
+            } else {
+                FTP_URI_PREFIX
+            }
+        )
+        if (validUsername != "" && validPassword != "") {
+            fullUri.append(validUsername)
+            fullUri.append(':').append(validPassword).append("@")
+        }
+        fullUri.append("${NetCopyClientConnectionPoolFtpTest.HOST}:$port")
+
+        utilsHandler.saveToDatabase(
+            OperationData(
+                UtilsHandler.Operation.SFTP,
+                encryptFtpPathAsNecessary(fullUri.toString()),
+                "Test",
+                certInfo?.toString(),
+                null,
+                null
+            )
+        )
+        Shadows.shadowOf(Looper.getMainLooper()).idle()
+    }
+
+    /**
+     * Save SSH connection settings to database.
+     */
+    fun saveSshConnectionSettings(
+        hostKeyPair: KeyPair,
+        validUsername: String,
+        validPassword: String?,
+        privateKey: PrivateKey?,
+        subpath: String? = null
+    ) {
+        val utilsHandler = AppConfig.getInstance().utilsHandler
+        var privateKeyContents: String? = null
+        if (privateKey != null) {
+            val writer = StringWriter()
+            val jw = JcaPEMWriter(writer)
+            jw.writeObject(privateKey)
+            jw.flush()
+            jw.close()
+            privateKeyContents = writer.toString()
+        }
+        val fullUri: StringBuilder = StringBuilder().append(SSH_URI_PREFIX).append(validUsername)
+        if (validPassword != null) fullUri.append(':').append(validPassword)
+        fullUri.append(
+            "@${NetCopyClientConnectionPoolSshTest.HOST}:${NetCopyClientConnectionPoolSshTest.PORT}"
+        )
+
+        if (true == subpath?.isNotEmpty()) {
+            fullUri.append(subpath)
+        }
+
+        if (validPassword != null) utilsHandler.saveToDatabase(
+            OperationData(
+                UtilsHandler.Operation.SFTP,
+                encryptFtpPathAsNecessary(fullUri.toString()),
+                "Test",
+                SecurityUtils.getFingerprint(hostKeyPair.public),
+                null,
+                null
+            )
+        ) else utilsHandler.saveToDatabase(
+            OperationData(
+                UtilsHandler.Operation.SFTP,
+                encryptFtpPathAsNecessary(fullUri.toString()),
+                "Test",
+                SecurityUtils.getFingerprint(hostKeyPair.public),
+                "id_rsa",
+                privateKeyContents
+            )
+        )
+        Shadows.shadowOf(Looper.getMainLooper()).idle()
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/ssh/SshClientUtilTest.kt b/app/src/test/java/com/amaze/filemanager/ssh/SshClientUtilTest.kt
deleted file mode 100644
index bfd4aa83f..000000000
--- a/app/src/test/java/com/amaze/filemanager/ssh/SshClientUtilTest.kt
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
- * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
- *
- * This file is part of Amaze File Manager.
- *
- * Amaze File Manager is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.amaze.filemanager.ssh
-
-import com.amaze.filemanager.filesystem.ssh.SshClientUtils
-import org.junit.Assert
-import org.junit.Test
-
-@Suppress("StringLiteralDuplication")
-class SshClientUtilTest {
-    /**
-     * Test [SshClientUtils.extractRemotePathFrom].
-     */
-    @Test
-    fun testExtractRemotePathFromUri() {
-        Assert.assertEquals(
-            "/home/user/foo/bar",
-            SshClientUtils.extractRemotePathFrom(
-                "ssh://user:password@127.0.0.1:22/home/user/foo/bar"
-            )
-        )
-        Assert.assertEquals(
-            "/",
-            SshClientUtils.extractRemotePathFrom("ssh://user:password@127.0.0.1:22/")
-        )
-        Assert.assertEquals(
-            "/",
-            SshClientUtils.extractRemotePathFrom("ssh://user:password@127.0.0.1:22")
-        )
-        Assert.assertEquals(
-            "/",
-            SshClientUtils.extractRemotePathFrom("ssh://root:a8/875dbc-==@127.0.0.1:9899")
-        )
-        Assert.assertEquals(
-            "/root/.config",
-            SshClientUtils.extractRemotePathFrom(
-                "ssh://root:a8/875dbc-==@127.0.0.1:9899/root/.config"
-            )
-        )
-    }
-
-    /**
-     * Test [SshClientUtils.extractRemotePathFrom].
-     */
-    @Test
-    fun testExtractBaseUriFromUri() {
-        Assert.assertEquals(
-            "ssh://root@127.0.0.1",
-            SshClientUtils.extractBaseUriFrom("ssh://root@127.0.0.1")
-        )
-        Assert.assertEquals(
-            "ssh://root@127.0.0.1:2233",
-            SshClientUtils.extractBaseUriFrom("ssh://root@127.0.0.1:2233")
-        )
-        Assert.assertEquals(
-            "ssh://root@127.0.0.1",
-            SshClientUtils.extractBaseUriFrom("ssh://root@127.0.0.1/root/.config")
-        )
-        Assert.assertEquals(
-            "ssh://root:password@127.0.0.1",
-            SshClientUtils.extractBaseUriFrom("ssh://root:password@127.0.0.1")
-        )
-        Assert.assertEquals(
-            "ssh://root:password@127.0.0.1:3456",
-            SshClientUtils.extractBaseUriFrom("ssh://root:password@127.0.0.1:3456/root/.config")
-        )
-        Assert.assertEquals(
-            "ssh://root:a8/875dbc-==@127.0.0.1:9899",
-            SshClientUtils.extractBaseUriFrom("ssh://root:a8/875dbc-==@127.0.0.1:9899")
-        )
-        Assert.assertEquals(
-            "ssh://root:a8/875dbc-==@127.0.0.1:9899",
-            SshClientUtils.extractBaseUriFrom(
-                "ssh://root:a8/875dbc-==@127.0.0.1:9899/root/.config"
-            )
-        )
-    }
-}
diff --git a/app/src/test/java/com/amaze/filemanager/test/ShadowPasswordUtil.kt b/app/src/test/java/com/amaze/filemanager/test/ShadowPasswordUtil.kt
index 0a7154870..e68b67db1 100644
--- a/app/src/test/java/com/amaze/filemanager/test/ShadowPasswordUtil.kt
+++ b/app/src/test/java/com/amaze/filemanager/test/ShadowPasswordUtil.kt
@@ -46,34 +46,42 @@ class ShadowPasswordUtil {
     /** Method handles encryption of plain text on various APIs  */
     @Implementation
     @Throws(GeneralSecurityException::class, IOException::class)
-    fun encryptPassword(context: Context?, plainText: String): String {
-        return aesEncryptPassword(plainText)
+    fun encryptPassword(
+        context: Context?,
+        plainText: String,
+        base64Options: Int = Base64.URL_SAFE
+    ): String {
+        return aesEncryptPassword(plainText, base64Options)
     }
 
     /** Method handles decryption of cipher text on various APIs  */
     @Implementation
     @Throws(GeneralSecurityException::class, IOException::class)
-    fun decryptPassword(context: Context?, cipherText: String): String {
-        return aesDecryptPassword(cipherText)
+    fun decryptPassword(
+        context: Context?,
+        cipherText: String,
+        base64Options: Int = Base64.URL_SAFE
+    ): String {
+        return aesDecryptPassword(cipherText, base64Options)
     }
 
     /** Helper method to encrypt plain text password  */
     @Throws(GeneralSecurityException::class)
-    private fun aesEncryptPassword(plainTextPassword: String): String {
+    private fun aesEncryptPassword(plainTextPassword: String, base64Options: Int): String {
         val cipher = Cipher.getInstance(ALGO_AES)
         val gcmParameterSpec = GCMParameterSpec(128, IV.toByteArray())
         cipher.init(Cipher.ENCRYPT_MODE, secretKey, gcmParameterSpec)
         val encodedBytes = cipher.doFinal(plainTextPassword.toByteArray())
-        return Base64.encodeToString(encodedBytes, Base64.DEFAULT)
+        return Base64.encodeToString(encodedBytes, base64Options)
     }
 
     /** Helper method to decrypt cipher text password  */
     @Throws(GeneralSecurityException::class)
-    private fun aesDecryptPassword(cipherPassword: String): String {
+    private fun aesDecryptPassword(cipherPassword: String, base64Options: Int): String {
         val cipher = Cipher.getInstance(ALGO_AES)
         val gcmParameterSpec = GCMParameterSpec(128, IV.toByteArray())
         cipher.init(Cipher.DECRYPT_MODE, secretKey, gcmParameterSpec)
-        val decryptedBytes = cipher.doFinal(Base64.decode(cipherPassword, Base64.DEFAULT))
+        val decryptedBytes = cipher.doFinal(Base64.decode(cipherPassword, base64Options))
         return String(decryptedBytes)
     }
 
diff --git a/app/src/test/java/com/amaze/filemanager/test/ShadowPasswordUtilTest.java b/app/src/test/java/com/amaze/filemanager/test/ShadowPasswordUtilTest.java
index 715cf7d6c..2ce8dcbd6 100644
--- a/app/src/test/java/com/amaze/filemanager/test/ShadowPasswordUtilTest.java
+++ b/app/src/test/java/com/amaze/filemanager/test/ShadowPasswordUtilTest.java
@@ -40,10 +40,12 @@ import org.robolectric.shadows.ShadowSQLiteConnection;
 import com.amaze.filemanager.database.UtilitiesDatabase;
 import com.amaze.filemanager.database.UtilsHandler;
 import com.amaze.filemanager.database.models.OperationData;
-import com.amaze.filemanager.filesystem.ssh.SshClientUtils;
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientUtils;
 import com.amaze.filemanager.shadows.ShadowMultiDex;
 import com.amaze.filemanager.utils.PasswordUtil;
 
+import android.util.Base64;
+
 import androidx.test.core.app.ApplicationProvider;
 import androidx.test.ext.junit.runners.AndroidJUnit4;
 
@@ -74,11 +76,12 @@ public class ShadowPasswordUtilTest {
   public void testEncryptDecrypt() throws GeneralSecurityException, IOException {
     String text = "test";
     String encrypted =
-        PasswordUtil.INSTANCE.encryptPassword(ApplicationProvider.getApplicationContext(), text);
+        PasswordUtil.INSTANCE.encryptPassword(
+            ApplicationProvider.getApplicationContext(), text, Base64.DEFAULT);
     assertEquals(
         text,
         PasswordUtil.INSTANCE.decryptPassword(
-            ApplicationProvider.getApplicationContext(), encrypted));
+            ApplicationProvider.getApplicationContext(), encrypted, Base64.DEFAULT));
   }
 
   @Test
@@ -95,7 +98,7 @@ public class ShadowPasswordUtilTest {
     utilsHandler.saveToDatabase(
         new OperationData(
             UtilsHandler.Operation.SFTP,
-            SshClientUtils.encryptSshPathAsNecessary(url),
+            NetCopyClientUtils.INSTANCE.encryptFtpPathAsNecessary(url),
             "Test",
             fingerprint,
             null,
@@ -107,7 +110,8 @@ public class ShadowPasswordUtilTest {
             () -> {
               assertEquals(
                   fingerprint,
-                  utilsHandler.getSshHostKey(SshClientUtils.encryptSshPathAsNecessary(url)));
+                  utilsHandler.getRemoteHostKey(
+                      NetCopyClientUtils.INSTANCE.encryptFtpPathAsNecessary(url)));
               utilitiesDatabase.close();
               return true;
             });
diff --git a/app/src/test/java/com/amaze/filemanager/ui/activities/MainActivityTest.java b/app/src/test/java/com/amaze/filemanager/ui/activities/MainActivityTest.java
index 1541c3c18..c2dc76569 100644
--- a/app/src/test/java/com/amaze/filemanager/ui/activities/MainActivityTest.java
+++ b/app/src/test/java/com/amaze/filemanager/ui/activities/MainActivityTest.java
@@ -27,7 +27,6 @@ import static android.os.Build.VERSION_CODES.P;
 import static androidx.test.core.app.ActivityScenario.launch;
 import static org.awaitility.Awaitility.await;
 import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.fail;
 import static org.mockito.ArgumentMatchers.any;
 import static org.mockito.ArgumentMatchers.anyBoolean;
 import static org.mockito.Mockito.doCallRealMethod;
@@ -55,17 +54,19 @@ import org.robolectric.util.ReflectionHelpers;
 
 import com.amaze.filemanager.application.AppConfig;
 import com.amaze.filemanager.database.UtilsHandler;
-import com.amaze.filemanager.filesystem.ssh.SshClientUtils;
+import com.amaze.filemanager.filesystem.ftp.NetCopyClientUtils;
 import com.amaze.filemanager.shadows.ShadowMultiDex;
 import com.amaze.filemanager.shadows.jcifs.smb.ShadowSmbFile;
 import com.amaze.filemanager.test.ShadowPasswordUtil;
 import com.amaze.filemanager.test.TestUtils;
 import com.amaze.filemanager.ui.dialogs.SftpConnectDialog;
+import com.amaze.filemanager.utils.PasswordUtil;
 import com.amaze.filemanager.utils.SmbUtil;
 
 import android.os.Build;
 import android.os.Bundle;
 import android.os.storage.StorageManager;
+import android.util.Base64;
 
 import androidx.lifecycle.Lifecycle;
 import androidx.test.core.app.ActivityScenario;
@@ -127,7 +128,7 @@ public class MainActivityTest {
   }
 
   @Test
-  public void testInvokeSftpConnectionDialog() {
+  public void testInvokeSftpConnectionDialog() throws GeneralSecurityException, IOException {
 
     Bundle verify = new Bundle();
     verify.putString("address", "127.0.0.1");
@@ -144,7 +145,8 @@ public class MainActivityTest {
   @Test
   public void testInvokeSftpConnectionDialogWithPassword()
       throws GeneralSecurityException, IOException {
-    String uri = "ssh://root:12345678@127.0.0.1:22";
+    String uri =
+        NetCopyClientUtils.INSTANCE.encryptFtpPathAsNecessary("ssh://root:12345678@127.0.0.1:22");
 
     Bundle verify = new Bundle();
     verify.putString("address", "127.0.0.1");
@@ -158,7 +160,8 @@ public class MainActivityTest {
     testOpenSftpConnectDialog(uri, verify);
   }
 
-  private void testOpenSftpConnectDialog(String uri, Bundle verify) {
+  private void testOpenSftpConnectDialog(String uri, Bundle verify)
+      throws GeneralSecurityException, IOException {
     MainActivity activity = mock(MainActivity.class);
     UtilsHandler utilsHandler = mock(UtilsHandler.class);
     when(utilsHandler.getSshAuthPrivateKeyName("ssh://root@127.0.0.1:22")).thenReturn("abcdefgh");
@@ -166,11 +169,23 @@ public class MainActivityTest {
     doCallRealMethod().when(activity).showSftpDialog(any(), any(), anyBoolean());
 
     activity.showSftpDialog(
-        "SCP/SFTP Connection", SshClientUtils.encryptSshPathAsNecessary(uri), true);
+        "SCP/SFTP Connection", NetCopyClientUtils.INSTANCE.encryptFtpPathAsNecessary(uri), true);
     assertEquals(1, mc.constructed().size());
     SftpConnectDialog mocked = mc.constructed().get(0);
+    await().atMost(5, TimeUnit.SECONDS).until(() -> mocked.getArguments() != null);
     for (String key : BUNDLE_KEYS) {
-      assertEquals(verify.get(key), mocked.getArguments().get(key));
+      if (mocked.getArguments().get(key) != null) {
+        if (!key.equals("password")) {
+          assertEquals(verify.get(key), mocked.getArguments().get(key));
+        } else {
+          assertEquals(
+              verify.get(key),
+              PasswordUtil.INSTANCE.decryptPassword(
+                  ApplicationProvider.getApplicationContext(),
+                  (String) mocked.getArguments().get(key),
+                  Base64.URL_SAFE));
+        }
+      }
     }
   }
 
@@ -223,8 +238,6 @@ public class MainActivityTest {
             String[] entry = verify.get(0);
             assertEquals(path, entry[1]);
 
-          } catch (GeneralSecurityException | IOException e) {
-            fail(e.getMessage());
           } finally {
             scenario.moveToState(Lifecycle.State.DESTROYED);
             scenario.close();
diff --git a/app/src/test/java/com/amaze/filemanager/utils/OpenModeTest.java b/app/src/test/java/com/amaze/filemanager/utils/OpenModeTest.java
index fb273ed9a..1f0b67aec 100644
--- a/app/src/test/java/com/amaze/filemanager/utils/OpenModeTest.java
+++ b/app/src/test/java/com/amaze/filemanager/utils/OpenModeTest.java
@@ -25,7 +25,9 @@ import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.CUSTOM;
 import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.DOCUMENT_FILE;
 import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.DROPBOX;
 import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.FILE;
+import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.FTP;
 import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.GDRIVE;
+import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.NFS;
 import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.ONEDRIVE;
 import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.OTG;
 import static com.amaze.filemanager.fileoperations.filesystem.OpenMode.ROOT;
@@ -48,14 +50,16 @@ public class OpenModeTest {
     assertEquals(FILE, OpenMode.getOpenMode(1));
     assertEquals(SMB, OpenMode.getOpenMode(2));
     assertEquals(SFTP, OpenMode.getOpenMode(3));
-    assertEquals(CUSTOM, OpenMode.getOpenMode(4));
-    assertEquals(ROOT, OpenMode.getOpenMode(5));
-    assertEquals(OTG, OpenMode.getOpenMode(6));
-    assertEquals(DOCUMENT_FILE, OpenMode.getOpenMode(7));
-    assertEquals(GDRIVE, OpenMode.getOpenMode(8));
-    assertEquals(DROPBOX, OpenMode.getOpenMode(9));
-    assertEquals(BOX, OpenMode.getOpenMode(10));
-    assertEquals(ONEDRIVE, OpenMode.getOpenMode(11));
+    assertEquals(FTP, OpenMode.getOpenMode(4));
+    assertEquals(NFS, OpenMode.getOpenMode(5));
+    assertEquals(CUSTOM, OpenMode.getOpenMode(6));
+    assertEquals(ROOT, OpenMode.getOpenMode(7));
+    assertEquals(OTG, OpenMode.getOpenMode(8));
+    assertEquals(DOCUMENT_FILE, OpenMode.getOpenMode(9));
+    assertEquals(GDRIVE, OpenMode.getOpenMode(10));
+    assertEquals(DROPBOX, OpenMode.getOpenMode(11));
+    assertEquals(BOX, OpenMode.getOpenMode(12));
+    assertEquals(ONEDRIVE, OpenMode.getOpenMode(13));
     assertThrows(ArrayIndexOutOfBoundsException.class, () -> OpenMode.getOpenMode(-1));
     assertThrows(ArrayIndexOutOfBoundsException.class, () -> OpenMode.getOpenMode(MAX_VALUE));
   }
diff --git a/app/src/test/java/com/amaze/filemanager/utils/SmbUtilTest.java b/app/src/test/java/com/amaze/filemanager/utils/SmbUtilTest.java
deleted file mode 100644
index 70d0d5836..000000000
--- a/app/src/test/java/com/amaze/filemanager/utils/SmbUtilTest.java
+++ /dev/null
@@ -1,139 +0,0 @@
-/*
- * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
- * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
- *
- * This file is part of Amaze File Manager.
- *
- * Amaze File Manager is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package com.amaze.filemanager.utils;
-
-import static android.os.Build.VERSION_CODES.JELLY_BEAN;
-import static android.os.Build.VERSION_CODES.KITKAT;
-import static android.os.Build.VERSION_CODES.P;
-import static com.amaze.filemanager.fileoperations.filesystem.FolderStateKt.DOESNT_EXIST;
-import static com.amaze.filemanager.fileoperations.filesystem.FolderStateKt.WRITABLE_ON_REMOTE;
-import static org.junit.Assert.assertEquals;
-import static org.junit.Assert.assertNotEquals;
-import static org.junit.Assert.assertTrue;
-
-import java.io.IOException;
-import java.security.GeneralSecurityException;
-
-import org.junit.Ignore;
-import org.junit.Test;
-import org.junit.runner.RunWith;
-import org.robolectric.annotation.Config;
-
-import com.amaze.filemanager.shadows.ShadowSmbUtil;
-import com.amaze.filemanager.test.ShadowPasswordUtil;
-
-import androidx.test.core.app.ApplicationProvider;
-import androidx.test.ext.junit.runners.AndroidJUnit4;
-
-import jcifs.smb.NtlmPasswordAuthenticator;
-
-@RunWith(AndroidJUnit4.class)
-@Config(
-    sdk = {JELLY_BEAN, KITKAT, P},
-    shadows = {ShadowPasswordUtil.class, ShadowSmbUtil.class})
-public class SmbUtilTest {
-
-  @Test
-  public void testEncryptDecrypt() throws GeneralSecurityException, IOException {
-    String path = "smb://root:toor@127.0.0.1";
-    String encrypted =
-        SmbUtil.getSmbEncryptedPath(ApplicationProvider.getApplicationContext(), path);
-    assertNotEquals(path, encrypted);
-    assertTrue(encrypted.startsWith("smb://root:"));
-    assertTrue(encrypted.endsWith("@127.0.0.1"));
-    String decrypted =
-        SmbUtil.getSmbDecryptedPath(ApplicationProvider.getApplicationContext(), encrypted);
-    assertEquals(path, decrypted);
-  }
-
-  @Test
-  public void testEncryptWithoutCredentials() throws GeneralSecurityException, IOException {
-    String path = "smb://127.0.0.1";
-    assertEquals(
-        path, SmbUtil.getSmbEncryptedPath(ApplicationProvider.getApplicationContext(), path));
-  }
-
-  @Test
-  @Ignore("Good idea to fix me")
-  public void testEncryptWithoutPassword() throws GeneralSecurityException, IOException {
-    String path = "smb://toor@127.0.0.1";
-    assertEquals(
-        path, SmbUtil.getSmbEncryptedPath(ApplicationProvider.getApplicationContext(), path));
-  }
-
-  @Test
-  public void testCheckFolder() {
-    assertEquals(
-        DOESNT_EXIST, SmbUtil.checkFolder("smb://user:password@5.6.7.8/newfolder/DummyFolder"));
-    assertEquals(
-        DOESNT_EXIST, SmbUtil.checkFolder("smb://user:password@5.6.7.8/newfolder/resume.doc"));
-    assertEquals(
-        WRITABLE_ON_REMOTE, SmbUtil.checkFolder("smb://user:password@5.6.7.8/newfolder/Documents"));
-    assertEquals(
-        DOESNT_EXIST, SmbUtil.checkFolder("smb://user:password@5.6.7.8/newfolder/wirebroken.log"));
-    assertEquals(
-        DOESNT_EXIST, SmbUtil.checkFolder("smb://user:password@5.6.7.8/newfolder/failcheck"));
-  }
-
-  public void testCreateNtlmPasswordAuthenticator() {
-    NtlmPasswordAuthenticator auth = SmbUtil.createFrom(null);
-    assertEquals("", auth.getUserDomain());
-    assertEquals("", auth.getUsername());
-    assertEquals("", auth.getPassword());
-
-    auth = SmbUtil.createFrom("");
-    assertEquals("", auth.getUserDomain());
-    assertEquals("", auth.getUsername());
-    assertEquals("", auth.getPassword());
-
-    auth = SmbUtil.createFrom("username:password");
-    assertEquals("", auth.getUserDomain());
-    assertEquals("username", auth.getUsername());
-    assertEquals("password", auth.getPassword());
-
-    auth = SmbUtil.createFrom("WORKGROUP;username:password");
-    assertEquals("WORKGROUP", auth.getUserDomain());
-    assertEquals("username", auth.getUsername());
-    assertEquals("password", auth.getPassword());
-
-    auth = SmbUtil.createFrom("WORKGROUP;username");
-    assertEquals("WORKGROUP", auth.getUserDomain());
-    assertEquals("username", auth.getUsername());
-    assertEquals("", auth.getPassword());
-
-    // #2313 major symptom
-    auth = SmbUtil.createFrom("username:pass%w0rd");
-    assertEquals("", auth.getUserDomain());
-    assertEquals("username", auth.getUsername());
-    assertEquals("pass%w0rd", auth.getPassword());
-
-    // Shall not happen - we should rarely have % in username/workgroup names, but anyway.
-    auth = SmbUtil.createFrom("WORKGROUP;user%1");
-    assertEquals("WORKGROUP", auth.getUserDomain());
-    assertEquals("user%1", auth.getUsername());
-    assertEquals("", auth.getPassword());
-
-    auth = SmbUtil.createFrom("WORKGROUP%2;user%1:pass%word");
-    assertEquals("WORKGROUP%2", auth.getUserDomain());
-    assertEquals("user%1", auth.getUsername());
-    assertEquals("pass%word", auth.getPassword());
-  }
-}
diff --git a/app/src/test/java/com/amaze/filemanager/utils/SmbUtilTest.kt b/app/src/test/java/com/amaze/filemanager/utils/SmbUtilTest.kt
new file mode 100644
index 000000000..03f8dda12
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/utils/SmbUtilTest.kt
@@ -0,0 +1,177 @@
+/*
+ * Copyright (C) 2014-2020 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.utils
+
+import android.os.Build.VERSION_CODES.JELLY_BEAN
+import android.os.Build.VERSION_CODES.KITKAT
+import android.os.Build.VERSION_CODES.P
+import androidx.test.core.app.ApplicationProvider
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import com.amaze.filemanager.fileoperations.filesystem.DOESNT_EXIST
+import com.amaze.filemanager.fileoperations.filesystem.WRITABLE_ON_REMOTE
+import com.amaze.filemanager.shadows.ShadowSmbUtil
+import com.amaze.filemanager.test.ShadowPasswordUtil
+import com.amaze.filemanager.utils.SmbUtil.checkFolder
+import com.amaze.filemanager.utils.SmbUtil.createFrom
+import com.amaze.filemanager.utils.SmbUtil.getSmbDecryptedPath
+import com.amaze.filemanager.utils.SmbUtil.getSmbEncryptedPath
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertNotEquals
+import org.junit.Assert.assertTrue
+import org.junit.Ignore
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.annotation.Config
+
+/**
+ * Unit tests for [SmbUtil].
+ */
+@Suppress("StringLiteralDuplication")
+@RunWith(AndroidJUnit4::class)
+@Config(
+    sdk = [JELLY_BEAN, KITKAT, P],
+    shadows = [ShadowPasswordUtil::class, ShadowSmbUtil::class]
+)
+class SmbUtilTest {
+
+    /**
+     * Test encrypt/decrypt SMB URIs.
+     */
+    @Test
+    fun testEncryptDecryptSmb() {
+        val path = "smb://root:toor@127.0.0.1"
+        val encrypted = getSmbEncryptedPath(ApplicationProvider.getApplicationContext(), path)
+        assertNotEquals(path, encrypted)
+        assertTrue(encrypted.startsWith("smb://root:"))
+        assertTrue(encrypted.endsWith("@127.0.0.1"))
+        val decrypted = getSmbDecryptedPath(ApplicationProvider.getApplicationContext(), encrypted)
+        assertEquals(path, decrypted)
+    }
+
+    /**
+     * Test encrypt/decrypt FTP(S) URIs.
+     */
+    @Test
+    fun testEncryptDecryptFtps() {
+        val path = "ftps://root:toor@127.0.0.1"
+        val encrypted = getSmbEncryptedPath(ApplicationProvider.getApplicationContext(), path)
+        assertNotEquals(path, encrypted)
+        assertTrue(encrypted.startsWith("ftps://root:"))
+        assertTrue(encrypted.endsWith("@127.0.0.1"))
+        val decrypted = getSmbDecryptedPath(ApplicationProvider.getApplicationContext(), encrypted)
+        assertEquals(path, decrypted)
+    }
+
+    /**
+     * Test encrypt/decrypt URIs without username and password. It should stay the same.
+     */
+    @Test
+    fun testEncryptWithoutCredentials() {
+        val path = "smb://127.0.0.1"
+        assertEquals(
+            path,
+            getSmbEncryptedPath(ApplicationProvider.getApplicationContext(), path)
+        )
+    }
+
+    /**
+     * Test encrypt/decrypt URIs without password. It should stay the same too.
+     */
+    @Test
+    @Ignore("Good idea to fix me")
+    fun testEncryptWithoutPassword() {
+        val path = "smb://toor@127.0.0.1"
+        assertEquals(
+            path,
+            getSmbEncryptedPath(ApplicationProvider.getApplicationContext(), path)
+        )
+    }
+
+    /**
+     * Tests [SmbUtil.checkFolder].
+     */
+    @Test
+    fun testCheckFolder() {
+        assertEquals(
+            DOESNT_EXIST,
+            checkFolder("smb://user:password@5.6.7.8/newfolder/DummyFolder")
+        )
+        assertEquals(
+            DOESNT_EXIST,
+            checkFolder("smb://user:password@5.6.7.8/newfolder/resume.doc")
+        )
+        assertEquals(
+            WRITABLE_ON_REMOTE,
+            checkFolder("smb://user:password@5.6.7.8/newfolder/Documents")
+        )
+        assertEquals(
+            DOESNT_EXIST,
+            checkFolder("smb://user:password@5.6.7.8/newfolder/wirebroken.log")
+        )
+        assertEquals(
+            DOESNT_EXIST,
+            checkFolder("smb://user:password@5.6.7.8/newfolder/failcheck")
+        )
+    }
+
+    /**
+     * Test [SmbUtil.createFrom] for different username/password/domain combinations.
+     */
+    @Test
+    fun testCreateNtlmPasswordAuthenticator() {
+        var auth = createFrom(null)
+        assertEquals("", auth.userDomain)
+        assertEquals("", auth.username)
+        assertEquals("", auth.password)
+        auth = createFrom("")
+        assertEquals("", auth.userDomain)
+        assertEquals("", auth.username)
+        assertEquals("", auth.password)
+        auth = createFrom("username:password")
+        assertEquals("", auth.userDomain)
+        assertEquals("username", auth.username)
+        assertEquals("password", auth.password)
+        auth = createFrom("WORKGROUP;username:password")
+        assertEquals("WORKGROUP", auth.userDomain)
+        assertEquals("username", auth.username)
+        assertEquals("password", auth.password)
+        auth = createFrom("WORKGROUP;username")
+        assertEquals("WORKGROUP", auth.userDomain)
+        assertEquals("username", auth.username)
+        assertEquals("", auth.password)
+
+        // #2313 major symptom
+        auth = createFrom("username:pass%w0rd")
+        assertEquals("", auth.userDomain)
+        assertEquals("username", auth.username)
+        assertEquals("pass%w0rd", auth.password)
+
+        // Shall not happen - we should rarely have % in username/workgroup names, but anyway.
+        auth = createFrom("WORKGROUP;user%1")
+        assertEquals("WORKGROUP", auth.userDomain)
+        assertEquals("user%1", auth.username)
+        assertEquals("", auth.password)
+        auth = createFrom("WORKGROUP%2;user%1:pass%word")
+        assertEquals("WORKGROUP%2", auth.userDomain)
+        assertEquals("user%1", auth.username)
+        assertEquals("pass%word", auth.password)
+    }
+}
diff --git a/app/src/test/java/com/amaze/filemanager/utils/X509CertificateUtilTest.kt b/app/src/test/java/com/amaze/filemanager/utils/X509CertificateUtilTest.kt
new file mode 100644
index 000000000..8a035f0b5
--- /dev/null
+++ b/app/src/test/java/com/amaze/filemanager/utils/X509CertificateUtilTest.kt
@@ -0,0 +1,91 @@
+/*
+ * Copyright (C) 2014-2022 Arpit Khurana <arpitkh96@gmail.com>, Vishal Nehra <vishalmeham2@gmail.com>,
+ * Emmanuel Messulam<emmanuelbendavid@gmail.com>, Raymond Lai <airwave209gt at gmail.com> and Contributors.
+ *
+ * This file is part of Amaze File Manager.
+ *
+ * Amaze File Manager is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <http://www.gnu.org/licenses/>.
+ */
+
+package com.amaze.filemanager.utils
+
+import android.os.Build.VERSION_CODES.JELLY_BEAN
+import android.os.Build.VERSION_CODES.KITKAT
+import android.os.Build.VERSION_CODES.P
+import androidx.test.ext.junit.runners.AndroidJUnit4
+import com.amaze.filemanager.shadows.ShadowMultiDex
+import com.amaze.filemanager.utils.X509CertificateUtil.FINGERPRINT
+import com.amaze.filemanager.utils.X509CertificateUtil.ISSUER
+import com.amaze.filemanager.utils.X509CertificateUtil.SERIAL
+import com.amaze.filemanager.utils.X509CertificateUtil.SUBJECT
+import org.bouncycastle.cert.X509CertificateHolder
+import org.bouncycastle.openssl.PEMParser
+import org.junit.Assert.assertEquals
+import org.junit.Assert.assertTrue
+import org.junit.Before
+import org.junit.Test
+import org.junit.runner.RunWith
+import org.robolectric.annotation.Config
+import java.io.StringReader
+import javax.security.cert.X509Certificate
+
+@RunWith(AndroidJUnit4::class)
+@Config(
+    shadows = [ShadowMultiDex::class],
+    sdk = [JELLY_BEAN, KITKAT, P]
+)
+class X509CertificateUtilTest {
+
+    private lateinit var cert: X509Certificate
+
+    /**
+     * Read and parse PEM as setup.
+     */
+    @Before
+    fun setUp() {
+        val parser = PEMParser(
+            StringReader(
+                String(
+                    javaClass.getResourceAsStream("/test.pem").readBytes()
+                )
+            )
+        )
+        val a = parser.readObject()
+        cert = X509Certificate.getInstance((a as X509CertificateHolder).encoded)
+    }
+
+    /**
+     * Test [X509CertificateUtil.parse]
+     */
+    @Test
+    fun testParseCert() {
+        val verify = X509CertificateUtil.parse(cert)
+
+        assertTrue(verify.containsKey(SUBJECT))
+        assertEquals("C=in, O=Team Amaze, CN=test.ftpsd.local", verify[SUBJECT])
+        assertTrue(verify.containsKey(ISSUER))
+        assertEquals("C=in, O=Team Amaze, CN=test.ftpsd.local", verify[ISSUER])
+        assertTrue(verify.containsKey(SERIAL))
+        assertEquals(
+            "11:f5:7b:bf:1e:4f:da:f6:b9:e8:0c:e3:49:67:5e:f1:5f:b7:0a:1f",
+            verify[SERIAL]
+        )
+        assertTrue(verify.containsKey(FINGERPRINT))
+        assertEquals(
+            "a9:ab:de:6f:67:3a:f8:db:41:e0:30:81:f9:b7:36:cb:7a:2b:42:fc:cd:a9:af:a2:bc:" +
+                "64:55:95:f2:c7:9a:74",
+            verify[FINGERPRINT]
+        )
+    }
+}
diff --git a/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/OpenMode.java b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/OpenMode.java
index 4a270fef4..407bef48a 100644
--- a/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/OpenMode.java
+++ b/file_operations/src/main/java/com/amaze/filemanager/fileoperations/filesystem/OpenMode.java
@@ -29,7 +29,12 @@ public enum OpenMode {
   UNKNOWN,
   FILE,
   SMB,
+  /** SSH/SCP/SFTP */
   SFTP,
+  /** FTP/FTP over SSL (FTPS) */
+  FTP,
+  /** Network file system - reserved for #268 */
+  NFS,
 
   /** Custom file types like apk/images/downloads (which don't have a defined path) */
   CUSTOM,
