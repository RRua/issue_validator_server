diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/BaseButtonlessDfuImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/BaseButtonlessDfuImpl.java
deleted file mode 100644
index 158c7b7..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/BaseButtonlessDfuImpl.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.annotation.SuppressLint;
-import android.bluetooth.BluetoothDevice;
-import android.bluetooth.BluetoothGatt;
-import android.bluetooth.BluetoothGattCharacteristic;
-import android.content.Intent;
-
-import androidx.annotation.NonNull;
-
-/**
- * A base implementation of a buttonless service. The purpose of a buttonless service is to
- * switch a device into the DFU bootloader mode.
- */
-@SuppressLint("MissingPermission")
-/* package */ abstract class BaseButtonlessDfuImpl extends BaseDfuImpl {
-
-	private final BaseButtonlessDfuImpl.ButtonlessBluetoothCallback mBluetoothCallback = new BaseButtonlessDfuImpl.ButtonlessBluetoothCallback();
-
-	protected class ButtonlessBluetoothCallback extends BaseBluetoothGattCallback {
-		@Override
-		public void onCharacteristicChanged(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "Notification received from " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
-			mReceivedData = characteristic.getValue();
-			notifyLock();
-		}
-
-		@Override
-		public void onCharacteristicWrite(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int status) {
-			// Despite the status code the Enter bootloader request has completed.
-			mRequestCompleted = true;
-			notifyLock();
-		}
-	}
-
-	BaseButtonlessDfuImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service) {
-		super(intent, service);
-	}
-
-	@Override
-	public BaseBluetoothGattCallback getGattCallback() {
-		return mBluetoothCallback;
-	}
-
-	/**
-	 * Closes the BLE connection to the device and removes bonding information if a proper flag was NOT set
-	 * in the {@link DfuServiceInitiator#setKeepBond(boolean)}.
-	 * This method will scan for a bootloader advertising with the address equal to the current or incremented by 1 and restart the service.
-	 * @param intent the intent used to start the DFU service. It contains all user flags in the bundle.
-	 * @param forceRefresh true, if cache should be cleared even for a bonded device. Usually the Service Changed indication should be used for this purpose.
-	 * @param scanForBootloader true to scan for advertising bootloader, false to keep the same address
-	 */
-	@SuppressWarnings("SameParameterValue")
-	void finalize(@NonNull final Intent intent, final boolean forceRefresh, final boolean scanForBootloader) {
-		/*
-		 * We are done with DFU. Now the service may refresh device cache and clear stored services.
-		 * For bonded device this is required only if if doesn't support Service Changed indication.
-		 * Android shouldn't cache services of non-bonded devices having Service Changed characteristic in their database, but it does, so...
-		 */
-		final boolean keepBond = intent.getBooleanExtra(DfuBaseService.EXTRA_KEEP_BOND, false);
-		mService.refreshDeviceCache(mGatt, forceRefresh || !keepBond);
-
-		// Close the device
-		mService.close(mGatt);
-
-		/*
-		 * The experimental buttonless service from SDK 12.x does not support sharing bond information
-		 * from the app to the bootloader. That means, that the DFU bootloader must advertise with advertise
-		 * with address +1 and must not be paired.
-		 */
-		logi("Restarting to bootloader mode");
-		final Intent newIntent = new Intent();
-		newIntent.fillIn(intent, Intent.FILL_IN_COMPONENT | Intent.FILL_IN_PACKAGE);
-		restartService(newIntent, scanForBootloader);
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/BaseCustomDfuImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/BaseCustomDfuImpl.java
deleted file mode 100644
index 4ee3c98..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/BaseCustomDfuImpl.java
+++ /dev/null
@@ -1,526 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.annotation.SuppressLint;
-import android.bluetooth.BluetoothDevice;
-import android.bluetooth.BluetoothGatt;
-import android.bluetooth.BluetoothGattCharacteristic;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.os.Build;
-import android.preference.PreferenceManager;
-
-import java.io.IOException;
-import java.util.UUID;
-import java.util.zip.CRC32;
-
-import androidx.annotation.NonNull;
-import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
-import no.nordicsemi.android.dfu.internal.exception.DfuException;
-import no.nordicsemi.android.dfu.internal.exception.HexFileValidationException;
-import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
-
-@SuppressLint("MissingPermission")
-/* package */ abstract class BaseCustomDfuImpl extends BaseDfuImpl {
-	/**
-	 * Flag indicating whether the init packet has been already transferred or not.
-	 */
-	private boolean mInitPacketInProgress;
-	/**
-	 * Flag indicating whether the firmware is being transmitted or not.
-	 */
-	boolean mFirmwareUploadInProgress;
-	/**
-	 * The number of packets of firmware data to be send before receiving a new Packets
-	 * receipt notification. 0 disables the packets notifications.
-	 */
-	int mPacketsBeforeNotification;
-	/**
-	 * The number of packets sent since last notification.
-	 */
-	private int mPacketsSentSinceNotification;
-	/**
-	 * <p>
-	 * Flag set to <code>true</code> when the DFU target had send a notification with status other
-	 * than success. Setting it to <code>true</code> will abort sending firmware and
-	 * stop logging notifications (read below for explanation).
-	 * <p>
-	 * The onCharacteristicWrite(..) callback is called when Android writes the packet into the
-	 * outgoing queue, not when it physically sends the data. This means that the service will
-	 * first put up to N* packets, one by one, to the queue, while in fact the first one is transmitted.
-	 * In case the DFU target is in an invalid state it will notify Android with a notification
-	 * 10-03-02 for each packet of firmware that has been sent. After receiving the first such
-	 * notification, the DFU service will add the reset command to the outgoing queue,
-	 * but it will still be receiving such notifications until all the data packets are sent.
-	 * Those notifications should be ignored. This flag will prevent from logging
-	 * "Notification received..." more than once.
-	 * <p>
-	 * Additionally, sometimes after writing the command 6 (OP_CODE_RESET),
-	 * Android will receive a notification and update the characteristic value with 10-03-02 and
-	 * the callback for write reset command will log
-	 * "[DFU] Data written to ..., value (0x): 10-03-02" instead of "...(x0): 06".
-	 * But this does not matter for the DFU process.
-	 * <p>
-	 * N* - Value of Packet Receipt Notification, 12 by default.
-	 */
-	boolean mRemoteErrorOccurred;
-
-	class BaseCustomBluetoothCallback extends BaseBluetoothGattCallback {
-		protected void onPacketCharacteristicWrite(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int status) {
-			// this method can be overwritten on the final class
-		}
-
-		@Override
-		public void onCharacteristicWrite(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int status) {
-			if (status == BluetoothGatt.GATT_SUCCESS) {
-				/*
-				 * This method is called when either a CONTROL POINT or PACKET characteristic has been written.
-				 * If it is the CONTROL POINT characteristic, just set the {@link mRequestCompleted}
-				 * flag to true. The main thread will continue its task when notified.
-				 * If the PACKET characteristic was written we must:
-				 * - if the image size was written in DFU Start procedure, just set flag to true
-				 * otherwise
-				 * - send the next packet, if notification is not required at that moment, or
-				 * - do nothing, because we have to wait for the notification to confirm the data received
-				 */
-				if (characteristic.getUuid().equals(getPacketCharacteristicUUID())) {
-					if (mInitPacketInProgress) {
-						// We've got confirmation that the init packet was sent
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO,
-								"Data written to " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
-						mInitPacketInProgress = false;
-					} else if (mFirmwareUploadInProgress) {
-						// If the PACKET characteristic was written with image data, update counters
-						mProgressInfo.addBytesSent(characteristic.getValue().length);
-						mPacketsSentSinceNotification++;
-
-						final boolean notificationExpected = mPacketsBeforeNotification > 0 && mPacketsSentSinceNotification >= mPacketsBeforeNotification;
-						final boolean lastPacketTransferred = mProgressInfo.isComplete();
-						final boolean lastObjectPacketTransferred = mProgressInfo.isObjectComplete();
-
-						// When a Packet Receipt Notification notification is expected
-						// we must not call notifyLock() as the process will resume after notification is received.
-						if (notificationExpected)
-							return;
-
-						// In Secure DFU we (usually, depends on the page size and PRN value) do not get any notification after the object is completed,
-						// therefore the lock must be notified here to resume the main process.
-						if (lastPacketTransferred || lastObjectPacketTransferred) {
-							mFirmwareUploadInProgress = false;
-							notifyLock();
-							return;
-						}
-
-						// When neither of them is true, send the next packet
-						try {
-							waitIfPaused();
-							// The writing might have been aborted (mAborted = true), an error might have occurred.
-							// In that case stop sending.
-							if (mAborted || mError != 0 || mRemoteErrorOccurred || mResetRequestSent) {
-								mFirmwareUploadInProgress = false;
-								mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "Upload terminated");
-								notifyLock();
-								return;
-							}
-
-							final int available = mProgressInfo.getAvailableObjectSizeIsBytes();
-							byte[] buffer = mBuffer;
-							if (available < buffer.length)
-								buffer = new byte[available];
-							final int size = mFirmwareStream.read(buffer);
-							writePacket(gatt, characteristic, buffer, size);
-							return;
-						} catch (final HexFileValidationException e) {
-							loge("Invalid HEX file");
-							mError = DfuBaseService.ERROR_FILE_INVALID;
-						} catch (final IOException e) {
-							loge("Error while reading the input stream", e);
-							mError = DfuBaseService.ERROR_FILE_IO_EXCEPTION;
-						}
-					} else {
-						onPacketCharacteristicWrite(gatt, characteristic, status);
-					}
-				} else {
-					// If the CONTROL POINT characteristic was written just set the flag to true.
-					// The main thread will continue its task when notified.
-					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO,
-							"Data written to " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
-					mRequestCompleted = true;
-				}
-			} else {
-				/*
-				 * If a Reset (Op Code = 6) or Activate and Reset (Op Code = 5) commands are sent,
-				 * the DFU target resets and sometimes does it so quickly that does not manage to send
-				 * any ACK to the controller and error 133 is thrown here. This bug should be fixed
-				 * in SDK 8.0+ where the target would gracefully disconnect before restarting.
-				 */
-				if (mResetRequestSent)
-					mRequestCompleted = true;
-				else {
-					loge("Characteristic write error: " + status);
-					mError = DfuBaseService.ERROR_CONNECTION_MASK | status;
-				}
-			}
-			notifyLock();
-		}
-
-		void handlePacketReceiptNotification(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {
-			// Secure DFU:
-			// When PRN is set to be received after the object is complete we don't want to send anything. First the object needs to be executed.
-			if (!mFirmwareUploadInProgress) {
-				handleNotification(gatt, characteristic);
-				return;
-			}
-
-			final BluetoothGattCharacteristic packetCharacteristic =
-					gatt.getService(getDfuServiceUUID()).getCharacteristic(getPacketCharacteristicUUID());
-			try {
-				mPacketsSentSinceNotification = 0;
-
-				waitIfPaused();
-				// The writing might have been aborted (mAborted = true), an error might have occurred.
-				// In that case quit sending.
-				if (mAborted || mError != 0 || mRemoteErrorOccurred || mResetRequestSent) {
-					mFirmwareUploadInProgress = false;
-					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "Upload terminated");
-					return;
-				}
-
-				final boolean lastPacketTransferred = mProgressInfo.isComplete();
-				final boolean lastObjectPacketTransferred = mProgressInfo.isObjectComplete();
-
-				if (lastPacketTransferred || lastObjectPacketTransferred) {
-					mFirmwareUploadInProgress = false;
-					notifyLock();
-					return;
-				}
-
-				final int available = mProgressInfo.getAvailableObjectSizeIsBytes();
-				byte[] buffer = mBuffer;
-				if (available < buffer.length)
-					buffer = new byte[available];
-				final int size = mFirmwareStream.read(buffer);
-				writePacket(gatt, packetCharacteristic, buffer, size);
-			} catch (final HexFileValidationException e) {
-				loge("Invalid HEX file");
-				mError = DfuBaseService.ERROR_FILE_INVALID;
-			} catch (final IOException e) {
-				loge("Error while reading the input stream", e);
-				mError = DfuBaseService.ERROR_FILE_IO_EXCEPTION;
-			}
-		}
-
-		@SuppressWarnings("unused")
-		void handleNotification(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO,
-					"Notification received from " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
-			mReceivedData = characteristic.getValue();
-			mFirmwareUploadInProgress = false;
-		}
-	}
-
-	@SuppressWarnings("deprecation")
-	BaseCustomDfuImpl(@NonNull final Intent intent, final DfuBaseService service) {
-		super(intent, service);
-
-		if (intent.hasExtra(DfuBaseService.EXTRA_PACKET_RECEIPT_NOTIFICATIONS_ENABLED)) {
-			// Read from intent
-			final boolean packetReceiptNotificationEnabled =
-					intent.getBooleanExtra(DfuBaseService.EXTRA_PACKET_RECEIPT_NOTIFICATIONS_ENABLED, Build.VERSION.SDK_INT < Build.VERSION_CODES.M);
-			int numberOfPackets = intent.getIntExtra(DfuBaseService.EXTRA_PACKET_RECEIPT_NOTIFICATIONS_VALUE, DfuServiceInitiator.DEFAULT_PRN_VALUE);
-			if (numberOfPackets < 0 || numberOfPackets > 0xFFFF)
-				numberOfPackets = DfuServiceInitiator.DEFAULT_PRN_VALUE;
-			if (!packetReceiptNotificationEnabled)
-				numberOfPackets = 0;
-			mPacketsBeforeNotification = numberOfPackets;
-		} else {
-			// Read preferences
-			final SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(service);
-			final boolean packetReceiptNotificationEnabled =
-					preferences.getBoolean(DfuSettingsConstants.SETTINGS_PACKET_RECEIPT_NOTIFICATION_ENABLED, Build.VERSION.SDK_INT < Build.VERSION_CODES.M);
-			String value = preferences.getString(DfuSettingsConstants.SETTINGS_NUMBER_OF_PACKETS, String.valueOf(DfuServiceInitiator.DEFAULT_PRN_VALUE));
-			int numberOfPackets;
-			try {
-				numberOfPackets = Integer.parseInt(value);
-				if (numberOfPackets < 0 || numberOfPackets > 0xFFFF)
-					numberOfPackets = DfuServiceInitiator.DEFAULT_PRN_VALUE;
-			} catch (final NumberFormatException e) {
-				numberOfPackets = DfuServiceInitiator.DEFAULT_PRN_VALUE;
-			}
-			if (!packetReceiptNotificationEnabled)
-				numberOfPackets = 0;
-			mPacketsBeforeNotification = numberOfPackets;
-		}
-	}
-
-	@SuppressWarnings("unused")
-	protected abstract UUID getControlPointCharacteristicUUID();
-
-	protected abstract UUID getPacketCharacteristicUUID();
-
-	protected abstract UUID getDfuServiceUUID();
-
-	/**
-	 * Wends the whole init packet stream to the given characteristic.
-	 *
-	 * @param characteristic the target characteristic
-	 * @param crc32          the CRC object to be updated based on the data sent
-	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
-	 *                                     the transmission.
-	 * @throws DfuException                Thrown if DFU error occur.
-	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
-	 */
-	void writeInitData(final BluetoothGattCharacteristic characteristic, final CRC32 crc32)
-			throws DfuException, DeviceDisconnectedException, UploadAbortedException {
-		try {
-			byte[] data = mBuffer;
-			int size;
-			while ((size = mInitPacketStream.read(data, 0, data.length)) != -1) {
-				writeInitPacket(characteristic, data, size);
-				if (crc32 != null)
-					crc32.update(data, 0, size);
-			}
-		} catch (final IOException e) {
-			loge("Error while reading Init packet file", e);
-			throw new DfuException("Error while reading Init packet file", DfuBaseService.ERROR_FILE_ERROR);
-		}
-	}
-
-	/**
-	 * Writes the Init packet to the characteristic. This method is SYNCHRONOUS and wait until the
-	 * {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)}
-	 * will be called or the device gets disconnected. If connection state will change,
-	 * or an error will occur, an exception will be thrown.
-	 *
-	 * @param characteristic the characteristic to write to. Should be the DFU PACKET.
-	 * @param buffer         the init packet as a byte array.
-	 * @param size           the init packet size.
-	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of the transmission.
-	 * @throws DfuException                Thrown if DFU error occur.
-	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
-	 */
-	private void writeInitPacket(final BluetoothGattCharacteristic characteristic, final byte[] buffer, final int size)
-			throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-		if (mAborted)
-			throw new UploadAbortedException();
-		byte[] locBuffer = buffer;
-		if (buffer.length != size) {
-			locBuffer = new byte[size];
-			System.arraycopy(buffer, 0, locBuffer, 0, size);
-		}
-		mReceivedData = null;
-		mError = 0;
-		mInitPacketInProgress = true;
-
-		characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE);
-		characteristic.setValue(locBuffer);
-		logi("Sending init packet (Value = " + parse(locBuffer) + ")");
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Writing to characteristic " + characteristic.getUuid());
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.writeCharacteristic(" + characteristic.getUuid() + ")");
-		mGatt.writeCharacteristic(characteristic);
-
-		// We have to wait for confirmation
-		try {
-			synchronized (mLock) {
-				while ((mInitPacketInProgress && mConnected && mError == 0) || mPaused)
-					mLock.wait();
-			}
-		} catch (final InterruptedException e) {
-			loge("Sleeping interrupted", e);
-		}
-		if (!mConnected)
-			throw new DeviceDisconnectedException("Unable to write Init DFU Parameters: device disconnected");
-		if (mError != 0)
-			throw new DfuException("Unable to write Init DFU Parameters", mError);
-	}
-
-	/**
-	 * Starts sending the data. This method is SYNCHRONOUS and terminates when the whole file will
-     * be uploaded or the device get disconnected. If connection state will change, or an error
-     * will occur, an exception will be thrown.
-	 *
-	 * @param packetCharacteristic the characteristic to write file content to. Must be the DFU PACKET.
-	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle
-     *                                     of the transmission.
-	 * @throws DfuException                Thrown if DFU error occur.
-	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
-	 */
-	void uploadFirmwareImage(final BluetoothGattCharacteristic packetCharacteristic)
-			throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-		if (mAborted)
-			throw new UploadAbortedException();
-		mReceivedData = null;
-		mError = 0;
-		mFirmwareUploadInProgress = true;
-		mPacketsSentSinceNotification = 0;
-
-		try {
-			final int available = mProgressInfo.getAvailableObjectSizeIsBytes();
-			byte[] buffer = mBuffer;
-			if (available < buffer.length)
-				buffer = new byte[available];
-			final int size = mFirmwareStream.read(buffer);
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE,
-                    "Sending firmware to characteristic " + packetCharacteristic.getUuid() + "...");
-			writePacket(mGatt, packetCharacteristic, buffer, size);
-		} catch (final HexFileValidationException e) {
-			throw new DfuException("HEX file not valid", DfuBaseService.ERROR_FILE_INVALID);
-		} catch (final IOException e) {
-			throw new DfuException("Error while reading file", DfuBaseService.ERROR_FILE_IO_EXCEPTION);
-		}
-
-		try {
-			synchronized (mLock) {
-				while ((mFirmwareUploadInProgress && mReceivedData == null && mConnected && mError == 0) || mPaused)
-					mLock.wait();
-			}
-		} catch (final InterruptedException e) {
-			loge("Sleeping interrupted", e);
-		}
-
-		if (!mConnected)
-			throw new DeviceDisconnectedException("Uploading Firmware Image failed: device disconnected");
-		if (mError != 0)
-			throw new DfuException("Uploading Firmware Image failed", mError);
-	}
-
-	/**
-	 * Writes the buffer to the characteristic. The maximum size of the buffer is dependent on MTU.
-	 * This method is ASYNCHRONOUS and returns immediately after adding the data to TX queue.
-	 *
-	 * @param characteristic the characteristic to write to. Should be the DFU PACKET.
-	 * @param buffer         the buffer with 1-20 bytes.
-	 * @param size           the number of bytes from the buffer to send.
-	 */
-	private void writePacket(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final byte[] buffer, final int size) {
-		byte[] locBuffer = buffer;
-		if (size <= 0) // This should never happen
-			return;
-		if (buffer.length != size) {
-			locBuffer = new byte[size];
-			System.arraycopy(buffer, 0, locBuffer, 0, size);
-		}
-		characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE);
-		characteristic.setValue(locBuffer);
-		gatt.writeCharacteristic(characteristic);
-	}
-
-	/**
-	 * Closes the BLE connection to the device and removes/restores bonding, if a proper flags were
-     * set in the {@link DfuServiceInitiator}. This method will also change the DFU state to
-     * completed or restart the service to send the second part.
-	 *
-	 * @param intent       the intent used to start the DFU service.
-     *                     It contains all user flags in the bundle.
-	 * @param forceRefresh true, if cache should be cleared even for a bonded device.
-     *                     Usually the Service Changed indication should be used for this purpose.
-	 */
-	void finalize(final Intent intent, final boolean forceRefresh) {
-		/*
-		 * We are done with DFU. Now the service may refresh device cache and clear stored services.
-		 * For bonded device this is required only if if doesn't support Service Changed indication.
-		 * Android shouldn't cache services of non-bonded devices having Service Changed
-		 * characteristic in their database, but it does, so...
-		 */
-		final boolean keepBond = intent.getBooleanExtra(DfuBaseService.EXTRA_KEEP_BOND, false);
-		mService.refreshDeviceCache(mGatt, forceRefresh || !keepBond);
-
-		// Close the device
-		mService.close(mGatt);
-
-		/*
-		 * During the update the bonding information on the target device may have been removed.
-		 * To create bond with the new application set the EXTRA_RESTORE_BOND extra to true.
-		 * In case the bond information is copied to the new application the new bonding is not required.
-		 */
-		boolean alreadyWaited = false;
-		if (mGatt.getDevice().getBondState() == BluetoothDevice.BOND_BONDED) {
-			final boolean restoreBond = intent.getBooleanExtra(DfuBaseService.EXTRA_RESTORE_BOND, false);
-			if (restoreBond || !keepBond) {
-				// The bond information was lost.
-				removeBond();
-
-				// Give some time for removing the bond information. 300 ms was to short,
-                // let's set it to 2 seconds just to be sure.
-				mService.waitFor(2000);
-				alreadyWaited = true;
-			}
-
-			if (restoreBond && (mFileType & DfuBaseService.TYPE_APPLICATION) > 0) {
-				// Restore pairing when application was updated.
-				if (!createBond())
-					logw("Creating bond failed");
-				alreadyWaited = false;
-			}
-		}
-
-		/*
-		 * We need to send PROGRESS_COMPLETED message only when all files has been transmitted.
-		 * In case you want to send the Soft Device and/or Bootloader and the Application,
-		 * the service will be started twice: one to send SD+BL, and the second time to send the
-		 * Application only (using the new Bootloader).
-		 * In the first case we do not send PROGRESS_COMPLETED notification.
-		 */
-		if (mProgressInfo.isLastPart()) {
-			// Delay this event a little bit. Android needs some time to prepare for reconnection.
-			if (!alreadyWaited)
-				mService.waitFor(1400);
-			mProgressInfo.setProgress(DfuBaseService.PROGRESS_COMPLETED);
-		} else {
-			/*
-			 * In case when the SoftDevice has been upgraded, and the application should be send
-			 * in the following connection, we have to make sure that we know the address the device
-			 * is advertising with. Depending on the method used to start the DFU bootloader the first time
-			 * the new Bootloader may advertise with the same address or one incremented by 1.
-			 * When the buttonless update was used, the bootloader will use the same address as the
-			 * application. The cached list of services on the Android device should be cleared
-			 * thanks to the Service Changed characteristic (the fact that it exists if not bonded,
-			 * or the Service Changed indication on bonded one).
-			 * In case of forced DFU mode (using a button), the Bootloader does not know whether
-			 * there was the Service Changed characteristic present in the list of application's
-			 * services so it must advertise with a different address. The same situation applies
-			 * when the new Soft Device was uploaded and the old application has been removed in
-			 * this process.
-			 *
-			 * We could have save the fact of jumping as a parameter of the service but it ma be
-			 * that some Android devices must first scan a device before connecting to it.
-			 * It a device with the address+1 has never been detected before the service could have
-			 * failed on connection.
-			 */
-
-			/*
-			 * The current service instance has uploaded the Soft Device and/or Bootloader.
-			 * We need to start another instance that will try to send application only.
-			 */
-			logi("Starting service that will upload application");
-			final Intent newIntent = new Intent();
-			newIntent.fillIn(intent, Intent.FILL_IN_COMPONENT | Intent.FILL_IN_PACKAGE);
-			newIntent.putExtra(DfuBaseService.EXTRA_FILE_MIME_TYPE, DfuBaseService.MIME_TYPE_ZIP); // ensure this is set (e.g. for scripts)
-			newIntent.putExtra(DfuBaseService.EXTRA_FILE_TYPE, DfuBaseService.TYPE_APPLICATION); // set the type to application only
-			newIntent.putExtra(DfuBaseService.EXTRA_PART_CURRENT, mProgressInfo.getCurrentPart() + 1);
-			newIntent.putExtra(DfuBaseService.EXTRA_PARTS_TOTAL, mProgressInfo.getTotalParts());
-			restartService(newIntent, /* the bootloader may advertise with different address */ true);
-		}
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/BaseDfuImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/BaseDfuImpl.java
deleted file mode 100644
index 901059b..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/BaseDfuImpl.java
+++ /dev/null
@@ -1,813 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.annotation.SuppressLint;
-import android.bluetooth.BluetoothDevice;
-import android.bluetooth.BluetoothGatt;
-import android.bluetooth.BluetoothGattCharacteristic;
-import android.bluetooth.BluetoothGattDescriptor;
-import android.bluetooth.BluetoothGattService;
-import android.content.Intent;
-import android.os.Build;
-import android.util.Log;
-
-import java.io.InputStream;
-import java.lang.reflect.Method;
-import java.util.UUID;
-
-import androidx.annotation.IntRange;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.RequiresApi;
-import no.nordicsemi.android.dfu.internal.ArchiveInputStream;
-import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
-import no.nordicsemi.android.dfu.internal.exception.DfuException;
-import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
-import no.nordicsemi.android.dfu.internal.scanner.BootloaderScannerFactory;
-
-@SuppressLint("MissingPermission")
-/* package */ abstract class BaseDfuImpl implements DfuService {
-	private static final String TAG = "DfuImpl";
-
-	static final UUID GENERIC_ATTRIBUTE_SERVICE_UUID = new UUID(0x0000180100001000L, 0x800000805F9B34FBL);
-	static final UUID SERVICE_CHANGED_UUID           = new UUID(0x00002A0500001000L, 0x800000805F9B34FBL);
-	static final UUID CLIENT_CHARACTERISTIC_CONFIG   = new UUID(0x0000290200001000L, 0x800000805f9b34fbL);
-	static final int NOTIFICATIONS = 1;
-	static final int INDICATIONS = 2;
-
-	private static final char[] HEX_ARRAY = "0123456789ABCDEF".toCharArray();
-	private static final int MAX_PACKET_SIZE_DEFAULT = 20; // the default maximum number of bytes in one packet is 20.
-
-	/**
-	 * Lock used in synchronization purposes.
-	 */
-	final Object mLock = new Object();
-
-	InputStream mFirmwareStream;
-	InputStream mInitPacketStream;
-
-	/**
-	 * The target GATT device.
-	 */
-	BluetoothGatt mGatt;
-	/**
-	 * The firmware type. See TYPE_* constants.
-	 */
-	int mFileType;
-	/**
-	 * Flag set to true if sending was paused.
-	 */
-	boolean mPaused;
-	/**
-	 * Flag set to true if sending was aborted.
-	 */
-	boolean mAborted;
-	/**
-	 * Flag indicating whether the device is still connected.
-	 */
-	boolean mConnected;
-	/**
-	 * Flag indicating whether the request was completed or not
-	 */
-	boolean mRequestCompleted;
-	/**
-	 * Flag sent when a request has been sent that will cause the DFU target to reset.
-     * Often, after sending such command, Android throws a connection state error.
-     * If this flag is set the error will be ignored.
-	 */
-	boolean mResetRequestSent;
-	/**
-	 * The number of the last error that has occurred or 0 if there was no error.
-	 */
-	int mError;
-	/**
-	 * Latest data received from device using notification.
-	 */
-	byte[] mReceivedData = null;
-	byte[] mBuffer = new byte[MAX_PACKET_SIZE_DEFAULT];
-	DfuBaseService mService;
-	DfuProgressInfo mProgressInfo;
-	int mImageSizeInBytes;
-	int mInitPacketSizeInBytes;
-	private int mCurrentMtu;
-
-	protected class BaseBluetoothGattCallback extends DfuGattCallback {
-		// The Implementation object is created depending on device services, so after the device
-        // is connected and services were scanned.
-
-		// public void onConnected() { }
-
-		@Override
-		public void onDisconnected() {
-			mConnected = false;
-			notifyLock();
-		}
-
-		@Override
-		public void onCharacteristicRead(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int status) {
-			if (status == BluetoothGatt.GATT_SUCCESS) {
-				/*
-				 * This method is called when the DFU Version characteristic has been read.
-				 */
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO,
-                        "Read Response received from " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
-				mReceivedData = characteristic.getValue();
-				mRequestCompleted = true;
-			} else {
-				loge("Characteristic read error: " + status);
-				mError = DfuBaseService.ERROR_CONNECTION_MASK | status;
-			}
-			notifyLock();
-		}
-
-		@Override
-		public void onDescriptorRead(final BluetoothGatt gatt, final BluetoothGattDescriptor descriptor, final int status) {
-			if (status == BluetoothGatt.GATT_SUCCESS) {
-				if (CLIENT_CHARACTERISTIC_CONFIG.equals(descriptor.getUuid())) {
-					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO,
-                            "Read Response received from descr." + descriptor.getCharacteristic().getUuid() + ", value (0x): " + parse(descriptor));
-					if (SERVICE_CHANGED_UUID.equals(descriptor.getCharacteristic().getUuid())) {
-						// We have enabled indications for the Service Changed characteristic
-						mRequestCompleted = true;
-					} else {
-						// reading other descriptor is not supported
-						loge("Unknown descriptor read"); // this have to be implemented if needed
-					}
-				}
-			} else {
-				loge("Descriptor read error: " + status);
-				mError = DfuBaseService.ERROR_CONNECTION_MASK | status;
-			}
-			notifyLock();
-		}
-
-		@Override
-		public void onDescriptorWrite(final BluetoothGatt gatt, final BluetoothGattDescriptor descriptor, final int status) {
-			if (status == BluetoothGatt.GATT_SUCCESS) {
-				if (CLIENT_CHARACTERISTIC_CONFIG.equals(descriptor.getUuid())) {
-					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO,
-                            "Data written to descr." + descriptor.getCharacteristic().getUuid() + ", value (0x): " + parse(descriptor));
-					if (SERVICE_CHANGED_UUID.equals(descriptor.getCharacteristic().getUuid())) {
-						// We have enabled indications for the Service Changed characteristic
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE,
-                                "Indications enabled for " + descriptor.getCharacteristic().getUuid());
-					} else {
-						// We have enabled notifications for this characteristic
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE,
-                                "Notifications enabled for " + descriptor.getCharacteristic().getUuid());
-					}
-				}
-			} else {
-				loge("Descriptor write error: " + status);
-				mError = DfuBaseService.ERROR_CONNECTION_MASK | status;
-			}
-			notifyLock();
-		}
-
-		@Override
-		public void onMtuChanged(final BluetoothGatt gatt, final int mtu, final int status) {
-			if (status == BluetoothGatt.GATT_SUCCESS) {
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "MTU changed to: " + mtu);
-				if (mtu - 3 > mBuffer.length)
-					mBuffer = new byte[mtu - 3]; // Maximum payload size is MTU - 3 bytes
-				logi("MTU changed to: " + mtu);
-			} else {
-				logw("Changing MTU failed: " + status + " (mtu: " + mtu + ")");
-				if (status == 4 /* Invalid PDU */ && mCurrentMtu > 23 && mCurrentMtu - 3 > mBuffer.length) {
-					mBuffer = new byte[mCurrentMtu - 3]; // Maximum payload size is MTU - 3 bytes
-					logi("MTU restored to: " + mCurrentMtu);
-				}
-			}
-			mRequestCompleted = true;
-			notifyLock();
-		}
-
-		@Override
-		public void onPhyUpdate(final BluetoothGatt gatt, final int txPhy, final int rxPhy, final int status) {
-			if (status == BluetoothGatt.GATT_SUCCESS) {
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO,
-                        "PHY updated (TX: " + phyToString(txPhy) + ", RX: " + phyToString(rxPhy) + ")");
-				logi("PHY updated (TX: " + phyToString(txPhy) + ", RX: " + phyToString(rxPhy) + ")");
-			} else {
-				logw("Updating PHY failed: " + status + " (txPhy: " + txPhy + ", rxPhy: " + rxPhy + ")");
-			}
-		}
-
-		protected String parse(final BluetoothGattCharacteristic characteristic) {
-			return parse(characteristic.getValue());
-		}
-
-		protected String parse(final BluetoothGattDescriptor descriptor) {
-			return parse(descriptor.getValue());
-		}
-
-		private String parse(final byte[] data) {
-			if (data == null)
-				return "";
-			final int length = data.length;
-			if (length == 0)
-				return "";
-
-			final char[] out = new char[length * 3 - 1];
-			for (int j = 0; j < length; j++) {
-				int v = data[j] & 0xFF;
-				out[j * 3] = HEX_ARRAY[v >>> 4];
-				out[j * 3 + 1] = HEX_ARRAY[v & 0x0F];
-				if (j != length - 1)
-					out[j * 3 + 2] = '-';
-			}
-			return new String(out);
-		}
-
-		private String phyToString(final int phy) {
-			switch (phy) {
-				case BluetoothDevice.PHY_LE_1M:
-					return "LE 1M";
-				case BluetoothDevice.PHY_LE_2M:
-					return "LE 2M";
-				case BluetoothDevice.PHY_LE_CODED:
-					return "LE Coded";
-				default:
-					return "UNKNOWN (" + phy + ")";
-			}
-		}
-	}
-
-    @SuppressWarnings("unused")
-    BaseDfuImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service) {
-		mService = service;
-		mProgressInfo = service.mProgressInfo;
-		mConnected = true; // the device is connected when impl object it created
-	}
-
-	@Override
-	public void release() {
-		mService = null;
-	}
-
-	@Override
-	public void pause() {
-		mPaused = true;
-	}
-
-	@Override
-	public void resume() {
-		mPaused = false;
-		notifyLock();
-	}
-
-	@Override
-	public void abort() {
-		mPaused = false;
-		mAborted = true;
-		notifyLock();
-	}
-
-	@Override
-	public void onBondStateChanged(final int state) {
-		mRequestCompleted = true;
-		notifyLock();
-	}
-
-	@Override
-	public boolean initialize(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt,
-                              final int fileType,
-                              @NonNull final InputStream firmwareStream,
-                              @Nullable final InputStream initPacketStream)
-            throws DfuException, DeviceDisconnectedException, UploadAbortedException {
-		mGatt = gatt;
-		mFileType = fileType;
-		mFirmwareStream = firmwareStream;
-		mInitPacketStream = initPacketStream;
-
-		final int currentPart = intent.getIntExtra(DfuBaseService.EXTRA_PART_CURRENT, 1);
-		int totalParts = intent.getIntExtra(DfuBaseService.EXTRA_PARTS_TOTAL, 1);
-		mCurrentMtu = intent.getIntExtra(DfuBaseService.EXTRA_CURRENT_MTU, 23);
-
-		// Sending App together with SD or BL is not supported. It must be spilt into two parts.
-		if (fileType > DfuBaseService.TYPE_APPLICATION) {
-			logw("DFU target does not support (SD/BL)+App update, splitting into 2 parts");
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "Sending system components");
-			mFileType &= ~DfuBaseService.TYPE_APPLICATION; // clear application bit
-			totalParts = 2;
-
-			// Set new content type in the ZIP Input Stream and update sizes of images
-			final ArchiveInputStream zhis = (ArchiveInputStream) mFirmwareStream;
-			zhis.setContentType(mFileType);
-		}
-
-		if (currentPart == 2) {
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "Sending application");
-		}
-
-		int size = 0;
-		try {
-		    if (initPacketStream != null) {
-                if (initPacketStream.markSupported()) {
-                    initPacketStream.reset();
-                }
-                size = initPacketStream.available();
-            }
-		} catch (final Exception e) {
-			// ignore
-		}
-		mInitPacketSizeInBytes = size;
-		try {
-			if (firmwareStream.markSupported()) {
-				if (firmwareStream instanceof ArchiveInputStream) {
-					((ArchiveInputStream) firmwareStream).fullReset();
-				} else {
-					firmwareStream.reset();
-				}
-			}
-			size = firmwareStream.available();
-		} catch (final Exception e) {
-			size = 0;
-			// not possible
-		}
-		mImageSizeInBytes = size;
-		mProgressInfo.init(size, currentPart, totalParts);
-
-		// If we are bonded we may want to enable Service Changed characteristic indications.
-		// Note: Sending SC indication on services change was introduced in the SDK 8.0.
-		//       Before, the cache had to be clear manually. This Android lib supports both implementations.
-		// Note: On iOS refreshing services is not available in the API. An app must have Service Change characteristic
-		//       if it intends ever to change its services. In that case on non-bonded devices services will never be cached,
-		//       and on bonded a change is indicated using Service Changed indication. Ergo - Legacy DFU will
-		//       not work by default on iOS with buttonless update on SDKs < 8 on bonded devices. The bootloader must be modified to
-		//       always send the indication when connected.
-
-		// <strike>The requirement of enabling Service Changed indications manually has been fixed on Android 6.
-		// Now the Android enables Service Changed indications automatically after bonding.</strike>
-		// This no longer works in Android 8 and 8.1:
-		// issue: https://github.com/NordicSemiconductor/Android-DFU-Library/issues/112
-		if (gatt.getDevice().getBondState() == BluetoothDevice.BOND_BONDED) {
-			final BluetoothGattService genericAttributeService = gatt.getService(GENERIC_ATTRIBUTE_SERVICE_UUID);
-			if (genericAttributeService != null) {
-				final BluetoothGattCharacteristic serviceChangedCharacteristic = genericAttributeService.getCharacteristic(SERVICE_CHANGED_UUID);
-				if (serviceChangedCharacteristic != null) {
-					// Let's read the current value of the Service Changed CCCD
-					final boolean serviceChangedIndicationsEnabled = isServiceChangedCCCDEnabled();
-
-					if (!serviceChangedIndicationsEnabled)
-						enableCCCD(serviceChangedCharacteristic, INDICATIONS);
-
-					logi("Service Changed indications enabled");
-					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Service Changed indications enabled");
-				}
-			}
-		}
-		return true;
-	}
-
-	void notifyLock() {
-		// Notify waiting thread
-		synchronized (mLock) {
-			mLock.notifyAll();
-		}
-	}
-
-	void waitIfPaused() {
-		try {
-			synchronized (mLock) {
-				while (mPaused)
-					mLock.wait();
-			}
-		} catch (final InterruptedException e) {
-			loge("Sleeping interrupted", e);
-		}
-	}
-
-	/**
-	 * Enables or disables the notifications for given characteristic.
-     * This method is SYNCHRONOUS and wait until the
-	 * {@link android.bluetooth.BluetoothGattCallback#onDescriptorWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattDescriptor, int)}
-     * will be called or the device gets disconnected.
-	 * If connection state will change, or an error will occur, an exception will be thrown.
-	 *
-	 * @param characteristic the characteristic to enable or disable notifications for.
-	 * @param type           {@link #NOTIFICATIONS} or {@link #INDICATIONS}.
-     * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
-     *                                     the transmission.
-     * @throws DfuException                Thrown if DFU error occur.
-     * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
-	 */
-	void enableCCCD(@NonNull final BluetoothGattCharacteristic characteristic, final int type)
-            throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-		final BluetoothGatt gatt = mGatt;
-		final String debugString = type == NOTIFICATIONS ? "notifications" : "indications";
-		if (!mConnected)
-			throw new DeviceDisconnectedException("Unable to set " + debugString + " state: device disconnected");
-		if (mAborted)
-			throw new UploadAbortedException();
-
-		mReceivedData = null;
-		mError = 0;
-		final BluetoothGattDescriptor descriptor = characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG);
-		boolean cccdEnabled = descriptor.getValue() != null && descriptor.getValue().length == 2 && descriptor.getValue()[0] > 0 && descriptor.getValue()[1] == 0;
-		if (cccdEnabled)
-			return;
-
-		logi("Enabling " + debugString + "...");
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE,
-                "Enabling " + debugString + " for " + characteristic.getUuid());
-
-		// enable notifications locally
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG,
-                "gatt.setCharacteristicNotification(" + characteristic.getUuid() + ", true)");
-		gatt.setCharacteristicNotification(characteristic, true);
-
-		// enable notifications on the device
-		descriptor.setValue(type == NOTIFICATIONS ? BluetoothGattDescriptor.ENABLE_NOTIFICATION_VALUE : BluetoothGattDescriptor.ENABLE_INDICATION_VALUE);
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG,
-                "gatt.writeDescriptor(" + descriptor.getUuid() + (type == NOTIFICATIONS ? ", value=0x01-00)" : ", value=0x02-00)"));
-		gatt.writeDescriptor(descriptor);
-
-		// We have to wait until device receives a response or an error occur
-		try {
-			synchronized (mLock) {
-				while ((!cccdEnabled && mConnected && mError == 0) || mPaused) {
-					mLock.wait();
-					// Check the value of the CCCD
-					cccdEnabled = descriptor.getValue() != null
-							   && descriptor.getValue().length == 2
-							   && descriptor.getValue()[0] > 0
-							   && descriptor.getValue()[1] == 0;
-				}
-			}
-		} catch (final InterruptedException e) {
-			loge("Sleeping interrupted", e);
-		}
-		if (!mConnected)
-			throw new DeviceDisconnectedException("Unable to set " + debugString + " state: device disconnected");
-		if (mError != 0)
-			throw new DfuException("Unable to set " + debugString + " state", mError);
-	}
-
-	/**
-	 * Reads the value of the Service Changed Client Characteristic Configuration descriptor (CCCD).
-	 *
-	 * @return <code>true</code> if Service Changed CCCD is enabled and set to INDICATE.
-     * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
-     *                                     the transmission.
-     * @throws DfuException                Thrown if DFU error occur.
-     * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
-	 */
-	private boolean isServiceChangedCCCDEnabled()
-            throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-		if (!mConnected)
-			throw new DeviceDisconnectedException("Unable to read Service Changed CCCD: device disconnected");
-		if (mAborted)
-			throw new UploadAbortedException();
-
-		// If the Service Changed characteristic or the CCCD is not available we return false.
-		final BluetoothGatt gatt = mGatt;
-		final BluetoothGattService genericAttributeService = gatt.getService(GENERIC_ATTRIBUTE_SERVICE_UUID);
-		if (genericAttributeService == null)
-			return false;
-
-		final BluetoothGattCharacteristic serviceChangedCharacteristic = genericAttributeService.getCharacteristic(SERVICE_CHANGED_UUID);
-		if (serviceChangedCharacteristic == null)
-			return false;
-
-		final BluetoothGattDescriptor descriptor = serviceChangedCharacteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG);
-		if (descriptor == null)
-			return false;
-
-		mRequestCompleted = false;
-		mError = 0;
-
-		logi("Reading Service Changed CCCD value...");
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Reading Service Changed CCCD value...");
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.readDescriptor(" + descriptor.getUuid() + ")");
-		gatt.readDescriptor(descriptor);
-
-		// We have to wait until device receives a response or an error occur
-		try {
-			synchronized (mLock) {
-				while ((!mRequestCompleted && mConnected && mError == 0) || mPaused)
-					mLock.wait();
-			}
-		} catch (final InterruptedException e) {
-			loge("Sleeping interrupted", e);
-		}
-		if (!mConnected)
-			throw new DeviceDisconnectedException("Unable to read Service Changed CCCD: device disconnected");
-		if (mError != 0)
-			throw new DfuException("Unable to read Service Changed CCCD", mError);
-
-		// Return true if the CCCD value is
-		return descriptor.getValue() != null && descriptor.getValue().length == 2
-				&& descriptor.getValue()[0] == BluetoothGattDescriptor.ENABLE_INDICATION_VALUE[0]
-				&& descriptor.getValue()[1] == BluetoothGattDescriptor.ENABLE_INDICATION_VALUE[1];
-	}
-
-	/**
-	 * Writes the operation code to the characteristic.
-     * This method is SYNCHRONOUS and wait until the
-	 * {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)}
-     * will be called or the device gets disconnected.
-     * If connection state will change, or an error will occur, an exception will be thrown.
-	 *
-	 * @param characteristic the characteristic to write to. Should be the DFU CONTROL POINT
-	 * @param value          the value to write to the characteristic
-	 * @param reset          whether the command trigger restarting the device
-     * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
-     *                                     the transmission.
-     * @throws DfuException                Thrown if DFU error occur.
-     * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
-	 */
-	void writeOpCode(@NonNull final BluetoothGattCharacteristic characteristic, @NonNull final byte[] value, final boolean reset)
-            throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-		if (mAborted)
-			throw new UploadAbortedException();
-		mReceivedData = null;
-		mError = 0;
-		mRequestCompleted = false;
-		/*
-		 * Sending a command that will make the DFU target to reboot may cause an error 133
-		 * (0x85 - Gatt Error). If so, with this flag set, the error will not be shown to the user
-		 * as the peripheral is disconnected anyway.
-		 * See: mGattCallback#onCharacteristicWrite(...) method
-		 */
-		mResetRequestSent = reset;
-
-		characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_DEFAULT);
-		characteristic.setValue(value);
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Writing to characteristic " + characteristic.getUuid());
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.writeCharacteristic(" + characteristic.getUuid() + ")");
-		mGatt.writeCharacteristic(characteristic);
-
-		// We have to wait for confirmation
-		try {
-			synchronized (mLock) {
-				while ((!mRequestCompleted && mConnected && mError == 0) || mPaused)
-					mLock.wait();
-			}
-		} catch (final InterruptedException e) {
-			loge("Sleeping interrupted", e);
-		}
-		if (!mResetRequestSent && !mConnected)
-			throw new DeviceDisconnectedException("Unable to write Op Code " + value[0] + ": device disconnected");
-		if (!mResetRequestSent && mError != 0)
-			throw new DfuException("Unable to write Op Code " + value[0], mError);
-	}
-
-	/**
-	 * Creates bond to the device. Works on all APIs since 18th (Android 4.3).
-	 * This method will only be called in this library after bond information was removed.
-	 *
-	 * @return true if bonding has started, false otherwise.
-	 */
-	@SuppressWarnings("UnusedReturnValue")
-	boolean createBond() {
-		final BluetoothDevice device = mGatt.getDevice();
-
-		boolean result;
-		mRequestCompleted = false;
-
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Starting pairing...");
-		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.getDevice().createBond()");
-			result = device.createBond();
-		} else {
-			result = createBondApi18(device);
-		}
-
-		// We have to wait until device is bounded
-		try {
-			synchronized (mLock) {
-				while (result && !mRequestCompleted && !mAborted)
-					mLock.wait();
-			}
-		} catch (final InterruptedException e) {
-			loge("Sleeping interrupted", e);
-		}
-		return result;
-	}
-
-	/**
-	 * A method that creates the bond to given device on API lower than Android 5.
-	 *
-	 * @param device the target device
-	 * @return false if bonding failed (no hidden createBond() method in BluetoothDevice, or this method returned false
-	 */
-	private boolean createBondApi18(@NonNull final BluetoothDevice device) {
-		/*
-		 * There is a createBond() method in BluetoothDevice class but for now it's hidden.
-		 * We will call it using reflections. It has been revealed in KitKat (Api19)
-		 */
-		try {
-			final Method createBond = device.getClass().getMethod("createBond");
-            mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.getDevice().createBond() (hidden)");
-			//noinspection ConstantConditions
-			return (Boolean) createBond.invoke(device);
-		} catch (final Exception e) {
-			Log.w(TAG, "An exception occurred while creating bond", e);
-		}
-		return false;
-	}
-
-	/**
-	 * Removes the bond information for the given device.
-	 *
-	 * @return <code>true</code> if operation succeeded, <code>false</code> otherwise
-	 */
-    @SuppressWarnings("UnusedReturnValue")
-    boolean removeBond() {
-		final BluetoothDevice device = mGatt.getDevice();
-		if (device.getBondState() == BluetoothDevice.BOND_NONE)
-			return true;
-
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Removing bond information...");
-		boolean result = false;
-		/*
-		 * There is a removeBond() method in BluetoothDevice class but for now it's hidden.
-		 * We will call it using reflections.
-		 */
-		try {
-            //noinspection JavaReflectionMemberAccess
-            final Method removeBond = device.getClass().getMethod("removeBond");
-            mRequestCompleted = false;
-            mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.getDevice().removeBond() (hidden)");
-			//noinspection ConstantConditions
-			result = (Boolean) removeBond.invoke(device);
-
-            // We have to wait until device is unbounded
-            try {
-                synchronized (mLock) {
-                    while (!mRequestCompleted && !mAborted)
-                        mLock.wait();
-                }
-            } catch (final InterruptedException e) {
-                loge("Sleeping interrupted", e);
-            }
-		} catch (final Exception e) {
-			Log.w(TAG, "An exception occurred while removing bond information", e);
-		}
-		return result;
-	}
-
-	/**
-	 * Returns whether the device is bonded.
-	 *
-	 * @return true if the device is bonded, false if not bonded or in process of bonding.
-	 */
-	boolean isBonded() {
-		final BluetoothDevice device = mGatt.getDevice();
-		return device.getBondState() == BluetoothDevice.BOND_BONDED;
-	}
-
-	/**
-	 * Requests given MTU. This method is only supported on Android Lollipop or newer versions.
-	 * Only DFU from SDK 14.1 or newer supports MTU > 23.
-	 *
-	 * @param mtu new MTU to be requested.
-	 */
-	@RequiresApi(api = Build.VERSION_CODES.LOLLIPOP)
-	void requestMtu(@IntRange(from = 0, to = 517) final int mtu)
-            throws DeviceDisconnectedException, UploadAbortedException {
-		if (mAborted)
-			throw new UploadAbortedException();
-		mRequestCompleted = false;
-
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Requesting new MTU...");
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.requestMtu(" + mtu + ")");
-		if (!mGatt.requestMtu(mtu))
-			return;
-
-		// We have to wait until the MTU exchange finishes
-		try {
-			synchronized (mLock) {
-				while ((!mRequestCompleted && mConnected && mError == 0) || mPaused)
-					mLock.wait();
-			}
-		} catch (final InterruptedException e) {
-			loge("Sleeping interrupted", e);
-		}
-		if (!mConnected)
-			throw new DeviceDisconnectedException("Unable to read Service Changed CCCD: device disconnected");
-	}
-
-	/**
-	 * Waits until the notification will arrive. Returns the data returned by the notification.
-     * This method will block the thread until response is not ready or the device gets disconnected.
-     * If connection state will change, or an error will occur, an exception will be thrown.
-	 *
-	 * @return the value returned by the Control Point notification
-     * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
-     *                                     the transmission.
-     * @throws DfuException                Thrown if DFU error occur.
-     * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
-	 */
-	byte[] readNotificationResponse()
-            throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-		// do not clear the mReceiveData here. The response might already be obtained. Clear it in write request instead.
-		try {
-			synchronized (mLock) {
-				while ((mReceivedData == null && mConnected && mError == 0 && !mAborted) || mPaused)
-					mLock.wait();
-			}
-		} catch (final InterruptedException e) {
-			loge("Sleeping interrupted", e);
-		}
-		if (mAborted)
-			throw new UploadAbortedException();
-		if (!mConnected)
-			throw new DeviceDisconnectedException("Unable to write Op Code: device disconnected");
-		if (mError != 0)
-			throw new DfuException("Unable to write Op Code", mError);
-		return mReceivedData;
-	}
-
-	/**
-	 * Restarts the service based on the given intent. If parameter set this method will also scan for
-	 * an advertising bootloader that has address equal or incremented by 1 to the current one.
-	 *
-	 * @param intent            the intent to be started as a service
-	 * @param scanForBootloader true to scan for advertising bootloader, false to keep the same address
-	 */
-	void restartService(@NonNull final Intent intent, final boolean scanForBootloader) {
-		String newAddress = null;
-		if (scanForBootloader) {
-			final long delay = intent.getLongExtra(DfuBaseService.EXTRA_SCAN_DELAY, 0);
-			final long timeout = intent.getLongExtra(DfuBaseService.EXTRA_SCAN_TIMEOUT, DfuServiceInitiator.DEFAULT_SCAN_TIMEOUT);
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Scanning for the DFU Bootloader... (timeout " + timeout + " ms)");
-			if (delay > 0)
-				mService.waitFor(delay);
-			newAddress = BootloaderScannerFactory.getScanner(mGatt.getDevice().getAddress()).searchUsing(mService.getDeviceSelector(), timeout);
-			logi("Scanning for new address finished with: " + newAddress);
-			if (newAddress != null)
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "DFU Bootloader found with address " + newAddress);
-			else {
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "DFU Bootloader not found. Trying the same address...");
-			}
-		}
-
-		if (newAddress != null)
-			intent.putExtra(DfuBaseService.EXTRA_DEVICE_ADDRESS, newAddress);
-
-		// Reset the DFU attempt counter
-		intent.putExtra(DfuBaseService.EXTRA_DFU_ATTEMPT, 0);
-
-		mService.startService(intent);
-	}
-
-	protected String parse(@Nullable final byte[] data) {
-		if (data == null)
-			return "";
-
-		final int length = data.length;
-		if (length == 0)
-			return "";
-
-		final char[] out = new char[length * 3 - 1];
-		for (int j = 0; j < length; j++) {
-			int v = data[j] & 0xFF;
-			out[j * 3] = HEX_ARRAY[v >>> 4];
-			out[j * 3 + 1] = HEX_ARRAY[v & 0x0F];
-			if (j != length - 1)
-				out[j * 3 + 2] = '-';
-		}
-		return new String(out);
-	}
-
-	void loge(final String message) {
-		Log.e(TAG, message);
-	}
-
-	void loge(final String message, final Throwable e) {
-		Log.e(TAG, message, e);
-	}
-
-	void logw(final String message) {
-		if (DfuBaseService.DEBUG)
-			Log.w(TAG, message);
-	}
-
-	void logi(final String message) {
-		if (DfuBaseService.DEBUG)
-			Log.i(TAG, message);
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ButtonlessDfuImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ButtonlessDfuImpl.java
deleted file mode 100644
index 0089048..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ButtonlessDfuImpl.java
+++ /dev/null
@@ -1,197 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.bluetooth.BluetoothGatt;
-import android.bluetooth.BluetoothGattCharacteristic;
-import android.content.Intent;
-
-import java.util.Locale;
-
-import androidx.annotation.NonNull;
-import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
-import no.nordicsemi.android.dfu.internal.exception.DfuException;
-import no.nordicsemi.android.dfu.internal.exception.RemoteDfuException;
-import no.nordicsemi.android.dfu.internal.exception.UnknownResponseException;
-import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
-import no.nordicsemi.android.error.SecureDfuError;
-
-/**
- * A base class for buttonless service implementations made for Secure and in the future for
- * Non-Secure DFU.
- */
-/* package */ abstract class ButtonlessDfuImpl extends BaseButtonlessDfuImpl {
-
-	private static final int DFU_STATUS_SUCCESS = 1;
-
-	private static final int OP_CODE_ENTER_BOOTLOADER_KEY = 0x01;
-	private static final int OP_CODE_RESPONSE_CODE_KEY = 0x20;
-	private static final byte[] OP_CODE_ENTER_BOOTLOADER = new byte[]{OP_CODE_ENTER_BOOTLOADER_KEY};
-
-	ButtonlessDfuImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service) {
-		super(intent, service);
-	}
-
-	/**
-	 * This method should return the type of the response received from the device after sending
-	 * Enable Dfu command. Should be one of {@link #NOTIFICATIONS} or {@link #INDICATIONS}.
-	 *
-	 * @return Response type.
-	 */
-	protected abstract int getResponseType();
-
-	/**
-	 * Returns the buttonless characteristic.
-	 *
-	 * @return The characteristic used to trigger buttonless jump to bootloader mode.
-	 */
-	protected abstract BluetoothGattCharacteristic getButtonlessDfuCharacteristic();
-
-	/**
-	 * This method should return {@code true} if the bootloader is expected to start advertising
-     * with address incremented by 1.
-	 *
-	 * @return True if the bootloader may advertise with address +1, false if it will keep
-	 * the same device address.
-	 */
-	protected abstract boolean shouldScanForBootloader();
-
-	@Override
-	public void performDfu(@NonNull final Intent intent)
-            throws DfuException, DeviceDisconnectedException, UploadAbortedException {
-		mProgressInfo.setProgress(DfuBaseService.PROGRESS_STARTING);
-
-		// Add one second delay to avoid the traffic jam before the DFU mode is enabled
-		// Related:
-		//   issue:        https://github.com/NordicSemiconductor/Android-DFU-Library/issues/10
-		//   pull request: https://github.com/NordicSemiconductor/Android-DFU-Library/pull/12
-		mService.waitFor(1000);
-		// End
-
-		final BluetoothGatt gatt = mGatt;
-
-		// The service is connected to the application, not to the bootloader
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "Application with buttonless update found");
-
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Jumping to the DFU Bootloader...");
-
-		final BluetoothGattCharacteristic characteristic = getButtonlessDfuCharacteristic();
-		// Enable notifications or indications
-		final int type = getResponseType();
-		enableCCCD(characteristic, getResponseType());
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, (type == INDICATIONS ? "Indications" : "Notifications") + " enabled");
-
-		// Wait a second here before going further
-		// Related:
-		//   pull request: https://github.com/NordicSemiconductor/Android-DFU-Library/pull/11
-		mService.waitFor(1000);
-		// End
-
-		try {
-			// Send 'enter bootloader command'
-			mProgressInfo.setProgress(DfuBaseService.PROGRESS_ENABLING_DFU_MODE);
-			logi("Sending Enter Bootloader (Op Code = 1)");
-			writeOpCode(characteristic, OP_CODE_ENTER_BOOTLOADER, true);
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Enter bootloader sent (Op Code = 1)");
-
-			byte[] response;
-			try {
-				// There may be a race condition here. The peripheral should send a notification
-                // and disconnect gracefully immediately after that, but the onConnectionStateChange
-                // event may be handled before this method ends. Also, sometimes the notification
-                // is not received at all.
-				response = readNotificationResponse();
-			} catch (final DeviceDisconnectedException e) {
-				// The device disconnect event was handled before the method finished,
-				// or the notification wasn't received. We behave as if we received status success.
-				response = mReceivedData;
-			}
-
-			if (response != null) {
-				/*
-				 * The response received from the DFU device contains:
-				 * +---------+--------+----------------------------------------------------+
-				 * | byte no | value  | description                                        |
-				 * +---------+--------+----------------------------------------------------+
-				 * | 0       | 0x20   | Response code                                      |
-				 * | 1       | 0x01   | The Op Code of a request that this response is for |
-				 * | 2       | STATUS | Status code                                        |
-				 * +---------+--------+----------------------------------------------------+
-				 */
-				final int status = getStatusCode(response, OP_CODE_ENTER_BOOTLOADER_KEY);
-				logi("Response received (Op Code = " + response[1] + ", Status = " + status + ")");
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION,
-                        "Response received (Op Code = " + response[1] + ", Status = " + status + ")");
-				if (status != DFU_STATUS_SUCCESS)
-					throw new RemoteDfuException("Device returned error after sending Enter Bootloader", status);
-				// The device will disconnect and now reset. Some devices don't disconnect gracefully,
-				// but reset instead. In that case, Android would assume disconnection after
-				// "supervision timeout" seconds, which may be 5 more seconds. If the device will
-				// use a different address in bootloader mode, there is no reason to wait for that.
-				// The library will immediately start scanning for the device advertising in
-				// bootloader mode and connect to it.
-				if (!shouldScanForBootloader()) {
-					// However, if the device is expected to use the same address, we need to wait
-					// for the disconnection. Otherwise, a new connectGatt would reconnect before
-					// disconnection and subsequent operations would fail.
-					mService.waitUntilDisconnected();
-				}
-			} else {
-				logi("Device disconnected before receiving notification");
-			}
-
-			if (!shouldScanForBootloader()) {
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "Disconnected by the remote device");
-			}
-			finalize(intent, false, shouldScanForBootloader());
-		} catch (final UnknownResponseException e) {
-			final int error = DfuBaseService.ERROR_INVALID_RESPONSE;
-			loge(e.getMessage());
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, e.getMessage());
-			mService.terminateConnection(gatt, error);
-		} catch (final RemoteDfuException e) {
-			final int error = DfuBaseService.ERROR_REMOTE_TYPE_SECURE_BUTTONLESS | e.getErrorNumber();
-			loge(e.getMessage());
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, String.format(Locale.US,
-                    "Remote DFU error: %s", SecureDfuError.parseButtonlessError(error)));
-			mService.terminateConnection(gatt, error | DfuBaseService.ERROR_REMOTE_MASK);
-		}
-	}
-
-	/**
-	 * Checks whether the response received is valid and returns the status code.
-	 *
-	 * @param response the response received from the DFU device.
-	 * @param request  the expected Op Code.
-	 * @return The status code.
-	 * @throws UnknownResponseException if response was not valid.
-	 */
-	@SuppressWarnings("SameParameterValue")
-	private int getStatusCode(final byte[] response, final int request) throws UnknownResponseException {
-		if (response == null || response.length < 3 || response[0] != OP_CODE_RESPONSE_CODE_KEY || response[1] != request ||
-				(response[2] != DFU_STATUS_SUCCESS && response[2] != SecureDfuError.BUTTONLESS_ERROR_OP_CODE_NOT_SUPPORTED
-                        && response[2] != SecureDfuError.BUTTONLESS_ERROR_OPERATION_FAILED))
-			throw new UnknownResponseException("Invalid response received", response, OP_CODE_RESPONSE_CODE_KEY, request);
-		return response[2];
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ButtonlessDfuWithBondSharingImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ButtonlessDfuWithBondSharingImpl.java
deleted file mode 100644
index 3f63d43..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ButtonlessDfuWithBondSharingImpl.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.bluetooth.BluetoothGatt;
-import android.bluetooth.BluetoothGattCharacteristic;
-import android.bluetooth.BluetoothGattService;
-import android.content.Intent;
-
-import java.util.UUID;
-
-import androidx.annotation.NonNull;
-import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
-import no.nordicsemi.android.dfu.internal.exception.DfuException;
-import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
-
-/**
- * This implementation handles the secure buttonless DFU service that will be implemented in
- * SDK 14 or later.
- * <p>
- * This service requires the device to be paired, so that only a trusted phone can switch it to
- * bootloader mode. The bond information will be shared to the bootloader and it will use the
- * same device address when in DFU mode and the connection will be encrypted.
- */
-/* package */ class ButtonlessDfuWithBondSharingImpl extends ButtonlessDfuImpl {
-	/**
-	 * The UUID of the Secure DFU service from SDK 12.
-	 */
-	static final UUID DEFAULT_BUTTONLESS_DFU_SERVICE_UUID = SecureDfuImpl.DEFAULT_DFU_SERVICE_UUID;
-	/**
-	 * The UUID of the Secure Buttonless DFU characteristic with bond sharing from SDK 14 or newer.
-	 */
-	static final UUID DEFAULT_BUTTONLESS_DFU_UUID = new UUID(0x8EC90004F3154F60L, 0x9FB8838830DAEA50L);
-
-	static UUID BUTTONLESS_DFU_SERVICE_UUID = DEFAULT_BUTTONLESS_DFU_SERVICE_UUID;
-	static UUID BUTTONLESS_DFU_UUID = DEFAULT_BUTTONLESS_DFU_UUID;
-
-	private BluetoothGattCharacteristic mButtonlessDfuCharacteristic;
-
-	ButtonlessDfuWithBondSharingImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service) {
-		super(intent, service);
-	}
-
-	@Override
-	public boolean isClientCompatible(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt) {
-		final BluetoothGattService dfuService = gatt.getService(BUTTONLESS_DFU_SERVICE_UUID);
-		if (dfuService == null)
-			return false;
-		final BluetoothGattCharacteristic characteristic = dfuService.getCharacteristic(BUTTONLESS_DFU_UUID);
-		if (characteristic == null || characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG) == null)
-			return false;
-		mButtonlessDfuCharacteristic = characteristic;
-		return true;
-	}
-
-	@Override
-	protected int getResponseType() {
-		return INDICATIONS;
-	}
-
-	@Override
-	protected BluetoothGattCharacteristic getButtonlessDfuCharacteristic() {
-		return mButtonlessDfuCharacteristic;
-	}
-
-	@Override
-	protected boolean shouldScanForBootloader() {
-		return false;
-	}
-
-	@Override
-	public void performDfu(@NonNull final Intent intent)
-			throws DfuException, DeviceDisconnectedException, UploadAbortedException {
-		logi("Buttonless service with bond sharing found -> SDK 14 or newer");
-		if (!isBonded()) {
-			logw("Device is not paired, cancelling DFU");
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "Device is not bonded");
-			mService.terminateConnection(mGatt, DfuBaseService.ERROR_DEVICE_NOT_BONDED);
-			return;
-		}
-		// In Secure DFU with Bond Sharing the bond information should not be removed
-		intent.putExtra(DfuBaseService.EXTRA_KEEP_BOND, true);
-		intent.putExtra(DfuBaseService.EXTRA_RESTORE_BOND, false);
-
-		super.performDfu(intent);
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ButtonlessDfuWithoutBondSharingImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ButtonlessDfuWithoutBondSharingImpl.java
deleted file mode 100644
index 897dddd..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ButtonlessDfuWithoutBondSharingImpl.java
+++ /dev/null
@@ -1,108 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.bluetooth.BluetoothGatt;
-import android.bluetooth.BluetoothGattCharacteristic;
-import android.bluetooth.BluetoothGattService;
-import android.content.Intent;
-
-import java.util.UUID;
-
-import androidx.annotation.NonNull;
-import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
-import no.nordicsemi.android.dfu.internal.exception.DfuException;
-import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
-
-/**
- * This implementation handles 2 services:
- * - a non-secure buttonless DFU service introduced in SDK 13
- * - a secure buttonless DFU service that will be implemented in some next SDK (14 or later)
- * <p>
- * An application that supports one of those services should have the Secure DFU Service with one
- * of those characteristic inside.
- * <p>
- * The non-secure one does not share the bond information to the bootloader, and the bootloader
- * starts advertising with address +1 after the jump. It may be used by a bonded devices
- * (it's even recommended, as it prevents from DoS attack), but the connection with the bootloader
- * will not be encrypted (in Secure DFU it is not an issue as the firmware itself is signed).
- * When implemented on a non-bonded device it is important to understand, that anyone could
- * connect to the device and switch it to DFU mode preventing the device from normal usage.
- * <p>
- * The secure one requires the device to be paired so that only the trusted phone can switch it
- * to bootloader mode. The bond information will be shared to the bootloader so it will use the
- * same device address when in DFU mode and the connection will be encrypted.
- */
-/* package */ class ButtonlessDfuWithoutBondSharingImpl extends ButtonlessDfuImpl {
-	/** The UUID of the Secure DFU service from SDK 12. */
-	static final UUID DEFAULT_BUTTONLESS_DFU_SERVICE_UUID = SecureDfuImpl.DEFAULT_DFU_SERVICE_UUID;
-	/** The UUID of the Secure Buttonless DFU characteristic without bond sharing from SDK 13. */
-	static final UUID DEFAULT_BUTTONLESS_DFU_UUID = new UUID(0x8EC90003F3154F60L, 0x9FB8838830DAEA50L);
-
-	static UUID BUTTONLESS_DFU_SERVICE_UUID = DEFAULT_BUTTONLESS_DFU_SERVICE_UUID;
-	static UUID BUTTONLESS_DFU_UUID         = DEFAULT_BUTTONLESS_DFU_UUID;
-
-	private BluetoothGattCharacteristic mButtonlessDfuCharacteristic;
-
-	ButtonlessDfuWithoutBondSharingImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service) {
-		super(intent, service);
-	}
-
-	@Override
-	public boolean isClientCompatible(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt) {
-		final BluetoothGattService dfuService = gatt.getService(BUTTONLESS_DFU_SERVICE_UUID);
-		if (dfuService == null)
-			return false;
-		final BluetoothGattCharacteristic characteristic = dfuService.getCharacteristic(BUTTONLESS_DFU_UUID);
-		if (characteristic == null || characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG) == null)
-			return false;
-		mButtonlessDfuCharacteristic = characteristic;
-		return true;
-	}
-
-	@Override
-	protected int getResponseType() {
-		return INDICATIONS;
-	}
-
-	@Override
-	protected BluetoothGattCharacteristic getButtonlessDfuCharacteristic() {
-		return mButtonlessDfuCharacteristic;
-	}
-
-	@Override
-	protected boolean shouldScanForBootloader() {
-		return true;
-	}
-
-	@Override
-	public void performDfu(@NonNull final Intent intent)
-			throws DfuException, DeviceDisconnectedException, UploadAbortedException {
-		logi("Buttonless service without bond sharing found -> SDK 13 or newer");
-		if (isBonded()) {
-			logw("Device is paired! Use Buttonless DFU with Bond Sharing instead (SDK 14 or newer)");
-		}
-
-		super.performDfu(intent);
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuBaseService.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuBaseService.java
deleted file mode 100644
index 04b2336..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuBaseService.java
+++ /dev/null
@@ -1,2060 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.annotation.SuppressLint;
-import android.app.Activity;
-import android.app.IntentService;
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.bluetooth.BluetoothAdapter;
-import android.bluetooth.BluetoothDevice;
-import android.bluetooth.BluetoothGatt;
-import android.bluetooth.BluetoothGattCallback;
-import android.bluetooth.BluetoothGattCharacteristic;
-import android.bluetooth.BluetoothGattDescriptor;
-import android.bluetooth.BluetoothManager;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.content.SharedPreferences;
-import android.database.Cursor;
-import android.graphics.Color;
-import android.net.Uri;
-import android.os.Build;
-import android.os.SystemClock;
-import android.preference.PreferenceManager;
-import android.provider.MediaStore;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.core.app.NotificationCompat;
-import androidx.localbroadcastmanager.content.LocalBroadcastManager;
-import android.util.Log;
-
-import java.io.ByteArrayInputStream;
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.lang.reflect.Method;
-import java.util.Locale;
-
-import no.nordicsemi.android.dfu.internal.ArchiveInputStream;
-import no.nordicsemi.android.dfu.internal.HexInputStream;
-import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
-import no.nordicsemi.android.dfu.internal.exception.DfuException;
-import no.nordicsemi.android.dfu.internal.exception.SizeValidationException;
-import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
-import no.nordicsemi.android.error.GattError;
-
-/**
- * The DFU Service provides full support for Over-the-Air (OTA) Device Firmware Update (DFU)
- * by Nordic Semiconductor.
- * With the Soft Device 7.0.0+ it allows to upload a new Soft Device, new Bootloader and a
- * new Application. For older soft devices only the Application update is supported.
- * <p>
- * To run the service to your application extend it in your project and overwrite the missing method.
- * Remember to add your service class to the AndroidManifest.xml file.
- * <p>
- * The {@link DfuServiceInitiator} object should be used to start the DFU Service.
- * <pre>
- * final DfuServiceInitiator starter = new DfuServiceInitiator(mSelectedDevice.getAddress())
- * 		.setDeviceName(mSelectedDevice.getName())
- * 		.setKeepBond(keepBond)
- * 		.setZip(mFileStreamUri, mFilePath) // where one, URI or path, should be null
- *		.start(this, DfuService.class);
- * </pre>
- * <p>
- * You may register the progress and log listeners using the {@link DfuServiceListenerHelper}
- * helper class. See {@link DfuProgressListener} and {@link DfuLogListener} for more information.
- * <p>
- * The service will show its progress on the notification bar and will send local broadcasts to the
- * application.
- */
-@SuppressLint("MissingPermission")
-@SuppressWarnings("deprecation")
-public abstract class DfuBaseService extends IntentService implements DfuProgressInfo.ProgressListener {
-	private static final String TAG = "DfuBaseService";
-
-	/* package */ static boolean DEBUG = false;
-
-	public static final int NOTIFICATION_ID = 283; // a random number
-	public static final String NOTIFICATION_CHANNEL_DFU = "dfu";
-
-	/**
-	 * The address of the device to update.
-	 */
-	public static final String EXTRA_DEVICE_ADDRESS = "no.nordicsemi.android.dfu.extra.EXTRA_DEVICE_ADDRESS";
-	/**
-	 * The optional device name. This name will be shown in the notification.
-	 */
-	public static final String EXTRA_DEVICE_NAME = "no.nordicsemi.android.dfu.extra.EXTRA_DEVICE_NAME";
-	/**
-	 * A boolean indicating whether to disable the progress notification in the status bar.
-	 * Defaults to false.
-	 */
-	public static final String EXTRA_DISABLE_NOTIFICATION = "no.nordicsemi.android.dfu.extra.EXTRA_DISABLE_NOTIFICATION";
-	/**
-	 * A boolean indicating whether the DFU service should be set as a foreground service.
-	 * It is recommended to have it as a background service at least on Android Oreo or newer as
-	 * the background service will be killed by the system few moments after the user closed the
-	 * foreground app.
-	 * <p>
-	 * Read more here: <a href="https://developer.android.com/about/versions/oreo/background.html">https://developer.android.com/about/versions/oreo/background.html</a>
-	 */
-	public static final String EXTRA_FOREGROUND_SERVICE = "no.nordicsemi.android.dfu.extra.EXTRA_FOREGROUND_SERVICE";
-	/**
-	 * An extra private field indicating which reconnection attempt is being performed.
-	 * In case of error 133 the service will retry to connect 2 more times.
-	 */
-	private static final String EXTRA_RECONNECTION_ATTEMPT = "no.nordicsemi.android.dfu.extra.EXTRA_RECONNECTION_ATTEMPT";
-	/**
-	 * An extra private field indicating which DFU attempt is being performed.
-	 * If the target device will disconnect for some unknown reason during DFU, the service will
-	 * retry to connect and continue. In case of Legacy DFU it will reconnect and restart process.
-	 */
-	/* package */ static final String EXTRA_DFU_ATTEMPT = "no.nordicsemi.android.dfu.extra.EXTRA_DFU_ATTEMPT";
-	/**
-	 * Maximum number of DFU attempts. Default value is 0.
-	 */
-	public static final String EXTRA_MAX_DFU_ATTEMPTS = "no.nordicsemi.android.dfu.extra.EXTRA_MAX_DFU_ATTEMPTS";
-	/**
-	 * If the new firmware (application) does not share the bond information with the old one,
-	 * the bond information is lost. Set this flag to <code>true</code> to make the service create
-	 * new bond with the new application when the upload is done (and remove the old one).
-	 * When set to <code>false</code> (default), the DFU service assumes that the LTK is shared
-	 * between them. Note: currently it is not possible to remove the old bond without creating
-	 * a new one so if your old application supported bonding while the new one does not you have
-	 * to modify the source code yourself.
-	 * <p>
-	 * In case of updating the soft device the application is always removed together with the
-	 * bond information.
-	 * <p>
-	 * Search for occurrences of EXTRA_RESTORE_BOND in this file to check the implementation and
-	 * get more details.
-	 * <p>
-	 * This flag is ignored when Secure DFU Buttonless Service is used.
-	 * It will keep or will not restore the bond depending on the Buttonless service type.
-	 */
-	public static final String EXTRA_RESTORE_BOND = "no.nordicsemi.android.dfu.extra.EXTRA_RESTORE_BOND";
-	/**
-	 * This flag indicated whether the bond information should be kept or removed after an upgrade
-	 * of the Application. If an application is being updated on a bonded device with the DFU
-	 * Bootloader that has been configured to preserve the bond information for the new application,
-	 * set it to <code>true</code>.
-	 * <p>
-	 * By default the Legacy DFU Bootloader clears the whole application's memory. It may be,
-	 * however, configured in the \Nordic\nrf51\components\libraries\bootloader_dfu\dfu_types.h
-	 * file (sdk 11, line 76: <code>#define DFU_APP_DATA_RESERVED 0x0000</code>) to preserve some pages.
-	 * The BLE_APP_HRM_DFU sample app stores the LTK and System Attributes in the first
-	 * two pages, so in order to preserve the bond information this value should be changed to
-	 * 0x0800 or more. For Secure DFU this value is by default set to 3 pages.
-	 * When those data are preserved, the new Application will notify the app with the
-	 * Service Changed indication when launched for the first time. Otherwise this service will
-	 * remove the bond information from the phone and force to refresh the device cache
-	 * (see {@link #refreshDeviceCache(android.bluetooth.BluetoothGatt, boolean)}).
-	 * <p>
-	 * In contrast to {@link #EXTRA_RESTORE_BOND} this flag will not remove the old bonding and
-	 * recreate a new one, but will keep the bond information untouched.
-	 * <p>
-	 * The default value of this flag is <code>false</code>.
-	 * <p>
-	 * This flag is ignored when Secure DFU Buttonless Service is used. It will keep or remove the
-	 * bond depending on the Buttonless service type.
-	 */
-	public static final String EXTRA_KEEP_BOND = "no.nordicsemi.android.dfu.extra.EXTRA_KEEP_BOND";
-	/**
-	 * This property must contain a boolean value.
-	 * <p>
-	 * The {@link DfuBaseService}, when connected to a DFU target will check whether it is in
-	 * application or in DFU bootloader mode. For DFU implementations from SDK 7.0 or newer
-	 * this is done by reading the value of DFU Version characteristic.
-	 * If the returned value is equal to 0x0100 (major = 0, minor = 1) it means that we are in the
-	 * application mode and jump to the bootloader mode is required.
-	 * <p>
-	 * However, for DFU implementations from older SDKs, where there was no DFU Version
-	 * characteristic, the service must guess. If this option is set to false (default) it will count
-	 * number of device's services. If the count is equal to 3 (Generic Access, Generic Attribute,
-	 * DFU Service) it will assume that it's in DFU mode. If greater than 3 - in app mode.
-	 * This guessing may not be always correct. One situation may be when the nRF chip is used to
-	 * flash update on external MCU using DFU. The DFU procedure may be implemented in the
-	 * application, which may (and usually does) have more services.
-	 * In such case set the value of this property to true.
-	 */
-	public static final String EXTRA_FORCE_DFU = "no.nordicsemi.android.dfu.extra.EXTRA_FORCE_DFU";
-
-	/**
-	 * This flag indicates whether the service should scan for bootloader in Legacy DFU after
-	 * switching using buttonless service. The default value is false.
-	 */
-	public static final String EXTRA_FORCE_SCANNING_FOR_BOOTLOADER_IN_LEGACY_DFU = "no.nordicsemi.android.dfu.extra.EXTRA_FORCE_SCANNING_FOR_BOOTLOADER_IN_LEGACY_DFU";
-	/**
-	 * This options allows to disable the resume feature in Secure DFU. When the extra value is set
-	 * to true, the DFU will send Init Packet and Data again, despite the firmware might have been
-	 * send partially before. By default, without setting this extra, or by setting it to false,
-	 * the DFU will resume the previously cancelled upload if CRC values match.
-	 * <p>
-	 * It is ignored when Legacy DFU is used.
-	 * <p>
-	 * This feature seems to help in some cases:
-	 * <a href="https://github.com/NordicSemiconductor/Android-DFU-Library/issues/71">#71</a>.
-	 */
-	public static final String EXTRA_DISABLE_RESUME = "no.nordicsemi.android.dfu.extra.EXTRA_DISABLE_RESUME";
-	/**
-	 * The MBR size.
-	 *
-	 * @see DfuServiceInitiator#setMbrSize(int)
-	 */
-	public static final String EXTRA_MBR_SIZE = "no.nordicsemi.android.dfu.extra.EXTRA_MBR_SIZE";
-	/**
-	 * This extra allows you to control the MTU that will be requested (on Lollipop or newer devices).
-	 * If the field is null, the service will not request higher MTU and will use MTU = 23
-	 * (even if it has been set to a higher value before).
-	 */
-	public static final String EXTRA_MTU = "no.nordicsemi.android.dfu.extra.EXTRA_MTU";
-	/**
-	 * This extra value will be used when MTU request returned with an error. That means, that
-	 * MTU has been requested before and may not be changed again. This value will be used instead.
-	 */
-	public static final String EXTRA_CURRENT_MTU = "no.nordicsemi.android.dfu.extra.EXTRA_CURRENT_MTU";
-	/**
-	 * Set this flag to true to enable experimental buttonless feature in Secure DFU from SDK 12.
-	 * When the experimental Buttonless DFU Service is found on a device, the service will use it to
-	 * switch the device to the bootloader mode, connect to it in that mode and proceed with DFU.
-	 * <p>
-	 * <b>Please, read the information below before setting it to true.</b>
-	 * <p>
-	 * In the SDK 12.x the Buttonless DFU feature for Secure DFU was experimental.
-	 * It is NOT recommended to use it: it was not properly tested, had implementation bugs
-	 * (e.g. https://devzone.nordicsemi.com/question/100609/sdk-12-bootloader-erased-after-programming/)
-	 * and does not require encryption and therefore may lead to DOS attack (anyone can use it
-	 * to switch the device to bootloader mode). However, as there is no other way to trigger
-	 * bootloader mode on devices without a button, this DFU Library supports this service,
-	 * but the feature must be explicitly enabled here.
-	 * Be aware, that setting this flag to false will not protect your devices from this kind of
-	 * attacks, as an attacker may use another app for that purpose. To be sure your device is
-	 * secure remove this experimental service from your device.
-	 * <p>
-	 * <b>Spec:</b><br>
-	 * Buttonless DFU Service UUID: 8E400001-F315-4F60-9FB8-838830DAEA50<br>
-	 * Buttonless DFU characteristic UUID: 8E400001-F315-4F60-9FB8-838830DAEA50 (the same)<br>
-	 * Enter Bootloader Op Code: 0x01<br>
-	 * Correct return value: 0x20-01-01 , where:<br>
-	 * 0x20 - Response Op Code<br>
-	 * 0x01 - Request Code<br>
-	 * 0x01 - Success<br>
-	 * The device should disconnect and restart in DFU mode after sending the notification.
-	 * <p>
-	 * In SDK 14 this issue was fixed by Buttonless Service With Bonds.
-	 */
-	public static final String EXTRA_UNSAFE_EXPERIMENTAL_BUTTONLESS_DFU = "no.nordicsemi.android.dfu.extra.EXTRA_UNSAFE_EXPERIMENTAL_BUTTONLESS_DFU";
-	/**
-	 * The duration of a delay that will be added before sending each data packet in Secure DFU,
-	 * in milliseconds. This defaults to 0 for backwards compatibility reason.
-	 */
-	public static final String EXTRA_DATA_OBJECT_DELAY = "no.nordicsemi.android.dfu.extra.EXTRA_DATA_OBJECT_DELAY";
-	/**
-	 * This property must contain a boolean value.
-	 * <p>
-	 * If true the Packet Receipt Notification procedure will be enabled.
-	 * See DFU documentation on http://infocenter.nordicsemi.com for more details.
-	 * The number of packets before receiving a Packet Receipt Notification is set with property
-	 * {@link #EXTRA_PACKET_RECEIPT_NOTIFICATIONS_VALUE}.
-	 * The PRNs by default are enabled on devices running Android 4.3, 4.4.x and 5.x and
-	 * disabled on 6.x and newer.
-	 *
-	 * @see #EXTRA_PACKET_RECEIPT_NOTIFICATIONS_VALUE
-	 */
-	public static final String EXTRA_PACKET_RECEIPT_NOTIFICATIONS_ENABLED = "no.nordicsemi.android.dfu.extra.EXTRA_PRN_ENABLED";
-	/**
-	 * This property must contain a positive integer value, usually from range 1-200.
-	 * <p>
-	 * The default value is {@link DfuServiceInitiator#DEFAULT_PRN_VALUE}.
-	 * Setting it to 0 will disable the Packet Receipt Notification procedure.
-	 * When sending a firmware using the DFU procedure the service will send this number of packets
-	 * before waiting for a notification. Packet Receipt Notifications are used to synchronize
-	 * the sender with receiver.
-	 * <p>
-	 * On Android, calling
-	 * {@link android.bluetooth.BluetoothGatt#writeCharacteristic(BluetoothGattCharacteristic)}
-	 * simply adds the packet to outgoing queue before returning the callback. Adding the next
-	 * packet in the callback is much faster than the real transmission (also the speed depends on
-	 * the device chip manufacturer) and the queue may reach its limit. When does, the transmission
-	 * stops and Android Bluetooth hangs (see Note below). Using PRN procedure eliminates this
-	 * problem as the notification is send when all packets were delivered the queue is empty.
-	 * <p>
-	 * Note: this bug has been fixed on Android 6.0 Marshmallow and now no notifications are required.
-	 * The onCharacteristicWrite callback will be postponed until half of the queue is empty and
-	 * upload will be resumed automatically. Disabling PRNs speeds up the upload process on those
-	 * devices.
-	 *
-	 * @see #EXTRA_PACKET_RECEIPT_NOTIFICATIONS_ENABLED
-	 */
-	public static final String EXTRA_PACKET_RECEIPT_NOTIFICATIONS_VALUE = "no.nordicsemi.android.dfu.extra.EXTRA_PRN_VALUE";
-	/**
-	 * A path to the file with the new firmware. It may point to a HEX, BIN or a ZIP file.
-	 * Some file manager applications return the path as a String while other return a Uri.
-	 * Use the {@link #EXTRA_FILE_URI} in the later case. For files included
-	 * in /res/raw resource directory please use {@link #EXTRA_FILE_RES_ID} instead.
-	 */
-	public static final String EXTRA_FILE_PATH = "no.nordicsemi.android.dfu.extra.EXTRA_FILE_PATH";
-	/**
-	 * See {@link #EXTRA_FILE_PATH} for details.
-	 */
-	public static final String EXTRA_FILE_URI = "no.nordicsemi.android.dfu.extra.EXTRA_FILE_URI";
-	/**
-	 * See {@link #EXTRA_FILE_PATH} for details.
-	 */
-	public static final String EXTRA_FILE_RES_ID = "no.nordicsemi.android.dfu.extra.EXTRA_FILE_RES_ID";
-	/**
-	 * The Init packet URI. This file is required if the Extended Init Packet is required (SDK 7.0+).
-	 * Must point to a 'dat' file corresponding with the selected firmware.
-	 * The Init packet may contain just the CRC (in case of older versions of DFU) or the
-	 * Extended Init Packet in binary format (SDK 7.0+).
-	 */
-	public static final String EXTRA_INIT_FILE_PATH = "no.nordicsemi.android.dfu.extra.EXTRA_INIT_FILE_PATH";
-	/**
-	 * The Init packet URI. This file is required if the Extended Init Packet is required (SDK 7.0+).
-	 * Must point to a 'dat' file corresponding with the selected firmware.
-	 * The Init packet may contain just the CRC (in case of older versions of DFU) or the
-	 * Extended Init Packet in binary format (SDK 7.0+).
-	 */
-	public static final String EXTRA_INIT_FILE_URI = "no.nordicsemi.android.dfu.extra.EXTRA_INIT_FILE_URI";
-	/**
-	 * The Init packet URI. This file is required if the Extended Init Packet is required (SDK 7.0+).
-	 * Must point to a 'dat' file corresponding with the selected firmware.
-	 * The Init packet may contain just the CRC (in case of older versions of DFU) or the
-	 * Extended Init Packet in binary format (SDK 7.0+).
-	 */
-	public static final String EXTRA_INIT_FILE_RES_ID = "no.nordicsemi.android.dfu.extra.EXTRA_INIT_FILE_RES_ID";
-	/**
-	 * The input file mime-type. Currently only "application/zip" (ZIP) or "application/octet-stream"
-	 * (HEX or BIN) are supported. If this parameter is empty the "application/octet-stream" is assumed.
-	 */
-	public static final String EXTRA_FILE_MIME_TYPE = "no.nordicsemi.android.dfu.extra.EXTRA_MIME_TYPE";
-	// Since the DFU Library version 0.5 both HEX and BIN files are supported.
-	// As both files have the same MIME TYPE the distinction is made based on the file extension.
-	public static final String MIME_TYPE_OCTET_STREAM = "application/octet-stream";
-	public static final String MIME_TYPE_ZIP = "application/zip";
-	/**
-	 * This optional extra parameter may contain a file type. Currently supported are:
-	 * <ul>
-	 * <li>{@link #TYPE_SOFT_DEVICE} - only Soft Device update</li>
-	 * <li>{@link #TYPE_BOOTLOADER} - only Bootloader update</li>
-	 * <li>{@link #TYPE_APPLICATION} - only application update</li>
-	 * <li>{@link #TYPE_AUTO} - the file is a ZIP file that may contain more than one HEX/BIN + DAT files.
-	 * Since SDK 8.0 the ZIP Distribution packet is a recommended way of delivering firmware files.
-	 * Please, see the DFU documentation for more details. A ZIP distribution packet may be created
-	 * using the 'nrf util' Python application, available at
-	 * <a href="https://github.com/NordicSemiconductor/pc-nrfutil">https://github.com/NordicSemiconductor/pc-nrfutil</a>.
-	 * The ZIP file MAY contain only the following files: <b>softdevice.hex/bin</b>,
-	 * <b>bootloader.hex/bin</b>, <b>application.hex/bin</b> to determine the type based on its name.
-	 * At lease one of them MUST be present.
-	 * </li>
-	 * </ul>
-	 * If this parameter is not provided the type is assumed as follows:
-	 * <ol>
-	 * <li>If the {@link #EXTRA_FILE_MIME_TYPE} field is <code>null</code> or is equal to
-	 * {@value #MIME_TYPE_OCTET_STREAM} - the {@link #TYPE_APPLICATION} is assumed.</li>
-	 * <li>If the {@link #EXTRA_FILE_MIME_TYPE} field is equal to {@value #MIME_TYPE_ZIP}
-	 * - the {@link #TYPE_AUTO} is assumed.</li>
-	 * </ol>
-	 */
-	public static final String EXTRA_FILE_TYPE = "no.nordicsemi.android.dfu.extra.EXTRA_FILE_TYPE";
-	/**
-	 * <p>
-	 * The file contains a new version of Soft Device.
-	 * <p>
-	 * Since DFU Library 7.0 all firmware may contain an Init packet. The Init packet is required
-	 * if Extended Init Packet is used by the DFU bootloader (SDK 7.0+)..
-	 * The Init packet for the bootloader must be placed in the .dat file.
-	 *
-	 * @see #EXTRA_FILE_TYPE
-	 */
-	public static final int TYPE_SOFT_DEVICE = 0x01;
-	/**
-	 * <p>
-	 * The file contains a new version of Bootloader.
-	 * <p>
-	 * Since DFU Library 7.0 all firmware may contain an Init packet. The Init packet is required
-	 * if Extended Init Packet is used by the DFU bootloader (SDK 7.0+).
-	 * The Init packet for the bootloader must be placed in the .dat file.
-	 *
-	 * @see #EXTRA_FILE_TYPE
-	 */
-	public static final int TYPE_BOOTLOADER = 0x02;
-	/**
-	 * <p>
-	 * The file contains a new version of Application.
-	 * <p>
-	 * Since DFU Library 0.5 all firmware may contain an Init packet. The Init packet is required
-	 * if Extended Init Packet is used by the DFU bootloader (SDK 7.0+).
-	 * The Init packet for the application must be placed in the .dat file.
-	 *
-	 * @see #EXTRA_FILE_TYPE
-	 */
-	public static final int TYPE_APPLICATION = 0x04;
-	/**
-	 * <p>
-	 * A ZIP file that consists of more than 1 file. Since SDK 8.0 the ZIP Distribution packet is
-	 * a recommended way of delivering firmware files. Please, see the DFU documentation for
-	 * more details. A ZIP distribution packet may be created using the 'nrf utility' command line
-	 * application, that is a part of Master Control Panel 3.8.0.
-	 * For backwards compatibility this library supports also ZIP files without the manifest file.
-	 * Instead they must follow the fixed naming convention:
-	 * The names of files in the ZIP must be: <b>softdevice.hex</b> (or .bin), <b>bootloader.hex</b>
-	 * (or .bin), <b>application.hex</b> (or .bin) in order to be read correctly. Using the
-	 * Soft Device v7.0.0+ the Soft Device and Bootloader may be updated and sent together.
-	 * In case of additional application file included, the service will try to send Soft Device,
-	 * Bootloader and Application together (which is not supported currently) and if it fails,
-	 * send first SD+BL, reconnect and send the application in the following connection.
-	 * <p>
-	 * Since the DFU Library 0.5 you may specify the Init packet, that will be send prior to the
-	 * firmware. The init packet contains some verification data, like a device type and revision,
-	 * application version or a list of supported Soft Devices. The Init packet is required if
-	 * Extended Init Packet is used by the DFU bootloader (SDK 7.0+).
-	 * In case of using the compatibility ZIP files the Init packet for the Soft Device and Bootloader
-	 * must be in the 'system.dat' file while for the application in the 'application.dat' file
-	 * (included in the ZIP). The CRC in the 'system.dat' must be a CRC of both BIN contents if
-	 * both a Soft Device and a Bootloader is present.
-	 *
-	 * @see #EXTRA_FILE_TYPE
-	 */
-	public static final int TYPE_AUTO = 0x00;
-	/**
-	 * An extra field with progress and error information used in broadcast events.
-	 */
-	public static final String EXTRA_DATA = "no.nordicsemi.android.dfu.extra.EXTRA_DATA";
-	/**
-	 * An extra field to send the progress or error information in the DFU notification.
-	 * The value may contain:
-	 * <ul>
-	 * <li>Value 0 - 100 - percentage progress value</li>
-	 * <li>One of the following status constants:
-	 * <ul>
-	 * <li>{@link #PROGRESS_CONNECTING}</li>
-	 * <li>{@link #PROGRESS_STARTING}</li>
-	 * <li>{@link #PROGRESS_ENABLING_DFU_MODE}</li>
-	 * <li>{@link #PROGRESS_VALIDATING}</li>
-	 * <li>{@link #PROGRESS_DISCONNECTING}</li>
-	 * <li>{@link #PROGRESS_COMPLETED}</li>
-	 * <li>{@link #PROGRESS_ABORTED}</li>
-	 * </ul>
-	 * </li>
-	 * <li>An error code with {@link #ERROR_MASK} if initialization error occurred</li>
-	 * <li>An error code with {@link #ERROR_REMOTE_MASK} if remote DFU target returned an error</li>
-	 * <li>An error code with {@link #ERROR_CONNECTION_MASK} if connection error occurred
-	 * (e.g. GATT error (133) or Internal GATT Error (129))</li>
-	 * </ul>
-	 * To check if error occurred use:<br>
-	 * {@code boolean error = progressValue >= DfuBaseService.ERROR_MASK;}
-	 */
-	public static final String EXTRA_PROGRESS = "no.nordicsemi.android.dfu.extra.EXTRA_PROGRESS";
-	/**
-	 * The number of currently transferred part. The SoftDevice and Bootloader may be send
-	 * together as one part. If user wants to upload them together with an application it has to be
-	 * sent in another connection as the second part.
-	 *
-	 * @see no.nordicsemi.android.dfu.DfuBaseService#EXTRA_PARTS_TOTAL
-	 */
-	public static final String EXTRA_PART_CURRENT = "no.nordicsemi.android.dfu.extra.EXTRA_PART_CURRENT";
-	/**
-	 * Number of parts in total.
-	 *
-	 * @see no.nordicsemi.android.dfu.DfuBaseService#EXTRA_PART_CURRENT
-	 */
-	public static final String EXTRA_PARTS_TOTAL = "no.nordicsemi.android.dfu.extra.EXTRA_PARTS_TOTAL";
-	/**
-	 * The current upload speed in bytes/millisecond.
-	 */
-	public static final String EXTRA_SPEED_B_PER_MS = "no.nordicsemi.android.dfu.extra.EXTRA_SPEED_B_PER_MS";
-	/**
-	 * The average upload speed in bytes/millisecond for the current part.
-	 */
-	public static final String EXTRA_AVG_SPEED_B_PER_MS = "no.nordicsemi.android.dfu.extra.EXTRA_AVG_SPEED_B_PER_MS";
-	/**
-	 * The broadcast message contains the following extras:
-	 * <ul>
-	 * <li>{@link #EXTRA_DATA} - the progress value (percentage 0-100) or:
-	 * <ul>
-	 * <li>{@link #PROGRESS_CONNECTING}</li>
-	 * <li>{@link #PROGRESS_STARTING}</li>
-	 * <li>{@link #PROGRESS_ENABLING_DFU_MODE}</li>
-	 * <li>{@link #PROGRESS_VALIDATING}</li>
-	 * <li>{@link #PROGRESS_DISCONNECTING}</li>
-	 * <li>{@link #PROGRESS_COMPLETED}</li>
-	 * <li>{@link #PROGRESS_ABORTED}</li>
-	 * </ul>
-	 * </li>
-	 * <li>{@link #EXTRA_DEVICE_ADDRESS} - the target device address</li>
-	 * <li>{@link #EXTRA_PART_CURRENT} - the number of currently transmitted part</li>
-	 * <li>{@link #EXTRA_PARTS_TOTAL} - total number of parts that are being sent, e.g. if a ZIP
-	 * file contains a Soft Device, a Bootloader and an Application, the SoftDevice and Bootloader
-	 * will be send together as one part. Then the service will disconnect and reconnect to the
-	 * new Bootloader and send the application as part number two.</li>
-	 * <li>{@link #EXTRA_SPEED_B_PER_MS} - current speed in bytes/millisecond as float</li>
-	 * <li>{@link #EXTRA_AVG_SPEED_B_PER_MS} - the average transmission speed in bytes/millisecond
-	 * as float</li>
-	 * </ul>
-	 */
-	public static final String BROADCAST_PROGRESS = "no.nordicsemi.android.dfu.broadcast.BROADCAST_PROGRESS";
-	/**
-	 * Service is connecting to the remote DFU target.
-	 */
-	public static final int PROGRESS_CONNECTING = -1;
-	/**
-	 * Service is enabling notifications and starting transmission.
-	 */
-	public static final int PROGRESS_STARTING = -2;
-	/**
-	 * Service has triggered a switch to bootloader mode. Now the service waits for the link loss
-	 * event (this may take up to several seconds) and will connect again to the same device,
-	 * now started in the bootloader mode.
-	 */
-	public static final int PROGRESS_ENABLING_DFU_MODE = -3;
-	/**
-	 * Service is sending validation request to the remote DFU target.
-	 */
-	public static final int PROGRESS_VALIDATING = -4;
-	/**
-	 * Service is disconnecting from the DFU target.
-	 */
-	public static final int PROGRESS_DISCONNECTING = -5;
-	/**
-	 * The connection is successful.
-	 */
-	public static final int PROGRESS_COMPLETED = -6;
-	/**
-	 * The upload has been aborted. Previous software version will be restored on the target.
-	 */
-	public static final int PROGRESS_ABORTED = -7;
-	/**
-	 * The broadcast error message contains the following extras:
-	 * <ul>
-	 * <li>{@link #EXTRA_DATA} - the error number. Use {@link GattError#parse(int)} to get String
-	 * representation.</li>
-	 * <li>{@link #EXTRA_DEVICE_ADDRESS} - the target device address</li>
-	 * </ul>
-	 */
-	public static final String BROADCAST_ERROR = "no.nordicsemi.android.dfu.broadcast.BROADCAST_ERROR";
-	/**
-	 * The type of the error. This extra contains information about that kind of error has occurred.
-	 * Connection state errors and other errors may share the same numbers. For example, the
-	 * {@link BluetoothGattCallback#onCharacteristicWrite(BluetoothGatt, BluetoothGattCharacteristic, int)}
-	 * method may return a status code 8 (GATT INSUF AUTHORIZATION), while the status code 8
-	 * returned by {@link BluetoothGattCallback#onConnectionStateChange(BluetoothGatt, int, int)}
-	 * is a GATT CONN TIMEOUT error.
-	 */
-	public static final String EXTRA_ERROR_TYPE = "no.nordicsemi.android.dfu.extra.EXTRA_ERROR_TYPE";
-	public static final int ERROR_TYPE_OTHER = 0;
-	public static final int ERROR_TYPE_COMMUNICATION_STATE = 1;
-	public static final int ERROR_TYPE_COMMUNICATION = 2;
-	public static final int ERROR_TYPE_DFU_REMOTE = 3;
-	/**
-	 * If this bit is set than the progress value indicates an error. Use {@link GattError#parse(int)}
-	 * to obtain error name.
-	 */
-	public static final int ERROR_MASK = 0x1000;
-	public static final int ERROR_DEVICE_DISCONNECTED = ERROR_MASK; // | 0x00;
-	public static final int ERROR_FILE_NOT_FOUND = ERROR_MASK | 0x01;
-	/**
-	 * Thrown if service was unable to open the file ({@link java.io.IOException} has been thrown).
-	 */
-	public static final int ERROR_FILE_ERROR = ERROR_MASK | 0x02;
-	/**
-	 * Thrown when input file is not a valid HEX or ZIP file.
-	 */
-	public static final int ERROR_FILE_INVALID = ERROR_MASK | 0x03;
-	/**
-	 * Thrown when {@link java.io.IOException} occurred when reading from file.
-	 */
-	public static final int ERROR_FILE_IO_EXCEPTION = ERROR_MASK | 0x04;
-	/**
-	 * Error thrown when {@code gatt.discoverServices();} returns false.
-	 */
-	public static final int ERROR_SERVICE_DISCOVERY_NOT_STARTED = ERROR_MASK | 0x05;
-	/**
-	 * Thrown when the service discovery has finished but the DFU service has not been found.
-	 * The device does not support DFU of is not in DFU mode.
-	 */
-	public static final int ERROR_SERVICE_NOT_FOUND = ERROR_MASK | 0x06;
-	/**
-	 * Thrown when unknown response has been obtained from the target. The DFU target must follow
-	 * specification.
-	 */
-	public static final int ERROR_INVALID_RESPONSE = ERROR_MASK | 0x08;
-	/**
-	 * Thrown when the the service does not support given type or mime-type.
-	 */
-	public static final int ERROR_FILE_TYPE_UNSUPPORTED = ERROR_MASK | 0x09;
-	/**
-	 * Thrown when the the Bluetooth adapter is disabled.
-	 */
-	public static final int ERROR_BLUETOOTH_DISABLED = ERROR_MASK | 0x0A;
-	/**
-	 * DFU Bootloader version 0.6+ requires sending the Init packet. If such bootloader version is
-	 * detected, but the init packet has not been set this error is thrown.
-	 */
-	public static final int ERROR_INIT_PACKET_REQUIRED = ERROR_MASK | 0x0B;
-	/**
-	 * Thrown when the firmware file is not word-aligned. The firmware size must be dividable by
-	 * 4 bytes.
-	 */
-	public static final int ERROR_FILE_SIZE_INVALID = ERROR_MASK | 0x0C;
-	/**
-	 * Thrown when the received CRC does not match with the calculated one. The service will try
-	 * 3 times to send the data, and if the CRC fails each time this error will be thrown.
-	 */
-	public static final int ERROR_CRC_ERROR = ERROR_MASK | 0x0D;
-	/**
-	 * Thrown when device had to be paired before the DFU process was started.
-	 */
-	public static final int ERROR_DEVICE_NOT_BONDED = ERROR_MASK | 0x0E;
-	/**
-	 * Thrown when the DFU library lost track of what is going on. Reported number of bytes is
-	 * not equal to the number of bytes sent and due to some other events the library cannot recover.
-	 * <p>
-	 * Check https://github.com/NordicSemiconductor/Android-DFU-Library/issues/229
-	 */
-	public static final int ERROR_PROGRESS_LOST = ERROR_MASK | 0x0F;
-	/**
-	 * Flag set when the DFU target returned a DFU error. Look for DFU specification to get error
-	 * codes. The error code is binary OR-ed with one of: {@link #ERROR_REMOTE_TYPE_LEGACY},
-	 * {@link #ERROR_REMOTE_TYPE_SECURE} or {@link #ERROR_REMOTE_TYPE_SECURE_EXTENDED}.
-	 */
-	public static final int ERROR_REMOTE_MASK = 0x2000;
-	public static final int ERROR_REMOTE_TYPE_LEGACY = 0x0100;
-	public static final int ERROR_REMOTE_TYPE_SECURE = 0x0200;
-	public static final int ERROR_REMOTE_TYPE_SECURE_EXTENDED = 0x0400;
-	public static final int ERROR_REMOTE_TYPE_SECURE_BUTTONLESS = 0x0800;
-	/**
-	 * The flag set when one of {@link android.bluetooth.BluetoothGattCallback} methods was called
-	 * with status other than {@link android.bluetooth.BluetoothGatt#GATT_SUCCESS}.
-	 */
-	public static final int ERROR_CONNECTION_MASK = 0x4000;
-	/**
-	 * The flag set when the
-	 * {@link android.bluetooth.BluetoothGattCallback#onConnectionStateChange(android.bluetooth.BluetoothGatt, int, int)}
-	 * method was called with status other than {@link android.bluetooth.BluetoothGatt#GATT_SUCCESS}.
-	 */
-	public static final int ERROR_CONNECTION_STATE_MASK = 0x8000;
-	/**
-	 * The log events are only broadcast when there is no nRF Logger installed.
-	 * The broadcast contains 2 extras:
-	 * <ul>
-	 * <li>{@link #EXTRA_LOG_LEVEL} - The log level, one of following: {@link #LOG_LEVEL_DEBUG},
-	 * {@link #LOG_LEVEL_VERBOSE}, {@link #LOG_LEVEL_INFO}, {@link #LOG_LEVEL_APPLICATION},
-	 * {@link #LOG_LEVEL_WARNING}, {@link #LOG_LEVEL_ERROR}</li>
-	 * <li>{@link #EXTRA_LOG_MESSAGE} - The log message</li>
-	 * </ul>
-	 */
-	public static final String BROADCAST_LOG = "no.nordicsemi.android.dfu.broadcast.BROADCAST_LOG";
-	public static final String EXTRA_LOG_MESSAGE = "no.nordicsemi.android.dfu.extra.EXTRA_LOG_INFO";
-	public static final String EXTRA_LOG_LEVEL = "no.nordicsemi.android.dfu.extra.EXTRA_LOG_LEVEL";
-	/*
-	 * Note:
-	 * The nRF Logger API library has been excluded from the DfuLibrary.
-	 * All log events are now being sent using local broadcasts and may be logged into nRF Logger
-	 * in the app module. This is to make the Dfu module independent from logging tool.
-	 *
-	 * The log levels below are equal to log levels in nRF Logger API library, v 2.0.
-	 * @see https://github.com/NordicSemiconductor/nRF-Logger-API
-	 */
-	/**
-	 * Level used just for debugging purposes. It has lowest level
-	 */
-	public final static int LOG_LEVEL_DEBUG = 0;
-	/**
-	 * Log entries with minor importance
-	 */
-	public final static int LOG_LEVEL_VERBOSE = 1;
-	/**
-	 * Default logging level for important entries
-	 */
-	public final static int LOG_LEVEL_INFO = 5;
-	/**
-	 * Log entries level for applications
-	 */
-	public final static int LOG_LEVEL_APPLICATION = 10;
-	/**
-	 * Log entries with high importance
-	 */
-	public final static int LOG_LEVEL_WARNING = 15;
-	/**
-	 * Log entries with very high importance, like errors
-	 */
-	public final static int LOG_LEVEL_ERROR = 20;
-	/**
-	 * Activity may broadcast this broadcast in order to pause, resume or abort DFU process.
-	 * Use {@link #EXTRA_ACTION} extra to pass the action.
-	 */
-	public static final String BROADCAST_ACTION = "no.nordicsemi.android.dfu.broadcast.BROADCAST_ACTION";
-	/**
-	 * The action extra. It may have one of the following values: {@link #ACTION_PAUSE},
-	 * {@link #ACTION_RESUME}, {@link #ACTION_ABORT}.
-	 */
-	public static final String EXTRA_ACTION = "no.nordicsemi.android.dfu.extra.EXTRA_ACTION";
-	/**
-	 * Pauses the upload. The service will wait for broadcasts with the action set to
-	 * {@link #ACTION_RESUME} or {@link #ACTION_ABORT}.
-	 */
-	public static final int ACTION_PAUSE = 0;
-	/** Resumes the upload that has been paused before using {@link #ACTION_PAUSE}. */
-	public static final int ACTION_RESUME = 1;
-	/**
-	 * Aborts the upload. The service does not need to be paused before.
-	 * After sending {@link #BROADCAST_ACTION} with extra {@link #EXTRA_ACTION} set to this value
-	 * the DFU bootloader will restore the old application (if there was already an application).
-	 * Be aware, that uploading the Soft Device will erase the application in order to make space
-	 * in the memory. In case there is no application, or the application has been removed, the
-	 * DFU bootloader will be started and user may try to send the application again.
-	 * The bootloader may advertise with the address incremented by 1 to prevent caching services.
-	 */
-	public static final int ACTION_ABORT = 2;
-
-	public static final String EXTRA_SCAN_DELAY = "no.nordicsemi.android.dfu.extra.EXTRA_SCAN_DELAY";
-	public static final String EXTRA_SCAN_TIMEOUT = "no.nordicsemi.android.dfu.extra.EXTRA_SCAN_TIMEOUT";
-
-	public static final String EXTRA_CUSTOM_UUIDS_FOR_LEGACY_DFU = "no.nordicsemi.android.dfu.extra.EXTRA_CUSTOM_UUIDS_FOR_LEGACY_DFU";
-	public static final String EXTRA_CUSTOM_UUIDS_FOR_SECURE_DFU = "no.nordicsemi.android.dfu.extra.EXTRA_CUSTOM_UUIDS_FOR_SECURE_DFU";
-	public static final String EXTRA_CUSTOM_UUIDS_FOR_EXPERIMENTAL_BUTTONLESS_DFU = "no.nordicsemi.android.dfu.extra.EXTRA_CUSTOM_UUIDS_FOR_EXPERIMENTAL_BUTTONLESS_DFU";
-	public static final String EXTRA_CUSTOM_UUIDS_FOR_BUTTONLESS_DFU_WITHOUT_BOND_SHARING = "no.nordicsemi.android.dfu.extra.EXTRA_CUSTOM_UUIDS_FOR_BUTTONLESS_DFU_WITHOUT_BOND_SHARING";
-	public static final String EXTRA_CUSTOM_UUIDS_FOR_BUTTONLESS_DFU_WITH_BOND_SHARING = "no.nordicsemi.android.dfu.extra.EXTRA_CUSTOM_UUIDS_FOR_BUTTONLESS_DFU_WITH_BOND_SHARING";
-
-	/**
-	 * Lock used in synchronization purposes
-	 */
-	private final Object mLock = new Object();
-	private BluetoothAdapter mBluetoothAdapter;
-	private String mDeviceAddress;
-	private String mDeviceName;
-	private boolean mDisableNotification;
-	/**
-	 * The current connection state. If its value is > 0 than an error has occurred.
-	 * Error number is a negative value of mConnectionState
-	 */
-	protected int mConnectionState;
-	protected final static int STATE_DISCONNECTED = 0;
-	protected final static int STATE_CONNECTING = -1;
-	protected final static int STATE_CONNECTED = -2;
-	protected final static int STATE_CONNECTED_AND_READY = -3; // indicates that services were discovered
-	protected final static int STATE_DISCONNECTING = -4;
-	protected final static int STATE_CLOSED = -5;
-	/**
-	 * The number of the last error that has occurred or 0 if there was no error
-	 */
-	private int mError;
-	/**
-	 * Stores the last progress percent. Used to prevent from sending progress notifications with
-	 * the same value.
-	 */
-	private int mLastProgress = -1;
-	/* package */ DfuProgressInfo mProgressInfo;
-	private long mLastNotificationTime;
-
-	/** Flag set to true if sending was aborted. */
-	private boolean mAborted;
-
-	private DfuCallback mDfuServiceImpl;
-	private InputStream mFirmwareInputStream, mInitFileInputStream;
-
-	private final BroadcastReceiver mDfuActionReceiver = new BroadcastReceiver() {
-		@Override
-		public void onReceive(final Context context, final Intent intent) {
-			final int action = intent.getIntExtra(EXTRA_ACTION, 0);
-
-			logi("User action received: " + action);
-			switch (action) {
-				case ACTION_PAUSE:
-					sendLogBroadcast(LOG_LEVEL_WARNING, "[Broadcast] Pause action received");
-					if (mDfuServiceImpl != null)
-						mDfuServiceImpl.pause();
-					break;
-				case ACTION_RESUME:
-					sendLogBroadcast(LOG_LEVEL_WARNING, "[Broadcast] Resume action received");
-					if (mDfuServiceImpl != null)
-						mDfuServiceImpl.resume();
-					break;
-				case ACTION_ABORT:
-					sendLogBroadcast(LOG_LEVEL_WARNING, "[Broadcast] Abort action received");
-					mAborted = true;
-					if (mDfuServiceImpl != null)
-						mDfuServiceImpl.abort();
-					break;
-			}
-		}
-	};
-
-	private final BroadcastReceiver mBluetoothStateBroadcastReceiver = new BroadcastReceiver() {
-		@Override
-		public void onReceive(final Context context, final Intent intent) {
-			final int state = intent.getIntExtra(BluetoothAdapter.EXTRA_STATE, BluetoothAdapter.STATE_OFF);
-			final int previousState = intent.getIntExtra(BluetoothAdapter.EXTRA_PREVIOUS_STATE, BluetoothAdapter.STATE_ON);
-			logw("Action received: android.bluetooth.adapter.action.STATE_CHANGED [state: " + state + ", previous state: " + previousState + "]");
-			if (previousState == BluetoothAdapter.STATE_ON
-					&& (state == BluetoothAdapter.STATE_TURNING_OFF || state == BluetoothAdapter.STATE_OFF)) {
-				sendLogBroadcast(LOG_LEVEL_WARNING, "Bluetooth adapter disabled");
-				mConnectionState = STATE_DISCONNECTED;
-				if (mDfuServiceImpl != null)
-					mDfuServiceImpl.getGattCallback().onDisconnected();
-
-				// Notify waiting thread
-				synchronized (mLock) {
-					mLock.notifyAll();
-				}
-			}
-		}
-	};
-
-	private final BroadcastReceiver mBondStateBroadcastReceiver = new BroadcastReceiver() {
-		@Override
-		public void onReceive(final Context context, final Intent intent) {
-			// Obtain the device and check if this is the one that we are connected to
-			final BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
-			if (device == null || !device.getAddress().equals(mDeviceAddress))
-				return;
-
-			// Read bond state
-			final int bondState = intent.getIntExtra(BluetoothDevice.EXTRA_BOND_STATE, -1);
-			if (bondState == BluetoothDevice.BOND_BONDING)
-				return;
-
-			if (mDfuServiceImpl != null)
-				mDfuServiceImpl.onBondStateChanged(bondState);
-		}
-	};
-
-	private final BroadcastReceiver mConnectionStateBroadcastReceiver = new BroadcastReceiver() {
-		@Override
-		public void onReceive(final Context context, final Intent intent) {
-			// Obtain the device and check it this is the one that we are connected to
-			final BluetoothDevice device = intent.getParcelableExtra(BluetoothDevice.EXTRA_DEVICE);
-			if (device == null || !device.getAddress().equals(mDeviceAddress))
-				return;
-
-			final String action = intent.getAction();
-
-			logi("Action received: " + action);
-			sendLogBroadcast(LOG_LEVEL_DEBUG, "[Broadcast] Action received: " + action);
-			/*
-			Handling the disconnection event here could lead to race conditions, as it also may (most probably will)
-			be delivered to onConnectionStateChange below.
-			See: https://github.com/NordicSemiconductor/Android-DFU-Library/issues/55
-
-			Note: This broadcast is now received on all 3 ACL events!
-				  Don't assume DISCONNECT here.
-
-			mConnectionState = STATE_DISCONNECTED;
-
-			if (mDfuServiceImpl != null)
-				mDfuServiceImpl.getGattCallback().onDisconnected();
-
-			// Notify waiting thread
-			synchronized (mLock) {
-				mLock.notifyAll();
-			}
-			*/
-		}
-	};
-
-	private final BluetoothGattCallback mGattCallback = new BluetoothGattCallback() {
-		@Override
-		public void onConnectionStateChange(final BluetoothGatt gatt, final int status, final int newState) {
-			// Check whether an error occurred
-			if (status == BluetoothGatt.GATT_SUCCESS) {
-				if (newState == BluetoothGatt.STATE_CONNECTED) {
-					logi("Connected to GATT server");
-					sendLogBroadcast(LOG_LEVEL_INFO, "Connected to " + mDeviceAddress);
-					mConnectionState = STATE_CONNECTED;
-
-					/*
-					 * The onConnectionStateChange callback is called just after establishing connection and before sending Encryption Request BLE event in case of a paired device.
-					 * In that case and when the Service Changed CCCD is enabled we will get the indication after initializing the encryption, about 1600 milliseconds later.
-					 * If we discover services right after connecting, the onServicesDiscovered callback will be called immediately, before receiving the indication and the following
-					 * service discovery and we may end up with old, application's services instead.
-					 *
-					 * This is to support the buttonless switch from application to bootloader mode where the DFU bootloader notifies the master about service change.
-					 * Tested on Nexus 4 (Android 4.4.4 and 5), Nexus 5 (Android 5), Samsung Note 2 (Android 4.4.2). The time after connection to end of service discovery is about 1.6s
-					 * on Samsung Note 2.
-					 *
-					 * NOTE: We are doing this to avoid the hack with calling the hidden gatt.refresh()
-					 * method, at least for bonded devices.
-					 *
-					 * IMPORTANT: BluetoothDevice.getBondState() returns true if the bond information
-					 * is present on Android, not necessarily when the link is established or even
-					 * encrypted. This is a security issue, but in here it does not matter.
-					 */
-					if (gatt.getDevice().getBondState() == BluetoothDevice.BOND_BONDED) {
-						logi("Waiting 1600 ms for a possible Service Changed indication...");
-						waitFor(1600);
-						// After 1.6s the services are already discovered so the following gatt.discoverServices() finishes almost immediately.
-
-						// NOTE: This also works with shorted waiting time. The gatt.discoverServices() must be called after the indication is received which is
-						// about 600ms after establishing connection. Values 600 - 1600ms should be OK.
-					}
-
-					// Attempts to discover services after successful connection.
-					sendLogBroadcast(LOG_LEVEL_VERBOSE, "Discovering services...");
-					sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.discoverServices()");
-					final boolean success = gatt.discoverServices();
-					logi("Attempting to start service discovery... " + (success ? "succeed" : "failed"));
-
-					if (!success) {
-						mError = ERROR_SERVICE_DISCOVERY_NOT_STARTED;
-					} else {
-						// Just return here, lock will be notified when service discovery finishes
-						return;
-					}
-				} else if (newState == BluetoothGatt.STATE_DISCONNECTED) {
-					logi("Disconnected from GATT server");
-					mConnectionState = STATE_DISCONNECTED;
-					if (mDfuServiceImpl != null)
-						mDfuServiceImpl.getGattCallback().onDisconnected();
-				}
-			} else {
-				if (status == 0x08 /* GATT CONN TIMEOUT */ || status == 0x13 /* GATT CONN TERMINATE PEER USER */)
-					logw("Target device disconnected with status: " + status);
-				else
-					loge("Connection state change error: " + status + " newState: " + newState);
-				mError = ERROR_CONNECTION_STATE_MASK | status;
-				if (newState == BluetoothGatt.STATE_DISCONNECTED) {
-					mConnectionState = STATE_DISCONNECTED;
-					if (mDfuServiceImpl != null)
-						mDfuServiceImpl.getGattCallback().onDisconnected();
-				}
-			}
-
-			// Notify waiting thread
-			synchronized (mLock) {
-				mLock.notifyAll();
-			}
-		}
-
-		@Override
-		public void onServicesDiscovered(final BluetoothGatt gatt, final int status) {
-			if (status == BluetoothGatt.GATT_SUCCESS) {
-				logi("Services discovered");
-				mConnectionState = STATE_CONNECTED_AND_READY;
-			} else {
-				loge("Service discovery error: " + status);
-				mError = ERROR_CONNECTION_MASK | status;
-			}
-
-			// Notify waiting thread
-			synchronized (mLock) {
-				mLock.notifyAll();
-			}
-		}
-
-		// Other methods just pass the parameters through
-		@Override
-		public void onCharacteristicWrite(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
-			if (mDfuServiceImpl != null)
-				mDfuServiceImpl.getGattCallback().onCharacteristicWrite(gatt, characteristic, status);
-		}
-
-		@Override
-		public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic, int status) {
-			if (mDfuServiceImpl != null)
-				mDfuServiceImpl.getGattCallback().onCharacteristicRead(gatt, characteristic, status);
-		}
-
-		@Override
-		public void onCharacteristicChanged(BluetoothGatt gatt, BluetoothGattCharacteristic characteristic) {
-			if (mDfuServiceImpl != null)
-				mDfuServiceImpl.getGattCallback().onCharacteristicChanged(gatt, characteristic);
-		}
-
-		@Override
-		public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {
-			if (mDfuServiceImpl != null)
-				mDfuServiceImpl.getGattCallback().onDescriptorWrite(gatt, descriptor, status);
-		}
-
-		@Override
-		public void onDescriptorRead(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {
-			if (mDfuServiceImpl != null)
-				mDfuServiceImpl.getGattCallback().onDescriptorRead(gatt, descriptor, status);
-		}
-
-		@SuppressLint("NewApi")
-		@Override
-		public void onMtuChanged(final BluetoothGatt gatt, final int mtu, final int status) {
-			if (mDfuServiceImpl != null)
-				mDfuServiceImpl.getGattCallback().onMtuChanged(gatt, mtu, status);
-		}
-
-		@SuppressLint("NewApi")
-		@Override
-		public void onPhyUpdate(final BluetoothGatt gatt, final int txPhy, final int rxPhy, final int status) {
-			if (mDfuServiceImpl != null)
-				mDfuServiceImpl.getGattCallback().onPhyUpdate(gatt, txPhy, rxPhy, status);
-		}
-	};
-
-	public DfuBaseService() {
-		super(TAG);
-	}
-
-	private static IntentFilter makeDfuActionIntentFilter() {
-		final IntentFilter intentFilter = new IntentFilter();
-		intentFilter.addAction(DfuBaseService.BROADCAST_ACTION);
-		return intentFilter;
-	}
-
-	@Override
-	public void onCreate() {
-		super.onCreate();
-
-		DEBUG = isDebug();
-		logi("DFU service created. Version: " + BuildConfig.VERSION_NAME);
-		initialize();
-
-		final LocalBroadcastManager manager = LocalBroadcastManager.getInstance(this);
-		final IntentFilter actionFilter = makeDfuActionIntentFilter();
-		manager.registerReceiver(mDfuActionReceiver, actionFilter);
-		registerReceiver(mDfuActionReceiver, actionFilter); // Additionally we must register this receiver as a non-local to get broadcasts from the notification actions
-
-		final IntentFilter filter = new IntentFilter();
-		// As we no longer perform any action based on this broadcast, we may log all ACL events
-		filter.addAction(BluetoothDevice.ACTION_ACL_CONNECTED);
-		filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECT_REQUESTED);
-		filter.addAction(BluetoothDevice.ACTION_ACL_DISCONNECTED);
-		registerReceiver(mConnectionStateBroadcastReceiver, filter);
-
-		final IntentFilter bondFilter = new IntentFilter(BluetoothDevice.ACTION_BOND_STATE_CHANGED);
-		registerReceiver(mBondStateBroadcastReceiver, bondFilter);
-
-		final IntentFilter stateFilter = new IntentFilter(BluetoothAdapter.ACTION_STATE_CHANGED);
-		registerReceiver(mBluetoothStateBroadcastReceiver, stateFilter);
-	}
-
-	@Override
-	public void onTaskRemoved(final Intent rootIntent) {
-		super.onTaskRemoved(rootIntent);
-		// This method is called when user removed the app from Recents.
-		// By default, the service will be killed and recreated immediately after that,
-		// but we don't want it. User removed the task, so let's cancel DFU.
-		final NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
-		if (manager != null) {
-			manager.cancel(NOTIFICATION_ID);
-		}
-		stopSelf();
-	}
-
-	@Override
-	public void onDestroy() {
-		super.onDestroy();
-
-		if (mDfuServiceImpl != null)
-			mDfuServiceImpl.abort();
-
-		final LocalBroadcastManager manager = LocalBroadcastManager.getInstance(this);
-		manager.unregisterReceiver(mDfuActionReceiver);
-
-		unregisterReceiver(mDfuActionReceiver);
-		unregisterReceiver(mConnectionStateBroadcastReceiver);
-		unregisterReceiver(mBondStateBroadcastReceiver);
-		unregisterReceiver(mBluetoothStateBroadcastReceiver);
-
-		try {
-			// Ensure that input stream is always closed
-			if (mFirmwareInputStream != null)
-				mFirmwareInputStream.close();
-			if (mInitFileInputStream != null)
-				mInitFileInputStream.close();
-		} catch (final IOException e) {
-			// do nothing
-		} finally {
-			mFirmwareInputStream = null;
-			mInitFileInputStream = null;
-		}
-		logi("DFU service destroyed");
-	}
-
-	@Override
-	protected void onHandleIntent(@Nullable final Intent intent) {
-		if (intent == null)
-			return;
-		// Read input parameters
-		final String deviceAddress = intent.getStringExtra(EXTRA_DEVICE_ADDRESS);
-		final String deviceName = intent.getStringExtra(EXTRA_DEVICE_NAME);
-		final boolean disableNotification = intent.getBooleanExtra(EXTRA_DISABLE_NOTIFICATION, false);
-		final boolean foregroundService = intent.getBooleanExtra(EXTRA_FOREGROUND_SERVICE, true);
-		final String filePath = intent.getStringExtra(EXTRA_FILE_PATH);
-		final Uri fileUri = intent.getParcelableExtra(EXTRA_FILE_URI);
-		final int fileResId = intent.getIntExtra(EXTRA_FILE_RES_ID, 0);
-		final String initFilePath = intent.getStringExtra(EXTRA_INIT_FILE_PATH);
-		final Uri initFileUri = intent.getParcelableExtra(EXTRA_INIT_FILE_URI);
-		final int initFileResId = intent.getIntExtra(EXTRA_INIT_FILE_RES_ID, 0);
-		int fileType = intent.getIntExtra(EXTRA_FILE_TYPE, TYPE_AUTO);
-		if (filePath != null && fileType == TYPE_AUTO)
-			fileType = filePath.toLowerCase(Locale.US).endsWith("zip") ? TYPE_AUTO : TYPE_APPLICATION;
-		String mimeType = intent.getStringExtra(EXTRA_FILE_MIME_TYPE);
-		mimeType = mimeType != null ? mimeType : (fileType == TYPE_AUTO ? MIME_TYPE_ZIP : MIME_TYPE_OCTET_STREAM);
-
-		// Some validation
-		if (deviceAddress == null || (filePath == null && fileUri == null && fileResId == 0)) {
-			loge("Device Address of firmware location are empty. Hint: use DfuServiceInitiator to start DFU");
-			return;
-		}
-		// Check file type and mime-type
-		if ((fileType & ~(TYPE_SOFT_DEVICE | TYPE_BOOTLOADER | TYPE_APPLICATION)) > 0 || !(MIME_TYPE_ZIP.equals(mimeType) || MIME_TYPE_OCTET_STREAM.equals(mimeType))) {
-			logw("File type or file mime-type not supported");
-			sendLogBroadcast(LOG_LEVEL_WARNING, "File type or file mime-type not supported");
-			report(ERROR_FILE_TYPE_UNSUPPORTED);
-			return;
-		}
-		if (MIME_TYPE_OCTET_STREAM.equals(mimeType) && fileType != TYPE_SOFT_DEVICE && fileType != TYPE_BOOTLOADER && fileType != TYPE_APPLICATION) {
-			logw("Unable to determine file type");
-			sendLogBroadcast(LOG_LEVEL_WARNING, "Unable to determine file type");
-			report(ERROR_FILE_TYPE_UNSUPPORTED);
-			return;
-		}
-		if (!disableNotification && getNotificationTarget() == null) {
-			// This would eventually crash later...
-			throw new NullPointerException("getNotificationTarget() must not return null if notifications are enabled");
-		}
-		if (!foregroundService && Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
-			logw("Foreground service disabled. Android Oreo or newer may kill a background service few moments after user closes the application.\n" +
-					"Consider enabling foreground service using DfuServiceInitiator#setForeground(boolean)");
-		}
-		UuidHelper.assignCustomUuids(intent);
-
-		if (foregroundService) {
-			logi("Starting DFU service in foreground");
-			startForeground();
-		}
-
-		mDeviceAddress = deviceAddress;
-		mDeviceName = deviceName;
-		mDisableNotification = disableNotification;
-		mConnectionState = STATE_DISCONNECTED;
-		mError = 0;
-
-		// The Soft Device starts where MBR ends (by default from the address 0x1000).
-		// Before there is a MBR section, which should not be transmitted over DFU.
-		// Applications and bootloader starts from bigger address. However, in custom DFU
-		// implementations, user may want to transmit the whole whole data, even from address 0x0000.
-		final SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(this);
-		int mbrSize = DfuServiceInitiator.DEFAULT_MBR_SIZE;
-		if (preferences.contains(DfuSettingsConstants.SETTINGS_MBR_SIZE)) {
-			final String value = preferences.getString(DfuSettingsConstants.SETTINGS_MBR_SIZE, String.valueOf(DfuServiceInitiator.DEFAULT_MBR_SIZE));
-			try {
-				mbrSize = Integer.parseInt(value);
-				if (mbrSize < 0)
-					mbrSize = 0;
-			} catch (final NumberFormatException e) {
-				// ignore, default value will be used
-			}
-		} else {
-			mbrSize = intent.getIntExtra(EXTRA_MBR_SIZE, DfuServiceInitiator.DEFAULT_MBR_SIZE);
-			if (mbrSize < 0)
-				mbrSize = 0;
-		}
-
-		sendLogBroadcast(LOG_LEVEL_VERBOSE, "DFU service started");
-
-		/*
-		 * First the service is trying to read the firmware and init packet files.
-		 */
-		InputStream is = mFirmwareInputStream;
-		InputStream initIs = mInitFileInputStream;
-		try {
-			final boolean firstRun = mFirmwareInputStream == null;
-
-			// Prepare data to send, calculate stream size
-			try {
-				if (firstRun) {
-					// The files are opened only once, when DFU service is first started.
-					// In case the service needs to be restarted (for example a buttonless service
-					// was found or to send Application in the second connection) the input stream
-					// is kept as a global service field. This is to avoid SecurityException
-					// when the URI was granted with one-time read permission.
-					// See: Intent#FLAG_GRANT_READ_URI_PERMISSION (https://developer.android.com/reference/android/content/Intent.html#FLAG_GRANT_READ_URI_PERMISSION).
-					sendLogBroadcast(LOG_LEVEL_VERBOSE, "Opening file...");
-					if (fileUri != null) {
-						is = openInputStream(fileUri, mimeType, mbrSize, fileType);
-					} else if (filePath != null) {
-						is = openInputStream(filePath, mimeType, mbrSize, fileType);
-					} else if (fileResId > 0) {
-						is = openInputStream(fileResId, mimeType, mbrSize, fileType);
-					}
-					assert is != null;
-
-					// The Init file Input Stream is kept global only in case it was provided
-					// as an argument (separate file for HEX/BIN and DAT files).
-					// If a ZIP file was given with DAT file(s) inside it will be taken from the ZIP
-					// ~20 lines below.
-					if (initFileUri != null) {
-						// Try to read the Init Packet file from URI
-						initIs = getContentResolver().openInputStream(initFileUri);
-					} else if (initFilePath != null) {
-						// Try to read the Init Packet file from path
-						initIs = new FileInputStream(initFilePath);
-					} else if (initFileResId > 0) {
-						// Try to read the Init Packet file from given resource
-						initIs = getResources().openRawResource(initFileResId);
-					}
-
-					final int imageSizeInBytes = is.available();
-					if ((imageSizeInBytes % 4) != 0)
-						throw new SizeValidationException("The new firmware is not word-aligned.");
-				}
-
-				// Update the file type bit field basing on the ZIP content
-				if (MIME_TYPE_ZIP.equals(mimeType)) {
-					final ArchiveInputStream zhis = (ArchiveInputStream) is;
-					if (fileType == TYPE_AUTO) {
-						fileType = zhis.getContentType();
-					} else {
-						fileType = zhis.setContentType(fileType);
-					}
-
-					// Validate sizes
-					if ((fileType & TYPE_APPLICATION) > 0 && (zhis.applicationImageSize() % 4) != 0)
-						throw new SizeValidationException("Application firmware is not word-aligned.");
-					if ((fileType & TYPE_BOOTLOADER) > 0 && (zhis.bootloaderImageSize() % 4) != 0)
-						throw new SizeValidationException("Bootloader firmware is not word-aligned.");
-					if ((fileType & TYPE_SOFT_DEVICE) > 0 && (zhis.softDeviceImageSize() % 4) != 0)
-						throw new SizeValidationException("Soft Device firmware is not word-aligned.");
-
-					if (fileType == TYPE_APPLICATION) {
-						if (zhis.getApplicationInit() != null)
-							initIs = new ByteArrayInputStream(zhis.getApplicationInit());
-					} else {
-						if (zhis.getSystemInit() != null)
-							initIs = new ByteArrayInputStream(zhis.getSystemInit());
-					}
-				}
-
-				// Mark the beginning of the streams. In case the service is restarted, it should
-				// re-upload again the whole file.
-				if (firstRun) {
-					// The input streams will be reset in initialize(), keep
-					is.mark(is.available());
-					if (initIs != null)
-						initIs.mark(initIs.available());
-				}
-
-				mFirmwareInputStream = is;
-				mInitFileInputStream = initIs;
-				sendLogBroadcast(LOG_LEVEL_INFO, "Firmware file opened successfully");
-			} catch (final SecurityException e) {
-				loge("A security exception occurred while opening file", e);
-				sendLogBroadcast(LOG_LEVEL_ERROR, "Opening file failed: Permission required");
-				report(ERROR_FILE_NOT_FOUND);
-				return;
-			} catch (final FileNotFoundException e) {
-				loge("An exception occurred while opening file", e);
-				sendLogBroadcast(LOG_LEVEL_ERROR, "Opening file failed: File not found");
-				report(ERROR_FILE_NOT_FOUND);
-				return;
-			} catch (final SizeValidationException e) {
-				loge("Firmware not word-aligned", e);
-				sendLogBroadcast(LOG_LEVEL_ERROR, "Opening file failed: Firmware size must be word-aligned");
-				report(ERROR_FILE_SIZE_INVALID);
-				return;
-			} catch (final IOException e) {
-				loge("An exception occurred while calculating file size", e);
-				sendLogBroadcast(LOG_LEVEL_ERROR, "Opening file failed: " + e.getLocalizedMessage());
-				report(ERROR_FILE_ERROR);
-				return;
-			} catch (final Exception e) {
-				loge("An exception occurred while opening files. Did you set the firmware file?", e);
-				sendLogBroadcast(LOG_LEVEL_ERROR, "Opening file failed: " + e.getLocalizedMessage());
-				report(ERROR_FILE_ERROR);
-				return;
-			}
-
-			if (!firstRun) {
-				// Wait a second... If we were connected before it's good to give some time before we start reconnecting.
-				waitFor(1000);
-				// Looks like a second is not enough. The ACL_DISCONNECTED broadcast sometimes comes later (on Android 7.0)
-				waitFor(1000);
-			}
-
-			mProgressInfo = new DfuProgressInfo(this);
-
-			if (mAborted) {
-				logw("Upload aborted");
-				sendLogBroadcast(LOG_LEVEL_WARNING, "Upload aborted");
-				mProgressInfo.setProgress(PROGRESS_ABORTED);
-				return;
-			}
-
-			/*
-			 * Now let's connect to the device.
-			 * All the methods below are synchronous. The mLock object is used to wait for asynchronous calls.
-			 */
-			sendLogBroadcast(LOG_LEVEL_VERBOSE, "Connecting to DFU target...");
-			mProgressInfo.setProgress(PROGRESS_CONNECTING);
-
-			final long before = SystemClock.elapsedRealtime();
-			final BluetoothGatt gatt = connect(deviceAddress);
-			final long after = SystemClock.elapsedRealtime();
-			// Are we connected?
-			if (gatt == null) {
-				loge("Bluetooth adapter disabled");
-				sendLogBroadcast(LOG_LEVEL_ERROR, "Bluetooth adapter disabled");
-				report(ERROR_BLUETOOTH_DISABLED);
-				return;
-			}
-			if (mError > 0) { // error occurred
-				if ((mError & ERROR_CONNECTION_STATE_MASK) > 0) {
-					final int error = mError & ~ERROR_CONNECTION_STATE_MASK;
-					logi("Connection error after: " + (after - before) + " ms");
-					final boolean timeout = error == 133 && after > before + 25000; // timeout is 30 sec
-					if (timeout) {
-						loge("Device not reachable. Check if the device with address " + deviceAddress + " is in range, is advertising and is connectable");
-						sendLogBroadcast(LOG_LEVEL_ERROR, "Error 133: Connection timeout");
-					} else {
-						loge("An error occurred while connecting to the device:" + error);
-						sendLogBroadcast(LOG_LEVEL_ERROR, String.format(Locale.US, "Connection failed (0x%02X): %s", error, GattError.parseConnectionError(error)));
-					}
-				} else {
-					final int error = mError & ~ERROR_CONNECTION_MASK;
-					loge("An error occurred during discovering services:" + error);
-					sendLogBroadcast(LOG_LEVEL_ERROR, String.format(Locale.US, "Connection failed (0x%02X): %s", error, GattError.parse(error)));
-				}
-				// Connection usually fails due to a 133 error (device unreachable, or.. something else went wrong).
-				// Usually trying the same for the second time works. Let's try 2 times.
-				final int attempt = intent.getIntExtra(EXTRA_RECONNECTION_ATTEMPT, 0);
-				logi("Attempt: " + (attempt + 1));
-				if (attempt < 2) {
-					sendLogBroadcast(LOG_LEVEL_WARNING, "Retrying...");
-
-					if (mConnectionState != STATE_DISCONNECTED) {
-						// Disconnect from the device
-						disconnect(gatt);
-					}
-					// Close the device
-					refreshDeviceCache(gatt, true);
-					close(gatt);
-
-					logi("Restarting the service");
-					final Intent newIntent = new Intent();
-					newIntent.fillIn(intent, Intent.FILL_IN_COMPONENT | Intent.FILL_IN_PACKAGE);
-					newIntent.putExtra(EXTRA_RECONNECTION_ATTEMPT, attempt + 1);
-					startService(newIntent);
-					return;
-				}
-				terminateConnection(gatt, mError);
-				return;
-			}
-			if (mConnectionState == STATE_DISCONNECTED) {
-				sendLogBroadcast(LOG_LEVEL_ERROR, "Disconnected");
-				terminateConnection(gatt, ERROR_DEVICE_DISCONNECTED);
-				return;
-			}
-			if (mAborted) {
-				logw("Upload aborted");
-				sendLogBroadcast(LOG_LEVEL_WARNING, "Upload aborted");
-				terminateConnection(gatt, 0);
-				mProgressInfo.setProgress(PROGRESS_ABORTED);
-				return;
-			}
-			sendLogBroadcast(LOG_LEVEL_INFO, "Services discovered");
-
-			// Reset the reconnection attempt counter
-			intent.putExtra(EXTRA_RECONNECTION_ATTEMPT, 0);
-
-			DfuService dfuService = null;
-			try {
-				/*
-				 * Device services were discovered. Based on them we may now choose the implementation.
-				 */
-				final DfuServiceProvider serviceProvider = new DfuServiceProvider();
-				mDfuServiceImpl = serviceProvider; // This is required if the provider is now able read data from the device
-				mDfuServiceImpl = dfuService = serviceProvider.getServiceImpl(intent, this, gatt);
-				if (dfuService == null) {
-					Log.w(TAG, "DFU Service not found.");
-					sendLogBroadcast(LOG_LEVEL_WARNING, "DFU Service not found");
-					terminateConnection(gatt, ERROR_SERVICE_NOT_FOUND);
-					return;
-				}
-
-				// Begin the DFU depending on the implementation
-				if (dfuService.initialize(intent, gatt, fileType, is, initIs)) {
-					dfuService.performDfu(intent);
-				}
-			} catch (final UploadAbortedException e) {
-				logw("Upload aborted");
-				sendLogBroadcast(LOG_LEVEL_WARNING, "Upload aborted");
-				terminateConnection(gatt, 0);
-				mProgressInfo.setProgress(PROGRESS_ABORTED);
-			} catch (final DeviceDisconnectedException e) {
-				sendLogBroadcast(LOG_LEVEL_ERROR, "Device has disconnected");
-				loge(e.getMessage());
-				close(gatt);
-
-				final int attempt = intent.getIntExtra(EXTRA_DFU_ATTEMPT, 0);
-				final int limit = intent.getIntExtra(EXTRA_MAX_DFU_ATTEMPTS, 0);
-				if (attempt < limit) {
-					logi("Restarting the service (" + (attempt + 1)  + " /" + limit + ")");
-					final Intent newIntent = new Intent();
-					newIntent.fillIn(intent, Intent.FILL_IN_COMPONENT | Intent.FILL_IN_PACKAGE);
-					newIntent.putExtra(EXTRA_DFU_ATTEMPT, attempt + 1);
-					startService(newIntent);
-					return;
-				}
-				report(ERROR_DEVICE_DISCONNECTED);
-			} catch (final DfuException e) {
-				int error = e.getErrorNumber();
-				// Connection state errors and other Bluetooth GATT callbacks share the same error numbers. Therefore we are using bit masks to identify the type.
-				if ((error & ERROR_CONNECTION_STATE_MASK) > 0) {
-					error &= ~ERROR_CONNECTION_STATE_MASK;
-					sendLogBroadcast(LOG_LEVEL_ERROR, String.format(Locale.US, "Error (0x%02X): %s", error, GattError.parseConnectionError(error)));
-				} else {
-					error &= ~ERROR_CONNECTION_MASK;
-					sendLogBroadcast(LOG_LEVEL_ERROR, String.format(Locale.US, "Error (0x%02X): %s", error, GattError.parse(error)));
-				}
-				loge(e.getMessage());
-				terminateConnection(gatt, e.getErrorNumber() /* we return the whole error number, including the error type mask */);
-			} finally {
-				if (dfuService != null) {
-					dfuService.release();
-				}
-			}
-		} finally {
-			if (foregroundService) {
-				// This will stop foreground state and, if the progress notifications were disabled
-				// it will also remove the notification indicating foreground service.
-				stopForeground(disableNotification);
-			}
-		}
-	}
-
-	/**
-	 * Opens the binary input stream that returns the firmware image content.
-	 * A Path to the file is given.
-	 *
-	 * @param filePath the path to the HEX, BIN or ZIP file.
-	 * @param mimeType the file type.
-	 * @param mbrSize  the size of MBR, by default 0x1000.
-	 * @param types    the content files types in ZIP.
-	 * @return The input stream with binary image content.
-	 */
-	private InputStream openInputStream(@NonNull final String filePath, final String mimeType, final int mbrSize, final int types)
-			throws IOException {
-		final InputStream is = new FileInputStream(filePath);
-		if (MIME_TYPE_ZIP.equals(mimeType))
-			return new ArchiveInputStream(is, mbrSize, types);
-		if (filePath.toLowerCase(Locale.US).endsWith("hex"))
-			return new HexInputStream(is, mbrSize);
-		return is;
-	}
-
-	/**
-	 * Opens the binary input stream. A Uri to the stream is given.
-	 *
-	 * @param stream   the Uri to the stream.
-	 * @param mimeType the file type.
-	 * @param mbrSize  the size of MBR, by default 0x1000.
-	 * @param types    the content files types in ZIP.
-	 * @return The input stream with binary image content.
-	 */
-	private InputStream openInputStream(@NonNull final Uri stream, final String mimeType, final int mbrSize, final int types)
-			throws IOException {
-		final InputStream is = stream.toString().startsWith("file:///android_asset/") ?
-				getAssets().open(stream.getPath().substring(15)) :
-				getContentResolver().openInputStream(stream);
-		assert is != null;
-		if (MIME_TYPE_ZIP.equals(mimeType))
-			return new ArchiveInputStream(is, mbrSize, types);
-
-		final String[] projection = {MediaStore.Images.Media.DISPLAY_NAME};
-		try (Cursor cursor = getContentResolver().query(stream, projection, null, null, null)) {
-			if (cursor != null && cursor.moveToNext()) {
-				final String fileName = cursor.getString(0 /* DISPLAY_NAME*/);
-
-				if (fileName.toLowerCase(Locale.US).endsWith("hex"))
-					return new HexInputStream(is, mbrSize);
-			}
-		}
-		return is;
-	}
-
-	/**
-	 * Opens the binary input stream that returns the firmware image content.
-	 * A resource id in the res/raw is given.
-	 *
-	 * @param resId the if of the resource file.
-	 * @param mimeType the file type.
-	 * @param mbrSize  the size of MBR, by default 0x1000.
-	 * @param types    the content files types in ZIP.
-	 * @return The input stream with binary image content.
-	 */
-	private InputStream openInputStream(final int resId, final String mimeType, final int mbrSize, final int types)
-			throws IOException {
-		final InputStream is = getResources().openRawResource(resId);
-		if (MIME_TYPE_ZIP.equals(mimeType))
-			return new ArchiveInputStream(is, mbrSize, types);
-		is.mark(2);
-		int firstByte = is.read();
-		is.reset();
-		if (firstByte == ':')
-			return new HexInputStream(is, mbrSize);
-		return is;
-	}
-
-	/**
-	 * Connects to the BLE device with given address. This method is SYNCHRONOUS, it wait until
-	 * the connection status change from {@link #STATE_CONNECTING} to
-	 * {@link #STATE_CONNECTED_AND_READY} or an error occurs.
-	 * This method returns <code>null</code> if Bluetooth adapter is disabled.
-	 *
-	 * @param address the device address.
-	 * @return The GATT device or <code>null</code> if Bluetooth adapter is disabled.
-	 */
-	protected BluetoothGatt connect(@NonNull final String address) {
-		if (!mBluetoothAdapter.isEnabled())
-			return null;
-
-		mConnectionState = STATE_CONNECTING;
-
-		logi("Connecting to the device...");
-		final BluetoothDevice device = mBluetoothAdapter.getRemoteDevice(address);
-		BluetoothGatt gatt;
-		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
-			sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt = device.connectGatt(autoConnect = false, TRANSPORT_LE, preferredPhy = LE_1M | LE_2M)");
-			gatt = device.connectGatt(this, false, mGattCallback,
-					BluetoothDevice.TRANSPORT_LE,
-					BluetoothDevice.PHY_LE_1M_MASK | BluetoothDevice.PHY_LE_2M_MASK);
-		} else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-			sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt = device.connectGatt(autoConnect = false, TRANSPORT_LE)");
-			gatt = device.connectGatt(this, false, mGattCallback,
-					BluetoothDevice.TRANSPORT_LE);
-		} else {
-			sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt = device.connectGatt(autoConnect = false)");
-			gatt = device.connectGatt(this, false, mGattCallback);
-		}
-
-		// We have to wait until the device is connected and services are discovered
-		// Connection error may occur as well.
-		try {
-			synchronized (mLock) {
-				while ((mConnectionState == STATE_CONNECTING || mConnectionState == STATE_CONNECTED) && mError == 0 && !mAborted)
-					mLock.wait();
-			}
-		} catch (final InterruptedException e) {
-			loge("Sleeping interrupted", e);
-		}
-		return gatt;
-	}
-
-	/**
-	 * Disconnects from the device and cleans local variables in case of error.
-	 * This method is SYNCHRONOUS and wait until the disconnecting process will be completed.
-	 *
-	 * @param gatt  the GATT device to be disconnected.
-	 * @param error error number.
-	 */
-	protected void terminateConnection(@NonNull final BluetoothGatt gatt, final int error) {
-		if (mConnectionState != STATE_DISCONNECTED) {
-			// Disconnect from the device
-			disconnect(gatt);
-		}
-
-		// Close the device
-		refreshDeviceCache(gatt, false); // This should be set to true when DFU Version is 0.5 or lower
-		close(gatt);
-		waitFor(600);
-		if (error != 0)
-			report(error);
-	}
-
-	/**
-	 * Disconnects from the device. This is SYNCHRONOUS method and waits until the callback returns
-	 * new state. Terminates immediately if device is already disconnected. Do not call this method
-	 * directly, use {@link #terminateConnection(android.bluetooth.BluetoothGatt, int)} instead.
-	 *
-	 * @param gatt the GATT device that has to be disconnected.
-	 */
-	protected void disconnect(@NonNull final BluetoothGatt gatt) {
-		if (mConnectionState == STATE_DISCONNECTED)
-			return;
-
-		sendLogBroadcast(LOG_LEVEL_VERBOSE, "Disconnecting...");
-		mProgressInfo.setProgress(PROGRESS_DISCONNECTING);
-		mConnectionState = STATE_DISCONNECTING;
-
-		logi("Disconnecting from the device...");
-		sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.disconnect()");
-		gatt.disconnect();
-
-		// We have to wait until device gets disconnected or an error occur
-		waitUntilDisconnected();
-		sendLogBroadcast(LOG_LEVEL_INFO, "Disconnected");
-	}
-
-	/**
-	 * Wait until the connection state will change to {@link #STATE_DISCONNECTED} or until
-	 * an error occurs.
-	 */
-	protected void waitUntilDisconnected() {
-		try {
-			synchronized (mLock) {
-				while (mConnectionState != STATE_DISCONNECTED && mError == 0)
-					mLock.wait();
-			}
-		} catch (final InterruptedException e) {
-			loge("Sleeping interrupted", e);
-		}
-	}
-
-	/**
-	 * Wait for given number of milliseconds.
-	 *
-	 * @param millis waiting period.
-	 */
-	protected void waitFor(final long millis) {
-		synchronized (mLock) {
-			try {
-				sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "wait(" + millis + ")");
-				mLock.wait(millis);
-			} catch (final InterruptedException e) {
-				loge("Sleeping interrupted", e);
-			}
-		}
-	}
-
-	/**
-	 * Closes the GATT device and cleans up.
-	 *
-	 * @param gatt the GATT device to be closed.
-	 */
-	protected void close(@NonNull final BluetoothGatt gatt) {
-		logi("Cleaning up...");
-		// Call disconnect() to make sure all resources are released. The device should already be
-		// disconnected, but that's OK.
-		sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.disconnect()");
-		gatt.disconnect();
-		sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.close()");
-		gatt.close();
-		mConnectionState = STATE_CLOSED;
-	}
-
-	/**
-	 * Clears the device cache. After uploading new firmware the DFU target will have other
-	 * services than before.
-	 *
-	 * @param gatt  the GATT device to be refreshed.
-	 * @param force <code>true</code> to force the refresh.
-	 */
-	protected void refreshDeviceCache(@NonNull final BluetoothGatt gatt, final boolean force) {
-		/*
-		 * If the device is bonded this is up to the Service Changed characteristic to notify Android
-		 * that the services has changed. There is no need for this trick in that case.
-		 * If not bonded, the Android should not keep the services cached when the Service Changed
-		 * characteristic is present in the target device database.
-		 * However, due to the Android bug, it is keeping them anyway and the only way to clear
-		 * services is by using this hidden refresh method.
-		 */
-		if (force || gatt.getDevice().getBondState() == BluetoothDevice.BOND_NONE) {
-			sendLogBroadcast(LOG_LEVEL_DEBUG, "gatt.refresh() (hidden)");
-			/*
-			 * There is a refresh() method in BluetoothGatt class but for now it's hidden.
-			 * We will call it using reflections.
-			 */
-			try {
-				//noinspection JavaReflectionMemberAccess
-				final Method refresh = gatt.getClass().getMethod("refresh");
-				//noinspection ConstantConditions
-				final boolean success = (Boolean) refresh.invoke(gatt);
-				logi("Refreshing result: " + success);
-			} catch (final Exception e) {
-				loge("An exception occurred while refreshing device", e);
-				sendLogBroadcast(LOG_LEVEL_WARNING, "Refreshing failed");
-			}
-		}
-	}
-
-	/**
-	 * Creates or updates the notification in the Notification Manager. Sends broadcast with
-	 * given progress state to the activity.
-	 */
-	@Override
-	public void updateProgressNotification() {
-		final DfuProgressInfo info = mProgressInfo;
-		final int progress = info.getProgress();
-		if (mLastProgress == progress)
-			return;
-
-		mLastProgress = progress;
-
-		// send progress or error broadcast
-		sendProgressBroadcast(info);
-
-		if (mDisableNotification)
-			return;
-
-		// the notification may not be refreshed too quickly as the ABORT button becomes not clickable
-		// If new state is an end-state, update regardless so it will not stick around in "Disconnecting" state
-		final long now = SystemClock.elapsedRealtime();
-		if (now - mLastNotificationTime < 250 && !(PROGRESS_COMPLETED == progress || PROGRESS_ABORTED == progress))
-			return;
-		mLastNotificationTime = now;
-
-		// create or update notification:
-		final String deviceAddress = mDeviceAddress;
-		final String deviceName = mDeviceName != null ? mDeviceName : getString(R.string.dfu_unknown_name);
-
-		final NotificationCompat.Builder builder = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_DFU)
-				.setSmallIcon(android.R.drawable.stat_sys_upload).setOnlyAlertOnce(true);//.setLargeIcon(largeIcon);
-		// Android 5
-		builder.setColor(Color.GRAY);
-
-		switch (progress) {
-			case PROGRESS_CONNECTING:
-				builder.setOngoing(true).setContentTitle(getString(R.string.dfu_status_connecting)).setContentText(getString(R.string.dfu_status_connecting_msg, deviceName))
-						.setProgress(100, 0, true);
-				break;
-			case PROGRESS_STARTING:
-				builder.setOngoing(true).setContentTitle(getString(R.string.dfu_status_starting)).setContentText(getString(R.string.dfu_status_starting_msg))
-						.setProgress(100, 0, true);
-				break;
-			case PROGRESS_ENABLING_DFU_MODE:
-				builder.setOngoing(true).setContentTitle(getString(R.string.dfu_status_switching_to_dfu)).setContentText(getString(R.string.dfu_status_switching_to_dfu_msg))
-						.setProgress(100, 0, true);
-				break;
-			case PROGRESS_VALIDATING:
-				builder.setOngoing(true).setContentTitle(getString(R.string.dfu_status_validating)).setContentText(getString(R.string.dfu_status_validating_msg))
-						.setProgress(100, 0, true);
-				break;
-			case PROGRESS_DISCONNECTING:
-				builder.setOngoing(true).setContentTitle(getString(R.string.dfu_status_disconnecting)).setContentText(getString(R.string.dfu_status_disconnecting_msg, deviceName))
-						.setProgress(100, 0, true);
-				break;
-			case PROGRESS_COMPLETED:
-				builder.setOngoing(false).setContentTitle(getString(R.string.dfu_status_completed)).setSmallIcon(android.R.drawable.stat_sys_upload_done)
-						.setContentText(getString(R.string.dfu_status_completed_msg)).setAutoCancel(true).setColor(0xFF00B81A);
-				break;
-			case PROGRESS_ABORTED:
-				builder.setOngoing(false).setContentTitle(getString(R.string.dfu_status_aborted)).setSmallIcon(android.R.drawable.stat_sys_upload_done)
-						.setContentText(getString(R.string.dfu_status_aborted_msg)).setAutoCancel(true);
-				break;
-			default:
-				// progress is in percents
-				final String title = info.getTotalParts() == 1 ? getString(R.string.dfu_status_uploading) : getString(R.string.dfu_status_uploading_part, info.getCurrentPart(), info.getTotalParts());
-				final String text = getString(R.string.dfu_status_uploading_msg, deviceName);
-				builder.setOngoing(true).setContentTitle(title).setContentText(text)
-						.setProgress(100, progress, false);
-				break;
-		}
-
-		// update the notification
-		final Intent intent = new Intent(this, getNotificationTarget());
-		intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-		intent.putExtra(EXTRA_DEVICE_ADDRESS, deviceAddress);
-		intent.putExtra(EXTRA_DEVICE_NAME, deviceName);
-		intent.putExtra(EXTRA_PROGRESS, progress);
-
-		int flags = PendingIntent.FLAG_UPDATE_CURRENT;
-		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-			flags |= PendingIntent.FLAG_IMMUTABLE;
-		}
-		final PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, flags);
-		builder.setContentIntent(pendingIntent);
-
-		// Any additional configuration?
-		updateProgressNotification(builder, progress);
-
-		final NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
-		if (manager != null) {
-			manager.notify(NOTIFICATION_ID, builder.build());
-		}
-	}
-
-	/**
-	 * This method allows you to update the notification showing the upload progress.
-	 *
-	 * @param builder notification builder.
-	 */
-	protected void updateProgressNotification(@NonNull final NotificationCompat.Builder builder, final int progress) {
-		// Add Abort action to the notification
-		if (progress != PROGRESS_ABORTED && progress != PROGRESS_COMPLETED) {
-			final Intent abortIntent = new Intent(BROADCAST_ACTION);
-			abortIntent.putExtra(EXTRA_ACTION, ACTION_ABORT);
-
-			int flags = PendingIntent.FLAG_UPDATE_CURRENT;
-			if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-				flags |= PendingIntent.FLAG_IMMUTABLE;
-			}
-
-			final PendingIntent pendingAbortIntent = PendingIntent.getBroadcast(this, 1, abortIntent, flags);
-			builder.addAction(R.drawable.ic_action_notify_cancel, getString(R.string.dfu_action_abort), pendingAbortIntent);
-		}
-	}
-
-	/**
-	 * Creates or updates the notification in the Notification Manager. Sends broadcast with given
-	 * error number to the activity.
-	 *
-	 * @param error the error number.
-	 */
-	private void report(final int error) {
-		sendErrorBroadcast(error);
-
-		if (mDisableNotification)
-			return;
-
-		// create or update notification:
-		final String deviceAddress = mDeviceAddress;
-		final String deviceName = mDeviceName != null ? mDeviceName : getString(R.string.dfu_unknown_name);
-
-		final NotificationCompat.Builder builder = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_DFU)
-				.setSmallIcon(android.R.drawable.stat_sys_upload)
-				.setOnlyAlertOnce(true)
-				.setColor(Color.RED)
-				.setOngoing(false)
-				.setContentTitle(getString(R.string.dfu_status_error))
-				.setSmallIcon(android.R.drawable.stat_sys_upload_done)
-				.setContentText(getString(R.string.dfu_status_error_msg))
-				.setAutoCancel(true);
-
-		// update the notification
-		final Intent intent = new Intent(this, getNotificationTarget());
-		intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-		intent.putExtra(EXTRA_DEVICE_ADDRESS, deviceAddress);
-		intent.putExtra(EXTRA_DEVICE_NAME, deviceName);
-		intent.putExtra(EXTRA_PROGRESS, error); // this may contains ERROR_CONNECTION_MASK bit!
-
-		int flags = PendingIntent.FLAG_UPDATE_CURRENT;
-		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-			flags |= PendingIntent.FLAG_IMMUTABLE;
-		}
-
-		final PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, intent, flags);
-		builder.setContentIntent(pendingIntent);
-
-		// Any additional configuration?
-		updateErrorNotification(builder);
-
-		final NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
-		if (manager != null) {
-			manager.notify(NOTIFICATION_ID, builder.build());
-		}
-	}
-
-	/**
-	 * This method allows you to update the notification showing an error.
-	 * @param builder error notification builder
-	 */
-	@SuppressWarnings("unused")
-	protected void updateErrorNotification(@NonNull final NotificationCompat.Builder builder) {
-		// Empty default implementation
-	}
-
-	private void startForeground() {
-		final NotificationCompat.Builder builder = new NotificationCompat.Builder(this, NOTIFICATION_CHANNEL_DFU)
-				.setSmallIcon(android.R.drawable.stat_sys_upload)
-				.setContentTitle(getString(R.string.dfu_status_foreground_title)).setContentText(getString(R.string.dfu_status_foreground_content))
-				.setColor(Color.GRAY)
-				.setPriority(NotificationCompat.PRIORITY_LOW)
-				.setOngoing(true);
-
-		// Update the notification
-		final Class<? extends Activity> clazz = getNotificationTarget();
-		if (clazz != null) {
-			final Intent targetIntent = new Intent(this, clazz);
-			targetIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
-			targetIntent.putExtra(EXTRA_DEVICE_ADDRESS, mDeviceAddress);
-			targetIntent.putExtra(EXTRA_DEVICE_NAME, mDeviceName);
-			int flags = PendingIntent.FLAG_UPDATE_CURRENT;
-			if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-				flags |= PendingIntent.FLAG_IMMUTABLE;
-			}
-			final PendingIntent pendingIntent = PendingIntent.getActivity(this, 0, targetIntent, flags);
-			builder.setContentIntent(pendingIntent);
-		} else {
-			logw("getNotificationTarget() should not return null if the service is to be started as a foreground service");
-			// otherwise the notification will not be clickable.
-		}
-
-		// Any additional configuration?
-		updateForegroundNotification(builder);
-
-		startForeground(NOTIFICATION_ID, builder.build());
-	}
-
-	/**
-	 * This method allows you to update the notification that will be shown when the service goes to
-	 * the foreground state.
-	 *
-	 * @param builder foreground notification builder
-	 */
-	@SuppressWarnings("unused")
-	protected void updateForegroundNotification(@NonNull final NotificationCompat.Builder builder) {
-		// Empty default implementation
-	}
-
-	/**
-	 * This method must return the activity class that will be used to create the pending intent
-	 * used as a content intent in the notification showing the upload progress
-	 * or service foreground state. The activity will be launched when user click the notification.
-	 * DfuService will add {@link android.content.Intent#FLAG_ACTIVITY_NEW_TASK} flag and the following extras:
-	 * <ul>
-	 * <li>{@link #EXTRA_DEVICE_ADDRESS} - target device address</li>
-	 * <li>{@link #EXTRA_DEVICE_NAME} - target device name</li>
-	 * <li>{@link #EXTRA_PROGRESS} - the connection state (values &lt; 0)*, current progress (0-100)
-	 * 		or error number if {@link #ERROR_MASK} bit set.</li>
-	 * </ul>
-	 * <p>
-	 * The {@link #EXTRA_PROGRESS} is not set when a notification indicating a foreground service
-	 * was clicked and notifications were disabled using {@link DfuServiceInitiator#setDisableNotification(boolean)}.
-	 * <p>
-	 * If your application disabled DFU notifications by calling
-	 * {@link DfuServiceInitiator#setDisableNotification(boolean)} with parameter <code>true</code> this method
-	 * will still be called if the service was started as foreground service. To disable foreground service
-	 * call {@link DfuServiceInitiator#setForeground(boolean)} with parameter <code>false</code>.
-	 * _______________________________<br>
-	 * * - connection state constants:
-	 * <ul>
-	 * <li>{@link #PROGRESS_CONNECTING}</li>
-	 * <li>{@link #PROGRESS_DISCONNECTING}</li>
-	 * <li>{@link #PROGRESS_COMPLETED}</li>
-	 * <li>{@link #PROGRESS_ABORTED}</li>
-	 * <li>{@link #PROGRESS_STARTING}</li>
-	 * <li>{@link #PROGRESS_ENABLING_DFU_MODE}</li>
-	 * <li>{@link #PROGRESS_VALIDATING}</li>
-	 * </ul>
-	 *
-	 * @return The target activity class.
-	 */
-	@Nullable
-	protected abstract Class<? extends Activity> getNotificationTarget();
-
-	/**
-	 * This method should return the device selector, which is to be used to find the bootloader.
-	 * The default selector will look for a device with the same, or incremented device address.
-	 *
-	 * @return The device selector instance.
-	 * @since 2.1
-	 */
-	@NonNull
-	protected DfuDeviceSelector getDeviceSelector() {
-		return new DfuDefaultDeviceSelector();
-	}
-
-	/**
-	 * Override this method to enable detailed debug LogCat logs with DFU events.
-	 * <p>Recommended use:</p>
-	 * <pre>
-	 * &#64;Override
-	 * protected boolean isDebug() {
-	 *     return BuildConfig.DEBUG;
-	 * }
-	 * </pre>
-	 * @return True to enable LogCat output, false (default) if not.
-	 */
-	protected boolean isDebug() {
-		// Override this method and return true if you need more logs in LogCat
-		// Note: BuildConfig.DEBUG always returns false in library projects, so please use
-		// your app package BuildConfig
-		return false;
-	}
-
-	private void sendProgressBroadcast(final DfuProgressInfo info) {
-		final Intent broadcast = new Intent(BROADCAST_PROGRESS);
-		broadcast.putExtra(EXTRA_DATA, info.getProgress());
-		broadcast.putExtra(EXTRA_DEVICE_ADDRESS, mDeviceAddress);
-		broadcast.putExtra(EXTRA_PART_CURRENT, info.getCurrentPart());
-		broadcast.putExtra(EXTRA_PARTS_TOTAL, info.getTotalParts());
-		broadcast.putExtra(EXTRA_SPEED_B_PER_MS, info.getSpeed());
-		broadcast.putExtra(EXTRA_AVG_SPEED_B_PER_MS, info.getAverageSpeed());
-		LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
-	}
-
-	private void sendErrorBroadcast(final int error) {
-		final Intent broadcast = new Intent(BROADCAST_ERROR);
-		if ((error & ERROR_CONNECTION_MASK) > 0) {
-			broadcast.putExtra(EXTRA_DATA, error & ~ERROR_CONNECTION_MASK);
-			broadcast.putExtra(EXTRA_ERROR_TYPE, ERROR_TYPE_COMMUNICATION);
-		} else if ((error & ERROR_CONNECTION_STATE_MASK) > 0) {
-			broadcast.putExtra(EXTRA_DATA, error & ~ERROR_CONNECTION_STATE_MASK);
-			broadcast.putExtra(EXTRA_ERROR_TYPE, ERROR_TYPE_COMMUNICATION_STATE);
-		} else if ((error & ERROR_REMOTE_MASK) > 0) {
-			broadcast.putExtra(EXTRA_DATA, error & ~ERROR_REMOTE_MASK);
-			broadcast.putExtra(EXTRA_ERROR_TYPE, ERROR_TYPE_DFU_REMOTE);
-		} else {
-			broadcast.putExtra(EXTRA_DATA, error);
-			broadcast.putExtra(EXTRA_ERROR_TYPE, ERROR_TYPE_OTHER);
-		}
-		broadcast.putExtra(EXTRA_DEVICE_ADDRESS, mDeviceAddress);
-		LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
-	}
-
-	/* package */ void sendLogBroadcast(final int level, final String message) {
-		final String fullMessage = "[DFU] " + message;
-		final Intent broadcast = new Intent(BROADCAST_LOG);
-		broadcast.putExtra(EXTRA_LOG_MESSAGE, fullMessage);
-		broadcast.putExtra(EXTRA_LOG_LEVEL, level);
-		broadcast.putExtra(EXTRA_DEVICE_ADDRESS, mDeviceAddress);
-		LocalBroadcastManager.getInstance(this).sendBroadcast(broadcast);
-	}
-
-	/**
-	 * Initializes bluetooth adapter.
-	 *
-	 * @return <code>True</code> if initialization was successful.
-	 */
-	@SuppressWarnings("UnusedReturnValue")
-	private boolean initialize() {
-		// For API level 18 and above, get a reference to BluetoothAdapter through
-		// BluetoothManager.
-		final BluetoothManager bluetoothManager = (BluetoothManager) getSystemService(Context.BLUETOOTH_SERVICE);
-		if (bluetoothManager == null) {
-			loge("Unable to initialize BluetoothManager.");
-			return false;
-		}
-
-		mBluetoothAdapter = bluetoothManager.getAdapter();
-		if (mBluetoothAdapter == null) {
-			loge("Unable to obtain a BluetoothAdapter.");
-			return false;
-		}
-
-		return true;
-	}
-
-	private void loge(final String message) {
-		Log.e(TAG, message);
-	}
-
-	private void loge(final String message, final Throwable e) {
-		Log.e(TAG, message, e);
-	}
-
-	private void logw(final String message) {
-		if (DfuBaseService.DEBUG)
-			Log.w(TAG, message);
-	}
-
-	private void logi(final String message) {
-		if (DfuBaseService.DEBUG)
-			Log.i(TAG, message);
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuCallback.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuCallback.java
deleted file mode 100644
index c5dbb5d..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuCallback.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.bluetooth.BluetoothGattCallback;
-
-/* package */ interface DfuCallback extends DfuController {
-
-	class DfuGattCallback extends BluetoothGattCallback {
-		public void onDisconnected() {
-			// empty initial implementation
-		}
-	}
-
-	/**
-	 * Returns the final BluetoothGattCallback instance, depending on the implementation.
-	 */
-	DfuGattCallback getGattCallback();
-
-	/**
-	 * Callback invoked when bond state changes to
-	 * {@link android.bluetooth.BluetoothDevice#BOND_BONDED BOND_BONDED} or
-     * {@link android.bluetooth.BluetoothDevice#BOND_NONE BOND_NONE}.
-	 */
-	void onBondStateChanged(final int state);
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuController.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuController.java
deleted file mode 100644
index 8c34cf1..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuController.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-public interface DfuController {
-
-	/**
-	 * Pauses the DFU operation. Call {@link #resume()} to resume, or {@link #abort()} to cancel.
-	 * This method does nothing if DFU operation was already paused.
-	 */
-	void pause();
-
-	/**
-	 * Resumes a previously paused DFU operation.
-	 * @see #pause()
-	 */
-	void resume();
-
-	/**
-	 * Aborts the DFU operation after it has started.
-	 */
-	void abort();
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuDefaultDeviceSelector.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuDefaultDeviceSelector.java
deleted file mode 100644
index bc74f39..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuDefaultDeviceSelector.java
+++ /dev/null
@@ -1,25 +0,0 @@
-package no.nordicsemi.android.dfu;
-
-import android.bluetooth.BluetoothDevice;
-
-import androidx.annotation.NonNull;
-
-/**
- * The default device selector looks for a device advertising an incremented address
- * (the original address + 1). By returning a custom selector from
- * {@link DfuBaseService#getDeviceSelector()} the app can override this behavior.
- *
- * @since 2.1
- */
-class DfuDefaultDeviceSelector implements DfuDeviceSelector {
-    @Override
-    public boolean matches(
-            @NonNull final BluetoothDevice device,
-            final int rssi,
-            @NonNull final byte[] scanRecord,
-            @NonNull final String originalAddress,
-            @NonNull final String incrementedAddress) {
-        return originalAddress.equals(device.getAddress()) || incrementedAddress.equals(device.getAddress());
-    }
-}
-
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuDeviceSelector.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuDeviceSelector.java
deleted file mode 100644
index 683c97b..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuDeviceSelector.java
+++ /dev/null
@@ -1,42 +0,0 @@
-package no.nordicsemi.android.dfu;
-
-import android.bluetooth.BluetoothDevice;
-
-import androidx.annotation.NonNull;
-
-/**
- * The device selector can be used to filter scan results when scanning for the device
- * advertising in bootloader mode.
- * <p>
- * By default, the scanner will look for a device advertising an incremented address
- * (the original address + 1). By returning a custom selector from
- * {@link DfuBaseService#getDeviceSelector()} the app can override this behavior.
- *
- * @see DfuDefaultDeviceSelector
- * @since 2.1
- */
-public interface DfuDeviceSelector {
-
-	/**
-	 * This method should return true if the given device matches the expected device in bootloader
-	 * mode.
-	 * <p>
-	 * The advertising data are given as a byte array for backwards compatibility with pre-Lollipop
-	 * devices.
-	 *
-	 * @param device the scanned Bluetooth device.
-	 * @param rssi the received signal strength indicator (RSSI) value for the device.
-	 * @param scanRecord the raw scan record of the device.
-	 * @param originalAddress the MAC address of the device when first connected.
-	 * @param incrementedAddress the incremented address of the device.
-	 * @return true if the device matches the expected device in bootloader mode.
-	 * @since 2.1
-	 */
-	boolean matches(
-			@NonNull final BluetoothDevice device,
-			final int rssi,
-			final @NonNull byte[] scanRecord,
-			final @NonNull String originalAddress,
-			final @NonNull String incrementedAddress
-	);
-}
\ No newline at end of file
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuLogListener.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuLogListener.java
deleted file mode 100644
index 40e8bcb..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuLogListener.java
+++ /dev/null
@@ -1,48 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-/**
- * Listener for log events. This listener should be used instead of creating the
- * BroadcastReceiver on your own.
- *
- * @see DfuServiceListenerHelper
- */
-public interface DfuLogListener {
-	/**
-	 * Method called when a log event was sent from the DFU service.
-	 *
-	 * @param deviceAddress the target device address
-	 * @param level the log level, one of:
-	 * 		<ul>
-	 * 		    <li>{@link DfuBaseService#LOG_LEVEL_DEBUG}</li>
-	 * 		    <li>{@link DfuBaseService#LOG_LEVEL_VERBOSE}</li>
-	 * 		    <li>{@link DfuBaseService#LOG_LEVEL_INFO}</li>
-	 * 		    <li>{@link DfuBaseService#LOG_LEVEL_APPLICATION}</li>
-	 * 		    <li>{@link DfuBaseService#LOG_LEVEL_WARNING}</li>
-	 * 		    <li>{@link DfuBaseService#LOG_LEVEL_ERROR}</li>
-	 * 		</ul>
-	 * @param message the log message
-	 */
-	void onLogEvent(final String deviceAddress, final int level, final String message);
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuProgressInfo.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuProgressInfo.java
deleted file mode 100644
index 43002bf..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuProgressInfo.java
+++ /dev/null
@@ -1,145 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.os.SystemClock;
-import androidx.annotation.NonNull;
-
-/* package */ class DfuProgressInfo {
-	interface ProgressListener {
-		void updateProgressNotification();
-	}
-
-	private final ProgressListener mListener;
-	private int progress;
-	private int bytesSent;
-	private int initialBytesSent;
-	private int lastBytesSent;
-	private int bytesReceived;
-	private int imageSizeInBytes;
-	private int maxObjectSizeInBytes;
-	private int currentPart;
-	private int totalParts;
-	private long timeStart, lastProgressTime;
-
-	DfuProgressInfo(final @NonNull ProgressListener listener) {
-		mListener = listener;
-	}
-
-	void init(final int imageSizeInBytes, final int currentPart, final int totalParts) {
-		this.imageSizeInBytes = imageSizeInBytes;
-		this.maxObjectSizeInBytes = Integer.MAX_VALUE; // by default the whole firmware will be sent as a single object
-		this.currentPart = currentPart;
-		this.totalParts = totalParts;
-	}
-
-	@SuppressWarnings({"UnusedReturnValue", "SameParameterValue"})
-	DfuProgressInfo setTotalPart(final int totalParts) {
-		this.totalParts = totalParts;
-		return this;
-	}
-
-	void setProgress(final int progress) {
-		this.progress = progress;
-		mListener.updateProgressNotification();
-	}
-
-	void setBytesSent(final int bytesSent) {
-		if (timeStart == 0) {
-			timeStart = SystemClock.elapsedRealtime();
-			initialBytesSent = bytesSent;
-		}
-		this.bytesSent = bytesSent;
-		this.progress = (int) (100.0f * bytesSent / imageSizeInBytes);
-		mListener.updateProgressNotification();
-	}
-
-	void addBytesSent(final int increment) {
-		setBytesSent(bytesSent + increment);
-	}
-
-	void setBytesReceived(final int bytesReceived) {
-		this.bytesReceived = bytesReceived;
-	}
-
-	void setMaxObjectSizeInBytes(final int bytes) {
-		this.maxObjectSizeInBytes = bytes;
-	}
-
-	boolean isComplete() {
-		return bytesSent == imageSizeInBytes;
-	}
-
-	boolean isObjectComplete() {
-		return (bytesSent % maxObjectSizeInBytes) == 0;
-	}
-
-	int getAvailableObjectSizeIsBytes() {
-		final int remainingBytes = imageSizeInBytes - bytesSent;
-		final int remainingChunk = maxObjectSizeInBytes - (bytesSent % maxObjectSizeInBytes);
-		return Math.min(remainingBytes, remainingChunk);
-	}
-
-	int getProgress() {
-		return progress;
-	}
-
-	int getBytesSent() {
-		return bytesSent;
-	}
-
-	@SuppressWarnings("unused")
-	int getBytesReceived() {
-		return bytesReceived;
-	}
-
-	@SuppressWarnings("unused")
-	int getImageSizeInBytes() {
-		return imageSizeInBytes;
-	}
-
-	float getSpeed() {
-		final long now = SystemClock.elapsedRealtime();
-		final float speed = now - timeStart != 0 ? (float) (bytesSent - lastBytesSent) / (float) (now - lastProgressTime) : 0.0f;
-		lastProgressTime = now;
-		lastBytesSent = bytesSent;
-		return speed;
-	}
-
-	float getAverageSpeed() {
-		final long now = SystemClock.elapsedRealtime();
-		return now - timeStart != 0 ? (float) (bytesSent - initialBytesSent) / (float) (now - timeStart) : 0.0f;
-	}
-
-	int getCurrentPart() {
-		return currentPart;
-	}
-
-	int getTotalParts() {
-		return totalParts;
-	}
-
-	boolean isLastPart() {
-		return currentPart == totalParts;
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuProgressListener.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuProgressListener.java
deleted file mode 100644
index 72e48f9..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuProgressListener.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import androidx.annotation.NonNull;
-
-/**
- * Listener for status, progress and error events. This listener should be used instead of
- * creating the BroadcastReceiver on your own.
- *
- * @see DfuServiceListenerHelper
- */
-public interface DfuProgressListener {
-
-	/**
-	 * Method called when the DFU service started connecting with the DFU target.
-	 *
-	 * @param deviceAddress the target device address.
-	 */
-	void onDeviceConnecting(@NonNull final String deviceAddress);
-
-	/**
-	 * Method called when the service has successfully connected, discovered services and found
-	 * DFU service on the DFU target.
-	 *
-	 * @param deviceAddress the target device address.
-	 */
-	void onDeviceConnected(@NonNull final String deviceAddress);
-
-	/**
-	 * Method called when the DFU process is starting. This includes reading the DFU Version
-	 * characteristic, sending DFU_START command as well as the Init packet, if set.
-	 *
-	 * @param deviceAddress the target device address.
-	 */
-	void onDfuProcessStarting(@NonNull final String deviceAddress);
-
-	/**
-	 * Method called when the DFU process was started and bytes about to be sent.
-	 *
-	 * @param deviceAddress the target device address
-	 */
-	void onDfuProcessStarted(@NonNull final String deviceAddress);
-
-	/**
-	 * Method called when the service discovered that the DFU target is in the application mode
-     * and must be switched to DFU mode. The switch command will be sent and the DFU process
-     * should start again. There will be no {@link #onDeviceDisconnected(String)} event following
-     * this call.
-	 *
-	 * @param deviceAddress the target device address.
-	 */
-	void onEnablingDfuMode(@NonNull final String deviceAddress);
-
-	/**
-	 * Method called during uploading the firmware. It will not be called twice with the same
-     * value of percent, however, in case of small firmware files, some values may be omitted.
-	 *
-	 * @param deviceAddress the target device address.
-	 * @param percent       the current status of upload (0-99).
-	 * @param speed         the current speed in bytes per millisecond.
-	 * @param avgSpeed      the average speed in bytes per millisecond
-	 * @param currentPart   the number pf part being sent. In case the ZIP file contains a Soft Device
-     *                      and/or a Bootloader together with the application the SD+BL are sent as part 1,
-	 *                      then the service starts again and send the application as part 2.
-	 * @param partsTotal    total number of parts.
-	 */
-	void onProgressChanged(@NonNull final String deviceAddress, final int percent,
-                           final float speed, final float avgSpeed,
-                           final int currentPart, final int partsTotal);
-
-	/**
-	 * Method called when the new firmware is being validated on the target device.
-	 *
-	 * @param deviceAddress the target device address.
-	 */
-	void onFirmwareValidating(@NonNull final String deviceAddress);
-
-	/**
-	 * Method called when the service started to disconnect from the target device.
-	 *
-	 * @param deviceAddress the target device address.
-	 */
-	void onDeviceDisconnecting(final String deviceAddress);
-
-	/**
-	 * Method called when the service disconnected from the device. The device has been reset.
-	 *
-	 * @param deviceAddress the target device address.
-	 */
-	void onDeviceDisconnected(@NonNull final String deviceAddress);
-
-	/**
-	 * Method called when the DFU process succeeded.
-	 *
-	 * @param deviceAddress the target device address.
-	 */
-	void onDfuCompleted(@NonNull final String deviceAddress);
-
-	/**
-	 * Method called when the DFU process has been aborted.
-	 *
-	 * @param deviceAddress the target device address.
-	 */
-	void onDfuAborted(@NonNull final String deviceAddress);
-
-	/**
-	 * Method called when an error occur.
-	 *
-	 * @param deviceAddress the target device address.
-	 * @param error         error number.
-	 * @param errorType     the error type, one of
-     *                      {@link DfuBaseService#ERROR_TYPE_COMMUNICATION_STATE},
-     *                      {@link DfuBaseService#ERROR_TYPE_COMMUNICATION},
-	 *                      {@link DfuBaseService#ERROR_TYPE_DFU_REMOTE},
-     *                      {@link DfuBaseService#ERROR_TYPE_OTHER}.
-	 * @param message       the error message.
-	 */
-	void onError(@NonNull final String deviceAddress,
-                 final int error, final int errorType, final String message);
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuProgressListenerAdapter.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuProgressListenerAdapter.java
deleted file mode 100644
index 2cb76da..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuProgressListenerAdapter.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import androidx.annotation.NonNull;
-
-public class DfuProgressListenerAdapter implements DfuProgressListener {
-
-	@Override
-	public void onDeviceConnecting(@NonNull final String deviceAddress) {
-		// empty default implementation
-	}
-
-	@Override
-	public void onDeviceConnected(@NonNull final String deviceAddress) {
-		// empty default implementation
-	}
-
-	@Override
-	public void onDfuProcessStarting(@NonNull final String deviceAddress) {
-		// empty default implementation
-	}
-
-	@Override
-	public void onDfuProcessStarted(@NonNull final String deviceAddress) {
-		// empty default implementation
-	}
-
-	@Override
-	public void onEnablingDfuMode(@NonNull final String deviceAddress) {
-		// empty default implementation
-	}
-
-	@Override
-	public void onProgressChanged(@NonNull final String deviceAddress, final int percent,
-								  final float speed, final float avgSpeed,
-								  final int currentPart, final int partsTotal) {
-		// empty default implementation
-	}
-
-	@Override
-	public void onFirmwareValidating(@NonNull final String deviceAddress) {
-		// empty default implementation
-	}
-
-	@Override
-	public void onDeviceDisconnecting(final String deviceAddress) {
-		// empty default implementation
-	}
-
-	@Override
-	public void onDeviceDisconnected(@NonNull final String deviceAddress) {
-		// empty default implementation
-	}
-
-	@Override
-	public void onDfuCompleted(@NonNull final String deviceAddress) {
-		// empty default implementation
-	}
-
-	@Override
-	public void onDfuAborted(@NonNull final String deviceAddress) {
-		// empty default implementation
-	}
-
-	@Override
-	public void onError(@NonNull final String deviceAddress,
-						final int error, final int errorType, final String message) {
-		// empty default implementation
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuScope.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuScope.java
deleted file mode 100644
index b8c116b..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuScope.java
+++ /dev/null
@@ -1,15 +0,0 @@
-package no.nordicsemi.android.dfu;
-
-import androidx.annotation.IntDef;
-
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-
-@SuppressWarnings("WeakerAccess")
-@Retention(RetentionPolicy.SOURCE)
-@IntDef(value = {
-            DfuServiceInitiator.SCOPE_SYSTEM_COMPONENTS,
-            DfuServiceInitiator.SCOPE_APPLICATION
-        },
-        flag = true)
-public @interface DfuScope {}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuService.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuService.java
deleted file mode 100644
index 17735f4..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuService.java
+++ /dev/null
@@ -1,81 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.bluetooth.BluetoothGatt;
-import android.content.Intent;
-
-import java.io.InputStream;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
-import no.nordicsemi.android.dfu.internal.exception.DfuException;
-import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
-
-/* package */ interface DfuService extends DfuCallback {
-
-	/**
-	 * This method must return true if the device is compatible with this DFU implementation,
-	 * false otherwise.
-     *
-     * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
-     *                                     the transmission.
-     * @throws DfuException                Thrown if DFU error occur.
-     * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
-	 */
-	boolean isClientCompatible(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt)
-			throws DfuException, DeviceDisconnectedException, UploadAbortedException;
-
-	/**
-	 * Initializes the DFU implementation and does some initial setting up.
-	 *
-	 * @return True if initialization was successful and the DFU process may begin,
-	 * false to finish teh DFU service.
-	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
-	 *                                     the transmission.
-	 * @throws DfuException                Thrown if DFU error occur.
-	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
-	 */
-	boolean initialize(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt,
-					   @FileType final int fileType,
-					   @NonNull final InputStream firmwareStream,
-                       @Nullable final InputStream initPacketStream)
-			throws DfuException, DeviceDisconnectedException, UploadAbortedException;
-
-	/**
-	 * Performs the DFU process.
-	 *
-	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
-	 *                                     the transmission.
-	 * @throws DfuException                Thrown if DFU error occur.
-	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
-	 */
-	void performDfu(@NonNull final Intent intent)
-			throws DfuException, DeviceDisconnectedException, UploadAbortedException;
-
-	/**
-	 * Releases the service.
-	 */
-	void release();
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceController.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceController.java
deleted file mode 100644
index fa9c7b2..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceController.java
+++ /dev/null
@@ -1,97 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.content.Context;
-import android.content.Intent;
-
-import androidx.annotation.NonNull;
-import androidx.localbroadcastmanager.content.LocalBroadcastManager;
-
-/**
- * A controller class allows you to pause, resume or abort the DFU operation in a easy way.
- * <p>
- * Keep in mind that there may be only one DFU operation at a time, and other instances of
- * a DfuServiceController (for example obtained with a previous DFU) will work for all DFU processes,
- * but the {@link #isPaused()} and {@link #isAborted()} methods may report incorrect values.
- * <p>
- * Added in DFU Library version 1.0.2.
- */
-@SuppressWarnings({"WeakerAccess", "unused"})
-public class DfuServiceController implements DfuController {
-	@SuppressWarnings("deprecation")
-	private final LocalBroadcastManager mBroadcastManager;
-	private boolean mPaused;
-	private boolean mAborted;
-
-	/* package */ DfuServiceController(@NonNull final Context context) {
-		//noinspection deprecation
-		mBroadcastManager = LocalBroadcastManager.getInstance(context);
-	}
-
-	@Override
-	public void pause() {
-		if (!mAborted && !mPaused) {
-			mPaused = true;
-			final Intent pauseAction = new Intent(DfuBaseService.BROADCAST_ACTION);
-			pauseAction.putExtra(DfuBaseService.EXTRA_ACTION, DfuBaseService.ACTION_PAUSE);
-			mBroadcastManager.sendBroadcast(pauseAction);
-		}
-	}
-
-	@Override
-	public void resume() {
-		if (!mAborted && mPaused) {
-			mPaused = false;
-			final Intent pauseAction = new Intent(DfuBaseService.BROADCAST_ACTION);
-			pauseAction.putExtra(DfuBaseService.EXTRA_ACTION, DfuBaseService.ACTION_RESUME);
-			mBroadcastManager.sendBroadcast(pauseAction);
-		}
-	}
-
-	@Override
-	public void abort() {
-		if (!mAborted) {
-			mAborted = true;
-			mPaused = false;
-			final Intent pauseAction = new Intent(DfuBaseService.BROADCAST_ACTION);
-			pauseAction.putExtra(DfuBaseService.EXTRA_ACTION, DfuBaseService.ACTION_ABORT);
-			mBroadcastManager.sendBroadcast(pauseAction);
-		}
-	}
-
-	/**
-	 * Returns true if the DFU operation was paused.
-	 * It can be now resumed using {@link #resume()}.
-	 */
-	public boolean isPaused() {
-		return mPaused;
-	}
-
-	/**
-	 * Returns true if DFU was aborted.
-	 */
-	public boolean isAborted() {
-		return mAborted;
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceInitiator.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceInitiator.java
deleted file mode 100644
index 994a8ad..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceInitiator.java
+++ /dev/null
@@ -1,929 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.app.Notification;
-import android.app.NotificationChannel;
-import android.app.NotificationManager;
-import android.bluetooth.BluetoothDevice;
-import android.bluetooth.BluetoothGatt;
-import android.content.Context;
-import android.content.Intent;
-import android.net.Uri;
-import android.os.Build;
-import android.os.ParcelUuid;
-import android.os.Parcelable;
-
-import java.security.InvalidParameterException;
-import java.util.UUID;
-
-import androidx.annotation.IntRange;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.annotation.RawRes;
-import androidx.annotation.RequiresApi;
-
-/**
- * Starting the DfuService service requires a knowledge of some EXTRA_* constants used to pass
- * parameters to the service. The DfuServiceInitiator class may be used to make this process easier.
- * It provides simple API that covers all low lever operations.
- */
-@SuppressWarnings({"WeakerAccess", "unused", "deprecation"})
-public final class DfuServiceInitiator {
-	public static final int DEFAULT_PRN_VALUE = 12;
-	public static final int DEFAULT_MBR_SIZE = 0x1000;
-	public static final long DEFAULT_SCAN_TIMEOUT = 5000; // ms
-
-	/** Constant used to narrow the scope of the update to system components (SD+BL) only. */
-	public static final int SCOPE_SYSTEM_COMPONENTS = 1;
-	/** Constant used to narrow the scope of the update to application only. */
-	public static final int SCOPE_APPLICATION = 2;
-
-	private final String deviceAddress;
-	private String deviceName;
-
-	private boolean disableNotification = false;
-	private boolean startAsForegroundService = true;
-
-	private Uri fileUri;
-	private String filePath;
-	private int fileResId;
-
-	private Uri initFileUri;
-	private String initFilePath;
-	private int initFileResId;
-
-	private String mimeType;
-	private int fileType = -1;
-
-	private boolean keepBond;
-	private boolean restoreBond;
-	private boolean forceDfu = false;
-	private boolean forceScanningForNewAddressInLegacyDfu = false;
-	private boolean enableUnsafeExperimentalButtonlessDfu = false;
-	private boolean disableResume = false;
-	private int numberOfRetries = 0; // 0 to be backwards compatible
-	private int mbrSize = DEFAULT_MBR_SIZE;
-	private long dataObjectDelay = 0; // initially disabled
-	private long rebootTime = 0; // ms
-	private long scanTimeout = DEFAULT_SCAN_TIMEOUT; // ms
-
-	private Boolean packetReceiptNotificationsEnabled;
-	private int numberOfPackets = 12;
-
-	private int mtu = 517;
-	private int currentMtu = 23;
-
-	private Parcelable[] legacyDfuUuids;
-	private Parcelable[] secureDfuUuids;
-	private Parcelable[] experimentalButtonlessDfuUuids;
-	private Parcelable[] buttonlessDfuWithoutBondSharingUuids;
-	private Parcelable[] buttonlessDfuWithBondSharingUuids;
-
-	/**
-	 * Creates the builder. Use setZip(...), or setBinOrHex(...) methods to specify the file you
-	 * want to upload. In the latter case an init file may also be set using the setInitFile(...)
-	 * method. Init files are required by DFU Bootloader version 0.5 or newer (SDK 7.0.0+).
-	 *
-	 * @param deviceAddress the target device device address
-	 */
-	public DfuServiceInitiator(@NonNull final String deviceAddress) {
-		this.deviceAddress = deviceAddress;
-	}
-
-	/**
-	 * Sets the device name. The device name is not required. It's written in the notification
-	 * during the DFU process. If not set the
-	 * {@link no.nordicsemi.android.dfu.R.string#dfu_unknown_name R.string.dfu_unknown_name}
-	 * value will be used.
-	 *
-	 * @param name the device name (optional)
-	 * @return the builder
-	 */
-	public DfuServiceInitiator setDeviceName(@Nullable final String name) {
-		this.deviceName = name;
-		return this;
-	}
-
-	/**
-	 * Sets whether the progress notification in the status bar should be disabled.
-	 * Defaults to false.
-	 *
-	 * @param disableNotification whether to disable the notification
-	 * @return the builder
-	 */
-	public DfuServiceInitiator setDisableNotification(final boolean disableNotification) {
-		this.disableNotification = disableNotification;
-		return this;
-	}
-
-	/**
-	 * Sets whether the DFU service should be started as a foreground service. By default it's
-	 * <i>true</i>. According to
-	 * <a href="https://developer.android.com/about/versions/oreo/background.html">
-	 * https://developer.android.com/about/versions/oreo/background.html</a>
-	 * the background service may be killed by the system on Android Oreo after user quits the
-	 * application so it is recommended to keep it as a foreground service (default) at least on
-	 * Android Oreo+.
-	 *
-	 * @param foreground whether the service should be started in foreground state.
-	 * @return the builder
-	 */
-	public DfuServiceInitiator setForeground(final boolean foreground) {
-		this.startAsForegroundService = foreground;
-		return this;
-	}
-
-	/**
-	 * Sets whether the bond information should be preserver after flashing new application.
-	 * This feature requires Legacy DFU Bootloader version 0.6 or newer (SDK 8.0.0+).
-	 * Please see the {@link DfuBaseService#EXTRA_KEEP_BOND} for more information regarding
-	 * requirements.
-	 * <p>
-	 * This flag is ignored when Secure DFU Buttonless Service is used. It will keep or remove the
-	 * bond depending on the Buttonless service type.
-	 * <p>
-	 * <b>Important:</b> The flag does not ensure that the DFU is performed on an encrypted link.
-	 * If the bond information is present only on Android side, but not on the peripheral side,
-	 * Android (version 4.3-10) will connect without encryption. On those versions it is not possible
-	 * to ensure the link is truly encrypted, as {@link BluetoothDevice#getBondState()} returns
-	 * {@link BluetoothDevice#BOND_BONDED} also if bonding isn't used.
-	 *
-	 * @param keepBond whether the bond information should be preserved in the new application.
-	 * @return the builder
-	 */
-	public DfuServiceInitiator setKeepBond(final boolean keepBond) {
-		this.keepBond = keepBond;
-		return this;
-	}
-
-	/**
-	 * Sets whether a new bond should be created after the DFU is complete. The old bond
-	 * information will be removed before.
-	 * Please see the {@link DfuBaseService#EXTRA_RESTORE_BOND} for more information regarding
-	 * requirements.
-	 * <p>
-	 * This flag is ignored when Secure DFU Buttonless Service is used. It will keep or will not
-	 * restore the bond depending on the Buttonless service type.
-	 *
-	 * @param restoreBond whether the bond should be created after the DFU is complete.
-	 * @return the builder
-	 */
-	public DfuServiceInitiator setRestoreBond(final boolean restoreBond) {
-		this.restoreBond = restoreBond;
-		return this;
-	}
-
-	/**
-	 * This method sets the duration of a delay, that the service will wait before sending each
-	 * data object in Secure DFU. The delay will be done after a data object is created, and before
-	 * any data byte is sent. The default value is 0, which disables this feature.
-	 * <p>
-	 * It has been found, that a delay of at least 300ms reduces the risk of packet lose (the
-	 * bootloader needs some time to prepare flash memory) on DFU bootloader from SDK 15 and 16.
-	 * The delay does not have to be longer than 400 ms, as according to performed tests, such delay
-	 * is sufficient.
-	 * <p>
-	 * The longer the delay, the more time DFU will take to complete (delay will be repeated for
-	 * each data object (4096 bytes)). However, with too small delay a packet lose may occur,
-	 * causing the service to enable PRN and set them to 1 making DFU process very, very slow
-	 * (but reliable).
-	 *
-	 * @param delay the initial delay that the service will wait before sending each data object.
-	 * @since 1.10
-	 * @return the builder
-	 */
-	public DfuServiceInitiator setPrepareDataObjectDelay(final long delay) {
-		this.dataObjectDelay = delay;
-		return this;
-	}
-
-	/**
-	 * Enables or disables the Packet Receipt Notification (PRN) procedure.
-	 * <p>
-	 * By default the PRNs are disabled on devices with Android Marshmallow or newer and enabled on
-	 * older ones.
-	 *
-	 * @param enabled true to enabled PRNs, false to disable
-	 * @return the builder
-	 * @see DfuSettingsConstants#SETTINGS_PACKET_RECEIPT_NOTIFICATION_ENABLED
-	 */
-	public DfuServiceInitiator setPacketsReceiptNotificationsEnabled(final boolean enabled) {
-		this.packetReceiptNotificationsEnabled = enabled;
-		return this;
-	}
-
-	/**
-	 * If Packet Receipt Notification procedure is enabled, this method sets number of packets to
-	 * be sent before receiving a PRN. A PRN is used to synchronize the transmitter and receiver.
-	 * <p>
-	 * If the value given is equal to 0, the {@link #DEFAULT_PRN_VALUE} will be used instead.
-	 * <p>
-	 * To disable PRNs use {@link #setPacketsReceiptNotificationsEnabled(boolean)}.
-	 *
-	 * @param number number of packets to be sent before receiving a PRN. Defaulted when set to 0.
-	 * @return the builder
-	 * @see #setPacketsReceiptNotificationsEnabled(boolean)
-	 * @see DfuSettingsConstants#SETTINGS_NUMBER_OF_PACKETS
-	 */
-	public DfuServiceInitiator setPacketsReceiptNotificationsValue(@IntRange(from = 0) final int number) {
-		this.numberOfPackets = number > 0 ? number : DEFAULT_PRN_VALUE;
-		return this;
-	}
-
-	/**
-	 * Setting force DFU to true will prevent from jumping to the DFU Bootloader
-	 * mode in case there is no DFU Version characteristic (Legacy DFU only!).
-	 * Use it if the DFU operation can be handled by your device running in the application mode.
-	 * <p>
-	 * If the DFU Version characteristic exists, the
-	 * information whether to begin DFU operation, or jump to bootloader, is taken from that
-	 * characteristic's value. The value returned equal to 0x0100 (read as: minor=1, major=0, or
-	 * version 0.1) means that the device is in the application mode and buttonless jump to
-	 * DFU Bootloader is supported.
-	 * <p>
-	 * However, if there is no DFU Version characteristic, a device
-	 * may support only Application update (version from SDK 4.3.0), may support Soft Device,
-	 * Bootloader and Application update but without buttonless jump to bootloader (SDK 6.0.0)
-	 * or with buttonless jump (SDK 6.1.0).
-	 * <p>
-	 * In the last case, the DFU Library determines whether the device is in application mode or in
-	 * DFU Bootloader mode by counting number of services: if no DFU Service found - device is in
-	 * app mode and does not support buttonless jump, if the DFU Service is the only service found
-	 * (except General Access and General Attribute services) - it assumes it is in DFU Bootloader
-	 * mode and may start DFU immediately, if there is at least one service except DFU Service -
-	 * the device is in application mode and supports buttonless jump. In the last case, if you
-	 * want to perform DFU operation without jumping - call the this method with parameter equal
-	 * to true.
-	 * <p>
-	 * This method is ignored in Secure DFU.
-	 *
-	 * @param force true to ensure the DFU will start if there is no DFU Version characteristic
-	 *              (Legacy DFU only)
-	 * @return the builder
-	 * @see DfuSettingsConstants#SETTINGS_ASSUME_DFU_NODE
-	 */
-	public DfuServiceInitiator setForceDfu(final boolean force) {
-		this.forceDfu = force;
-		return this;
-	}
-
-	/**
-	 * Sets the time required by the device to reboot. The library will wait for this time before
-	 * scanning for the device in bootloader mode.
-	 *
-	 * @param rebootTime the reboot time in milliseconds, default 0.
-	 * @return the builder
-	 * @since 2.1
-	 */
-	public DfuServiceInitiator setRebootTime(final long rebootTime) {
-		this.rebootTime = rebootTime;
-		return this;
-	}
-
-	/**
-	 * Sets the scan duration (in milliseconds) when scanning for DFU Bootloader.
-	 *
-	 * @param scanTimeout the scan duration in milliseconds, default {@value #DEFAULT_SCAN_TIMEOUT} ms.
-	 * @return the builder
-	 * @since 2.1
-	 */
-	public DfuServiceInitiator setScanTimeout(final long scanTimeout) {
-		this.scanTimeout = scanTimeout;
-		return this;
-	}
-
-	/**
-	 * When this is set to true, the Legacy Buttonless Service will scan for the device advertising
-	 * with an incremented MAC address, instead of trying to reconnect to the same device.
-	 * <p>
-	 * Setting this to true requires modifying the buttonless service on the device not to share the
-	 * peer data with the bootloader, or modifying the bootloader to always advertise with MAC+1.
-	 * Setting it to true with a default implementation of the buttonless service should work, but
-	 * is pointless.
-	 * <p>
-	 * This is a feature equivalent to
-	 * <a href="https://github.com/NordicSemiconductor/IOS-Pods-DFU-Library/pull/374">PR #374</a>
-	 * in DFU library for iOS.
-	 * @param force set to true when your bootloader is advertising with an incremented MAC address.
-	 *              By default, in Legacy DFU, the bootloader uses the same MAC address and is
-	 *              advertising directly. This does not seen to work on some phones (Samsung) with
-	 *              recent Android versions.
-	 * @return the builder
-	 */
-	public DfuServiceInitiator setForceScanningForNewAddressInLegacyDfu(final boolean force) {
-		this.forceScanningForNewAddressInLegacyDfu = force;
-		return this;
-	}
-
-	/**
-	 * This options allows to disable the resume feature in Secure DFU. When the extra value is set
-	 * to true, the DFU will send Init Packet and Data again, despite the firmware might have been
-	 * send partially before. By default, without setting this extra, or by setting it to false,
-	 * the DFU will resume the previously cancelled upload if CRC values match.
-	 * <p>
-	 * It is ignored when Legacy DFU is used.
-	 * <p>
-	 * This feature seems to help in some cases:
-	 * <a href="https://github.com/NordicSemiconductor/Android-DFU-Library/issues/71">#71</a>.
-	 *
-	 * @return the builder
-	 */
-	public DfuServiceInitiator disableResume() {
-		this.disableResume = true;
-		return this;
-	}
-
-	/**
-	 * Sets the number of retries that the DFU service will use to complete DFU. The default
-	 * value is 0, for backwards compatibility reason.
-	 * <p>
-	 * If the given value is greater than 0, the service will restart itself at most {@code max}
-	 * times in case of an undesired disconnection during DFU operation. This attempt counter
-	 * is independent from another counter, for reconnection attempts, which is equal to 3.
-	 * The latter one will be used when connection will fail with an error (possible packet
-	 * collision or any other reason). After successful connection, the reconnection counter is
-	 * reset, while the retry counter is cleared after a DFU finishes with success.
-	 * <p>
-	 * The service will not try to retry DFU in case of any other error, for instance an error
-	 * sent from the target device.
-	 *
-	 * @param max Maximum number of retires to complete DFU. Usually around 2.
-	 * @return the builder
-	 */
-	public DfuServiceInitiator setNumberOfRetries(@IntRange(from = 0) final int max) {
-		this.numberOfRetries = max;
-		return this;
-	}
-
-	/**
-	 * Sets the Maximum Transfer Unit (MTU) value that the Secure DFU service will try to request
-	 * before performing DFU. By default, value 517 will be used, which is the highest supported
-	 * by Android. However, as the highest supported MTU by the Secure DFU from SDK 15
-	 * (first which supports higher MTU) is 247, the sides will agree on using MTU = 247 instead
-	 * if the phone supports it (Lollipop or newer device).
-	 * <p>
-	 * The higher the MTU, the faster the data may be sent.
-	 * <p>
-	 * If you encounter problems with high MTU, you may lower the required value using this method.
-	 * See: https://github.com/NordicSemiconductor/Android-DFU-Library/issues/111
-	 * <p>
-	 * To disable requesting MTU, use value 0, or {@link #disableMtuRequest()}.
-	 * <p>
-	 * Note: Higher (that is greater then 23) MTUs are supported on Lollipop or newer Android
-	 * devices, and on DFU bootloader from SDK 15 or newer (Secure DFU only).
-	 *
-	 * @param mtu the MTU that wil be requested, 0 to disable MTU request.
-	 * @return the builder
-	 */
-	public DfuServiceInitiator setMtu(@IntRange(from = 23, to = 517) final int mtu) {
-		this.mtu = mtu;
-		return this;
-	}
-
-	/**
-	 * Sets the current MTU value. This method should be used only if the device is already
-	 * connected and MTU has been requested before DFU service is started.
-	 * The SoftDevice allows to change MTU only once, while the following requests fail with
-	 * Invalid PDU error. In case this error is received, the MTU will be set to the value
-	 * specified using this method. There is no verification of this value. If it's set to
-	 * too high value, some of the packets will not be sent and DFU will not succeed.
-	 * <p>
-	 * By default value 23 is used for compatibility reasons.
-	 * <p>
-	 * Higher MTU values were supported since SDK 15.0.
-	 *
-	 * @param mtu the MTU value received in
-	 *            {@link android.bluetooth.BluetoothGattCallback#onMtuChanged(BluetoothGatt, int, int)} or
-	 *            {@link android.bluetooth.BluetoothGattServerCallback#onMtuChanged(BluetoothDevice, int)}.
-	 * @return the builder
-	 */
-	public DfuServiceInitiator setCurrentMtu(@IntRange(from = 23, to = 517) final int mtu) {
-		this.currentMtu = mtu;
-		return this;
-	}
-
-	/**
-	 * Disables MTU request.
-	 *
-	 * @return the builder
-	 * @see #setMtu(int)
-	 */
-	public DfuServiceInitiator disableMtuRequest() {
-		this.mtu = 0;
-		return this;
-	}
-
-	/**
-	 * This method allows to narrow the update to selected parts from the ZIP, for example
-	 * to allow only application update from a ZIP file that has SD+BL+App. System components scope
-	 * include the Softdevice and/or the Bootloader (they can't be separated as they are packed in
-	 * a single bin file and the library does not know whether it contains only the softdevice,
-	 * the bootloader or both) Application scope includes the application only.
-	 *
-	 * @param scope the update scope, one of {@link #SCOPE_SYSTEM_COMPONENTS} or
-	 *              {@link #SCOPE_APPLICATION}.
-	 * @return the builder
-	 */
-	public DfuServiceInitiator setScope(@DfuScope final int scope) {
-		if (!DfuBaseService.MIME_TYPE_ZIP.equals(mimeType))
-			throw new UnsupportedOperationException("Scope can be set only for a ZIP file");
-		if (scope == SCOPE_APPLICATION)
-			fileType = DfuBaseService.TYPE_APPLICATION;
-		else if (scope == SCOPE_SYSTEM_COMPONENTS)
-			fileType = DfuBaseService.TYPE_SOFT_DEVICE | DfuBaseService.TYPE_BOOTLOADER;
-		else if (scope == (SCOPE_APPLICATION | SCOPE_SYSTEM_COMPONENTS))
-			fileType = DfuBaseService.TYPE_AUTO;
-		else throw new UnsupportedOperationException("Unknown scope");
-		return this;
-	}
-
-	/**
-	 * This method sets the size of an MBR (Master Boot Record). It should be used only
-	 * when updating a file from a HEX file. If you use BIN or ZIP, value set here will
-	 * be ignored.
-	 * <p>
-	 * The MBR size is important for the HEX parser, which has to cut it from the Soft Device's
-	 * HEX before sending it to the DFU target. The MBR can't be updated using DFU, and the
-	 * bootloader expects only the Soft Device bytes. Usually, the Soft Device HEX provided
-	 * by Nordic contains an MBR at addresses 0x0000 to 0x1000.
-	 * 0x1000 is the default size of MBR which will be used.
-	 * <p>
-	 * If you have a HEX file which address start from 0 and want to send the whole BIN content
-	 * from it, you have to set the MBR size to 0, otherwise first 4096 bytes will be cut off.
-	 * <p>
-	 * The value set here will not be used if the {@link DfuSettingsConstants#SETTINGS_MBR_SIZE}
-	 * is set in Shared Preferences.
-	 *
-	 * @param mbrSize the MBR size in bytes. Defaults to 4096 (0x1000) bytes.
-	 * @return the builder
-	 * @see DfuSettingsConstants#SETTINGS_MBR_SIZE
-	 */
-	public DfuServiceInitiator setMbrSize(@IntRange(from = 0) final int mbrSize) {
-		this.mbrSize = mbrSize;
-		return this;
-	}
-
-	/**
-	 * Set this flag to true to enable experimental buttonless feature in Secure DFU. When the
-	 * experimental Buttonless DFU Service is found on a device, the service will use it to
-	 * switch the device to the bootloader mode, connect to it in that mode and proceed with DFU.
-	 * <p>
-	 * <b>Please, read the information below before setting it to true.</b>
-	 * <p>
-	 * In the SDK 12.x the Buttonless DFU feature for Secure DFU was experimental.
-	 * It is NOT recommended to use it: it was not properly tested, had implementation bugs (e.g.
-	 * <a href="https://devzone.nordicsemi.com/question/100609/sdk-12-bootloader-erased-after-programming/">link</a>)
-	 * and does not required encryption and therefore may lead to DOS attack (anyone can use it to
-	 * switch the device to bootloader mode). However, as there is no other way to trigger
-	 * bootloader mode on devices without a button, this DFU Library supports this service, but the
-	 * feature must be explicitly enabled here. Be aware, that setting this flag to false will no
-	 * protect your devices from this kind of attacks, as an attacker may use another app for that
-	 * purpose. To be sure your device is secure remove this experimental service from your device.
-	 * <p>
-	 * <b>Spec:</b><br>
-	 * Buttonless DFU Service UUID: 8E400001-F315-4F60-9FB8-838830DAEA50<br>
-	 * Buttonless DFU characteristic UUID: 8E400001-F315-4F60-9FB8-838830DAEA50 (the same)<br>
-	 * Enter Bootloader Op Code: 0x01<br>
-	 * Correct return value: 0x20-01-01 , where:<br>
-	 * 0x20 - Response Op Code<br>
-	 * 0x01 - Request Code<br>
-	 * 0x01 - Success<br>
-	 * The device should disconnect and restart in DFU mode after sending the notification.
-	 * <p>
-	 * The Buttonless service has changed in SDK 13 and later. Indications are used instead of
-	 * notifications. Also, Buttonless service for bonded devices has been added.
-	 * It is recommended to use any of the new services instead.
-	 *
-	 * @return the builder
-	 */
-	public DfuServiceInitiator setUnsafeExperimentalButtonlessServiceInSecureDfuEnabled(final boolean enable) {
-		this.enableUnsafeExperimentalButtonlessDfu = enable;
-		return this;
-	}
-
-	/**
-	 * Sets custom UUIDs for Legacy DFU and Legacy Buttonless DFU. Use this method if your DFU
-	 * implementation uses different UUID for at least one of the given UUIDs.
-	 * Parameter set to <code>null</code> will reset the UUID to the default value.
-	 *
-	 * @param dfuServiceUuid      custom Legacy DFU service UUID or null, if default is to be used
-	 * @param dfuControlPointUuid custom Legacy DFU Control Point characteristic UUID or null,
-	 *                            if default is to be used
-	 * @param dfuPacketUuid       custom Legacy DFU Packet characteristic UUID or null, if default is
-	 *                            to be used
-	 * @param dfuVersionUuid      custom Legacy DFU Version characteristic UUID or null,
-	 *                            if default is to be used (SDK 7.0 - 11.0 only, set null for earlier SDKs)
-	 * @return the builder
-	 */
-	public DfuServiceInitiator setCustomUuidsForLegacyDfu(@Nullable final UUID dfuServiceUuid,
-														  @Nullable final UUID dfuControlPointUuid,
-														  @Nullable final UUID dfuPacketUuid,
-														  @Nullable final UUID dfuVersionUuid) {
-		final ParcelUuid[] uuids = new ParcelUuid[4];
-		uuids[0] = dfuServiceUuid      != null ? new ParcelUuid(dfuServiceUuid)      : null;
-		uuids[1] = dfuControlPointUuid != null ? new ParcelUuid(dfuControlPointUuid) : null;
-		uuids[2] = dfuPacketUuid       != null ? new ParcelUuid(dfuPacketUuid)       : null;
-		uuids[3] = dfuVersionUuid      != null ? new ParcelUuid(dfuVersionUuid)      : null;
-		legacyDfuUuids = uuids;
-		return this;
-	}
-
-	/**
-	 * Sets custom UUIDs for Secure DFU. Use this method if your DFU implementation uses different
-	 * UUID for at least one of the given UUIDs. Parameter set to <code>null</code> will reset
-	 * the UUID to the default value.
-	 *
-	 * @param dfuServiceUuid      custom Secure DFU service UUID or null, if default is to be used
-	 * @param dfuControlPointUuid custom Secure DFU Control Point characteristic UUID or null,
-	 *                            if default is to be used
-	 * @param dfuPacketUuid       custom Secure DFU Packet characteristic UUID or null, if default
-	 *                            is to be used
-	 * @return the builder
-	 */
-	public DfuServiceInitiator setCustomUuidsForSecureDfu(@Nullable final UUID dfuServiceUuid,
-														  @Nullable final UUID dfuControlPointUuid,
-														  @Nullable final UUID dfuPacketUuid) {
-		final ParcelUuid[] uuids = new ParcelUuid[3];
-		uuids[0] = dfuServiceUuid      != null ? new ParcelUuid(dfuServiceUuid)      : null;
-		uuids[1] = dfuControlPointUuid != null ? new ParcelUuid(dfuControlPointUuid) : null;
-		uuids[2] = dfuPacketUuid       != null ? new ParcelUuid(dfuPacketUuid)       : null;
-		secureDfuUuids = uuids;
-		return this;
-	}
-
-	/**
-	 * Sets custom UUIDs for the experimental Buttonless DFU Service from SDK 12.x. Use this method
-	 * if your DFU implementation uses different UUID for at least one of the given UUIDs.
-	 * Parameter set to <code>null</code> will reset the UUID to the default value.
-	 * <p>
-	 * Remember to call {@link #setUnsafeExperimentalButtonlessServiceInSecureDfuEnabled(boolean)}
-	 * with parameter <code>true</code> if you intent to use this service.
-	 *
-	 * @param buttonlessDfuServiceUuid      custom Buttonless DFU service UUID or null, if default
-	 *                                      is to be used
-	 * @param buttonlessDfuControlPointUuid custom Buttonless DFU characteristic UUID or null,
-	 *                                      if default is to be used
-	 * @return the builder
-	 */
-	public DfuServiceInitiator setCustomUuidsForExperimentalButtonlessDfu(@Nullable final UUID buttonlessDfuServiceUuid,
-																		  @Nullable final UUID buttonlessDfuControlPointUuid) {
-		final ParcelUuid[] uuids = new ParcelUuid[2];
-		uuids[0] = buttonlessDfuServiceUuid      != null ? new ParcelUuid(buttonlessDfuServiceUuid)      : null;
-		uuids[1] = buttonlessDfuControlPointUuid != null ? new ParcelUuid(buttonlessDfuControlPointUuid) : null;
-		experimentalButtonlessDfuUuids = uuids;
-		return this;
-	}
-
-	/**
-	 * Sets custom UUIDs for the Buttonless DFU Service from SDK 14 (or later).
-	 * Use this method if your DFU implementation uses different UUID for at least one of the given
-	 * UUIDs. Parameter set to <code>null</code> will reset the UUID to the default value.
-	 *
-	 * @param buttonlessDfuServiceUuid      custom Buttonless DFU service UUID or null, if default
-	 *                                      is to be used
-	 * @param buttonlessDfuControlPointUuid custom Buttonless DFU characteristic UUID or null,
-	 *                                      if default is to be used
-	 * @return the builder
-	 */
-	public DfuServiceInitiator setCustomUuidsForButtonlessDfuWithBondSharing(@Nullable final UUID buttonlessDfuServiceUuid,
-																			 @Nullable final UUID buttonlessDfuControlPointUuid) {
-		final ParcelUuid[] uuids = new ParcelUuid[2];
-		uuids[0] = buttonlessDfuServiceUuid      != null ? new ParcelUuid(buttonlessDfuServiceUuid)      : null;
-		uuids[1] = buttonlessDfuControlPointUuid != null ? new ParcelUuid(buttonlessDfuControlPointUuid) : null;
-		buttonlessDfuWithBondSharingUuids = uuids;
-		return this;
-	}
-
-	/**
-	 * Sets custom UUIDs for the Buttonless DFU Service from SDK 13. Use this method if your DFU
-	 * implementation uses different UUID for at least one of the given UUIDs.
-	 * Parameter set to <code>null</code> will reset the UUID to the default value.
-	 *
-	 * @param buttonlessDfuServiceUuid      custom Buttonless DFU service UUID or null, if default
-	 *                                      is to be used
-	 * @param buttonlessDfuControlPointUuid custom Buttonless DFU characteristic UUID or null,
-	 *                                      if default is to be used
-	 * @return the builder
-	 */
-	public DfuServiceInitiator setCustomUuidsForButtonlessDfuWithoutBondSharing(@Nullable final UUID buttonlessDfuServiceUuid,
-																				@Nullable final UUID buttonlessDfuControlPointUuid) {
-		final ParcelUuid[] uuids = new ParcelUuid[2];
-		uuids[0] = buttonlessDfuServiceUuid      != null ? new ParcelUuid(buttonlessDfuServiceUuid)      : null;
-		uuids[1] = buttonlessDfuControlPointUuid != null ? new ParcelUuid(buttonlessDfuControlPointUuid) : null;
-		buttonlessDfuWithoutBondSharingUuids = uuids;
-		return this;
-	}
-
-	/**
-	 * Sets the URI to the Distribution packet (ZIP) or to a ZIP file matching the deprecated naming
-	 * convention.
-	 *
-	 * @param uri the URI of the file
-	 * @return the builder
-	 * @see #setZip(String)
-	 * @see #setZip(int)
-	 */
-	public DfuServiceInitiator setZip(@NonNull final Uri uri) {
-		return init(uri, null, 0, DfuBaseService.TYPE_AUTO, DfuBaseService.MIME_TYPE_ZIP);
-	}
-
-	/**
-	 * Sets the path to the Distribution packet (ZIP) or the a ZIP file matching the deprecated naming
-	 * convention.
-	 *
-	 * @param path path to the file
-	 * @return the builder
-	 * @see #setZip(Uri)
-	 * @see #setZip(int)
-	 */
-	public DfuServiceInitiator setZip(@NonNull final String path) {
-		return init(null, path, 0, DfuBaseService.TYPE_AUTO, DfuBaseService.MIME_TYPE_ZIP);
-	}
-
-	/**
-	 * Sets the resource ID of the Distribution packet (ZIP) or the a ZIP file matching the
-	 * deprecated naming convention. The file should be in the /res/raw folder.
-	 *
-	 * @param rawResId file's resource ID
-	 * @return the builder
-	 * @see #setZip(Uri)
-	 * @see #setZip(String)
-	 */
-	public DfuServiceInitiator setZip(@RawRes final int rawResId) {
-		return init(null, null, rawResId, DfuBaseService.TYPE_AUTO, DfuBaseService.MIME_TYPE_ZIP);
-	}
-
-	/**
-	 * Sets the URI or path of the ZIP file.
-	 * At least one of the parameters must not be null.
-	 * If the URI and path are not null the URI will be used.
-	 *
-	 * @param uri  the URI of the file
-	 * @param path the path of the file
-	 * @return the builder
-	 */
-	public DfuServiceInitiator setZip(@Nullable final Uri uri, @Nullable final String path) {
-		return init(uri, path, 0, DfuBaseService.TYPE_AUTO, DfuBaseService.MIME_TYPE_ZIP);
-	}
-
-	/**
-	 * Sets the URI of the BIN or HEX file containing the new firmware.
-	 * For DFU Bootloader version 0.5 or newer the init file must be specified using one of
-	 * {@link #setInitFile(Uri)} methods.
-	 *
-	 * @param fileType the file type, a bit field created from:
-	 *                 <ul>
-	 *                 <li>{@link DfuBaseService#TYPE_APPLICATION} - the Application will be sent</li>
-	 *                 <li>{@link DfuBaseService#TYPE_SOFT_DEVICE} - he Soft Device will be sent</li>
-	 *                 <li>{@link DfuBaseService#TYPE_BOOTLOADER} - the Bootloader will be sent</li>
-	 *                 </ul>
-	 * @param uri      the URI of the file
-	 * @return the builder
-	 */
-	@Deprecated
-	public DfuServiceInitiator setBinOrHex(@FileType final int fileType, @NonNull final Uri uri) {
-		if (fileType == DfuBaseService.TYPE_AUTO)
-			throw new UnsupportedOperationException("You must specify the file type");
-		return init(uri, null, 0, fileType, DfuBaseService.MIME_TYPE_OCTET_STREAM);
-	}
-
-	/**
-	 * Sets the URI of the BIN or HEX file containing the new firmware.
-	 * For DFU Bootloader version 0.5 or newer the init file must be specified using one of
-	 * {@link #setInitFile(String)} methods.
-	 *
-	 * @param fileType see {@link #setBinOrHex(int, Uri)} for details
-	 * @param path     path to the file
-	 * @return the builder
-	 */
-	@Deprecated
-	public DfuServiceInitiator setBinOrHex(@FileType final int fileType, @NonNull final String path) {
-		if (fileType == DfuBaseService.TYPE_AUTO)
-			throw new UnsupportedOperationException("You must specify the file type");
-		return init(null, path, 0, fileType, DfuBaseService.MIME_TYPE_OCTET_STREAM);
-	}
-
-	/**
-	 * Sets the URI or path to the BIN or HEX file containing the new firmware.
-	 * For DFU Bootloader version 0.5 or newer the init file must be specified using one of
-	 * {@link #setInitFile(String)} methods.
-	 *
-	 * @param fileType see {@link #setBinOrHex(int, Uri)} for details
-	 * @param uri      the URI of the file
-	 * @param path     path to the file
-	 * @return the builder
-	 * @deprecated The Distribution packet (ZIP) should be used for DFU Bootloader version 0.5 or newer
-	 */
-	@Deprecated
-	public DfuServiceInitiator setBinOrHex(@FileType final int fileType, @Nullable final Uri uri, @Nullable final String path) {
-		if (fileType == DfuBaseService.TYPE_AUTO)
-			throw new UnsupportedOperationException("You must specify the file type");
-		return init(uri, path, 0, fileType, DfuBaseService.MIME_TYPE_OCTET_STREAM);
-	}
-
-	/**
-	 * Sets the resource ID pointing the BIN or HEX file containing the new firmware.
-	 * The file should be in the /res/raw folder. For DFU Bootloader version 0.5 or newer the init
-	 * file must be specified using one of {@link #setInitFile(int)} methods.
-	 *
-	 * @param fileType see {@link #setBinOrHex(int, Uri)} for details
-	 * @param rawResId resource ID
-	 * @return the builder
-	 */
-	@Deprecated
-	public DfuServiceInitiator setBinOrHex(@FileType final int fileType, @RawRes final int rawResId) {
-		if (fileType == DfuBaseService.TYPE_AUTO)
-			throw new UnsupportedOperationException("You must specify the file type");
-		return init(null, null, rawResId, fileType, DfuBaseService.MIME_TYPE_OCTET_STREAM);
-	}
-
-	/**
-	 * Sets the URI of the Init file. The init file for DFU Bootloader version pre-0.5
-	 * (SDK 4.3, 6.0, 6.1) contains only the CRC-16 of the firmware.
-	 * Bootloader version 0.5 or newer requires the Extended Init Packet.
-	 *
-	 * @param initFileUri the URI of the init file
-	 * @return the builder
-	 */
-	@Deprecated
-	public DfuServiceInitiator setInitFile(@NonNull final Uri initFileUri) {
-		return init(initFileUri, null, 0);
-	}
-
-	/**
-	 * Sets the path to the Init file. The init file for DFU Bootloader version pre-0.5
-	 * (SDK 4.3, 6.0, 6.1) contains only the CRC-16 of the firmware.
-	 * Bootloader version 0.5 or newer requires the Extended Init Packet.
-	 *
-	 * @param initFilePath the path to the init file
-	 * @return the builder
-	 */
-	@Deprecated
-	public DfuServiceInitiator setInitFile(@Nullable final String initFilePath) {
-		return init(null, initFilePath, 0);
-	}
-
-	/**
-	 * Sets the resource ID of the Init file. The init file for DFU Bootloader version pre-0.5
-	 * (SDK 4.3, 6.0, 6.1) contains only the CRC-16 of the firmware.
-	 * Bootloader version 0.5 or newer requires the Extended Init Packet.
-	 *
-	 * @param initFileResId the resource ID of the init file
-	 * @return the builder
-	 */
-	@Deprecated
-	public DfuServiceInitiator setInitFile(@RawRes final int initFileResId) {
-		return init(null, null, initFileResId);
-	}
-
-	/**
-	 * Sets the URI or path to the Init file. The init file for DFU Bootloader version pre-0.5
-	 * (SDK 4.3, 6.0, 6.1) contains only the CRC-16 of the firmware. Bootloader version 0.5 or newer
-	 * requires the Extended Init Packet. If the URI and path are not null the URI will be used.
-	 *
-	 * @param initFileUri  the URI of the init file
-	 * @param initFilePath the path of the init file
-	 * @return the builder
-	 */
-	@Deprecated
-	public DfuServiceInitiator setInitFile(@Nullable final Uri initFileUri, @Nullable final String initFilePath) {
-		return init(initFileUri, initFilePath, 0);
-	}
-
-	/**
-	 * Starts the DFU service.
-	 *
-	 * @param context the application context
-	 * @param service the class derived from the BaseDfuService
-	 */
-	public DfuServiceController start(@NonNull final Context context, @NonNull final Class<? extends DfuBaseService> service) {
-		if (fileType == -1)
-			throw new UnsupportedOperationException("You must specify the firmware file before starting the service");
-
-		final Intent intent = new Intent(context, service);
-
-		intent.putExtra(DfuBaseService.EXTRA_DEVICE_ADDRESS, deviceAddress);
-		intent.putExtra(DfuBaseService.EXTRA_DEVICE_NAME, deviceName);
-		intent.putExtra(DfuBaseService.EXTRA_DISABLE_NOTIFICATION, disableNotification);
-		intent.putExtra(DfuBaseService.EXTRA_FOREGROUND_SERVICE, startAsForegroundService);
-		intent.putExtra(DfuBaseService.EXTRA_FILE_MIME_TYPE, mimeType);
-		intent.putExtra(DfuBaseService.EXTRA_FILE_TYPE, fileType);
-		intent.putExtra(DfuBaseService.EXTRA_FILE_URI, fileUri);
-		intent.putExtra(DfuBaseService.EXTRA_FILE_PATH, filePath);
-		intent.putExtra(DfuBaseService.EXTRA_FILE_RES_ID, fileResId);
-		intent.putExtra(DfuBaseService.EXTRA_INIT_FILE_URI, initFileUri);
-		intent.putExtra(DfuBaseService.EXTRA_INIT_FILE_PATH, initFilePath);
-		intent.putExtra(DfuBaseService.EXTRA_INIT_FILE_RES_ID, initFileResId);
-		intent.putExtra(DfuBaseService.EXTRA_KEEP_BOND, keepBond);
-		intent.putExtra(DfuBaseService.EXTRA_RESTORE_BOND, restoreBond);
-		intent.putExtra(DfuBaseService.EXTRA_FORCE_DFU, forceDfu);
-		intent.putExtra(DfuBaseService.EXTRA_FORCE_SCANNING_FOR_BOOTLOADER_IN_LEGACY_DFU, forceScanningForNewAddressInLegacyDfu);
-		intent.putExtra(DfuBaseService.EXTRA_DISABLE_RESUME, disableResume);
-		intent.putExtra(DfuBaseService.EXTRA_MAX_DFU_ATTEMPTS, numberOfRetries);
-		intent.putExtra(DfuBaseService.EXTRA_MBR_SIZE, mbrSize);
-		intent.putExtra(DfuBaseService.EXTRA_DATA_OBJECT_DELAY, dataObjectDelay);
-		intent.putExtra(DfuBaseService.EXTRA_SCAN_TIMEOUT, scanTimeout);
-		intent.putExtra(DfuBaseService.EXTRA_SCAN_DELAY, rebootTime);
-		if (mtu > 0)
-			intent.putExtra(DfuBaseService.EXTRA_MTU, mtu);
-		intent.putExtra(DfuBaseService.EXTRA_CURRENT_MTU, currentMtu);
-		intent.putExtra(DfuBaseService.EXTRA_UNSAFE_EXPERIMENTAL_BUTTONLESS_DFU, enableUnsafeExperimentalButtonlessDfu);
-		//noinspection StatementWithEmptyBody
-		if (packetReceiptNotificationsEnabled != null) {
-			intent.putExtra(DfuBaseService.EXTRA_PACKET_RECEIPT_NOTIFICATIONS_ENABLED, packetReceiptNotificationsEnabled);
-			intent.putExtra(DfuBaseService.EXTRA_PACKET_RECEIPT_NOTIFICATIONS_VALUE, numberOfPackets);
-		} else {
-			// For backwards compatibility:
-			// If the setPacketsReceiptNotificationsEnabled(boolean) has not been called, the PRN state and value are taken from
-			// SharedPreferences the way they were read in DFU Library in 1.0.3 and before, or set to default values.
-			// Default values: PRNs enabled on Android 4.3 - 5.1 and disabled starting from Android 6.0. Default PRN value is 12.
-		}
-		if (legacyDfuUuids != null)
-			intent.putExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_LEGACY_DFU, legacyDfuUuids);
-		if (secureDfuUuids != null)
-			intent.putExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_SECURE_DFU, secureDfuUuids);
-		if (experimentalButtonlessDfuUuids != null)
-			intent.putExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_EXPERIMENTAL_BUTTONLESS_DFU, experimentalButtonlessDfuUuids);
-		if (buttonlessDfuWithoutBondSharingUuids != null)
-			intent.putExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_BUTTONLESS_DFU_WITHOUT_BOND_SHARING, buttonlessDfuWithoutBondSharingUuids);
-		if (buttonlessDfuWithBondSharingUuids != null)
-			intent.putExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_BUTTONLESS_DFU_WITH_BOND_SHARING, buttonlessDfuWithBondSharingUuids);
-
-		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O && startAsForegroundService) {
-			// On Android Oreo and above the service must be started as a foreground service to make it accessible from
-			// a killed application.
-			context.startForegroundService(intent);
-		} else {
-			context.startService(intent);
-		}
-		return new DfuServiceController(context);
-	}
-
-	private DfuServiceInitiator init(@Nullable final Uri initFileUri,
-									 @Nullable final String initFilePath,
-									 @RawRes final int initFileResId) {
-		if (DfuBaseService.MIME_TYPE_ZIP.equals(mimeType))
-			throw new InvalidParameterException("Init file must be located inside the ZIP");
-
-		this.initFileUri = initFileUri;
-		this.initFilePath = initFilePath;
-		this.initFileResId = initFileResId;
-		return this;
-	}
-
-	private DfuServiceInitiator init(@Nullable final Uri fileUri,
-									 @Nullable final String filePath,
-									 @RawRes final int fileResId,
-									 final int fileType,
-									 @NonNull final String mimeType) {
-		this.fileUri = fileUri;
-		this.filePath = filePath;
-		this.fileResId = fileResId;
-		this.fileType = fileType;
-		this.mimeType = mimeType;
-
-		// If the MIME TYPE implies it's a ZIP file then the init file must be included in the file.
-		if (DfuBaseService.MIME_TYPE_ZIP.equals(mimeType)) {
-			this.initFileUri = null;
-			this.initFilePath = null;
-			this.initFileResId = 0;
-		}
-		return this;
-	}
-
-	@RequiresApi(api = Build.VERSION_CODES.O)
-	public static void createDfuNotificationChannel(@NonNull final Context context) {
-		final NotificationChannel channel =
-				new NotificationChannel(DfuBaseService.NOTIFICATION_CHANNEL_DFU, context.getString(R.string.dfu_channel_name), NotificationManager.IMPORTANCE_LOW);
-		channel.setDescription(context.getString(R.string.dfu_channel_description));
-		channel.setShowBadge(false);
-		channel.setLockscreenVisibility(Notification.VISIBILITY_PUBLIC);
-
-		final NotificationManager notificationManager =
-				(NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
-		if (notificationManager != null) {
-			notificationManager.createNotificationChannel(channel);
-		}
-	}
-}
\ No newline at end of file
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceListenerHelper.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceListenerHelper.java
deleted file mode 100644
index 4006e2d..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceListenerHelper.java
+++ /dev/null
@@ -1,395 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-
-import java.util.HashMap;
-import java.util.Map;
-
-import androidx.annotation.NonNull;
-import androidx.localbroadcastmanager.content.LocalBroadcastManager;
-import no.nordicsemi.android.dfu.internal.scanner.BootloaderScannerFactory;
-import no.nordicsemi.android.error.GattError;
-
-/**
- * A helper class that should be used to register listeners for DFU Service broadcast events.
- * The {@link DfuProgressListener} should be registered to listen for DFU status updates and errors,
- * while the {@link DfuLogListener} listener receives the log updates.
- * Listeners may be registered for a specified device (given with device address) or for any device.
- * Keep in mind, that while updating the SoftDevice using the buttonless update the device may
- * change its address in the bootloader mode.
- * <p>
- * Use {@link #registerProgressListener(Context, DfuProgressListener)} or
- * {@link #registerLogListener(Context, DfuLogListener)} to register your listeners.
- * Remember about unregistering them when your context is destroyed.
- */
-@SuppressWarnings({"WeakerAccess", "unused"})
-public class DfuServiceListenerHelper {
-	private static LogBroadcastReceiver mLogBroadcastReceiver;
-	private static ProgressBroadcastsReceiver mProgressBroadcastReceiver;
-
-	private static class LogBroadcastReceiver extends BroadcastReceiver {
-		private final Map<String, DfuLogListener> mListeners = new HashMap<>();
-		private DfuLogListener mGlobalLogListener;
-
-		private void setLogListener(final DfuLogListener globalLogListener) {
-			this.mGlobalLogListener = globalLogListener;
-		}
-
-		private void setLogListener(final String deviceAddress, final DfuLogListener listener) {
-			// When using the buttonless update and updating the SoftDevice the application will
-			// be removed to make space for the new SoftDevice.
-			// The new bootloader will afterwards advertise with the address incremented by 1.
-			// We need to make sure that the listener will receive also events from this device.
-			mListeners.put(deviceAddress, listener);
-			mListeners.put(BootloaderScannerFactory.getIncrementedAddress(deviceAddress), listener); // assuming the address is a valid BLE address
-		}
-
-		private boolean removeLogListener(final DfuLogListener listener) {
-			if (mGlobalLogListener == listener)
-				mGlobalLogListener = null;
-
-			// We do it 2 times as the listener was added for 2 addresses
-			for (final Map.Entry<String, DfuLogListener> entry : mListeners.entrySet()) {
-				if (entry.getValue() == listener) {
-					mListeners.remove(entry.getKey());
-					break;
-				}
-			}
-			for (final Map.Entry<String, DfuLogListener> entry : mListeners.entrySet()) {
-				if (entry.getValue() == listener) {
-					mListeners.remove(entry.getKey());
-					break;
-				}
-			}
-
-			return mGlobalLogListener == null && mListeners.isEmpty();
-		}
-
-		@Override
-		public void onReceive(final Context context, final Intent intent) {
-			final String address = intent.getStringExtra(DfuBaseService.EXTRA_DEVICE_ADDRESS);
-
-			// Find proper listeners
-			final DfuLogListener globalListener = mGlobalLogListener;
-			final DfuLogListener deviceListener = mListeners.get(address);
-
-			if (globalListener == null && deviceListener == null)
-				return;
-
-			final int level = intent.getIntExtra(DfuBaseService.EXTRA_LOG_LEVEL, 0);
-			final String message = intent.getStringExtra(DfuBaseService.EXTRA_LOG_MESSAGE);
-
-			if (globalListener != null)
-				globalListener.onLogEvent(address, level, message);
-			if (deviceListener != null)
-				deviceListener.onLogEvent(address, level, message);
-		}
-	}
-
-	private static class ProgressBroadcastsReceiver extends BroadcastReceiver {
-		private final Map<String, DfuProgressListener> mListeners = new HashMap<>();
-		private DfuProgressListener mGlobalProgressListener;
-
-		private void setProgressListener(final DfuProgressListener globalProgressListener) {
-			this.mGlobalProgressListener = globalProgressListener;
-		}
-
-		private void setProgressListener(final String deviceAddress, final DfuProgressListener listener) {
-			// When using the buttonless update and updating the SoftDevice the application will be removed to make space for the new SoftDevice.
-			// The new bootloader will afterwards advertise with the address incremented by 1. We need to make sure that the listener will receive also events from this device.
-			mListeners.put(deviceAddress, listener);
-			mListeners.put(BootloaderScannerFactory.getIncrementedAddress(deviceAddress), listener); // assuming the address is a valid BLE address
-		}
-
-		private boolean removeProgressListener(final DfuProgressListener listener) {
-			if (mGlobalProgressListener == listener)
-				mGlobalProgressListener = null;
-
-			// We do it 2 times as the listener was added for 2 addresses
-			for (final Map.Entry<String, DfuProgressListener> entry : mListeners.entrySet()) {
-				if (entry.getValue() == listener) {
-					mListeners.remove(entry.getKey());
-					break;
-				}
-			}
-			for (final Map.Entry<String, DfuProgressListener> entry : mListeners.entrySet()) {
-				if (entry.getValue() == listener) {
-					mListeners.remove(entry.getKey());
-					break;
-				}
-			}
-
-			return mGlobalProgressListener == null && mListeners.isEmpty();
-		}
-
-		@Override
-		public void onReceive(final Context context, final Intent intent) {
-			final String address = intent.getStringExtra(DfuBaseService.EXTRA_DEVICE_ADDRESS);
-			if (address == null)
-				return;
-
-			// Find proper listeners
-			final DfuProgressListener globalListener = mGlobalProgressListener;
-			final DfuProgressListener deviceListener = mListeners.get(address);
-
-			if (globalListener == null && deviceListener == null)
-				return;
-
-			final String action = intent.getAction();
-			if (action == null)
-				return;
-
-			switch (action) {
-				case DfuBaseService.BROADCAST_PROGRESS: {
-					final int progress = intent.getIntExtra(DfuBaseService.EXTRA_DATA, 0);
-					final float speed = intent.getFloatExtra(DfuBaseService.EXTRA_SPEED_B_PER_MS, 0.0f);
-					final float avgSpeed = intent.getFloatExtra(DfuBaseService.EXTRA_AVG_SPEED_B_PER_MS, 0.0f);
-					final int currentPart = intent.getIntExtra(DfuBaseService.EXTRA_PART_CURRENT, 0);
-					final int partsTotal = intent.getIntExtra(DfuBaseService.EXTRA_PARTS_TOTAL, 0);
-
-					switch (progress) {
-						case DfuBaseService.PROGRESS_CONNECTING:
-							if (globalListener != null)
-								globalListener.onDeviceConnecting(address);
-							if (deviceListener != null)
-								deviceListener.onDeviceConnecting(address);
-							break;
-						case DfuBaseService.PROGRESS_STARTING:
-							if (globalListener != null) {
-								globalListener.onDeviceConnected(address);
-								globalListener.onDfuProcessStarting(address);
-							}
-							if (deviceListener != null) {
-								deviceListener.onDeviceConnected(address);
-								deviceListener.onDfuProcessStarting(address);
-							}
-							break;
-						case DfuBaseService.PROGRESS_ENABLING_DFU_MODE:
-							if (globalListener != null)
-								globalListener.onEnablingDfuMode(address);
-							if (deviceListener != null)
-								deviceListener.onEnablingDfuMode(address);
-							break;
-						case DfuBaseService.PROGRESS_VALIDATING:
-							if (globalListener != null)
-								globalListener.onFirmwareValidating(address);
-							if (deviceListener != null)
-								deviceListener.onFirmwareValidating(address);
-							break;
-						case DfuBaseService.PROGRESS_DISCONNECTING:
-							if (globalListener != null)
-								globalListener.onDeviceDisconnecting(address);
-							if (deviceListener != null)
-								deviceListener.onDeviceDisconnecting(address);
-							break;
-						case DfuBaseService.PROGRESS_COMPLETED:
-							if (globalListener != null) {
-								globalListener.onDeviceDisconnected(address);
-								globalListener.onDfuCompleted(address);
-							}
-							if (deviceListener != null) {
-								deviceListener.onDeviceDisconnected(address);
-								deviceListener.onDfuCompleted(address);
-							}
-							break;
-						case DfuBaseService.PROGRESS_ABORTED:
-							if (globalListener != null) {
-								globalListener.onDeviceDisconnected(address);
-								globalListener.onDfuAborted(address);
-							}
-							if (deviceListener != null) {
-								deviceListener.onDeviceDisconnected(address);
-								deviceListener.onDfuAborted(address);
-							}
-							break;
-						default:
-							if (progress == 0) {
-								if (globalListener != null)
-									globalListener.onDfuProcessStarted(address);
-								if (deviceListener != null)
-									deviceListener.onDfuProcessStarted(address);
-							}
-							if (globalListener != null)
-								globalListener.onProgressChanged(address, progress, speed, avgSpeed, currentPart, partsTotal);
-							if (deviceListener != null)
-								deviceListener.onProgressChanged(address, progress, speed, avgSpeed, currentPart, partsTotal);
-							break;
-					}
-
-					break;
-				}
-				case DfuBaseService.BROADCAST_ERROR: {
-					final int error = intent.getIntExtra(DfuBaseService.EXTRA_DATA, 0);
-					final int errorType = intent.getIntExtra(DfuBaseService.EXTRA_ERROR_TYPE, 0);
-
-					if (globalListener != null)
-						globalListener.onDeviceDisconnected(address);
-					if (deviceListener != null)
-						deviceListener.onDeviceDisconnected(address);
-					switch (errorType) {
-						case DfuBaseService.ERROR_TYPE_COMMUNICATION_STATE:
-							if (globalListener != null)
-								globalListener.onError(address, error, errorType, GattError.parseConnectionError(error));
-							if (deviceListener != null)
-								deviceListener.onError(address, error, errorType, GattError.parseConnectionError(error));
-							break;
-						case DfuBaseService.ERROR_TYPE_DFU_REMOTE:
-							if (globalListener != null)
-								globalListener.onError(address, error, errorType, GattError.parseDfuRemoteError(error));
-							if (deviceListener != null)
-								deviceListener.onError(address, error, errorType, GattError.parseDfuRemoteError(error));
-							break;
-						default:
-							if (globalListener != null)
-								globalListener.onError(address, error, errorType, GattError.parse(error));
-							if (deviceListener != null)
-								deviceListener.onError(address, error, errorType, GattError.parse(error));
-							break;
-					}
-				}
-			}
-		}
-	}
-
-	/**
-	 * Registers the {@link DfuProgressListener}.
-     * Registered listener will receive the progress events from the DFU service.
-	 *
-	 * @param context  the application context.
-	 * @param listener the listener to register.
-	 */
-	public static void registerProgressListener(@NonNull final Context context, @NonNull final DfuProgressListener listener) {
-		if (mProgressBroadcastReceiver == null) {
-			mProgressBroadcastReceiver = new ProgressBroadcastsReceiver();
-
-			final IntentFilter filter = new IntentFilter();
-			filter.addAction(DfuBaseService.BROADCAST_PROGRESS);
-			filter.addAction(DfuBaseService.BROADCAST_ERROR);
-			//noinspection deprecation
-			LocalBroadcastManager.getInstance(context).registerReceiver(mProgressBroadcastReceiver, filter);
-		}
-		mProgressBroadcastReceiver.setProgressListener(listener);
-	}
-
-	/**
-	 * Registers the {@link DfuProgressListener}. Registered listener will receive the progress
-     * events from the DFU service.
-	 *
-	 * @param context       the application context.
-	 * @param listener      the listener to register.
-	 * @param deviceAddress the address of the device to receive updates from (or null if any device).
-	 */
-	public static void registerProgressListener(@NonNull final Context context,
-                                                @NonNull final DfuProgressListener listener, @NonNull final String deviceAddress) {
-		if (mProgressBroadcastReceiver == null) {
-			mProgressBroadcastReceiver = new ProgressBroadcastsReceiver();
-
-			final IntentFilter filter = new IntentFilter();
-			filter.addAction(DfuBaseService.BROADCAST_PROGRESS);
-			filter.addAction(DfuBaseService.BROADCAST_ERROR);
-			//noinspection deprecation
-			LocalBroadcastManager.getInstance(context).registerReceiver(mProgressBroadcastReceiver, filter);
-		}
-		mProgressBroadcastReceiver.setProgressListener(deviceAddress, listener);
-	}
-
-	/**
-	 * Unregisters the previously registered progress listener.
-	 *
-	 * @param context  the application context.
-	 * @param listener the listener to unregister.
-	 */
-	public static void unregisterProgressListener(@NonNull final Context context, @NonNull final DfuProgressListener listener) {
-		if (mProgressBroadcastReceiver != null) {
-			final boolean empty = mProgressBroadcastReceiver.removeProgressListener(listener);
-
-			if (empty) {
-				//noinspection deprecation
-				LocalBroadcastManager.getInstance(context).unregisterReceiver(mProgressBroadcastReceiver);
-				mProgressBroadcastReceiver = null;
-			}
-		}
-	}
-
-	/**
-	 * Registers the {@link DfuLogListener}. Registered listener will receive the log events from the DFU service.
-	 *
-	 * @param context  the application context.
-	 * @param listener the listener to register.
-	 */
-	public static void registerLogListener(@NonNull final Context context, @NonNull final DfuLogListener listener) {
-		if (mLogBroadcastReceiver == null) {
-			mLogBroadcastReceiver = new LogBroadcastReceiver();
-
-			final IntentFilter filter = new IntentFilter();
-			filter.addAction(DfuBaseService.BROADCAST_LOG);
-			//noinspection deprecation
-			LocalBroadcastManager.getInstance(context).registerReceiver(mLogBroadcastReceiver, filter);
-		}
-		mLogBroadcastReceiver.setLogListener(listener);
-	}
-
-	/**
-	 * Registers the {@link DfuLogListener}. Registered listener will receive the log events from
-     * the DFU service.
-	 *
-	 * @param context       the application context.
-	 * @param listener      the listener to register.
-	 * @param deviceAddress the address of the device to receive updates from (or null if any device).
-	 */
-	public static void registerLogListener(@NonNull final Context context,
-                                           @NonNull final DfuLogListener listener, @NonNull final String deviceAddress) {
-		if (mLogBroadcastReceiver == null) {
-			mLogBroadcastReceiver = new LogBroadcastReceiver();
-
-			final IntentFilter filter = new IntentFilter();
-			filter.addAction(DfuBaseService.BROADCAST_LOG);
-			//noinspection deprecation
-			LocalBroadcastManager.getInstance(context).registerReceiver(mLogBroadcastReceiver, filter);
-		}
-		mLogBroadcastReceiver.setLogListener(deviceAddress, listener);
-	}
-
-	/**
-	 * Unregisters the previously registered log listener.
-	 *
-	 * @param context  the application context.
-	 * @param listener the listener to unregister.
-	 */
-	public static void unregisterLogListener(@NonNull final Context context, @NonNull final DfuLogListener listener) {
-		if (mLogBroadcastReceiver != null) {
-			final boolean empty = mLogBroadcastReceiver.removeLogListener(listener);
-
-			if (empty) {
-				//noinspection deprecation
-				LocalBroadcastManager.getInstance(context).unregisterReceiver(mLogBroadcastReceiver);
-				mLogBroadcastReceiver = null;
-			}
-		}
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceProvider.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceProvider.java
deleted file mode 100644
index 7278f76..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuServiceProvider.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.bluetooth.BluetoothGatt;
-import android.content.Intent;
-
-import androidx.annotation.NonNull;
-import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
-import no.nordicsemi.android.dfu.internal.exception.DfuException;
-import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
-
-/* package */ class DfuServiceProvider implements DfuCallback {
-	private BaseDfuImpl mImpl;
-	private boolean mPaused;
-	private boolean mAborted;
-
-	DfuService getServiceImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service, @NonNull final BluetoothGatt gatt)
-			throws DfuException, DeviceDisconnectedException, UploadAbortedException {
-		try {
-			mImpl = new ButtonlessDfuWithBondSharingImpl(intent, service);
-			if (mImpl.isClientCompatible(intent, gatt))
-				return mImpl;
-
-			mImpl = new ButtonlessDfuWithoutBondSharingImpl(intent, service);
-			if (mImpl.isClientCompatible(intent, gatt))
-				return mImpl;
-
-			mImpl = new SecureDfuImpl(intent, service);
-			if (mImpl.isClientCompatible(intent, gatt))
-				return mImpl;
-
-			mImpl = new LegacyButtonlessDfuImpl(intent, service); // This will read the DFU Version char...
-			if (mImpl.isClientCompatible(intent, gatt))
-				return mImpl;
-
-			mImpl = new LegacyDfuImpl(intent, service);           // ...that this impl will then use.
-			if (mImpl.isClientCompatible(intent, gatt))
-				return mImpl;
-
-			// Support for experimental Buttonless DFU Service from SDK 12.
-			// This feature must be explicitly enabled in the initiator.
-			final boolean enableUnsafeExperimentalButtonlessDfuService = intent.getBooleanExtra(DfuBaseService.EXTRA_UNSAFE_EXPERIMENTAL_BUTTONLESS_DFU, false);
-			if (enableUnsafeExperimentalButtonlessDfuService) {
-				mImpl = new ExperimentalButtonlessDfuImpl(intent, service);
-				if (mImpl.isClientCompatible(intent, gatt))
-					return mImpl;
-			}
-			// No implementation found
-			return null;
-		} finally {
-			// Call pause() or abort() only on the chosen implementation
-			if (mImpl != null) {
-				if (mPaused)
-					mImpl.pause();
-				if (mAborted)
-					mImpl.abort();
-			}
-		}
-	}
-
-	@Override
-	public DfuGattCallback getGattCallback() {
-		return mImpl != null ? mImpl.getGattCallback() : null;
-	}
-
-	@Override
-	public void onBondStateChanged(final int state) {
-		if (mImpl != null)
-			mImpl.onBondStateChanged(state);
-	}
-
-	@Override
-	public void pause() {
-		mPaused = true;
-	}
-
-	@Override
-	public void resume() {
-		mPaused = false;
-	}
-
-	@Override
-	public void abort() {
-		mAborted = true;
-		if (mImpl != null)
-			mImpl.abort();
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuSettingsConstants.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuSettingsConstants.java
deleted file mode 100644
index 84f7bc7..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/DfuSettingsConstants.java
+++ /dev/null
@@ -1,129 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.bluetooth.BluetoothGattCharacteristic;
-
-/**
- * A collection of constants used for reading DFU constants from
- * {@link android.preference.PreferenceManager} in previous versions of DFU Library.
- *
- * @deprecated Use {@link DfuServiceInitiator} methods instead.
- */
-@SuppressWarnings("DeprecatedIsStillUsed")
-@Deprecated
-public interface DfuSettingsConstants {
-	/**
-	 * This property must contain a boolean value.
-	 * <p>
-	 * If true (default) the Packet Receipt Notification procedure will be enabled.
-	 * See DFU documentation on
-	 * <a href="https://infocenter.nordicsemi.com/topic/sdk_nrf5_v17.0.0/lib_dfu_transport.html?cp=7_1_3_5_2">Infocenter</a>
-	 * for more details. The number of packets before receiving a Packet Receipt Notification
-	 * is set with property {@link #SETTINGS_NUMBER_OF_PACKETS}.
-	 *
-	 * @deprecated Use {@link DfuServiceInitiator#setPacketsReceiptNotificationsEnabled(boolean)} to set it.
-	 */
-	@Deprecated
-	String SETTINGS_PACKET_RECEIPT_NOTIFICATION_ENABLED = "settings_packet_receipt_notification_enabled";
-
-	/**
-	 * This property must contain a positive integer value, usually from range 1-200.
-	 * <p>The default value is {@value #SETTINGS_NUMBER_OF_PACKETS_DEFAULT}. Setting it to 0 will
-	 * disable the Packet Receipt Notification procedure. When sending a firmware using the
-	 * DFU procedure the service will send this number of packets before waiting for a notification.
-	 * Packet Receipt Notifications are used to synchronize the sender with receiver.
-	 * On Android, calling {@link android.bluetooth.BluetoothGatt#writeCharacteristic(BluetoothGattCharacteristic)}
-	 * will simply add the packet to outgoing queue before returning the callback. Adding the
-	 * next packet in the callback is much faster than the real transmission (also the speed depends on
-	 * the device chip manufacturer) and the queue may reach its limit. When does, the transmission
-	 * stops and Android Bluetooth hangs. Using PRN procedure eliminates this problem as
-	 * the notification is send when all packets were delivered the queue is empty.
-	 * <p>
-	 * Note: this bug has been fixed on Android 6.0 Marshmallow and now no notifications are required.
-	 * The onCharacteristicWrite callback will be postponed until half of the queue is empty.
-	 *
-	 * @deprecated Use {@link DfuServiceInitiator#setPacketsReceiptNotificationsValue(int)} to set it.
-	 */
-	@Deprecated
-	String SETTINGS_NUMBER_OF_PACKETS = "settings_number_of_packets";
-
-	/**
-	 * The default value of {@link #SETTINGS_NUMBER_OF_PACKETS} property.
-	 * Different phones sent a different number of packets each connection interval.
-	 * The values are (for tested phones):
-	 * <ul>
-	 *     <li>1 packet - Nexus 4 and Nexus 7 and others</li>
-	 *     <li>4 packets - Nexus 5 and Nexus 6 and others</li>
-	 *     <li>6 packets - LG F60 and others</li>
-	 * </ul>
-	 * The least common multiplier is 12 which is reasonably small. You may try other values,
-	 * like 24 etc. Values higher than ~300 may cause the Bluetooth outgoing queue overflow
-	 * error on Android versions before Marshmallow.
-	 *
-	 * @deprecated Use {@link DfuServiceInitiator#setPacketsReceiptNotificationsValue(int)} to set it.
-	 */
-	@Deprecated
-	int SETTINGS_NUMBER_OF_PACKETS_DEFAULT = DfuServiceInitiator.DEFAULT_PRN_VALUE;
-
-	/**
-	 * This property must contain an integer value.
-	 * <p>
-	 * Size of the MBR (Master Boot Record) for the target chip. This applies only if you are
-	 * using HEX files. The HEX_to_BIN parser included in the library will skip the addresses
-	 * from 0 to this value. By default for nRF51 and the SoftDevice S110 this value is equal
-	 * 4096 (0x1000 HEX) and for nRF52 has to be changed to 12288 (0x3000). If you want to send
-	 * a firmware in HEX onto another MCU via nRF chip, set this value to 0.
-	 * <p>
-	 * If you are using the PC nrf util tool to create a ZIP Distribution Packet with the
-	 * firmware and Init Packet this option does not apply as the nrf tool will convert
-	 * HEX to BIN itself.
-	 *
-	 * @deprecated Use {@link DfuServiceInitiator#setMbrSize(int)} instead.
-	 */
-	@Deprecated
-	String SETTINGS_MBR_SIZE = "settings_mbr_size";
-
-	/**
-	 * This property must contain a boolean value.
-	 * <p>
-	 * The {@link DfuBaseService}, when connected to a DFU target will check whether it is
-	 * in application or in DFU bootloader mode. For DFU implementations from SDK 7.0 or newer
-	 * this is done by reading the value of DFU Version characteristic. If the returned value
-	 * is equal to 0x0100 (major = 0, minor = 1) it means that we are in the application mode and
-	 * jump to the bootloader mode is required.
-	 * <p>
-	 * However, for DFU implementations from older SDKs, where there was no DFU Version
-	 * characteristic, the service must guess. If this option is set to false (default) it will count
-	 * number of device's services. If the count is equal to 3 (Generic Access, Generic Attribute,
-	 * DFU Service) it will assume that it's in DFU mode. If greater than 3 - in app mode.
-	 * This guessing may not be always correct. One situation may be when the nRF chip is used
-	 * to flash update on external MCU using DFU. The DFU procedure may be implemented in the
-	 * application, which may (and usually does) have more services. In such case set the
-	 * value of this property to true.
-	 *
-	 * @deprecated Use {@link DfuServiceInitiator#setForceDfu(boolean)} instead.
-	 */
-	@Deprecated
-	String SETTINGS_ASSUME_DFU_NODE = "settings_assume_dfu_mode";
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ExperimentalButtonlessDfuImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ExperimentalButtonlessDfuImpl.java
deleted file mode 100644
index 67390d3..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/ExperimentalButtonlessDfuImpl.java
+++ /dev/null
@@ -1,90 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.bluetooth.BluetoothGatt;
-import android.bluetooth.BluetoothGattCharacteristic;
-import android.bluetooth.BluetoothGattService;
-import android.content.Intent;
-
-import java.util.UUID;
-
-import androidx.annotation.NonNull;
-import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
-import no.nordicsemi.android.dfu.internal.exception.DfuException;
-import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
-
-/**
- * The implementation of the experimental buttonless service that was
- * implemented in SDK 12.x. The original implementation had bugs and must be enabled using this method:
- * (see {@link DfuServiceInitiator#setUnsafeExperimentalButtonlessServiceInSecureDfuEnabled(boolean)}).
- * Read this method documentation for more details.
- */
-/* package */ class ExperimentalButtonlessDfuImpl extends ButtonlessDfuImpl {
-	/** The UUID of the experimental Buttonless DFU service from SDK 12.x. */
-	static final UUID DEFAULT_EXPERIMENTAL_BUTTONLESS_DFU_SERVICE_UUID = new UUID(0x8E400001F3154F60L, 0x9FB8838830DAEA50L);
-	/** The UUID of the experimental Buttonless DFU characteristic from SDK 12.x. */
-	static final UUID DEFAULT_EXPERIMENTAL_BUTTONLESS_DFU_UUID         = new UUID(0x8E400001F3154F60L, 0x9FB8838830DAEA50L); // the same as service
-
-	static UUID EXPERIMENTAL_BUTTONLESS_DFU_SERVICE_UUID = DEFAULT_EXPERIMENTAL_BUTTONLESS_DFU_SERVICE_UUID;
-	static UUID EXPERIMENTAL_BUTTONLESS_DFU_UUID         = DEFAULT_EXPERIMENTAL_BUTTONLESS_DFU_UUID;
-
-	private BluetoothGattCharacteristic mButtonlessDfuCharacteristic;
-
-	ExperimentalButtonlessDfuImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service) {
-		super(intent, service);
-	}
-
-	@Override
-	public boolean isClientCompatible(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt) {
-		final BluetoothGattService dfuService = gatt.getService(EXPERIMENTAL_BUTTONLESS_DFU_SERVICE_UUID);
-		if (dfuService == null)
-			return false;
-		final BluetoothGattCharacteristic characteristic = dfuService.getCharacteristic(EXPERIMENTAL_BUTTONLESS_DFU_UUID);
-		if (characteristic == null || characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG) == null)
-			return false;
-		mButtonlessDfuCharacteristic = characteristic;
-		return true;
-	}
-
-	@Override
-	protected int getResponseType() {
-		return NOTIFICATIONS;
-	}
-
-	@Override
-	protected BluetoothGattCharacteristic getButtonlessDfuCharacteristic() {
-		return mButtonlessDfuCharacteristic;
-	}
-
-	@Override
-	protected boolean shouldScanForBootloader() {
-		return true;
-	}
-
-	@Override
-	public void performDfu(@NonNull final Intent intent) throws DfuException, DeviceDisconnectedException, UploadAbortedException {
-		logi("Experimental buttonless service found -> SDK 12.x");
-		super.performDfu(intent);
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/FileType.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/FileType.java
deleted file mode 100644
index b9d70b2..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/FileType.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package no.nordicsemi.android.dfu;
-
-import androidx.annotation.IntDef;
-
-import java.lang.annotation.Retention;
-import java.lang.annotation.RetentionPolicy;
-
-@SuppressWarnings("WeakerAccess")
-@Retention(RetentionPolicy.SOURCE)
-@IntDef(value = {
-            DfuBaseService.TYPE_SOFT_DEVICE,
-            DfuBaseService.TYPE_BOOTLOADER,
-            DfuBaseService.TYPE_APPLICATION
-        },
-        flag = true)
-public @interface FileType {}
-
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/LegacyButtonlessDfuImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/LegacyButtonlessDfuImpl.java
deleted file mode 100644
index 99d50f2..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/LegacyButtonlessDfuImpl.java
+++ /dev/null
@@ -1,286 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.annotation.SuppressLint;
-import android.bluetooth.BluetoothGatt;
-import android.bluetooth.BluetoothGattCharacteristic;
-import android.bluetooth.BluetoothGattService;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.os.Build;
-import android.preference.PreferenceManager;
-
-import java.util.UUID;
-
-import androidx.annotation.NonNull;
-import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
-import no.nordicsemi.android.dfu.internal.exception.DfuException;
-import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
-
-/**
- * Implementations of the legacy buttonless service introduced in SDK 6.1.
- */
-@SuppressLint("MissingPermission")
-/* package */ class LegacyButtonlessDfuImpl extends BaseButtonlessDfuImpl {
-	// UUIDs used by the DFU
-	static UUID DFU_SERVICE_UUID = LegacyDfuImpl.DEFAULT_DFU_SERVICE_UUID;
-	static UUID DFU_CONTROL_POINT_UUID = LegacyDfuImpl.DEFAULT_DFU_CONTROL_POINT_UUID;
-	static UUID DFU_VERSION_UUID = LegacyDfuImpl.DEFAULT_DFU_VERSION_UUID;
-
-	private static final byte[] OP_CODE_ENTER_BOOTLOADER = new byte[]{0x01, 0x04};
-
-	private BluetoothGattCharacteristic mControlPointCharacteristic;
-	private int mVersion;
-
-	LegacyButtonlessDfuImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service) {
-		super(intent, service);
-	}
-
-	@SuppressWarnings("deprecation")
-	@Override
-	public boolean isClientCompatible(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt)
-			throws DfuException, DeviceDisconnectedException, UploadAbortedException {
-		final BluetoothGattService dfuService = gatt.getService(DFU_SERVICE_UUID);
-		if (dfuService == null)
-			return false;
-		final BluetoothGattCharacteristic characteristic = dfuService.getCharacteristic(DFU_CONTROL_POINT_UUID);
-		if (characteristic == null || characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG) == null)
-			return false;
-		mControlPointCharacteristic = characteristic;
-
-		mProgressInfo.setProgress(DfuBaseService.PROGRESS_STARTING);
-
-		// Add one second delay to avoid the traffic jam before the DFU mode is enabled
-		// Related:
-		//   issue:        https://github.com/NordicSemiconductor/Android-DFU-Library/issues/10
-		//   pull request: https://github.com/NordicSemiconductor/Android-DFU-Library/pull/12
-		mService.waitFor(1000);
-		// End
-
-		/*
-		 * Read the version number if available.
-		 * The DFU Version characteristic has been added in SDK 7.0.
-		 * The version number consists of 2 bytes: major and minor. Therefore e.g. the version 5 (00-05) can be read as 0.5.
-		 *
-		 * Currently supported versions are:
-		 *  * no DFU Version characteristic - we may be either in the bootloader mode or in the app mode. The DFU Bootloader from SDK 6.1 did not have this characteristic,
-		 *                                    but it also supported the buttonless update. Usually, the application must have had some additional services (like Heart Rate, etc)
-		 *                                    so if the number of services greater is than 3 (Generic Access, Generic Attribute, DFU Service) we can also assume we are in
-		 *                                    the application mode and jump is required.
-		 *
-		 *  * version = 1 (major = 0, minor = 1) - Application with DFU buttonless update supported. A jump to DFU mode is required.
-		 *
-		 *  * version = 5 (major = 0, minor = 5) - Since version 5 the Extended Init Packet is required. Keep in mind that if we are in the app mode the DFU Version characteristic
-		 *  								  still returns version = 1, as it is independent from the DFU Bootloader. The version = 5 is reported only after successful jump to
-		 *  								  the DFU mode. In version = 5 the bond information is always lost. Released in SDK 7.0.0.
-		 *
-		 *  * version = 6 (major = 0, minor = 6) - The DFU Bootloader may be configured to keep the bond information after application update. Please, see the {@link #EXTRA_KEEP_BOND}
-		 *  								  documentation for more information about how to enable the feature (disabled by default). A change in the DFU bootloader source and
-		 *  								  setting the {@link DfuServiceInitiator#setKeepBond} to true is required. Released in SDK 8.0.0.
-		 *
-		 *  * version = 7 (major = 0, minor = 7) - The SHA-256 firmware hash is used in the Extended Init Packet instead of CRC-16. This feature is transparent for the DFU Service.
-		 *
-		 *  * version = 8 (major = 0, minor = 8) - The Extended Init Packet is signed using the private key. The bootloader, using the public key, is able to verify the content.
-		 *  								  Released in SDK 9.0.0 as experimental feature.
-		 *  								  Caution! The firmware type (Application, Bootloader, SoftDevice or SoftDevice+Bootloader) is not encrypted as it is not a part of the
-		 *  								  Extended Init Packet. Use Secure DFU instead for better security.
-		 */
-		int version = 0;
-		final BluetoothGattCharacteristic versionCharacteristic = dfuService.getCharacteristic(DFU_VERSION_UUID); // this may be null for older versions of the Bootloader
-		if (versionCharacteristic != null) {
-			version = mVersion = readVersion(gatt, versionCharacteristic);
-			final int minor = (version & 0x0F);
-			final int major = (version >> 8);
-			logi("Version number read: " + major + "." + minor + " -> " + getVersionFeatures(version));
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Version number read: " + major + "." + minor);
-		} else {
-			logi("No DFU Version characteristic found -> " + getVersionFeatures(version));
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "DFU Version characteristic not found");
-		}
-
-		/*
-		 * In case of old DFU bootloader versions, where there was no DFU Version characteristic, the service was unable to determine whether it was in the application mode, or in
-		 * bootloader mode. In that case, if the following boolean value is set to false (default) the bootloader will count number of services on the device. In case of 3 service
-		 * it will start the DFU procedure (Generic Access, Generic Attribute, DFU Service). If more services will be found, it assumes that a jump to the DFU bootloader is required.
-		 *
-		 * However, in some cases, the DFU bootloader is used to flash firmware on other chip via nRF5x. In that case the application may support DFU operation without switching
-		 * to the bootloader mode itself.
-		 *
-		 * For newer implementations of DFU in such case the DFU Version should return value other than 0x0100 (major 0, minor 1) which means that the application does not support
-		 * DFU process itself but rather support jump to the bootloader mode.
-		 */
-		final SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(mService);
-		boolean assumeDfuMode = preferences.getBoolean(DfuSettingsConstants.SETTINGS_ASSUME_DFU_NODE, false);
-		if (intent.hasExtra(DfuBaseService.EXTRA_FORCE_DFU))
-			assumeDfuMode = intent.getBooleanExtra(DfuBaseService.EXTRA_FORCE_DFU, false);
-
-		final boolean moreServicesFound = gatt.getServices().size() > 3; // More services than Generic Access, Generic Attribute, DFU Service
-		if (version == 0 && moreServicesFound)
-			logi("Additional services found -> Bootloader from SDK 6.1. Updating SD and BL supported, extended init packet not supported");
-		return version == 1 || (!assumeDfuMode && version == 0 && moreServicesFound);
-	}
-
-	@Override
-	public void performDfu(@NonNull final Intent intent) throws DfuException, DeviceDisconnectedException, UploadAbortedException {
-		logw("Application with legacy buttonless update found");
-
-		// The service is connected to the application, not to the bootloader
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "Application with buttonless update found");
-
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Jumping to the DFU Bootloader...");
-
-		// Let's request the MTU requested by the user. It may be that a lower MTU will be used.
-		if (intent.hasExtra(DfuBaseService.EXTRA_MTU) && Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-			final int requiredMtu = intent.getIntExtra(DfuBaseService.EXTRA_MTU, 517);
-			logi("Requesting MTU = " + requiredMtu);
-			requestMtu(requiredMtu);
-		}
-
-		// Enable notifications
-		enableCCCD(mControlPointCharacteristic, NOTIFICATIONS);
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Notifications enabled");
-
-		// Wait a second here before going further
-		// Related:
-		//   pull request: https://github.com/NordicSemiconductor/Android-DFU-Library/pull/11
-		mService.waitFor(1000);
-		// End
-
-		// Send 'jump to bootloader command' (Start DFU)
-		mProgressInfo.setProgress(DfuBaseService.PROGRESS_ENABLING_DFU_MODE);
-		logi("Sending Start DFU command (Op Code = 1, Upload Mode = 4)");
-		writeOpCode(mControlPointCharacteristic, OP_CODE_ENTER_BOOTLOADER, true);
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Jump to bootloader sent (Op Code = 1, Upload Mode = 4)");
-
-		// The device will disconnect and now reset. Some devices don't disconnect gracefully,
-		// but reset instead. In that case, Android would assume disconnection after
-		// "supervision timeout" seconds, which may be 5 more seconds. If the device will
-		// use a different address in bootloader mode, there is no reason to wait for that.
-		// The library will immediately start scanning for the device advertising in
-		// bootloader mode and connect to it.
-		final boolean forceScanning = intent.getBooleanExtra(DfuBaseService.EXTRA_FORCE_SCANNING_FOR_BOOTLOADER_IN_LEGACY_DFU, false);
-		if (/* Bootloader from SDK 6.1 may use incremented address, see Pull request #45 */ !forceScanning && mVersion > 0) {
-			mService.waitUntilDisconnected();
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "Disconnected by the remote device");
-		}
-
-		/*
-		 * We would like to avoid using the hack with refreshing the device (refresh method is not in the public API). The refresh method clears the cached services and causes a
-		 * service discovery afterwards (when connected). Android, however, does it itself when receive the Service Changed indication when bonded.
-		 * In case of unpaired device we may either refresh the services manually (using the hack), or include the Service Changed characteristic.
-		 *
-		 * According to Bluetooth Core 4.0 (and 4.1) specification:
-		 *
-		 * [Vol. 3, Part G, 2.5.2 - Attribute Caching]
-		 * Note: Clients without a trusted relationship must perform service discovery on each connection if the server supports the Services Changed characteristic.
-		 *
-		 * However, as up to Android 7 the system does NOT respect this requirement and servers are cached for every device, even if Service Changed is enabled -> Android BUG?
-		 * For bonded devices Android performs service re-discovery when SC indication is received.
-		 *
-		 * Android 8 and 9 never cache services of not bonded devices.
-		 */
-		final BluetoothGatt gatt = mGatt;
-		final BluetoothGattService gas = gatt.getService(GENERIC_ATTRIBUTE_SERVICE_UUID);
-		final boolean hasServiceChanged = gas != null && gas.getCharacteristic(SERVICE_CHANGED_UUID) != null;
-		mService.refreshDeviceCache(gatt, !hasServiceChanged);
-
-		// Close the device
-		mService.close(gatt);
-
-		logi("Starting service that will connect to the DFU bootloader");
-		final Intent newIntent = new Intent();
-		newIntent.fillIn(intent, Intent.FILL_IN_COMPONENT | Intent.FILL_IN_PACKAGE);
-		restartService(newIntent, /* scan only for SDK 6.1, see Pull request #45 */ forceScanning || mVersion == 0);
-	}
-
-	/**
-	 * Reads the DFU Version characteristic if such exists. Otherwise it returns 0.
-	 *
-	 * @param gatt           the GATT device.
-	 * @param characteristic the characteristic to read.
-	 * @return a version number or 0 if not present on the bootloader.
-	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
-	 *                                     the transmission.
-	 * @throws DfuException                Thrown if DFU error occur.
-	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
-	 */
-	private int readVersion(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic)
-            throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-		if (!mConnected)
-			throw new DeviceDisconnectedException("Unable to read version number: device disconnected");
-		if (mAborted)
-			throw new UploadAbortedException();
-		// If the DFU Version characteristic is not available we return 0.
-		if (characteristic == null)
-			return 0;
-
-		mReceivedData = null;
-		mError = 0;
-
-		logi("Reading DFU version number...");
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Reading DFU version number...");
-
-		characteristic.setValue((byte[]) null);
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.readCharacteristic(" + characteristic.getUuid() + ")");
-		gatt.readCharacteristic(characteristic);
-
-		// We have to wait until device receives a response or an error occur
-		try {
-			synchronized (mLock) {
-				while (((!mRequestCompleted || characteristic.getValue() == null) && mConnected && mError == 0 && !mAborted) || mPaused) {
-					mRequestCompleted = false;
-					mLock.wait();
-				}
-			}
-		} catch (final InterruptedException e) {
-			loge("Sleeping interrupted", e);
-		}
-		if (!mConnected)
-			throw new DeviceDisconnectedException("Unable to read version number: device disconnected");
-		if (mError != 0)
-			throw new DfuException("Unable to read version number", mError);
-
-		// The version is a 16-bit unsigned int
-		return characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT16, 0);
-	}
-
-	private String getVersionFeatures(final int version) {
-		switch (version) {
-			case 0:
-				return "Bootloader from SDK 6.1 or older";
-			case 1:
-				return "Application with Legacy buttonless update from SDK 7.0 or newer";
-			case 5:
-				return "Bootloader from SDK 7.0 or newer. No bond sharing";
-			case 6:
-				return "Bootloader from SDK 8.0 or newer. Bond sharing supported";
-			case 7:
-				return "Bootloader from SDK 8.0 or newer. SHA-256 used instead of CRC-16 in the Init Packet";
-			case 8:
-				return "Bootloader from SDK 9.0 or newer. Signature supported";
-			default:
-				return "Unknown version";
-		}
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/LegacyDfuImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/LegacyDfuImpl.java
deleted file mode 100644
index bb5941d..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/LegacyDfuImpl.java
+++ /dev/null
@@ -1,755 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.annotation.SuppressLint;
-import android.bluetooth.BluetoothGatt;
-import android.bluetooth.BluetoothGattCharacteristic;
-import android.bluetooth.BluetoothGattService;
-import android.content.Intent;
-import android.os.Build;
-import android.os.SystemClock;
-
-import java.util.Locale;
-import java.util.UUID;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import no.nordicsemi.android.dfu.internal.ArchiveInputStream;
-import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
-import no.nordicsemi.android.dfu.internal.exception.DfuException;
-import no.nordicsemi.android.dfu.internal.exception.RemoteDfuException;
-import no.nordicsemi.android.dfu.internal.exception.UnknownResponseException;
-import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
-import no.nordicsemi.android.error.LegacyDfuError;
-
-@SuppressLint("MissingPermission")
-/* package */ class LegacyDfuImpl extends BaseCustomDfuImpl {
-	// UUIDs used by the DFU
-	static final UUID DEFAULT_DFU_SERVICE_UUID       = new UUID(0x000015301212EFDEL, 0x1523785FEABCD123L);
-	static final UUID DEFAULT_DFU_CONTROL_POINT_UUID = new UUID(0x000015311212EFDEL, 0x1523785FEABCD123L);
-	static final UUID DEFAULT_DFU_PACKET_UUID        = new UUID(0x000015321212EFDEL, 0x1523785FEABCD123L);
-	static final UUID DEFAULT_DFU_VERSION_UUID       = new UUID(0x000015341212EFDEL, 0x1523785FEABCD123L);
-
-	static UUID DFU_SERVICE_UUID       = DEFAULT_DFU_SERVICE_UUID;
-	static UUID DFU_CONTROL_POINT_UUID = DEFAULT_DFU_CONTROL_POINT_UUID;
-	static UUID DFU_PACKET_UUID        = DEFAULT_DFU_PACKET_UUID;
-	static UUID DFU_VERSION_UUID       = DEFAULT_DFU_VERSION_UUID;
-
-	private static final int DFU_STATUS_SUCCESS = 1;
-	// Operation codes and packets
-	private static final int OP_CODE_START_DFU_KEY = 0x01; // 1
-	private static final int OP_CODE_INIT_DFU_PARAMS_KEY = 0x02; // 2
-	private static final int OP_CODE_RECEIVE_FIRMWARE_IMAGE_KEY = 0x03; // 3
-	private static final int OP_CODE_VALIDATE_KEY = 0x04; // 4
-	private static final int OP_CODE_ACTIVATE_AND_RESET_KEY = 0x05; // 5
-	private static final int OP_CODE_RESET_KEY = 0x06; // 6
-	//private static final int OP_CODE_PACKET_REPORT_RECEIVED_IMAGE_SIZE_KEY = 0x07; // 7
-	private static final int OP_CODE_PACKET_RECEIPT_NOTIF_REQ_KEY = 0x08; // 8
-	private static final int OP_CODE_RESPONSE_CODE_KEY = 0x10; // 16
-	private static final int OP_CODE_PACKET_RECEIPT_NOTIF_KEY = 0x11; // 11
-	private static final byte[] OP_CODE_START_DFU = new byte[]{OP_CODE_START_DFU_KEY, 0x00};
-	private static final byte[] OP_CODE_START_DFU_V1 = new byte[]{OP_CODE_START_DFU_KEY};
-	private static final byte[] OP_CODE_INIT_DFU_PARAMS = new byte[]{OP_CODE_INIT_DFU_PARAMS_KEY}; // SDK 6.0.0 or older
-	private static final byte[] OP_CODE_INIT_DFU_PARAMS_START = new byte[]{OP_CODE_INIT_DFU_PARAMS_KEY, 0x00};
-	private static final byte[] OP_CODE_INIT_DFU_PARAMS_COMPLETE = new byte[]{OP_CODE_INIT_DFU_PARAMS_KEY, 0x01};
-	private static final byte[] OP_CODE_RECEIVE_FIRMWARE_IMAGE = new byte[]{OP_CODE_RECEIVE_FIRMWARE_IMAGE_KEY};
-	private static final byte[] OP_CODE_VALIDATE = new byte[]{OP_CODE_VALIDATE_KEY};
-	private static final byte[] OP_CODE_ACTIVATE_AND_RESET = new byte[]{OP_CODE_ACTIVATE_AND_RESET_KEY};
-	private static final byte[] OP_CODE_RESET = new byte[]{OP_CODE_RESET_KEY};
-	//private static final byte[] OP_CODE_REPORT_RECEIVED_IMAGE_SIZE = new byte[] { OP_CODE_PACKET_REPORT_RECEIVED_IMAGE_SIZE_KEY };
-	private static final byte[] OP_CODE_PACKET_RECEIPT_NOTIF_REQ = new byte[]{OP_CODE_PACKET_RECEIPT_NOTIF_REQ_KEY, 0x00, 0x00};
-
-	private BluetoothGattCharacteristic mControlPointCharacteristic;
-	private BluetoothGattCharacteristic mPacketCharacteristic;
-
-	/**
-	 * Flag indicating whether the image size has been already transferred or not.
-	 */
-	private boolean mImageSizeInProgress;
-
-	private final LegacyBluetoothCallback mBluetoothCallback = new LegacyBluetoothCallback();
-
-	protected class LegacyBluetoothCallback extends BaseCustomBluetoothCallback {
-		@Override
-		protected void onPacketCharacteristicWrite(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic, final int status) {
-			if (mImageSizeInProgress) {
-				// We've got confirmation that the image size was sent
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "Data written to " + characteristic.getUuid() + ", value (0x): " + parse(characteristic));
-				mImageSizeInProgress = false;
-			}
-		}
-
-		@Override
-		public void onCharacteristicChanged(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {
-			final int responseType = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 0);
-
-			switch (responseType) {
-				case OP_CODE_PACKET_RECEIPT_NOTIF_KEY:
-					mProgressInfo.setBytesReceived(characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT32, 1));
-					handlePacketReceiptNotification(gatt, characteristic);
-					break;
-				case OP_CODE_RESPONSE_CODE_KEY:
-				default:
-					/*
-					 * If the DFU target device is in invalid state (f.e. the Init Packet is required but has not been selected), the target will send DFU_STATUS_INVALID_STATE error
-					 * for each firmware packet that was send. We are interested may ignore all but the first one.
-					 * After obtaining a remote DFU error the OP_CODE_RESET_KEY will be sent.
-					 */
-					if (mRemoteErrorOccurred)
-						break;
-					final int status = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 2);
-					if (status != DFU_STATUS_SUCCESS)
-						mRemoteErrorOccurred = true;
-
-					handleNotification(gatt, characteristic);
-					break;
-			}
-			notifyLock();
-		}
-	}
-
-	/* package */ LegacyDfuImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service) {
-		super(intent, service);
-	}
-
-	@Override
-	public boolean isClientCompatible(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt) {
-		final BluetoothGattService dfuService = gatt.getService(DFU_SERVICE_UUID);
-		if (dfuService == null)
-			return false;
-		final BluetoothGattCharacteristic characteristic = dfuService.getCharacteristic(DFU_CONTROL_POINT_UUID);
-		if (characteristic == null || characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG) == null)
-			return false;
-		mControlPointCharacteristic = characteristic;
-		mPacketCharacteristic = dfuService.getCharacteristic(DFU_PACKET_UUID);
-		return mPacketCharacteristic != null;
-	}
-
-	@Override
-	public BaseCustomBluetoothCallback getGattCallback() {
-		return mBluetoothCallback;
-	}
-
-	@Override
-	protected UUID getControlPointCharacteristicUUID() {
-		return DFU_CONTROL_POINT_UUID;
-	}
-
-	@Override
-	protected UUID getPacketCharacteristicUUID() {
-		return DFU_PACKET_UUID;
-	}
-
-	@Override
-	protected UUID getDfuServiceUUID() {
-		return DFU_SERVICE_UUID;
-	}
-
-	@Override
-	public void performDfu(@NonNull final Intent intent)
-			throws DfuException, DeviceDisconnectedException, UploadAbortedException {
-		logw("Legacy DFU bootloader found");
-		mProgressInfo.setProgress(DfuBaseService.PROGRESS_STARTING);
-
-		// Let's request the MTU requested by the user. It may be that a lower MTU will be used.
-		if (intent.hasExtra(DfuBaseService.EXTRA_MTU) && Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-			final int requiredMtu = intent.getIntExtra(DfuBaseService.EXTRA_MTU, 517);
-			logi("Requesting MTU = " + requiredMtu);
-			requestMtu(requiredMtu);
-		}
-
-		// Add one second delay to avoid the traffic jam before the DFU mode is enabled
-		// Related:
-		//   issue:        https://github.com/NordicSemiconductor/Android-DFU-Library/issues/10
-		//   pull request: https://github.com/NordicSemiconductor/Android-DFU-Library/pull/12
-		mService.waitFor(1000);
-		// End
-
-		final BluetoothGatt gatt = mGatt;
-
-		/*
-		 * DFU Version characteristic has been read by the LegacyButtonlessDfuImpl#isClientCompatible(...) while determining implementation.
-		 * No need to read it again.
-		 */
-		final BluetoothGattCharacteristic versionCharacteristic = gatt.getService(DFU_SERVICE_UUID).getCharacteristic(DFU_VERSION_UUID); // this may be null for older versions of the Bootloader
-		final int version = readVersion(versionCharacteristic);
-
-		/*
-		 * If the DFU Version characteristic is present and the version returned from it is greater or equal to 0.5, the Extended Init Packet is required.
-		 * If the InputStream with init packet is null we may safely abort sending and reset the device as it would happen eventually in few moments.
-		 * The DFU target would send DFU INVALID STATE error if the init packet would not be sent before starting file transmission.
-		 */
-		if (version >= 5 && mInitPacketStream == null) {
-			logw("Init packet not set for the DFU Bootloader version " + version);
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, "The Init packet is required by this version DFU Bootloader");
-			mService.terminateConnection(gatt, DfuBaseService.ERROR_INIT_PACKET_REQUIRED);
-			return;
-		}
-
-		try {
-			// Enable notifications
-			enableCCCD(mControlPointCharacteristic, NOTIFICATIONS);
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Notifications enabled");
-
-			// Wait a second here before going further
-			// Related:
-			//   pull request: https://github.com/NordicSemiconductor/Android-DFU-Library/pull/11
-			mService.waitFor(1000);
-			// End
-
-			// Set up the temporary variable that will hold the responses
-			byte[] response;
-			int status;
-
-			/*
-			 * The first version of DFU supported only an Application update.
-			 * Initializing procedure:
-			 * [DFU Start (0x01)] -> DFU Control Point
-			 * [App size in bytes (UINT32)] -> DFU Packet
-			 * ---------------------------------------------------------------------
-			 * Since SDK 6.0 and Soft Device 7.0+ the DFU supports upgrading Soft Device, Bootloader and Application.
-			 * Initializing procedure:
-			 * [DFU Start (0x01), <Update Mode>] -> DFU Control Point
-			 * [SD size in bytes (UINT32), Bootloader size in bytes (UINT32), Application size in bytes (UINT32)] -> DFU Packet
-			 * where <Upload Mode> is a bit mask:
-			 * 0x01 - Soft Device update
-			 * 0x02 - Bootloader update
-			 * 0x04 - Application update
-			 * so that
-			 * 0x03 - Soft Device and Bootloader update
-			 * If <Upload Mode> equals 5, 6 or 7 DFU target may return OPERATION_NOT_SUPPORTED [10, 01, 03]. In that case service will try to send
-			 * Soft Device and/or Bootloader first, reconnect to the new Bootloader and send the Application in the second connection.
-			 * --------------------------------------------------------------------
-			 * If DFU target supports only the old DFU, a response [10, 01, 03] will be send as a notification on DFU Control Point characteristic, where:
-			 * 10 - Response for...
-			 * 01 - DFU Start command
-			 * 03 - Operation Not Supported
-			 * (see table below)
-			 * In that case:
-			 * 1. If this is application update - service will try to upload using the old DFU protocol.
-			 * 2. In case of SD or BL update an error is returned.
-			 */
-
-			// Obtain size of image(s)
-			int fileType = mFileType;
-			int softDeviceImageSize = (fileType & DfuBaseService.TYPE_SOFT_DEVICE) > 0 ? mImageSizeInBytes : 0;
-			int bootloaderImageSize = (fileType & DfuBaseService.TYPE_BOOTLOADER) > 0 ? mImageSizeInBytes : 0;
-			int appImageSize = (fileType & DfuBaseService.TYPE_APPLICATION) > 0 ? mImageSizeInBytes : 0;
-			// The sizes above may be overwritten if a ZIP file was passed
-			if (mFirmwareStream instanceof ArchiveInputStream) {
-				final ArchiveInputStream zhis = (ArchiveInputStream) mFirmwareStream;
-				if (zhis.isSecureDfuRequired()) {
-					loge("Secure DFU is required to upload selected firmware");
-					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, "The device does not support given firmware.");
-					logi("Sending Reset command (Op Code = 6)");
-					writeOpCode(mControlPointCharacteristic, OP_CODE_RESET);
-					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Reset request sent");
-					mService.terminateConnection(gatt, DfuBaseService.ERROR_FILE_INVALID);
-					return;
-				}
-				softDeviceImageSize = zhis.softDeviceImageSize();
-				bootloaderImageSize = zhis.bootloaderImageSize();
-				appImageSize = zhis.applicationImageSize();
-			}
-
-			boolean extendedInitPacketSupported = true;
-			try {
-				OP_CODE_START_DFU[1] = (byte) fileType;
-
-				// Send Start DFU command to Control Point
-				logi("Sending Start DFU command (Op Code = 1, Upload Mode = " + fileType + ")");
-				writeOpCode(mControlPointCharacteristic, OP_CODE_START_DFU);
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "DFU Start sent (Op Code = 1, Upload Mode = " + fileType + ")");
-
-				// Send image size in bytes to DFU Packet
-				logi("Sending image size array to DFU Packet (" + softDeviceImageSize + "b, " + bootloaderImageSize + "b, " + appImageSize + "b)");
-				writeImageSize(mPacketCharacteristic, softDeviceImageSize, bootloaderImageSize, appImageSize);
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Firmware image size sent (" + softDeviceImageSize + "b, " + bootloaderImageSize + "b, " + appImageSize + "b)");
-
-				// A notification will come with confirmation. Let's wait for it a bit
-				response = readNotificationResponse();
-
-				/*
-				 * The response received from the DFU device contains:
-				 * +---------+--------+----------------------------------------------------+
-				 * | byte no | value  | description                                        |
-				 * +---------+--------+----------------------------------------------------+
-				 * | 0       | 16     | Response code                                      |
-				 * | 1       | 1      | The Op Code of a request that this response is for |
-				 * | 2       | STATUS | Status code                                        |
-				 * +---------+--------+----------------------------------------------------+
-				 */
-				status = getStatusCode(response, OP_CODE_START_DFU_KEY);
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + " Status = " + status + ")");
-
-				// If upload was not completed in the previous connection the INVALID_STATE status will be reported.
-				// Theoretically, the connection could be resumed from that point, but there is no guarantee, that the same firmware
-				// is to be uploaded now. It's safer to reset the device and start DFU again.
-				if (status == LegacyDfuError.INVALID_STATE) {
-					resetAndRestart(gatt, intent);
-					return;
-				}
-				if (status != DFU_STATUS_SUCCESS)
-					throw new RemoteDfuException("Starting DFU failed", status);
-			} catch (final RemoteDfuException e) {
-				try {
-					if (e.getErrorNumber() != LegacyDfuError.NOT_SUPPORTED)
-						throw e;
-
-					// If user wants to send the Soft Device and/or the Bootloader + Application we may try to send the Soft Device/Bootloader files first,
-					// and then reconnect and send the application in the second connection.
-					if ((fileType & DfuBaseService.TYPE_APPLICATION) > 0 && (fileType & (DfuBaseService.TYPE_SOFT_DEVICE | DfuBaseService.TYPE_BOOTLOADER)) > 0) {
-						// Clear the remote error flag
-						mRemoteErrorOccurred = false;
-
-						logw("DFU target does not support (SD/BL)+App update");
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "DFU target does not support (SD/BL)+App update");
-
-						fileType &= ~DfuBaseService.TYPE_APPLICATION; // clear application bit
-						mFileType = fileType;
-						OP_CODE_START_DFU[1] = (byte) fileType;
-						mProgressInfo.setTotalPart(2);
-
-						// Set new content type in the ZIP Input Stream and update sizes of images
-						final ArchiveInputStream zhis = (ArchiveInputStream) mFirmwareStream;
-						zhis.setContentType(fileType);
-						appImageSize = 0;
-
-						// Send Start DFU command to Control Point
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Sending only SD/BL");
-						logi("Resending Start DFU command (Op Code = 1, Upload Mode = " + fileType + ")");
-						writeOpCode(mControlPointCharacteristic, OP_CODE_START_DFU);
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "DFU Start sent (Op Code = 1, Upload Mode = " + fileType + ")");
-
-						// Send image size in bytes to DFU Packet
-						logi("Sending image size array to DFU Packet: [" + softDeviceImageSize + "b, " + bootloaderImageSize + "b, " + appImageSize + "b]");
-						writeImageSize(mPacketCharacteristic, softDeviceImageSize, bootloaderImageSize, appImageSize);
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Firmware image size sent [" + softDeviceImageSize + "b, " + bootloaderImageSize + "b, " + appImageSize + "b]");
-
-						// A notification will come with confirmation. Let's wait for it a bit
-						response = readNotificationResponse();
-						status = getStatusCode(response, OP_CODE_START_DFU_KEY);
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + " Status = " + status + ")");
-
-						// If upload was not completed in the previous connection the INVALID_STATE status will be reported.
-						// Theoretically, the connection could be resumed from that point, but there is no guarantee, that the same firmware
-						// is to be uploaded now. It's safer to reset the device and start DFU again.
-						if (status == LegacyDfuError.INVALID_STATE) {
-							resetAndRestart(gatt, intent);
-							return;
-						}
-						if (status != DFU_STATUS_SUCCESS)
-							throw new RemoteDfuException("Starting DFU failed", status);
-					} else
-						throw e;
-				} catch (final RemoteDfuException e1) {
-					if (e1.getErrorNumber() != LegacyDfuError.NOT_SUPPORTED)
-						throw e1;
-
-					// If operation is not supported by DFU target we may try to upload application with legacy mode, using the old DFU protocol
-					if (fileType == DfuBaseService.TYPE_APPLICATION) {
-						// Clear the remote error flag
-						mRemoteErrorOccurred = false;
-						extendedInitPacketSupported = false;
-
-						// The DFU target does not support DFU v.2 protocol
-						logw("DFU target does not support DFU v.2");
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "DFU target does not support DFU v.2");
-
-						// Send Start DFU command to Control Point
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Switching to DFU v.1");
-						logi("Resending Start DFU command (Op Code = 1)");
-						writeOpCode(mControlPointCharacteristic, OP_CODE_START_DFU_V1);
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "DFU Start sent (Op Code = 1)");
-
-						// Send image size in bytes to DFU Packet
-						logi("Sending application image size to DFU Packet: " + mImageSizeInBytes + " bytes");
-						writeImageSize(mPacketCharacteristic, mImageSizeInBytes);
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Firmware image size sent (" + mImageSizeInBytes + " bytes)");
-
-						// A notification will come with confirmation. Let's wait for it a bit
-						response = readNotificationResponse();
-						status = getStatusCode(response, OP_CODE_START_DFU_KEY);
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + ", Status = " + status + ")");
-
-						// If upload was not completed in the previous connection the INVALID_STATE status will be reported.
-						// Theoretically, the connection could be resumed from that point, but there is no guarantee, that the same firmware
-						// is to be uploaded now. It's safer to reset the device and start DFU again.
-						if (status == LegacyDfuError.INVALID_STATE) {
-							resetAndRestart(gatt, intent);
-							return;
-						}
-						if (status != DFU_STATUS_SUCCESS)
-							throw new RemoteDfuException("Starting DFU failed", status);
-					} else
-						throw e1;
-				}
-			}
-
-			/*
-			 * If the DFU Version characteristic is present and the version returned from it is greater or equal to 0.5, the Extended Init Packet is required.
-			 * For older versions, or if the DFU Version characteristic is not present (pre SDK 7.0.0), the Init Packet (which could have contained only the firmware CRC) was optional.
-			 * Deprecated: To calculate the CRC (CRC-CCTII-16 0xFFFF) the following application may be used: http://www.lammertbies.nl/comm/software/index.html -> CRC library.
-			 * New: To calculate the CRC (CRC-CCTII-16 0xFFFF) the 'nrf utility' may be used (see below).
-			 *
-			 * The Init Packet is read from the *.dat file as a binary file. This service you allows to specify the init packet file in two ways.
-			 * Since SDK 8.0 and the DFU Library v0.6 using the Distribution packet (ZIP) is recommended. The distribution packet can be created using the
-			 * *nrf utility* tool, available together with Master Control Panel v 3.8.0+. See the DFU documentation at http://developer.nordicsemi.com for more details.
-			 * An init file may be also provided as a separate file using the {@link #EXTRA_INIT_FILE_PATH} or {@link #EXTRA_INIT_FILE_URI} or in the ZIP file
-			 * with the deprecated fixed naming convention:
-			 *
-			 *    a) If the ZIP file contain a softdevice.hex (or .bin) and/or bootloader.hex (or .bin) the 'system.dat' must also be included.
-			 *       In case when both files are present the CRC should be calculated from the two BIN contents merged together.
-			 *       This means: if there are softdevice.hex and bootloader.hex files in the ZIP file you have to convert them to BIN
-			 *       (e.g. using: http://hex2bin.sourceforge.net/ application), copy them into a single file where the soft device is placed as the first one and calculate
-			 *       the CRC for the whole file.
-			 *
-			 *    b) If the ZIP file contains a application.hex (or .bin) file the 'application.dat' file must be included and contain the Init packet for the application.
-			 */
-			// Send DFU Init Packet
-			if (mInitPacketStream != null) {
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Writing Initialize DFU Parameters...");
-
-				if (extendedInitPacketSupported) {
-					logi("Sending the Initialize DFU Parameters START (Op Code = 2, Value = 0)");
-					writeOpCode(mControlPointCharacteristic, OP_CODE_INIT_DFU_PARAMS_START);
-
-					logi("Sending " + mInitPacketSizeInBytes + " bytes of init packet");
-					writeInitData(mPacketCharacteristic, null);
-
-					logi("Sending the Initialize DFU Parameters COMPLETE (Op Code = 2, Value = 1)");
-					writeOpCode(mControlPointCharacteristic, OP_CODE_INIT_DFU_PARAMS_COMPLETE);
-					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Initialize DFU Parameters completed");
-				} else {
-					// In SDK 4.3 - 6.0.0 the Init Packet could have had only 2 bytes - the CRC16. START-STOP commands were not supported,
-					// instead there was just a single command 0x02, followed by a write to DFU Packet after which the device was sending a response.
-					logi("Sending the Initialize DFU Parameters (Op Code = 2)");
-					writeOpCode(mControlPointCharacteristic, OP_CODE_INIT_DFU_PARAMS);
-
-					logi("Sending " + mInitPacketSizeInBytes + " bytes of init packet");
-					writeInitData(mPacketCharacteristic, null);
-				}
-
-				// A notification will come with confirmation. Let's wait for it a bit
-				response = readNotificationResponse();
-				status = getStatusCode(response, OP_CODE_INIT_DFU_PARAMS_KEY);
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + ", Status = " + status + ")");
-				if (status != DFU_STATUS_SUCCESS)
-					throw new RemoteDfuException("Device returned error after sending init packet", status);
-			}
-
-			// Send the number of packets of firmware before receiving a receipt notification
-			// Note: DFU bootloaders from SDK 6.0.0 or older were unable to save incoming data to the flash memory with the same speed
-			//       as they are being sent from modern devices, therefore the PRNs are here force-enabled for them.
-			//       It has been tested that PRN = 10 may be the highest supported value.
-			final int numberOfPacketsBeforeNotification = extendedInitPacketSupported || (mPacketsBeforeNotification > 0 && mPacketsBeforeNotification <= 10) ? mPacketsBeforeNotification : 10;
-			if (numberOfPacketsBeforeNotification > 0) {
-				mPacketsBeforeNotification = numberOfPacketsBeforeNotification;
-				logi("Sending the number of packets before notifications (Op Code = 8, Value = " + numberOfPacketsBeforeNotification + ")");
-				setNumberOfPackets(OP_CODE_PACKET_RECEIPT_NOTIF_REQ, numberOfPacketsBeforeNotification);
-				writeOpCode(mControlPointCharacteristic, OP_CODE_PACKET_RECEIPT_NOTIF_REQ);
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Packet Receipt Notif Req (Op Code = 8) sent (Value = " + numberOfPacketsBeforeNotification + ")");
-			}
-
-			// Initialize firmware upload
-			logi("Sending Receive Firmware Image request (Op Code = 3)");
-			writeOpCode(mControlPointCharacteristic, OP_CODE_RECEIVE_FIRMWARE_IMAGE);
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Receive Firmware Image request sent");
-
-			// Send the firmware. The method below sends the first packet and waits until the whole firmware is sent.
-			final long startTime = SystemClock.elapsedRealtime();
-			mProgressInfo.setBytesSent(0);
-			try {
-				logi("Uploading firmware...");
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Uploading firmware...");
-				uploadFirmwareImage(mPacketCharacteristic);
-			} catch (final DeviceDisconnectedException e) {
-				loge("Disconnected while sending data");
-				throw e;
-			}
-			final long endTime = SystemClock.elapsedRealtime();
-
-			// Check the result of the operation
-			response = readNotificationResponse();
-			status = getStatusCode(response, OP_CODE_RECEIVE_FIRMWARE_IMAGE_KEY);
-			logi("Response received (Op Code = " + response[0] + ", Req Op Code = " + response[1] + ", Status = " + response[2] + ")");
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + ", Status = " + status + ")");
-			if (status != DFU_STATUS_SUCCESS)
-				throw new RemoteDfuException("Device returned error after sending file", status);
-
-			logi("Transfer of " + mProgressInfo.getBytesSent() + " bytes has taken " + (endTime - startTime) + " ms");
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Upload completed in " + (endTime - startTime) + " ms");
-
-			// Send Validate request
-			logi("Sending Validate request (Op Code = 4)");
-			writeOpCode(mControlPointCharacteristic, OP_CODE_VALIDATE);
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Validate request sent");
-
-			// A notification will come with status code. Let's wait for it a bit.
-			response = readNotificationResponse();
-			status = getStatusCode(response, OP_CODE_VALIDATE_KEY);
-			logi("Response received (Op Code = " + response[0] + ", Req Op Code = " + response[1] + ", Status = " + response[2] + ")");
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Response received (Op Code = " + response[1] + ", Status = " + status + ")");
-			if (status != DFU_STATUS_SUCCESS)
-				throw new RemoteDfuException("Device returned validation error", status);
-
-			// Send Activate and Reset signal.
-			mProgressInfo.setProgress(DfuBaseService.PROGRESS_DISCONNECTING);
-			logi("Sending Activate and Reset request (Op Code = 5)");
-			writeOpCode(mControlPointCharacteristic, OP_CODE_ACTIVATE_AND_RESET);
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Activate and Reset request sent");
-
-			// The device will reset so we don't have to send Disconnect signal.
-			mService.waitUntilDisconnected();
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "Disconnected by the remote device");
-
-			// We are ready with DFU, the device is disconnected, let's close it and finalize the operation.
-
-			// In the DFU version 0.5, in case the device is bonded, the target device does not send the Service Changed indication after
-			// a jump from bootloader mode to app mode. This issue has been fixed in DFU version 0.6 (SDK 8.0). If the DFU bootloader has been
-			// configured to preserve the bond information we do not need to enforce refreshing services, as it will notify the phone using the
-			// Service Changed indication.
-			finalize(intent, version == 5);
-		} catch (final UploadAbortedException e) {
-			logi("Sending Reset command (Op Code = 6)");
-			mAborted = false; // clear the flag, otherwise the writeOpCode method will not wait until the device disconnects
-			writeOpCode(mControlPointCharacteristic, OP_CODE_RESET);
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Reset request sent");
-			// The connection will be terminated in the DfuBaseService
-			throw e;
-		} catch (final UnknownResponseException e) {
-			final int error = DfuBaseService.ERROR_INVALID_RESPONSE;
-			loge(e.getMessage());
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, e.getMessage());
-
-			logi("Sending Reset command (Op Code = 6)");
-			writeOpCode(mControlPointCharacteristic, OP_CODE_RESET);
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Reset request sent");
-			mService.terminateConnection(gatt, error);
-		} catch (final RemoteDfuException e) {
-			final int error = DfuBaseService.ERROR_REMOTE_TYPE_LEGACY | e.getErrorNumber();
-			loge(e.getMessage() + ": " + LegacyDfuError.parse(error));
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, String.format(Locale.US, "Remote DFU error: %s", LegacyDfuError.parse(error)));
-
-			logi("Sending Reset command (Op Code = 6)");
-			writeOpCode(mControlPointCharacteristic, OP_CODE_RESET);
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Reset request sent");
-			mService.terminateConnection(gatt, error | DfuBaseService.ERROR_REMOTE_MASK);
-		}
-	}
-
-	/**
-	 * Sets number of data packets that will be send before the notification will be received.
-	 *
-	 * @param data  control point data packet.
-	 * @param value number of packets before receiving notification.
-	 *              If this value is 0, then the notification of packet receipt will be disabled
-	 *              by the DFU target.
-	 */
-	@SuppressWarnings("SameParameterValue")
-	private void setNumberOfPackets(@NonNull final byte[] data, final int value) {
-		data[1] = (byte) (value & 0xFF);
-		data[2] = (byte) ((value >> 8) & 0xFF);
-	}
-
-	/**
-	 * Checks whether the response received is valid and returns the status code.
-	 *
-	 * @param response the response received from the DFU device.
-	 * @param request  the expected Op Code.
-	 * @return The status code.
-	 * @throws UnknownResponseException if response was not valid.
-	 */
-	private int getStatusCode(@Nullable final byte[] response, final int request)
-			throws UnknownResponseException {
-		if (response == null || response.length != 3 || response[0] != OP_CODE_RESPONSE_CODE_KEY ||
-				response[1] != request || response[2] < 1 || response[2] > 6)
-			throw new UnknownResponseException("Invalid response received", response, OP_CODE_RESPONSE_CODE_KEY, request);
-		return response[2];
-	}
-
-	/**
-	 * Returns the DFU Version characteristic if such exists. Otherwise it returns 0.
-	 *
-	 * @param characteristic the characteristic to read.
-	 * @return a version number or 0 if not present on the bootloader.
-	 */
-	private int readVersion(@Nullable final BluetoothGattCharacteristic characteristic) {
-		// The value of this characteristic has been read before by LegacyButtonlessDfuImpl
-		return characteristic != null ? characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT16, 0) : 0;
-	}
-
-	/**
-	 * Writes the operation code to the characteristic. This method is SYNCHRONOUS and wait until the
-	 * {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)}
-	 * will be called or the device gets disconnected.
-	 * If connection state will change, or an error will occur, an exception will be thrown.
-	 *
-	 * @param characteristic the characteristic to write to. Should be the DFU CONTROL POINT.
-	 * @param value          the value to write to the characteristic.
-	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
-	 *                                     the transmission.
-	 * @throws DfuException                Thrown if DFU error occur.
-	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
-	 */
-	private void writeOpCode(@NonNull final BluetoothGattCharacteristic characteristic, @NonNull final byte[] value)
-			throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-		final boolean reset = value[0] == OP_CODE_RESET_KEY || value[0] == OP_CODE_ACTIVATE_AND_RESET_KEY;
-		writeOpCode(characteristic, value, reset);
-	}
-
-	/**
-	 * Writes the image size to the characteristic. This method is SYNCHRONOUS and wait until the
-	 * {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)}
-	 * will be called or the device gets disconnected. If connection state will change, or an
-	 * error will occur, an exception will be thrown.
-	 *
-	 * @param characteristic the characteristic to write to. Should be the DFU PACKET.
-	 * @param imageSize      the image size in bytes.
-	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
-	 *                                     the transmission.
-	 * @throws DfuException                Thrown if DFU error occur.
-	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
-	 */
-	private void writeImageSize(@NonNull final BluetoothGattCharacteristic characteristic, final int imageSize)
-			throws DeviceDisconnectedException, DfuException,
-			UploadAbortedException {
-		mReceivedData = null;
-		mError = 0;
-		mImageSizeInProgress = true;
-
-		characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE);
-		characteristic.setValue(new byte[4]);
-		characteristic.setValue(imageSize, BluetoothGattCharacteristic.FORMAT_UINT32, 0);
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Writing to characteristic " + characteristic.getUuid());
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.writeCharacteristic(" + characteristic.getUuid() + ")");
-		mGatt.writeCharacteristic(characteristic);
-
-		// We have to wait for confirmation
-		try {
-			synchronized (mLock) {
-				while ((mImageSizeInProgress && mConnected && mError == 0 && !mAborted) || mPaused)
-					mLock.wait();
-			}
-		} catch (final InterruptedException e) {
-			loge("Sleeping interrupted", e);
-		}
-		if (mAborted)
-			throw new UploadAbortedException();
-		if (!mConnected)
-			throw new DeviceDisconnectedException("Unable to write Image Size: device disconnected");
-		if (mError != 0)
-			throw new DfuException("Unable to write Image Size", mError);
-	}
-
-	/**
-	 * <p>
-	 * Writes the Soft Device, Bootloader and Application image sizes to the characteristic.
-	 * Soft Device and Bootloader update is supported since Soft Device s110 v7.0.0.
-	 * Sizes of SD, BL and App are uploaded as 3x UINT32 even though some of them may be 0s.
-	 * E.g. if only App is being updated the data will be <0x00000000, 0x00000000, [App size]>
-	 * <p>
-	 * This method is SYNCHRONOUS and wait until the
-	 * {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)}
-	 * will be called or the device gets disconnected. If connection state will change, or an
-	 * error will occur, an exception will be thrown.
-	 *
-	 * @param characteristic      the characteristic to write to. Should be the DFU PACKET.
-	 * @param softDeviceImageSize the Soft Device image size in bytes.
-	 * @param bootloaderImageSize the Bootloader image size in bytes.
-	 * @param appImageSize        the Application image size in bytes.
-	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
-	 *                                     the transmission.
-	 * @throws DfuException                Thrown if DFU error occur.
-	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
-	 */
-	private void writeImageSize(@NonNull final BluetoothGattCharacteristic characteristic,
-								final int softDeviceImageSize, final int bootloaderImageSize, final int appImageSize)
-			throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-		mReceivedData = null;
-		mError = 0;
-		mImageSizeInProgress = true;
-
-		characteristic.setWriteType(BluetoothGattCharacteristic.WRITE_TYPE_NO_RESPONSE);
-		characteristic.setValue(new byte[12]);
-		characteristic.setValue(softDeviceImageSize, BluetoothGattCharacteristic.FORMAT_UINT32, 0);
-		characteristic.setValue(bootloaderImageSize, BluetoothGattCharacteristic.FORMAT_UINT32, 4);
-		characteristic.setValue(appImageSize, BluetoothGattCharacteristic.FORMAT_UINT32, 8);
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_VERBOSE, "Writing to characteristic " + characteristic.getUuid());
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_DEBUG, "gatt.writeCharacteristic(" + characteristic.getUuid() + ")");
-		mGatt.writeCharacteristic(characteristic);
-
-		// We have to wait for confirmation
-		try {
-			synchronized (mLock) {
-				while ((mImageSizeInProgress && mConnected && mError == 0 && !mAborted) || mPaused)
-					mLock.wait();
-			}
-		} catch (final InterruptedException e) {
-			loge("Sleeping interrupted", e);
-		}
-		if (mAborted)
-			throw new UploadAbortedException();
-		if (!mConnected)
-			throw new DeviceDisconnectedException("Unable to write Image Sizes: device disconnected");
-		if (mError != 0)
-			throw new DfuException("Unable to write Image Sizes", mError);
-	}
-
-	/**
-	 * Sends Reset command to the target device to reset its state and restarts the DFU Service that will start again.
-	 *
-	 * @param gatt the GATT device.
-	 * @param intent intent used to start the service.
-	 * @throws DeviceDisconnectedException Thrown when the device will disconnect in the middle of
-	 *                                     the transmission.
-	 * @throws DfuException                Thrown if DFU error occur.
-	 * @throws UploadAbortedException      Thrown if DFU operation was aborted by user.
-	 */
-	private void resetAndRestart(@NonNull final BluetoothGatt gatt, @NonNull final Intent intent)
-			throws DfuException, DeviceDisconnectedException, UploadAbortedException {
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "Last upload interrupted. Restarting device...");
-		// Send 'jump to bootloader command' (Start DFU)
-		mProgressInfo.setProgress(DfuBaseService.PROGRESS_DISCONNECTING);
-		logi("Sending Reset command (Op Code = 6)");
-		writeOpCode(mControlPointCharacteristic, OP_CODE_RESET);
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Reset request sent");
-
-		// The device will reset so we don't have to send Disconnect signal.
-		mService.waitUntilDisconnected();
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "Disconnected by the remote device");
-
-		final BluetoothGattService gas = gatt.getService(GENERIC_ATTRIBUTE_SERVICE_UUID);
-		final boolean hasServiceChanged = gas != null && gas.getCharacteristic(SERVICE_CHANGED_UUID) != null;
-		mService.refreshDeviceCache(gatt, !hasServiceChanged);
-
-		// Close the device
-		mService.close(gatt);
-
-		logi("Restarting the service");
-		final Intent newIntent = new Intent();
-		newIntent.fillIn(intent, Intent.FILL_IN_COMPONENT | Intent.FILL_IN_PACKAGE);
-		restartService(newIntent, false);
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/SecureDfuImpl.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/SecureDfuImpl.java
deleted file mode 100644
index fb57e75..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/SecureDfuImpl.java
+++ /dev/null
@@ -1,1012 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.bluetooth.BluetoothGatt;
-import android.bluetooth.BluetoothGattCharacteristic;
-import android.bluetooth.BluetoothGattService;
-import android.content.Intent;
-import android.os.Build;
-import android.os.SystemClock;
-
-import java.io.ByteArrayInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.util.Locale;
-import java.util.UUID;
-import java.util.zip.CRC32;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import no.nordicsemi.android.dfu.internal.ArchiveInputStream;
-import no.nordicsemi.android.dfu.internal.exception.DeviceDisconnectedException;
-import no.nordicsemi.android.dfu.internal.exception.DfuException;
-import no.nordicsemi.android.dfu.internal.exception.RemoteDfuException;
-import no.nordicsemi.android.dfu.internal.exception.RemoteDfuExtendedErrorException;
-import no.nordicsemi.android.dfu.internal.exception.UnknownResponseException;
-import no.nordicsemi.android.dfu.internal.exception.UploadAbortedException;
-import no.nordicsemi.android.error.SecureDfuError;
-
-/* package */
-@SuppressWarnings("JavaDoc")
-class SecureDfuImpl extends BaseCustomDfuImpl {
-	// UUIDs used by the DFU
-	static final UUID DEFAULT_DFU_SERVICE_UUID       = new UUID(0x0000FE5900001000L, 0x800000805F9B34FBL); // 16-bit UUID assigned by Bluetooth SIG
-	static final UUID DEFAULT_DFU_CONTROL_POINT_UUID = new UUID(0x8EC90001F3154F60L, 0x9FB8838830DAEA50L);
-	static final UUID DEFAULT_DFU_PACKET_UUID        = new UUID(0x8EC90002F3154F60L, 0x9FB8838830DAEA50L);
-
-	static UUID DFU_SERVICE_UUID       = DEFAULT_DFU_SERVICE_UUID;
-	static UUID DFU_CONTROL_POINT_UUID = DEFAULT_DFU_CONTROL_POINT_UUID;
-	static UUID DFU_PACKET_UUID        = DEFAULT_DFU_PACKET_UUID;
-
-	private static final int DFU_STATUS_SUCCESS = 1;
-	private static final int MAX_ATTEMPTS = 3;
-
-	// Object types
-	private static final int OBJECT_COMMAND = 0x01;
-	private static final int OBJECT_DATA = 0x02;
-	// Operation codes and packets
-	private static final int OP_CODE_CREATE_KEY = 0x01;
-	private static final int OP_CODE_PACKET_RECEIPT_NOTIF_REQ_KEY = 0x02;
-	private static final int OP_CODE_CALCULATE_CHECKSUM_KEY = 0x03;
-	private static final int OP_CODE_EXECUTE_KEY = 0x04;
-	private static final int OP_CODE_SELECT_OBJECT_KEY = 0x06;
-	private static final int OP_CODE_RESPONSE_CODE_KEY = 0x60;
-	private static final byte[] OP_CODE_CREATE_COMMAND = new byte[]{OP_CODE_CREATE_KEY, OBJECT_COMMAND, 0x00, 0x00, 0x00, 0x00 };
-	private static final byte[] OP_CODE_CREATE_DATA = new byte[]{OP_CODE_CREATE_KEY, OBJECT_DATA, 0x00, 0x00, 0x00, 0x00};
-	private static final byte[] OP_CODE_PACKET_RECEIPT_NOTIF_REQ = new byte[]{OP_CODE_PACKET_RECEIPT_NOTIF_REQ_KEY, 0x00, 0x00 /* param PRN uint16 in Little Endian */};
-	private static final byte[] OP_CODE_CALCULATE_CHECKSUM = new byte[]{OP_CODE_CALCULATE_CHECKSUM_KEY};
-	private static final byte[] OP_CODE_EXECUTE = new byte[]{OP_CODE_EXECUTE_KEY};
-	private static final byte[] OP_CODE_SELECT_OBJECT = new byte[]{OP_CODE_SELECT_OBJECT_KEY, 0x00 /* type */};
-
-	private BluetoothGattCharacteristic mControlPointCharacteristic;
-	private BluetoothGattCharacteristic mPacketCharacteristic;
-
-	private long prepareObjectDelay;
-
-	private final SecureBluetoothCallback mBluetoothCallback = new SecureBluetoothCallback();
-
-	protected class SecureBluetoothCallback extends BaseCustomBluetoothCallback {
-
-		@Override
-		public void onCharacteristicChanged(final BluetoothGatt gatt, final BluetoothGattCharacteristic characteristic) {
-			if (characteristic.getValue() == null || characteristic.getValue().length < 3) {
-				loge("Empty response: " + parse(characteristic));
-				mError = DfuBaseService.ERROR_INVALID_RESPONSE;
-				notifyLock();
-				return;
-			}
-
-			final int responseType = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 0);
-
-			// The first byte should always be the response code
-			if (responseType == OP_CODE_RESPONSE_CODE_KEY) {
-				final int requestType = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 1);
-
-				//noinspection SwitchStatementWithTooFewBranches
-				switch (requestType) {
-					case OP_CODE_CALCULATE_CHECKSUM_KEY: {
-						final int offset = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT32, 3);
-						final int remoteCrc = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT32, 3 + 4);
-						final int localCrc = (int) (((ArchiveInputStream) mFirmwareStream).getCrc32() & 0xFFFFFFFFL);
-						// Check whether local and remote CRC match
-						if (localCrc == remoteCrc) {
-							// If so, update the number of bytes received
-							mProgressInfo.setBytesReceived(offset);
-						} else {
-							// Else, and only in case it was a PRN received, not the response for
-                            // Calculate Checksum Request, stop sending data
-							if (mFirmwareUploadInProgress) {
-								mFirmwareUploadInProgress = false;
-								notifyLock();
-								return;
-							} // else will be handled by sendFirmware(gatt) below
-						}
-						handlePacketReceiptNotification(gatt, characteristic);
-						break;
-					}
-					default: {
-						/*
-						 * If the DFU target device is in invalid state (e.g. the Init Packet is
-						 * required but has not been selected), the target will send
-						 * DFU_STATUS_INVALID_STATE error for each firmware packet that was send.
-						 * We are interested may ignore all but the first one.
-						 */
-						if (mRemoteErrorOccurred)
-							break;
-						final int status = characteristic.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT8, 2);
-						if (status != DFU_STATUS_SUCCESS)
-							mRemoteErrorOccurred = true;
-
-						handleNotification(gatt, characteristic);
-						break;
-					}
-				}
-			} else {
-				loge("Invalid response: " + parse(characteristic));
-				mError = DfuBaseService.ERROR_INVALID_RESPONSE;
-			}
-			notifyLock();
-		}
-	}
-
-	SecureDfuImpl(@NonNull final Intent intent, @NonNull final DfuBaseService service) {
-		super(intent, service);
-	}
-
-	@Override
-	public boolean isClientCompatible(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt) {
-		final BluetoothGattService dfuService = gatt.getService(DFU_SERVICE_UUID);
-		if (dfuService == null)
-			return false;
-		final BluetoothGattCharacteristic characteristic = dfuService.getCharacteristic(DFU_CONTROL_POINT_UUID);
-		if (characteristic == null || characteristic.getDescriptor(CLIENT_CHARACTERISTIC_CONFIG) == null)
-			return false;
-		mControlPointCharacteristic = characteristic;
-		mPacketCharacteristic = dfuService.getCharacteristic(DFU_PACKET_UUID);
-		return mPacketCharacteristic != null;
-	}
-
-	@Override
-	public boolean initialize(@NonNull final Intent intent, @NonNull final BluetoothGatt gatt,
-							  @FileType final int fileType,
-							  @NonNull final InputStream firmwareStream,
-							  @Nullable final InputStream initPacketStream)
-			throws DfuException, DeviceDisconnectedException, UploadAbortedException {
-		if (initPacketStream == null) {
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR,
-                    "The Init packet is required by this version DFU Bootloader");
-			mService.terminateConnection(gatt, DfuBaseService.ERROR_INIT_PACKET_REQUIRED);
-			return false;
-		}
-
-		return super.initialize(intent, gatt, fileType, firmwareStream, initPacketStream);
-	}
-
-	@Override
-	public BaseBluetoothGattCallback getGattCallback() {
-		return mBluetoothCallback;
-	}
-
-	@Override
-	protected UUID getControlPointCharacteristicUUID() {
-		return DFU_CONTROL_POINT_UUID;
-	}
-
-	@Override
-	protected UUID getPacketCharacteristicUUID() {
-		return DFU_PACKET_UUID;
-	}
-
-	@Override
-	protected UUID getDfuServiceUUID() {
-		return DFU_SERVICE_UUID;
-	}
-
-	@Override
-	public void performDfu(@NonNull final Intent intent)
-			throws DfuException, DeviceDisconnectedException, UploadAbortedException {
-		logw("Secure DFU bootloader found");
-		mProgressInfo.setProgress(DfuBaseService.PROGRESS_STARTING);
-
-		// Add one second delay to avoid the traffic jam before the DFU mode is enabled
-		// Related:
-		//   issue:        https://github.com/NordicSemiconductor/Android-DFU-Library/issues/10
-		//   pull request: https://github.com/NordicSemiconductor/Android-DFU-Library/pull/12
-		mService.waitFor(1000);
-		// End
-
-		final BluetoothGatt gatt = mGatt;
-
-		// Secure DFU since SDK 15 supports higher MTUs.
-		// Let's request the MTU requested by the user. It may be that a lower MTU will be used.
-		if (intent.hasExtra(DfuBaseService.EXTRA_MTU) && Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-			final int requiredMtu = intent.getIntExtra(DfuBaseService.EXTRA_MTU, 517);
-			logi("Requesting MTU = " + requiredMtu);
-			requestMtu(requiredMtu);
-		}
-
-		prepareObjectDelay = intent.getLongExtra(DfuBaseService.EXTRA_DATA_OBJECT_DELAY, 0);
-
-		try {
-			// Enable notifications
-			enableCCCD(mControlPointCharacteristic, NOTIFICATIONS);
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION,
-                    "Notifications enabled");
-
-			// Wait a second here before going further
-			// Related:
-			//   pull request: https://github.com/NordicSemiconductor/Android-DFU-Library/pull/11
-			mService.waitFor(1000);
-			// End
-
-			final boolean allowResume = !intent.hasExtra(DfuBaseService.EXTRA_DISABLE_RESUME)
-					|| !intent.getBooleanExtra(DfuBaseService.EXTRA_DISABLE_RESUME, false);
-			if (!allowResume)
-				logi("Resume feature disabled. Performing fresh DFU");
-			try {
-				sendInitPacket(gatt, allowResume);
-			} catch (final RemoteDfuException e) {
-				// If the SD+BL upload failed, we may still be able to upload the App.
-				// The SD+BL might have been updated before.
-				if (!mProgressInfo.isLastPart()) {
-					mRemoteErrorOccurred = false;
-
-					logw("Sending SD+BL failed. Trying to send App only");
-					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING,
-                            "Invalid system components. Trying to send application");
-					mFileType = DfuBaseService.TYPE_APPLICATION;
-
-					// Set new content type in the ZIP Input Stream and update sizes of images
-					final ArchiveInputStream zhis = (ArchiveInputStream) mFirmwareStream;
-					zhis.setContentType(mFileType);
-					final byte[] applicationInit = zhis.getApplicationInit();
-					mInitPacketStream = new ByteArrayInputStream(applicationInit);
-					mInitPacketSizeInBytes = applicationInit.length;
-					mImageSizeInBytes = zhis.applicationImageSize();
-					mProgressInfo.init(mImageSizeInBytes, 2, 2);
-
-					sendInitPacket(gatt, false);
-				} else {
-					// There's noting we could do about it.
-					throw e;
-				}
-			}
-			sendFirmware(gatt);
-
-			// The device will reset so we don't have to send Disconnect signal.
-			mProgressInfo.setProgress(DfuBaseService.PROGRESS_DISCONNECTING);
-			mService.waitUntilDisconnected();
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_INFO, "Disconnected by the remote device");
-
-			// We are ready with DFU, the device is disconnected, let's close it and finalize the operation.
-			finalize(intent, false);
-		} catch (@SuppressWarnings("CaughtExceptionImmediatelyRethrown") final UploadAbortedException e) {
-			// In secure DFU there is currently not possible to reset the device to application mode, so... do nothing
-			// The connection will be terminated in the DfuBaseService
-			throw e;
-		} catch (final UnknownResponseException e) {
-			final int error = DfuBaseService.ERROR_INVALID_RESPONSE;
-			loge(e.getMessage());
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, e.getMessage());
-			mService.terminateConnection(gatt, error);
-		} catch (final RemoteDfuException e) {
-			final int error = DfuBaseService.ERROR_REMOTE_TYPE_SECURE | e.getErrorNumber();
-			loge(e.getMessage() + ": " + SecureDfuError.parse(error));
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, String.format(Locale.US,
-                    "Remote DFU error: %s", SecureDfuError.parse(error)));
-
-			// For the Extended Error more details can be obtained on some devices.
-			if (e instanceof RemoteDfuExtendedErrorException) {
-				final RemoteDfuExtendedErrorException ee = (RemoteDfuExtendedErrorException) e;
-				final int extendedError = DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | ee.getExtendedErrorNumber();
-				loge("Extended Error details: " + SecureDfuError.parseExtendedError(extendedError));
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR,
-                        "Details: " + SecureDfuError.parseExtendedError(extendedError) + " (Code = " + ee.getExtendedErrorNumber() + ")");
-				mService.terminateConnection(gatt, extendedError | DfuBaseService.ERROR_REMOTE_MASK);
-			} else {
-				mService.terminateConnection(gatt, error | DfuBaseService.ERROR_REMOTE_MASK);
-			}
-		}
-	}
-
-	/**
-	 * This method does the following:
-	 * <ol>
-	 *     <li>Selects the Command object - this Op Code returns the maximum acceptable size of a
-     *     command object, and the offset and CRC32 of the command that is already stored in the
-     *     device (in case the DFU was started in a previous connection and disconnected before
-     *     it has finished).</li>
-	 *     <li>If the offset received is greater than 0 and less or equal to the size of the
-     *     Init file that is to be sent, it will compare the
-	 *     received CRC with the local one and, if they match:
-	 *     	<ul>
-	 *     	    <li>If offset < init file size - it will continue sending the Init file from the
-     *     	    point it stopped before,</li>
-	 *     	    <li>If offset == init file size - it will send Execute command to execute the
-     *     	    Init file, as it may have not been executed before.</li>
-	 *     	</ul>
-	 *     </li>
-	 *     <li>If the CRC don't match, or the received offset is greater then init file size,
-     *     it creates the Command Object and sends the whole Init file as the previous one was
-     *     different.</li>
-	 * </ol>
-	 * Sending of the Init packet is done without using PRNs (Packet Receipt Notifications),
-     * so they are disabled prior to sending the data.
-	 *
-	 * @param gatt        the target GATT device.
-	 * @param allowResume true to allow resuming sending Init Packet. If false, it will be started
-     *                    again.
-	 * @throws RemoteDfuException
-	 * @throws DeviceDisconnectedException
-	 * @throws DfuException
-	 * @throws UploadAbortedException
-	 * @throws UnknownResponseException
-	 */
-	private void sendInitPacket(@NonNull final BluetoothGatt gatt, final boolean allowResume)
-			throws RemoteDfuException, DeviceDisconnectedException, DfuException, UploadAbortedException, UnknownResponseException {
-		final CRC32 crc32 = new CRC32(); // Used to calculate CRC32 of the Init packet
-		ObjectChecksum checksum;
-
-		// First, select the Command Object. As a response the maximum command size and information whether there is already
-		// a command saved from a previous connection is returned.
-		logi("Setting object to Command (Op Code = 6, Type = 1)");
-		final ObjectInfo info = selectObject(OBJECT_COMMAND);
-		logi(String.format(Locale.US, "Command object info received (Max size = %d, Offset = %d, CRC = %08X)", info.maxSize, info.offset, info.CRC32));
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, String.format(Locale.US, "Command object info received (Max size = %d, Offset = %d, CRC = %08X)", info.maxSize, info.offset, info.CRC32));
-		//noinspection StatementWithEmptyBody
-		if (mInitPacketSizeInBytes > info.maxSize) {
-			// Ignore this here. Later, after sending the 'Create object' command, DFU target will send an error if init packet is too large
-		}
-
-		// Can we resume? If the offset obtained from the device is greater then zero we can compare it with the local init packet CRC
-		// and resume sending the init packet, or even skip sending it if the whole file was sent before.
-		boolean skipSendingInitPacket = false;
-		boolean resumeSendingInitPacket = false;
-		if (allowResume && info.offset > 0 && info.offset <= mInitPacketSizeInBytes) {
-			try {
-				// Read the same number of bytes from the current init packet to calculate local CRC32
-				final byte[] buffer = new byte[info.offset];
-				//noinspection ResultOfMethodCallIgnored
-				mInitPacketStream.read(buffer);
-				// Calculate the CRC32
-				crc32.update(buffer);
-				final int crc = (int) (crc32.getValue() & 0xFFFFFFFFL);
-
-				if (info.CRC32 == crc) {
-					logi("Init packet CRC is the same");
-					if (info.offset ==  mInitPacketSizeInBytes) {
-						// The whole init packet was sent and it is equal to one we try to send now.
-						// There is no need to send it again. We may try to resume sending data.
-						logi("-> Whole Init packet was sent before");
-						skipSendingInitPacket = true;
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Received CRC match Init packet");
-					} else {
-						logi("-> " + info.offset + " bytes of Init packet were sent before");
-						resumeSendingInitPacket = true;
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Resuming sending Init packet...");
-					}
-				} else {
-					// A different Init packet was sent before, or the error occurred while sending.
-					// We have to send the whole Init packet again.
-					mInitPacketStream.reset();
-					crc32.reset();
-					info.offset = 0;
-				}
-			} catch (final IOException e) {
-				loge("Error while reading " + info.offset + " bytes from the init packet stream", e);
-				try {
-					// Go back to the beginning of the stream, we will send the whole init packet
-					mInitPacketStream.reset();
-					crc32.reset();
-					info.offset = 0;
-				} catch (final IOException e1) {
-					loge("Error while resetting the init packet stream", e1);
-					mService.terminateConnection(gatt, DfuBaseService.ERROR_FILE_IO_EXCEPTION);
-					return;
-				}
-			}
-		}
-
-		if (!skipSendingInitPacket) {
-			// The Init packet is sent different way in this implementation than the firmware, and receiving PRNs is not implemented.
-			// This value might have been stored on the device, so we have to explicitly disable PRNs.
-			setPacketReceiptNotifications(0);
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Packet Receipt Notif disabled (Op Code = 2, Value = 0)");
-
-			for (int attempt = 1; attempt <= MAX_ATTEMPTS;) {
-				if (!resumeSendingInitPacket) {
-					// Create the Init object
-					logi("Creating Init packet object (Op Code = 1, Type = 1, Size = " + mInitPacketSizeInBytes + ")");
-					writeCreateRequest(OBJECT_COMMAND, mInitPacketSizeInBytes);
-					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Command object created");
-				}
-				// Write Init data to the Packet Characteristic
-				try {
-					logi("Sending " + (mInitPacketSizeInBytes - info.offset) + " bytes of init packet...");
-					writeInitData(mPacketCharacteristic, crc32);
-				} catch (final DeviceDisconnectedException e) {
-					loge("Disconnected while sending init packet");
-					throw e;
-				}
-				final int crc = (int) (crc32.getValue() & 0xFFFFFFFFL);
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, String.format(Locale.US, "Command object sent (CRC = %08X)", crc));
-
-				// Calculate Checksum
-				logi("Sending Calculate Checksum command (Op Code = 3)");
-				checksum = readChecksum();
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, String.format(Locale.US, "Checksum received (Offset = %d, CRC = %08X)", checksum.offset, checksum.CRC32));
-				logi(String.format(Locale.US, "Checksum received (Offset = %d, CRC = %08X)", checksum.offset, checksum.CRC32));
-
-				if (crc == checksum.CRC32) {
-					// Everything is OK, we can proceed
-					break;
-				} else {
-					if (attempt < MAX_ATTEMPTS) {
-						attempt++;
-						logi("CRC does not match! Retrying...(" + attempt + "/" + MAX_ATTEMPTS + ")");
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, "CRC does not match! Retrying...(" + attempt + "/" + MAX_ATTEMPTS + ")");
-						try {
-							// Go back to the beginning, we will send the whole Init packet again
-							resumeSendingInitPacket = false;
-							info.offset = 0;
-							info.CRC32 = 0;
-							mInitPacketStream.reset();
-							crc32.reset();
-						} catch (final IOException e) {
-							loge("Error while resetting the init packet stream", e);
-							mService.terminateConnection(gatt, DfuBaseService.ERROR_FILE_IO_EXCEPTION);
-							return;
-						}
-					} else {
-						loge("CRC does not match!");
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, "CRC does not match!");
-						mService.terminateConnection(gatt, DfuBaseService.ERROR_CRC_ERROR);
-						return;
-					}
-				}
-			}
-		}
-
-		// Execute Init packet. It's better to execute it twice than not execute at all...
-		logi("Executing init packet (Op Code = 4)");
-		writeExecute();
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Command object executed");
-	}
-
-	/**
-	 * This method does the following:
-	 * <ol>
-	 *     <li>Sets the Packet Receipt Notification to a value specified in the settings.</li>
-	 *     <li>Selects the Data object - this returns maximum single object size and the offset
-     *     and CRC of the data already saved.</li>
-	 *     <li>If the offset received is greater than 0 it will calculate the CRC of the same
-     *     number of bytes of the firmware to be sent. If the CRC match it will continue sending data.
-     *     Otherwise, it will go back to the beginning of the last chunk, or to the beginning
-	 *     of the previous chunk assuming the last one was not executed before, and continue
-     *     sending data from there.</li>
-	 *     <li>If the CRC and offset received match and the offset is equal to the firmware size,
-     *     it will only send the Execute command.</li>
-	 * </ol>
-	 * @param gatt the target GATT device.
-	 * @throws RemoteDfuException
-	 * @throws DeviceDisconnectedException
-	 * @throws DfuException
-	 * @throws UploadAbortedException
-	 * @throws UnknownResponseException
-	 */
-	private void sendFirmware(final BluetoothGatt gatt) throws RemoteDfuException,
-            DeviceDisconnectedException, DfuException, UploadAbortedException, UnknownResponseException {
-		// Send the number of packets of firmware before receiving a receipt notification
-		int numberOfPacketsBeforeNotification = mPacketsBeforeNotification;
-		if (numberOfPacketsBeforeNotification > 0) {
-			setPacketReceiptNotifications(numberOfPacketsBeforeNotification);
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION,
-					"Packet Receipt Notif Req (Op Code = 2) sent (Value = " + numberOfPacketsBeforeNotification + ")");
-		}
-
-		// We are ready to start sending the new firmware.
-
-		logi("Setting object to Data (Op Code = 6, Type = 2)");
-		final ObjectInfo info = selectObject(OBJECT_DATA);
-		logi(String.format(Locale.US,
-				"Data object info received (Max size = %d, Offset = %d, CRC = %08X)", info.maxSize, info.offset, info.CRC32));
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, String.format(Locale.US,
-				"Data object info received (Max size = %d, Offset = %d, CRC = %08X)", info.maxSize, info.offset, info.CRC32));
-		mProgressInfo.setMaxObjectSizeInBytes(info.maxSize);
-
-		// Number of chunks in which the data will be sent
-		final int chunkCount = (mImageSizeInBytes + info.maxSize - 1) / info.maxSize;
-		int currentChunk = 0;
-		boolean resumeSendingData = false;
-
-		// Can we resume? If the offset obtained from the device is greater then zero we can compare it with the local CRC
-		// and resume sending the data.
-		if (info.offset > 0) {
-			try {
-				currentChunk = info.offset / info.maxSize;
-				int bytesSentAndExecuted = info.maxSize * currentChunk;
-				int bytesSentNotExecuted = info.offset - bytesSentAndExecuted;
-
-				// If the offset is dividable by maxSize, assume that the last page was not executed
-				if (bytesSentNotExecuted == 0) {
-					bytesSentAndExecuted -= info.maxSize;
-					bytesSentNotExecuted = info.maxSize;
-				}
-
-				// Read the same number of bytes from the current init packet to calculate local CRC32
-				if (bytesSentAndExecuted > 0) {
-					//noinspection ResultOfMethodCallIgnored
-					mFirmwareStream.read(new byte[bytesSentAndExecuted]); // Read executed bytes
-					mFirmwareStream.mark(info.maxSize); // Mark here
-				}
-				// Here the bytesSentNotExecuted is for sure greater then 0
-				//noinspection ResultOfMethodCallIgnored
-				mFirmwareStream.read(new byte[bytesSentNotExecuted]); // Read the rest
-
-				// Calculate the CRC32
-				final int crc = (int) (((ArchiveInputStream) mFirmwareStream).getCrc32() & 0xFFFFFFFFL);
-
-				if (crc == info.CRC32) {
-					logi(info.offset + " bytes of data sent before, CRC match");
-					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION,
-							info.offset + " bytes of data sent before, CRC match");
-					mProgressInfo.setBytesSent(info.offset);
-					mProgressInfo.setBytesReceived(info.offset);
-
-					// If the whole page was sent and CRC match, we have to make sure it was executed
-					if (bytesSentNotExecuted == info.maxSize && info.offset < mImageSizeInBytes) {
-						logi("Executing data object (Op Code = 4)");
-						try {
-							writeExecute();
-							mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Data object executed");
-						} catch (final RemoteDfuException e) {
-							// In DFU bootloader from SDK 15.x, 16 and 17 there's a bug, which
-							// prevents executing an object that has already been executed.
-							// See: https://github.com/NordicSemiconductor/Android-DFU-Library/issues/252
-							if (e.getErrorNumber() != SecureDfuError.OPERATION_NOT_PERMITTED) {
-								throw e;
-							}
-							mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Data object already executed");
-							// At this point, the error flag should be cleared, and the subsequent process can be executed normally.
-							mRemoteErrorOccurred = false;
-						}
-					} else {
-						resumeSendingData = true;
-					}
-				} else {
-					logi(info.offset + " bytes sent before, CRC does not match");
-					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING,
-							info.offset + " bytes sent before, CRC does not match");
-					// The CRC of the current object is not correct. If there was another Data object sent before, its CRC must have been correct,
-					// as it has been executed. Either way, we have to create the current object again.
-					mProgressInfo.setBytesSent(bytesSentAndExecuted);
-					mProgressInfo.setBytesReceived(bytesSentAndExecuted);
-					info.offset -= bytesSentNotExecuted;
-					info.CRC32 = 0; // invalidate
-					mFirmwareStream.reset();
-					logi("Resuming from byte " + info.offset + "...");
-					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION,
-							"Resuming from byte " + info.offset + "...");
-				}
-			} catch (final IOException e) {
-				loge("Error while reading firmware stream", e);
-				mService.terminateConnection(gatt, DfuBaseService.ERROR_FILE_IO_EXCEPTION);
-				return;
-			}
-		} else {
-			// Initialize the timer used to calculate the transfer speed
-			mProgressInfo.setBytesSent(0);
-		}
-
-		final long startTime = SystemClock.elapsedRealtime();
-
-		if (info.offset < mImageSizeInBytes) {
-			int attempt = 1;
-			// Each page will be sent in MAX_ATTEMPTS
-			while (mProgressInfo.getAvailableObjectSizeIsBytes() > 0) {
-				if (!resumeSendingData) {
-					// Create the Data object
-					final int availableObjectSizeInBytes = mProgressInfo.getAvailableObjectSizeIsBytes();
-					logi("Creating Data object (Op Code = 1, Type = 2, Size = " + availableObjectSizeInBytes + ") (" + (currentChunk + 1) + "/" + chunkCount + ")");
-					writeCreateRequest(OBJECT_DATA, availableObjectSizeInBytes);
-					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION,
-                            "Data object (" + (currentChunk + 1) + "/" + chunkCount + ") created");
-					// Waiting until the device is ready to receive the data object.
-					// If prepare data object delay was set in the initiator, the delay will be used
-					// for all data objects.
-					if (prepareObjectDelay > 0 || chunkCount == 0) {
-						mService.waitFor(prepareObjectDelay > 0 ? prepareObjectDelay : 400);
-					}
-					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION,
-                            "Uploading firmware...");
-				} else {
-					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION,
-                            "Resuming uploading firmware...");
-					resumeSendingData = false;
-				}
-
-				// Send the current object part
-				try {
-					logi("Uploading firmware...");
-					uploadFirmwareImage(mPacketCharacteristic);
-				} catch (final DeviceDisconnectedException e) {
-					loge("Disconnected while sending data");
-					throw e;
-				}
-
-				// Calculate Checksum
-				logi("Sending Calculate Checksum command (Op Code = 3)");
-				final ObjectChecksum checksum = readChecksum();
-				logi(String.format(Locale.US, "Checksum received (Offset = %d, CRC = %08X)", checksum.offset, checksum.CRC32));
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, String.format(Locale.US,
-                        "Checksum received (Offset = %d, CRC = %08X)", checksum.offset, checksum.CRC32));
-
-				// It may happen, that not all bytes that were sent were received by the remote device
-				final int bytesLost = mProgressInfo.getBytesSent() - checksum.offset;
-				if (bytesLost > 0) {
-					logw(bytesLost + " bytes were lost!");
-					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING,
-                            bytesLost + " bytes were lost");
-
-					try {
-						// We have to reset the stream and read 'offset' number of bytes to recalculate the CRC
-						mFirmwareStream.reset(); // Resets to the beginning of current object
-						//noinspection ResultOfMethodCallIgnored
-						mFirmwareStream.read(new byte[info.maxSize - bytesLost]); // Reads additional bytes that were sent and received in this object
-						mProgressInfo.setBytesSent(checksum.offset);
-					} catch (final IOException e) {
-						loge("Error while reading firmware stream", e);
-						mService.terminateConnection(gatt, DfuBaseService.ERROR_FILE_IO_EXCEPTION);
-						return;
-					} catch (final Throwable tr) {
-						// crash fix
-						// Check https://github.com/NordicSemiconductor/Android-DFU-Library/issues/229
-						loge("Progress lost. Bytes sent: " + mProgressInfo.getBytesSent(), tr);
-						mService.terminateConnection(gatt, DfuBaseService.ERROR_PROGRESS_LOST);
-						return;
-					}
-					// To decrease the chance of loosing data next time let's set PRN to 1.
-					// This will make the update very long, but perhaps it will succeed.
-					final int newPrn = 1;
-					if (mPacketsBeforeNotification == 0 || mPacketsBeforeNotification > newPrn) {
-						numberOfPacketsBeforeNotification = mPacketsBeforeNotification = newPrn;
-						setPacketReceiptNotifications(numberOfPacketsBeforeNotification);
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION,
-								"Packet Receipt Notif Req (Op Code = 2) sent (Value = " + newPrn + ")");
-					}
-				}
-
-				// Calculate the CRC32
-				final int crc = (int) (((ArchiveInputStream) mFirmwareStream).getCrc32() & 0xFFFFFFFFL);
-				if (crc == checksum.CRC32) {
-					if (bytesLost > 0) {
-						resumeSendingData = true;
-						continue;
-					}
-					// Execute Init packet
-					logi("Executing data object (Op Code = 4)");
-					writeExecute(mProgressInfo.isComplete());
-					mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Data object executed");
-
-					// Increment iterator
-					currentChunk++;
-					attempt = 1;
-					//Mark this location after completion of successful transfer.  In the event of a CRC retry on the next packet we will restart from this point.
-					mFirmwareStream.mark(0);
-				} else {
-					String crcFailMessage = String.format(Locale.US, "CRC does not match! Expected %08X but found %08X.", crc, checksum.CRC32);
-					if (attempt < MAX_ATTEMPTS) {
-						attempt++;
-						crcFailMessage += String.format(Locale.US, " Retrying...(%d/%d)", attempt, MAX_ATTEMPTS);
-						logi(crcFailMessage);
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, crcFailMessage);
-						try {
-							// Reset the CRC and file pointer back to the previous mark() point after completion of the last successful packet.
-							mFirmwareStream.reset();
-							mProgressInfo.setBytesSent(((ArchiveInputStream) mFirmwareStream).getBytesRead());
-						} catch (final IOException e) {
-							loge("Error while resetting the firmware stream", e);
-							mService.terminateConnection(gatt, DfuBaseService.ERROR_FILE_IO_EXCEPTION);
-							return;
-						}
-					} else {
-						loge(crcFailMessage);
-						mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_ERROR, crcFailMessage);
-						mService.terminateConnection(gatt, DfuBaseService.ERROR_CRC_ERROR);
-						return;
-					}
-				}
-			}
-		} else {
-			// Looks as if the whole file was sent correctly but has not been executed
-			logi("Executing data object (Op Code = 4)");
-			writeExecute(true);
-			mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Data object executed");
-		}
-
-		final long endTime = SystemClock.elapsedRealtime();
-		logi("Transfer of " + (mProgressInfo.getBytesSent() - info.offset) + " bytes has taken " + (endTime - startTime) + " ms");
-		mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_APPLICATION, "Upload completed in " + (endTime - startTime) + " ms");
-	}
-
-	/**
-	 * Checks whether the response received is valid and returns the status code.
-	 *
-	 * @param response the response received from the DFU device.
-	 * @param request  the expected Op Code
-	 * @return the status code
-	 * @throws UnknownResponseException if response was not valid
-	 */
-	private int getStatusCode(final byte[] response, final int request) throws UnknownResponseException {
-		if (response == null || response.length < 3 || response[0] != OP_CODE_RESPONSE_CODE_KEY || response[1] != request ||
-				(response[2] != DFU_STATUS_SUCCESS &&
-						response[2] != SecureDfuError.OP_CODE_NOT_SUPPORTED &&
-						response[2] != SecureDfuError.INVALID_PARAM &&
-						response[2] != SecureDfuError.INSUFFICIENT_RESOURCES &&
-						response[2] != SecureDfuError.INVALID_OBJECT &&
-						response[2] != SecureDfuError.UNSUPPORTED_TYPE &&
-						response[2] != SecureDfuError.OPERATION_NOT_PERMITTED &&
-						response[2] != SecureDfuError.OPERATION_FAILED &&
-						response[2] != SecureDfuError.EXTENDED_ERROR))
-			throw new UnknownResponseException("Invalid response received", response, OP_CODE_RESPONSE_CODE_KEY, request);
-		return response[2];
-	}
-
-	/**
-	 * Sets number of data packets that will be send before the notification will be received.
-	 *
-	 * @param data  control point data packet
-	 * @param value number of packets before receiving notification. If this value is 0, then the
-     *              notification of packet receipt will be disabled by the DFU target.
-	 */
-	private void setNumberOfPackets(@SuppressWarnings("SameParameterValue") @NonNull final byte[] data, final int value) {
-		data[1] = (byte) (value & 0xFF);
-		data[2] = (byte) ((value >> 8) & 0xFF);
-	}
-
-	/**
-	 * Sets the object size in correct position of the data array.
-	 *
-	 * @param data  control point data packet
-	 * @param value Object size in bytes.
-	 */
-	private void setObjectSize(@NonNull final byte[] data, final int value) {
-		data[2] = (byte) (value & 0xFF);
-		data[3] = (byte) ((value >> 8) & 0xFF);
-		data[4] = (byte) ((value >> 16) & 0xFF);
-		data[5] = (byte) ((value >> 24) & 0xFF);
-	}
-
-	/**
-	 * Sets the number of packets that needs to be sent to receive the Packet Receipt Notification.
-	 * Value 0 disables PRNs. By default this is disabled. The PRNs may be used to send both the
-	 * Data and Command object, but this Secure DFU implementation can handle them only during Data transfer.
-	 * <p>
-	 * The intention of having PRNs is to make sure the outgoing BLE buffer is not getting overflown.
-	 * The PRN will be sent after sending all packets from the queue.
-	 *
-	 * @param number number of packets required before receiving a Packet Receipt Notification.
-	 * @throws DfuException
-	 * @throws DeviceDisconnectedException
-	 * @throws UploadAbortedException
-	 * @throws UnknownResponseException
-	 * @throws RemoteDfuException thrown when the returned status code is not equal to {@link #DFU_STATUS_SUCCESS}
-	 */
-	private void setPacketReceiptNotifications(final int number)
-			throws DfuException, DeviceDisconnectedException, UploadAbortedException,
-			UnknownResponseException, RemoteDfuException {
-		if (!mConnected)
-			throw new DeviceDisconnectedException("Unable to read Checksum: device disconnected");
-
-		// Send the number of packets of firmware before receiving a receipt notification
-		logi("Sending the number of packets before notifications (Op Code = 2, Value = " + number + ")");
-		setNumberOfPackets(OP_CODE_PACKET_RECEIPT_NOTIF_REQ, number);
-		writeOpCode(mControlPointCharacteristic, OP_CODE_PACKET_RECEIPT_NOTIF_REQ);
-
-		// Read response
-		final byte[] response = readNotificationResponse();
-		final int status = getStatusCode(response, OP_CODE_PACKET_RECEIPT_NOTIF_REQ_KEY);
-		if (status == SecureDfuError.EXTENDED_ERROR)
-			throw new RemoteDfuExtendedErrorException("Sending the number of packets failed", response[3]);
-		if (status != DFU_STATUS_SUCCESS)
-			throw new RemoteDfuException("Sending the number of packets failed", status);
-	}
-
-	/**
-	 * Writes the operation code to the characteristic. This method is SYNCHRONOUS and wait until the
-	 * {@link android.bluetooth.BluetoothGattCallback#onCharacteristicWrite(android.bluetooth.BluetoothGatt, android.bluetooth.BluetoothGattCharacteristic, int)}
-	 * will be called or the device gets disconnected.
-	 * If connection state will change, or an error will occur, an exception will be thrown.
-	 *
-	 * @param characteristic the characteristic to write to. Should be the DFU CONTROL POINT.
-	 * @param value          the value to write to the characteristic.
-	 * @throws DeviceDisconnectedException
-	 * @throws DfuException
-	 * @throws UploadAbortedException
-	 */
-	private void writeOpCode(@NonNull final BluetoothGattCharacteristic characteristic, @NonNull final byte[] value)
-			throws DeviceDisconnectedException, DfuException, UploadAbortedException {
-		writeOpCode(characteristic, value, false);
-	}
-
-	/**
-	 * Writes Create Object request providing the type and size of the object.
-	 *
-	 * @param type {@link #OBJECT_COMMAND} or {@link #OBJECT_DATA}.
-	 * @param size size of the object or current part of the object.
-	 * @throws DeviceDisconnectedException
-	 * @throws DfuException
-	 * @throws UploadAbortedException
-	 * @throws RemoteDfuException thrown when the returned status code is not equal to {@link #DFU_STATUS_SUCCESS}
-	 * @throws UnknownResponseException
-	 */
-	private void writeCreateRequest(final int type, final int size)
-			throws DeviceDisconnectedException, DfuException, UploadAbortedException, RemoteDfuException,
-			UnknownResponseException {
-		if (!mConnected)
-			throw new DeviceDisconnectedException("Unable to create object: device disconnected");
-
-		final byte[] data = (type == OBJECT_COMMAND) ? OP_CODE_CREATE_COMMAND : OP_CODE_CREATE_DATA;
-		setObjectSize(data, size);
-		writeOpCode(mControlPointCharacteristic, data);
-
-		final byte[] response = readNotificationResponse();
-		final int status = getStatusCode(response, OP_CODE_CREATE_KEY);
-		if (status == SecureDfuError.EXTENDED_ERROR)
-			throw new RemoteDfuExtendedErrorException("Creating Command object failed", response[3]);
-		if (status != DFU_STATUS_SUCCESS)
-			throw new RemoteDfuException("Creating Command object failed", status);
-	}
-
-	/**
-	 * Selects the current object and reads its metadata. The object info contains the max object
-	 * size, and the offset and CRC32 of the whole object until now.
-	 *
-	 * @return object info.
-	 * @throws DeviceDisconnectedException
-	 * @throws DfuException
-	 * @throws UploadAbortedException
-	 * @throws RemoteDfuException thrown when the returned status code is not equal to
-	 * {@link #DFU_STATUS_SUCCESS}.
-	 */
-	private ObjectInfo selectObject(final int type)
-			throws DeviceDisconnectedException, DfuException, UploadAbortedException,
-			RemoteDfuException, UnknownResponseException {
-		if (!mConnected)
-			throw new DeviceDisconnectedException("Unable to read object info: device disconnected");
-
-		OP_CODE_SELECT_OBJECT[1] = (byte) type;
-		writeOpCode(mControlPointCharacteristic, OP_CODE_SELECT_OBJECT);
-
-		final byte[] response = readNotificationResponse();
-		final int status = getStatusCode(response, OP_CODE_SELECT_OBJECT_KEY);
-		if (status == SecureDfuError.EXTENDED_ERROR)
-			throw new RemoteDfuExtendedErrorException("Selecting object failed", response[3]);
-		if (status != DFU_STATUS_SUCCESS)
-			throw new RemoteDfuException("Selecting object failed", status);
-
-		final ObjectInfo info = new ObjectInfo();
-		info.maxSize = unsignedBytesToInt(response, 3);
-		info.offset = unsignedBytesToInt(response, 3 + 4);
-		info.CRC32  = unsignedBytesToInt(response, 3 + 8);
-		return info;
-	}
-
-	/**
-	 * Sends the Calculate Checksum request. As a response a notification will be sent with current
-     * offset and CRC32 of the current object.
-	 *
-	 * @return requested object info.
-	 * @throws DeviceDisconnectedException
-	 * @throws DfuException
-	 * @throws UploadAbortedException
-	 * @throws RemoteDfuException thrown when the returned status code is not equal to
-     * {@link #DFU_STATUS_SUCCESS}.
-	 */
-	private ObjectChecksum readChecksum() throws DeviceDisconnectedException, DfuException,
-            UploadAbortedException, RemoteDfuException, UnknownResponseException {
-		if (!mConnected)
-			throw new DeviceDisconnectedException("Unable to read Checksum: device disconnected");
-
-		writeOpCode(mControlPointCharacteristic, OP_CODE_CALCULATE_CHECKSUM);
-
-		final byte[] response = readNotificationResponse();
-		final int status = getStatusCode(response, OP_CODE_CALCULATE_CHECKSUM_KEY);
-		if (status == SecureDfuError.EXTENDED_ERROR)
-			throw new RemoteDfuExtendedErrorException("Receiving Checksum failed", response[3]);
-		if (status != DFU_STATUS_SUCCESS)
-			throw new RemoteDfuException("Receiving Checksum failed", status);
-
-		final ObjectChecksum checksum = new ObjectChecksum();
-		checksum.offset = unsignedBytesToInt(response, 3);
-		checksum.CRC32  = unsignedBytesToInt(response, 3 + 4);
-		return checksum;
-	}
-
-	private int unsignedBytesToInt(@NonNull final byte[] array, final int offset) {
-		return (array[offset] & 0xFF) + ((array[offset + 1] & 0xFF) << 8)
-			+ ((array[offset + 2] & 0xFF) << 16) + ((array[offset + 3] & 0xFF) << 24);
-	}
-
-	/**
-	 * Sends the Execute operation code and awaits for a return notification containing status code.
-	 * The Execute command will confirm the last chunk of data or the last command that was sent.
-	 * Creating the same object again, instead of executing it allows to retransmitting it in case
-     * of a CRC error.
-	 *
-	 * @throws DfuException
-	 * @throws DeviceDisconnectedException
-	 * @throws UploadAbortedException
-	 * @throws UnknownResponseException
-	 * @throws RemoteDfuException thrown when the returned status code is not equal to
-     * {@link #DFU_STATUS_SUCCESS}.
-	 */
-	private void writeExecute() throws DfuException, DeviceDisconnectedException,
-            UploadAbortedException, UnknownResponseException, RemoteDfuException {
-		if (!mConnected)
-			throw new DeviceDisconnectedException("Unable to read Checksum: device disconnected");
-
-		writeOpCode(mControlPointCharacteristic, OP_CODE_EXECUTE);
-
-		final byte[] response = readNotificationResponse();
-		final int status = getStatusCode(response, OP_CODE_EXECUTE_KEY);
-		if (status == SecureDfuError.EXTENDED_ERROR)
-			throw new RemoteDfuExtendedErrorException("Executing object failed", response[3]);
-		if (status != DFU_STATUS_SUCCESS)
-			throw new RemoteDfuException("Executing object failed", status);
-	}
-
-	/**
-	 * After the whole firmware image was sent, the last command Execute will cause erasing memory
-	 * and flashing the new firmware. This may result in INVALID_OBJECT error in 2 cases:
-	 * <ol>
-	 *     <li>The SoftDevice (which is responsible for allowing writing) was busy and the bootloader
-	 *         tried to erase the memory N times without a success. Then we can resend the Execute here.</li>
-	 *     <li>The firmware sent contained only SoftDevice (no Bootloader) and the Major version has
-	 *         changed comparing to the previous one. The old bootloader would not work with this new SD
-	 *         so such update is forbidden as it would brick the device.</li>
-	 * </ol>
-	 * See: <a href="https://github.com/NordicSemiconductor/Android-DFU-Library/issues/86">https://github.com/NordicSemiconductor/Android-DFU-Library/issues/86</a>
-     *
-	 * @param allowRetry if true service will retry to send the execute command in case of
-     *                   INVALID_OBJECT error.
-	 * @throws DfuException
-	 * @throws DeviceDisconnectedException
-	 * @throws UploadAbortedException
-	 * @throws UnknownResponseException
-	 * @throws RemoteDfuException thrown when the returned status code is not equal to
-     * {@link #DFU_STATUS_SUCCESS}.
-	 */
-	private void writeExecute(final boolean allowRetry)
-            throws DfuException, DeviceDisconnectedException, UploadAbortedException,
-            UnknownResponseException, RemoteDfuException {
-		try {
-			writeExecute();
-		} catch (final RemoteDfuException e) {
-			if (allowRetry && e.getErrorNumber() == SecureDfuError.INVALID_OBJECT) {
-				logw(e.getMessage() + ": " + SecureDfuError.parse(DfuBaseService.ERROR_REMOTE_TYPE_SECURE | SecureDfuError.INVALID_OBJECT));
-				if (mFileType == DfuBaseService.TYPE_SOFT_DEVICE) {
-					logw("Are you sure your new SoftDevice is API compatible with the updated one? If not, update the bootloader as well");
-					// API compatible = both SoftDevices have the same Major version
-				}
-				mService.sendLogBroadcast(DfuBaseService.LOG_LEVEL_WARNING, String.format(Locale.US, "Remote DFU error: %s. SD busy? Retrying...",
-						SecureDfuError.parse(DfuBaseService.ERROR_REMOTE_TYPE_SECURE | SecureDfuError.INVALID_OBJECT)));
-				logi("SD busy? Retrying...");
-				logi("Executing data object (Op Code = 4)");
-				writeExecute();
-			} else {
-				throw e;
-			}
-		}
-	}
-
-	private static class ObjectInfo extends ObjectChecksum {
-		int maxSize;
-	}
-
-	private static class ObjectChecksum {
-		int offset;
-		int CRC32;
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/UuidHelper.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/UuidHelper.java
deleted file mode 100644
index e208b3b..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/UuidHelper.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu;
-
-import android.content.Intent;
-import android.os.ParcelUuid;
-import android.os.Parcelable;
-
-import androidx.annotation.NonNull;
-
-/* package */ class UuidHelper {
-
-	/* package */ static void assignCustomUuids(@NonNull final Intent intent) {
-		// Added in SDK 4.3.0. Legacy DFU and Legacy bootloader share the same UUIDs.
-		Parcelable[] uuids = intent.getParcelableArrayExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_LEGACY_DFU);
-		if (uuids != null && uuids.length == 4) {
-			LegacyDfuImpl.DFU_SERVICE_UUID       = uuids[0] != null ? ((ParcelUuid) uuids[0]).getUuid() : LegacyDfuImpl.DEFAULT_DFU_SERVICE_UUID;
-			LegacyDfuImpl.DFU_CONTROL_POINT_UUID = uuids[1] != null ? ((ParcelUuid) uuids[1]).getUuid() : LegacyDfuImpl.DEFAULT_DFU_CONTROL_POINT_UUID;
-			LegacyDfuImpl.DFU_PACKET_UUID        = uuids[2] != null ? ((ParcelUuid) uuids[2]).getUuid() : LegacyDfuImpl.DEFAULT_DFU_PACKET_UUID;
-			LegacyDfuImpl.DFU_VERSION_UUID       = uuids[3] != null ? ((ParcelUuid) uuids[3]).getUuid() : LegacyDfuImpl.DEFAULT_DFU_VERSION_UUID;
-
-			LegacyButtonlessDfuImpl.DFU_SERVICE_UUID       = LegacyDfuImpl.DFU_SERVICE_UUID;
-			LegacyButtonlessDfuImpl.DFU_CONTROL_POINT_UUID = LegacyDfuImpl.DFU_CONTROL_POINT_UUID;
-			// No need for DFU Packet in buttonless DFU
-			LegacyButtonlessDfuImpl.DFU_VERSION_UUID       = LegacyDfuImpl.DFU_VERSION_UUID;
-		} else {
-			LegacyDfuImpl.DFU_SERVICE_UUID       = LegacyDfuImpl.DEFAULT_DFU_SERVICE_UUID;
-			LegacyDfuImpl.DFU_CONTROL_POINT_UUID = LegacyDfuImpl.DEFAULT_DFU_CONTROL_POINT_UUID;
-			LegacyDfuImpl.DFU_PACKET_UUID        = LegacyDfuImpl.DEFAULT_DFU_PACKET_UUID;
-			LegacyDfuImpl.DFU_VERSION_UUID       = LegacyDfuImpl.DEFAULT_DFU_VERSION_UUID;
-
-			LegacyButtonlessDfuImpl.DFU_SERVICE_UUID       = LegacyDfuImpl.DEFAULT_DFU_SERVICE_UUID;
-			LegacyButtonlessDfuImpl.DFU_CONTROL_POINT_UUID = LegacyDfuImpl.DEFAULT_DFU_CONTROL_POINT_UUID;
-			LegacyButtonlessDfuImpl.DFU_VERSION_UUID       = LegacyDfuImpl.DEFAULT_DFU_VERSION_UUID;
-		}
-
-		// Added in SDK 12
-		uuids = intent.getParcelableArrayExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_SECURE_DFU);
-		if (uuids != null && uuids.length == 3) {
-			SecureDfuImpl.DFU_SERVICE_UUID       = uuids[0] != null ? ((ParcelUuid) uuids[0]).getUuid() : SecureDfuImpl.DEFAULT_DFU_SERVICE_UUID;
-			SecureDfuImpl.DFU_CONTROL_POINT_UUID = uuids[1] != null ? ((ParcelUuid) uuids[1]).getUuid() : SecureDfuImpl.DEFAULT_DFU_CONTROL_POINT_UUID;
-			SecureDfuImpl.DFU_PACKET_UUID        = uuids[2] != null ? ((ParcelUuid) uuids[2]).getUuid() : SecureDfuImpl.DEFAULT_DFU_PACKET_UUID;
-		} else {
-			SecureDfuImpl.DFU_SERVICE_UUID       = SecureDfuImpl.DEFAULT_DFU_SERVICE_UUID;
-			SecureDfuImpl.DFU_CONTROL_POINT_UUID = SecureDfuImpl.DEFAULT_DFU_CONTROL_POINT_UUID;
-			SecureDfuImpl.DFU_PACKET_UUID        = SecureDfuImpl.DEFAULT_DFU_PACKET_UUID;
-		}
-
-		uuids = intent.getParcelableArrayExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_EXPERIMENTAL_BUTTONLESS_DFU);
-		if (uuids != null && uuids.length == 2) {
-			ExperimentalButtonlessDfuImpl.EXPERIMENTAL_BUTTONLESS_DFU_SERVICE_UUID = uuids[0] != null ? ((ParcelUuid) uuids[0]).getUuid() : ExperimentalButtonlessDfuImpl.DEFAULT_EXPERIMENTAL_BUTTONLESS_DFU_SERVICE_UUID;
-			ExperimentalButtonlessDfuImpl.EXPERIMENTAL_BUTTONLESS_DFU_UUID         = uuids[1] != null ? ((ParcelUuid) uuids[1]).getUuid() : ExperimentalButtonlessDfuImpl.DEFAULT_EXPERIMENTAL_BUTTONLESS_DFU_UUID;
-		} else {
-			ExperimentalButtonlessDfuImpl.EXPERIMENTAL_BUTTONLESS_DFU_SERVICE_UUID = ExperimentalButtonlessDfuImpl.DEFAULT_EXPERIMENTAL_BUTTONLESS_DFU_SERVICE_UUID;
-			ExperimentalButtonlessDfuImpl.EXPERIMENTAL_BUTTONLESS_DFU_UUID         = ExperimentalButtonlessDfuImpl.DEFAULT_EXPERIMENTAL_BUTTONLESS_DFU_UUID;
-		}
-
-		// Added in SDK 13
-		uuids = intent.getParcelableArrayExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_BUTTONLESS_DFU_WITHOUT_BOND_SHARING);
-		if (uuids != null && uuids.length == 2) {
-			ButtonlessDfuWithoutBondSharingImpl.BUTTONLESS_DFU_SERVICE_UUID = uuids[0] != null ? ((ParcelUuid) uuids[0]).getUuid() : ButtonlessDfuWithoutBondSharingImpl.DEFAULT_BUTTONLESS_DFU_SERVICE_UUID;
-			ButtonlessDfuWithoutBondSharingImpl.BUTTONLESS_DFU_UUID         = uuids[1] != null ? ((ParcelUuid) uuids[1]).getUuid() : ButtonlessDfuWithoutBondSharingImpl.DEFAULT_BUTTONLESS_DFU_UUID;
-		} else {
-			ButtonlessDfuWithoutBondSharingImpl.BUTTONLESS_DFU_SERVICE_UUID = ButtonlessDfuWithoutBondSharingImpl.DEFAULT_BUTTONLESS_DFU_SERVICE_UUID;
-			ButtonlessDfuWithoutBondSharingImpl.BUTTONLESS_DFU_UUID         = ButtonlessDfuWithoutBondSharingImpl.DEFAULT_BUTTONLESS_DFU_UUID;
-		}
-
-		// Added in SDK 14 (or later)
-		uuids = intent.getParcelableArrayExtra(DfuBaseService.EXTRA_CUSTOM_UUIDS_FOR_BUTTONLESS_DFU_WITH_BOND_SHARING);
-		if (uuids != null && uuids.length == 2) {
-			ButtonlessDfuWithBondSharingImpl.BUTTONLESS_DFU_SERVICE_UUID = uuids[0] != null ? ((ParcelUuid) uuids[0]).getUuid() : ButtonlessDfuWithBondSharingImpl.DEFAULT_BUTTONLESS_DFU_SERVICE_UUID;
-			ButtonlessDfuWithBondSharingImpl.BUTTONLESS_DFU_UUID         = uuids[1] != null ? ((ParcelUuid) uuids[1]).getUuid() : ButtonlessDfuWithBondSharingImpl.DEFAULT_BUTTONLESS_DFU_UUID;
-		} else {
-			ButtonlessDfuWithBondSharingImpl.BUTTONLESS_DFU_SERVICE_UUID = ButtonlessDfuWithBondSharingImpl.DEFAULT_BUTTONLESS_DFU_SERVICE_UUID;
-			ButtonlessDfuWithBondSharingImpl.BUTTONLESS_DFU_UUID         = ButtonlessDfuWithBondSharingImpl.DEFAULT_BUTTONLESS_DFU_UUID;
-		}
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/ArchiveInputStream.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/ArchiveInputStream.java
deleted file mode 100644
index a0cdbcf..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/ArchiveInputStream.java
+++ /dev/null
@@ -1,665 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu.internal;
-
-import android.os.Build;
-import android.util.Log;
-
-import com.google.gson.Gson;
-
-import java.io.ByteArrayOutputStream;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.io.InputStream;
-import java.nio.charset.StandardCharsets;
-import java.util.HashMap;
-import java.util.Locale;
-import java.util.Map;
-import java.util.zip.CRC32;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipInputStream;
-
-import androidx.annotation.NonNull;
-import no.nordicsemi.android.dfu.DfuBaseService;
-import no.nordicsemi.android.dfu.internal.manifest.FileInfo;
-import no.nordicsemi.android.dfu.internal.manifest.Manifest;
-import no.nordicsemi.android.dfu.internal.manifest.ManifestFile;
-import no.nordicsemi.android.dfu.internal.manifest.SoftDeviceBootloaderFileInfo;
-
-/**
- * <p>
- * Reads the firmware files from the a ZIP file. The ZIP file must be either created using the
- * <a href="https://github.com/NordicSemiconductor/pc-nrfutil"><b>nrf util</b></a>,
- * or follow the backward compatibility syntax: must contain only files with names:
- * application.hex/bin, softdevice.hex/dat or bootloader.hex/bin, optionally also application.dat
- * and/or system.dat with init packets.
- * <p>
- * The ArchiveInputStream will read only files with types specified by <b>types</b> parameter of
- * the constructor.
- */
-public class ArchiveInputStream extends InputStream {
-	private static final String TAG = "DfuArchiveInputStream";
-
-	/**
-	 * The name of the manifest file is fixed.
-	 */
-	private static final String MANIFEST = "manifest.json";
-	// Those file names are for backwards compatibility mode
-	private static final String SOFTDEVICE_HEX = "softdevice.hex";
-	private static final String SOFTDEVICE_BIN = "softdevice.bin";
-	private static final String BOOTLOADER_HEX = "bootloader.hex";
-	private static final String BOOTLOADER_BIN = "bootloader.bin";
-	private static final String APPLICATION_HEX = "application.hex";
-	private static final String APPLICATION_BIN = "application.bin";
-	private static final String SYSTEM_INIT = "system.dat";
-	private static final String APPLICATION_INIT = "application.dat";
-
-	private final ZipInputStream zipInputStream;
-
-	/**
-	 * Contains bytes arrays with BIN files. HEX files are converted to BIN before being
-     * added to this map.
-	 */
-	private final Map<String, byte[]> entries;
-	private final CRC32 crc32;
-	private Manifest manifest;
-
-	private byte[] applicationBytes;
-	private byte[] softDeviceBytes;
-	private byte[] bootloaderBytes;
-	private byte[] softDeviceAndBootloaderBytes;
-	private byte[] systemInitBytes;
-	private byte[] applicationInitBytes;
-	private byte[] currentSource;
-	private int type;
-	private int bytesReadFromCurrentSource;
-	private int softDeviceSize;
-	private int bootloaderSize;
-	private int applicationSize;
-	private int bytesRead;
-
-	private byte[] markedSource;
-	private int bytesReadFromMarkedSource;
-
-	/**
-	 * <p>
-	 * The ArchiveInputStream read HEX or BIN files from the Zip stream. It may skip some of them,
-     * depending on the value of the types parameter. This is useful if the DFU service wants to
-     * send the Soft Device and Bootloader only, and then the Application in the following connection,
-     * despite the ZIP file contains all 3 HEX/BIN files.
-	 * When types is equal to {@link DfuBaseService#TYPE_AUTO} all present files are read.
-	 * <p>
-     * Use bit combination of the following types:
-	 * <ul>
-	 * <li>{@link DfuBaseService#TYPE_SOFT_DEVICE}</li>
-	 * <li>{@link DfuBaseService#TYPE_BOOTLOADER}</li>
-	 * <li>{@link DfuBaseService#TYPE_APPLICATION}</li>
-	 * <li>{@link DfuBaseService#TYPE_AUTO}</li>
-	 * </ul>
-	 *
-	 * @param stream  the Zip Input Stream
-	 * @param mbrSize The size of the MRB segment (Master Boot Record) on the device.
-     *                The parser will cut data from addresses below that number from all HEX files.
-	 * @param types   File types that are to be read from the ZIP. Use
-     *                {@link DfuBaseService#TYPE_APPLICATION} etc.
-	 * @throws java.io.IOException Thrown in case of an invalid ZIP file.
-	 */
-	public ArchiveInputStream(final InputStream stream, final int mbrSize, final int types)
-            throws IOException {
-		this.zipInputStream = new ZipInputStream(stream);
-
-		this.crc32 = new CRC32();
-		this.entries = new HashMap<>();
-		this.bytesRead = 0;
-		this.bytesReadFromCurrentSource = 0;
-
-		try {
-			/*
-			 * This method reads all entries from the ZIP file and puts them to entries map.
-			 * The 'manifest.json' file, if exists, is converted to the manifestData String.
-			 */
-			parseZip(mbrSize);
-
-			/*
-			 * Let's read and parse the 'manifest.json' file.
-			 */
-			if (manifest != null) {
-				boolean valid = false;
-
-				// Read the application
-				if (manifest.getApplicationInfo() != null && (types == DfuBaseService.TYPE_AUTO || (types & DfuBaseService.TYPE_APPLICATION) > 0)) {
-					final FileInfo application = manifest.getApplicationInfo();
-					applicationBytes = entries.get(application.getBinFileName());
-					applicationInitBytes = entries.get(application.getDatFileName());
-
-					if (applicationBytes == null)
-						throw new IOException("Application file " + application.getBinFileName() + " not found.");
-					applicationSize = applicationBytes.length;
-					currentSource = applicationBytes;
-					valid = true;
-				}
-
-				// Read the Bootloader
-				if (manifest.getBootloaderInfo() != null && (types == DfuBaseService.TYPE_AUTO || (types & DfuBaseService.TYPE_BOOTLOADER) > 0)) {
-					if (systemInitBytes != null)
-						throw new IOException("Manifest: softdevice and bootloader specified. Use softdevice_bootloader instead.");
-
-					final FileInfo bootloader = manifest.getBootloaderInfo();
-					bootloaderBytes = entries.get(bootloader.getBinFileName());
-					systemInitBytes = entries.get(bootloader.getDatFileName());
-
-					if (bootloaderBytes == null)
-						throw new IOException("Bootloader file " + bootloader.getBinFileName() + " not found.");
-					bootloaderSize = bootloaderBytes.length;
-					currentSource = bootloaderBytes;
-					valid = true;
-				}
-
-				// Read the Soft Device
-				if (manifest.getSoftdeviceInfo() != null && (types == DfuBaseService.TYPE_AUTO || (types & DfuBaseService.TYPE_SOFT_DEVICE) > 0)) {
-					final FileInfo softdevice = manifest.getSoftdeviceInfo();
-					softDeviceBytes = entries.get(softdevice.getBinFileName());
-					systemInitBytes = entries.get(softdevice.getDatFileName());
-
-					if (softDeviceBytes == null)
-						throw new IOException("SoftDevice file " + softdevice.getBinFileName() + " not found.");
-					softDeviceSize = softDeviceBytes.length;
-					currentSource = softDeviceBytes;
-					valid = true;
-				}
-
-				// Read the combined Soft Device and Bootloader
-				if (manifest.getSoftdeviceBootloaderInfo() != null && (types == DfuBaseService.TYPE_AUTO ||
-						((types & DfuBaseService.TYPE_SOFT_DEVICE) > 0) && (types & DfuBaseService.TYPE_BOOTLOADER) > 0)) {
-					if (systemInitBytes != null)
-						throw new IOException("Manifest: The softdevice_bootloader may not be used together with softdevice or bootloader.");
-
-					final SoftDeviceBootloaderFileInfo system = manifest.getSoftdeviceBootloaderInfo();
-					softDeviceAndBootloaderBytes = entries.get(system.getBinFileName());
-					systemInitBytes = entries.get(system.getDatFileName());
-
-					if (softDeviceAndBootloaderBytes == null)
-						throw new IOException("File " + system.getBinFileName() + " not found.");
-					softDeviceSize = system.getSoftdeviceSize();
-					bootloaderSize = system.getBootloaderSize();
-					currentSource = softDeviceAndBootloaderBytes;
-					valid = true;
-				}
-
-				if (!valid) {
-					throw new IOException("Manifest file must specify at least one file.");
-				}
-			} else {
-				/*
-				 * Compatibility mode. The 'manifest.json' file does not exist.
-				 *
-				 * In that case the ZIP file must contain one or more of the following files:
-				 *
-				 * - application.hex/dat
-				 *     + application.dat
-				 * - softdevice.hex/dat
-				 * - bootloader.hex/dat
-				 *     + system.dat
-				 */
-				boolean valid = false;
-				// Search for the application
-				if (types == DfuBaseService.TYPE_AUTO || (types & DfuBaseService.TYPE_APPLICATION) > 0) {
-					applicationBytes = entries.get(APPLICATION_HEX); // the entry bytes has already been converted to BIN, just the name remained.
-					if (applicationBytes == null)
-						applicationBytes = entries.get(APPLICATION_BIN);
-					if (applicationBytes != null) {
-						applicationSize = applicationBytes.length;
-						applicationInitBytes = entries.get(APPLICATION_INIT);
-						currentSource = applicationBytes;
-						valid = true;
-					}
-				}
-
-				// Search for theBootloader
-				if (types == DfuBaseService.TYPE_AUTO || (types & DfuBaseService.TYPE_BOOTLOADER) > 0) {
-					bootloaderBytes = entries.get(BOOTLOADER_HEX); // the entry bytes has already been converted to BIN, just the name remained.
-					if (bootloaderBytes == null)
-						bootloaderBytes = entries.get(BOOTLOADER_BIN);
-					if (bootloaderBytes != null) {
-						bootloaderSize = bootloaderBytes.length;
-						systemInitBytes = entries.get(SYSTEM_INIT);
-						currentSource = bootloaderBytes;
-						valid = true;
-					}
-				}
-
-				// Search for the Soft Device
-				if (types == DfuBaseService.TYPE_AUTO || (types & DfuBaseService.TYPE_SOFT_DEVICE) > 0) {
-					softDeviceBytes = entries.get(SOFTDEVICE_HEX); // the entry bytes has already been converted to BIN, just the name remained.
-					if (softDeviceBytes == null)
-						softDeviceBytes = entries.get(SOFTDEVICE_BIN);
-					if (softDeviceBytes != null) {
-						softDeviceSize = softDeviceBytes.length;
-						systemInitBytes = entries.get(SYSTEM_INIT);
-						currentSource = softDeviceBytes;
-						valid = true;
-					}
-				}
-
-				if (!valid) {
-					throw new IOException("The ZIP file must contain an Application, a Soft Device and/or a Bootloader.");
-				}
-			}
-			mark(0);
-		} finally {
-			type = getContentType();
-			zipInputStream.close();
-		}
-	}
-
-	/**
-	 * Validates the path (not the content) of the zip file to prevent path traversal issues.
-	 *
-	 * <p> When unzipping an archive, always validate the compressed files' paths and reject any path
-	 * that has a path traversal (such as ../..). Simply looking for .. characters in the compressed
-	 * file's path may not be enough to prevent path traversal issues. The code validates the name of
-	 * the entry before extracting the entry. If the name is invalid, the entire extraction is aborted.
-	 * <p>
-	 *
-	 * @param filename The path to the file.
-	 * @param intendedDir The intended directory where the zip should be.
-	 * @return The validated path to the file.
-	 * @throws java.io.IOException Thrown in case of path traversal issues.
-	 */
-	@SuppressWarnings("SameParameterValue")
-	private String validateFilename(@NonNull final String filename,
-									@NonNull final String intendedDir)
-			throws java.io.IOException {
-		File f = new File(filename);
-		String canonicalPath = f.getCanonicalPath();
-
-		File iD = new File(intendedDir);
-		String canonicalID = iD.getCanonicalPath();
-
-		if (canonicalPath.startsWith(canonicalID)) {
-			return canonicalPath.substring(1); // remove leading "/"
-		} else {
-			throw new IllegalStateException("File is outside extraction target directory.");
-		}
-	}
-
-	/**
-	 * Reads all files into byte arrays.
-	 * Here we don't know whether the ZIP file is valid.
-	 * <p>
-	 * The ZIP file is valid when contains a 'manifest.json' file and all BIN and DAT files that
-     * are specified in the manifest.
-	 * <p>
-	 * For backwards compatibility ArchiveInputStream supports also ZIP archives without
-     * 'manifest.json' file but than it MUST include at least one of the following files:
-     * softdevice.bin/hex, bootloader.bin/hex, application.bin/hex.
-	 * To support the init packet such ZIP file should contain also application.dat and/or system.dat
-     * (with the CRC16 of a SD, BL or SD+BL together).
-	 */
-	private void parseZip(final int mbrSize) throws IOException {
-		final byte[] buffer = new byte[1024];
-		String manifestData = null;
-
-		ZipEntry ze;
-		while ((ze = zipInputStream.getNextEntry()) != null) {
-			final String filename = validateFilename(ze.getName(), ".");
-
-			if (ze.isDirectory()) {
-				Log.w(TAG, "A directory found in the ZIP: " + filename + "!");
-				continue;
-			}
-
-			// Read file content to byte array
-			final ByteArrayOutputStream baos = new ByteArrayOutputStream();
-			int count;
-			while ((count = zipInputStream.read(buffer)) != -1) {
-				baos.write(buffer, 0, count);
-			}
-			byte[] source = baos.toByteArray();
-
-			// In case of HEX file convert it to BIN
-			if (filename.toLowerCase(Locale.US).endsWith("hex")) {
-				final HexInputStream is = new HexInputStream(source, mbrSize);
-				source = new byte[is.available()];
-				is.read(source);
-				is.close();
-			}
-
-			// Save the file content either as a manifest data or by adding it to entries
-			if (MANIFEST.equals(filename))
-				if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-					manifestData = new String(source, StandardCharsets.UTF_8);
-				} else {
-					//noinspection CharsetObjectCanBeUsed
-					manifestData = new String(source, "UTF-8");
-				}
-			else
-				entries.put(filename, source);
-		}
-
-		// Some validation
-		if (entries.isEmpty()) {
-			throw new FileNotFoundException("No files found in the ZIP. Check if the URI provided is " +
-                    "valid and the ZIP contains required files on root level, not in a directory.");
-		}
-
-		if (manifestData != null) {
-			final ManifestFile manifestFile = new Gson().fromJson(manifestData, ManifestFile.class);
-			manifest = manifestFile.getManifest();
-			if (manifest == null) {
-				Log.w(TAG, "Manifest failed to be parsed. Did you add \n" +
-						"-keep class no.nordicsemi.android.dfu.** { *; }\n" +
-						"to your proguard rules?");
-			}
-		} else {
-			Log.w(TAG, "Manifest not found in the ZIP. It is recommended to use a distribution " +
-                    "file created with: https://github.com/NordicSemiconductor/pc-nrfutil/ (for Legacy DFU use version 0.5.x)");
-		}
-	}
-
-	@Override
-	public void close() throws IOException {
-		softDeviceBytes = null;
-		bootloaderBytes = null;
-		applicationBytes = null;
-		softDeviceAndBootloaderBytes = null;
-		softDeviceSize = bootloaderSize = applicationSize = 0;
-		currentSource = null;
-		bytesRead = bytesReadFromCurrentSource = 0;
-		zipInputStream.close();
-	}
-
-	@Override
-	public long skip(final long n) {
-		return 0;
-	}
-
-	@Override
-	public int read() {
-		final byte[] buffer = new byte[1];
-		if (read(buffer) == -1) {
-			return -1;
-		} else {
-			return buffer[0] & 0xFF;
-		}
-	}
-
-	@Override
-	public int read(@NonNull final byte[] buffer) {
-		return read(buffer, 0, buffer.length);
-	}
-
-	@Override
-	public int read(@NonNull final byte[] buffer, final int offset, final int length) {
-		final int size = rawRead(buffer, offset, length);
-		if (length > size && startNextFile() != null) {
-			return size + rawRead(buffer, offset + size, length - size);
-		}
-		return size;
-	}
-
-	private int rawRead(@NonNull final byte[] buffer, final int offset, final int length) {
-		final int maxSize = currentSource.length - bytesReadFromCurrentSource;
-		final int size = Math.min(length, maxSize);
-		System.arraycopy(currentSource, bytesReadFromCurrentSource, buffer, offset, size);
-		bytesReadFromCurrentSource += size;
-		bytesRead += size;
-		crc32.update(buffer, offset, size);
-		return size;
-	}
-
-	@Override
-	public boolean markSupported() {
-		return true;
-	}
-
-	/**
-	 * Marks the current position in the stream. The parameter is ignored.
-	 *
-	 * @param readlimit this parameter is ignored, can be anything
-	 */
-	@Override
-	public void mark(final int readlimit) {
-		markedSource = currentSource;
-		bytesReadFromMarkedSource = bytesReadFromCurrentSource;
-	}
-
-	@Override
-	public void reset() {
-		currentSource = markedSource;
-		bytesRead = bytesReadFromCurrentSource = bytesReadFromMarkedSource;
-
-		// Restore the CRC to the value is was on mark.
-		crc32.reset();
-		if (currentSource == bootloaderBytes && softDeviceBytes != null) {
-			crc32.update(softDeviceBytes);
-			bytesRead += softDeviceSize;
-		}
-		crc32.update(currentSource, 0, bytesReadFromCurrentSource);
-	}
-
-	/**
-	 * Resets to the beginning of current stream.
-	 * If SD and BL were updated, the stream will be reset to the beginning.
-	 * If SD and BL were already sent and the current stream was changed to application,
-	 * this method will reset to the beginning of the application stream.
-	 */
-	public void fullReset() {
-		// Reset stream to SoftDevice if SD and BL firmware were given separately
-		if (softDeviceBytes != null && bootloaderBytes != null && currentSource == bootloaderBytes) {
-			currentSource = softDeviceBytes;
-		}
-		// Reset the bytes count to 0
-		bytesReadFromCurrentSource = 0;
-		mark(0);
-		reset();
-	}
-
-	/**
-	 * Returns number of bytes read until now.
-	 */
-	public int getBytesRead() {
-		return bytesRead;
-	}
-
-	/**
-	 * Returns the CRC32 of the part of the firmware that was already read.
-	 *
-	 * @return the CRC
-	 */
-	public long getCrc32() {
-		return crc32.getValue();
-	}
-
-	/**
-	 * Returns the content type based on the content of the ZIP file. The content type may be
-     * truncated using {@link #setContentType(int)}.
-	 *
-	 * @return A bit field of {@link DfuBaseService#TYPE_SOFT_DEVICE TYPE_SOFT_DEVICE},
-     * {@link DfuBaseService#TYPE_BOOTLOADER TYPE_BOOTLOADER} and
-     * {@link DfuBaseService#TYPE_APPLICATION TYPE_APPLICATION}
-	 */
-	public int getContentType() {
-		type = 0;
-		// In Secure DFU the softDeviceSize and bootloaderSize may be 0 if both are in the ZIP file.
-        // The size of each part is embedded in the Init packet.
-		if (softDeviceAndBootloaderBytes != null)
-			type |= DfuBaseService.TYPE_SOFT_DEVICE | DfuBaseService.TYPE_BOOTLOADER;
-		// In Legacy DFU the size of each of these parts was given in the manifest file.
-		if (softDeviceSize > 0)
-			type |= DfuBaseService.TYPE_SOFT_DEVICE;
-		if (bootloaderSize > 0)
-			type |= DfuBaseService.TYPE_BOOTLOADER;
-		if (applicationSize > 0)
-			type |= DfuBaseService.TYPE_APPLICATION;
-		return type;
-	}
-
-	/**
-	 * Truncates the current content type. May be used to hide some files, e.g. to send Soft Device
-     * and Bootloader without Application or only the Application.
-	 *
-	 * @param type the new type.
-	 * @return The final type after truncating.
-	 */
-	public int setContentType(final int type) {
-		this.type = type;
-		// If the new type has Application, but there is no application fw, remove this type bit
-		if ((type & DfuBaseService.TYPE_APPLICATION) > 0 && applicationBytes == null)
-			this.type &= ~DfuBaseService.TYPE_APPLICATION;
-		// If the new type has SD+BL
-		if ((type & (DfuBaseService.TYPE_SOFT_DEVICE | DfuBaseService.TYPE_BOOTLOADER)) == (DfuBaseService.TYPE_SOFT_DEVICE | DfuBaseService.TYPE_BOOTLOADER)) {
-			// but there is no SD, remove the softdevice type bit
-			if (softDeviceBytes == null && softDeviceAndBootloaderBytes == null)
-				this.type &= ~DfuBaseService.TYPE_SOFT_DEVICE;
-			// or there is no BL, remove the bootloader type bit
-			if (bootloaderBytes == null && softDeviceAndBootloaderBytes == null)
-				this.type &= ~DfuBaseService.TYPE_SOFT_DEVICE;
-		} else {
-			// If at least one of SD or B: bit is cleared, but the SD+BL file is set, remove both bits.
-			if (softDeviceAndBootloaderBytes != null)
-				this.type &= ~(DfuBaseService.TYPE_SOFT_DEVICE | DfuBaseService.TYPE_BOOTLOADER);
-		}
-
-		if ((type & (DfuBaseService.TYPE_SOFT_DEVICE | DfuBaseService.TYPE_BOOTLOADER)) > 0 && softDeviceAndBootloaderBytes != null)
-			currentSource = softDeviceAndBootloaderBytes;
-		else if ((type & DfuBaseService.TYPE_SOFT_DEVICE) > 0)
-			currentSource = softDeviceBytes;
-		else if ((type & DfuBaseService.TYPE_BOOTLOADER) > 0)
-			currentSource = bootloaderBytes;
-		else if ((type & DfuBaseService.TYPE_APPLICATION) > 0)
-			currentSource = applicationBytes;
-		bytesReadFromCurrentSource = 0;
-		mark(0);
-		reset();
-		return this.type;
-	}
-
-	/**
-	 * Sets the currentSource to the new file or to <code>null</code> if the last file has been
-     * transmitted.
-	 *
-	 * @return The new source, the same as {@link #currentSource}.
-	 */
-	private byte[] startNextFile() {
-		byte[] ret;
-		if (currentSource == softDeviceBytes && bootloaderBytes != null && (type & DfuBaseService.TYPE_BOOTLOADER) > 0) {
-			ret = currentSource = bootloaderBytes;
-		} else if (currentSource != applicationBytes && applicationBytes != null && (type & DfuBaseService.TYPE_APPLICATION) > 0) {
-			ret = currentSource = applicationBytes;
-		} else {
-			ret = currentSource = null;
-		}
-		bytesReadFromCurrentSource = 0;
-		return ret;
-	}
-
-	/**
-	 * Returns the number of bytes that has not been read yet. This value includes only
-     * firmwares matching the content type set by the constructor or the
-     * {@link #setContentType(int)} method.
-	 */
-	@Override
-	public int available() {
-		// In Secure DFU softdevice and bootloader sizes are not provided in the Init file
-        // (they are encoded inside the Init file instead). The service doesn't send those sizes,
-        // not the whole size of the firmware separately, like it was done in the Legacy DFU.
-		// This method then is just used to log file size.
-
-		// In case of SD+BL in Secure DFU:
-		if (softDeviceAndBootloaderBytes != null && softDeviceSize == 0 && bootloaderSize == 0
-				&& (type & (DfuBaseService.TYPE_SOFT_DEVICE | DfuBaseService.TYPE_BOOTLOADER)) > 0)
-			return softDeviceAndBootloaderBytes.length + applicationImageSize() - bytesRead;
-
-		// Otherwise:
-		return softDeviceImageSize() + bootloaderImageSize() + applicationImageSize() - bytesRead;
-	}
-
-	/**
-	 * Returns the total size of the SoftDevice firmware. In case the firmware was given as a HEX,
-     * this method returns the size of the BIN content of the file.
-	 *
-	 * @return The size of the SoftDevice firmware (BIN part).
-	 */
-	public int softDeviceImageSize() {
-		return (type & DfuBaseService.TYPE_SOFT_DEVICE) > 0 ? softDeviceSize : 0;
-	}
-
-	/**
-	 * Returns the total size of the Bootloader firmware. In case the firmware was given as a HEX,
-     * this method returns the size of the BIN content of the file.
-	 *
-	 * @return The size of the Bootloader firmware (BIN part).
-	 */
-	public int bootloaderImageSize() {
-		return (type & DfuBaseService.TYPE_BOOTLOADER) > 0 ? bootloaderSize : 0;
-	}
-
-	/**
-	 * Returns the total size of the Application firmware. In case the firmware was given as a HEX,
-     * this method returns the size of the BIN content of the file.
-	 *
-	 * @return The size of the Application firmware (BIN part).
-	 */
-	public int applicationImageSize() {
-		return (type & DfuBaseService.TYPE_APPLICATION) > 0 ? applicationSize : 0;
-	}
-
-	/**
-	 * Returns the content of the init file for SoftDevice and/or Bootloader. When both SoftDevice
-     * and Bootloader are present in the ZIP file (as two files using the compatibility mode
-	 * or as one file using the new Distribution packet) the system init contains validation data
-     * for those two files combined (e.g. the CRC value). This method may return
-	 * <code>null</code> if there is no SoftDevice nor Bootloader in the ZIP or the DAT file is
-     * not present there.
-	 *
-	 * @return The content of the init packet for SoftDevice and/or Bootloader.
-	 */
-	public byte[] getSystemInit() {
-		return systemInitBytes;
-	}
-
-	/**
-	 * Returns the content of the init file for the Application or <code>null</code> if no
-     * application file in the ZIP, or the DAT file is not provided.
-	 *
-	 * @return The content of the init packet for Application.
-	 */
-	public byte[] getApplicationInit() {
-		return applicationInitBytes;
-	}
-
-	/**
-	 * This method returns true if the content of the ZIP file may be sent only using Secure DFU.
-	 * The reason may be that the ZIP contains a single bin file with SD and/or BL together with
-     * App, which has to be sent in a single connection.
-	 * Sizes of each component are not given explicitly in the Manifest (even if they are,
-     * they are ignored). They are hidden in the Init Packet instead.
-	 *
-	 * @return True if the content of this ZIP may only be sent using Secure DFU.
-	 */
-	public boolean isSecureDfuRequired() {
-		return manifest != null && manifest.isSecureDfuRequired();
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/HexInputStream.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/HexInputStream.java
deleted file mode 100644
index 808f7be..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/HexInputStream.java
+++ /dev/null
@@ -1,452 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu.internal;
-
-import androidx.annotation.NonNull;
-
-import java.io.BufferedInputStream;
-import java.io.ByteArrayInputStream;
-import java.io.FilterInputStream;
-import java.io.IOException;
-import java.io.InputStream;
-
-import no.nordicsemi.android.dfu.DfuSettingsConstants;
-import no.nordicsemi.android.dfu.internal.exception.HexFileValidationException;
-
-/**
- * Reads the binary content from the HEX file using IntelHex standard:
- * http://www.interlog.com/~speff/usefulinfo/Hexfrmt.pdf.
- * Truncates the HEX file from all meta data and returns only the BIN content.
- * <p>
- * In nRF51 chips memory a SoftDevice starts at address 0x1000. From 0x0000 to 0x1000 there is
- * MBR sector (since SoftDevice 7.0.0) which should not be transmitted using DFU. Therefore this
- * class skips all data from addresses below 0x1000.
- */
-@SuppressWarnings({"WeakerAccess", "unused"})
-public class HexInputStream extends FilterInputStream {
-	private final int LINE_LENGTH = 128;
-
-	private final byte[] localBuf;
-	private final int available;
-	private int localPos;
-	private int pos;
-	private int size;
-	private int lastAddress;
-	private int bytesRead;
-	private final int MBRSize;
-
-    public static final int APP_CODE_BASE_START = 0x18000;
-    public static final int APP_CODE_BASE_END = 0x3BBFF;
-
-	/**
-	 * Creates the HEX Input Stream. The constructor calculates the size of the BIN content which
-	 * is available through {@link #sizeInBytes()}. If HEX file is invalid then the bin size is 0.
-	 *
-	 * @param in      the input stream to read from.
-	 * @param mbrSize the MBR (Master Boot Record) size in bytes. Data with addresses below than
-	 *                number will be trimmed and not transferred to DFU target.
-	 * @throws HexFileValidationException if HEX file is invalid, e.g. there is no semicolon (':')
-	 *                                    on the beginning of each line.
-	 * @throws IOException                if the stream is closed or another IOException occurs.
-	 */
-	public HexInputStream(@NonNull final InputStream in, final int mbrSize)
-			throws HexFileValidationException, IOException {
-		super(new BufferedInputStream(in));
-		this.localBuf = new byte[LINE_LENGTH];
-		this.localPos = LINE_LENGTH; // we are at the end of the local buffer, new one must be obtained
-		this.size = localBuf.length;
-		this.lastAddress = 0;
-		this.MBRSize = mbrSize;
-
-		this.available = calculateBinSizeAlternative();
-	}
-
-	/**
-	 * Creates the HEX Input Stream. The constructor calculates the size of the BIN content which
-	 * is available through {@link #sizeInBytes()}. If HEX file is invalid then the bin size is 0.
-	 *
-	 * @param data    the input stream to read from.
-	 * @param mbrSize the MBR (Master Boot Record) size in bytes. Data with addresses below than
-	 * 	 *                number will be trimmed and not transferred to DFU target.
-	 * @throws HexFileValidationException if HEX file is invalid, e.g. there is no semicolon (':')
-	 *                                    on the beginning of each line.
-	 * @throws IOException                if the stream is closed or another IOException occurs.
-	 */
-	public HexInputStream(@NonNull final byte[] data, final int mbrSize)
-			throws HexFileValidationException, IOException {
-		super(new ByteArrayInputStream(data));
-		this.localBuf = new byte[LINE_LENGTH];
-		this.localPos = LINE_LENGTH; // we are at the end of the local buffer, new one must be obtained
-		this.size = localBuf.length;
-		this.lastAddress = 0;
-		this.MBRSize = mbrSize;
-
-		this.available = calculateBinSizeAlternative();
-	}
-
-	@SuppressWarnings("DuplicateThrows")
-	private int calculateBinSize(final int mbrSize) throws HexFileValidationException, IOException {
-		int binSize = 0;
-		final InputStream in = this.in;
-		in.mark(in.available());
-
-		int b, lineSize, offset, type;
-		int lastBaseAddress = 0; // last Base Address, default 0 
-		int lastAddress;
-		try {
-			b = in.read();
-			while (true) {
-				checkComma(b);
-
-				lineSize = readByte(in); // reading the length of the data in this line
-				offset = readAddress(in);// reading the offset
-				type = readByte(in); // reading the line type
-				switch (type) {
-					case 0x01:
-						// end of file
-						return binSize;
-					case 0x04: {
-						// extended linear address record
-						/*
-						 * The HEX file may contain jump to different addresses.
-						 * The MSB of LBA (Linear Base Address) is given using the line type 4.
-						 * We only support files where bytes are located together, no jumps are
-						 * allowed. Therefore the newULBA may be only lastULBA + 1 (or any,
-						 * if this is the first line of the HEX)
-						 */
-						final int newULBA = readAddress(in);
-						if (binSize > 0 && newULBA != (lastBaseAddress >> 16) + 1)
-							return binSize;
-						lastBaseAddress = newULBA << 16;
-						skip(in, 2 /* check sum */);
-						break;
-					}
-					case 0x02: {
-						// extended segment address record
-						final int newSBA = readAddress(in) << 4;
-						if (binSize > 0 && (newSBA >> 16) != (lastBaseAddress >> 16) + 1)
-							return binSize;
-						lastBaseAddress = newSBA;
-						skip(in, 2 /* check sum */);
-						break;
-					}
-					case 0x00:
-						// data type line
-						lastAddress = lastBaseAddress + offset;
-						// we must skip all data from below last MBR address (default 0x1000)
-						// as those are the MBR. The Soft Device starts at the end of MBR (0x1000),
-						// the app and bootloader farther more
-						if (lastAddress >= mbrSize)
-							binSize += lineSize;
-						// no break!
-					default:
-						final long toBeSkipped = lineSize * 2L /* 2 hex per one byte */ + 2 /* check sum */;
-						skip(in, toBeSkipped);
-						break;
-				}
-				// skip end of line
-				do {
-					b = in.read();
-				} while (b == '\n' || b == '\r');
-			}
-		} finally {
-			in.reset();
-		}
-	}
-
-    private int calculateBinSizeAlternative() throws IOException {
-        int binSize = 0;
-        final InputStream in = this.in;
-        in.mark(in.available());
-
-        int b, lineSize, offset, type;
-        int lastBaseAddress = 0; // last Base Address, default 0
-        int lastAddress;
-        try {
-            b = in.read();
-            while (true) {
-                checkComma(b);
-
-                lineSize = readByte(in); // reading the length of the data in this line
-                offset = readAddress(in);// reading the offset
-                type = readByte(in); // reading the line type
-                switch (type) {
-                    case 0x01:
-                        // end of file
-                        return binSize;
-                    case 0x04: {
-                        // extended linear address record
-                        /*
-                         * The HEX file may contain jump to different addresses. The MSB of LBA (Linear Base Address) is given using the line type 4.
-                         * We only support files where bytes are located together, no jumps are allowed. Therefore the newULBA may be only lastULBA + 1 (or any, if this is the first line of the HEX)
-                         */
-                        final int newULBA = readAddress(in);
-                        if (binSize > 0 && newULBA != (lastBaseAddress >> 16) + 1)
-                            return binSize;
-                        lastBaseAddress = newULBA << 16;
-                        skip(in, 2 /* check sum */);
-                        break;
-                    }
-                    case 0x02: {
-                        // extended segment address record
-                        final int newSBA = readAddress(in) << 4;
-                        if (binSize > 0 && (newSBA >> 16) != (lastBaseAddress >> 16) + 1)
-                            return binSize;
-                        lastBaseAddress = newSBA;
-                        skip(in, 2 /* check sum */);
-                        break;
-                    }
-                    case 0x00:
-                        // data type line
-                        lastAddress = lastBaseAddress + offset;
-                        if (lastAddress >= APP_CODE_BASE_START && lastAddress < APP_CODE_BASE_END)
-                        {
-                            //Log.d("HexInputStrem", "Found FOTA Start address");
-                            binSize += lineSize;
-                        }
-                        // no break!
-                    default:
-                        skip(in, lineSize * 2L /* 2 hex per one byte */+ 2 /* check sum */);
-                        break;
-                }
-                // skip end of line
-                do {
-                    b = in.read();
-                } while (b == '\n' || b == '\r');
-            }
-        } finally {
-            in.reset();
-        }
-    }
-
-
-	@Override
-	public int available() {
-		return available - bytesRead;
-	}
-
-	/**
-	 * Fills the buffer with next bytes from the stream.
-	 *
-	 * @param buffer buffer to be filled
-	 * @return the size of the buffer
-	 */
-	public int readPacket(@NonNull byte[] buffer) throws IOException {
-		int i = 0;
-		while (i < buffer.length) {
-			if (localPos < size) {
-				buffer[i++] = localBuf[localPos++];
-				continue;
-			}
-
-			bytesRead += size = readLine();
-			if (size == 0)
-				break; // end of file reached
-		}
-		return i;
-	}
-
-	@Override
-	public int read() {
-		throw new UnsupportedOperationException("Please, use readPacket() method instead");
-	}
-
-	@Override
-	public int read(@NonNull byte[] buffer) throws IOException {
-		return readPacket(buffer);
-	}
-
-	@Override
-	public int read(@NonNull byte[] buffer, int offset, int count) {
-		throw new UnsupportedOperationException("Please, use readPacket() method instead");
-	}
-
-	/**
-	 * Returns the total number of bytes.
-	 *
-	 * @return total number of bytes available
-	 */
-	public int sizeInBytes() {
-		return available;
-	}
-
-	/**
-	 * Returns the total number of packets with given size that are needed to get all
-	 * available data.
-	 *
-	 * @param packetSize the maximum packet size
-	 * @return the number of packets needed to get all the content
-	 */
-	public int sizeInPackets(final int packetSize) {
-		final int sizeInBytes = sizeInBytes();
-
-		return sizeInBytes / packetSize + ((sizeInBytes % packetSize) > 0 ? 1 : 0);
-	}
-
-	/**
-	 * Reads new line from the input stream. Input stream must be a HEX file.
-	 * The first line is always skipped.
-	 *
-	 * @return the number of data bytes in the new line. 0 if end of file.
-	 * @throws java.io.IOException if this stream is closed or another IOException occurs.
-	 */
-	private int readLine() throws IOException {
-		// end of file reached
-		if (pos == -1)
-			return 0;
-		final InputStream in = this.in;
-
-		// temporary value
-		int b;
-
-		int lineSize, type, offset;
-		do {
-			// skip end of line
-			do {
-				b = in.read();
-				pos++;
-			} while (b == '\n' || b == '\r');
-
-			/*
-			 * Each line starts with comma (':')
-			 * Data is written in HEX, so each 2 ASCII letters give one byte.
-			 * After the comma there is one byte (2 HEX signs) with line length
-			 * (normally 10 -> 0x10 -> 16 bytes -> 32 HEX characters)
-			 * After that there is a 4 byte of an address. This part may be skipped.
-			 * There is a packet type after the address (1 byte = 2 HEX characters).
-			 * 00 is the valid data. Other values can be skipped when converting to BIN file.
-			 * Then goes n bytes of data followed by 1 byte (2 HEX chars) of checksum,
-			 * which is also skipped in BIN file.
-			 */
-			checkComma(b); // checking the comma at the beginning
-			lineSize = readByte(in); // reading the length of the data in this line
-			pos += 2;
-			offset = readAddress(in);// reading the offset
-			pos += 4;
-			type = readByte(in); // reading the line type
-			pos += 2;
-
-			// if the line type is no longer data type (0x00), we've reached the end of the file
-			switch (type) {
-				case 0x00:
-					// data type
-					if (lastAddress + offset < MBRSize) { // skip MBR
-						type = -1; // some other than 0
-						pos += skip(in, lineSize * 2L /* 2 hex per one byte */ + 2 /* check sum */);
-					}
-					break;
-				case 0x01:
-					// end of file
-					pos = -1;
-					return 0;
-				case 0x02: {
-					// extended segment address
-					final int address = readAddress(in) << 4;
-					pos += 4;
-					if (bytesRead > 0 && (address >> 16) != (lastAddress >> 16) + 1)
-						return 0;
-					lastAddress = address;
-					pos += skip(in, 2 /* check sum */);
-					break;
-				}
-				case 0x04: {
-					// extended linear address
-					final int address = readAddress(in);
-					pos += 4;
-					if (bytesRead > 0 && address != (lastAddress >> 16) + 1)
-						return 0;
-					lastAddress = address << 16;
-					pos += skip(in, 2 /* check sum */);
-					break;
-				}
-				default:
-					final long toBeSkipped = lineSize * 2L /* 2 hex per one byte */ + 2 /* check sum */;
-					pos += skip(in, toBeSkipped);
-					break;
-			}
-		} while (type != 0);
-
-		// otherwise read lineSize bytes or fill the whole buffer
-		for (int i = 0; i < localBuf.length && i < lineSize; ++i) {
-			b = readByte(in);
-			pos += 2;
-			localBuf[i] = (byte) b;
-		}
-		pos += skip(in, 2); // skip the checksum
-		localPos = 0;
-
-		return lineSize;
-	}
-
-	@Override
-	public synchronized void mark(final int readlimit) {
-		try {
-			super.mark(in.available());
-		} catch (final IOException e) {
-			// ignore
-		}
-	}
-
-	@Override
-	public synchronized void reset() throws IOException {
-		super.reset();
-
-		pos = 0;
-		bytesRead = 0;
-		localPos = LINE_LENGTH; // we are at the end of the local buffer, new one must be obtained
-	}
-
-	private void checkComma(final int comma) throws HexFileValidationException {
-		if (comma != ':')
-			throw new HexFileValidationException("Not a HEX file");
-	}
-
-	private long skip(@NonNull final InputStream in, final long offset) throws IOException {
-		long skipped = in.skip(offset);
-		// try to skip 2 times as skip(..) method does not guarantee to skip exactly
-		// given number of bytes
-		if (skipped < offset)
-			skipped += in.skip(offset - skipped);
-		return skipped;
-	}
-
-	private int readByte(@NonNull final InputStream in) throws IOException {
-		final int first = asciiToInt(in.read());
-		final int second = asciiToInt(in.read());
-
-		return first << 4 | second;
-	}
-
-	private int readAddress(@NonNull final InputStream in) throws IOException {
-		return readByte(in) << 8 | readByte(in);
-	}
-
-	private int asciiToInt(final int ascii) {
-		if (ascii >= 'A')
-			return ascii - 0x37;
-
-		if (ascii >= '0')
-			return ascii - '0';
-		return -1;
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/DeviceDisconnectedException.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/DeviceDisconnectedException.java
deleted file mode 100644
index b4f5426..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/DeviceDisconnectedException.java
+++ /dev/null
@@ -1,34 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu.internal.exception;
-
-/**
- * Device has disconnected.
- */
-public class DeviceDisconnectedException extends Exception {
-	private static final long serialVersionUID = -6901728550661937942L;
-
-	public DeviceDisconnectedException(final String message) {
-		super(message);
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/DfuException.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/DfuException.java
deleted file mode 100644
index 322c522..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/DfuException.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu.internal.exception;
-
-import no.nordicsemi.android.dfu.DfuBaseService;
-
-/**
- * A DFU error occurred on the remote DFU target.
- */
-public class DfuException extends Exception {
-	private static final long serialVersionUID = -6901728550661937942L;
-
-	private final int mError;
-
-	public DfuException(final String message, final int state) {
-		super(message);
-
-		mError = state;
-	}
-
-	public int getErrorNumber() {
-		return mError;
-	}
-
-	@Override
-	public String getMessage() {
-		return super.getMessage() + " (error " + (mError & ~DfuBaseService.ERROR_CONNECTION_MASK) + ")";
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/HexFileValidationException.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/HexFileValidationException.java
deleted file mode 100644
index 008cb9c..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/HexFileValidationException.java
+++ /dev/null
@@ -1,36 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu.internal.exception;
-
-import java.io.IOException;
-
-/**
- * The HEX file could not be parsed.
- */
-public class HexFileValidationException extends IOException {
-	private static final long serialVersionUID = -6467104024030837875L;
-
-	public HexFileValidationException(final String message) {
-		super(message);
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/RemoteDfuException.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/RemoteDfuException.java
deleted file mode 100644
index 59b6496..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/RemoteDfuException.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu.internal.exception;
-
-/**
- * A DFU error occurred on the remote DFU target.
- */
-public class RemoteDfuException extends Exception {
-	private static final long serialVersionUID = -6901728550661937942L;
-
-	private final int mState;
-
-	public RemoteDfuException(final String message, final int state) {
-		super(message);
-
-		mState = state;
-	}
-
-	public int getErrorNumber() {
-		return mState;
-	}
-
-	@Override
-	public String getMessage() {
-		return super.getMessage() + " (error " + mState + ")";
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/RemoteDfuExtendedErrorException.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/RemoteDfuExtendedErrorException.java
deleted file mode 100644
index d7d0a35..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/RemoteDfuExtendedErrorException.java
+++ /dev/null
@@ -1,49 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu.internal.exception;
-
-import no.nordicsemi.android.error.SecureDfuError;
-
-/**
- * A DFU error occurred on the remote DFU target.
- */
-public class RemoteDfuExtendedErrorException extends RemoteDfuException {
-	private static final long serialVersionUID = -6901728550661937942L;
-
-	private final int mError;
-
-	public RemoteDfuExtendedErrorException(final String message, final int extendedError) {
-		super(message, SecureDfuError.EXTENDED_ERROR);
-
-		mError = extendedError;
-	}
-
-	public int getExtendedErrorNumber() {
-		return mError;
-	}
-
-	@Override
-	public String getMessage() {
-		return super.getMessage() + " (extended error " + mError + ")";
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/SizeValidationException.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/SizeValidationException.java
deleted file mode 100644
index 1961b5a..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/SizeValidationException.java
+++ /dev/null
@@ -1,37 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu.internal.exception;
-
-import java.io.IOException;
-
-/**
- * This exception is thrown when the firmware size is not word-aligned (number of bytes does not divide by 4).
- * This is the requirement for the DFU Bootloader.
- */
-public class SizeValidationException extends IOException {
-	private static final long serialVersionUID = -6467104024030837875L;
-
-	public SizeValidationException(final String message) {
-		super(message);
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/UnknownResponseException.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/UnknownResponseException.java
deleted file mode 100644
index cb67a13..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/UnknownResponseException.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu.internal.exception;
-
-import java.util.Locale;
-
-public class UnknownResponseException extends Exception {
-	private static final long serialVersionUID = -8716125467309979289L;
-	private static final char[] HEX_ARRAY = { '0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F' };
-
-	private final byte[] mResponse;
-	private final int mExpectedReturnCode;
-	private final int mExpectedOpCode;
-
-	public UnknownResponseException(final String message, final byte[] response, final int expectedReturnCode, final int expectedOpCode) {
-		super(message);
-
-		mResponse = response != null ? response : new byte[0];
-		mExpectedReturnCode = expectedReturnCode;
-		mExpectedOpCode = expectedOpCode;
-	}
-
-	@Override
-	public String getMessage() {
-		return String.format(Locale.US, "%s (response: %s, expected: 0x%02X%02X..)", super.getMessage(), bytesToHex(mResponse, 0, mResponse.length), mExpectedReturnCode, mExpectedOpCode);
-	}
-
-	public static String bytesToHex(final byte[] bytes, final int start, final int length) {
-		if (bytes == null || bytes.length <= start || length <= 0)
-			return "";
-
-		final int maxLength = Math.min(length, bytes.length - start);
-		final char[] hexChars = new char[maxLength * 2];
-		for (int j = 0; j < maxLength; j++) {
-			final int v = bytes[start + j] & 0xFF;
-			hexChars[j * 2] = HEX_ARRAY[v >>> 4];
-			hexChars[j * 2 + 1] = HEX_ARRAY[v & 0x0F];
-		}
-		return "0x" + new String(hexChars);
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/UploadAbortedException.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/UploadAbortedException.java
deleted file mode 100644
index d4cb540..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/exception/UploadAbortedException.java
+++ /dev/null
@@ -1,31 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu.internal.exception;
-
-public class UploadAbortedException extends Exception {
-	private static final long serialVersionUID = -6901728550661937942L;
-
-	public UploadAbortedException() {
-		super();
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/FileInfo.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/FileInfo.java
deleted file mode 100644
index 0fad05b..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/FileInfo.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu.internal.manifest;
-
-import com.google.gson.annotations.SerializedName;
-
-public class FileInfo {
-	@SerializedName("bin_file") private String binFile;
-	@SerializedName("dat_file") private String datFile;
-
-	public String getBinFileName() {
-		return binFile;
-	}
-
-	public String getDatFileName() {
-		return datFile;
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/Manifest.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/Manifest.java
deleted file mode 100644
index fa17deb..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/Manifest.java
+++ /dev/null
@@ -1,74 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu.internal.manifest;
-
-import com.google.gson.annotations.SerializedName;
-
-@SuppressWarnings("unused")
-public class Manifest {
-	private FileInfo application;
-	private FileInfo bootloader;
-	private FileInfo softdevice;
-	@SerializedName("softdevice_bootloader")
-	private SoftDeviceBootloaderFileInfo softdeviceBootloader;
-
-	// The following options are available only in some implementations of Secure DFU and will be sent as application (in a single connection).
-	// The service is not aware of sizes of each component in the bin file. This information is hidden in the Init Packet.
-	@SerializedName("bootloader_application")
-	private FileInfo bootloaderApplication;
-	@SerializedName("softdevice_application")
-	private FileInfo softdeviceApplication;
-	@SerializedName("softdevice_bootloader_application")
-	private FileInfo softdeviceBootloaderApplication;
-
-	public FileInfo getApplicationInfo() {
-		if (application != null)
-			return application;
-		// The other parts will be sent together with application, so they may be returned here.
-		if (softdeviceApplication != null)
-			return softdeviceApplication;
-		if (bootloaderApplication != null)
-			return bootloaderApplication;
-		return softdeviceBootloaderApplication;
-	}
-
-	public FileInfo getBootloaderInfo() {
-		return bootloader;
-	}
-
-	public FileInfo getSoftdeviceInfo() {
-		return softdevice;
-	}
-
-	public SoftDeviceBootloaderFileInfo getSoftdeviceBootloaderInfo() {
-		return softdeviceBootloader;
-	}
-
-	public boolean isSecureDfuRequired() {
-		// Legacy DFU requires sending firmware type together with Start DFU command.
-		// The following options were not supported by the legacy bootloader,
-		// but in some implementations they are supported in Secure DFU.
-		// In Secure DFU the fw type is provided in the Init packet.
-		return bootloaderApplication != null || softdeviceApplication != null || softdeviceBootloaderApplication != null;
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/ManifestFile.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/ManifestFile.java
deleted file mode 100644
index 8961b7b..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/ManifestFile.java
+++ /dev/null
@@ -1,32 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu.internal.manifest;
-
-@SuppressWarnings("unused")
-public class ManifestFile {
-	private Manifest manifest;
-
-	public Manifest getManifest() {
-		return manifest;
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/SoftDeviceBootloaderFileInfo.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/SoftDeviceBootloaderFileInfo.java
deleted file mode 100644
index 969d6c5..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/manifest/SoftDeviceBootloaderFileInfo.java
+++ /dev/null
@@ -1,38 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu.internal.manifest;
-
-import com.google.gson.annotations.SerializedName;
-
-public class SoftDeviceBootloaderFileInfo extends FileInfo {
-	@SerializedName("bl_size") private int bootloaderSize;
-	@SerializedName("sd_size") private int softdeviceSize;
-
-	public int getSoftdeviceSize() {
-		return softdeviceSize;
-	}
-
-	public int getBootloaderSize() {
-		return bootloaderSize;
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScanner.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScanner.java
deleted file mode 100644
index 9f27ff0..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScanner.java
+++ /dev/null
@@ -1,60 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu.internal.scanner;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import no.nordicsemi.android.dfu.DfuDeviceSelector;
-
-/**
- * <p>
- * The DFU Bootloader may advertise with the same address as an application or one incremented by 1.
- * This depends on the bootloader configuration. If buttonless service is used and the device is
- * bonded, the address is usually preserved, otherwise it is incremented by 1.
- * Check out <code>NRF_DFU_BLE_REQUIRES_BONDS</code> define in the sdk_config.
- * Also, when the SD is updated, the bootloader will use the incremented address, as bond info
- * were erased together with the old application.
- * <p>
- * The DFU service always connects to the address given as a parameter. However, when flashing
- * SD+BL+App it will first send the SD+BL as part one followed by the App in the second connection.
- * As the service does not know which address was used in the first connection (normal,
- * when buttonless update, or +1 when with-button update) we have to scan for the advertising
- * device after SD+BL part is completed.
- */
-public interface BootloaderScanner {
-	/**
-	 * Searches for the advertising bootloader. The bootloader may advertise with the same device
-	 * address or one with the last byte incremented by 1.
-	 * This method is a blocking one and ends when such device is found. There are two
-	 * implementations of this interface - one for Androids 4.3 and 4.4.x and one for the
-	 * Android 5+ devices.
-	 *
-	 * @param selector the device selector
-	 * @param timeout the scanning timeout, in milliseconds
-	 * @return the address of the advertising DFU bootloader. It may be the same as the application
-	 * address or one with the last byte incremented by 1 (AA:BB:CC:DD:EE:45/FF -&gt; AA:BB:CC:DD:EE:46/00).
-	 * Null is returned when Bluetooth is off or the device has not been found.
-	 */
-	@Nullable
-	String searchUsing(final @NonNull DfuDeviceSelector selector, final long timeout);
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScannerFactory.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScannerFactory.java
deleted file mode 100644
index 0dbfba8..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScannerFactory.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu.internal.scanner;
-
-import android.os.Build;
-
-import java.util.Locale;
-
-import androidx.annotation.NonNull;
-
-/**
- * The factory should be used to create the {@link BootloaderScanner} instance appropriate
- * for the Android version.
- */
-public final class BootloaderScannerFactory {
-	/**
-	 * The bootloader may advertise with the same address or one with the last byte incremented
-	 * by this value. I.e. 00:11:22:33:44:55 -&gt; 00:11:22:33:44:56. FF changes to 00.
-	 */
-	private final static int ADDRESS_DIFF = 1;
-
-	private BootloaderScannerFactory() {}
-
-	public static String getIncrementedAddress(@NonNull final String deviceAddress) {
-		final String firstBytes = deviceAddress.substring(0, 15);
-		final String lastByte = deviceAddress.substring(15); // assuming that the device address is correct
-		final String lastByteIncremented = String.format(Locale.US, "%02X", (Integer.valueOf(lastByte, 16) + ADDRESS_DIFF) & 0xFF);
-		return firstBytes + lastByteIncremented;
-	}
-
-	/**
-	 * Returns the scanner implementation.
-	 *
-	 * @return the bootloader scanner
-	 */
-	public static BootloaderScanner getScanner(@NonNull final String deviceAddress) {
-		final String deviceAddressIncremented = getIncrementedAddress(deviceAddress);
-
-		if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP)
-			return new BootloaderScannerLollipop(deviceAddress, deviceAddressIncremented);
-		return new BootloaderScannerJB(deviceAddress, deviceAddressIncremented);
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScannerJB.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScannerJB.java
deleted file mode 100644
index 99e4742..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScannerJB.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu.internal.scanner;
-
-import android.annotation.SuppressLint;
-import android.bluetooth.BluetoothAdapter;
-import android.bluetooth.BluetoothDevice;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import no.nordicsemi.android.dfu.DfuDeviceSelector;
-
-/**
- * @see BootloaderScanner
- */
-@SuppressLint("MissingPermission")
-public class BootloaderScannerJB implements BootloaderScanner, BluetoothAdapter.LeScanCallback {
-	private final Object mLock = new Object();
-	private final String mDeviceAddress;
-	private final String mDeviceAddressIncremented;
-	private DfuDeviceSelector mSelector;
-	private String mBootloaderAddress;
-	private boolean mFound;
-
-	BootloaderScannerJB(final String deviceAddress, final String deviceAddressIncremented) {
-		mDeviceAddress = deviceAddress;
-		mDeviceAddressIncremented = deviceAddressIncremented;
-	}
-
-	@Nullable
-	@Override
-	public String searchUsing(@NonNull DfuDeviceSelector selector, long timeout) {
-		mSelector = selector;
-		mBootloaderAddress = null;
-		mFound = false;
-
-		// Add timeout
-		new Thread(() -> {
-			try {
-				Thread.sleep(timeout);
-			} catch (final InterruptedException e) {
-				// do nothing
-			}
-
-			if (mFound)
-				return;
-
-			mBootloaderAddress = null;
-			mFound = true;
-
-			// Notify the waiting thread
-			synchronized (mLock) {
-				mLock.notifyAll();
-			}
-		}, "Scanner timer").start();
-
-		final BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
-		if (adapter == null || adapter.getState() != BluetoothAdapter.STATE_ON)
-			return null;
-		adapter.startLeScan(this);
-
-		try {
-			synchronized (mLock) {
-				while (!mFound)
-					mLock.wait();
-			}
-		} catch (final InterruptedException e) {
-			// do nothing
-		}
-
-		adapter.stopLeScan(this);
-		return mBootloaderAddress;
-	}
-
-	@Override
-	public void onLeScan(@NonNull final BluetoothDevice device, final int rssi, final byte[] scanRecord) {
-		final String address = device.getAddress();
-
-		if (!mFound && mSelector.matches(
-				device, rssi,
-				scanRecord,
-				mDeviceAddress, mDeviceAddressIncremented
-		)) {
-			mBootloaderAddress = address;
-			mFound = true;
-
-			// Notify the waiting thread
-			synchronized (mLock) {
-				mLock.notifyAll();
-			}
-		}
-	}
-
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScannerLollipop.java b/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScannerLollipop.java
deleted file mode 100644
index cc46588..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/dfu/internal/scanner/BootloaderScannerLollipop.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.dfu.internal.scanner;
-
-import android.annotation.SuppressLint;
-import android.annotation.TargetApi;
-import android.bluetooth.BluetoothAdapter;
-import android.bluetooth.le.BluetoothLeScanner;
-import android.bluetooth.le.ScanCallback;
-import android.bluetooth.le.ScanFilter;
-import android.bluetooth.le.ScanResult;
-import android.bluetooth.le.ScanSettings;
-import android.os.Build;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import no.nordicsemi.android.dfu.DfuDeviceSelector;
-
-/**
- * @see BootloaderScanner
- */
-@SuppressLint("MissingPermission")
-@TargetApi(Build.VERSION_CODES.LOLLIPOP)
-class BootloaderScannerLollipop extends ScanCallback implements BootloaderScanner {
-    private final Object mLock = new Object();
-    private final String mDeviceAddress;
-    private final String mDeviceAddressIncremented;
-    private DfuDeviceSelector mSelector;
-    private String mBootloaderAddress;
-    private boolean mFound;
-
-    BootloaderScannerLollipop(final String deviceAddress, final String deviceAddressIncremented) {
-        mDeviceAddress = deviceAddress;
-        mDeviceAddressIncremented = deviceAddressIncremented;
-    }
-
-    @Nullable
-    @Override
-    public String searchUsing(@NonNull DfuDeviceSelector selector, long timeout) {
-        mSelector = selector;
-        mBootloaderAddress = null;
-        mFound = false;
-
-        // Add timeout
-        new Thread(() -> {
-            try {
-                Thread.sleep(timeout);
-            } catch (final InterruptedException e) {
-                // do nothing
-            }
-
-            if (mFound)
-                return;
-
-            mBootloaderAddress = null;
-            mFound = true;
-
-            // Notify the waiting thread
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }, "Scanner timer").start();
-
-        final BluetoothAdapter adapter = BluetoothAdapter.getDefaultAdapter();
-        if (adapter == null || adapter.getState() != BluetoothAdapter.STATE_ON)
-            return null;
-        final BluetoothLeScanner scanner = adapter.getBluetoothLeScanner();
-        if (scanner == null)
-            return null;
-        /*
-         * Android 8.1 onwards, stops unfiltered BLE scanning on screen off. Therefore we must add a filter to
-         * get scan results in case the device screen is turned off as this may affect users wanting scan/connect to the device in background.
-         * See https://android.googlesource.com/platform/packages/apps/Bluetooth/+/319aeae6f4ebd13678b4f77375d1804978c4a1e1
-         */
-        final ScanSettings settings = new ScanSettings.Builder().setScanMode(ScanSettings.SCAN_MODE_LOW_LATENCY).build();
-        if (adapter.isOffloadedFilteringSupported() && Build.VERSION.SDK_INT >= Build.VERSION_CODES.O_MR1) {
-            final List<ScanFilter> filters = new ArrayList<>();
-            // Some Android devices fail to scan with offloaded address filters.
-            // Instead, we will add an empty filter, just to allow background scanning, and will
-            // filter below using the device selector.
-            scanner.startScan(filters, settings, this);
-        } else {
-            /*
-             * Scanning with filters does not work on Nexus 9 (Android 5.1). No devices are found and scanner terminates on timeout.
-             * We will match the device address in the callback method instead. It's not like it should be, but at least it works.
-             */
-            scanner.startScan(null, settings, this);
-        }
-
-        try {
-            synchronized (mLock) {
-                while (!mFound)
-                    mLock.wait();
-            }
-        } catch (final InterruptedException e) {
-            // do nothing
-        }
-
-        scanner.stopScan(this);
-        return mBootloaderAddress;
-    }
-
-    @Override
-    public void onScanResult(final int callbackType, final ScanResult result) {
-        final String address = result.getDevice().getAddress();
-
-        if (!mFound && mSelector.matches(
-                result.getDevice(), result.getRssi(),
-                result.getScanRecord().getBytes(),
-                mDeviceAddress, mDeviceAddressIncremented
-        )) {
-            mBootloaderAddress = address;
-            mFound = true;
-
-            // Notify the waiting thread
-            synchronized (mLock) {
-                mLock.notifyAll();
-            }
-        }
-    }
-}
\ No newline at end of file
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/error/GattError.java b/dfu-lib/src/main/java/no/nordicsemi/android/error/GattError.java
deleted file mode 100644
index 9f2817b..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/error/GattError.java
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.error;
-
-import android.bluetooth.BluetoothGatt;
-
-import no.nordicsemi.android.dfu.DfuBaseService;
-
-/**
- * Parses the error numbers according to the <b>gatt_api.h</b> file from bluedroid stack.
- * See: https://android.googlesource.com/platform/external/bluetooth/bluedroid/+/android-5.1.0_r1/stack/include/gatt_api.h (and other versions) for details.
- * See also: https://android.googlesource.com/platform/external/libnfc-nci/+/master/src/include/hcidefs.h#447 for other possible HCI errors.
- */
-public class GattError {
-	// Starts at line 106 of gatt_api.h file
-	/**
-	 * Converts the connection status given by the {@link android.bluetooth.BluetoothGattCallback#onConnectionStateChange(android.bluetooth.BluetoothGatt, int, int)} to error name.
-	 * @param error the status number
-	 * @return the error name as stated in the gatt_api.h file
-	 */
-	public static String parseConnectionError(final int error) {
-		switch (error) {
-			case BluetoothGatt.GATT_SUCCESS:
-				return "SUCCESS";
-			case 0x01:
-				return "GATT CONN L2C FAILURE";
-			case 0x08:
-				return "GATT CONN TIMEOUT";
-			case 0x13:
-				return "GATT CONN TERMINATE PEER USER";
-			case 0x16:
-				return "GATT CONN TERMINATE LOCAL HOST";
-			case 0x3E:
-				return "GATT CONN FAIL ESTABLISH";
-			case 0x22:
-				return "GATT CONN LMP TIMEOUT";
-			case 0x0100:
-				return "GATT CONN CANCEL ";
-			case 0x0085:
-				return "GATT ERROR"; // Device not reachable
-			default:
-				return "UNKNOWN (" + error + ")";
-		}
-	}
-
-	// Starts at line 29 of the gatt_api.h file
-	/**
-	 * Converts the bluetooth communication status given by other BluetoothGattCallbacks to error name. It also parses the DFU errors.
-	 * @param error the status number
-	 * @return the error name as stated in the gatt_api.h file
-	 */
-	public static String parse(final int error) {
-		switch (error) {
-			case 0x0001:
-				return "GATT INVALID HANDLE";
-			case 0x0002:
-				return "GATT READ NOT PERMIT";
-			case 0x0003:
-				return "GATT WRITE NOT PERMIT";
-			case 0x0004:
-				return "GATT INVALID PDU";
-			case 0x0005:
-				return "GATT INSUF AUTHENTICATION";
-			case 0x0006:
-				return "GATT REQ NOT SUPPORTED";
-			case 0x0007:
-				return "GATT INVALID OFFSET";
-			case 0x0008:
-				return "GATT INSUF AUTHORIZATION";
-			case 0x0009:
-				return "GATT PREPARE Q FULL";
-			case 0x000a:
-				return "GATT NOT FOUND";
-			case 0x000b:
-				return "GATT NOT LONG";
-			case 0x000c:
-				return "GATT INSUF KEY SIZE";
-			case 0x000d:
-				return "GATT INVALID ATTR LEN";
-			case 0x000e:
-				return "GATT ERR UNLIKELY";
-			case 0x000f:
-				return "GATT INSUF ENCRYPTION";
-			case 0x0010:
-				return "GATT UNSUPPORT GRP TYPE";
-			case 0x0011:
-				return "GATT INSUF RESOURCE";
-			case 0x001A:
-				return "HCI ERROR UNSUPPORTED REMOTE FEATURE";
-			case 0x001E:
-				return "HCI ERROR INVALID LMP PARAM";
-			case 0x0022:
-				return "GATT CONN LMP TIMEOUT";
-			case 0x002A:
-				return "HCI ERROR DIFF TRANSACTION COLLISION";
-			case 0x003A:
-				return "GATT CONTROLLER BUSY";
-			case 0x003B:
-				return "GATT UNACCEPT CONN INTERVAL";
-			case 0x0087:
-				return "GATT ILLEGAL PARAMETER";
-			case 0x0080:
-				return "GATT NO RESOURCES";
-			case 0x0081:
-				return "GATT INTERNAL ERROR";
-			case 0x0082:
-				return "GATT WRONG STATE";
-			case 0x0083:
-				return "GATT DB FULL";
-			case 0x0084:
-				return "GATT BUSY";
-			case 0x0085:
-				return "GATT ERROR";
-			case 0x0086:
-				return "GATT CMD STARTED";
-			case 0x0088:
-				return "GATT PENDING";
-			case 0x0089:
-				return "GATT AUTH FAIL";
-			case 0x008a:
-				return "GATT MORE";
-			case 0x008b:
-				return "GATT INVALID CFG";
-			case 0x008c:
-				return "GATT SERVICE STARTED";
-			case 0x008d:
-				return "GATT ENCRYPTED NO MITM";
-			case 0x008e:
-				return "GATT NOT ENCRYPTED";
-			case 0x008f:
-				return "GATT CONGESTED";
-			case 0x00FD:
-				return "GATT CCCD CFG ERROR";
-			case 0x00FE:
-				return "GATT PROCEDURE IN PROGRESS";
-			case 0x00FF:
-				return "GATT VALUE OUT OF RANGE";
-			case 0x0101:
-				return "TOO MANY OPEN CONNECTIONS";
-			case DfuBaseService.ERROR_DEVICE_DISCONNECTED:
-				return "DFU DEVICE DISCONNECTED";
-			case DfuBaseService.ERROR_FILE_NOT_FOUND:
-				return "DFU FILE NOT FOUND";
-			case DfuBaseService.ERROR_FILE_ERROR:
-				return "DFU FILE ERROR";
-			case DfuBaseService.ERROR_FILE_INVALID:
-				return "DFU NOT A VALID HEX FILE";
-			case DfuBaseService.ERROR_FILE_IO_EXCEPTION:
-				return "DFU IO EXCEPTION";
-			case DfuBaseService.ERROR_SERVICE_DISCOVERY_NOT_STARTED:
-				return "DFU SERVICE DISCOVERY NOT STARTED";
-			case DfuBaseService.ERROR_SERVICE_NOT_FOUND:
-				return "DFU CHARACTERISTICS NOT FOUND";
-			case DfuBaseService.ERROR_INVALID_RESPONSE:
-				return "DFU INVALID RESPONSE";
-			case DfuBaseService.ERROR_FILE_TYPE_UNSUPPORTED:
-				return "DFU FILE TYPE NOT SUPPORTED";
-			case DfuBaseService.ERROR_BLUETOOTH_DISABLED:
-				return "BLUETOOTH ADAPTER DISABLED";
-			case DfuBaseService.ERROR_INIT_PACKET_REQUIRED:
-				return "DFU INIT PACKET REQUIRED";
-			case DfuBaseService.ERROR_FILE_SIZE_INVALID:
-				return "DFU INIT PACKET REQUIRED";
-			case DfuBaseService.ERROR_CRC_ERROR:
-				return "DFU CRC ERROR";
-			case DfuBaseService.ERROR_DEVICE_NOT_BONDED:
-				return "DFU DEVICE NOT BONDED";
-			default:
-				return "UNKNOWN (" + error + ")";
-		}
-	}
-
-	public static String parseDfuRemoteError(final int error) {
-		switch (error & (DfuBaseService.ERROR_REMOTE_TYPE_LEGACY | DfuBaseService.ERROR_REMOTE_TYPE_SECURE | DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | DfuBaseService.ERROR_REMOTE_TYPE_SECURE_BUTTONLESS)) {
-			case DfuBaseService.ERROR_REMOTE_TYPE_LEGACY:
-				return LegacyDfuError.parse(error);
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE:
-				return SecureDfuError.parse(error);
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED:
-				return SecureDfuError.parseExtendedError(error);
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_BUTTONLESS:
-				return SecureDfuError.parseButtonlessError(error);
-			default:
-				return "UNKNOWN (" + error + ")";
-		}
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/error/LegacyDfuError.java b/dfu-lib/src/main/java/no/nordicsemi/android/error/LegacyDfuError.java
deleted file mode 100644
index 258e8dd..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/error/LegacyDfuError.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.error;
-
-import no.nordicsemi.android.dfu.DfuBaseService;
-
-public final class LegacyDfuError {
-	// DFU status values
-	// public static final int SUCCESS = 1; // that's not an error
-	public static final int INVALID_STATE = 2;
-	public static final int NOT_SUPPORTED = 3;
-	public static final int DATA_SIZE_EXCEEDS_LIMIT = 4;
-	public static final int CRC_ERROR = 5;
-	public static final int OPERATION_FAILED = 6;
-
-	public static String parse(final int error) {
-		switch (error) {
-			case DfuBaseService.ERROR_REMOTE_TYPE_LEGACY | INVALID_STATE:				return "INVALID STATE";
-			case DfuBaseService.ERROR_REMOTE_TYPE_LEGACY | NOT_SUPPORTED:				return "NOT SUPPORTED";
-			case DfuBaseService.ERROR_REMOTE_TYPE_LEGACY | DATA_SIZE_EXCEEDS_LIMIT:		return "DATA SIZE EXCEEDS LIMIT";
-			case DfuBaseService.ERROR_REMOTE_TYPE_LEGACY | CRC_ERROR:					return "INVALID CRC ERROR";
-			case DfuBaseService.ERROR_REMOTE_TYPE_LEGACY | OPERATION_FAILED:			return "OPERATION FAILED";
-			default:
-				return "UNKNOWN (" + error + ")";
-		}
-	}
-}
diff --git a/dfu-lib/src/main/java/no/nordicsemi/android/error/SecureDfuError.java b/dfu-lib/src/main/java/no/nordicsemi/android/error/SecureDfuError.java
deleted file mode 100644
index 944700a..0000000
--- a/dfu-lib/src/main/java/no/nordicsemi/android/error/SecureDfuError.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/*
- * Copyright (c) 2018, Nordic Semiconductor
- * All rights reserved.
- *
- * Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
- *
- * 1. Redistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.
- *
- * 2. Redistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the
- * documentation and/or other materials provided with the distribution.
- *
- * 3. Neither the name of the copyright holder nor the names of its contributors may be used to endorse or promote products derived from this
- * software without specific prior written permission.
- *
- * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
- * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
- * HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
- * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON
- * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE
- * USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
- */
-
-package no.nordicsemi.android.error;
-
-import no.nordicsemi.android.dfu.DfuBaseService;
-
-public final class SecureDfuError {
-	// DFU status values
-	// public static final int SUCCESS = 1; // that's not an error
-	public static final int OP_CODE_NOT_SUPPORTED = 2;
-	public static final int INVALID_PARAM = 3;
-	public static final int INSUFFICIENT_RESOURCES = 4;
-	public static final int INVALID_OBJECT = 5;
-	public static final int UNSUPPORTED_TYPE = 7;
-	public static final int OPERATION_NOT_PERMITTED = 8;
-	public static final int OPERATION_FAILED = 10; // 0xA
-	public static final int EXTENDED_ERROR = 11; // 0xB
-
-	// public static final int EXT_ERROR_NO_ERROR = 0x00; // that's not an error
-	public static final int EXT_ERROR_WRONG_COMMAND_FORMAT = 0x02;
-	public static final int EXT_ERROR_UNKNOWN_COMMAND = 0x03;
-	public static final int EXT_ERROR_INIT_COMMAND_INVALID = 0x04;
-	public static final int EXT_ERROR_FW_VERSION_FAILURE = 0x05;
-	public static final int EXT_ERROR_HW_VERSION_FAILURE = 0x06;
-	public static final int EXT_ERROR_SD_VERSION_FAILURE = 0x07;
-	public static final int EXT_ERROR_SIGNATURE_MISSING = 0x08;
-	public static final int EXT_ERROR_WRONG_HASH_TYPE = 0x09;
-	public static final int EXT_ERROR_HASH_FAILED = 0x0A;
-	public static final int EXT_ERROR_WRONG_SIGNATURE_TYPE = 0x0B;
-	public static final int EXT_ERROR_VERIFICATION_FAILED = 0x0C;
-	public static final int EXT_ERROR_INSUFFICIENT_SPACE = 0x0D;
-
-	// public static final int BUTTONLESS_SUCCESS = 1;
-	public static final int BUTTONLESS_ERROR_OP_CODE_NOT_SUPPORTED = 2;
-	public static final int BUTTONLESS_ERROR_OPERATION_FAILED = 4;
-
-	public static String parse(final int error) {
-		switch (error) {
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE | OP_CODE_NOT_SUPPORTED:		return "OP CODE NOT SUPPORTED";
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE | INVALID_PARAM:				return "INVALID PARAM";
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE | INSUFFICIENT_RESOURCES:		return "INSUFFICIENT RESOURCES";
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE | INVALID_OBJECT:				return "INVALID OBJECT";
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE | UNSUPPORTED_TYPE:			return "UNSUPPORTED TYPE";
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE | OPERATION_NOT_PERMITTED:		return "OPERATION NOT PERMITTED";
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE | OPERATION_FAILED:			return "OPERATION FAILED";
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE | EXTENDED_ERROR:				return "EXTENDED ERROR";
-			default:
-				return "UNKNOWN (" + error + ")";
-		}
-	}
-
-	public static String parseExtendedError(final int error) {
-		switch (error) {
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_WRONG_COMMAND_FORMAT: return "Wrong command format";
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_UNKNOWN_COMMAND:		return "Unknown command";
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_INIT_COMMAND_INVALID: return "Init command invalid";
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_FW_VERSION_FAILURE:	return "FW version failure";
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_HW_VERSION_FAILURE:	return "HW version failure";
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_SD_VERSION_FAILURE:	return "SD version failure";
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_SIGNATURE_MISSING :	return "Signature mismatch";
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_WRONG_HASH_TYPE:		return "Wrong hash type";
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_HASH_FAILED:			return "Hash failed";
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_WRONG_SIGNATURE_TYPE: return "Wrong signature type";
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_VERIFICATION_FAILED:	return "Verification failed";
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_EXTENDED | EXT_ERROR_INSUFFICIENT_SPACE:	return "Insufficient space";
-			default:
-				return "Reserved for future use";
-		}
-	}
-
-	public static String parseButtonlessError(final int error) {
-		switch (error) {
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_BUTTONLESS | BUTTONLESS_ERROR_OP_CODE_NOT_SUPPORTED:	return "OP CODE NOT SUPPORTED";
-			case DfuBaseService.ERROR_REMOTE_TYPE_SECURE_BUTTONLESS | BUTTONLESS_ERROR_OPERATION_FAILED:		return "OPERATION FAILED";
-			default:
-				return "UNKNOWN (" + error + ")";
-		}
-	}
-}
