diff --git a/app/src/main/java/be/ugent/zeus/hydra/data/models/UrgentProgramme.java b/app/src/main/java/be/ugent/zeus/hydra/data/models/UrgentProgramme.java
new file mode 100644
index 00000000..b5f383a9
--- /dev/null
+++ b/app/src/main/java/be/ugent/zeus/hydra/data/models/UrgentProgramme.java
@@ -0,0 +1,28 @@
+package be.ugent.zeus.hydra.data.models;
+
+import org.threeten.bp.Instant;
+
+/**
+ * @author Niko Strijbol
+ */
+public class UrgentProgramme {
+
+    private String name;
+    private Instant validUntil;
+
+    public Instant getValidUntil() {
+        return validUntil;
+    }
+
+    public void setValidUntil(Instant validUntil) {
+        this.validUntil = validUntil;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public void setName(String name) {
+        this.name = name;
+    }
+}
diff --git a/app/src/main/java/be/ugent/zeus/hydra/data/models/UrgentTrack.java b/app/src/main/java/be/ugent/zeus/hydra/data/models/UrgentTrack.java
deleted file mode 100644
index 143b6d75..00000000
--- a/app/src/main/java/be/ugent/zeus/hydra/data/models/UrgentTrack.java
+++ /dev/null
@@ -1,81 +0,0 @@
-package be.ugent.zeus.hydra.data.models;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.os.AsyncTask;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import be.ugent.zeus.hydra.R;
-import be.ugent.zeus.hydra.data.network.requests.UrgentUrlRequest;
-import be.ugent.zeus.hydra.service.urgent.Track;
-import java8.util.function.Consumer;
-
-/**
- * The track for Urgent.
- *
- * @author Niko Strijbol
- */
-public class UrgentTrack implements Track {
-
-    private static final String TAG = "UrgentTrack";
-    private static final int URGENT_ID = 1;
-
-    private final Context context;
-
-    public UrgentTrack(Context context) {
-        this.context = context.getApplicationContext(); //Prevent leaks.
-    }
-
-    @Override
-    public int getId() {
-        return URGENT_ID;
-    }
-
-    @Override
-    @Nullable
-    public String getArtist() {
-        return null;
-        //return context.getString(R.string.urgent_unknown_programme);
-    }
-
-    @Override
-    @NonNull
-    public String getTitle() {
-        return context.getString(R.string.urgent_fm);
-    }
-
-    @Override
-    public void getUrl(final Consumer<String> consumer) {
-        new UrlTask(consumer).execute();
-    }
-
-    @Override
-    @Nullable
-    public Bitmap getAlbumArtwork() {
-        return BitmapFactory.decodeResource(context.getResources(), R.drawable.logo_urgent);
-    }
-
-    /**
-     * Task to get the URL. This class is not static, since we need the context.
-     */
-    private static class UrlTask extends AsyncTask<Void, Void, String> {
-
-        private final Consumer<String> consumer;
-
-        private UrlTask(Consumer<String> consumer) {
-            this.consumer = consumer;
-        }
-
-        @Override
-        protected String doInBackground(Void... voids) {
-            return new UrgentUrlRequest().performRequest(null).getData() + ".mp3";
-        }
-
-        @Override
-        protected void onPostExecute(String s) {
-            super.onPostExecute(s);
-            consumer.accept(s);
-        }
-    }
-}
\ No newline at end of file
diff --git a/app/src/main/java/be/ugent/zeus/hydra/data/network/requests/UrgentInfoRequest.java b/app/src/main/java/be/ugent/zeus/hydra/data/network/requests/UrgentInfoRequest.java
new file mode 100644
index 00000000..52ae0ae3
--- /dev/null
+++ b/app/src/main/java/be/ugent/zeus/hydra/data/network/requests/UrgentInfoRequest.java
@@ -0,0 +1,22 @@
+package be.ugent.zeus.hydra.data.network.requests;
+
+import android.support.annotation.NonNull;
+
+import be.ugent.zeus.hydra.data.models.UrgentProgramme;
+import be.ugent.zeus.hydra.data.network.JsonSpringRequest;
+
+/**
+ * @author Niko Strijbol
+ */
+public class UrgentInfoRequest extends JsonSpringRequest<UrgentProgramme> {
+
+    public UrgentInfoRequest() {
+        super(UrgentProgramme.class);
+    }
+
+    @NonNull
+    @Override
+    protected String getAPIUrl() {
+        return "http://hydra.api.almiro.be/current";
+    }
+}
diff --git a/app/src/main/java/be/ugent/zeus/hydra/service/urgent/MediaNotificationBuilder.java b/app/src/main/java/be/ugent/zeus/hydra/service/urgent/MediaNotificationBuilder.java
index f1d6bb65..08a1c5c8 100644
--- a/app/src/main/java/be/ugent/zeus/hydra/service/urgent/MediaNotificationBuilder.java
+++ b/app/src/main/java/be/ugent/zeus/hydra/service/urgent/MediaNotificationBuilder.java
@@ -1,18 +1,17 @@
 package be.ugent.zeus.hydra.service.urgent;
 
 import android.app.Notification;
-import android.app.PendingIntent;
 import android.content.Context;
-import android.content.Intent;
 import android.graphics.BitmapFactory;
 import android.support.v4.app.NotificationCompat;
+import android.support.v4.media.MediaDescriptionCompat;
 import android.support.v4.media.session.MediaButtonReceiver;
+import android.support.v4.media.session.MediaControllerCompat;
 import android.support.v4.media.session.MediaSessionCompat;
 import android.support.v4.media.session.PlaybackStateCompat;
 
 import be.ugent.zeus.hydra.R;
 import be.ugent.zeus.hydra.data.ChannelCreator;
-import be.ugent.zeus.hydra.ui.main.MainActivity;
 
 /**
  * Manages the media notification(s).
@@ -27,12 +26,8 @@ public class MediaNotificationBuilder {
         this.context = context;
     }
 
-    public Notification buildNotification(MediaInfoProvider provider) {
-
-        Track track = provider.getTrack();
-
-        // Get the click intent
-        PendingIntent clickIntent = buildClickIntent();
+    public Notification buildNotification(MediaSessionCompat mediaSession) {
+        MediaControllerCompat controller = mediaSession.getController();
 
         // Construct the actual notification
         NotificationCompat.Builder builder = new NotificationCompat.Builder(context, ChannelCreator.URGENT_CHANNEL);
@@ -40,17 +35,18 @@ public class MediaNotificationBuilder {
         // Construct the style
         android.support.v4.media.app.NotificationCompat.MediaStyle style =
                 new android.support.v4.media.app.NotificationCompat.MediaStyle(builder)
-                .setMediaSession(provider.getMediaToken())
-                .setShowCancelButton(true)
-                .setCancelButtonIntent(MediaButtonReceiver.buildMediaButtonPendingIntent(context, PlaybackStateCompat.ACTION_STOP))
-                .setShowActionsInCompactView(0);
+                        .setMediaSession(mediaSession.getSessionToken())
+                        .setShowCancelButton(true)
+                        .setCancelButtonIntent(MediaButtonReceiver.buildMediaButtonPendingIntent(context, PlaybackStateCompat.ACTION_STOP))
+                        .setShowActionsInCompactView(0);
 
         // Construct the play/pause button.
-        if (provider.isPlaying()) {
+        boolean isPlaying = controller.getPlaybackState().getState() == PlaybackStateCompat.STATE_PLAYING;
+        if (isPlaying) {
             builder.addAction(new NotificationCompat.Action(
-                    R.drawable.noti_ic_pause_24dp,
-                    context.getString(R.string.urgent_pause),
-                    MediaButtonReceiver.buildMediaButtonPendingIntent(context, PlaybackStateCompat.ACTION_PAUSE))
+                    R.drawable.noti_ic_stop,
+                    context.getString(R.string.urgent_stop),
+                    MediaButtonReceiver.buildMediaButtonPendingIntent(context, PlaybackStateCompat.ACTION_STOP))
             );
         } else {
             builder.addAction(
@@ -60,48 +56,25 @@ public class MediaNotificationBuilder {
             );
         }
 
-        if (provider.getState().getState() == PlaybackStateCompat.STATE_PAUSED || provider.getState().getState() ==  PlaybackStateCompat.STATE_PLAYING) {
-            builder.addAction(new NotificationCompat.Action(
-                    R.drawable.noti_ic_stop,
-                    context.getString(R.string.urgent_stop),
-                    MediaButtonReceiver.buildMediaButtonPendingIntent(context, PlaybackStateCompat.ACTION_STOP))
-            );
-        }
+        MediaDescriptionCompat descriptionCompat = controller.getMetadata().getDescription();
 
         builder.setSmallIcon(R.drawable.ic_notification_urgent)
                 .setShowWhen(false)
-                .setContentTitle(track.getTitle())
-                .setContentText(track.getArtist())
+                .setContentTitle(descriptionCompat.getTitle())
+                .setContentText(descriptionCompat.getSubtitle())
                 .setDeleteIntent(MediaButtonReceiver.buildMediaButtonPendingIntent(context, PlaybackStateCompat.ACTION_STOP))
-                .setContentIntent(clickIntent)
+                .setContentIntent(controller.getSessionActivity())
                 .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)
                 .setChannelId(ChannelCreator.URGENT_CHANNEL)
                 .setStyle(style);
 
         //Add album artwork if available
-        if (track.getAlbumArtwork() != null) {
-            builder.setLargeIcon(track.getAlbumArtwork());
+        if (descriptionCompat.getIconBitmap() != null) {
+            builder.setLargeIcon(descriptionCompat.getIconBitmap());
         } else {
             builder.setLargeIcon(BitmapFactory.decodeResource(context.getResources(), R.drawable.ic_album));
         }
 
         return builder.build();
     }
-
-    public interface MediaInfoProvider {
-
-        boolean isPlaying();
-
-        MediaSessionCompat.Token getMediaToken();
-
-        Track getTrack();
-
-        PlaybackStateCompat getState();
-    }
-
-    private PendingIntent buildClickIntent() {
-        Intent startThis = new Intent(context, MainActivity.class);
-        startThis.putExtra(MainActivity.ARG_TAB, R.id.drawer_urgent);
-        return PendingIntent.getActivity(context, 0, startThis, PendingIntent.FLAG_UPDATE_CURRENT);
-    }
 }
\ No newline at end of file
diff --git a/app/src/main/java/be/ugent/zeus/hydra/service/urgent/MediaStateListener.java b/app/src/main/java/be/ugent/zeus/hydra/service/urgent/MediaStateListener.java
index 7fc38866..be144a82 100644
--- a/app/src/main/java/be/ugent/zeus/hydra/service/urgent/MediaStateListener.java
+++ b/app/src/main/java/be/ugent/zeus/hydra/service/urgent/MediaStateListener.java
@@ -1,7 +1,7 @@
 package be.ugent.zeus.hydra.service.urgent;
 
 /**
- * Listen to changes of the state of the {@link MediaManager}.
+ * Listen to changes of the state of the {@link Playback}.
  *
  * @author Niko Strijbol
  */
diff --git a/app/src/main/java/be/ugent/zeus/hydra/service/urgent/MusicBinder.java b/app/src/main/java/be/ugent/zeus/hydra/service/urgent/MusicBinder.java
index 79807499..d08b1673 100644
--- a/app/src/main/java/be/ugent/zeus/hydra/service/urgent/MusicBinder.java
+++ b/app/src/main/java/be/ugent/zeus/hydra/service/urgent/MusicBinder.java
@@ -21,8 +21,4 @@ public class MusicBinder extends Binder {
     public MusicService getService() {
         return service;
     }
-
-    public MediaManager getManager() {
-        return service.getMediaManager();
-    }
 }
\ No newline at end of file
diff --git a/app/src/main/java/be/ugent/zeus/hydra/service/urgent/MusicService.java b/app/src/main/java/be/ugent/zeus/hydra/service/urgent/MusicService.java
index 0874e9f1..0902936a 100644
--- a/app/src/main/java/be/ugent/zeus/hydra/service/urgent/MusicService.java
+++ b/app/src/main/java/be/ugent/zeus/hydra/service/urgent/MusicService.java
@@ -2,124 +2,61 @@ package be.ugent.zeus.hydra.service.urgent;
 
 import android.app.Notification;
 import android.app.NotificationManager;
-import android.app.Service;
+import android.app.PendingIntent;
 import android.content.Context;
 import android.content.Intent;
-import android.media.AudioManager;
-import android.net.wifi.WifiManager;
-import android.os.IBinder;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v4.media.MediaBrowserCompat;
+import android.support.v4.media.MediaBrowserServiceCompat;
 import android.support.v4.media.MediaMetadataCompat;
 import android.support.v4.media.session.MediaButtonReceiver;
 import android.support.v4.media.session.MediaSessionCompat;
 import android.support.v4.media.session.PlaybackStateCompat;
 import android.util.Log;
 
-import be.ugent.zeus.hydra.data.models.UrgentTrack;
-import java8.util.Objects;
-import java8.util.function.Consumer;
+import be.ugent.zeus.hydra.R;
+import be.ugent.zeus.hydra.ui.main.MainActivity;
+
+import java.util.Collections;
+import java.util.List;
 
 /**
  * TODO: handle noisy audio
+ *
  * @author Niko Strijbol
  */
-public class MusicService extends Service implements MediaStateListener, AudioManager.OnAudioFocusChangeListener {
+public class MusicService extends MediaBrowserServiceCompat implements MediaStateListener {
 
     private static final String TAG = "MusicService";
     private static final int MUSIC_SERVICE_ID = 1;
-    private static final String WIFI_LOCK_TAG = "UrgentMusic";
-
-    private final IBinder binder = new MusicBinder(this);
-
+    private static final int REQUEST_CODE = 121;
     private MediaNotificationBuilder notificationBuilder;
-    private Track track;
 
     private MediaSessionCompat mediaSession;
-    private WifiManager.WifiLock wifiLock;
-    private MediaManager mediaManager;
-    private boolean initialized = false;
-    private boolean isForeground = false;
-    private Consumer<MediaSessionCompat.Token> tokenConsumer;
-    private boolean isMediaSessionPrepared = false;
+    private Playback playback;
+    private boolean isStarted = false;
     private PlaybackStateCompat.Builder stateCompatBuilder;
-
-    @Override
-    public IBinder onBind(Intent intent) {
-        return binder;
-    }
+    private UrgentTrackProvider trackProvider;
 
     @Override
     public void onCreate() {
         super.onCreate();
-        notificationBuilder = new MediaNotificationBuilder(getApplicationContext());
-        track = new UrgentTrack(getApplicationContext());
         Log.d(TAG, "onCreate: starting new service...");
-    }
-
-    @Override
-    public int onStartCommand(Intent intent, int flags, int startId) {
+        trackProvider = new UrgentTrackProvider(this);
+        notificationBuilder = new MediaNotificationBuilder(this);
 
-        Log.d(TAG, "onStartCommand: Received intent");
+        playback = new Playback(this, this);
 
-        if (!initialized) {
-            Log.d(TAG, "onStartCommand: Doing set up");
-            setUp();
-            initialized = true;
-        }
-
-        MediaButtonReceiver.handleIntent(mediaSession, intent);
-
-        return START_STICKY;
-    }
-
-    private void setUp() {
-
-        // Set up the media player.
-        initMediaPlayer();
-
-        // Get the wake lock instance.
-        wifiLock = ((WifiManager) getApplicationContext()
-                .getSystemService(Context.WIFI_SERVICE))
-                .createWifiLock(WifiManager.WIFI_MODE_FULL, WIFI_LOCK_TAG);
-
-        // Set up the media session.
-        initMediaSession();
-    }
+        // Start a MediaSession
 
-    /**
-     * Initialises the media player and starts retrieving the URL to play.
-     */
-    private void initMediaPlayer() {
-
-        Log.d(TAG, "initMediaPlayer: initing media player");
-
-        mediaManager = new MediaManager(getApplicationContext(), this);
-
-        // Start getting the URL.
-
-        track.getUrl(s -> {
-            mediaManager.setUrl(s);
-            if (tokenConsumer != null) {
-                tokenConsumer.accept(mediaSession.getSessionToken());
-                tokenConsumer = null;
-            }
-        });
-    }
-
-    /**
-     * Initialises the media session. MUST be called after the media player was set up.
-     */
-    private void initMediaSession() {
-
-        Log.d(TAG, "initMediaSession: initing media session");
+        mediaSession = new MediaSessionCompat(this, TAG);
+        setSessionToken(mediaSession.getSessionToken());
+        mediaSession.setFlags(MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS | MediaSessionCompat.FLAG_HANDLES_TRANSPORT_CONTROLS);
 
-        //TODO
-        Objects.requireNonNull(mediaManager);
+        mediaSession.setCallback(new SimpleSessionCallback(getApplicationContext(), playback, trackProvider, this::updateMetadata));
 
-        // TODO: sort out the media buttons handlers
-        mediaSession = new MediaSessionCompat(getApplicationContext(), TAG);
-        mediaSession.setFlags(MediaSessionCompat.FLAG_HANDLES_MEDIA_BUTTONS | MediaSessionCompat.FLAG_HANDLES_TRANSPORT_CONTROLS);
-        mediaSession.setCallback(new SimpleSessionCallback(getApplicationContext(), mediaManager));
-        mediaSession.setActive(true);
         stateCompatBuilder = new PlaybackStateCompat.Builder()
                 .setActions(PlaybackStateCompat.ACTION_PAUSE
                         | PlaybackStateCompat.ACTION_PLAY
@@ -127,25 +64,16 @@ public class MusicService extends Service implements MediaStateListener, AudioMa
                         | PlaybackStateCompat.ACTION_PREPARE);
         mediaSession.setPlaybackState(stateCompatBuilder.build());
 
-        // Set metadata
-        final MediaMetadataCompat.Builder builder = new MediaMetadataCompat.Builder();
-        builder.putText(MediaMetadataCompat.METADATA_KEY_ALBUM_ARTIST, track.getArtist());
-        builder.putText(MediaMetadataCompat.METADATA_KEY_TITLE, track.getTitle());
-
-        //Add the album artwork if it is available.
-        if (track.getAlbumArtwork() != null) {
-            builder.putBitmap(MediaMetadataCompat.METADATA_KEY_ALBUM_ART, track.getAlbumArtwork());
-        }
-
-        mediaSession.setMetadata(builder.build());
+        Intent startThis = new Intent(this, MainActivity.class);
+        startThis.putExtra(MainActivity.ARG_TAB, R.id.drawer_urgent);
+        PendingIntent pi = PendingIntent.getActivity(this, REQUEST_CODE, startThis, PendingIntent.FLAG_UPDATE_CURRENT);
+        mediaSession.setSessionActivity(pi);
+    }
 
-        // The playback is already preparing.
-        updateSessionState(PlaybackStateCompat.STATE_CONNECTING);
-        isMediaSessionPrepared = true;
-        if (tokenConsumer != null && mediaManager.hasUrl()) {
-            tokenConsumer.accept(mediaSession.getSessionToken());
-            tokenConsumer = null;
-        }
+    @Override
+    public int onStartCommand(Intent intent, int flags, int startId) {
+        MediaButtonReceiver.handleIntent(mediaSession, intent);
+        return super.onStartCommand(intent, flags, startId);
     }
 
     @Override
@@ -153,7 +81,7 @@ public class MusicService extends Service implements MediaStateListener, AudioMa
         // TODO: should we move this somewhere else?
         switch (newState) {
             case MediaState.PREPARED:
-                onPrepared();
+                updateSessionState(PlaybackStateCompat.STATE_BUFFERING);
                 break;
             case MediaState.ERROR:
                 updateSessionState(PlaybackStateCompat.STATE_ERROR);
@@ -169,74 +97,36 @@ public class MusicService extends Service implements MediaStateListener, AudioMa
                 break;
             case MediaState.STARTED:
                 updateSessionState(PlaybackStateCompat.STATE_PLAYING);
+                handlePlayRequest();
                 break;
             case MediaState.STOPPED:
-                onStopped();
+                updateSessionState(PlaybackStateCompat.STATE_STOPPED);
+                stopSelf();
                 break;
             case MediaState.END:
                 stopSelf(); // Stop the service.
+                updateSessionState(PlaybackStateCompat.STATE_NONE);
+                break;
+            case MediaState.IDLE:
+            case MediaState.INITIALIZED:
             default:
                 // Nothing.
         }
 
-        // Do not update the notification when we stop the service.
-        // Normally isForeground should always be false, but we never know.
-        if (isForeground || newState != MediaState.END) {
-            // Update notification
-            updateNotification();
-        }
+        updateNotification();
     }
 
-    /**
-     * The media player is read. Show the actual notification and start playback.
-     */
-    public void onPrepared() {
-
-        updateSessionState(PlaybackStateCompat.STATE_BUFFERING);
-
-        // Get the wakelock.
-        if (!wifiLock.isHeld()) {
-            wifiLock.acquire();
+    private void handlePlayRequest() {
+        if (!isStarted) {
+            startService(new Intent(getApplicationContext(), MusicService.class));
+            isStarted = true;
         }
-
-        AudioManager audioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
-        int result = audioManager.requestAudioFocus(this, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN);
-        if (result != AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
-            stopSelf();
+        if (!mediaSession.isActive()) {
+            mediaSession.setActive(true);
         }
-    }
-
-    public void onStopped() {
-        updateSessionState(PlaybackStateCompat.STATE_STOPPED);
-        if (wifiLock.isHeld()) {
-            wifiLock.release();
-        }
-
-        AudioManager audioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
-        audioManager.abandonAudioFocus(this);
-    }
 
-    @Override
-    public void onAudioFocusChange(int focusChange) {
-        switch (focusChange) {
-            case AudioManager.AUDIOFOCUS_LOSS:
-                mediaSession.getController().getTransportControls().stop();
-                break;
-            case AudioManager.AUDIOFOCUS_REQUEST_FAILED:
-                mediaSession.getController().getTransportControls().stop();
-                stopSelf(); // Stop the service
-                break;
-            case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:
-                mediaSession.getController().getTransportControls().pause();
-                break;
-            case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:
-                mediaManager.setVolume(0.5f, 0.5f);
-                break;
-            case AudioManager.AUDIOFOCUS_GAIN:
-                mediaManager.setVolume(1f, 1f);
-                mediaSession.getController().getTransportControls().play();
-                break;
-        }
+        MediaMetadataCompat data = trackProvider.getTrack();
+        mediaSession.setMetadata(data);
     }
 
     private void updateSessionState(@PlaybackStateCompat.State int state) {
@@ -250,74 +140,63 @@ public class MusicService extends Service implements MediaStateListener, AudioMa
     @Override
     public void onDestroy() {
         super.onDestroy();
-
         Log.d(TAG, "onDestroy");
+        mediaSession.getController().getTransportControls().stop();
+        mediaSession.release();
+    }
 
-        // Ensure we absolutely release everything.
-        if (wifiLock != null && wifiLock.isHeld()) {
-            wifiLock.release();
-        }
+    private void updateNotification() {
+        Notification mediaNotification = notificationBuilder.buildNotification(mediaSession);
 
-        AudioManager audioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
-        audioManager.abandonAudioFocus(this);
+        if (playback.isPlaying()) {
+            startForeground(MUSIC_SERVICE_ID, mediaNotification);
+        } else {
+            NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
 
-        if (mediaManager != null && mediaManager.hasMediaPlayer()) {
-            mediaManager.destroy();
+            //if (playback.getState() == MediaState.STOPPED || playback.getState() == MediaState.END) {
+                manager.notify(MUSIC_SERVICE_ID, mediaNotification);
+            //} else {
+                //manager.cancel(MUSIC_SERVICE_ID);
+            //}
+            stopForeground(false);
         }
-
-        stopForeground(true);
-        isForeground = false;
     }
 
-    public void setTokenConsumer(Consumer<MediaSessionCompat.Token> tokenConsumer) {
-        if (isMediaSessionPrepared && mediaManager.hasUrl()) {
-            tokenConsumer.accept(mediaSession.getSessionToken());
+    @Nullable
+    @Override
+    public BrowserRoot onGetRoot(@NonNull String clientPackageName, int clientUid, @Nullable Bundle rootHints) {
+        // If the client is us, allow browsing. Otherwise, don't allow any browsing.
+        if (clientPackageName.equals(getPackageName())) {
+            return new BrowserRoot(UrgentTrackProvider.MEDIA_ID_ROOT, null);
         } else {
-            this.tokenConsumer = tokenConsumer;
+            return new BrowserRoot(UrgentTrackProvider.MEDIA_ID_EMPTY_ROOT, null);
         }
     }
 
-    private MediaNotificationBuilder.MediaInfoProvider provider = new MediaNotificationBuilder.MediaInfoProvider() {
-        @Override
-        public boolean isPlaying() {
-            return mediaManager.isPlaying();
-        }
-
-        @Override
-        public MediaSessionCompat.Token getMediaToken() {
-            return mediaSession.getSessionToken();
-        }
+    @Override
+    public void onLoadChildren(@NonNull String parentId, @NonNull Result<List<MediaBrowserCompat.MediaItem>> result) {
 
-        @Override
-        public Track getTrack() {
-            return track;
+        if (!trackProvider.hasTrackInformation()) {
+            result.detach();
         }
 
-        @Override
-        public PlaybackStateCompat getState() {
-            return mediaSession.getController().getPlaybackState();
-        }
+        trackProvider.prepareMedia(success -> {
+            if (success && parentId.equals(UrgentTrackProvider.MEDIA_ID_ROOT)) {
 
-    };
+                // Set metadata
+                mediaSession.setMetadata(trackProvider.getTrack());
 
-    private void updateNotification() {
-        // Show the actual notification.
-        Notification mediaNotification = notificationBuilder.buildNotification(provider);
-
-        if (mediaManager != null && mediaManager.isPlaying()) {
-            startForeground(MUSIC_SERVICE_ID, mediaNotification);
-            isForeground = true;
-        } else {
-            if (isForeground) {
-                stopForeground(false);
-                isForeground = false;
+                result.sendResult(Collections.singletonList(new MediaBrowserCompat.MediaItem(
+                        trackProvider.getTrack().getDescription(),
+                        MediaBrowserCompat.MediaItem.FLAG_PLAYABLE
+                )));
+            } else {
+                result.sendResult(Collections.emptyList());
             }
-            NotificationManager manager = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
-            manager.notify(MUSIC_SERVICE_ID, mediaNotification);
-        }
+        });
     }
 
-    MediaManager getMediaManager() {
-        return mediaManager;
+    public void updateMetadata() {
+        mediaSession.setMetadata(trackProvider.getTrack());
     }
 }
\ No newline at end of file
diff --git a/app/src/main/java/be/ugent/zeus/hydra/service/urgent/MediaManager.java b/app/src/main/java/be/ugent/zeus/hydra/service/urgent/Playback.java
similarity index 69%
rename from app/src/main/java/be/ugent/zeus/hydra/service/urgent/MediaManager.java
rename to app/src/main/java/be/ugent/zeus/hydra/service/urgent/Playback.java
index 92a94084..9e9c3e76 100644
--- a/app/src/main/java/be/ugent/zeus/hydra/service/urgent/MediaManager.java
+++ b/app/src/main/java/be/ugent/zeus/hydra/service/urgent/Playback.java
@@ -3,8 +3,10 @@ package be.ugent.zeus.hydra.service.urgent;
 import android.content.Context;
 import android.media.AudioManager;
 import android.media.MediaPlayer;
+import android.net.wifi.WifiManager;
 import android.os.PowerManager;
 import android.support.annotation.Nullable;
+import android.support.v4.media.MediaMetadataCompat;
 
 import java8.util.stream.IntStreams;
 
@@ -14,18 +16,19 @@ import java.util.Arrays;
 import static be.ugent.zeus.hydra.service.urgent.MediaState.*;
 
 /**
- * Manages the {@link android.media.MediaPlayer}. The MediaManager supports playing a single stream, and does not
- * have support for multiple tracks.
+ * Manages actually playing the stream.
  *
  * This class will manage the CPU wakelock, but not the wifi wakelock.
  *
  * @author Niko Strijbol
  */
-public class MediaManager implements
+public class Playback implements
         MediaPlayer.OnCompletionListener,
         MediaPlayer.OnErrorListener,
         MediaPlayer.OnPreparedListener
 {
+    private static final String WIFI_LOCK_TAG = "UrgentMusic";
+
     @MediaState
     private int state = MediaState.IDLE;
 
@@ -33,32 +36,18 @@ public class MediaManager implements
 
     private final Context context;
     private final MediaStateListener listener;
+    private final WifiManager.WifiLock wifiLock;
 
-    private String url;
-    private MediaPlayer.OnPreparedListener onPrepared;
-
-    public MediaManager(Context context, @Nullable MediaStateListener listener1) {
-        this.context = context;
+    public Playback(Context context, @Nullable MediaStateListener listener1) {
+        Context applicationContext = context.getApplicationContext();
+        this.context = applicationContext;
         this.listener = listener1;
+        wifiLock = ((WifiManager) applicationContext.getSystemService(Context.WIFI_SERVICE))
+                .createWifiLock(WifiManager.WIFI_MODE_FULL, WIFI_LOCK_TAG);
     }
 
-    /**
-     * Prepare the media player for streaming. This is executed in a blocking manner.
-     *
-     * @param url The URL to play. If null, the existing URL will be used.
-     * @param onPrepared Custom callback to be run when the media player is done preparing. Calling this method will
-     *                   clear any existing listener.
-     */
-    public void prepare(@Nullable String url, @Nullable MediaPlayer.OnPreparedListener onPrepared) throws IOException {
-
-        if (url != null) {
-            this.url = url;
-        }
-        this.onPrepared = onPrepared;
 
-        if (this.url == null) {
-            throw new NullPointerException("The URL cannot be null!");
-        }
+    public void play(MediaMetadataCompat metadataCompat) {
 
         // If the state is error or end, we must construct a new media player.
         if (mediaPlayer == null || state == ERROR || state == END) {
@@ -78,13 +67,23 @@ public class MediaManager implements
 
         if (state == IDLE) {
             mediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC);
-            mediaPlayer.setDataSource(this.url);
+            try {
+                mediaPlayer.setDataSource(metadataCompat.getString(MediaMetadataCompat.METADATA_KEY_MEDIA_URI));
+            } catch (IOException e) {
+                setState(ERROR);
+                return;
+            }
             setState(INITIALIZED);
         }
 
+        if (isPlaying()) {
+            return;
+        }
+
         checkStates(INITIALIZED, STOPPED);
 
         mediaPlayer.prepareAsync();
+        wifiLock.acquire();
         setState(PREPARING);
     }
 
@@ -98,7 +97,7 @@ public class MediaManager implements
     }
 
     /**
-     * Start playback. You MUST have called {@link #prepare(String, android.media.MediaPlayer.OnPreparedListener)} before calling this method.
+     * Start playback.
      */
     public void play() {
         checkStates(PREPARED, STARTED, PAUSED, PLAYBACK_COMPLETED);
@@ -119,26 +118,22 @@ public class MediaManager implements
      * Stop playback.
      */
     public void stop() {
-        checkStates(PREPARED, STARTED, STOPPED, PAUSED, PLAYBACK_COMPLETED);
-        mediaPlayer.stop();
-        setState(STOPPED);
-    }
+        if (isStateOneOf(PREPARED, STARTED, STOPPED, PAUSED, PLAYBACK_COMPLETED)) {
+            mediaPlayer.stop();
+            setState(STOPPED);
+        }
 
-    /**
-     * Destroy playback.
-     */
-    public void destroy() {
+        if (mediaPlayer != null) {
+            mediaPlayer.reset();
+            mediaPlayer.release();
+            mediaPlayer = null;
+        }
         // This may be called from any state.
-        mediaPlayer.release();
         setState(END);
-    }
 
-    public void setUrl(String url) {
-        this.url = url;
-    }
-
-    public boolean hasUrl() {
-        return url != null;
+        if (wifiLock.isHeld()) {
+            wifiLock.release();
+        }
     }
 
     @Override
@@ -165,10 +160,7 @@ public class MediaManager implements
     @Override
     public void onPrepared(MediaPlayer mediaPlayer) {
         setState(PREPARED);
-        if (onPrepared != null) {
-            onPrepared.onPrepared(mediaPlayer);
-            onPrepared = null;
-        }
+        play();
     }
 
     /**
@@ -206,8 +198,4 @@ public class MediaManager implements
     public boolean isPlaying() {
         return state != ERROR && state != END && mediaPlayer.isPlaying();
     }
-
-    public boolean hasMediaPlayer() {
-        return mediaPlayer != null;
-    }
 }
\ No newline at end of file
diff --git a/app/src/main/java/be/ugent/zeus/hydra/service/urgent/SimpleSessionCallback.java b/app/src/main/java/be/ugent/zeus/hydra/service/urgent/SimpleSessionCallback.java
index 216f704e..cb2340f7 100644
--- a/app/src/main/java/be/ugent/zeus/hydra/service/urgent/SimpleSessionCallback.java
+++ b/app/src/main/java/be/ugent/zeus/hydra/service/urgent/SimpleSessionCallback.java
@@ -21,14 +21,16 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.media.AudioManager;
-import android.media.MediaPlayer;
+import android.os.Bundle;
+import android.os.Handler;
 import android.support.v4.media.session.MediaSessionCompat;
 import android.util.Log;
 
-import java.io.IOException;
+import org.threeten.bp.Instant;
+import org.threeten.bp.temporal.ChronoUnit;
 
 /**
- * A simple implementation of a session callback that maps the methods to the {@link MediaManager}.
+ * A simple implementation of a session callback that maps the methods to the {@link Playback}.
  *
  * This is the main controller for the state of the playback: all user-generated events are directed to this class.
  *
@@ -42,95 +44,93 @@ import java.io.IOException;
  *
  * @author Niko Strijbol.
  */
-public class SimpleSessionCallback extends MediaSessionCompat.Callback implements MediaPlayer.OnPreparedListener {
+public class SimpleSessionCallback extends MediaSessionCompat.Callback implements AudioManager.OnAudioFocusChangeListener {
 
     public static final String TAG = "SimpleSessionCallback";
 
     private final IntentFilter intentFilter = new IntentFilter(AudioManager.ACTION_AUDIO_BECOMING_NOISY);
     private final BecomingNoisyReceiver myNoisyAudioStreamReceiver = new BecomingNoisyReceiver();
 
-    private final MediaManager mediaManager;
+    private final Playback mediaManager;
     private final Context context;
+    private final UrgentTrackProvider provider;
     private boolean registered = false;
+    private final AudioManager audioManager;
+    private final Runnable metadataUpdater;
+    private Runnable nextUpdate;
 
-    public SimpleSessionCallback(Context context, MediaManager mediaManager) {
+    private final Handler handler = new Handler();
+
+    public SimpleSessionCallback(Context context, Playback mediaManager, UrgentTrackProvider provider, Runnable metadataUpdater) {
         this.mediaManager = mediaManager;
         this.context = context.getApplicationContext();
+        this.provider = provider;
+        this.audioManager = (AudioManager) this.context.getSystemService(Context.AUDIO_SERVICE);
+        this.metadataUpdater = metadataUpdater;
     }
 
     @Override
     public void onPause() {
-        if (mediaManager.isStateOneOf(
-                MediaState.STARTED,
-                MediaState.PAUSED,
-                MediaState.PLAYBACK_COMPLETED)) {
+        if (mediaManager.isPlaying()) {
             mediaManager.pause();
         }
     }
 
     @Override
-    public void onPlay() {
-
-        // Do nothing if we are already preparing.
-        if (mediaManager.getState() == MediaState.PREPARING) {
-            return;
+    public void onPlayFromMediaId(String mediaId, Bundle extras) {
+        if (provider.isUrgentId(mediaId)) {
+            onPlay();
         }
+    }
 
-        try {
-            // If not in a playable state, prepare the media manager.
-            if (!mediaManager.isStateOneOf(
-                    MediaState.PREPARED,
-                    MediaState.STARTED,
-                    MediaState.PAUSED,
-                    MediaState.PLAYBACK_COMPLETED)
-                    ) {
-                mediaManager.prepare(null, this);
-            } else {
-                mediaManager.play();
+    @Override
+    public void onPlay() {
+        // Do nothing if we are already preparing or there is nothing to play.
+        if (provider.hasTrackInformation()) {
+            // Try and get audio focus
+            int result = audioManager.requestAudioFocus(this, AudioManager.STREAM_MUSIC, AudioManager.AUDIOFOCUS_GAIN);
+
+            if (result == AudioManager.AUDIOFOCUS_REQUEST_GRANTED) {
+                mediaManager.play(provider.getTrack());
+                scheduleMetadataUpdate();
                 if (!registered) {
                     context.registerReceiver(myNoisyAudioStreamReceiver, intentFilter);
                     registered = true;
                 }
             }
-        } catch (IOException e) {
-            Log.e(TAG, "Error while trying to play.", e);
         }
     }
 
     @Override
     public void onStop() {
-        ensureStop();
+        cancelMetadataUpdate();
+        mediaManager.stop();
+        audioManager.abandonAudioFocus(this);
         if (registered) {
             context.unregisterReceiver(myNoisyAudioStreamReceiver);
             registered = false;
         }
     }
 
-    private void ensureStop() {
-        if (mediaManager.isStateOneOf(
-                MediaState.PREPARED,
-                MediaState.STARTED,
-                MediaState.STOPPED,
-                MediaState.PAUSED,
-                MediaState.PLAYBACK_COMPLETED)) {
-            mediaManager.stop();
-        }
-
-        mediaManager.destroy();
-    }
-
-    /**
-     * Called when a play command is received, but the player wasn't ready. At that point the prepare() method is
-     * called. When preparing finishes, this method is called.
-     *
-     * @param mediaPlayer The media player. Not intended for use.
-     */
     @Override
-    public void onPrepared(MediaPlayer mediaPlayer) {
-        mediaManager.play();
-        if (!registered) {
-            context.registerReceiver(myNoisyAudioStreamReceiver, intentFilter);
-            registered = true;
+    public void onAudioFocusChange(int focusChange) {
+        switch (focusChange) {
+            case AudioManager.AUDIOFOCUS_LOSS:
+                onStop();
+                break;
+            case AudioManager.AUDIOFOCUS_REQUEST_FAILED:
+                onStop();
+                break;
+            case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT:
+                onPause();
+                break;
+            case AudioManager.AUDIOFOCUS_LOSS_TRANSIENT_CAN_DUCK:
+                mediaManager.setVolume(0.5f, 0.5f);
+                break;
+            case AudioManager.AUDIOFOCUS_GAIN:
+                mediaManager.setVolume(1f, 1f);
+                onPlay();
+                break;
         }
     }
 
@@ -139,8 +139,41 @@ public class SimpleSessionCallback extends MediaSessionCompat.Callback implement
         public void onReceive(Context context, Intent intent) {
             if (AudioManager.ACTION_AUDIO_BECOMING_NOISY.equals(intent.getAction())) {
                 // Stop the playback
-                ensureStop();
+                onStop();
             }
         }
     }
+
+    private void scheduleMetadataUpdate() {
+        Log.d(TAG, "scheduleMetadataUpdate");
+        cancelMetadataUpdate();
+        nextUpdate = getMetadataUpdate();
+
+        Instant time = Instant.now().plus(1, ChronoUnit.HOURS)
+                .truncatedTo(ChronoUnit.HOURS)
+                .plus(2, ChronoUnit.MINUTES);
+
+        long millis = Instant.now().until(time, ChronoUnit.MILLIS);
+        Log.d(TAG, "scheduleMetadataUpdate: scheduling update in " + millis + " millis.");
+        handler.postDelayed(nextUpdate, millis);
+    }
+
+    private void cancelMetadataUpdate() {
+        if (nextUpdate != null) {
+            Log.d(TAG, "cancelMetadataUpdate");
+            handler.removeCallbacks(nextUpdate);
+            nextUpdate = null;
+        }
+    }
+
+    private Runnable getMetadataUpdate() {
+        return () -> provider.prepareMedia(aBoolean -> {
+            if (aBoolean && metadataUpdater != null) {
+                metadataUpdater.run();
+                if (mediaManager.isPlaying()) {
+                    scheduleMetadataUpdate();
+                }
+            }
+        });
+    }
 }
\ No newline at end of file
diff --git a/app/src/main/java/be/ugent/zeus/hydra/service/urgent/Track.java b/app/src/main/java/be/ugent/zeus/hydra/service/urgent/Track.java
deleted file mode 100644
index 5418d83c..00000000
--- a/app/src/main/java/be/ugent/zeus/hydra/service/urgent/Track.java
+++ /dev/null
@@ -1,61 +0,0 @@
-/*
- * Copyright 2016 Allan Pichardo
- * Copyright 2016 Niko Strijbol
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-package be.ugent.zeus.hydra.service.urgent;
-
-import android.graphics.Bitmap;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import java8.util.function.Consumer;
-
-/**
- * A track to play.
- *
- * @author Allan Pichardo
- * @author Niko Strijbol
- */
-public interface Track {
-
-    /**
-     * @return The id of this track.
-     */
-    int getId();
-
-    /**
-     * @return The name of the artist.
-     */
-    @Nullable
-    String getArtist();
-
-    /**
-     * @return The title of the track.
-     */
-    @NonNull
-    String getTitle();
-
-    /**
-     * Calling this method will instruct the track to provide an URL that can be played.
-     *
-     * @param consumer The receiver of the url.
-     */
-    void getUrl(Consumer<String> consumer);
-
-    /**
-     * @return The URL of the album track. If null, the defaults will be used.
-     */
-    @Nullable
-    Bitmap getAlbumArtwork();
-}
\ No newline at end of file
diff --git a/app/src/main/java/be/ugent/zeus/hydra/service/urgent/UrgentTrackProvider.java b/app/src/main/java/be/ugent/zeus/hydra/service/urgent/UrgentTrackProvider.java
new file mode 100644
index 00000000..e13f4b05
--- /dev/null
+++ b/app/src/main/java/be/ugent/zeus/hydra/service/urgent/UrgentTrackProvider.java
@@ -0,0 +1,88 @@
+package be.ugent.zeus.hydra.service.urgent;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.os.AsyncTask;
+import android.support.annotation.NonNull;
+import android.support.v4.media.MediaMetadataCompat;
+
+import be.ugent.zeus.hydra.R;
+import be.ugent.zeus.hydra.data.models.UrgentProgramme;
+import be.ugent.zeus.hydra.data.network.requests.UrgentInfoRequest;
+import be.ugent.zeus.hydra.data.network.requests.UrgentUrlRequest;
+import be.ugent.zeus.hydra.repository.requests.Result;
+import java8.util.function.Consumer;
+
+/**
+ * @author Niko Strijbol
+ */
+public class UrgentTrackProvider {
+
+    public static final String URGENT_ID = "be.ugent.zeus.hydra.urgent";
+
+    public static final String MEDIA_ID_ROOT = "__ROOT__";
+    public static final String MEDIA_ID_EMPTY_ROOT = "__EMPTY__";
+
+    private MediaMetadataCompat track;
+    private final Context context;
+
+    public UrgentTrackProvider(Context context) {
+        this.context = context.getApplicationContext();
+    }
+
+    public MediaMetadataCompat getTrack() {
+        return track;
+    }
+
+    public boolean isUrgentId(String id) {
+        return URGENT_ID.equals(id);
+    }
+
+    public void prepareMedia(@NonNull Consumer<Boolean> callback) {
+
+        if (track != null) {
+            callback.accept(true);
+            return;
+        }
+
+        new AsyncTask<Void, Void, Void>() {
+            @Override
+            protected Void doInBackground(Void... voids) {
+                loadData();
+                return null;
+            }
+
+            @Override
+            protected void onPostExecute(Void aVoid) {
+                super.onPostExecute(aVoid);
+                callback.accept(hasTrackInformation());
+            }
+        }.execute();
+    }
+
+    private synchronized void loadData() {
+        new UrgentUrlRequest().performRequest(null).ifPresent(s -> {
+            UrgentInfoRequest infoRequest = new UrgentInfoRequest();
+            Result<UrgentProgramme> programme = infoRequest.performRequest(null);
+            Bitmap albumArt = BitmapFactory.decodeResource(context.getResources(), R.drawable.logo_urgent);
+            MediaMetadataCompat.Builder builder = new MediaMetadataCompat.Builder()
+                    .putString(MediaMetadataCompat.METADATA_KEY_MEDIA_ID, URGENT_ID)
+                    .putString(MediaMetadataCompat.METADATA_KEY_MEDIA_URI, s)
+                    .putBitmap(MediaMetadataCompat.METADATA_KEY_ALBUM_ART, albumArt);
+
+            if (programme.hasData()) {
+                builder.putString(MediaMetadataCompat.METADATA_KEY_TITLE, programme.getData().getName())
+                        .putString(MediaMetadataCompat.METADATA_KEY_ARTIST, context.getString(R.string.urgent_fm));
+            } else {
+                builder.putString(MediaMetadataCompat.METADATA_KEY_TITLE, context.getString(R.string.urgent_fm));
+            }
+
+            track = builder.build();
+        });
+    }
+
+    public synchronized boolean hasTrackInformation() {
+        return track != null;
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/be/ugent/zeus/hydra/ui/main/UrgentFragment.java b/app/src/main/java/be/ugent/zeus/hydra/ui/main/UrgentFragment.java
index f970cf7f..472ea6a3 100644
--- a/app/src/main/java/be/ugent/zeus/hydra/ui/main/UrgentFragment.java
+++ b/app/src/main/java/be/ugent/zeus/hydra/ui/main/UrgentFragment.java
@@ -2,19 +2,15 @@ package be.ugent.zeus.hydra.ui.main;
 
 import android.annotation.SuppressLint;
 import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.ServiceConnection;
 import android.os.Bundle;
-import android.os.IBinder;
 import android.os.RemoteException;
 import android.support.annotation.DrawableRes;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.support.v4.app.Fragment;
+import android.support.v4.media.MediaBrowserCompat;
 import android.support.v4.media.MediaMetadataCompat;
 import android.support.v4.media.session.MediaControllerCompat;
-import android.support.v4.media.session.MediaSessionCompat;
 import android.support.v4.media.session.PlaybackStateCompat;
 import android.util.Log;
 import android.view.LayoutInflater;
@@ -26,9 +22,10 @@ import android.widget.TextView;
 import android.widget.Toast;
 
 import be.ugent.zeus.hydra.R;
-import be.ugent.zeus.hydra.service.urgent.MusicBinder;
 import be.ugent.zeus.hydra.service.urgent.MusicService;
 
+import java.util.List;
+
 /**
  * @author Niko Strijbol
  */
@@ -41,29 +38,24 @@ public class UrgentFragment extends Fragment {
     @DrawableRes
     private static final int PLAY_DRAWABLE = R.drawable.ic_play_arrow_24dp;
     @DrawableRes
-    private static final int PAUSE_DRAWABLE = R.drawable.ic_pause_24dp;
-
-    private boolean isBound = false;
-    private ServiceConnection serviceConnection = new MusicConnection();
-    private MusicService musicService;
+    private static final int PAUSE_DRAWABLE = R.drawable.ic_stop;
 
     private ImageButton playPauseButton;
-    private ImageButton stopButton;
     private View buttonWrapper;
     private TextView artistText;
     private TextView titleText;
     private ImageView albumImage;
-    private MediaControllerCompat mediaController;
-    private MediaSessionCompat.Token token;
     private View progressBar;
-    private TextView warning;
+
+    private MediaBrowserCompat mediaBrowser;
 
     // Receive callbacks from the MediaController. Here we update our state such as which queue
     // is being shown, the current title and description and the PlaybackState.
     private final MediaControllerCompat.Callback mediaControllerCallback = new MediaControllerCompat.Callback() {
         @Override
         public void onPlaybackStateChanged(@NonNull PlaybackStateCompat state) {
-            UrgentFragment.this.onPlaybackStateChanged(state);
+            Log.d(TAG, "onPlaybackStateChanged: state is " + state.toString());
+            configureButtons();
         }
 
         @Override
@@ -74,10 +66,60 @@ public class UrgentFragment extends Fragment {
             Log.d(TAG, "Received metadata state change to mediaId=" +
                     metadata.getDescription().getMediaId() +
                     " song=" + metadata.getDescription().getTitle());
-            UrgentFragment.this.onMetadataChanged(metadata);
+            readMetadata(metadata);
         }
     };
 
+    private MediaBrowserCompat.SubscriptionCallback subscriptionCallback =
+            new MediaBrowserCompat.SubscriptionCallback() {
+                @Override
+                public void onChildrenLoaded(@NonNull String parentId, @NonNull List<MediaBrowserCompat.MediaItem> children) {
+                    initMediaControls();
+                    configureButtons();
+                }
+
+                @Override
+                public void onError(@NonNull String id) {
+                    Toast.makeText(getActivity(), "Errror", Toast.LENGTH_LONG).show();
+                }
+            };
+
+    private MediaBrowserCompat.ConnectionCallback connectionCallback =
+            new MediaBrowserCompat.ConnectionCallback() {
+                @Override
+                public void onConnected() {
+                    Log.d(TAG, "onConnected: session token " + mediaBrowser.getSessionToken());
+
+                    mediaBrowser.subscribe(mediaBrowser.getRoot(), subscriptionCallback);
+                    try {
+                        MediaControllerCompat mediaController =
+                                new MediaControllerCompat(getActivity(), mediaBrowser.getSessionToken());
+                        MediaControllerCompat.setMediaController(getActivity(), mediaController);
+
+                        // Register a Callback to stay in sync
+                        mediaController.registerCallback(mediaControllerCallback);
+                    } catch (RemoteException e) {
+                        Log.e(TAG, "Failed to connect to MediaController", e);
+                    }
+                }
+
+                @Override
+                public void onConnectionFailed() {
+                    Log.e(TAG, "onConnectionFailed");
+                }
+
+                @Override
+                public void onConnectionSuspended() {
+                    Log.d(TAG, "onConnectionSuspended");
+                    MediaControllerCompat mediaController = MediaControllerCompat
+                            .getMediaController(getActivity());
+                    if (mediaController != null) {
+                        mediaController.unregisterCallback(mediaControllerCallback);
+                        MediaControllerCompat.setMediaController(getActivity(), null);
+                    }
+                }
+            };
+
     @Override
     public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
         return inflater.inflate(R.layout.fragment_urgent, container, false);
@@ -87,83 +129,34 @@ public class UrgentFragment extends Fragment {
     public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
         super.onViewCreated(view, savedInstanceState);
 
-        if (savedInstanceState != null) {
-            token = savedInstanceState.getParcelable(STATE_TOKEN);
-        }
-
         albumImage = view.findViewById(R.id.albumImage);
         artistText = view.findViewById(R.id.artistText);
         titleText = view.findViewById(R.id.titleText);
         progressBar = view.findViewById(R.id.progress_bar);
         playPauseButton = view.findViewById(R.id.playPauseButton);
-        stopButton = view.findViewById(R.id.stopButton);
         buttonWrapper = view.findViewById(R.id.button_wrap);
-        warning = view.findViewById(R.id.urgent_warning);
-
-        if (token != null) {
-            initialiseController();
-        }
-    }
-
-    private void initialiseController() {
-        try {
-            mediaController = new MediaControllerCompat(getContext(), token);
-            mediaController.registerCallback(mediaControllerCallback);
-        } catch (RemoteException e) {
-            Log.e(TAG, e.getMessage());
-        }
 
-        playPauseButton.setImageResource(PLAY_DRAWABLE);
-        readMetadata(mediaController.getMetadata());
-        configureButtons(mediaController.getPlaybackState());
-    }
-
-    @Override
-    public void onDetach() {
-        if (mediaController != null) {
-            mediaController.unregisterCallback(mediaControllerCallback);
-        }
-        super.onDetach();
+        mediaBrowser = new MediaBrowserCompat(getActivity(),
+                new ComponentName(getActivity(), MusicService.class), connectionCallback, null);
+        hideMediaControls();
     }
 
     @Override
     public void onStart() {
         super.onStart();
-
-        // Don't do anything if the service is bound.
-        if (!isBound) {
-            hideMediaControls();
-            bind();
-        }
-    }
-
-    private void bind() {
-        // Start the service, doesn't matter if it is already started.
-        Intent intent = new Intent(getActivity(), MusicService.class);
-        Log.d(TAG, "onStart: Starting service");
-        getContext().startService(intent);
-
-        // Request a bind with the service.
-        Log.d(TAG, "onStart: Requesting bind");
-        getActivity().bindService(intent, serviceConnection, Context.BIND_AUTO_CREATE);
+        mediaBrowser.connect();
     }
 
     @Override
     public void onStop() {
         super.onStop();
-        if (isBound) {
-            getActivity().unbindService(serviceConnection);
-            musicService = null;
-            isBound = false;
-        }
+        mediaBrowser.disconnect();
     }
 
     /**
      * Init the media control fragment.
      */
-    private void initMediaControls(MediaSessionCompat.Token token) {
-        this.token = token;
-        initialiseController();
+    private void initMediaControls() {
         buttonWrapper.setVisibility(View.VISIBLE);
         progressBar.setVisibility(View.GONE);
     }
@@ -173,12 +166,6 @@ public class UrgentFragment extends Fragment {
         progressBar.setVisibility(View.VISIBLE);
     }
 
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        outState.putParcelable(STATE_TOKEN, token);
-        super.onSaveInstanceState(outState);
-    }
-
     private void readMetadata(MediaMetadataCompat metadata) {
         if (metadata != null) {
             //These must be set at least.
@@ -194,66 +181,25 @@ public class UrgentFragment extends Fragment {
         }
     }
 
-    private void onMetadataChanged(MediaMetadataCompat metadata) {
-        Log.d(TAG, "onMetadataChanged ");
-
-        if (getActivity() == null) {
-            Log.w(TAG, "onMetadataChanged called when getActivity null, this should not happen if the callback was properly unregistered. Ignoring.");
-            return;
-        }
-
-        if (metadata == null) {
-            return;
-        }
-
-        readMetadata(metadata);
-    }
-
-    private void onPlaybackStateChanged(PlaybackStateCompat state) {
-        if (getActivity() == null) {
-            Log.w(TAG, "onPlaybackStateChanged called when getActivity null, this should not happen if the callback was properly unregistered. Ignoring.");
-            return;
-        }
-
-        // If we have restarted the service, attempt to bind again.
-        if (state.getState() == PlaybackStateCompat.STATE_PLAYING && !isBound) {
-            bind();
-        }
-
-        configureButtons(state);
-    }
+    @SuppressLint("SwitchIntDef")
+    private void configureButtons() {
 
-    private int getPlaybackState() {
-        return mediaController.getPlaybackState().getState();
-    }
+        MediaControllerCompat mediaController = MediaControllerCompat.getMediaController(getActivity());
+        PlaybackStateCompat state = mediaController.getPlaybackState();
 
-    @SuppressLint("SwitchIntDef")
-    private void configureButtons(PlaybackStateCompat state) {
-        if (state == null) {
-            return;
-        }
         boolean enablePlay = false;
-        boolean disableStop = false;
-        Log.d(TAG, "configureButtons: STATE PEOPLE!");
         switch (state.getState()) {
             case PlaybackStateCompat.STATE_PLAYING:
-                warning.setVisibility(View.GONE);
                 break;
             case PlaybackStateCompat.STATE_PAUSED:
-                warning.setVisibility(View.VISIBLE);
                 enablePlay = true;
-                disableStop = false;
                 break;
             case PlaybackStateCompat.STATE_ERROR:
                 Log.e(TAG, "error playbackstate: " + state.getErrorMessage());
                 Toast.makeText(getActivity(), state.getErrorMessage(), Toast.LENGTH_LONG).show();
                 break;
-            case PlaybackStateCompat.STATE_BUFFERING:
-                Log.d(TAG, "configureButtons: BUFFERING PEOPLE!");
             default:
-                warning.setVisibility(View.GONE);
                 enablePlay = true;
-                disableStop = true;
         }
 
         if (enablePlay) {
@@ -262,41 +208,12 @@ public class UrgentFragment extends Fragment {
             playPauseButton.setImageResource(PAUSE_DRAWABLE);
         }
 
-        if (disableStop) {
-            stopButton.setVisibility(View.GONE);
-        } else {
-            stopButton.setVisibility(View.VISIBLE);
-        }
-
         playPauseButton.setOnClickListener(v -> {
-            if (getPlaybackState() == PlaybackStateCompat.STATE_PLAYING) {
-                mediaController.getTransportControls().pause();
+            if (state.getState() == PlaybackStateCompat.STATE_PLAYING) {
+                mediaController.getTransportControls().stop();
             } else {
                 mediaController.getTransportControls().play();
             }
         });
-
-        stopButton.setOnClickListener(v -> mediaController.getTransportControls().stop());
-    }
-
-    /**
-     * The service connection. This is used to facilitate communication between the service and use.
-     */
-    private class MusicConnection implements ServiceConnection {
-
-        @Override
-        public void onServiceConnected(ComponentName name, IBinder service) {
-            MusicBinder binder = (MusicBinder) service;
-            musicService = binder.getService();
-            musicService.setTokenConsumer(UrgentFragment.this::initMediaControls);
-            isBound = true;
-            Log.d(TAG, "onServiceConnected: MusicService is bound.");
-        }
-
-        @Override
-        public void onServiceDisconnected(ComponentName name) {
-            isBound = false;
-            Log.d(TAG, "onServiceConnected: MusicService is unbound.");
-        }
     }
 }
\ No newline at end of file
