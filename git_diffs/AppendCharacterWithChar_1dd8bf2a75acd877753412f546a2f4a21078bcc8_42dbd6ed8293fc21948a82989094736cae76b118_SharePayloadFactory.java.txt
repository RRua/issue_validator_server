diff --git a/android-usbmanager/src/main/java/uk/co/alt236/androidusbmanager/model/AndroidUsbConfiguration.kt b/android-usbmanager/src/main/java/uk/co/alt236/androidusbmanager/model/AndroidUsbConfiguration.kt
index 629c00a..c4b2690 100644
--- a/android-usbmanager/src/main/java/uk/co/alt236/androidusbmanager/model/AndroidUsbConfiguration.kt
+++ b/android-usbmanager/src/main/java/uk/co/alt236/androidusbmanager/model/AndroidUsbConfiguration.kt
@@ -20,12 +20,13 @@ data class AndroidUsbConfiguration(
     val isSelfPowered get() = rawConfiguration.isSelfPowered
     val isRemoteWakeup get() = rawConfiguration.isRemoteWakeup
 
-    val interfaces: List<AndroidUsbInterface> by lazy {
-        val result = ArrayList<AndroidUsbInterface>(rawConfiguration.interfaceCount)
-        for (i in 0 until rawConfiguration.interfaceCount) {
-            result.add(AndroidUsbInterface(rawConfiguration.getInterface(i)))
+    val interfaces: List<AndroidUsbInterface>
+        get() {
+            val result = ArrayList<AndroidUsbInterface>(rawConfiguration.interfaceCount)
+            for (i in 0 until rawConfiguration.interfaceCount) {
+                result.add(AndroidUsbInterface(rawConfiguration.getInterface(i)))
+            }
+            return result
         }
-        result
-    }
 
 }
\ No newline at end of file
diff --git a/android-usbmanager/src/main/java/uk/co/alt236/androidusbmanager/model/AndroidUsbDevice.kt b/android-usbmanager/src/main/java/uk/co/alt236/androidusbmanager/model/AndroidUsbDevice.kt
index 6876493..ed47e72 100644
--- a/android-usbmanager/src/main/java/uk/co/alt236/androidusbmanager/model/AndroidUsbDevice.kt
+++ b/android-usbmanager/src/main/java/uk/co/alt236/androidusbmanager/model/AndroidUsbDevice.kt
@@ -46,13 +46,14 @@ class AndroidUsbDevice(
         mapConfigurations()
     }
 
-    val interfaces: List<AndroidUsbInterface> by lazy {
-        val result = ArrayList<AndroidUsbInterface>(rawDevice.interfaceCount)
-        for (i in 0 until rawDevice.interfaceCount) {
-            result.add(AndroidUsbInterface(rawDevice.getInterface(i)))
+    val interfaces: List<AndroidUsbInterface>
+        get() {
+            val result = ArrayList<AndroidUsbInterface>(rawDevice.interfaceCount)
+            for (i in 0 until rawDevice.interfaceCount) {
+                result.add(AndroidUsbInterface(rawDevice.getInterface(i)))
+            }
+            return result
         }
-        result
-    }
 
     private fun mapConfigurations(): ApiConditionalResult<List<AndroidUsbConfiguration>> {
         return if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
diff --git a/android-usbmanager/src/main/java/uk/co/alt236/androidusbmanager/model/AndroidUsbInterface.kt b/android-usbmanager/src/main/java/uk/co/alt236/androidusbmanager/model/AndroidUsbInterface.kt
index c81ae8e..988e4a7 100644
--- a/android-usbmanager/src/main/java/uk/co/alt236/androidusbmanager/model/AndroidUsbInterface.kt
+++ b/android-usbmanager/src/main/java/uk/co/alt236/androidusbmanager/model/AndroidUsbInterface.kt
@@ -29,13 +29,14 @@ data class AndroidUsbInterface(val rawInterface: UsbInterface) : Parcelable {
     val interfaceSubclass: Int get() = rawInterface.interfaceSubclass
     val interfaceProtocol: Int get() = rawInterface.interfaceProtocol
 
-    val endpoints: List<AndroidUsbEndpoint> by lazy {
-        val result = ArrayList<AndroidUsbEndpoint>(rawInterface.endpointCount)
+    val endpoints: List<AndroidUsbEndpoint>
+        get() {
+            val result = ArrayList<AndroidUsbEndpoint>(rawInterface.endpointCount)
 
-        for (i in 0 until rawInterface.endpointCount) {
-            result.add(AndroidUsbEndpoint(rawInterface.getEndpoint(i)))
-        }
+            for (i in 0 until rawInterface.endpointCount) {
+                result.add(AndroidUsbEndpoint(rawInterface.getEndpoint(i)))
+            }
 
-        result
-    }
+            return result
+        }
 }
\ No newline at end of file
diff --git a/android-usbmanager/src/main/java/uk/co/alt236/androidusbmanager/result/ApiConditionalResult.kt b/android-usbmanager/src/main/java/uk/co/alt236/androidusbmanager/result/ApiConditionalResult.kt
index a92ed50..57d138f 100644
--- a/android-usbmanager/src/main/java/uk/co/alt236/androidusbmanager/result/ApiConditionalResult.kt
+++ b/android-usbmanager/src/main/java/uk/co/alt236/androidusbmanager/result/ApiConditionalResult.kt
@@ -2,6 +2,11 @@ package uk.co.alt236.androidusbmanager.result
 
 sealed interface ApiConditionalResult<out T> {
     data class Success<T>(val result: T) : ApiConditionalResult<T>
-    data class Error<T>(val error: Exception) : ApiConditionalResult<Nothing>
+    data class Error(val error: Exception) : ApiConditionalResult<Nothing>
     data object ApiTooLow : ApiConditionalResult<Nothing>
+
+    fun getValueOrNull(): T? = when (this) {
+        is Success -> this.result
+        else -> null
+    }
 }
\ No newline at end of file
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/common/IntExt.kt b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/common/IntExt.kt
new file mode 100644
index 0000000..1d3ab9c
--- /dev/null
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/common/IntExt.kt
@@ -0,0 +1,13 @@
+package aws.apps.usbDeviceEnumerator.ui.common
+
+object IntExt {
+    fun Int.toHex() = "%x".format(this)
+    fun Int.formatVidPid(addHexPrefix: Boolean = false): String {
+        val hex = this.toHex().padStart(4, '0')
+        return if (addHexPrefix) {
+            "0x$hex"
+        } else {
+            hex
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/common/Navigation.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/common/Navigation.java
index 343d38e..15cede3 100644
--- a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/common/Navigation.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/common/Navigation.java
@@ -8,9 +8,9 @@ import androidx.core.app.ActivityCompat;
 import androidx.fragment.app.Fragment;
 import androidx.fragment.app.FragmentTransaction;
 import aws.apps.usbDeviceEnumerator.R;
+import aws.apps.usbDeviceEnumerator.ui.main.list.UiUsbDevice;
 import aws.apps.usbDeviceEnumerator.ui.usbinfo.UsbInfoActivity;
 import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.FragmentFactory;
-import uk.co.alt236.usbdeviceenumerator.sysbususb.SysBusUsbDevice;
 
 public class Navigation {
     private static final String TAG = Navigation.class.getSimpleName();
@@ -18,29 +18,19 @@ public class Navigation {
     private static final int DEFAULT_FRAGMENT_TRANSACTION = FragmentTransaction.TRANSIT_FRAGMENT_FADE;
 
     private final AppCompatActivity activity;
+    private final FragmentFactory fragmentFactory;
 
-    public Navigation(AppCompatActivity activity) {
+    public Navigation(AppCompatActivity activity, FragmentFactory fragmentFactory) {
         this.activity = activity;
+        this.fragmentFactory = fragmentFactory;
     }
 
-    public void showAndroidUsbDeviceInfo(String device) {
+    public void showUsbDeviceInfo(UiUsbDevice device) {
         if (isSmallScreen()) {
-            final Intent i = new Intent(activity.getApplicationContext(), UsbInfoActivity.class);
-            i.putExtra(UsbInfoActivity.EXTRA_DATA_ANDROID, device);
+            final Intent i = UsbInfoActivity.createIntent(activity, device);
             startActivity(i);
         } else {
-            final Fragment fragment = FragmentFactory.getFragment(device);
-            stackFragment(fragment);
-        }
-    }
-
-    public void showLinuxUsbDeviceInfo(SysBusUsbDevice device) {
-        if (isSmallScreen()) {
-            final Intent i = new Intent(activity.getApplicationContext(), UsbInfoActivity.class);
-            i.putExtra(UsbInfoActivity.EXTRA_DATA_LINUX, device);
-            startActivity(i);
-        } else {
-            final Fragment fragment = FragmentFactory.getFragment(device);
+            final Fragment fragment = fragmentFactory.getFragment(device);
             stackFragment(fragment);
         }
     }
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/common/ViewExt.kt b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/common/ViewExt.kt
new file mode 100644
index 0000000..abf478e
--- /dev/null
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/common/ViewExt.kt
@@ -0,0 +1,18 @@
+package aws.apps.usbDeviceEnumerator.ui.common
+
+import android.widget.TextView
+import androidx.core.view.isVisible
+
+object ViewExt {
+
+    fun TextView.setTextOrHide(text: CharSequence?) {
+        if (text.isNullOrEmpty()) {
+            this.text = ""
+            this.isVisible = false
+        } else {
+            this.text = text
+            this.isVisible = true
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/common/views/CheckableRelativeLayout.kt b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/common/views/CheckableRelativeLayout.kt
new file mode 100644
index 0000000..cf310bf
--- /dev/null
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/common/views/CheckableRelativeLayout.kt
@@ -0,0 +1,38 @@
+package aws.apps.usbDeviceEnumerator.ui.common.views
+
+import android.content.Context
+import android.util.AttributeSet
+import android.widget.Checkable
+import android.widget.CompoundButton
+import android.widget.RelativeLayout
+import androidx.core.view.children
+import androidx.core.view.isVisible
+
+class CheckableRelativeLayout(context: Context?, attrs: AttributeSet?) :
+    RelativeLayout(context, attrs), Checkable {
+    private var isChecked = false
+
+    override fun isChecked(): Boolean {
+        return isChecked
+    }
+
+    override fun setChecked(isChecked: Boolean) {
+        this.isChecked = isChecked
+        checkCheckbox(isChecked)
+    }
+
+    override fun toggle() {
+        this.isChecked = !this.isChecked
+        checkCheckbox(this.isChecked)
+    }
+
+    private fun checkCheckbox(isChecked: Boolean) {
+        val checkBox = findCheckbox()
+        checkBox.isVisible = isChecked // We only want a single check to be visible
+        checkBox.isChecked = isChecked
+    }
+
+    private fun findCheckbox(): CompoundButton {
+        return children.find { it is CompoundButton } as CompoundButton
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/common/views/ScrollViewNestedViewPager.kt b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/common/views/ScrollViewNestedViewPager.kt
new file mode 100644
index 0000000..e1a190b
--- /dev/null
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/common/views/ScrollViewNestedViewPager.kt
@@ -0,0 +1,28 @@
+package aws.apps.usbDeviceEnumerator.ui.common.views
+
+import android.content.Context
+import android.util.AttributeSet
+import androidx.viewpager.widget.ViewPager
+
+class ScrollViewNestedViewPager(cont: Context, attr: AttributeSet?) : ViewPager(cont, attr) {
+
+    override fun onMeasure(widthMeasureSpec: Int, heightMeasureSpec: Int) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec)
+
+        var height = 0
+        for (i in 0 until childCount) {
+            val child = getChildAt(i)
+            child.measure(
+                widthMeasureSpec,
+                MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED)
+            )
+            val h: Int = child.measuredHeight
+            if (h > height) height = h
+        }
+        val heightMeasure = MeasureSpec.makeMeasureSpec(
+            height,
+            MeasureSpec.EXACTLY
+        )
+        super.onMeasure(widthMeasureSpec, heightMeasure)
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/MainActivity.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/MainActivity.java
deleted file mode 100644
index 60f29cf..0000000
--- a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/MainActivity.java
+++ /dev/null
@@ -1,210 +0,0 @@
-/*
- Copyright 2011 Alexandros Schillings
- <p/>
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
- <p/>
- http://www.apache.org/licenses/LICENSE-2.0
- <p/>
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
- */
-package aws.apps.usbDeviceEnumerator.ui.main;
-
-import android.content.Intent;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.Menu;
-import android.view.MenuInflater;
-import android.view.MenuItem;
-import android.widget.ArrayAdapter;
-import android.widget.ListAdapter;
-import android.widget.ListView;
-import android.widget.TextView;
-
-import java.io.File;
-import java.util.Arrays;
-import java.util.Map;
-
-import javax.inject.Inject;
-
-import androidx.appcompat.app.AppCompatActivity;
-import androidx.core.app.ActivityCompat;
-import androidx.fragment.app.Fragment;
-import aws.apps.usbDeviceEnumerator.R;
-import aws.apps.usbDeviceEnumerator.data.DataProviderCompanyInfo;
-import aws.apps.usbDeviceEnumerator.data.DataProviderCompanyLogo;
-import aws.apps.usbDeviceEnumerator.data.DataProviderUsbInfo;
-import aws.apps.usbDeviceEnumerator.ui.common.DialogFactory;
-import aws.apps.usbDeviceEnumerator.ui.common.Navigation;
-import aws.apps.usbDeviceEnumerator.ui.dbupdate.DatabaseUpdater;
-import aws.apps.usbDeviceEnumerator.ui.debug.DebugActivity;
-import aws.apps.usbDeviceEnumerator.ui.main.tabs.TabController;
-import aws.apps.usbDeviceEnumerator.ui.main.tabs.TabViewHolder;
-import aws.apps.usbDeviceEnumerator.ui.progress.ProgressDialogControl;
-import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.FragmentFactory;
-import dagger.hilt.android.AndroidEntryPoint;
-import uk.co.alt236.androidusbmanager.AndroidUsbManager;
-import uk.co.alt236.androidusbmanager.model.AndroidUsbDevice;
-import uk.co.alt236.usbdeviceenumerator.sysbususb.SysBusUsbDevice;
-import uk.co.alt236.usbdeviceenumerator.sysbususb.SysBusUsbManager;
-
-@AndroidEntryPoint
-public class MainActivity extends AppCompatActivity {
-    final String TAG = this.getClass().getName();
-    @Inject
-    SysBusUsbManager mUsbManagerLinux;
-    @Inject
-    AndroidUsbManager mUsbManagerAndroid;
-    @Inject
-    DataProviderUsbInfo mDbUsb;
-    @Inject
-    DataProviderCompanyInfo mDbComp;
-    @Inject
-    DataProviderCompanyLogo mZipComp;
-
-    private Map<String, SysBusUsbDevice> mLinuxDeviceMap;
-
-    private Navigation mNavigation;
-
-    private TabController mTabController;
-
-    private void checkIfDbPresent() {
-        // Prompt user to DL db if it is missing.
-        if (!new File(mDbUsb.getDataFilePath()).exists()) {
-            DialogFactory.createOkDialog(this,
-                            R.string.alert_db_not_found_title,
-                            R.string.alert_db_not_found_instructions)
-                    .show();
-            Log.w(TAG, "^ Database not found: " + mDbUsb.getDataFilePath());
-        }
-    }
-
-    /**
-     * Called when the activity is first created.
-     */
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.act_main);
-        mTabController = new TabController(this);
-        mNavigation = new Navigation(this);
-
-        mTabController.setup(this::onTabChanged);
-
-        // Setup android list - tab1;
-        mTabController.getHolderForTag(TabController.TAB_ANDROID_INFO)
-                .getList().setOnItemClickListener((parent, view, position, id) -> {
-                    ((ListView) parent).setItemChecked(position, true);
-                    mNavigation.showAndroidUsbDeviceInfo(((TextView) view).getText().toString());
-                });
-
-
-        // Setup linux list - tab2
-        mTabController.getHolderForTag(TabController.TAB_LINUX_INFO)
-                .getList().setOnItemClickListener((parent, view, position, id) -> {
-                    ((ListView) parent).setItemChecked(position, true);
-                    mNavigation.showLinuxUsbDeviceInfo(mLinuxDeviceMap.get(((TextView) view).getText().toString()));
-                });
-
-
-        checkIfDbPresent();
-        refreshUsbDevices();
-    }
-
-    /**
-     * Creates the menu items
-     */
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        MenuInflater inflater = getMenuInflater();
-        inflater.inflate(R.menu.main_menu, menu);
-        return super.onCreateOptionsMenu(menu);
-    }
-
-    /**
-     * Handles item selections
-     */
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        final int itemId = item.getItemId();
-        if (itemId == R.id.menu_about) {
-            AboutDialogFactory.createAboutDialog(this).show();
-            return true;
-        } else if (itemId == R.id.menu_debug) {
-            final Intent intent = new Intent(this, DebugActivity.class);
-            ActivityCompat.startActivity(this, intent, null);
-            return true;
-        } else if (itemId == R.id.menu_update_db) {
-            final ProgressDialogControl control = new ProgressDialogControl(getSupportFragmentManager());
-            final DatabaseUpdater databaseUpdater = new DatabaseUpdater(control, mDbComp, mDbUsb, mZipComp);
-
-            databaseUpdater.start(this);
-            return true;
-        } else if (itemId == R.id.menu_refresh) {
-            refreshUsbDevices();
-            return true;
-        }
-
-        return false;
-    }
-
-    private void onTabChanged(String tabId, TabViewHolder tabViewHolder) {
-        if (mNavigation.isSmallScreen()) {
-            return;
-        }
-
-        final ListView listView = tabViewHolder.getList();
-        final int checkedItemPosition = listView.getCheckedItemPosition();
-        final Fragment fragment;
-
-        if (checkedItemPosition == ListView.INVALID_POSITION) {
-            fragment = null;
-        } else {
-            final String text = (String) listView.getItemAtPosition(checkedItemPosition);
-
-            switch (tabId) {
-                case TabController.TAB_ANDROID_INFO:
-                    fragment = FragmentFactory.getFragment(text);
-                    break;
-                case TabController.TAB_LINUX_INFO:
-                    fragment = FragmentFactory.getFragment(mLinuxDeviceMap.get(text));
-                    break;
-                default:
-                    fragment = null;
-                    break;
-            }
-        }
-
-        if (fragment == null) {
-            mNavigation.removeFragmentsFromContainer();
-        } else {
-            mNavigation.stackFragment(fragment);
-        }
-    }
-
-
-    private void refreshUsbDevices() {
-        Map<String, AndroidUsbDevice> mAndroidDeviceMap = mUsbManagerAndroid.getDeviceList();
-        mLinuxDeviceMap = mUsbManagerLinux.getUsbDevices();
-
-        updateList(mTabController.getHolderForTag(TabController.TAB_ANDROID_INFO), mAndroidDeviceMap);
-        updateList(mTabController.getHolderForTag(TabController.TAB_LINUX_INFO), mLinuxDeviceMap);
-    }
-
-    private void updateList(final TabViewHolder holder, final Map<String, ?> map) {
-        final String[] array = map.keySet().toArray(new String[0]);
-
-        Arrays.sort(array);
-
-        final ListAdapter adapter = new ArrayAdapter<>(getApplicationContext(), R.layout.list_item, array);
-        holder.getList().setAdapter(adapter);
-
-        final String count = getString(R.string.text_number_of_devices, array.length);
-        holder.getCount().setText(count);
-    }
-}
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/MainActivity.kt b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/MainActivity.kt
new file mode 100644
index 0000000..9418622
--- /dev/null
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/MainActivity.kt
@@ -0,0 +1,226 @@
+/*
+ Copyright 2011 Alexandros Schillings
+ <p/>
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+ <p/>
+ http://www.apache.org/licenses/LICENSE-2.0
+ <p/>
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ */
+package aws.apps.usbDeviceEnumerator.ui.main
+
+import android.content.Intent
+import android.os.Bundle
+import android.util.Log
+import android.view.Menu
+import android.view.MenuItem
+import android.view.View
+import android.widget.AdapterView
+import android.widget.AdapterView.OnItemClickListener
+import android.widget.ListAdapter
+import android.widget.ListView
+import androidx.appcompat.app.AppCompatActivity
+import androidx.core.app.ActivityCompat
+import aws.apps.usbDeviceEnumerator.R
+import aws.apps.usbDeviceEnumerator.data.DataProviderCompanyInfo
+import aws.apps.usbDeviceEnumerator.data.DataProviderCompanyLogo
+import aws.apps.usbDeviceEnumerator.data.DataProviderUsbInfo
+import aws.apps.usbDeviceEnumerator.ui.common.DialogFactory
+import aws.apps.usbDeviceEnumerator.ui.common.Navigation
+import aws.apps.usbDeviceEnumerator.ui.dbupdate.DatabaseUpdater
+import aws.apps.usbDeviceEnumerator.ui.debug.DebugActivity
+import aws.apps.usbDeviceEnumerator.ui.main.list.UiUsbDevice
+import aws.apps.usbDeviceEnumerator.ui.main.list.UsbDeviceListAdapter
+import aws.apps.usbDeviceEnumerator.ui.main.list.UsbDeviceListDataMapper
+import aws.apps.usbDeviceEnumerator.ui.main.tabs.TabController
+import aws.apps.usbDeviceEnumerator.ui.main.tabs.TabViewHolder
+import aws.apps.usbDeviceEnumerator.ui.progress.ProgressDialogControl
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.FragmentFactory
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.android.mapper.ApiConditionalResultMapper
+import dagger.hilt.android.AndroidEntryPoint
+import uk.co.alt236.androidusbmanager.AndroidUsbManager
+import uk.co.alt236.usbdeviceenumerator.sysbususb.SysBusUsbManager
+import java.io.File
+import javax.inject.Inject
+
+@AndroidEntryPoint
+class MainActivity : AppCompatActivity() {
+    private val TAG: String = javaClass.name
+
+    @Inject
+    lateinit var usbManagerLinux: SysBusUsbManager
+
+    @Inject
+    lateinit var usbManagerAndroid: AndroidUsbManager
+
+    @Inject
+    lateinit var dbUsb: DataProviderUsbInfo
+
+    @Inject
+    lateinit var dbComp: DataProviderCompanyInfo
+
+    @Inject
+    lateinit var zipComp: DataProviderCompanyLogo
+
+    @Inject
+    lateinit var usbListDataMapper: UsbDeviceListDataMapper
+
+    @Inject
+    lateinit var apiConditionalResultMapper: ApiConditionalResultMapper
+
+    @Inject
+    lateinit var infoFragmentFactory: FragmentFactory
+
+    private var navigation: Navigation? = null
+
+    private var tabController: TabController? = null
+
+    public override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        setContentView(R.layout.act_main)
+        tabController = createTabController()
+        navigation = Navigation(this, infoFragmentFactory)
+        checkIfDbPresent()
+        refreshUsbDevices()
+    }
+
+    override fun onCreateOptionsMenu(menu: Menu): Boolean {
+        val inflater = menuInflater
+        inflater.inflate(R.menu.main_menu, menu)
+        return super.onCreateOptionsMenu(menu)
+    }
+
+    override fun onOptionsItemSelected(item: MenuItem): Boolean {
+        val itemId = item.itemId
+        when (itemId) {
+            R.id.menu_about -> {
+                AboutDialogFactory.createAboutDialog(this).show()
+                return true
+            }
+
+            R.id.menu_debug -> {
+                val intent = Intent(this, DebugActivity::class.java)
+                ActivityCompat.startActivity(this, intent, null)
+                return true
+            }
+
+            R.id.menu_update_db -> {
+                val control = ProgressDialogControl(supportFragmentManager)
+                val databaseUpdater = DatabaseUpdater(control, dbComp, dbUsb, zipComp)
+
+                databaseUpdater.start(this)
+                return true
+            }
+
+            R.id.menu_refresh -> {
+                refreshUsbDevices()
+                return true
+            }
+
+            else -> return false
+        }
+    }
+
+    private fun createTabController(): TabController {
+        val tabController = TabController(this)
+
+        tabController.setup { tabId: String, tabViewHolder: TabViewHolder ->
+            this.onTabChanged(tabId, tabViewHolder)
+        }
+
+        // Setup android list - tab1;
+        tabController.getHolderForTag(TabController.TAB_ANDROID_INFO)
+            .list.onItemClickListener =
+            OnItemClickListener { parent: AdapterView<*>, _: View?, position: Int, _: Long ->
+                onListItemClicked((parent as ListView), position)
+            }
+
+        // Setup linux list - tab2
+        tabController.getHolderForTag(TabController.TAB_LINUX_INFO)
+            .list.onItemClickListener =
+            OnItemClickListener { parent: AdapterView<*>, _: View?, position: Int, _: Long ->
+                onListItemClicked((parent as ListView), position)
+            }
+
+        return tabController
+    }
+
+    private fun onListItemClicked(listView: ListView, position: Int) {
+        listView.setItemChecked(position, true)
+        navigation?.showUsbDeviceInfo(listView.getDeviceAtPosition(position))
+    }
+
+    private fun onTabChanged(
+        @Suppress("UNUSED_PARAMETER") tabId: String,
+        tabViewHolder: TabViewHolder
+    ) {
+        if (navigation!!.isSmallScreen) {
+            return
+        }
+
+        val listView = tabViewHolder.list
+        val checkedItemPosition = listView.checkedItemPosition
+
+        val fragment = if (checkedItemPosition == ListView.INVALID_POSITION) {
+            null
+        } else {
+            val device = listView.getDeviceAtPosition(checkedItemPosition)
+            infoFragmentFactory.getFragment(device)
+        }
+
+        if (fragment == null) {
+            navigation!!.removeFragmentsFromContainer()
+        } else {
+            navigation!!.stackFragment(fragment)
+        }
+    }
+
+
+    private fun refreshUsbDevices() {
+        updateList(
+            tabController!!.getHolderForTag(TabController.TAB_ANDROID_INFO),
+            usbManagerAndroid.getDeviceList()
+        )
+
+        updateList(
+            tabController!!.getHolderForTag(TabController.TAB_LINUX_INFO),
+            usbManagerLinux.usbDevices
+        )
+    }
+
+    private fun updateList(holder: TabViewHolder, map: Map<String, *>) {
+        val devices = usbListDataMapper.map(map)
+
+        val adapter: ListAdapter = UsbDeviceListAdapter(
+            applicationContext,
+            devices,
+            apiConditionalResultMapper
+        )
+
+        holder.list.adapter = adapter
+
+        val count = getString(R.string.text_number_of_devices, devices.size)
+        holder.count.text = count
+    }
+
+    private fun checkIfDbPresent() {
+        // Prompt user to DL db if it is missing.
+        if (!File(dbUsb.dataFilePath).exists()) {
+            DialogFactory.createOkDialog(
+                this,
+                R.string.alert_db_not_found_title,
+                R.string.alert_db_not_found_instructions
+            ).show()
+            Log.w(TAG, "^ Database not found: " + dbUsb.dataFilePath)
+        }
+    }
+
+    private fun ListView.getDeviceAtPosition(position: Int) =
+        this.getItemAtPosition(position) as UiUsbDevice
+}
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/list/UiUsbDevice.kt b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/list/UiUsbDevice.kt
new file mode 100644
index 0000000..7f000a8
--- /dev/null
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/list/UiUsbDevice.kt
@@ -0,0 +1,17 @@
+package aws.apps.usbDeviceEnumerator.ui.main.list
+
+import android.os.Parcelable
+import kotlinx.parcelize.Parcelize
+import uk.co.alt236.androidusbmanager.model.AndroidUsbDevice
+import uk.co.alt236.usbdeviceenumerator.sysbususb.SysBusUsbDevice
+
+@Parcelize
+sealed interface UiUsbDevice : Parcelable {
+    val key: String
+
+    @Parcelize
+    data class AndroidUsb(override val key: String, val device: AndroidUsbDevice) : UiUsbDevice
+
+    @Parcelize
+    data class SysUsb(override val key: String, val device: SysBusUsbDevice) : UiUsbDevice
+}
\ No newline at end of file
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/list/UsbDeviceListAdapter.kt b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/list/UsbDeviceListAdapter.kt
new file mode 100644
index 0000000..044456e
--- /dev/null
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/list/UsbDeviceListAdapter.kt
@@ -0,0 +1,95 @@
+package aws.apps.usbDeviceEnumerator.ui.main.list
+
+import android.content.Context
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import android.widget.BaseAdapter
+import android.widget.TextView
+import aws.apps.usbDeviceEnumerator.R
+import aws.apps.usbDeviceEnumerator.ui.common.IntExt.formatVidPid
+import aws.apps.usbDeviceEnumerator.ui.common.ViewExt.setTextOrHide
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.android.mapper.ApiConditionalResultMapper
+
+
+class UsbDeviceListAdapter(
+    private val context: Context,
+    private val data: List<UiUsbDevice>,
+    private val mapper: ApiConditionalResultMapper,
+) : BaseAdapter() {
+
+    private val inflater = LayoutInflater.from(context)
+
+    override fun getCount() = data.size
+
+    override fun getItem(position: Int) = data[position]
+
+    override fun getItemId(position: Int) = getItem(position).hashCode().toLong()
+
+    override fun getView(position: Int, convertView: View?, parent: ViewGroup): View {
+        val view = convertView ?: createView(parent)
+
+        with(view.tag as ViewHolder) {
+            val device = getItem(position)
+            val title = device.key
+            val line1: String
+            val line2: String
+
+            when (device) {
+                is UiUsbDevice.AndroidUsb -> {
+                    val vid = combineNullableStrings(
+                        device.device.vendorId.formatVidPid(),
+                        mapper.map(device.device.manufacturerName)
+                    )
+                    val pid = combineNullableStrings(
+                        device.device.productId.formatVidPid(),
+                        mapper.map(device.device.productName)
+                    )
+                    line1 = context.getString(R.string.device_list_vid_template, vid)
+                    line2 = context.getString(R.string.device_list_pid_template, pid)
+                }
+
+                is UiUsbDevice.SysUsb -> {
+                    line1 = context.getString(R.string.device_list_vid_template, device.device.vid)
+                    line2 = context.getString(R.string.device_list_pid_template, device.device.pid)
+                }
+            }
+
+            this.title.setTextOrHide(title)
+            this.line1.setTextOrHide(line1)
+            this.line2.setTextOrHide(line2)
+        }
+
+        return view
+    }
+
+    private fun createView(parent: ViewGroup): View {
+        val view = inflater.inflate(LAYOUT_ID, parent, false)
+
+        val holder = ViewHolder(
+            title = view.findViewById(R.id.title),
+            line1 = view.findViewById(R.id.line1),
+            line2 = view.findViewById(R.id.line2),
+        )
+
+        view.tag = holder
+
+        return view
+    }
+
+    private data class ViewHolder(
+        val title: TextView,
+        val line1: TextView,
+        val line2: TextView
+    )
+
+    private companion object {
+        val LAYOUT_ID = R.layout.list_item_usb_device
+    }
+
+    private fun combineNullableStrings(vararg args: String?): String {
+        val nonNull = args.filterNotNull().filter { it.isNotEmpty() }
+        return nonNull.joinToString(separator = " | ")
+    }
+
+}
\ No newline at end of file
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/list/UsbDeviceListDataMapper.kt b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/list/UsbDeviceListDataMapper.kt
new file mode 100644
index 0000000..13032a5
--- /dev/null
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/list/UsbDeviceListDataMapper.kt
@@ -0,0 +1,24 @@
+package aws.apps.usbDeviceEnumerator.ui.main.list
+
+import uk.co.alt236.androidusbmanager.model.AndroidUsbDevice
+import uk.co.alt236.usbdeviceenumerator.sysbususb.SysBusUsbDevice
+import javax.inject.Inject
+
+class UsbDeviceListDataMapper @Inject constructor() {
+
+    fun map(input: Map<String, *>): List<UiUsbDevice> {
+        val result = ArrayList<UiUsbDevice>()
+
+        for (pair in input) {
+            val listDevice = when (val device = pair.value) {
+                is AndroidUsbDevice -> UiUsbDevice.AndroidUsb(pair.key, device)
+                is SysBusUsbDevice -> UiUsbDevice.SysUsb(pair.key, device)
+                else -> throw IllegalArgumentException("Don't know how to map '${device}'")
+            }
+            result.add(listDevice)
+        }
+        result.sortBy { it.key }
+        return result
+    }
+
+}
\ No newline at end of file
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/tabs/TabViewHolder.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/tabs/TabViewHolder.java
deleted file mode 100644
index 65a2647..0000000
--- a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/tabs/TabViewHolder.java
+++ /dev/null
@@ -1,34 +0,0 @@
-package aws.apps.usbDeviceEnumerator.ui.main.tabs;
-
-import android.view.View;
-import android.widget.ListView;
-import android.widget.TextView;
-
-import aws.apps.usbDeviceEnumerator.R;
-
-public class TabViewHolder {
-
-    private final View rootView;
-    private final ListView list;
-    private final View empty;
-    private final TextView count;
-
-    public TabViewHolder(final View rootView) {
-        this.rootView = rootView;
-
-        list = rootView.findViewById(android.R.id.list);
-        empty = rootView.findViewById(android.R.id.empty);
-        count = rootView.findViewById(R.id.count);
-
-        list.setEmptyView(empty);
-        list.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
-    }
-
-    public ListView getList() {
-        return list;
-    }
-
-    public TextView getCount() {
-        return count;
-    }
-}
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/tabs/TabViewHolder.kt b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/tabs/TabViewHolder.kt
new file mode 100644
index 0000000..04a1576
--- /dev/null
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/main/tabs/TabViewHolder.kt
@@ -0,0 +1,18 @@
+package aws.apps.usbDeviceEnumerator.ui.main.tabs
+
+import android.view.View
+import android.widget.ListView
+import android.widget.TextView
+import aws.apps.usbDeviceEnumerator.R
+
+class TabViewHolder(rootView: View) {
+    private val empty: View = rootView.findViewById(android.R.id.empty)
+
+    val list: ListView = rootView.findViewById(android.R.id.list)
+    val count: TextView = rootView.findViewById(R.id.count)
+
+    init {
+        list.emptyView = empty
+        list.choiceMode = ListView.CHOICE_MODE_SINGLE
+    }
+}
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/UsbInfoActivity.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/UsbInfoActivity.java
index c113aa7..37ee74b 100644
--- a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/UsbInfoActivity.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/UsbInfoActivity.java
@@ -15,21 +15,27 @@
  */
 package aws.apps.usbDeviceEnumerator.ui.usbinfo;
 
+import android.content.Context;
+import android.content.Intent;
 import android.os.Bundle;
 import android.view.MenuItem;
 
+import javax.inject.Inject;
+
 import androidx.appcompat.app.AppCompatActivity;
 import androidx.fragment.app.Fragment;
 import androidx.fragment.app.FragmentTransaction;
 import aws.apps.usbDeviceEnumerator.R;
+import aws.apps.usbDeviceEnumerator.ui.main.list.UiUsbDevice;
 import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.FragmentFactory;
 import dagger.hilt.android.AndroidEntryPoint;
-import uk.co.alt236.usbdeviceenumerator.sysbususb.SysBusUsbDevice;
 
 @AndroidEntryPoint
 public class UsbInfoActivity extends AppCompatActivity {
-    public static final String EXTRA_DATA_ANDROID = UsbInfoActivity.class.getName() + ".EXTRA_DATA_ANDROID";
-    public static final String EXTRA_DATA_LINUX = UsbInfoActivity.class.getName() + ".EXTRA_DATA_LINUX";
+    public static final String EXTRA_DATA_DEVICE = UsbInfoActivity.class.getName() + ".EXTRA_DATA_DEVICE";
+
+    @Inject
+    protected FragmentFactory deviceInfoFragmentFactory;
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
@@ -42,24 +48,13 @@ public class UsbInfoActivity extends AppCompatActivity {
         if (b == null) {
             finish();
         } else {
-            final String androidKey = b.getString(EXTRA_DATA_ANDROID);
-            final SysBusUsbDevice linuxDevice = (SysBusUsbDevice) b.getSerializable(EXTRA_DATA_LINUX);
-
-            final Fragment fragment;
-
-            if (androidKey != null) {
-                fragment = FragmentFactory.getFragment(androidKey);
-            } else if (linuxDevice != null) {
-                fragment = FragmentFactory.getFragment(linuxDevice);
-            } else {
-                fragment = null;
-            }
-
-            if (fragment == null) {
+            final UiUsbDevice device = b.getParcelable(EXTRA_DATA_DEVICE);
+            if (device == null) {
                 finish();
-            } else {
-                showFragment(fragment);
             }
+
+            final Fragment fragment = deviceInfoFragmentFactory.getFragment(device);
+            showFragment(fragment);
         }
     }
 
@@ -78,4 +73,10 @@ public class UsbInfoActivity extends AppCompatActivity {
         ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN);
         ft.commit();
     }
+
+    public static Intent createIntent(Context context, UiUsbDevice device) {
+        final Intent intent = new Intent(context, UsbInfoActivity.class);
+        intent.putExtra(UsbInfoActivity.EXTRA_DATA_DEVICE, device);
+        return intent;
+    }
 }
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/FragmentFactory.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/FragmentFactory.java
deleted file mode 100644
index ff2e2c8..0000000
--- a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/FragmentFactory.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments;
-
-import androidx.fragment.app.Fragment;
-import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.android.InfoFragmentAndroid;
-import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.linux.InfoFragmentLinux;
-import uk.co.alt236.usbdeviceenumerator.sysbususb.SysBusUsbDevice;
-
-public final class FragmentFactory {
-
-    public static Fragment getFragment(String usbKey) {
-        return InfoFragmentAndroid.create(usbKey);
-    }
-
-    public static Fragment getFragment(SysBusUsbDevice usbDevice) {
-        return InfoFragmentLinux.create(usbDevice);
-    }
-}
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/FragmentFactory.kt b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/FragmentFactory.kt
new file mode 100644
index 0000000..25d3704
--- /dev/null
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/FragmentFactory.kt
@@ -0,0 +1,23 @@
+package aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments
+
+import androidx.fragment.app.Fragment
+import aws.apps.usbDeviceEnumerator.ui.main.list.UiUsbDevice
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.android.AndroidUsbInfoFragment
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.linux.LinuxUsbInfoFragment
+import javax.inject.Inject
+
+class FragmentFactory @Inject constructor() {
+
+    fun getFragment(device: UiUsbDevice): Fragment {
+        return when (device) {
+            is UiUsbDevice.AndroidUsb -> getFragment(device)
+            is UiUsbDevice.SysUsb -> getFragment(device)
+        }
+    }
+
+    fun getFragment(device: UiUsbDevice.AndroidUsb): Fragment =
+        AndroidUsbInfoFragment.create(device.device)
+
+    fun getFragment(device: UiUsbDevice.SysUsb) = LinuxUsbInfoFragment.create(device.device)
+
+}
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/AndroidUsbInfoDataBinder.kt b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/AndroidUsbInfoDataBinder.kt
new file mode 100644
index 0000000..b38b398
--- /dev/null
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/AndroidUsbInfoDataBinder.kt
@@ -0,0 +1,64 @@
+package aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.android
+
+import android.view.LayoutInflater
+import aws.apps.usbDeviceEnumerator.R
+import aws.apps.usbDeviceEnumerator.ui.common.IntExt.formatVidPid
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.android.mapper.ApiConditionalResultMapper
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.android.table.ConfigurationTableBuilder
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.android.table.InterfaceTableBuilder
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.base.ViewHolder
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.tabs.BottomTabSetup
+import uk.co.alt236.androidusbmanager.model.AndroidUsbDevice
+import uk.co.alt236.usbdeviceenumerator.UsbConstantResolver
+import javax.inject.Inject
+
+class AndroidUsbInfoDataBinder @Inject constructor(
+    private val apiConditionalResultMapper: ApiConditionalResultMapper
+) {
+    fun bind(
+        inflater: LayoutInflater,
+        viewHolder: ViewHolder,
+        device: AndroidUsbDevice
+    ) {
+        val vid = device.vendorId.formatVidPid()
+        val pid = device.productId.formatVidPid()
+        val deviceClass = UsbConstantResolver.resolveUsbClass(device.deviceClass)
+
+        viewHolder.logo.setImageResource(R.drawable.no_image)
+        viewHolder.vid.text = vid
+        viewHolder.pid.text = pid
+        viewHolder.devicePath.text = device.deviceName
+        viewHolder.deviceClass.text = deviceClass
+
+        populateBottomTabs(inflater, viewHolder, device)
+
+        val manufacturedNameResult = device.manufacturerName
+        val mappedManufacturerNameValue = apiConditionalResultMapper.map(manufacturedNameResult)
+
+        viewHolder.reportedVendor.text = mappedManufacturerNameValue
+        viewHolder.reportedProduct.text = apiConditionalResultMapper.map(device.productName)
+    }
+
+    private fun populateBottomTabs(
+        inflater: LayoutInflater,
+        viewHolder: ViewHolder,
+        device: AndroidUsbDevice
+    ) {
+        BottomTabSetup().setup(
+            viewHolder, listOf(
+                "Interfaces",
+                "Configurations"
+            )
+        )
+
+        val resources = viewHolder.rootView.resources
+        InterfaceTableBuilder(resources, inflater).build(
+            viewHolder.firstBottomTable,
+            device
+        )
+        ConfigurationTableBuilder(resources, inflater).build(
+            viewHolder.secondBottomTable,
+            device
+        )
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/AndroidUsbInfoFragment.kt b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/AndroidUsbInfoFragment.kt
new file mode 100644
index 0000000..6fb30ca
--- /dev/null
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/AndroidUsbInfoFragment.kt
@@ -0,0 +1,113 @@
+/*
+ Copyright 2011 Alexandros Schillings
+ <p/>
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+ <p/>
+ http://www.apache.org/licenses/LICENSE-2.0
+ <p/>
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ */
+package aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.android
+
+import android.os.Bundle
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import android.widget.TextView
+import androidx.fragment.app.Fragment
+import aws.apps.usbDeviceEnumerator.R
+import aws.apps.usbDeviceEnumerator.ui.common.IntExt.formatVidPid
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.base.BaseInfoFragment
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.base.ViewHolder
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.sharing.SharePayloadFactory
+import dagger.hilt.android.AndroidEntryPoint
+import uk.co.alt236.androidusbmanager.model.AndroidUsbDevice
+import javax.inject.Inject
+
+@AndroidEntryPoint
+class AndroidUsbInfoFragment : BaseInfoFragment() {
+    @Inject
+    lateinit var binder: AndroidUsbInfoDataBinder
+
+    @Inject
+    lateinit var sharePayloadFactory: SharePayloadFactory
+
+    private var viewHolder: ViewHolder? = null
+    private var device: AndroidUsbDevice? = null
+
+    private fun hasValidData() = device != null
+
+    override fun onCreateView(
+        inflater: LayoutInflater,
+        container: ViewGroup?,
+        saved: Bundle?
+    ): View {
+        device = requireArguments().getParcelable(EXTRA_DATA)
+
+        return if (hasValidData()) {
+            inflater.inflate(LAYOUT_ID, container, false)
+        } else {
+            inflater.inflate(R.layout.fragment_error, container, false)
+        }
+    }
+
+    override fun onViewCreated(view: View, bundle: Bundle?) {
+        super.onViewCreated(view, bundle)
+        viewHolder = ViewHolder(view)
+
+        if (hasValidData()) {
+            viewHolder = ViewHolder(view)
+            populateDataTable(LayoutInflater.from(requireContext()))
+        } else {
+            setErrorState()
+        }
+    }
+
+    override fun onDestroyView() {
+        viewHolder = null
+        super.onDestroyView()
+    }
+
+    private fun setErrorState() {
+        requireView()
+            .findViewById<TextView>(R.id.errorText)
+            .setText(R.string.error_loading_device_info_unknown)
+    }
+
+    private fun populateDataTable(inflater: LayoutInflater) {
+        binder.bind(inflater, viewHolder!!, device!!)
+        val manufacturerName = device!!.manufacturerName.getValueOrNull()
+        loadAsyncData(
+            viewHolder,
+            device!!.vendorId.formatVidPid(false),
+            device!!.productId.formatVidPid(false),
+            manufacturerName
+        )
+    }
+
+    override fun getSharePayload(): String {
+        return viewHolder?.let {
+            sharePayloadFactory.getSharePayload(it)
+        } ?: DEFAULT_STRING
+    }
+
+    companion object {
+        const val DEFAULT_STRING: String = "???"
+        private val EXTRA_DATA = AndroidUsbInfoFragment::class.java.name + ".BUNDLE_DATA"
+        private val LAYOUT_ID = R.layout.fragment_usb_info
+
+        fun create(device: AndroidUsbDevice): Fragment {
+            val fragment = AndroidUsbInfoFragment()
+            val bundle = Bundle()
+            bundle.putParcelable(EXTRA_DATA, device)
+            fragment.arguments = bundle
+            return fragment
+        }
+    }
+}
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/InfoFragmentAndroid.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/InfoFragmentAndroid.java
deleted file mode 100644
index 0126041..0000000
--- a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/InfoFragmentAndroid.java
+++ /dev/null
@@ -1,140 +0,0 @@
-/*
- Copyright 2011 Alexandros Schillings
- <p/>
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
- <p/>
- http://www.apache.org/licenses/LICENSE-2.0
- <p/>
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
- */
-package aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.android;
-
-import android.os.Bundle;
-import android.text.TextUtils;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.TextView;
-
-import javax.inject.Inject;
-
-import androidx.annotation.NonNull;
-import androidx.fragment.app.Fragment;
-import aws.apps.usbDeviceEnumerator.R;
-import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.android.mapper.ApiConditionalResultMapper;
-import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.android.table.BottomTableBuilder;
-import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.base.BaseInfoFragment;
-import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.base.ViewHolder;
-import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.sharing.SharePayloadFactory;
-import aws.apps.usbDeviceEnumerator.util.StringUtils;
-import dagger.hilt.android.AndroidEntryPoint;
-import uk.co.alt236.androidusbmanager.AndroidUsbManager;
-import uk.co.alt236.androidusbmanager.model.AndroidUsbDevice;
-import uk.co.alt236.androidusbmanager.result.ApiConditionalResult;
-import uk.co.alt236.usbdeviceenumerator.UsbConstantResolver;
-
-@AndroidEntryPoint
-public class InfoFragmentAndroid extends BaseInfoFragment {
-    public final static String DEFAULT_STRING = "???";
-    private final static String EXTRA_DATA = InfoFragmentAndroid.class.getName() + ".BUNDLE_DATA";
-    private static final SharePayloadFactory SHARE_PAYLOAD_FACTORY = new SharePayloadFactory();
-    private static final int LAYOUT_ID = R.layout.fragment_usb_info;
-
-    @Inject
-    protected AndroidUsbManager usbManager;
-    @Inject
-    protected ApiConditionalResultMapper resultMapper;
-
-    private String usbKey = DEFAULT_STRING;
-    private ViewHolder viewHolder;
-
-    private boolean validData;
-    private AndroidUsbDevice device;
-
-    @Override
-    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle saved) {
-        usbKey = requireArguments().getString(EXTRA_DATA, DEFAULT_STRING);
-        device = usbManager.getDeviceList().get(usbKey);
-
-        final View view;
-
-        if (usbKey == null || device == null) {
-            view = inflater.inflate(R.layout.fragment_error, container, false);
-            validData = false;
-        } else {
-            view = inflater.inflate(LAYOUT_ID, container, false);
-            validData = true;
-        }
-
-        return view;
-    }
-
-    @Override
-    public void onViewCreated(@NonNull View view, Bundle bundle) {
-        super.onViewCreated(view, bundle);
-        viewHolder = new ViewHolder(view);
-
-        usbKey = requireArguments().getString(EXTRA_DATA, DEFAULT_STRING);
-
-        if (validData) {
-            viewHolder = new ViewHolder(view);
-            populateDataTable(LayoutInflater.from(getContext()));
-        } else {
-            final TextView textView = view.findViewById(R.id.errorText);
-            if (usbKey == null) {
-                textView.setText(R.string.error_loading_device_info_unknown);
-            } else {
-                textView.setText(R.string.error_loading_device_info_device_disconnected);
-            }
-        }
-    }
-
-    private void populateDataTable(LayoutInflater inflater) {
-        final String vid = StringUtils.padLeft(Integer.toHexString(device.getVendorId()), '0', 4);
-        final String pid = StringUtils.padLeft(Integer.toHexString(device.getProductId()), '0', 4);
-        final String deviceClass = UsbConstantResolver.resolveUsbClass(device.getDeviceClass());
-
-        viewHolder.getLogo().setImageResource(R.drawable.no_image);
-        viewHolder.getVid().setText(vid);
-        viewHolder.getPid().setText(pid);
-        viewHolder.getDevicePath().setText(usbKey);
-        viewHolder.getDeviceClass().setText(deviceClass);
-
-        new BottomTableBuilder(getResources(), inflater).build(viewHolder.getBottomTable(), device);
-
-        final ApiConditionalResult<String> manufacturedNameResult = device.getManufacturerName();
-        final String mappedManufacturerNameValue = resultMapper.map(manufacturedNameResult);
-
-        viewHolder.getReportedVendor().setText(mappedManufacturerNameValue);
-        viewHolder.getReportedProduct().setText(resultMapper.map(device.getProductName()));
-
-        final String manufacturerName;
-        if (manufacturedNameResult instanceof ApiConditionalResult.Success<String>
-                && !TextUtils.isEmpty(mappedManufacturerNameValue)) {
-            manufacturerName = mappedManufacturerNameValue;
-        } else {
-            manufacturerName = null;
-        }
-
-        loadAsyncData(viewHolder, vid, pid, manufacturerName);
-    }
-
-    @Override
-    public String getSharePayload() {
-        return SHARE_PAYLOAD_FACTORY.getSharePayload(viewHolder);
-    }
-
-    public static Fragment create(final String usbKey) {
-        final Fragment fragment = new InfoFragmentAndroid();
-        final Bundle bundle = new Bundle();
-        bundle.putString(EXTRA_DATA, usbKey);
-        fragment.setArguments(bundle);
-        return fragment;
-    }
-}
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/mapper/ApiConditionalResultMapper.kt b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/mapper/ApiConditionalResultMapper.kt
index 5dab2a2..3f27e69 100644
--- a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/mapper/ApiConditionalResultMapper.kt
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/mapper/ApiConditionalResultMapper.kt
@@ -10,7 +10,7 @@ class ApiConditionalResultMapper @Inject constructor(private val resources: Reso
     fun map(input: ApiConditionalResult<*>): String {
         return when (input) {
             ApiConditionalResult.ApiTooLow -> resources.getString(R.string.error_device_api_too_low)
-            is ApiConditionalResult.Error<*> -> input.error::class.java.simpleName
+            is ApiConditionalResult.Error -> input.error::class.java.simpleName
             is ApiConditionalResult.Success -> input.result.toString()
         }
     }
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/table/ConfigurationTableBuilder.kt b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/table/ConfigurationTableBuilder.kt
index 280be86..e6bf289 100644
--- a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/table/ConfigurationTableBuilder.kt
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/table/ConfigurationTableBuilder.kt
@@ -2,14 +2,27 @@ package aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.android.table
 
 import android.annotation.SuppressLint
 import android.content.res.Resources
+import android.view.LayoutInflater
+import android.widget.TableLayout
 import aws.apps.usbDeviceEnumerator.R
 import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.base.TableWriter
 import uk.co.alt236.androidusbmanager.model.AndroidUsbConfiguration
+import uk.co.alt236.androidusbmanager.model.AndroidUsbDevice
 import uk.co.alt236.androidusbmanager.result.ApiConditionalResult
 
-internal class ConfigurationTableBuilder(resources: Resources) : TableBuilder(resources) {
+internal class ConfigurationTableBuilder(
+    resources: Resources,
+    private val inflater: LayoutInflater
+) : TableBuilder(resources) {
 
-    fun addConfigurations(
+
+    fun build(table: TableLayout, device: AndroidUsbDevice) {
+        val tableWriter = TableWriter(inflater, table)
+
+        addConfigurations(tableWriter, device.configurations)
+    }
+
+    private fun addConfigurations(
         tableWriter: TableWriter,
         result: ApiConditionalResult<List<AndroidUsbConfiguration>>
     ) {
@@ -20,7 +33,7 @@ internal class ConfigurationTableBuilder(resources: Resources) : TableBuilder(re
                 getString(R.string.error_device_api_too_low)
             )
 
-            is ApiConditionalResult.Error<*> -> tableWriter.addDataRow(
+            is ApiConditionalResult.Error -> tableWriter.addDataRow(
                 title,
                 result.error::class.java.simpleName
             )
@@ -39,6 +52,10 @@ internal class ConfigurationTableBuilder(resources: Resources) : TableBuilder(re
             tableWriter.addDataRow(title, "no configurations")
         } else {
             for ((index, config) in result.withIndex()) {
+                if (index > 0) {
+                    tableWriter.addEmptyRow()
+                }
+
                 tableWriter.addTitleRow(getString(R.string.configuration_) + index)
                 tableWriter.addDataRow(R.string.id_, config.id.toString())
                 tableWriter.addDataRow(R.string.name_, config.name)
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/table/BottomTableBuilder.kt b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/table/InterfaceTableBuilder.kt
similarity index 94%
rename from app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/table/BottomTableBuilder.kt
rename to app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/table/InterfaceTableBuilder.kt
index 291e75b..f862af1 100644
--- a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/table/BottomTableBuilder.kt
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/android/table/InterfaceTableBuilder.kt
@@ -12,28 +12,26 @@ import uk.co.alt236.androidusbmanager.model.AndroidUsbEndpoint
 import uk.co.alt236.androidusbmanager.model.AndroidUsbInterface
 import uk.co.alt236.usbdeviceenumerator.UsbConstantResolver
 
-class BottomTableBuilder(
+class InterfaceTableBuilder(
     resources: Resources,
     private val inflater: LayoutInflater
 ) : TableBuilder(resources) {
-    private val configurationTableBuilder = ConfigurationTableBuilder(resources)
-
     private val resultMapper = ApiConditionalResultMapper(resources)
 
     fun build(table: TableLayout, device: AndroidUsbDevice) {
         val tableWriter = TableWriter(inflater, table)
-
-        configurationTableBuilder.addConfigurations(tableWriter, device.configurations)
-        tableWriter.addEmptyRow()
         addInterfaces(tableWriter, device.interfaces)
     }
 
-
     private fun addInterfaces(tableWriter: TableWriter, iFaces: List<AndroidUsbInterface>) {
         for ((index, iFace) in iFaces.withIndex()) {
             val usbClass = UsbConstantResolver.resolveUsbClass((iFace.interfaceClass))
             val subClass = UsbConstantResolver.resolveUsbInterfaceSubClass(iFace.interfaceSubclass)
 
+            if (index > 0) {
+                tableWriter.addEmptyRow()
+            }
+
             tableWriter.addTitleRow(getString(R.string.interface_) + index)
             tableWriter.addDataRow(R.string.id_, iFace.id.toString())
             tableWriter.addDataRow(R.string.name_, resultMapper.map(iFace.name))
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/base/BaseInfoFragment.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/base/BaseInfoFragment.java
index f7f4295..5200d9a 100644
--- a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/base/BaseInfoFragment.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/base/BaseInfoFragment.java
@@ -59,7 +59,7 @@ public abstract class BaseInfoFragment extends Fragment {
         return super.onOptionsItemSelected(item);
     }
 
-    public abstract String getSharePayload();
+    protected abstract String getSharePayload();
 
 
     protected void loadAsyncData(final ViewHolder viewHolder,
@@ -69,8 +69,8 @@ public abstract class BaseInfoFragment extends Fragment {
 
         dataFetcher.fetchData(vid, pid, reportedVendorName, (vendorFromDb, productFromDb, bitmap) -> {
 
-            if (isAdded() && getActivity() != null && getView() != null) {
-                getActivity().runOnUiThread(() -> {
+            if (isFragmentValidAndHasView()) {
+                requireActivity().runOnUiThread(() -> {
                     viewHolder.getVendorFromDb().setText(vendorFromDb);
                     viewHolder.getProductFromDb().setText(productFromDb);
                     if (bitmap != null) {
@@ -83,4 +83,8 @@ public abstract class BaseInfoFragment extends Fragment {
             }
         });
     }
+
+    private boolean isFragmentValidAndHasView() {
+        return isAdded() && getActivity() != null && getView() != null;
+    }
 }
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/base/DataFetcher.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/base/DataFetcher.java
index 07e2f88..889c98b 100644
--- a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/base/DataFetcher.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/base/DataFetcher.java
@@ -38,12 +38,18 @@ public class DataFetcher {
 
                     if (!TextUtils.isEmpty(vendorFromDb)) {
                         searchFor = vendorFromDb;
-                    } else {
+                    } else if (!TextUtils.isEmpty(reportedVendorName)) {
                         searchFor = reportedVendorName;
+                    } else {
+                        searchFor = null;
                     }
 
-                    final String logo = dbComp.getLogoName(searchFor);
-                    bitmap = zipComp.getLogoBitmap(logo);
+                    if (searchFor == null) {
+                        bitmap = null;
+                    } else {
+                        final String logo = dbComp.getLogoName(searchFor);
+                        bitmap = zipComp.getLogoBitmap(logo);
+                    }
                 } else {
                     bitmap = null;
                 }
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/base/ViewHolder.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/base/ViewHolder.java
index c329e7e..8579236 100644
--- a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/base/ViewHolder.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/base/ViewHolder.java
@@ -6,12 +6,16 @@ import android.widget.ImageView;
 import android.widget.TableLayout;
 import android.widget.TextView;
 
+import com.google.android.material.tabs.TabLayout;
+
+import androidx.viewpager.widget.ViewPager;
 import aws.apps.usbDeviceEnumerator.R;
 
 public class ViewHolder {
     private final TableLayout tblUsbInfoHeader;
     private final TableLayout tblUsbInfoTop;
-    private final TableLayout tblUsbInfoBottom;
+    private final TableLayout firstBottomInfoTable;
+    private final TableLayout secondBottomInfoTable;
     private final TextView tvVID;
     private final TextView tvPID;
     private final TextView tvVendorReported;
@@ -22,10 +26,18 @@ public class ViewHolder {
     private final TextView tvDeviceClass;
     private final ImageButton logo;
 
+    private final TabLayout bottomInfoTabLayout;
+    private final ViewPager bottomTabViewPager;
+    private final View rootView;
+
     public ViewHolder(final View rootView) {
+        this.rootView = rootView;
         tblUsbInfoHeader = rootView.findViewById(R.id.tblUsbInfo_title);
         tblUsbInfoTop = rootView.findViewById(R.id.tblUsbInfo_top);
-        tblUsbInfoBottom = rootView.findViewById(R.id.tblUsbInfo_bottom);
+        firstBottomInfoTable = rootView.findViewById(R.id.first_bottom_table);
+        secondBottomInfoTable = rootView.findViewById(R.id.second_bottom_table);
+        bottomInfoTabLayout = rootView.findViewById(R.id.tabs);
+        bottomTabViewPager = rootView.findViewById(R.id.pager);
         tvVID = rootView.findViewById(R.id.tvVID);
         tvPID = rootView.findViewById(R.id.tvPID);
         tvProductDb = rootView.findViewById(R.id.tvProductDb);
@@ -37,6 +49,10 @@ public class ViewHolder {
         logo = rootView.findViewById(R.id.btnLogo);
     }
 
+    public View getRootView() {
+        return rootView;
+    }
+
     public ImageView getLogo() {
         return logo;
     }
@@ -49,8 +65,12 @@ public class ViewHolder {
         return tblUsbInfoTop;
     }
 
-    public TableLayout getBottomTable() {
-        return tblUsbInfoBottom;
+    public TableLayout getFirstBottomTable() {
+        return firstBottomInfoTable;
+    }
+
+    public TableLayout getSecondBottomTable() {
+        return secondBottomInfoTable;
     }
 
     public TextView getPid() {
@@ -84,4 +104,12 @@ public class ViewHolder {
     public TextView getReportedVendor() {
         return tvVendorReported;
     }
+
+    public TabLayout getBottomInfoTabLayout() {
+        return bottomInfoTabLayout;
+    }
+
+    public ViewPager getBottomTabViewPager() {
+        return bottomTabViewPager;
+    }
 }
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/linux/InfoFragmentLinux.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/linux/InfoFragmentLinux.java
deleted file mode 100644
index fb2dab9..0000000
--- a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/linux/InfoFragmentLinux.java
+++ /dev/null
@@ -1,112 +0,0 @@
-/*
- Copyright 2011 Alexandros Schillings
- <p/>
- Licensed under the Apache License, Version 2.0 (the "License");
- you may not use this file except in compliance with the License.
- You may obtain a copy of the License at
- <p/>
- http://www.apache.org/licenses/LICENSE-2.0
- <p/>
- Unless required by applicable law or agreed to in writing, software
- distributed under the License is distributed on an "AS IS" BASIS,
- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- See the License for the specific language governing permissions and
- limitations under the License.
- */
-package aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.linux;
-
-import android.os.Bundle;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.TextView;
-
-import androidx.annotation.NonNull;
-import androidx.fragment.app.Fragment;
-import aws.apps.usbDeviceEnumerator.R;
-import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.base.BaseInfoFragment;
-import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.base.TableWriter;
-import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.base.ViewHolder;
-import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.sharing.SharePayloadFactory;
-import aws.apps.usbDeviceEnumerator.util.StringUtils;
-import uk.co.alt236.usbdeviceenumerator.UsbConstantResolver;
-import uk.co.alt236.usbdeviceenumerator.sysbususb.SysBusUsbDevice;
-
-public class InfoFragmentLinux extends BaseInfoFragment {
-    public final static String DEFAULT_STRING = "???";
-    private final static String EXTRA_DATA = InfoFragmentLinux.class.getName() + ".BUNDLE_DATA";
-    private static final int LAYOUT_ID = R.layout.fragment_usb_info;
-    private static final SharePayloadFactory SHARE_PAYLOAD_FACTORY = new SharePayloadFactory();
-    private final String TAG = this.getClass().getName();
-    private SysBusUsbDevice device;
-    private boolean validData;
-
-    private ViewHolder viewHolder;
-
-    @Override
-    public View onCreateView(@NonNull LayoutInflater inflater, ViewGroup container, Bundle saved) {
-        device = (SysBusUsbDevice) getArguments().getSerializable(EXTRA_DATA);
-        final View view;
-
-        if (device == null) {
-            view = inflater.inflate(R.layout.fragment_error, container, false);
-            validData = false;
-        } else {
-            view = inflater.inflate(LAYOUT_ID, container, false);
-            validData = true;
-        }
-
-        return view;
-    }
-
-    @Override
-    public void onViewCreated(@NonNull View view, Bundle bundle) {
-        super.onViewCreated(view, bundle);
-
-        if (validData) {
-            viewHolder = new ViewHolder(view);
-            populateDataTable(LayoutInflater.from(getContext()));
-        } else {
-            final TextView textView = view.findViewById(R.id.errorText);
-            textView.setText(R.string.error_loading_device_info_unknown);
-        }
-    }
-
-    private void populateDataTable(LayoutInflater inflater) {
-        final String vid = StringUtils.padLeft(device.getVid(), '0', 4);
-        final String pid = StringUtils.padLeft(device.getPid(), '0', 4);
-        final String deviceClass = UsbConstantResolver.resolveUsbClass(device);
-
-        viewHolder.getLogo().setImageResource(R.drawable.no_image);
-
-        viewHolder.getVid().setText(vid);
-        viewHolder.getPid().setText(pid);
-        viewHolder.getDevicePath().setText(device.getDevicePath());
-        viewHolder.getDeviceClass().setText(deviceClass);
-
-        viewHolder.getReportedVendor().setText(device.getReportedVendorName());
-        viewHolder.getReportedProduct().setText(device.getReportedProductName());
-
-        final TableWriter tableWriter = new TableWriter(inflater, viewHolder.getBottomTable());
-        tableWriter.addDataRow(getString(R.string.usb_version_), device.getUsbVersion());
-        tableWriter.addDataRow(getString(R.string.speed_), device.getSpeed());
-        tableWriter.addDataRow(getString(R.string.protocol_), device.getDeviceProtocol());
-        tableWriter.addDataRow(getString(R.string.maximum_power_), device.getMaxPower());
-        tableWriter.addDataRow(getString(R.string.serial_number_), device.getSerialNumber());
-
-        loadAsyncData(viewHolder, vid, pid, device.getReportedVendorName());
-    }
-
-    @Override
-    public String getSharePayload() {
-        return SHARE_PAYLOAD_FACTORY.getSharePayload(viewHolder);
-    }
-
-    public static Fragment create(final SysBusUsbDevice usbDevice) {
-        final Fragment fragment = new InfoFragmentLinux();
-        final Bundle bundle = new Bundle();
-        bundle.putSerializable(EXTRA_DATA, usbDevice);
-        fragment.setArguments(bundle);
-        return fragment;
-    }
-}
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/linux/LinuxUsbInfoFragment.kt b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/linux/LinuxUsbInfoFragment.kt
new file mode 100644
index 0000000..2507128
--- /dev/null
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/linux/LinuxUsbInfoFragment.kt
@@ -0,0 +1,108 @@
+/*
+ Copyright 2011 Alexandros Schillings
+ <p/>
+ Licensed under the Apache License, Version 2.0 (the "License");
+ you may not use this file except in compliance with the License.
+ You may obtain a copy of the License at
+ <p/>
+ http://www.apache.org/licenses/LICENSE-2.0
+ <p/>
+ Unless required by applicable law or agreed to in writing, software
+ distributed under the License is distributed on an "AS IS" BASIS,
+ WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ See the License for the specific language governing permissions and
+ limitations under the License.
+ */
+package aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.linux
+
+import android.os.Bundle
+import android.view.LayoutInflater
+import android.view.View
+import android.view.ViewGroup
+import android.widget.TextView
+import androidx.fragment.app.Fragment
+import aws.apps.usbDeviceEnumerator.R
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.android.AndroidUsbInfoFragment.Companion.DEFAULT_STRING
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.base.BaseInfoFragment
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.base.ViewHolder
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.sharing.SharePayloadFactory
+import aws.apps.usbDeviceEnumerator.util.StringUtils
+import dagger.hilt.android.AndroidEntryPoint
+import uk.co.alt236.usbdeviceenumerator.sysbususb.SysBusUsbDevice
+import javax.inject.Inject
+
+@AndroidEntryPoint
+class LinuxUsbInfoFragment : BaseInfoFragment() {
+
+    @Inject
+    lateinit var sharePayloadFactory: SharePayloadFactory
+
+    @Inject
+    lateinit var dataBinder: SysUsbInfoDataBinder
+
+    private var device: SysBusUsbDevice? = null
+    private var viewHolder: ViewHolder? = null
+
+    private fun hasValidData() = device != null
+
+    override fun onCreateView(
+        inflater: LayoutInflater,
+        container: ViewGroup?,
+        saved: Bundle?
+    ): View? {
+        device = requireArguments().getSerializable(EXTRA_DATA) as SysBusUsbDevice?
+
+        return if (hasValidData()) {
+            inflater.inflate(LAYOUT_ID, container, false)
+        } else {
+            inflater.inflate(R.layout.fragment_error, container, false)
+        }
+    }
+
+    override fun onViewCreated(view: View, bundle: Bundle?) {
+        super.onViewCreated(view, bundle)
+
+        if (hasValidData()) {
+            viewHolder = ViewHolder(view)
+            populateDataTable(LayoutInflater.from(context))
+        } else {
+            val textView = view.findViewById<TextView>(R.id.errorText)
+            textView.setText(R.string.error_loading_device_info_unknown)
+        }
+    }
+
+    override fun onDestroyView() {
+        viewHolder = null
+        super.onDestroyView()
+    }
+
+    private fun populateDataTable(inflater: LayoutInflater) {
+        val device = device!!
+        val vid = StringUtils.padLeft(device.vid, '0', 4)
+        val pid = StringUtils.padLeft(device.pid, '0', 4)
+
+        dataBinder.bind(inflater, viewHolder!!, device)
+
+        loadAsyncData(viewHolder, vid, pid, device.reportedVendorName)
+    }
+
+
+    override fun getSharePayload(): String {
+        return viewHolder?.let {
+            sharePayloadFactory.getSharePayload(it)
+        } ?: DEFAULT_STRING
+    }
+
+    companion object {
+        private val EXTRA_DATA = LinuxUsbInfoFragment::class.java.name + ".BUNDLE_DATA"
+        private val LAYOUT_ID = R.layout.fragment_usb_info
+
+        fun create(usbDevice: SysBusUsbDevice): Fragment {
+            val fragment: Fragment = LinuxUsbInfoFragment()
+            val bundle = Bundle()
+            bundle.putSerializable(EXTRA_DATA, usbDevice)
+            fragment.arguments = bundle
+            return fragment
+        }
+    }
+}
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/linux/SysUsbInfoDataBinder.kt b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/linux/SysUsbInfoDataBinder.kt
new file mode 100644
index 0000000..a2a7f1c
--- /dev/null
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/linux/SysUsbInfoDataBinder.kt
@@ -0,0 +1,43 @@
+package aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.linux
+
+import android.content.res.Resources
+import android.view.LayoutInflater
+import aws.apps.usbDeviceEnumerator.R
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.base.TableWriter
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.base.ViewHolder
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.tabs.BottomTabSetup
+import aws.apps.usbDeviceEnumerator.util.StringUtils
+import uk.co.alt236.usbdeviceenumerator.UsbConstantResolver
+import uk.co.alt236.usbdeviceenumerator.sysbususb.SysBusUsbDevice
+import javax.inject.Inject
+
+class SysUsbInfoDataBinder @Inject constructor(private val res: Resources) {
+    fun bind(
+        inflater: LayoutInflater,
+        viewHolder: ViewHolder,
+        device: SysBusUsbDevice
+    ) {
+        val vid = StringUtils.padLeft(device.vid, '0', 4)
+        val pid = StringUtils.padLeft(device.pid, '0', 4)
+        val deviceClass = UsbConstantResolver.resolveUsbClass(device)
+
+        viewHolder.logo.setImageResource(R.drawable.no_image)
+
+        viewHolder.vid.text = vid
+        viewHolder.pid.text = pid
+        viewHolder.devicePath.text = device.devicePath
+        viewHolder.deviceClass.text = deviceClass
+
+        viewHolder.reportedVendor.text = device.reportedVendorName
+        viewHolder.reportedProduct.text = device.reportedProductName
+
+        BottomTabSetup().setup(viewHolder, listOf(res.getString(R.string.additional_info)))
+
+        val tableWriter = TableWriter(inflater, viewHolder.firstBottomTable)
+        tableWriter.addDataRow(res.getString(R.string.usb_version_), device.usbVersion)
+        tableWriter.addDataRow(res.getString(R.string.speed_), device.speed)
+        tableWriter.addDataRow(res.getString(R.string.protocol_), device.deviceProtocol)
+        tableWriter.addDataRow(res.getString(R.string.maximum_power_), device.maxPower)
+        tableWriter.addDataRow(res.getString(R.string.serial_number_), device.serialNumber)
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/sharing/SharePayloadFactory.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/sharing/SharePayloadFactory.java
deleted file mode 100644
index 0840aa9..0000000
--- a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/sharing/SharePayloadFactory.java
+++ /dev/null
@@ -1,55 +0,0 @@
-package aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.sharing;
-
-import android.util.Log;
-import android.view.View;
-import android.widget.TableLayout;
-import android.widget.TableRow;
-import android.widget.TextView;
-
-import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.base.ViewHolder;
-
-public class SharePayloadFactory {
-    private static final String TAG = ShareUtils.class.getSimpleName();
-
-    public String getSharePayload(final ViewHolder holder) {
-        final StringBuilder sb = new StringBuilder();
-        sb.append(tableToString(holder.getHeaderTable()));
-        sb.append(tableToString(holder.getTopTable()));
-        sb.append('\n');
-        sb.append(tableToString(holder.getBottomTable()));
-        return sb.toString();
-    }
-
-    private String tableToString(TableLayout table) {
-        final StringBuilder sb = new StringBuilder();
-
-        if (table == null) {
-            return sb.toString();
-        }
-
-        for (int i = 0; i <= table.getChildCount() - 1; i++) {
-            final TableRow row = (TableRow) table.getChildAt(i);
-
-            for (int j = 0; j <= row.getChildCount() - 1; j++) {
-                final View v = row.getChildAt(j);
-
-                try {
-                    if (v instanceof TextView) {
-                        final TextView textView = (TextView) v;
-                        sb.append(textView.getText());
-
-                        if (j == 0) {
-                            sb.append(" ");
-                        }
-                    }
-                } catch (Exception e) {
-                    sb.append(e.toString());
-                    Log.e(TAG, "^ ERROR: tableToString: " + e.toString());
-                }
-            }
-            sb.append("\n");
-        }
-
-        return sb.toString();
-    }
-}
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/sharing/SharePayloadFactory.kt b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/sharing/SharePayloadFactory.kt
new file mode 100644
index 0000000..35e3905
--- /dev/null
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/sharing/SharePayloadFactory.kt
@@ -0,0 +1,64 @@
+package aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.sharing
+
+import android.util.Log
+import android.widget.TableLayout
+import android.widget.TableRow
+import android.widget.TextView
+import aws.apps.usbDeviceEnumerator.BuildConfig
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.base.ViewHolder
+import javax.inject.Inject
+
+class SharePayloadFactory @Inject constructor() {
+
+    fun getSharePayload(holder: ViewHolder): String {
+        val sb = StringBuilder()
+        sb.append(tableToString(holder.headerTable))
+        sb.append(tableToString(holder.topTable))
+        sb.append('\n')
+        sb.append(tableToString(holder.firstBottomTable))
+        sb.append('\n')
+        sb.append(tableToString(holder.secondBottomTable))
+
+        if (BuildConfig.DEBUG) {
+            Log.d("SharePayloadFactory", "----\n$sb")
+        }
+
+        return sb.toString()
+    }
+
+    private fun tableToString(table: TableLayout?): String {
+        val sb = StringBuilder()
+
+        if (table == null) {
+            return sb.toString()
+        }
+
+        for (i in 0..<table.childCount) {
+            val row = table.getChildAt(i) as TableRow
+
+            for (j in 0..<row.childCount) {
+                val v = row.getChildAt(j)
+
+                try {
+                    if (v is TextView) {
+                        sb.append(v.text)
+
+                        if (j == 0) {
+                            sb.append(" ")
+                        }
+                    }
+                } catch (e: Exception) {
+                    sb.append(e.toString())
+                    Log.e(TAG, "^ ERROR: tableToString: $e")
+                }
+            }
+            sb.append('\n')
+        }
+
+        return sb.toString()
+    }
+
+    private companion object {
+        val TAG: String = ShareUtils::class.java.simpleName
+    }
+}
diff --git a/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/tabs/BottomTabSetup.kt b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/tabs/BottomTabSetup.kt
new file mode 100644
index 0000000..890ae60
--- /dev/null
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/usbinfo/fragments/tabs/BottomTabSetup.kt
@@ -0,0 +1,39 @@
+package aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.tabs
+
+import android.view.View
+import android.view.ViewGroup
+import androidx.viewpager.widget.PagerAdapter
+import aws.apps.usbDeviceEnumerator.R
+import aws.apps.usbDeviceEnumerator.ui.usbinfo.fragments.base.ViewHolder
+
+
+class BottomTabSetup {
+
+    fun setup(viewHolder: ViewHolder, titles: List<CharSequence>) {
+        val pager = viewHolder.bottomTabViewPager
+        pager.adapter = BottomTabsPagerAdapter(titles)
+        viewHolder.bottomInfoTabLayout.setupWithViewPager(pager, true)
+    }
+
+    private class BottomTabsPagerAdapter(private val titles: List<CharSequence>) : PagerAdapter() {
+
+        override fun instantiateItem(view: ViewGroup, position: Int): Any {
+            val resId = when (position) {
+                0 -> R.id.first_bottom_table
+                1 -> R.id.second_bottom_table
+                else -> throw IllegalStateException("There is no tab with index $position")
+            }
+            return view.findViewById(resId)
+        }
+
+        override fun getCount(): Int {
+            return titles.size
+        }
+
+        override fun getPageTitle(position: Int): CharSequence = titles[position]
+
+        override fun isViewFromObject(arg0: View, arg1: Any): Boolean {
+            return arg0 === (arg1 as View)
+        }
+    }
+}
\ No newline at end of file
