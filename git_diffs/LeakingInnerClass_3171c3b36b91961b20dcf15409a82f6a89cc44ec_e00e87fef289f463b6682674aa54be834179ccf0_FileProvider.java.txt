diff --git a/app/src/main/java/android/support/copied/FileProvider.java b/app/src/main/java/android/support/copied/FileProvider.java
deleted file mode 100644
index c85cacc..0000000
--- a/app/src/main/java/android/support/copied/FileProvider.java
+++ /dev/null
@@ -1,823 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.support.copied;
-
-import android.content.ContentProvider;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.content.pm.ProviderInfo;
-import android.content.res.XmlResourceParser;
-import android.database.Cursor;
-import android.database.MatrixCursor;
-import android.net.Uri;
-import android.os.Build;
-import android.os.Environment;
-import android.os.ParcelFileDescriptor;
-import android.provider.OpenableColumns;
-import android.text.TextUtils;
-import android.webkit.MimeTypeMap;
-
-import org.xmlpull.v1.XmlPullParserException;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
-
-import static org.xmlpull.v1.XmlPullParser.END_DOCUMENT;
-import static org.xmlpull.v1.XmlPullParser.START_TAG;
-
-/**
- * FileProvider is a special subclass of {@link ContentProvider} that facilitates secure sharing
- * of files associated with an app by creating a <code>content://</code> {@link Uri} for a file
- * instead of a <code>file:///</code> {@link Uri}.
- * <p>
- * A content URI allows you to grant read and write access using
- * temporary access permissions. When you create an {@link Intent} containing
- * a content URI, in order to send the content URI
- * to a client app, you can also call {@link Intent#setFlags(int) Intent.setFlags()} to add
- * permissions. These permissions are available to the client app for as long as the stack for
- * a receiving {@link android.app.Activity} is active. For an {@link Intent} going to a
- * {@link android.app.Service}, the permissions are available as long as the
- * {@link android.app.Service} is running.
- * <p>
- * In comparison, to control access to a <code>file:///</code> {@link Uri} you have to modify the
- * file system permissions of the underlying file. The permissions you provide become available to
- * <em>any</em> app, and remain in effect until you change them. This level of access is
- * fundamentally insecure.
- * <p>
- * The increased level of file access security offered by a content URI
- * makes FileProvider a key part of Android's security infrastructure.
- * <p>
- * This overview of FileProvider includes the following topics:
- * </p>
- * <ol>
- *     <li><a href="#ProviderDefinition">Defining a FileProvider</a></li>
- *     <li><a href="#SpecifyFiles">Specifying Available Files</a></li>
- *     <li><a href="#GetUri">Retrieving the Content URI for a File</li>
- *     <li><a href="#Permissions">Granting Temporary Permissions to a URI</a></li>
- *     <li><a href="#ServeUri">Serving a Content URI to Another App</a></li>
- * </ol>
- * <h3 id="ProviderDefinition">Defining a FileProvider</h3>
- * <p>
- * Since the default functionality of FileProvider includes content URI generation for files, you
- * don't need to define a subclass in code. Instead, you can include a FileProvider in your app
- * by specifying it entirely in XML. To specify the FileProvider component itself, add a
- * <code><a href="{@docRoot}guide/topics/manifest/provider-element.html">&lt;provider&gt;</a></code>
- * element to your app manifest. Set the <code>android:name</code> attribute to
- * <code>android.support.v4.content.FileProvider</code>. Set the <code>android:authorities</code>
- * attribute to a URI authority based on a domain you control; for example, if you control the
- * domain <code>mydomain.com</code> you should use the authority
- * <code>com.mydomain.fileprovider</code>. Set the <code>android:exported</code> attribute to
- * <code>false</code>; the FileProvider does not need to be public. Set the
- * <a href="{@docRoot}guide/topics/manifest/provider-element.html#gprmsn"
- * >android:grantUriPermissions</a> attribute to <code>true</code>, to allow you
- * to grant temporary access to files. For example:
- * <pre class="prettyprint">
- *&lt;manifest&gt;
- *    ...
- *    &lt;application&gt;
- *        ...
- *        &lt;provider
- *            android:name="android.support.v4.content.FileProvider"
- *            android:authorities="com.mydomain.fileprovider"
- *            android:exported="false"
- *            android:grantUriPermissions="true"&gt;
- *            ...
- *        &lt;/provider&gt;
- *        ...
- *    &lt;/application&gt;
- *&lt;/manifest&gt;</pre>
- * <p>
- * If you want to override any of the default behavior of FileProvider methods, extend
- * the FileProvider class and use the fully-qualified class name in the <code>android:name</code>
- * attribute of the <code>&lt;provider&gt;</code> element.
- * <h3 id="SpecifyFiles">Specifying Available Files</h3>
- * A FileProvider can only generate a content URI for files in directories that you specify
- * beforehand. To specify a directory, specify the its storage area and path in XML, using child
- * elements of the <code>&lt;paths&gt;</code> element.
- * For example, the following <code>paths</code> element tells FileProvider that you intend to
- * request content URIs for the <code>images/</code> subdirectory of your private file area.
- * <pre class="prettyprint">
- *&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt;
- *    &lt;files-path name="my_images" path="images/"/&gt;
- *    ...
- *&lt;/paths&gt;
- *</pre>
- * <p>
- * The <code>&lt;paths&gt;</code> element must contain one or more of the following child elements:
- * </p>
- * <dl>
- *     <dt>
- * <pre class="prettyprint">
- *&lt;files-path name="<i>name</i>" path="<i>path</i>" /&gt;
- *</pre>
- *     </dt>
- *     <dd>
- *     Represents files in the <code>files/</code> subdirectory of your app's internal storage
- *     area. This subdirectory is the same as the value returned by {@link Context#getFilesDir()
- *     Context.getFilesDir()}.
- *     </dd>
- *     <dt>
- * <pre>
- *&lt;cache-path name="<i>name</i>" path="<i>path</i>" /&gt;
- *</pre>
- *     <dt>
- *     <dd>
- *     Represents files in the cache subdirectory of your app's internal storage area. The root path
- *     of this subdirectory is the same as the value returned by {@link Context#getCacheDir()
- *     getCacheDir()}.
- *     </dd>
- *     <dt>
- * <pre class="prettyprint">
- *&lt;external-path name="<i>name</i>" path="<i>path</i>" /&gt;
- *</pre>
- *     </dt>
- *     <dd>
- *     Represents files in the root of the external storage area. The root path of this subdirectory
- *     is the same as the value returned by
- *     {@link Environment#getExternalStorageDirectory() Environment.getExternalStorageDirectory()}.
- *     </dd>
- *     <dt>
- * <pre class="prettyprint">
- *&lt;external-files-path name="<i>name</i>" path="<i>path</i>" /&gt;
- *</pre>
- *     </dt>
- *     <dd>
- *     Represents files in the root of your app's external storage area. The root path of this
- *     subdirectory is the same as the value returned by
- *     {@code Context#getExternalFilesDir(String) Context.getExternalFilesDir(null)}.
- *     </dd>
- *     <dt>
- * <pre class="prettyprint">
- *&lt;external-cache-path name="<i>name</i>" path="<i>path</i>" /&gt;
- *</pre>
- *     </dt>
- *     <dd>
- *     Represents files in the root of your app's external cache area. The root path of this
- *     subdirectory is the same as the value returned by
- *     {@link Context#getExternalCacheDir() Context.getExternalCacheDir()}.
- *     </dd>
- * </dl>
- * <p>
- *     These child elements all use the same attributes:
- * </p>
- * <dl>
- *     <dt>
- *         <code>name="<i>name</i>"</code>
- *     </dt>
- *     <dd>
- *         A URI path segment. To enforce security, this value hides the name of the subdirectory
- *         you're sharing. The subdirectory name for this value is contained in the
- *         <code>path</code> attribute.
- *     </dd>
- *     <dt>
- *         <code>path="<i>path</i>"</code>
- *     </dt>
- *     <dd>
- *         The subdirectory you're sharing. While the <code>name</code> attribute is a URI path
- *         segment, the <code>path</code> value is an actual subdirectory name. Notice that the
- *         value refers to a <b>subdirectory</b>, not an individual file or files. You can't
- *         share a single file by its file name, nor can you specify a subset of files using
- *         wildcards.
- *     </dd>
- * </dl>
- * <p>
- * You must specify a child element of <code>&lt;paths&gt;</code> for each directory that contains
- * files for which you want content URIs. For example, these XML elements specify two directories:
- * <pre class="prettyprint">
- *&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt;
- *    &lt;files-path name="my_images" path="images/"/&gt;
- *    &lt;files-path name="my_docs" path="docs/"/&gt;
- *&lt;/paths&gt;
- *</pre>
- * <p>
- * Put the <code>&lt;paths&gt;</code> element and its children in an XML file in your project.
- * For example, you can add them to a new file called <code>res/xml/file_paths.xml</code>.
- * To link this file to the FileProvider, add a
- * <a href="{@docRoot}guide/topics/manifest/meta-data-element.html">&lt;meta-data&gt;</a> element
- * as a child of the <code>&lt;provider&gt;</code> element that defines the FileProvider. Set the
- * <code>&lt;meta-data&gt;</code> element's "android:name" attribute to
- * <code>android.support.FILE_PROVIDER_PATHS</code>. Set the element's "android:resource" attribute
- * to <code>&#64;xml/file_paths</code> (notice that you don't specify the <code>.xml</code>
- * extension). For example:
- * <pre class="prettyprint">
- *&lt;provider
- *    android:name="android.support.v4.content.FileProvider"
- *    android:authorities="com.mydomain.fileprovider"
- *    android:exported="false"
- *    android:grantUriPermissions="true"&gt;
- *    &lt;meta-data
- *        android:name="android.support.FILE_PROVIDER_PATHS"
- *        android:resource="&#64;xml/file_paths" /&gt;
- *&lt;/provider&gt;
- *</pre>
- * <h3 id="GetUri">Generating the Content URI for a File</h3>
- * <p>
- * To share a file with another app using a content URI, your app has to generate the content URI.
- * To generate the content URI, create a new {@link File} for the file, then pass the {@link File}
- * to {@link #getUriForFile(Context, String, File) getUriForFile()}. You can send the content URI
- * returned by {@link #getUriForFile(Context, String, File) getUriForFile()} to another app in an
- * {@link Intent}. The client app that receives the content URI can open the file
- * and access its contents by calling
- * {@link android.content.ContentResolver#openFileDescriptor(Uri, String)
- * ContentResolver.openFileDescriptor} to get a {@link ParcelFileDescriptor}.
- * <p>
- * For example, suppose your app is offering files to other apps with a FileProvider that has the
- * authority <code>com.mydomain.fileprovider</code>. To get a content URI for the file
- * <code>default_image.jpg</code> in the <code>images/</code> subdirectory of your internal storage
- * add the following code:
- * <pre class="prettyprint">
- *File imagePath = new File(Context.getFilesDir(), "images");
- *File newFile = new File(imagePath, "default_image.jpg");
- *Uri contentUri = getUriForFile(getContext(), "com.mydomain.fileprovider", newFile);
- *</pre>
- * As a result of the previous snippet,
- * {@link #getUriForFile(Context, String, File) getUriForFile()} returns the content URI
- * <code>content://com.mydomain.fileprovider/my_images/default_image.jpg</code>.
- * <h3 id="Permissions">Granting Temporary Permissions to a URI</h3>
- * To grant an access permission to a content URI returned from
- * {@link #getUriForFile(Context, String, File) getUriForFile()}, do one of the following:
- * <ul>
- * <li>
- *     Call the method
- *     {@link Context#grantUriPermission(String, Uri, int)
- *     Context.grantUriPermission(package, Uri, mode_flags)} for the <code>content://</code>
- *     {@link Uri}, using the desired mode flags. This grants temporary access permission for the
- *     content URI to the specified package, according to the value of the
- *     the <code>mode_flags</code> parameter, which you can set to
- *     {@link Intent#FLAG_GRANT_READ_URI_PERMISSION}, {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION}
- *     or both. The permission remains in effect until you revoke it by calling
- *     {@link Context#revokeUriPermission(Uri, int) revokeUriPermission()} or until the device
- *     reboots.
- * </li>
- * <li>
- *     Put the content URI in an {@link Intent} by calling {@link Intent#setData(Uri) setData()}.
- * </li>
- * <li>
- *     Next, call the method {@link Intent#setFlags(int) Intent.setFlags()} with either
- *     {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} or
- *     {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION} or both.
- * </li>
- * <li>
- *     Finally, send the {@link Intent} to
- *     another app. Most often, you do this by calling
- *     {@link android.app.Activity#setResult(int, Intent) setResult()}.
- *     <p>
- *     Permissions granted in an {@link Intent} remain in effect while the stack of the receiving
- *     {@link android.app.Activity} is active. When the stack finishes, the permissions are
- *     automatically removed. Permissions granted to one {@link android.app.Activity} in a client
- *     app are automatically extended to other components of that app.
- *     </p>
- * </li>
- * </ul>
- * <h3 id="ServeUri">Serving a Content URI to Another App</h3>
- * <p>
- * There are a variety of ways to serve the content URI for a file to a client app. One common way
- * is for the client app to start your app by calling
- * {@link android.app.Activity#startActivityForResult(Intent, int, Bundle) startActivityResult()},
- * which sends an {@link Intent} to your app to start an {@link android.app.Activity} in your app.
- * In response, your app can immediately return a content URI to the client app or present a user
- * interface that allows the user to pick a file. In the latter case, once the user picks the file
- * your app can return its content URI. In both cases, your app returns the content URI in an
- * {@link Intent} sent via {@link android.app.Activity#setResult(int, Intent) setResult()}.
- * </p>
- * <p>
- *  You can also put the content URI in a {@link android.content.ClipData} object and then add the
- *  object to an {@link Intent} you send to a client app. To do this, call
- *  {@link Intent#setClipData(ClipData) Intent.setClipData()}. When you use this approach, you can
- *  add multiple {@link android.content.ClipData} objects to the {@link Intent}, each with its own
- *  content URI. When you call {@link Intent#setFlags(int) Intent.setFlags()} on the {@link Intent}
- *  to set temporary access permissions, the same permissions are applied to all of the content
- *  URIs.
- * </p>
- * <p class="note">
- *  <strong>Note:</strong> The {@link Intent#setClipData(ClipData) Intent.setClipData()} method is
- *  only available in platform version 16 (Android 4.1) and later. If you want to maintain
- *  compatibility with previous versions, you should send one content URI at a time in the
- *  {@link Intent}. Set the action to {@link Intent#ACTION_SEND} and put the URI in data by calling
- *  {@link Intent#setData setData()}.
- * </p>
- * <h3 id="">More Information</h3>
- * <p>
- *    To learn more about FileProvider, see the Android training class
- *    <a href="{@docRoot}training/secure-file-sharing/index.html">Sharing Files Securely with URIs</a>.
- * </p>
- */
-public class FileProvider extends ContentProvider {
-    private static final String[] COLUMNS = {
-            OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE };
-
-    private static final String
-            META_DATA_FILE_PROVIDER_PATHS = "android.support.FILE_PROVIDER_PATHS";
-
-    private static final String TAG_ROOT_PATH = "root-path";
-    private static final String TAG_FILES_PATH = "files-path";
-    private static final String TAG_CACHE_PATH = "cache-path";
-    private static final String TAG_EXTERNAL = "external-path";
-    private static final String TAG_EXTERNAL_FILES = "external-files-path";
-    private static final String TAG_EXTERNAL_CACHE = "external-cache-path";
-
-    private static final String ATTR_NAME = "name";
-    private static final String ATTR_PATH = "path";
-
-    private static final File DEVICE_ROOT = new File("/");
-
-    // @GuardedBy("sCache")
-    private static HashMap<String, PathStrategy> sCache = new HashMap<String, PathStrategy>();
-
-    private PathStrategy mStrategy;
-
-    /**
-     * The default FileProvider implementation does not need to be initialized. If you want to
-     * override this method, you must provide your own subclass of FileProvider.
-     */
-    @Override
-    public boolean onCreate() {
-        return true;
-    }
-
-    /**
-     * After the FileProvider is instantiated, this method is called to provide the system with
-     * information about the provider.
-     *
-     * @param context A {@link Context} for the current component.
-     * @param info A {@link ProviderInfo} for the new provider.
-     */
-    @Override
-    public void attachInfo(Context context, ProviderInfo info) {
-        super.attachInfo(context, info);
-
-        // Sanity check our security
-        if (info.exported) {
-            throw new SecurityException("Provider must not be exported");
-        }
-        if (!info.grantUriPermissions) {
-            throw new SecurityException("Provider must grant uri permissions");
-        }
-
-        mStrategy = getPathStrategy(context, info.authority);
-    }
-
-    /**
-     * Return a content URI for a given {@link File}. Specific temporary
-     * permissions for the content URI can be set with
-     * {@link Context#grantUriPermission(String, Uri, int)}, or added
-     * to an {@link Intent} by calling {@link Intent#setData(Uri) setData()} and then
-     * {@link Intent#setFlags(int) setFlags()}; in both cases, the applicable flags are
-     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} and
-     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION}. A FileProvider can only return a
-     * <code>content</code> {@link Uri} for file paths defined in their <code>&lt;paths&gt;</code>
-     * meta-data element. See the Class Overview for more information.
-     *
-     * @param context A {@link Context} for the current component.
-     * @param authority The authority of a {@link FileProvider} defined in a
-     *            {@code <provider>} element in your app's manifest.
-     * @param file A {@link File} pointing to the filename for which you want a
-     * <code>content</code> {@link Uri}.
-     * @return A content URI for the file.
-     * @throws IllegalArgumentException When the given {@link File} is outside
-     * the paths supported by the provider.
-     */
-    public static Uri getUriForFile(Context context, String authority, File file) {
-        final PathStrategy strategy = getPathStrategy(context, authority);
-        return strategy.getUriForFile(file);
-    }
-
-    /**
-     * Use a content URI returned by
-     * {@link #getUriForFile(Context, String, File) getUriForFile()} to get information about a file
-     * managed by the FileProvider.
-     * FileProvider reports the column names defined in {@link OpenableColumns}:
-     * <ul>
-     * <li>{@link OpenableColumns#DISPLAY_NAME}</li>
-     * <li>{@link OpenableColumns#SIZE}</li>
-     * </ul>
-     * For more information, see
-     * {@link ContentProvider#query(Uri, String[], String, String[], String)
-     * ContentProvider.query()}.
-     *
-     * @param uri A content URI returned by {@link #getUriForFile}.
-     * @param projection The list of columns to put into the {@link Cursor}. If null all columns are
-     * included.
-     * @param selection Selection criteria to apply. If null then all data that matches the content
-     * URI is returned.
-     * @param selectionArgs An array of {@link String}, containing arguments to bind to
-     * the <i>selection</i> parameter. The <i>query</i> method scans <i>selection</i> from left to
-     * right and iterates through <i>selectionArgs</i>, replacing the current "?" character in
-     * <i>selection</i> with the value at the current position in <i>selectionArgs</i>. The
-     * values are bound to <i>selection</i> as {@link String} values.
-     * @param sortOrder A {@link String} containing the column name(s) on which to sort
-     * the resulting {@link Cursor}.
-     * @return A {@link Cursor} containing the results of the query.
-     *
-     */
-    @Override
-    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
-                        String sortOrder) {
-        // ContentProvider has already checked granted permissions
-        final File file = mStrategy.getFileForUri(uri);
-
-        if (projection == null) {
-            projection = COLUMNS;
-        }
-
-        String[] cols = new String[projection.length];
-        Object[] values = new Object[projection.length];
-        int i = 0;
-        for (String col : projection) {
-            if (OpenableColumns.DISPLAY_NAME.equals(col)) {
-                cols[i] = OpenableColumns.DISPLAY_NAME;
-                values[i++] = file.getName();
-            } else if (OpenableColumns.SIZE.equals(col)) {
-                cols[i] = OpenableColumns.SIZE;
-                values[i++] = file.length();
-            }
-        }
-
-        cols = copyOf(cols, i);
-        values = copyOf(values, i);
-
-        final MatrixCursor cursor = new MatrixCursor(cols, 1);
-        cursor.addRow(values);
-        return cursor;
-    }
-
-    /**
-     * Returns the MIME type of a content URI returned by
-     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
-     *
-     * @param uri A content URI returned by
-     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
-     * @return If the associated file has an extension, the MIME type associated with that
-     * extension; otherwise <code>application/octet-stream</code>.
-     */
-    @Override
-    public String getType(Uri uri) {
-        // ContentProvider has already checked granted permissions
-        final File file = mStrategy.getFileForUri(uri);
-
-        final int lastDot = file.getName().lastIndexOf('.');
-        if (lastDot >= 0) {
-            final String extension = file.getName().substring(lastDot + 1);
-            final String mime = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);
-            if (mime != null) {
-                return mime;
-            }
-        }
-
-        return "application/octet-stream";
-    }
-
-    /**
-     * By default, this method throws an {@link UnsupportedOperationException}. You must
-     * subclass FileProvider if you want to provide different functionality.
-     */
-    @Override
-    public Uri insert(Uri uri, ContentValues values) {
-        throw new UnsupportedOperationException("No external inserts");
-    }
-
-    /**
-     * By default, this method throws an {@link UnsupportedOperationException}. You must
-     * subclass FileProvider if you want to provide different functionality.
-     */
-    @Override
-    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
-        throw new UnsupportedOperationException("No external updates");
-    }
-
-    /**
-     * Deletes the file associated with the specified content URI, as
-     * returned by {@link #getUriForFile(Context, String, File) getUriForFile()}. Notice that this
-     * method does <b>not</b> throw an {@link IOException}; you must check its return value.
-     *
-     * @param uri A content URI for a file, as returned by
-     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
-     * @param selection Ignored. Set to {@code null}.
-     * @param selectionArgs Ignored. Set to {@code null}.
-     * @return 1 if the delete succeeds; otherwise, 0.
-     */
-    @Override
-    public int delete(Uri uri, String selection, String[] selectionArgs) {
-        // ContentProvider has already checked granted permissions
-        final File file = mStrategy.getFileForUri(uri);
-        return file.delete() ? 1 : 0;
-    }
-
-    /**
-     * By default, FileProvider automatically returns the
-     * {@link ParcelFileDescriptor} for a file associated with a <code>content://</code>
-     * {@link Uri}. To get the {@link ParcelFileDescriptor}, call
-     * {@link android.content.ContentResolver#openFileDescriptor(Uri, String)
-     * ContentResolver.openFileDescriptor}.
-     *
-     * To override this method, you must provide your own subclass of FileProvider.
-     *
-     * @param uri A content URI associated with a file, as returned by
-     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
-     * @param mode Access mode for the file. May be "r" for read-only access, "rw" for read and
-     * write access, or "rwt" for read and write access that truncates any existing file.
-     * @return A new {@link ParcelFileDescriptor} with which you can access the file.
-     */
-    @Override
-    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
-        // ContentProvider has already checked granted permissions
-        final File file = mStrategy.getFileForUri(uri);
-        final int fileMode = modeToMode(mode);
-        return ParcelFileDescriptor.open(file, fileMode);
-    }
-
-    /**
-     * Return {@link PathStrategy} for given authority, either by parsing or
-     * returning from cache.
-     */
-    private static PathStrategy getPathStrategy(Context context, String authority) {
-        PathStrategy strat;
-        synchronized (sCache) {
-            strat = sCache.get(authority);
-            if (strat == null) {
-                try {
-                    strat = parsePathStrategy(context, authority);
-                } catch (IOException e) {
-                    throw new IllegalArgumentException(
-                            "Failed to parse " + META_DATA_FILE_PROVIDER_PATHS + " meta-data", e);
-                } catch (XmlPullParserException e) {
-                    throw new IllegalArgumentException(
-                            "Failed to parse " + META_DATA_FILE_PROVIDER_PATHS + " meta-data", e);
-                }
-                sCache.put(authority, strat);
-            }
-        }
-        return strat;
-    }
-
-    /**
-     * Parse and return {@link PathStrategy} for given authority as defined in
-     * {@link #META_DATA_FILE_PROVIDER_PATHS} {@code <meta-data>}.
-     *
-     * @see #getPathStrategy(Context, String)
-     */
-    private static PathStrategy parsePathStrategy(Context context, String authority)
-            throws IOException, XmlPullParserException {
-        final SimplePathStrategy strat = new SimplePathStrategy(authority);
-
-        final ProviderInfo info = context.getPackageManager()
-                .resolveContentProvider(authority, PackageManager.GET_META_DATA);
-        final XmlResourceParser in = info.loadXmlMetaData(
-                context.getPackageManager(), META_DATA_FILE_PROVIDER_PATHS);
-        if (in == null) {
-            throw new IllegalArgumentException(
-                    "Missing " + META_DATA_FILE_PROVIDER_PATHS + " meta-data");
-        }
-
-        int type;
-        while ((type = in.next()) != END_DOCUMENT) {
-            if (type == START_TAG) {
-                final String tag = in.getName();
-
-                final String name = in.getAttributeValue(null, ATTR_NAME);
-                String path = in.getAttributeValue(null, ATTR_PATH);
-
-                File target = null;
-                if (TAG_ROOT_PATH.equals(tag)) {
-                    target = DEVICE_ROOT;
-                } else if (TAG_FILES_PATH.equals(tag)) {
-                    target = context.getFilesDir();
-                } else if (TAG_CACHE_PATH.equals(tag)) {
-                    target = context.getCacheDir();
-                } else if (TAG_EXTERNAL.equals(tag)) {
-                    target = Environment.getExternalStorageDirectory();
-                } else if (TAG_EXTERNAL_FILES.equals(tag)) {
-                    File[] externalFilesDirs = getExternalFilesDirs(context, null);
-                    if (externalFilesDirs.length > 0) {
-                        target = externalFilesDirs[0];
-                    }
-                } else if (TAG_EXTERNAL_CACHE.equals(tag)) {
-                    File[] externalCacheDirs = getExternalCacheDirs(context);
-                    if (externalCacheDirs.length > 0) {
-                        target = externalCacheDirs[0];
-                    }
-                }
-
-                if (target != null) {
-                    strat.addRoot(name, buildPath(target, path));
-                }
-            }
-        }
-
-        return strat;
-    }
-
-    public static File[] getExternalCacheDirs(Context context) {
-        if (Build.VERSION.SDK_INT >= 19) {
-            return context.getExternalCacheDirs();
-        } else {
-            return new File[] { context.getExternalCacheDir() };
-        }
-    }
-
-    public static File[] getExternalFilesDirs(Context context, String type) {
-        if (Build.VERSION.SDK_INT >= 19) {
-            return context.getExternalFilesDirs(type);
-        } else {
-            return new File[] { context.getExternalFilesDir(type) };
-        }
-    }
-
-    /**
-     * Strategy for mapping between {@link File} and {@link Uri}.
-     * <p>
-     * Strategies must be symmetric so that mapping a {@link File} to a
-     * {@link Uri} and then back to a {@link File} points at the original
-     * target.
-     * <p>
-     * Strategies must remain consistent across app launches, and not rely on
-     * dynamic state. This ensures that any generated {@link Uri} can still be
-     * resolved if your process is killed and later restarted.
-     *
-     * @see SimplePathStrategy
-     */
-    interface PathStrategy {
-        /**
-         * Return a {@link Uri} that represents the given {@link File}.
-         */
-        public Uri getUriForFile(File file);
-
-        /**
-         * Return a {@link File} that represents the given {@link Uri}.
-         */
-        public File getFileForUri(Uri uri);
-    }
-
-    /**
-     * Strategy that provides access to files living under a narrow whitelist of
-     * filesystem roots. It will throw {@link SecurityException} if callers try
-     * accessing files outside the configured roots.
-     * <p>
-     * For example, if configured with
-     * {@code addRoot("myfiles", context.getFilesDir())}, then
-     * {@code context.getFileStreamPath("foo.txt")} would map to
-     * {@code content://myauthority/myfiles/foo.txt}.
-     */
-    static class SimplePathStrategy implements PathStrategy {
-        private final String mAuthority;
-        private final HashMap<String, File> mRoots = new HashMap<String, File>();
-
-        public SimplePathStrategy(String authority) {
-            mAuthority = authority;
-        }
-
-        /**
-         * Add a mapping from a name to a filesystem root. The provider only offers
-         * access to files that live under configured roots.
-         */
-        public void addRoot(String name, File root) {
-            if (TextUtils.isEmpty(name)) {
-                throw new IllegalArgumentException("Name must not be empty");
-            }
-
-            try {
-                // Resolve to canonical path to keep path checking fast
-                root = root.getCanonicalFile();
-            } catch (IOException e) {
-                throw new IllegalArgumentException(
-                        "Failed to resolve canonical path for " + root, e);
-            }
-
-            mRoots.put(name, root);
-        }
-
-        @Override
-        public Uri getUriForFile(File file) {
-            String path;
-            try {
-                path = file.getCanonicalPath();
-            } catch (IOException e) {
-                throw new IllegalArgumentException("Failed to resolve canonical path for " + file);
-            }
-
-            // Find the most-specific root path
-            Map.Entry<String, File> mostSpecific = null;
-            for (Map.Entry<String, File> root : mRoots.entrySet()) {
-                final String rootPath = root.getValue().getPath();
-                if (path.startsWith(rootPath) && (mostSpecific == null
-                        || rootPath.length() > mostSpecific.getValue().getPath().length())) {
-                    mostSpecific = root;
-                }
-            }
-
-            if (mostSpecific == null) {
-                throw new IllegalArgumentException(
-                        "Failed to find configured root that contains " + path);
-            }
-
-            // Start at first char of path under root
-            final String rootPath = mostSpecific.getValue().getPath();
-            if (rootPath.endsWith("/")) {
-                path = path.substring(rootPath.length());
-            } else {
-                path = path.substring(rootPath.length() + 1);
-            }
-
-            // Encode the tag and path separately
-            path = Uri.encode(mostSpecific.getKey()) + '/' + Uri.encode(path, "/");
-            return new Uri.Builder().scheme("content")
-                    .authority(mAuthority).encodedPath(path).build();
-        }
-
-        @Override
-        public File getFileForUri(Uri uri) {
-            String path = uri.getEncodedPath();
-
-            final int splitIndex = path.indexOf('/', 1);
-            final String tag = Uri.decode(path.substring(1, splitIndex));
-            path = Uri.decode(path.substring(splitIndex + 1));
-
-            final File root = mRoots.get(tag);
-            if (root == null) {
-                throw new IllegalArgumentException("Unable to find configured root for " + uri);
-            }
-
-            File file = new File(root, path);
-            try {
-                file = file.getCanonicalFile();
-            } catch (IOException e) {
-                throw new IllegalArgumentException("Failed to resolve canonical path for " + file);
-            }
-
-            if (!file.getPath().startsWith(root.getPath())) {
-                throw new SecurityException("Resolved path jumped beyond configured root");
-            }
-
-            return file;
-        }
-    }
-
-    /**
-     * Copied from ContentResolver.java
-     */
-    private static int modeToMode(String mode) {
-        int modeBits;
-        if ("r".equals(mode)) {
-            modeBits = ParcelFileDescriptor.MODE_READ_ONLY;
-        } else if ("w".equals(mode) || "wt".equals(mode)) {
-            modeBits = ParcelFileDescriptor.MODE_WRITE_ONLY
-                    | ParcelFileDescriptor.MODE_CREATE
-                    | ParcelFileDescriptor.MODE_TRUNCATE;
-        } else if ("wa".equals(mode)) {
-            modeBits = ParcelFileDescriptor.MODE_WRITE_ONLY
-                    | ParcelFileDescriptor.MODE_CREATE
-                    | ParcelFileDescriptor.MODE_APPEND;
-        } else if ("rw".equals(mode)) {
-            modeBits = ParcelFileDescriptor.MODE_READ_WRITE
-                    | ParcelFileDescriptor.MODE_CREATE;
-        } else if ("rwt".equals(mode)) {
-            modeBits = ParcelFileDescriptor.MODE_READ_WRITE
-                    | ParcelFileDescriptor.MODE_CREATE
-                    | ParcelFileDescriptor.MODE_TRUNCATE;
-        } else {
-            throw new IllegalArgumentException("Invalid mode: " + mode);
-        }
-        return modeBits;
-    }
-
-    private static File buildPath(File base, String... segments) {
-        File cur = base;
-        for (String segment : segments) {
-            if (segment != null) {
-                cur = new File(cur, segment);
-            }
-        }
-        return cur;
-    }
-
-    private static String[] copyOf(String[] original, int newLength) {
-        final String[] result = new String[newLength];
-        System.arraycopy(original, 0, result, 0, newLength);
-        return result;
-    }
-
-    private static Object[] copyOf(Object[] original, int newLength) {
-        final Object[] result = new Object[newLength];
-        System.arraycopy(original, 0, result, 0, newLength);
-        return result;
-    }
-}
diff --git a/app/src/main/java/com/kanedias/vanilla/audiotag/PluginService.java b/app/src/main/java/com/kanedias/vanilla/audiotag/PluginService.java
index c9f2ea1..20e3626 100644
--- a/app/src/main/java/com/kanedias/vanilla/audiotag/PluginService.java
+++ b/app/src/main/java/com/kanedias/vanilla/audiotag/PluginService.java
@@ -16,23 +16,19 @@
  */
 package com.kanedias.vanilla.audiotag;
 
-import android.annotation.TargetApi;
 import android.app.Service;
 import android.content.Intent;
+import android.content.SharedPreferences;
 import android.content.pm.ApplicationInfo;
-import android.content.pm.PackageManager;
-import android.database.Cursor;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
 import android.media.MediaScannerConnection;
 import android.net.Uri;
 import android.os.Binder;
-import android.os.Build;
 import android.os.IBinder;
 import android.os.ParcelFileDescriptor;
-import android.os.Process;
-import android.provider.MediaStore;
-import android.support.copied.FileProvider;
+import android.preference.PreferenceManager;
+import android.support.annotation.Nullable;
+import android.support.v4.content.FileProvider;
+import android.support.v4.provider.DocumentFile;
 import android.util.Log;
 import android.widget.Toast;
 
@@ -42,6 +38,7 @@ import org.jaudiotagger.audio.exceptions.CannotReadException;
 import org.jaudiotagger.audio.exceptions.CannotWriteException;
 import org.jaudiotagger.audio.exceptions.InvalidAudioFrameException;
 import org.jaudiotagger.audio.exceptions.ReadOnlyFileException;
+import org.jaudiotagger.audio.generic.Utils;
 import org.jaudiotagger.tag.FieldDataInvalidException;
 import org.jaudiotagger.tag.FieldKey;
 import org.jaudiotagger.tag.Tag;
@@ -55,6 +52,9 @@ import java.io.File;
 import java.io.FileInputStream;
 import java.io.FileOutputStream;
 import java.io.IOException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.List;
 import java.util.UUID;
 
 import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
@@ -89,6 +89,12 @@ import static com.kanedias.vanilla.audiotag.PluginConstants.*;
  */
 public class PluginService extends Service {
 
+    static final String EXTRA_PARAM_SAF_P2P = "ch.blinkenlights.android.vanilla.extra.SAF_P2P";
+
+    static final String PREF_SDCARD_URI = "ch.blinkenlights.android.vanilla.pref.SDCARD_URI";
+
+    private SharedPreferences mPrefs;
+
     private Intent mLaunchIntent;
     private AudioFile mAudioFile;
     private Tag mTag;
@@ -126,6 +132,21 @@ public class PluginService extends Service {
         return false;
     }
 
+    @Override
+    public void onCreate() {
+        super.onCreate();
+
+        mPrefs = PreferenceManager.getDefaultSharedPreferences(this);
+    }
+
+    /**
+     * Main plugin service operation entry point. This is called each time plugins are quieried
+     * and requested by main Vanilla Music app and also when plugins communicate with each other through P2P-intents.
+     * @param intent intent provided by broadcast or request
+     * @param flags - not used
+     * @param startId - not used
+     * @return always constant {@link #START_NOT_STICKY}
+     */
     @Override
     public int onStartCommand(Intent intent, int flags, int startId) {
         if (intent != null) {
@@ -161,13 +182,23 @@ public class PluginService extends Service {
     }
 
     private void handleLaunchPlugin() {
-        if (Utils.havePermissions(this, WRITE_EXTERNAL_STORAGE) && mLaunchIntent.hasExtra(EXTRA_PARAM_P2P)) {
+        if (mLaunchIntent.hasExtra(EXTRA_PARAM_SAF_P2P)) {
+            // it's SAF intent that is returned from SAF activity, should have URI inside
+            persistThroughSaf(mLaunchIntent);
+            return;
+        }
+
+        // if it's P2P intent, just try to read/write file as requested
+        if (TagEditorUtils.havePermissions(this, WRITE_EXTERNAL_STORAGE) && mLaunchIntent.hasExtra(EXTRA_PARAM_P2P)) {
             if(loadFile()) {
                 handleP2pIntent();
             }
             return;
         }
 
+        // either we have no permissions to write to SD and activity is requested
+        // or this is normal user-requested operation (non-P2P)
+        // start activity!
         Intent dialogIntent = new Intent(this, TagEditActivity.class);
         dialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
         dialogIntent.putExtras(mLaunchIntent);
@@ -178,13 +209,6 @@ public class PluginService extends Service {
         return mTag;
     }
 
-    /**
-     * @return cached in-memory audio file associated with opened tag
-     */
-    public AudioFile getAudioFile() {
-        return mAudioFile;
-    }
-
     /**
      * Loads file as {@link AudioFile} and performs initial tag creation if it's absent.
      * If error happens while loading, shows popup indicating error details.
@@ -219,28 +243,37 @@ public class PluginService extends Service {
         return true;
     }
 
-    /**
-     * Writes changes in tags into file and closes activity.
-     * If something goes wrong, leaves activity intact.
-     */
-    public void persistChanges() {
-        try {
-            if (!mAudioFile.getFile().canWrite() && Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-                Toast.makeText(this,R.string.file_on_external_sd_error, Toast.LENGTH_LONG).show();
-                Toast.makeText(this,R.string.file_on_external_sd_sorry, Toast.LENGTH_LONG).show();
+    public void writeFile() {
+        if (TagEditorUtils.isSafNeeded(mAudioFile)) {
+            if (mPrefs.contains(PREF_SDCARD_URI)) {
+                // we already got the permission!
+                persistThroughSaf(null);
                 return;
             }
 
+            // request SAF permissions in SAF activity
+            Intent dialogIntent = new Intent(this, SafRequestActivity.class);
+            dialogIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);
+            dialogIntent.putExtras(mLaunchIntent);
+            startActivity(dialogIntent);
+            // it will pass us URI back after the work is done
+        } else {
+            persistThroughFile();
+        }
+    }
+
+    /**
+     * Writes changes in tags directly into file and closes activity.
+     * Call this if you're absolutely sure everything is right with file and tag.
+     */
+    private void persistThroughFile() {
+        try {
             AudioFileIO.write(mAudioFile);
             Toast.makeText(this, R.string.file_written_successfully, Toast.LENGTH_SHORT).show();
 
             // update media database
-            // TODO: this does not conform to our new media-db project
-            // TODO: we should create a way to update file via intent to vanilla-music
-            MediaScannerConnection.scanFile(this,
-                    new String[]{mAudioFile.getFile().getAbsolutePath()},
-                    null,
-                    null);
+            File persisted = mAudioFile.getFile();
+            MediaScannerConnection.scanFile(this, new String[]{persisted.getAbsolutePath()}, null, null);
         } catch (CannotWriteException e) {
             Log.e(LOG_TAG,
                     String.format(getString(R.string.error_audio_file), mAudioFile.getFile().getPath()), e);
@@ -252,6 +285,98 @@ public class PluginService extends Service {
         }
     }
 
+    /**
+     * Write changes through SAF framework - the only way to do it in Android > 4.4 when working with SD card
+     * @param activityResponse response with URI contained in. Can be null if tree permission is already given.
+     */
+    private void persistThroughSaf(Intent activityResponse) {
+        Uri safUri;
+        if (mPrefs.contains(PREF_SDCARD_URI)) {
+            // no sorcery can allow you to gain URI to the document representing file you've been provided with
+            // you have to find it again using now Document API
+
+            // /storage/volume/Music/some.mp3 will become [storage, volume, music, some.mp3]
+            List<String> pathSegments = new ArrayList<>(Arrays.asList(mAudioFile.getFile().getAbsolutePath().split("/")));
+            Uri allowedSdRoot = Uri.parse(mPrefs.getString(PREF_SDCARD_URI, ""));
+            safUri = findInDocumentTree(DocumentFile.fromTreeUri(this, allowedSdRoot), pathSegments);
+        } else {
+            Intent originalSafResponse = activityResponse.getParcelableExtra(EXTRA_PARAM_SAF_P2P);
+            safUri = originalSafResponse.getData();
+        }
+
+        if (safUri == null) {
+            // nothing selected or invalid file?
+            Toast.makeText(this, R.string.saf_nothing_selected, Toast.LENGTH_LONG).show();
+            return;
+        }
+
+        try {
+            // we don't have fd-related audiotagger write functions, have to use workaround
+            // write audio file to temp cache dir
+            // jaudiotagger can't work through file descriptor, sadly
+            File original = mAudioFile.getFile();
+            File temp = File.createTempFile("tmp-media", '.' + Utils.getExtension(original));
+            Utils.copy(original, temp); // jtagger writes only header, we should copy the rest
+            temp.deleteOnExit(); // in case of exception it will be deleted too
+            mAudioFile.setFile(temp);
+            AudioFileIO.write(mAudioFile);
+
+            // retrieve FD from SAF URI
+            ParcelFileDescriptor pfd = getContentResolver().openFileDescriptor(safUri, "rw");
+            if (pfd == null) {
+                // should not happen
+                Log.e(LOG_TAG, "SAF provided incorrect URI!" + safUri);
+                return;
+            }
+
+            // now read persisted data and write it to real FD provided by SAF
+            FileInputStream fis = new FileInputStream(temp);
+            byte[] audioContent = TagEditorUtils.readFully(fis);
+            FileOutputStream fos = new FileOutputStream(pfd.getFileDescriptor());
+            fos.write(audioContent);
+            fos.close();
+
+            // delete temporary file used
+            temp.delete();
+
+            // rescan original file
+            MediaScannerConnection.scanFile(this, new String[]{original.getAbsolutePath()}, null, null);
+            Toast.makeText(this, R.string.file_written_successfully, Toast.LENGTH_SHORT).show();
+        } catch (Exception e) {
+            Toast.makeText(this, getString(R.string.saf_write_error) + e.getLocalizedMessage(), Toast.LENGTH_LONG).show();
+            Log.e(LOG_TAG, "Failed to write to file descriptor provided by SAF!", e);
+        }
+    }
+
+    /**
+     * Finds needed file through Document API for SAF. It's not optimized yet - you can still gain wrong URI on
+     * files such as "/a/b/c.mp3" and "/b/a/c.mp3", but I consider it complete enough to be usable.
+     * @param currentDir - document file representing current dir of search
+     * @param remainingPathSegments - path segments that are left to find
+     * @return URI for found file. Null if nothing found.
+     */
+    @Nullable
+    private Uri findInDocumentTree(DocumentFile currentDir, List<String> remainingPathSegments) {
+        for (DocumentFile file : currentDir.listFiles()) {
+            int index = remainingPathSegments.indexOf(file.getName());
+            if (index == -1) {
+                continue;
+            }
+
+            if (file.isDirectory()) {
+                remainingPathSegments.remove(file.getName());
+                return findInDocumentTree(file, remainingPathSegments);
+            }
+
+            if (file.isFile() && index == remainingPathSegments.size() - 1) {
+                // got to the last part
+                return file.getUri();
+            }
+        }
+
+        return null;
+    }
+
     /**
      * This plugin also has P2P functionality with others. It provides generic way to
      * read and write tags for the file.
@@ -283,7 +408,7 @@ public class PluginService extends Service {
                         Log.e(LOG_TAG, "Error writing tag", e);
                     }
                 }
-                persistChanges();
+                writeFile();
                 break;
             }
             case P2P_READ_TAG: {
@@ -365,7 +490,7 @@ public class PluginService extends Service {
                     }
 
                     FileInputStream fis = new FileInputStream(pfd.getFileDescriptor());
-                    byte[] imgBytes = Utils.readFully(fis);
+                    byte[] imgBytes = TagEditorUtils.readFully(fis);
 
                     Artwork cover = new AndroidArtwork();
                     cover.setBinaryData(imgBytes);
@@ -379,7 +504,7 @@ public class PluginService extends Service {
                     Toast.makeText(this, R.string.invalid_artwork_provided, Toast.LENGTH_SHORT).show();
                 }
 
-                persistChanges();
+                writeFile();
                 break;
             }
         }
diff --git a/app/src/main/java/com/kanedias/vanilla/audiotag/SafRequestActivity.java b/app/src/main/java/com/kanedias/vanilla/audiotag/SafRequestActivity.java
new file mode 100644
index 0000000..0e043c2
--- /dev/null
+++ b/app/src/main/java/com/kanedias/vanilla/audiotag/SafRequestActivity.java
@@ -0,0 +1,160 @@
+package com.kanedias.vanilla.audiotag;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.content.ComponentName;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.content.SharedPreferences;
+import android.net.Uri;
+import android.os.Build;
+import android.os.IBinder;
+import android.preference.PreferenceManager;
+import android.widget.Toast;
+
+import org.jaudiotagger.audio.AudioFile;
+
+import java.io.File;
+
+import static com.kanedias.vanilla.audiotag.PluginConstants.ACTION_LAUNCH_PLUGIN;
+import static com.kanedias.vanilla.audiotag.PluginConstants.EXTRA_PARAM_URI;
+
+/**
+ * Activity that is needed solely for requesting SAF permissions for external SD cards.
+ *
+ * @author  Kanedias on 17.02.17.
+ */
+public class SafRequestActivity extends Activity {
+
+    private static final int SAF_FILE_REQUEST_CODE = 1;
+    private static final int SAF_TREE_REQUEST_CODE = 2;
+
+    /**
+     * File to search access for
+     */
+    private File mFile;
+
+    private SharedPreferences mPrefs;
+
+    private ServiceConnection mServiceConn = new ServiceConnection() {
+        @Override
+        public void onServiceConnected(ComponentName name, IBinder service) {
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName name) {
+        }
+    };
+
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+
+        mPrefs = PreferenceManager.getDefaultSharedPreferences(this);
+
+        // need to bind the service or it will stop itself after TagEditActivity is closed
+        Intent bind = new Intent(this, PluginService.class);
+        bindService(bind, mServiceConn, 0);
+
+        Uri fileUri = getIntent().getParcelableExtra(EXTRA_PARAM_URI);
+        mFile = new File(fileUri.getPath());
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
+            // it's Lollipop - let's request tree URI instead of nitpicking with specific files...
+            // deal with file passed after request is fulfilled
+            callSafRequestTree();
+            return;
+        }
+
+        // it's Kitkat - we're doomed to request each file one by one
+        // this is very unlikely actually - external card is still R/W for KitKat, so
+        // service should be able to persist everything through normal File API
+        callSafFilePicker();
+    }
+
+    /**
+     * Call tree-picker to select root of SD card.
+     * Shows a hint how to do this, continues if "ok" is clicked.
+     */
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    private void callSafRequestTree() {
+        new AlertDialog.Builder(this)
+                .setTitle(R.string.need_sd_card_access)
+                .setIcon(R.drawable.icon)
+                .setView(R.layout.sd_operate_instructions)
+                .setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        finish();
+                    }
+                })
+                .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        Intent selectFile = new Intent(Intent.ACTION_OPEN_DOCUMENT_TREE);
+                        startActivityForResult(selectFile, SAF_TREE_REQUEST_CODE);
+                    }
+                })
+                .create()
+                .show();
+    }
+
+    /**
+     * Mostly this is needed for SAF support. If the file is located on external SD card then android provides
+     * only Storage Access Framework to be able to write anything.
+     * @param requestCode our sent code, see {@link TagEditorUtils#isSafNeeded(AudioFile)}
+     * @param resultCode success or error
+     * @param data URI-containing intent
+     */
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        Intent serviceStart = new Intent(this, PluginService.class);
+        serviceStart.setAction(ACTION_LAUNCH_PLUGIN);
+        serviceStart.putExtras(getIntent());
+        serviceStart.putExtra(PluginService.EXTRA_PARAM_SAF_P2P, data);
+
+        if (requestCode == SAF_FILE_REQUEST_CODE && resultCode == Activity.RESULT_OK) {
+            // access granted, write through
+            serviceStart.putExtra(PluginService.EXTRA_PARAM_SAF_P2P, data);
+            startService(serviceStart); // pass intent back to the service
+        }
+
+        if (requestCode == SAF_TREE_REQUEST_CODE && resultCode == Activity.RESULT_OK) {
+            saveTreeAccessForever(data);
+            startService(serviceStart); // pass intent back to the service
+        }
+
+        // canceled or denied
+        finish();
+    }
+
+    /**
+     * Saves SAF-provided tree URI forever
+     * @param data intent containing tree URI in data
+     */
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    private void saveTreeAccessForever(Intent data) {
+        Uri treeAccessUri = data.getData();
+        getContentResolver().takePersistableUriPermission(treeAccessUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION);
+        mPrefs.edit().putString(PluginService.PREF_SDCARD_URI, treeAccessUri.toString()).apply();
+    }
+
+    /**
+     * Opens SAF file pick dialog to allow you to select specific file to write to
+     */
+    @TargetApi(Build.VERSION_CODES.KITKAT)
+    private void callSafFilePicker() {
+        Toast.makeText(this, R.string.file_on_external_sd_warning, Toast.LENGTH_LONG).show();
+        Toast.makeText(this, R.string.file_on_external_sd_workaround, Toast.LENGTH_LONG).show();
+        Toast.makeText(this, String.format(getString(R.string.file_on_external_sd_hint), mFile.getPath()), Toast.LENGTH_LONG).show();
+
+        Intent selectFile = new Intent(Intent.ACTION_CREATE_DOCUMENT);
+        selectFile.addCategory(Intent.CATEGORY_OPENABLE);
+        selectFile.setType("audio/*");
+        startActivityForResult(selectFile, SAF_FILE_REQUEST_CODE);
+    }
+
+}
diff --git a/app/src/main/java/com/kanedias/vanilla/audiotag/TagEditActivity.java b/app/src/main/java/com/kanedias/vanilla/audiotag/TagEditActivity.java
index 8fcc2f8..267fda0 100644
--- a/app/src/main/java/com/kanedias/vanilla/audiotag/TagEditActivity.java
+++ b/app/src/main/java/com/kanedias/vanilla/audiotag/TagEditActivity.java
@@ -16,18 +16,15 @@
  */
 package com.kanedias.vanilla.audiotag;
 
-import android.annotation.TargetApi;
 import android.app.Activity;
 import android.content.ComponentName;
 import android.content.Intent;
 import android.content.ServiceConnection;
 import android.content.pm.PackageManager;
-import android.net.Uri;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.IBinder;
-import android.os.ParcelFileDescriptor;
-import android.system.Os;
+import android.support.annotation.NonNull;
 import android.text.Editable;
 import android.text.TextUtils;
 import android.text.TextWatcher;
@@ -39,18 +36,13 @@ import android.widget.Button;
 import android.widget.EditText;
 import android.widget.Spinner;
 import android.widget.SpinnerAdapter;
-import android.widget.Toast;
 
 import com.kanedias.vanilla.audiotag.misc.HintSpinnerAdapter;
 
-import org.jaudiotagger.audio.AudioFile;
 import org.jaudiotagger.tag.FieldDataInvalidException;
 import org.jaudiotagger.tag.FieldKey;
 import org.jaudiotagger.tag.Tag;
 
-import java.io.File;
-import java.io.FileNotFoundException;
-
 import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
 import static com.kanedias.vanilla.audiotag.PluginConstants.*;
 
@@ -67,7 +59,6 @@ import static com.kanedias.vanilla.audiotag.PluginConstants.*;
 public class TagEditActivity extends Activity {
 
     private static final int PERMISSIONS_REQUEST_CODE = 0;
-    private static final int SAF_REQUEST_CODE = 1;
 
     private EditText mTitleEdit;
     private EditText mArtistEdit;
@@ -114,14 +105,6 @@ public class TagEditActivity extends Activity {
         setupUI();
     }
 
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-        if (mService != null) {
-            unbindService(mServiceConn);
-        }
-    }
-
     /**
      * Initialize UI elements with handlers and action listeners
      */
@@ -132,15 +115,10 @@ public class TagEditActivity extends Activity {
                 finish();
             }
         });
-
         mConfirm.setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
-                if (isSafRelated()) {
-                    // will be handled after file is picked
-                    return;
-                }
-                mService.persistChanges();
+                mService.writeFile();
                 finish();
             }
         });
@@ -177,30 +155,6 @@ public class TagEditActivity extends Activity {
         mAlbumEdit.addTextChangedListener(new FieldKeyListener(FieldKey.ALBUM));
     }
 
-    /**
-     * Check if Android Storage Access Framework routines apply here
-     * @return true if document seems to be SAF-accessible only, false otherwise
-     */
-    private boolean isSafRelated() {
-        // on external SD card this will return false, workaround it
-        if (!mService.getAudioFile().getFile().canWrite() && Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT) {
-            Toast.makeText(this,R.string.file_on_external_sd_warning, Toast.LENGTH_LONG).show();
-            Toast.makeText(this,R.string.file_on_external_sd_workaround, Toast.LENGTH_LONG).show();
-            callSafFilePicker();
-            return true;
-        }
-
-        return false;
-    }
-
-    @TargetApi(Build.VERSION_CODES.KITKAT)
-    private void callSafFilePicker() {
-        Intent selectFile = new Intent(Intent.ACTION_CREATE_DOCUMENT);
-        selectFile.addCategory(Intent.CATEGORY_OPENABLE);
-        selectFile.setType("audio/*");
-        startActivityForResult(selectFile, SAF_REQUEST_CODE);
-    }
-
     /**
      * Handle Vanilla Music player intents. This will show activity window (in most cases) and load
      * all needed info from file.
@@ -248,7 +202,7 @@ public class TagEditActivity extends Activity {
      * @param grantResults results of permission request. Indexes of permissions array are linked with these
      */
     @Override
-    public void onRequestPermissionsResult(int requestCode, String[] permissions, int[] grantResults) {
+    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
         super.onRequestPermissionsResult(requestCode, permissions, grantResults);
 
         if (requestCode != PERMISSIONS_REQUEST_CODE) {
@@ -263,34 +217,6 @@ public class TagEditActivity extends Activity {
         }
     }
 
-    @Override
-    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-        if (requestCode == SAF_REQUEST_CODE && resultCode == Activity.RESULT_OK) {
-            Uri safUri = data.getData();
-            if (safUri == null) {
-                // nothing selected
-                return;
-            }
-
-            try {
-                // we don't have fd-related audiotagger write functions, have to use workaround
-                // some low-level Linux sorcery
-                AudioFile af = mService.getAudioFile();
-                ParcelFileDescriptor pfd = getContentResolver().openFileDescriptor(safUri, "rw");
-                File fdLink = new File("/proc/" + android.os.Process.myPid() + "/fd/" + pfd.getFd());
-                File realFile = new File(fdLink.getAbsolutePath());
-                File virtFile = new File(getCacheDir().getAbsolutePath() + "/" + af.getFile().getName()); // f
-                Runtime.getRuntime().exec("ln -s " + fdLink.getAbsolutePath() + " " + virtFile).waitFor();
-                af.setFile(virtFile);
-                mService.persistChanges();
-                virtFile.delete();
-                finish();
-            } catch (Exception e) {
-                // do nothing
-            }
-        }
-    }
-
     /**
      * Checks for permission and requests it if needed.
      * You should catch answer back in {@link #onRequestPermissionsResult(int, String[], int[])}
@@ -300,7 +226,7 @@ public class TagEditActivity extends Activity {
      * @return true if this app had this permission prior to check, false otherwise.
      */
     private boolean checkAndRequestPermissions(String perm) {
-        if (!Utils.havePermissions(this, perm)  && Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+        if (!TagEditorUtils.havePermissions(this, perm)  && Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
             requestPermissions(new String[]{perm}, PERMISSIONS_REQUEST_CODE);
             return false;
         }
diff --git a/app/src/main/java/com/kanedias/vanilla/audiotag/Utils.java b/app/src/main/java/com/kanedias/vanilla/audiotag/TagEditorUtils.java
similarity index 73%
rename from app/src/main/java/com/kanedias/vanilla/audiotag/Utils.java
rename to app/src/main/java/com/kanedias/vanilla/audiotag/TagEditorUtils.java
index 6082427..926c125 100644
--- a/app/src/main/java/com/kanedias/vanilla/audiotag/Utils.java
+++ b/app/src/main/java/com/kanedias/vanilla/audiotag/TagEditorUtils.java
@@ -20,7 +20,10 @@ import android.content.Context;
 import android.content.pm.PackageManager;
 import android.os.Build;
 
+import org.jaudiotagger.audio.AudioFile;
+
 import java.io.ByteArrayOutputStream;
+import java.io.File;
 import java.io.IOException;
 import java.io.InputStream;
 
@@ -29,7 +32,7 @@ import java.io.InputStream;
  *
  * @author Oleg Chernovskiy
  */
-public class Utils {
+public class TagEditorUtils {
 
     /**
      * Checks if all required permissions have been granted
@@ -55,7 +58,25 @@ public class Utils {
             baos.write(buffer, 0, count);
         }
 
+        stream.close();
         return baos.toByteArray();
     }
 
+
+    /**
+     * Shortcut for {@link #isSafNeeded(File)} for {@link AudioFile}
+     */
+    public static boolean isSafNeeded(AudioFile af) {
+        return isSafNeeded(af.getFile());
+    }
+
+    /**
+     * Check if Android Storage Access Framework routines apply here
+     * @return true if document seems to be SAF-accessible only, false otherwise
+     */
+    public static boolean isSafNeeded(File file) {
+        // on external SD card after KitKat this will return false
+        return !file.canWrite() && Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
+    }
+
 }
