diff --git a/app/src/main/java/com/mdiqentw/lifedots/MVApplication.java b/app/src/main/java/com/mdiqentw/lifedots/MVApplication.java
deleted file mode 100644
index 29932f3..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/MVApplication.java
+++ /dev/null
@@ -1,80 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2017 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots;
-
-import android.annotation.SuppressLint;
-import android.app.Application;
-import android.content.Context;
-import android.graphics.Color;
-
-//import org.acra.*;
-//import org.acra.annotation.*;
-//import org.acra.data.StringFormat;
-
-import com.mdiqentw.lifedots.helpers.GraphicsHelper;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-public class MVApplication extends Application {
-
-    @SuppressLint("StaticFieldLeak")
-    private static Context context;
-
-    public void onCreate() {
-        super.onCreate();
-        MVApplication.context = getApplicationContext();
-
-        /* now do some init stuff */
-        String[] colors = context.getResources().getStringArray(R.array.activityColorPalette);
-
-        for (String color : colors) {
-            GraphicsHelper.activityColorPalette.add(Color.parseColor(color));
-        }
-    }
-
-    @Override
-    protected void attachBaseContext(Context base) {
-        super.attachBaseContext(base);
-
-//        ACRA.init(this);
-    }
-
-    public static Context getAppContext() {
-        return MVApplication.context;
-    }
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/MVApplication.kt b/app/src/main/java/com/mdiqentw/lifedots/MVApplication.kt
new file mode 100755
index 0000000..63f0532
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/MVApplication.kt
@@ -0,0 +1,55 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2017 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots
+
+import android.annotation.SuppressLint
+import android.app.Application
+import android.content.Context
+import android.graphics.Color
+import com.mdiqentw.lifedots.helpers.GraphicsHelper
+
+//import org.acra.*;
+//import org.acra.annotation.*;
+//import org.acra.data.StringFormat;
+class MVApplication : Application() {
+    override fun onCreate() {
+        super.onCreate()
+        appContext = applicationContext
+
+        /* now do some init stuff */
+        val colors = appContext!!.resources.getStringArray(R.array.activityColorPalette)
+        for (color in colors) {
+            GraphicsHelper.activityColorPalette.add(Color.parseColor(color))
+        }
+    }
+
+    override fun attachBaseContext(base: Context) {
+        super.attachBaseContext(base)
+
+//        ACRA.init(this);
+    }
+
+    companion object {
+        @JvmField
+        @SuppressLint("StaticFieldLeak")
+        var appContext: Context? = null
+//            private set
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/db/Contract.java b/app/src/main/java/com/mdiqentw/lifedots/db/Contract.java
old mode 100644
new mode 100755
diff --git a/app/src/main/java/com/mdiqentw/lifedots/db/LDContentProvider.java b/app/src/main/java/com/mdiqentw/lifedots/db/LDContentProvider.java
deleted file mode 100644
index 9596a5c..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/db/LDContentProvider.java
+++ /dev/null
@@ -1,739 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- * Copyright (C) 2018 Bc. Ondrej Janitor
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots.db;
-
-import android.annotation.SuppressLint;
-import android.app.SearchManager;
-import android.content.ContentProvider;
-import android.content.ContentUris;
-import android.content.ContentValues;
-import android.content.Intent;
-import android.content.UriMatcher;
-import android.database.Cursor;
-import android.database.MatrixCursor;
-import android.database.SQLException;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteQueryBuilder;
-import android.net.Uri;
-import android.provider.BaseColumns;
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import android.text.TextUtils;
-import android.util.Log;
-
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.List;
-import java.util.regex.Pattern;
-
-import com.mdiqentw.lifedots.R;
-import com.mdiqentw.lifedots.helpers.ActivityHelper;
-import com.mdiqentw.lifedots.model.DiaryActivity;
-
-import static android.app.SearchManager.SUGGEST_COLUMN_ICON_1;
-import static android.app.SearchManager.SUGGEST_COLUMN_INTENT_ACTION;
-import static android.app.SearchManager.SUGGEST_COLUMN_INTENT_DATA;
-import static android.app.SearchManager.SUGGEST_COLUMN_QUERY;
-import static android.app.SearchManager.SUGGEST_COLUMN_TEXT_1;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-/*
- * Why a new Content Provider for Diary Activites?
- *
- * According https://developer.android.com/guide/topics/providers/content-provider-creating.html
- * we need it to do searching, synching or widget use of the data -> which in the long we all want to do.
- *
- * Additionally it is used as SearchProvider these days.
- * */
-public class LDContentProvider extends ContentProvider {
-
-    private static final int ACTIVITIES = 1;
-    private static final int ACTIVITIES_ID = 2;
-    private static final int CONDITIONS = 3;
-    private static final int CONDITIONS_ID = 4;
-    private static final int DIARY = 5;
-    private static final int DIARY_ID = 6;
-    private static final int DIARY_IMAGE = 7;
-    private static final int DIARY_IMAGE_ID = 8;
-    private static final int DIARY_LOCATION = 9;
-    private static final int DIARY_LOCATION_ID = 10;
-    private static final int DIARY_STATS = 11;
-    private static final int SEARCH_RECENT_SUGGESTION = 12;
-    private static final int SEARCH_SUGGESTION = 13;
-    private static final int DIARY_SUGGESTION = 14;
-
-    private static final String TAG = LDContentProvider.class.getName();
-
-    public static final String SEARCH_ACTIVITY = "com.mdiqentw.lifedots.action.SEARCH_ACTIVITY";
-    public static final String SEARCH_NOTE = "com.mdiqentw.lifedots.action.SEARCH_NOTE";
-    public static final String SEARCH_GLOBAL = "com.mdiqentw.lifedots.action.SEARCH_GLOBAL";
-    public static final String SEARCH_DATE = "com.mdiqentw.lifedots.action.SEARCH_DATE";
-
-    // TODO: isn't this already somewhere else?
-    public static final Uri SEARCH_URI = Uri.parse("content://" + Contract.AUTHORITY);
-
-    private static final UriMatcher sUriMatcher = new UriMatcher(UriMatcher.NO_MATCH);
-    private static final Pattern plusPattern = Pattern.compile("^/+");
-
-    static {
-        sUriMatcher.addURI(Contract.AUTHORITY, plusPattern.matcher(Contract.DiaryActivity.CONTENT_URI.getPath()).replaceAll(""), ACTIVITIES);
-        sUriMatcher.addURI(Contract.AUTHORITY, plusPattern.matcher(Contract.DiaryActivity.CONTENT_URI.getPath()).replaceAll("") + "/#", ACTIVITIES_ID);
-
-        sUriMatcher.addURI(Contract.AUTHORITY, plusPattern.matcher(Contract.Diary.CONTENT_URI.getPath()).replaceAll(""), DIARY);
-        sUriMatcher.addURI(Contract.AUTHORITY, plusPattern.matcher(Contract.Diary.CONTENT_URI.getPath()).replaceAll("") + "/#", DIARY_ID);
-
-        sUriMatcher.addURI(Contract.AUTHORITY, plusPattern.matcher(Contract.DiaryImage.CONTENT_URI.getPath()).replaceAll(""), DIARY_IMAGE);
-        sUriMatcher.addURI(Contract.AUTHORITY, plusPattern.matcher(Contract.DiaryImage.CONTENT_URI.getPath()).replaceAll("") + "/#", DIARY_IMAGE_ID);
-
-        sUriMatcher.addURI(Contract.AUTHORITY, plusPattern.matcher(Contract.DiaryStats.CONTENT_URI.getPath()).replaceAll(""), DIARY_STATS);
-        sUriMatcher.addURI(Contract.AUTHORITY, plusPattern.matcher(Contract.DiaryStats.CONTENT_URI.getPath()).replaceAll("") + "/#/#", DIARY_STATS);
-
-        sUriMatcher.addURI(Contract.AUTHORITY, plusPattern.matcher(Contract.DiaryLocation.CONTENT_URI.getPath()).replaceAll(""), DIARY_LOCATION);
-        sUriMatcher.addURI(Contract.AUTHORITY, plusPattern.matcher(Contract.DiaryLocation.CONTENT_URI.getPath()).replaceAll("") + "/#", DIARY_LOCATION_ID);
-
-        sUriMatcher.addURI(Contract.AUTHORITY, plusPattern.matcher(Contract.DiaryLocation.CONTENT_URI.getPath()).replaceAll(""), DIARY_LOCATION);
-        sUriMatcher.addURI(Contract.AUTHORITY, plusPattern.matcher(Contract.DiaryLocation.CONTENT_URI.getPath()).replaceAll("") + "/#", DIARY_LOCATION_ID);
-// TODO:
-        sUriMatcher.addURI(Contract.AUTHORITY, "history/" + SearchManager.SUGGEST_URI_PATH_QUERY + "/", SEARCH_RECENT_SUGGESTION);
-        sUriMatcher.addURI(Contract.AUTHORITY, "history/" + SearchManager.SUGGEST_URI_PATH_QUERY + "/*", SEARCH_SUGGESTION);
-        sUriMatcher.addURI(Contract.AUTHORITY, plusPattern.matcher(Contract.DiarySearchSuggestion.CONTENT_URI.getPath()).replaceAll(""), DIARY_SUGGESTION);
-
-        /* TODO #18 */
-        sUriMatcher.addURI(Contract.AUTHORITY, "CONDITIONS", CONDITIONS);
-        sUriMatcher.addURI(Contract.AUTHORITY, "CONDITIONS/#", CONDITIONS_ID);
-
-    }
-
-    private LocalDBHelper mOpenHelper;
-
-    @Override
-    public boolean onCreate() {
-        mOpenHelper = new LocalDBHelper(getContext());
-        return true; /* successfully loaded */
-    }
-
-    @Nullable
-    @Override
-    public Cursor query(@NonNull Uri uri, @Nullable String[] projection, @Nullable String selection, @Nullable String[] selectionArgs, @Nullable String sortOrder) {
-        SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder();
-        boolean useRawQuery = false;
-        String grouping = null;
-        String sql = "";
-        Cursor c;
-        int id = 0;
-        if(selection == null){
-            selection = "";
-        }
-
-        MatrixCursor result = new MatrixCursor(new String[]{
-                BaseColumns._ID,
-                SUGGEST_COLUMN_TEXT_1,
-                SUGGEST_COLUMN_ICON_1,
-                SUGGEST_COLUMN_INTENT_ACTION,
-                SUGGEST_COLUMN_INTENT_DATA,
-                SUGGEST_COLUMN_QUERY
-        });
-
-        if (sUriMatcher.match(uri) < 1) {
-            /* URI is not recognized, return an empty Cursor */
-            result.close();
-            return null;
-        }
-        switch (sUriMatcher.match(uri)) {
-            case ACTIVITIES_ID:
-            case CONDITIONS_ID:
-            case DIARY_ID:
-            case DIARY_IMAGE_ID:
-            case DIARY_LOCATION_ID:
-                if (selection != null) {
-                    selection = selection + " AND ";
-                } else {
-                    selection = "";
-                }
-                selection = selection + "_id=" + uri.getLastPathSegment();
-            default:
-                /* empty */
-        }
-
-        switch (sUriMatcher.match(uri)) {
-            case ACTIVITIES_ID: /* intended fall through */
-            case ACTIVITIES:
-                int n;
-                boolean hasDiaryJoin = false;
-                String tables = Contract.DiaryActivity.TABLE_NAME;
-                if (TextUtils.isEmpty(sortOrder)) {
-                    sortOrder = Contract.DiaryActivity.SORT_ORDER_DEFAULT;
-                }
-                n = 0;
-                while(n < projection.length){
-                    if(Contract.DiaryActivityJoinableColumns.X_AVG_DURATION.equals(projection[n])){
-                        projection[n] = "AVG(" + Contract.DiaryColumns.END + " - "
-                                + Contract.DiaryColumns.START + ") AS "
-                                + Contract.DiaryActivityJoinableColumns.X_AVG_DURATION;
-                        hasDiaryJoin = true;
-                    }
-                    if(Contract.DiaryActivityJoinableColumns.X_START_OF_LAST.equals(projection[n])){
-                        projection[n] = "xx_start AS "
-                                + Contract.DiaryActivityJoinableColumns.X_START_OF_LAST;
-                        hasDiaryJoin = true;
-                    }
-                    n++;
-                }
-                if(hasDiaryJoin){
-                    n = 0;
-                    while(n < projection.length) {
-                        if(Contract.DiaryActivityColumns._ID.equals(projection[n])){
-                            projection[n] = Contract.DiaryActivity.TABLE_NAME + "."
-                                    + Contract.DiaryActivityColumns._ID;
-                        }
-                        n++;
-                    }
-                    selection = selection.replaceAll(" " + Contract.DiaryActivityColumns._ID, " " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID);
-                    selection = selection.replaceAll(Contract.DiaryActivityColumns._DELETED, Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._DELETED);
-
-                    tables = tables + ", " + Contract.Diary.TABLE_NAME;
-                    tables = tables + ", (SELECT xx_ref, " + Contract.DiaryColumns.START + " as xx_start FROM " + Contract.Diary.TABLE_NAME + ","
-                                    +     "(SELECT " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID + " AS xx_ref,"
-                                                 + " MAX(" + Contract.Diary.TABLE_NAME + "." + Contract.DiaryColumns.END + ") AS xx_ref_end"
-                                    +     " FROM " + Contract.DiaryActivity.TABLE_NAME + ", " + Contract.Diary.TABLE_NAME
-                                    +     " WHERE " +  Contract.Diary.TABLE_NAME + "." + Contract.DiaryColumns.ACT_ID
-                                    +           " = " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID
-                                    +     " GROUP BY " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID
-                                    +     ")"
-                                    +    " WHERE " +  Contract.Diary.TABLE_NAME + "." + Contract.DiaryColumns.END + " = xx_ref_end"
-                                    +  ")"
-                                        ;
-
-                    selection = selection + " AND " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID + " = " + Contract.Diary.TABLE_NAME + "." + Contract.DiaryColumns.ACT_ID
-                                          + " AND " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID + " = xx_ref";
-
-                    grouping = Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID;
-
-                }
-                qBuilder.setTables(tables);
-                break;
-
-            case DIARY_IMAGE_ID: /* intended fall through */
-            case DIARY_IMAGE:
-                qBuilder.setTables(Contract.DiaryImage.TABLE_NAME);
-                if (TextUtils.isEmpty(sortOrder))
-                    sortOrder = Contract.DiaryImage.SORT_ORDER_DEFAULT;
-                break;
-            case DIARY_LOCATION_ID: /* intended fall through */
-            case DIARY_LOCATION:
-                qBuilder.setTables(Contract.DiaryLocation.TABLE_NAME);
-                if (TextUtils.isEmpty(sortOrder))
-                    sortOrder = Contract.DiaryLocation.SORT_ORDER_DEFAULT;
-                break;
-            case DIARY_ID: /* intended fall through */
-            case DIARY:
-                /* rewrite projection, to prefix with tables */
-                qBuilder.setTables(Contract.Diary.TABLE_NAME + " INNER JOIN " +
-                        Contract.DiaryActivity.TABLE_NAME + " ON " +
-                        Contract.Diary.TABLE_NAME + "." + Contract.DiaryColumns.ACT_ID + " = " +
-                        Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID
-                );
-                if (TextUtils.isEmpty(sortOrder))
-                    sortOrder = Contract.Diary.SORT_ORDER_DEFAULT;
-                break;
-            case DIARY_STATS:
-                useRawQuery = true;
-                List<String> l = uri.getPathSegments();
-                String start;
-                String end;
-
-                if(l.size() == 3){
-                    // we have a range query with start and end timestamps here
-                    start = l.get(1);
-                    end = l.get(2);
-                }else{
-                    start = "0";
-                    end = "6156000000000"; // this is roughly 200 year since epoch, congratulations if this lasted so long...
-                }
-
-//                System.out.println(start + " " + end);
-                String subselect = "SELECT SUM(MIN(IFNULL(" + Contract.DiaryColumns.END + ",strftime('%s','now') * 1000), " + end + ") - "
-                        + "MAX(" + Contract.DiaryColumns.START + ", " + start + ")) from " + Contract.Diary.TABLE_NAME
-                        + " WHERE ((start >= " + start + " AND start < " + end + ") OR (end > " + start + " AND end <= " + end + ") OR (start < " + start + " AND end > " + end + "))";
-
-                if (selection != null && selection.length() > 0) {
-                    subselect += " AND (" + selection + ")";
-                }
-
-                sql = "SELECT " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityJoinableColumns.NAME + " as " + Contract.DiaryStats.NAME
-                        + ", " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityJoinableColumns.COLOR + " as " + Contract.DiaryStats.COLOR
-                        + ", SUM(MIN(IFNULL(" + Contract.DiaryColumns.END + ",strftime('%s','now') * 1000), " + end + ") - MAX(" + start + ", " + Contract.DiaryColumns.START + ")) as " + Contract.DiaryStats.DURATION
-                        + ", (SUM(MIN(IFNULL(" + Contract.DiaryColumns.END + ",strftime('%s','now') * 1000), " + end + ") - MAX(" + start + ", " + Contract.DiaryColumns.START + ")) * 100.0 " +
-                        "/ (" + subselect + ")) as " + Contract.DiaryStats.PORTION
-                        + " FROM " + Contract.Diary.TABLE_NAME + ", " + Contract.DiaryActivity.TABLE_NAME
-                        + " WHERE " + Contract.Diary.TABLE_NAME + "." + Contract.DiaryColumns.ACT_ID + " = " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID + " AND"
-                        + " ((start >= " + start + " AND start < " + end + ") OR (end > " + start + " AND end <= " + end + ") OR (start < " + start + " AND end > " + end + "))"
-                ;
-                if(selection != null && selection.length() > 0) {
-                    sql += " AND (" + selection + ")";
-                    String[] newArgs = Arrays.copyOf(selectionArgs, selectionArgs.length * 2);
-                    System.arraycopy(selectionArgs, 0, newArgs, selectionArgs.length, selectionArgs.length);
-                    selectionArgs = newArgs;
-                }
-                sql += " GROUP BY " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID;
-                if (sortOrder != null && sortOrder.length() > 0) {
-                    sql += " ORDER by " + sortOrder;
-                }
-                break;
-
-            case SEARCH_RECENT_SUGGESTION:
-
-                sql = "SELECT " + Contract.DiarySearchSuggestion.SUGGESTION + ", " +
-                        Contract.DiarySearchSuggestion.ACTION + " FROM " +
-                        Contract.DiarySearchSuggestion.TABLE_NAME +
-                        " ORDER BY " + Contract.DiarySearchSuggestion._ID + " DESC";
-
-                c = mOpenHelper.getReadableDatabase().rawQuery(sql, selectionArgs);
-                if (c != null && c.moveToFirst()) {
-                    do {
-                        Object icon = null;
-                        String action = c.getString(1);
-                        String q = c.getString(0); // what do we want to display
-
-                        switch (action) {
-                            case SEARCH_ACTIVITY:
-                                /* icon stays null */
-                                int i = Integer.parseInt(q);
-                                q = ActivityHelper.helper.activityWithId(i).getName();
-                                break;
-                            case SEARCH_NOTE:
-                                q = getContext().getResources().getString(R.string.search_notes, q);
-                                icon = R.drawable.ic_search;
-                                break;
-                            case SEARCH_GLOBAL:
-                            case Intent.ACTION_SEARCH:
-                                q = getContext().getResources().getString(R.string.search_diary, q);
-                                icon = R.drawable.ic_search;
-                                break;
-                            case SEARCH_DATE:
-                                q = getContext().getResources().getString(R.string.search_date, q);
-                                icon = R.drawable.ic_calendar;
-                                break;
-                        }
-
-                        result.addRow(new Object[]{id++,
-                                q,
-                                /* icon */ icon,
-                                /* intent action */ action,
-                                /* intent data */ Uri.withAppendedPath(SEARCH_URI, c.getString(0)),
-                                /* rewrite query */c.getString(0)
-                        });
-                    } while (c.moveToNext());
-                }
-                c.close();
-                return result;
-
-
-            case SEARCH_SUGGESTION:
-                String query = uri.getLastPathSegment(); //.toLowerCase();
-
-                if (query != null && query.length() > 0) {
-                    // ACTIVITIES matching the current search
-                    ArrayList<DiaryActivity> filtered = ActivityHelper.sortedActivities(query);
-
-                    // TODO: make the amount of ACTIVITIES shown configurable
-                    for (int i = 0; i < 3; i++) {
-                        if (i < filtered.size()) {
-                            result.addRow(new Object[]{id++,
-                                    filtered.get(i).getName(),
-                                    /* icon */ null,
-                                    /* intent action */ SEARCH_ACTIVITY,
-                                    /* intent data */ Uri.withAppendedPath(SEARCH_URI, Integer.toString(filtered.get(i).getId())),
-                                    /* rewrite query */filtered.get(i).getName()
-                            });
-                        }
-                    }
-                    // Notes
-                    result.addRow(new Object[]{id++,
-                            getContext().getResources().getString(R.string.search_notes, query),
-                            /* icon */ R.drawable.ic_search,
-                            /* intent action */ SEARCH_NOTE,
-                            /* intent data */ Uri.withAppendedPath(SEARCH_URI, query),
-                            /* rewrite query */ query
-                    });
-
-                    // Global search
-                    result.addRow(new Object[]{id++,
-                            getContext().getResources().getString(R.string.search_diary, query),
-                            /* icon */ R.drawable.ic_search,
-                            /* intent action */ SEARCH_GLOBAL,
-                            /* intent data */ Uri.withAppendedPath(SEARCH_URI, query),
-                            /* rewrite query */ query
-                    });
-
-                    // Date
-                    result.addRow(new Object[]{id++,
-                            getContext().getResources().getString(R.string.search_date, query),
-                            /* icon */ R.drawable.ic_calendar,
-                            /* intent action */ SEARCH_DATE,
-                            /* intent data */ Uri.withAppendedPath(SEARCH_URI, query),
-                            /* rewrite query */ query
-                    });
-
-                    // has Pictures
-                    // TODO: add picture search
-
-                    // Location (GPS)
-                    // TODO: add location search
-
-                }
-                return result;
-
-            case CONDITIONS_ID:
-                /* intended fall through */
-            case CONDITIONS:
-//                qBuilder.setTables(Contract.Condition.TABLE_NAME);
-                /* TODO #18               if (TextUtils.isEmpty(sortOrder)) sortOrder = Contract.Conditions.SORT_ORDER_DEFAULT; */
-            default:
-                /* empty */
-        }
-
-        if (useRawQuery) {
-            c = mOpenHelper.getReadableDatabase().rawQuery(sql, selectionArgs);
-        } else {
-            c = qBuilder.query(mOpenHelper.getReadableDatabase(),
-                    projection,
-                    selection,
-                    selectionArgs,
-                    grouping,
-                    null,
-                    sortOrder);
-        }
-        c.setNotificationUri(getContext().getContentResolver(), uri);
-        return c;
-    }
-
-    @Nullable
-    @Override
-    public String getType(@NonNull Uri uri) {
-        switch (sUriMatcher.match(uri)) {
-            case ACTIVITIES:
-                return Contract.DiaryActivity.CONTENT_TYPE;
-            case ACTIVITIES_ID:
-                return Contract.DiaryActivity.CONTENT_ITEM_TYPE;
-            case DIARY:
-                return Contract.Diary.CONTENT_TYPE;
-            case DIARY_ID:
-                return Contract.Diary.CONTENT_ITEM_TYPE;
-            case DIARY_LOCATION:
-                return Contract.DiaryLocation.CONTENT_TYPE;
-            case DIARY_LOCATION_ID:
-                return Contract.DiaryLocation.CONTENT_ITEM_TYPE;
-            case DIARY_STATS:
-                return Contract.DiaryStats.CONTENT_TYPE;
-            // TODO #18: add other types
-            default:
-                Log.e(TAG, "MIME type for " + uri.toString() + " not defined.");
-                return "";
-        }
-    }
-
-    @Nullable
-    @Override
-    public Uri insert(@NonNull Uri uri, @Nullable ContentValues values) {
-        String table;
-        Uri resultUri;
-
-        switch (sUriMatcher.match(uri)) {
-            case ACTIVITIES:
-                table = Contract.DiaryActivity.TABLE_NAME;
-                resultUri = Contract.DiaryActivity.CONTENT_URI;
-                break;
-            case DIARY:
-                table = Contract.Diary.TABLE_NAME;
-                resultUri = Contract.Diary.CONTENT_URI;
-                break;
-            case DIARY_IMAGE:
-                table = Contract.DiaryImage.TABLE_NAME;
-                resultUri = Contract.DiaryImage.CONTENT_URI;
-                break;
-            case DIARY_LOCATION:
-                table = Contract.DiaryLocation.TABLE_NAME;
-                resultUri = Contract.DiaryLocation.CONTENT_URI;
-                break;
-            case DIARY_SUGGESTION:
-                table = Contract.DiarySearchSuggestion.TABLE_NAME;
-                resultUri = Contract.DiarySearchSuggestion.CONTENT_URI;
-                break;
-            case CONDITIONS:
-//                table = Contract.Condition.TABLE_NAME;
-// TODO #18               resultUri = Contract.Condition.CONTENT_URI;
-//                break;
-            case DIARY_STATS: /* intended fall-through */
-            default:
-                throw new IllegalArgumentException(
-                        "Unsupported URI for insertion: " + uri);
-        }
-        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
-
-        db.beginTransaction();
-        long id = db.insertOrThrow(table,
-                null,
-                values);
-        db.setTransactionSuccessful();
-        db.endTransaction();
-
-        if(id > 0) {
-            resultUri = ContentUris.withAppendedId(resultUri, id);
-            getContext().
-                    getContentResolver().
-                    notifyChange(resultUri, null);
-
-            return resultUri;
-        } else {
-            throw new SQLException(
-                    "Problem while inserting into uri: " + uri + " values " + values.toString());
-        }
-    }
-
-    /**
-     * Implement this to handle requests to delete one or more rows.
-     * The implementation should apply the selection clause when performing
-     * deletion, allowing the operation to affect multiple rows in a directory.
-     * This method can be called from multiple threads, as described in
-     * <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads">Processes
-     * and Threads</a>.
-     * <p>
-     * <p>The implementation is responsible for parsing out a row ID at the end
-     * of the URI, if a specific row is being deleted. That is, the client would
-     * pass in <code>content://contacts/people/22</code> and the implementation is
-     * responsible for parsing the record number (22) when creating a SQL statement.
-     *
-     * @param uri           The full URI to query, including a row ID (if a specific record is requested).
-     * @param selection     An optional restriction to apply to rows when deleting.
-     * @param selectionArgs
-     * @return The number of rows affected.
-     * @throws SQLException
-     */
-    @Override
-    public int delete(@NonNull Uri uri, @Nullable String selection, @Nullable String[] selectionArgs) {
-        boolean isGlobalDelete = false;
-        String table;
-        ContentValues values = new ContentValues();
-        switch (sUriMatcher.match(uri)) {
-            case ACTIVITIES_ID:
-                table = Contract.DiaryActivity.TABLE_NAME;
-                break;
-            case DIARY:
-                isGlobalDelete = true;
-                /* fall though */
-            case DIARY_ID:
-                table = Contract.Diary.TABLE_NAME;
-                break;
-            case DIARY_IMAGE:
-                isGlobalDelete = true;
-                /* fall though */
-            case DIARY_IMAGE_ID:
-                table = Contract.DiaryImage.TABLE_NAME;
-                break;
-            case DIARY_LOCATION:
-                isGlobalDelete = true;
-                /* fall though */
-            case DIARY_LOCATION_ID:
-                table = Contract.DiaryLocation.TABLE_NAME;
-                break;
-            case DIARY_SUGGESTION:
-                table = Contract.DiarySearchSuggestion.TABLE_NAME;
-                SQLiteDatabase db = mOpenHelper.getWritableDatabase();
-                return db.delete(table, selection, selectionArgs);
-            case CONDITIONS_ID:
-//                table = Contract.Condition.TABLE_NAME;
-//                break;
-            case DIARY_STATS: /* intended fall-through */
-            default:
-                throw new IllegalArgumentException(
-                        "Unsupported URI for deletion: " + uri);
-        }
-        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
-        if (!isGlobalDelete) {
-            if (selection != null) {
-                selection = selection + " AND ";
-            } else {
-                selection = "";
-            }
-            selection = selection + "_id=" + uri.getLastPathSegment();
-        }
-        values.put(Contract.DiaryActivityColumns._DELETED, "1");
-
-        db.beginTransaction();
-        int upds = db.update(table,
-                values,
-                selection,
-                selectionArgs);
-        if (upds > 0) {
-            getContext().
-                    getContentResolver().
-                    notifyChange(uri, null);
-
-        } else {
-            Log.i(TAG, "Could not delete anything for uri: " + uri + " with selection '" + selection + "'");
-        }
-        db.setTransactionSuccessful();
-        db.endTransaction();
-
-        return upds;
-    }
-
-    /**
-     * Implement this to handle requests to update one or more rows.
-     * The implementation should update all rows matching the selection
-     * to set the columns according to the provided values map.
-     * This method can be called from multiple threads, as described in
-     * <a href="{@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads">Processes
-     * and Threads</a>.
-     *
-     * @param uri           The URI to query. This can potentially have a record ID if this
-     *                      is an update request for a specific record.
-     * @param values        A set of column_name/value pairs to update in the database.
-     *                      This must not be {@code null}.
-     * @param selection     An optional filter to match rows to update.
-     * @param selectionArgs
-     * @return the number of rows affected.
-     */
-    @Override
-    public int update(@NonNull Uri uri, @NonNull ContentValues values, @Nullable String selection, @Nullable String[] selectionArgs) {
-        String table;
-        boolean isID = false;
-        switch (sUriMatcher.match(uri)) {
-            case ACTIVITIES_ID:
-                isID = true;
-                table = Contract.DiaryActivity.TABLE_NAME;
-                break;
-            case DIARY_ID:
-                isID = true;
-            case DIARY:
-                table = Contract.Diary.TABLE_NAME;
-                break;
-            case DIARY_IMAGE:
-                table = Contract.DiaryImage.TABLE_NAME;
-                break;
-            case DIARY_LOCATION_ID:
-                isID = true;
-            case DIARY_LOCATION:
-                table = Contract.DiaryLocation.TABLE_NAME;
-                break;
-            case CONDITIONS_ID:
-                //                table = Contract.Condition.TABLE_NAME;
-//                break;
-            case DIARY_STATS: /* intended fall-through */
-            default:
-                throw new IllegalArgumentException(
-                        "Unsupported URI for update: " + uri);
-        }
-        SQLiteDatabase db = mOpenHelper.getWritableDatabase();
-        if (isID) {
-            if (selection != null) {
-                selection = selection + " AND ";
-            } else {
-                selection = "";
-            }
-            selection = selection + "_id=" + uri.getLastPathSegment();
-        }
-
-        int upds = db.update(table,
-                values,
-                selection,
-                selectionArgs);
-        if (upds > 0) {
-            getContext().
-                    getContentResolver().
-                    notifyChange(uri, null);
-
-        } else if (isID) {
-            throw new SQLException(
-                    "Problem while updating uri: " + uri + " with selection '" + selection + "'");
-        }
-        return upds;
-    }
-
-    public void resetDatabase() {
-        mOpenHelper.close();
-    }
-
-
-    /**
-     * Search for all dates in database which match start/end date or are in range (between start and end date)
-     * @param dateInMillis - date is searched
-     * @return query (string) with ids that fulfills defined CONDITIONS
-     */
-    @SuppressLint("Range")
-    public String searchDate(Long dateInMillis) {
-        // TODO: move this into the method query, for the case DIARY,
-        // similar to DIARY_STATS, we can modify selection and selection args there
-        // or maybe better, invent a new URI like "DIARY/number" where number is the dateInMillis
-        // Alternative: move all this directly into HistoryActivity.onCreateLoader
-
-        String querySelection = " ", id;
-        long searchedValue = dateInMillis;
-        long searchedValuePlusDay = searchedValue + 86400000; // TODO: replace magic numbers by the formula to calculate them...
-        long searchSpecialCase = searchedValue + 86399999;  //used for searching for still running activity
-
-        try (Cursor allRowsStart = mOpenHelper.getReadableDatabase().rawQuery(
-                "SELECT " + Contract.DiaryColumns._ID
-                        + " FROM " + Contract.Diary.TABLE_NAME
-                        + " WHERE " + "(" + searchedValue + " >= " + Contract.DiaryColumns.START + " AND " + searchedValue + " <= " + Contract.DiaryColumns.END + ")" + " OR " +
-                        "(" + searchedValuePlusDay + " >= " + Contract.DiaryColumns.START + " AND " + searchedValuePlusDay + " <= " + Contract.DiaryColumns.END + ")" + " OR " +
-                        "(" + searchedValue + " < " + Contract.DiaryColumns.START + " AND " + searchedValuePlusDay + " > " + Contract.DiaryColumns.END + ")" + " OR " +
-                        "(" + searchSpecialCase + " >= " + Contract.DiaryColumns.START + " AND " + Contract.DiaryColumns.END + " IS NULL" + ")", null)) {
-// TODO: -> this query should not be executed outside of the method LDContentProvider.query
-
-            if (allRowsStart.moveToFirst()) {
-                do {
-                    for (String name : allRowsStart.getColumnNames()) {
-                        id = (allRowsStart.getString(allRowsStart.getColumnIndex(name)));
-                        querySelection += querySelection.equals(" ") ? Contract.Diary.TABLE_NAME + "." + Contract.DiaryColumns._ID + " =" + id : " OR " + Contract.Diary.TABLE_NAME + "." + Contract.DiaryColumns._ID + " =" + id;
-                    }
-                } while (allRowsStart.moveToNext());
-            }
-        } catch (Exception e) {
-            // TODO: add proper exception handling. Also "Exception" seems quite generic -> catch all exceptions that can occur directly
-        }
-
-        // if there is no matching dates it returns query which links to find nothings
-        // otherwise it will return query with IDs of matching dates
-        return querySelection.equals(" ") ?  " start=null" : querySelection;
-    }
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/db/LDContentProvider.kt b/app/src/main/java/com/mdiqentw/lifedots/db/LDContentProvider.kt
new file mode 100755
index 0000000..7d61269
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/db/LDContentProvider.kt
@@ -0,0 +1,748 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2018 Bc. Ondrej Janitor
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.db
+
+import android.annotation.SuppressLint
+import android.app.SearchManager
+import android.content.*
+import android.database.Cursor
+import android.database.MatrixCursor
+import android.database.SQLException
+import android.database.sqlite.SQLiteQueryBuilder
+import android.net.Uri
+import android.provider.BaseColumns
+import android.text.TextUtils
+import android.util.Log
+import com.mdiqentw.lifedots.R
+import com.mdiqentw.lifedots.helpers.ActivityHelper
+import com.mdiqentw.lifedots.helpers.ActivityHelper.Companion.sortedActivities
+import java.util.*
+import java.util.regex.Pattern
+
+/*
+ * Why a new Content Provider for Diary Activites?
+ *
+ * According https://developer.android.com/guide/topics/providers/content-provider-creating.html
+ * we need it to do searching, synching or widget use of the data -> which in the long we all want to do.
+ *
+ * Additionally it is used as SearchProvider these days.
+ * */
+class LDContentProvider : ContentProvider() {
+    private var mOpenHelper: LocalDBHelper? = null
+    override fun onCreate(): Boolean {
+        mOpenHelper = LocalDBHelper(context)
+        return true /* successfully loaded */
+    }
+
+    override fun query(
+        uri: Uri,
+        projection: Array<String>?,
+        selection: String?,
+        selectionArgs: Array<String>?,
+        sortOrder: String?
+    ): Cursor? {
+        var selection = selection
+        var selectionArgs = selectionArgs
+        var sortOrder = sortOrder
+        val qBuilder = SQLiteQueryBuilder()
+        var useRawQuery = false
+        var grouping: String? = null
+        var sql = ""
+        val c: Cursor?
+        var id = 0
+        if (selection == null) {
+            selection = ""
+        }
+        val result = MatrixCursor(
+            arrayOf(
+                BaseColumns._ID,
+                SearchManager.SUGGEST_COLUMN_TEXT_1,
+                SearchManager.SUGGEST_COLUMN_ICON_1,
+                SearchManager.SUGGEST_COLUMN_INTENT_ACTION,
+                SearchManager.SUGGEST_COLUMN_INTENT_DATA,
+                SearchManager.SUGGEST_COLUMN_QUERY
+            )
+        )
+        if (sUriMatcher.match(uri) < 1) {
+            /* URI is not recognized, return an empty Cursor */
+            result.close()
+            return null
+        }
+        when (sUriMatcher.match(uri)) {
+            ACTIVITIES_ID, CONDITIONS_ID, DIARY_ID, DIARY_IMAGE_ID, DIARY_LOCATION_ID -> {
+                selection = "$selection AND "
+                selection = selection + "_id=" + uri.lastPathSegment
+            }
+
+            else -> {}
+        }
+        when (sUriMatcher.match(uri)) {
+            ACTIVITIES_ID, ACTIVITIES -> {
+                var n: Int
+                var hasDiaryJoin = false
+                var tables = Contract.DiaryActivity.TABLE_NAME
+                if (TextUtils.isEmpty(sortOrder)) {
+                    sortOrder = Contract.DiaryActivity.SORT_ORDER_DEFAULT
+                }
+                n = 0
+                while (n < projection!!.size) {
+                    if (Contract.DiaryActivityJoinableColumns.X_AVG_DURATION == projection[n]) {
+                        projection[n] = ("AVG(" + Contract.DiaryColumns.END + " - "
+                                + Contract.DiaryColumns.START + ") AS "
+                                + Contract.DiaryActivityJoinableColumns.X_AVG_DURATION)
+                        hasDiaryJoin = true
+                    }
+                    if (Contract.DiaryActivityJoinableColumns.X_START_OF_LAST == projection[n]) {
+                        projection[n] = ("xx_start AS "
+                                + Contract.DiaryActivityJoinableColumns.X_START_OF_LAST)
+                        hasDiaryJoin = true
+                    }
+                    n++
+                }
+                if (hasDiaryJoin) {
+                    n = 0
+                    while (n < projection.size) {
+                        if (Contract.DiaryActivityColumns._ID == projection[n]) {
+                            projection[n] = (Contract.DiaryActivity.TABLE_NAME + "."
+                                    + Contract.DiaryActivityColumns._ID)
+                        }
+                        n++
+                    }
+                    selection = selection.replace(
+                        (" " + Contract.DiaryActivityColumns._ID).toRegex(),
+                        " " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID
+                    )
+                    selection = selection.replace(
+                        Contract.DiaryActivityColumns._DELETED.toRegex(),
+                        Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._DELETED
+                    )
+                    tables = tables + ", " + Contract.Diary.TABLE_NAME
+                    tables =
+                        (tables + ", (SELECT xx_ref, " + Contract.DiaryColumns.START + " as xx_start FROM " + Contract.Diary.TABLE_NAME + ","
+                                + "(SELECT " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID + " AS xx_ref,"
+                                + " MAX(" + Contract.Diary.TABLE_NAME + "." + Contract.DiaryColumns.END + ") AS xx_ref_end"
+                                + " FROM " + Contract.DiaryActivity.TABLE_NAME + ", " + Contract.Diary.TABLE_NAME
+                                + " WHERE " + Contract.Diary.TABLE_NAME + "." + Contract.DiaryColumns.ACT_ID
+                                + " = " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID
+                                + " GROUP BY " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID
+                                + ")"
+                                + " WHERE " + Contract.Diary.TABLE_NAME + "." + Contract.DiaryColumns.END + " = xx_ref_end"
+                                + ")")
+                    selection =
+                        (selection + " AND " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID + " = " + Contract.Diary.TABLE_NAME + "." + Contract.DiaryColumns.ACT_ID
+                                + " AND " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID + " = xx_ref")
+                    grouping = Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID
+                }
+                qBuilder.tables = tables
+            }
+
+            DIARY_IMAGE_ID, DIARY_IMAGE -> {
+                qBuilder.tables = Contract.DiaryImage.TABLE_NAME
+                if (TextUtils.isEmpty(sortOrder)) sortOrder = Contract.DiaryImage.SORT_ORDER_DEFAULT
+            }
+
+            DIARY_LOCATION_ID, DIARY_LOCATION -> {
+                qBuilder.tables = Contract.DiaryLocation.TABLE_NAME
+                if (TextUtils.isEmpty(sortOrder)) sortOrder = Contract.DiaryLocation.SORT_ORDER_DEFAULT
+            }
+
+            DIARY_ID, DIARY -> {
+                /* rewrite projection, to prefix with tables */qBuilder.tables =
+                    Contract.Diary.TABLE_NAME + " INNER JOIN " +
+                            Contract.DiaryActivity.TABLE_NAME + " ON " +
+                            Contract.Diary.TABLE_NAME + "." + Contract.DiaryColumns.ACT_ID + " = " +
+                            Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID
+                if (TextUtils.isEmpty(sortOrder)) sortOrder = Contract.Diary.SORT_ORDER_DEFAULT
+            }
+
+            DIARY_STATS -> {
+                useRawQuery = true
+                val l = uri.pathSegments
+                val start: String
+                val end: String
+                if (l.size == 3) {
+                    // we have a range query with start and end timestamps here
+                    start = l[1]
+                    end = l[2]
+                } else {
+                    start = "0"
+                    end =
+                        "6156000000000" // this is roughly 200 year since epoch, congratulations if this lasted so long...
+                }
+
+//                System.out.println(start + " " + end);
+                var subselect =
+                    ("SELECT SUM(MIN(IFNULL(" + Contract.DiaryColumns.END + ",strftime('%s','now') * 1000), " + end + ") - "
+                            + "MAX(" + Contract.DiaryColumns.START + ", " + start + ")) from " + Contract.Diary.TABLE_NAME
+                            + " WHERE ((start >= " + start + " AND start < " + end + ") OR (end > " + start + " AND end <= " + end + ") OR (start < " + start + " AND end > " + end + "))")
+                if (selection.isNotEmpty()) {
+                    subselect += " AND ($selection)"
+                }
+                sql =
+                    ("SELECT " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityJoinableColumns.NAME + " as " + Contract.DiaryStats.NAME
+                            + ", " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityJoinableColumns.COLOR + " as " + Contract.DiaryStats.COLOR
+                            + ", SUM(MIN(IFNULL(" + Contract.DiaryColumns.END + ",strftime('%s','now') * 1000), " + end + ") - MAX(" + start + ", " + Contract.DiaryColumns.START + ")) as " + Contract.DiaryStats.DURATION
+                            + ", (SUM(MIN(IFNULL(" + Contract.DiaryColumns.END + ",strftime('%s','now') * 1000), " + end + ") - MAX(" + start + ", " + Contract.DiaryColumns.START + ")) * 100.0 " +
+                            "/ (" + subselect + ")) as " + Contract.DiaryStats.PORTION
+                            + " FROM " + Contract.Diary.TABLE_NAME + ", " + Contract.DiaryActivity.TABLE_NAME
+                            + " WHERE " + Contract.Diary.TABLE_NAME + "." + Contract.DiaryColumns.ACT_ID + " = " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID + " AND"
+                            + " ((start >= " + start + " AND start < " + end + ") OR (end > " + start + " AND end <= " + end + ") OR (start < " + start + " AND end > " + end + "))")
+                if (selection.isNotEmpty()) {
+                    sql += " AND ($selection)"
+                    val newArgs = Arrays.copyOf(selectionArgs!!, selectionArgs.size * 2)
+                    System.arraycopy(selectionArgs, 0, newArgs, selectionArgs.size, selectionArgs.size)
+                    selectionArgs = newArgs
+                }
+                sql += " GROUP BY " + Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivityColumns._ID
+                if (!sortOrder.isNullOrEmpty()) {
+                    sql += " ORDER by $sortOrder"
+                }
+            }
+
+            SEARCH_RECENT_SUGGESTION -> {
+                sql = "SELECT " + Contract.DiarySearchSuggestion.SUGGESTION + ", " +
+                        Contract.DiarySearchSuggestion.ACTION + " FROM " +
+                        Contract.DiarySearchSuggestion.TABLE_NAME +
+                        " ORDER BY " + Contract.DiarySearchSuggestion._ID + " DESC"
+                c = mOpenHelper!!.readableDatabase.rawQuery(sql, selectionArgs)
+                if (c != null && c.moveToFirst()) {
+                    do {
+                        var icon: Any? = null
+                        val action = c.getString(1)
+                        var q = c.getString(0) // what do we want to display
+                        when (action) {
+                            SEARCH_ACTIVITY -> {
+                                /* icon stays null */
+                                val i = q.toInt()
+                                q = ActivityHelper.helper.activityWithId(i)!!.mName
+                            }
+
+                            SEARCH_NOTE -> {
+                                q = context!!.resources.getString(R.string.search_notes, q)
+                                icon = R.drawable.ic_search
+                            }
+
+                            SEARCH_GLOBAL, Intent.ACTION_SEARCH -> {
+                                q = context!!.resources.getString(R.string.search_diary, q)
+                                icon = R.drawable.ic_search
+                            }
+
+                            SEARCH_DATE -> {
+                                q = context!!.resources.getString(R.string.search_date, q)
+                                icon = R.drawable.ic_calendar
+                            }
+                        }
+                        result.addRow(
+                            arrayOf(
+                                id++,
+                                q,  /* icon */
+                                icon,  /* intent action */
+                                action,  /* intent data */
+                                Uri.withAppendedPath(SEARCH_URI, c.getString(0)),  /* rewrite query */
+                                c.getString(0)
+                            )
+                        )
+                    } while (c.moveToNext())
+                }
+                c.close()
+                return result
+            }
+
+            SEARCH_SUGGESTION -> {
+                val query = uri.lastPathSegment //.toLowerCase();
+                if (!query.isNullOrEmpty()) {
+                    // ACTIVITIES matching the current search
+                    val filtered = sortedActivities(query)
+
+                    // TODO: make the amount of ACTIVITIES shown configurable
+                    var i = 0
+                    while (i < 3) {
+                        if (i < filtered.size) {
+                            result.addRow(
+                                arrayOf<Any?>(
+                                    id++,
+                                    filtered[i].mName,  /* icon */
+                                    null,  /* intent action */
+                                    SEARCH_ACTIVITY,  /* intent data */
+                                    Uri.withAppendedPath(
+                                        SEARCH_URI, filtered[i].mId.toString()
+                                    ),  /* rewrite query */
+                                    filtered[i].mName
+                                )
+                            )
+                        }
+                        i++
+                    }
+                    // Notes
+                    result.addRow(
+                        arrayOf<Any>(
+                            id++,
+                            context!!.resources.getString(R.string.search_notes, query),  /* icon */
+                            R.drawable.ic_search,  /* intent action */
+                            SEARCH_NOTE,  /* intent data */
+                            Uri.withAppendedPath(SEARCH_URI, query),  /* rewrite query */
+                            query
+                        )
+                    )
+
+                    // Global search
+                    result.addRow(
+                        arrayOf<Any>(
+                            id++,
+                            context!!.resources.getString(R.string.search_diary, query),  /* icon */
+                            R.drawable.ic_search,  /* intent action */
+                            SEARCH_GLOBAL,  /* intent data */
+                            Uri.withAppendedPath(SEARCH_URI, query),  /* rewrite query */
+                            query
+                        )
+                    )
+
+                    // Date
+                    result.addRow(
+                        arrayOf<Any>(
+                            id++,
+                            context!!.resources.getString(R.string.search_date, query),  /* icon */
+                            R.drawable.ic_calendar,  /* intent action */
+                            SEARCH_DATE,  /* intent data */
+                            Uri.withAppendedPath(SEARCH_URI, query),  /* rewrite query */
+                            query
+                        )
+                    )
+
+                    // has Pictures
+                    // TODO: add picture search
+
+                    // Location (GPS)
+                    // TODO: add location search
+                }
+                return result
+            }
+
+            CONDITIONS_ID, CONDITIONS -> {}
+            else -> {}
+        }
+        c = if (useRawQuery) {
+            mOpenHelper!!.readableDatabase.rawQuery(sql, selectionArgs)
+        } else {
+            qBuilder.query(
+                mOpenHelper!!.readableDatabase,
+                projection,
+                selection,
+                selectionArgs,
+                grouping,
+                null,
+                sortOrder
+            )
+        }
+        c.setNotificationUri(context!!.contentResolver, uri)
+        return c
+    }
+
+    override fun getType(uri: Uri): String {
+        return when (sUriMatcher.match(uri)) {
+            ACTIVITIES -> Contract.DiaryActivity.CONTENT_TYPE
+            ACTIVITIES_ID -> Contract.DiaryActivity.CONTENT_ITEM_TYPE
+            DIARY -> Contract.Diary.CONTENT_TYPE
+            DIARY_ID -> Contract.Diary.CONTENT_ITEM_TYPE
+            DIARY_LOCATION -> Contract.DiaryLocation.CONTENT_TYPE
+            DIARY_LOCATION_ID -> Contract.DiaryLocation.CONTENT_ITEM_TYPE
+            DIARY_STATS -> Contract.DiaryStats.CONTENT_TYPE
+            else -> {
+                Log.e(TAG, "MIME type for $uri not defined.")
+                ""
+            }
+        }
+    }
+
+    override fun insert(uri: Uri, values: ContentValues?): Uri {
+        val table: String
+        var resultUri: Uri?
+        when (sUriMatcher.match(uri)) {
+            ACTIVITIES -> {
+                table = Contract.DiaryActivity.TABLE_NAME
+                resultUri = Contract.DiaryActivity.CONTENT_URI
+            }
+
+            DIARY -> {
+                table = Contract.Diary.TABLE_NAME
+                resultUri = Contract.Diary.CONTENT_URI
+            }
+
+            DIARY_IMAGE -> {
+                table = Contract.DiaryImage.TABLE_NAME
+                resultUri = Contract.DiaryImage.CONTENT_URI
+            }
+
+            DIARY_LOCATION -> {
+                table = Contract.DiaryLocation.TABLE_NAME
+                resultUri = Contract.DiaryLocation.CONTENT_URI
+            }
+
+            DIARY_SUGGESTION -> {
+                table = Contract.DiarySearchSuggestion.TABLE_NAME
+                resultUri = Contract.DiarySearchSuggestion.CONTENT_URI
+            }
+
+            CONDITIONS, DIARY_STATS -> throw IllegalArgumentException(
+                "Unsupported URI for insertion: $uri"
+            )
+
+            else -> throw IllegalArgumentException(
+                "Unsupported URI for insertion: $uri"
+            )
+        }
+        val db = mOpenHelper!!.writableDatabase
+        db.beginTransaction()
+        val id = db.insertOrThrow(
+            table,
+            null,
+            values
+        )
+        db.setTransactionSuccessful()
+        db.endTransaction()
+        return if (id > 0) {
+            resultUri = ContentUris.withAppendedId(resultUri, id)
+            context!!.contentResolver.notifyChange(resultUri, null)
+            resultUri
+        } else {
+            throw SQLException(
+                "Problem while inserting into uri: " + uri + " values " + values.toString()
+            )
+        }
+    }
+
+    /**
+     * Implement this to handle requests to delete one or more rows.
+     * The implementation should apply the selection clause when performing
+     * deletion, allowing the operation to affect multiple rows in a directory.
+     * This method can be called from multiple threads, as described in
+     * [Processes
+ * and Threads]({@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads).
+     *
+     *
+     *
+     * The implementation is responsible for parsing out a row ID at the end
+     * of the URI, if a specific row is being deleted. That is, the client would
+     * pass in `content://contacts/people/22` and the implementation is
+     * responsible for parsing the record number (22) when creating a SQL statement.
+     *
+     * @param uri           The full URI to query, including a row ID (if a specific record is requested).
+     * @param selection     An optional restriction to apply to rows when deleting.
+     * @param selectionArgs
+     * @return The number of rows affected.
+     * @throws SQLException
+     */
+    override fun delete(uri: Uri, selection: String?, selectionArgs: Array<String>?): Int {
+        var selection = selection
+        var isGlobalDelete = false
+        val table: String
+        val values = ContentValues()
+        when (sUriMatcher.match(uri)) {
+            ACTIVITIES_ID -> table = Contract.DiaryActivity.TABLE_NAME
+            DIARY -> {
+                isGlobalDelete = true
+                table = Contract.Diary.TABLE_NAME
+            }
+
+            DIARY_ID -> table = Contract.Diary.TABLE_NAME
+            DIARY_IMAGE -> {
+                isGlobalDelete = true
+                table = Contract.DiaryImage.TABLE_NAME
+            }
+
+            DIARY_IMAGE_ID -> table = Contract.DiaryImage.TABLE_NAME
+            DIARY_LOCATION -> {
+                isGlobalDelete = true
+                table = Contract.DiaryLocation.TABLE_NAME
+            }
+
+            DIARY_LOCATION_ID -> table = Contract.DiaryLocation.TABLE_NAME
+            DIARY_SUGGESTION -> {
+                table = Contract.DiarySearchSuggestion.TABLE_NAME
+                val db = mOpenHelper!!.writableDatabase
+                return db.delete(table, selection, selectionArgs)
+            }
+
+            CONDITIONS_ID, DIARY_STATS -> throw IllegalArgumentException(
+                "Unsupported URI for deletion: $uri"
+            )
+
+            else -> throw IllegalArgumentException(
+                "Unsupported URI for deletion: $uri"
+            )
+        }
+        val db = mOpenHelper!!.writableDatabase
+        if (!isGlobalDelete) {
+            selection = if (selection != null) {
+                "$selection AND "
+            } else {
+                ""
+            }
+            selection = selection + "_id=" + uri.lastPathSegment
+        }
+        values.put(Contract.DiaryActivityColumns._DELETED, "1")
+        db.beginTransaction()
+        val upds = db.update(
+            table,
+            values,
+            selection,
+            selectionArgs
+        )
+        if (upds > 0) {
+            context!!.contentResolver.notifyChange(uri, null)
+        } else {
+            Log.i(TAG, "Could not delete anything for uri: $uri with selection '$selection'")
+        }
+        db.setTransactionSuccessful()
+        db.endTransaction()
+        return upds
+    }
+
+    /**
+     * Implement this to handle requests to update one or more rows.
+     * The implementation should update all rows matching the selection
+     * to set the columns according to the provided values map.
+     * This method can be called from multiple threads, as described in
+     * [Processes
+ * and Threads]({@docRoot}guide/topics/fundamentals/processes-and-threads.html#Threads).
+     *
+     * @param uri           The URI to query. This can potentially have a record ID if this
+     * is an update request for a specific record.
+     * @param values        A set of column_name/value pairs to update in the database.
+     * This must not be `null`.
+     * @param selection     An optional filter to match rows to update.
+     * @param selectionArgs
+     * @return the number of rows affected.
+     */
+    override fun update(uri: Uri, values: ContentValues?, selection: String?, selectionArgs: Array<out String>?): Int {
+        var selection = selection
+        val table: String
+        var isID = false
+        when (sUriMatcher.match(uri)) {
+            ACTIVITIES_ID -> {
+                isID = true
+                table = Contract.DiaryActivity.TABLE_NAME
+            }
+
+            DIARY_ID -> {
+                isID = true
+                table = Contract.Diary.TABLE_NAME
+            }
+
+            DIARY -> table = Contract.Diary.TABLE_NAME
+            DIARY_IMAGE -> table = Contract.DiaryImage.TABLE_NAME
+            DIARY_LOCATION_ID -> {
+                isID = true
+                table = Contract.DiaryLocation.TABLE_NAME
+            }
+
+            DIARY_LOCATION -> table = Contract.DiaryLocation.TABLE_NAME
+            CONDITIONS_ID, DIARY_STATS -> throw IllegalArgumentException(
+                "Unsupported URI for update: $uri"
+            )
+
+            else -> throw IllegalArgumentException(
+                "Unsupported URI for update: $uri"
+            )
+        }
+        val db = mOpenHelper!!.writableDatabase
+        if (isID) {
+            selection = if (selection != null) {
+                "$selection AND "
+            } else {
+                ""
+            }
+            selection = selection + "_id=" + uri.lastPathSegment
+        }
+        val upds = db.update(
+            table,
+            values,
+            selection,
+            selectionArgs
+        )
+        if (upds > 0) {
+            context!!.contentResolver.notifyChange(uri, null)
+        } else if (isID) {
+            throw SQLException(
+                "Problem while updating uri: $uri with selection '$selection'"
+            )
+        }
+        return upds
+    }
+
+    fun resetDatabase() {
+        mOpenHelper!!.close()
+    }
+
+    /**
+     * Search for all dates in database which match start/end date or are in range (between start and end date)
+     * @param dateInMillis - date is searched
+     * @return query (string) with ids that fulfills defined CONDITIONS
+     */
+    @SuppressLint("Range")
+    fun searchDate(dateInMillis: Long): String {
+        // TODO: move this into the method query, for the case DIARY,
+        // similar to DIARY_STATS, we can modify selection and selection args there
+        // or maybe better, invent a new URI like "DIARY/number" where number is the dateInMillis
+        // Alternative: move all this directly into HistoryActivity.onCreateLoader
+        var querySelection = " "
+        var id: String
+        val searchedValuePlusDay =
+            dateInMillis + 86400000 // TODO: replace magic numbers by the formula to calculate them...
+        val searchSpecialCase = dateInMillis + 86399999 //used for searching for still running activity
+        try {
+            mOpenHelper!!.readableDatabase.rawQuery(
+                "SELECT " + Contract.DiaryColumns._ID
+                        + " FROM " + Contract.Diary.TABLE_NAME
+                        + " WHERE " + "(" + dateInMillis + " >= " + Contract.DiaryColumns.START + " AND " + dateInMillis + " <= " + Contract.DiaryColumns.END + ")" + " OR " +
+                        "(" + searchedValuePlusDay + " >= " + Contract.DiaryColumns.START + " AND " + searchedValuePlusDay + " <= " + Contract.DiaryColumns.END + ")" + " OR " +
+                        "(" + dateInMillis + " < " + Contract.DiaryColumns.START + " AND " + searchedValuePlusDay + " > " + Contract.DiaryColumns.END + ")" + " OR " +
+                        "(" + searchSpecialCase + " >= " + Contract.DiaryColumns.START + " AND " + Contract.DiaryColumns.END + " IS NULL" + ")",
+                null
+            ).use { allRowsStart ->
+// TODO: -> this query should not be executed outside of the method LDContentProvider.query
+                if (allRowsStart.moveToFirst()) {
+                    do {
+                        for (name in allRowsStart.columnNames) {
+                            id = allRowsStart.getString(allRowsStart.getColumnIndex(name))
+                            querySelection += if (querySelection == " ") Contract.Diary.TABLE_NAME + "." + Contract.DiaryColumns._ID + " =" + id else " OR " + Contract.Diary.TABLE_NAME + "." + Contract.DiaryColumns._ID + " =" + id
+                        }
+                    } while (allRowsStart.moveToNext())
+                }
+            }
+        } catch (e: Exception) {
+            // TODO: add proper exception handling. Also "Exception" seems quite generic -> catch all exceptions that can occur directly
+        }
+
+        // if there is no matching dates it returns query which links to find nothings
+        // otherwise it will return query with IDs of matching dates
+        return if (querySelection == " ") " start=null" else querySelection
+    }
+
+    companion object {
+        private const val ACTIVITIES = 1
+        private const val ACTIVITIES_ID = 2
+        private const val CONDITIONS = 3
+        private const val CONDITIONS_ID = 4
+        private const val DIARY = 5
+        private const val DIARY_ID = 6
+        private const val DIARY_IMAGE = 7
+        private const val DIARY_IMAGE_ID = 8
+        private const val DIARY_LOCATION = 9
+        private const val DIARY_LOCATION_ID = 10
+        private const val DIARY_STATS = 11
+        private const val SEARCH_RECENT_SUGGESTION = 12
+        private const val SEARCH_SUGGESTION = 13
+        private const val DIARY_SUGGESTION = 14
+        private val TAG = LDContentProvider::class.java.name
+        const val SEARCH_ACTIVITY = "com.mdiqentw.lifedots.action.SEARCH_ACTIVITY"
+        const val SEARCH_NOTE = "com.mdiqentw.lifedots.action.SEARCH_NOTE"
+        const val SEARCH_GLOBAL = "com.mdiqentw.lifedots.action.SEARCH_GLOBAL"
+        const val SEARCH_DATE = "com.mdiqentw.lifedots.action.SEARCH_DATE"
+
+        // TODO: isn't this already somewhere else?
+        val SEARCH_URI = Uri.parse("content://" + Contract.AUTHORITY)
+        private val sUriMatcher = UriMatcher(UriMatcher.NO_MATCH)
+        private val plusPattern = Pattern.compile("^/+")
+
+        init {
+            sUriMatcher.addURI(
+                Contract.AUTHORITY,
+                plusPattern.matcher(Contract.DiaryActivity.CONTENT_URI.path!!).replaceAll(""),
+                ACTIVITIES
+            )
+            sUriMatcher.addURI(
+                Contract.AUTHORITY,
+                plusPattern.matcher(Contract.DiaryActivity.CONTENT_URI.path!!).replaceAll("") + "/#",
+                ACTIVITIES_ID
+            )
+            sUriMatcher.addURI(
+                Contract.AUTHORITY,
+                plusPattern.matcher(Contract.Diary.CONTENT_URI.path!!).replaceAll(""),
+                DIARY
+            )
+            sUriMatcher.addURI(
+                Contract.AUTHORITY,
+                plusPattern.matcher(Contract.Diary.CONTENT_URI.path!!).replaceAll("") + "/#",
+                DIARY_ID
+            )
+            sUriMatcher.addURI(
+                Contract.AUTHORITY,
+                plusPattern.matcher(Contract.DiaryImage.CONTENT_URI.path!!).replaceAll(""),
+                DIARY_IMAGE
+            )
+            sUriMatcher.addURI(
+                Contract.AUTHORITY,
+                plusPattern.matcher(Contract.DiaryImage.CONTENT_URI.path!!).replaceAll("") + "/#",
+                DIARY_IMAGE_ID
+            )
+            sUriMatcher.addURI(
+                Contract.AUTHORITY,
+                plusPattern.matcher(Contract.DiaryStats.CONTENT_URI.path!!).replaceAll(""),
+                DIARY_STATS
+            )
+            sUriMatcher.addURI(
+                Contract.AUTHORITY,
+                plusPattern.matcher(Contract.DiaryStats.CONTENT_URI.path!!).replaceAll("") + "/#/#",
+                DIARY_STATS
+            )
+            sUriMatcher.addURI(
+                Contract.AUTHORITY,
+                plusPattern.matcher(Contract.DiaryLocation.CONTENT_URI.path!!).replaceAll(""),
+                DIARY_LOCATION
+            )
+            sUriMatcher.addURI(
+                Contract.AUTHORITY,
+                plusPattern.matcher(Contract.DiaryLocation.CONTENT_URI.path!!).replaceAll("") + "/#",
+                DIARY_LOCATION_ID
+            )
+            sUriMatcher.addURI(
+                Contract.AUTHORITY,
+                plusPattern.matcher(Contract.DiaryLocation.CONTENT_URI.path!!).replaceAll(""),
+                DIARY_LOCATION
+            )
+            sUriMatcher.addURI(
+                Contract.AUTHORITY,
+                plusPattern.matcher(Contract.DiaryLocation.CONTENT_URI.path!!).replaceAll("") + "/#",
+                DIARY_LOCATION_ID
+            )
+            // TODO:
+            sUriMatcher.addURI(
+                Contract.AUTHORITY,
+                "history/" + SearchManager.SUGGEST_URI_PATH_QUERY + "/",
+                SEARCH_RECENT_SUGGESTION
+            )
+            sUriMatcher.addURI(
+                Contract.AUTHORITY,
+                "history/" + SearchManager.SUGGEST_URI_PATH_QUERY + "/*",
+                SEARCH_SUGGESTION
+            )
+            sUriMatcher.addURI(
+                Contract.AUTHORITY,
+                plusPattern.matcher(Contract.DiarySearchSuggestion.CONTENT_URI.path!!).replaceAll(""),
+                DIARY_SUGGESTION
+            )
+
+            /* TODO #18 */sUriMatcher.addURI(Contract.AUTHORITY, "CONDITIONS", CONDITIONS)
+            sUriMatcher.addURI(Contract.AUTHORITY, "CONDITIONS/#", CONDITIONS_ID)
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/db/LocalDBHelper.java b/app/src/main/java/com/mdiqentw/lifedots/db/LocalDBHelper.java
deleted file mode 100644
index de9bc06..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/db/LocalDBHelper.java
+++ /dev/null
@@ -1,213 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- * Copyright (C) 2018 Bc. Ondrej Janitor
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots.db;
-
-import android.content.Context;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteOpenHelper;
-import android.graphics.Color;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-public class LocalDBHelper extends SQLiteOpenHelper {
-
-    public LocalDBHelper(Context context) {
-        super(context, Contract.AUTHORITY, null, CURRENT_VERSION);
-    }
-
-    @Override
-    public void onCreate(SQLiteDatabase db) {
-        createTablesForVersion(db);
-
-        /* now fill some sample data */
-        db.execSQL("INSERT INTO " +
-                Contract.DiaryActivity.TABLE_NAME +
-                "(" + Contract.DiaryActivityJoinableColumns.NAME + "," + Contract.DiaryActivityJoinableColumns.COLOR + ")" +
-                " VALUES " +
-                " ('', '" + Color.parseColor("#fbc02d") + "');");
-        db.execSQL("INSERT INTO " +
-                Contract.DiaryActivity.TABLE_NAME +
-                "(" + Contract.DiaryActivityJoinableColumns.NAME + "," + Contract.DiaryActivityJoinableColumns.COLOR + ")" +
-                " VALUES " +
-                " ('  ', '" + Color.parseColor("#0bc02d") + "');");
-        db.execSQL("INSERT INTO " +
-                Contract.DiaryActivity.TABLE_NAME +
-                "(" + Contract.DiaryActivityJoinableColumns.NAME + "," + Contract.DiaryActivityJoinableColumns.COLOR + ")" +
-                " VALUES " +
-                " ('Eat', '" + Color.parseColor("#e64a19") + "');");
-        db.execSQL("INSERT INTO " +
-                Contract.DiaryActivity.TABLE_NAME +
-                "(" + Contract.DiaryActivityJoinableColumns.NAME + "," + Contract.DiaryActivityJoinableColumns.COLOR + ")" +
-                " VALUES " +
-                " ('', '" + Color.parseColor("#CFD8DC") + "');");
-        db.execSQL("INSERT INTO " +
-                Contract.DiaryActivity.TABLE_NAME +
-                "(" + Contract.DiaryActivityJoinableColumns.NAME + "," + Contract.DiaryActivityJoinableColumns.COLOR + ")" +
-                " VALUES " +
-                " ('', '" + Color.parseColor("#303f9f") + "');");
-    }
-
-    public static final int CURRENT_VERSION = 5;
-/*
-    For debugging sometimes it is handy to drop a table again. This can easily be achieved in onDowngrade,
-    after CURRENT_VERSION is decremented again
-
-    @Override
-    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-        db.execSQL("DROP TABLE diary_search_suggestions");
-    }
-*/
-    @Override
-    public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {
-        /**
-         * The SQLite ALTER TABLE documentation can be found
-         * <a href="http://sqlite.org/lang_altertable.html">here</a>. If you add new columns
-         * you can use ALTER TABLE to insert them into a live table. If you rename or remove columns
-         * you can use ALTER TABLE to rename the old table, then create the new table and then
-         * populate the new table with the contents of the old table.
-         */
-        if (oldVersion == 1) {
-            /* upgrade from 1 to current */
-            /* still alpha, so just delete and restart */
-            /* do not use synmbolic names here, because in case of later rename the old names shall be dropped */
-            db.execSQL("DROP TABLE activity");
-            db.execSQL("DROP TABLE activity_alias");
-            db.execSQL("DROP TABLE condition");
-            db.execSQL("DROP TABLE conditions_map");
-            db.execSQL("DROP TABLE diary");
-            onCreate(db);
-            oldVersion = CURRENT_VERSION;
-        }
-        if (oldVersion < 3) {
-            /* upgrade from 2 to 3 */
-            createDiaryImageTable(db);
-        }
-        if (oldVersion < 4) {
-            /* upgrade from 3 to 4 */
-            createDiaryLocationTable(db);
-        }
-
-        if (oldVersion < 5) {
-            /* upgrade from 4 to 5 */
-            createRecentSuggestionsTable(db);
-        }
-
-        if (newVersion > 5) {
-            throw new RuntimeException("Database upgrade to version " + newVersion + " nyi.");
-        }
-    }
-
-    private void createDiaryLocationTable(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE " +
-                Contract.DiaryLocation.TABLE_NAME + " " +
-                "(" +
-                "_id INTEGER PRIMARY KEY ASC, " +
-                "_deleted INTEGER DEFAULT 0, " +
-                "ts INTEGER NOT NULL, " +
-                "latitude REAL NOT NULL, " +
-                "longitude REAL NOT NULL, " +
-                "altitude REAL DEFAULT NULL, " +
-                "speed INTEGER DEFAULT NULL," +
-                "hacc INTEGER DEFAULT NULL, " +
-                "vacc INTEGER DEFAULT NULL, " +
-                "sacc INTEGER DEFAULT NULL " +
-                ");");
-    }
-
-    private static void createDiaryImageTable(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE " +
-                "diary_image " +
-                "(" +
-                "_id INTEGER PRIMARY KEY ASC, " +
-                "_deleted INTEGER DEFAULT 0, " +
-                "diary_id INTEGER NOT NULL, " +
-                "uri TEXT NOT NULL, " +
-                " FOREIGN KEY(diary_id) REFERENCES diary(_id)" +
-                ");");
-    }
-
-    private static void createRecentSuggestionsTable(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE " +
-                "diary_search_suggestions" +
-                "(" +
-                "_id INTEGER PRIMARY KEY ASC, " +
-                "_deleted INTEGER DEFAULT 0, " +
-//                "action TEXT NOT NULL, " +
-                "suggestion TEXT NOT NULL " +
-                ");");
-    }
-
-    private void createTablesForVersion(SQLiteDatabase db) {
-        db.execSQL("CREATE TABLE " +
-                "activity " +
-                "(" +
-                "_id INTEGER PRIMARY KEY ASC, " +
-                "_deleted INTEGER DEFAULT 0, " +
-                "name TEXT NOT NULL UNIQUE," +
-                "color INTEGER," +
-                "parent INTEGER " +
-                ");");
-
-        db.execSQL("CREATE TABLE " +
-                "diary" +
-                "(" +
-                "_id INTEGER PRIMARY KEY ASC, " +
-                "_deleted INTEGER DEFAULT 0," +
-                "act_id INTEGER NOT NULL, " +
-                "start INTEGER NOT NULL, " +
-                "'end' INTEGER DEFAULT NULL, " +
-                "note TEXT, " +
-                " FOREIGN KEY(act_id) REFERENCES activity(_id) " +
-                ");");
-
-        if (LocalDBHelper.CURRENT_VERSION >= 3) {
-            createDiaryImageTable(db);
-        }
-
-        if (LocalDBHelper.CURRENT_VERSION >= 4) {
-            createDiaryLocationTable(db);
-        }
-
-        if (LocalDBHelper.CURRENT_VERSION >= 5) {
-            createRecentSuggestionsTable(db);
-        }
-
-    }
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/db/LocalDBHelper.kt b/app/src/main/java/com/mdiqentw/lifedots/db/LocalDBHelper.kt
new file mode 100755
index 0000000..30b046b
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/db/LocalDBHelper.kt
@@ -0,0 +1,199 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2018 Bc. Ondrej Janitor
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.db
+
+import android.content.Context
+import android.database.sqlite.SQLiteDatabase
+import android.database.sqlite.SQLiteOpenHelper
+import android.graphics.Color
+
+class LocalDBHelper(context: Context?) : SQLiteOpenHelper(context, Contract.AUTHORITY, null, CURRENT_VERSION) {
+    override fun onCreate(db: SQLiteDatabase) {
+        createTablesForVersion(db)
+
+        /* now fill some sample data */db.execSQL(
+            "INSERT INTO " +
+                    Contract.DiaryActivity.TABLE_NAME +
+                    "(" + Contract.DiaryActivityJoinableColumns.NAME + "," + Contract.DiaryActivityJoinableColumns.COLOR + ")" +
+                    " VALUES " +
+                    " ('', '" + Color.parseColor("#fbc02d") + "');"
+        )
+        db.execSQL(
+            "INSERT INTO " +
+                    Contract.DiaryActivity.TABLE_NAME +
+                    "(" + Contract.DiaryActivityJoinableColumns.NAME + "," + Contract.DiaryActivityJoinableColumns.COLOR + ")" +
+                    " VALUES " +
+                    " ('  ', '" + Color.parseColor("#0bc02d") + "');"
+        )
+        db.execSQL(
+            "INSERT INTO " +
+                    Contract.DiaryActivity.TABLE_NAME +
+                    "(" + Contract.DiaryActivityJoinableColumns.NAME + "," + Contract.DiaryActivityJoinableColumns.COLOR + ")" +
+                    " VALUES " +
+                    " ('Eat', '" + Color.parseColor("#e64a19") + "');"
+        )
+        db.execSQL(
+            "INSERT INTO " +
+                    Contract.DiaryActivity.TABLE_NAME +
+                    "(" + Contract.DiaryActivityJoinableColumns.NAME + "," + Contract.DiaryActivityJoinableColumns.COLOR + ")" +
+                    " VALUES " +
+                    " ('', '" + Color.parseColor("#CFD8DC") + "');"
+        )
+        db.execSQL(
+            "INSERT INTO " +
+                    Contract.DiaryActivity.TABLE_NAME +
+                    "(" + Contract.DiaryActivityJoinableColumns.NAME + "," + Contract.DiaryActivityJoinableColumns.COLOR + ")" +
+                    " VALUES " +
+                    " ('', '" + Color.parseColor("#303f9f") + "');"
+        )
+    }
+
+    /*
+    For debugging sometimes it is handy to drop a table again. This can easily be achieved in onDowngrade,
+    after CURRENT_VERSION is decremented again
+
+    @Override
+    public void onDowngrade(SQLiteDatabase db, int oldVersion, int newVersion) {
+        db.execSQL("DROP TABLE diary_search_suggestions");
+    }
+*/
+    override fun onUpgrade(db: SQLiteDatabase, oldVersion: Int, newVersion: Int) {
+        /**
+         * The SQLite ALTER TABLE documentation can be found
+         * [here](http://sqlite.org/lang_altertable.html). If you add new columns
+         * you can use ALTER TABLE to insert them into a live table. If you rename or remove columns
+         * you can use ALTER TABLE to rename the old table, then create the new table and then
+         * populate the new table with the contents of the old table.
+         */
+        var oldVersion = oldVersion
+        if (oldVersion == 1) {
+            /* upgrade from 1 to current */
+            /* still alpha, so just delete and restart */
+            /* do not use synmbolic names here, because in case of later rename the old names shall be dropped */
+            db.execSQL("DROP TABLE activity")
+            db.execSQL("DROP TABLE activity_alias")
+            db.execSQL("DROP TABLE condition")
+            db.execSQL("DROP TABLE conditions_map")
+            db.execSQL("DROP TABLE diary")
+            onCreate(db)
+            oldVersion = CURRENT_VERSION
+        }
+        if (oldVersion < 3) {
+            /* upgrade from 2 to 3 */
+            createDiaryImageTable(db)
+        }
+        if (oldVersion < 4) {
+            /* upgrade from 3 to 4 */
+            createDiaryLocationTable(db)
+        }
+        if (oldVersion < 5) {
+            /* upgrade from 4 to 5 */
+            createRecentSuggestionsTable(db)
+        }
+        if (newVersion > 5) {
+            throw RuntimeException("Database upgrade to version $newVersion nyi.")
+        }
+    }
+
+    private fun createDiaryLocationTable(db: SQLiteDatabase) {
+        db.execSQL(
+            "CREATE TABLE " +
+                    Contract.DiaryLocation.TABLE_NAME + " " +
+                    "(" +
+                    "_id INTEGER PRIMARY KEY ASC, " +
+                    "_deleted INTEGER DEFAULT 0, " +
+                    "ts INTEGER NOT NULL, " +
+                    "latitude REAL NOT NULL, " +
+                    "longitude REAL NOT NULL, " +
+                    "altitude REAL DEFAULT NULL, " +
+                    "speed INTEGER DEFAULT NULL," +
+                    "hacc INTEGER DEFAULT NULL, " +
+                    "vacc INTEGER DEFAULT NULL, " +
+                    "sacc INTEGER DEFAULT NULL " +
+                    ");"
+        )
+    }
+
+    private fun createTablesForVersion(db: SQLiteDatabase) {
+        db.execSQL(
+            "CREATE TABLE " +
+                    "activity " +
+                    "(" +
+                    "_id INTEGER PRIMARY KEY ASC, " +
+                    "_deleted INTEGER DEFAULT 0, " +
+                    "name TEXT NOT NULL UNIQUE," +
+                    "color INTEGER," +
+                    "parent INTEGER " +
+                    ");"
+        )
+        db.execSQL(
+            "CREATE TABLE " +
+                    "diary" +
+                    "(" +
+                    "_id INTEGER PRIMARY KEY ASC, " +
+                    "_deleted INTEGER DEFAULT 0," +
+                    "act_id INTEGER NOT NULL, " +
+                    "start INTEGER NOT NULL, " +
+                    "'end' INTEGER DEFAULT NULL, " +
+                    "note TEXT, " +
+                    " FOREIGN KEY(act_id) REFERENCES activity(_id) " +
+                    ");"
+        )
+        if (CURRENT_VERSION >= 3) {
+            createDiaryImageTable(db)
+        }
+        if (CURRENT_VERSION >= 4) {
+            createDiaryLocationTable(db)
+        }
+        if (CURRENT_VERSION >= 5) {
+            createRecentSuggestionsTable(db)
+        }
+    }
+
+    companion object {
+        const val CURRENT_VERSION = 5
+        private fun createDiaryImageTable(db: SQLiteDatabase) {
+            db.execSQL(
+                "CREATE TABLE " +
+                        "diary_image " +
+                        "(" +
+                        "_id INTEGER PRIMARY KEY ASC, " +
+                        "_deleted INTEGER DEFAULT 0, " +
+                        "diary_id INTEGER NOT NULL, " +
+                        "uri TEXT NOT NULL, " +
+                        " FOREIGN KEY(diary_id) REFERENCES diary(_id)" +
+                        ");"
+            )
+        }
+
+        private fun createRecentSuggestionsTable(db: SQLiteDatabase) {
+            db.execSQL(
+                "CREATE TABLE " +
+                        "diary_search_suggestions" +
+                        "(" +
+                        "_id INTEGER PRIMARY KEY ASC, " +
+                        "_deleted INTEGER DEFAULT 0, " +  //                "action TEXT NOT NULL, " +
+                        "suggestion TEXT NOT NULL " +
+                        ");"
+            )
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/helpers/ActivityHelper.java b/app/src/main/java/com/mdiqentw/lifedots/helpers/ActivityHelper.java
deleted file mode 100644
index a53cd18..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/helpers/ActivityHelper.java
+++ /dev/null
@@ -1,692 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- * Copyright (C) 2018 Bc. Ondrej Janitor
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots.helpers;
-
-import android.annotation.SuppressLint;
-import android.content.AsyncQueryHandler;
-import android.content.ContentProviderClient;
-import android.content.ContentResolver;
-import android.content.ContentUris;
-import android.content.ContentValues;
-import android.database.Cursor;
-import android.net.Uri;
-import android.os.Build;
-import android.os.Handler;
-import android.os.Looper;
-import android.os.Message;
-import android.util.Log;
-
-import androidx.annotation.Nullable;
-import androidx.preference.PreferenceManager;
-
-import com.mdiqentw.lifedots.MVApplication;
-import com.mdiqentw.lifedots.db.Contract;
-import com.mdiqentw.lifedots.db.LDContentProvider;
-import com.mdiqentw.lifedots.model.DiaryActivity;
-import com.mdiqentw.lifedots.model.conditions.AlphabeticalCondition;
-import com.mdiqentw.lifedots.model.conditions.Condition;
-import com.mdiqentw.lifedots.model.conditions.GlobalOccurrenceCondition;
-import com.mdiqentw.lifedots.model.conditions.RecentOccurrenceCondition;
-import com.mdiqentw.lifedots.ui.settings.SettingsActivity;
-
-import java.util.ArrayList;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.Date;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Locale;
-import java.util.Objects;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
- * Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-/**
- * provide a smooth interface to an OO abstraction of the data for our diary.
- */
-public class ActivityHelper extends AsyncQueryHandler{
-    private static final String TAG = ActivityHelper.class.getName();
-
-    private static final int QUERY_ALL_ACTIVITIES = 0;
-    private static final int UPDATE_CLOSE_ACTIVITY = 1;
-    private static final int INSERT_NEW_DIARY_ENTRY = 2;
-    private static final int UPDATE_ACTIVITY = 3;
-    private static final int INSERT_NEW_ACTIVITY = 4;
-    private static final int UPDATE_DELETE_ACTIVITY = 5;
-    private static final int QUERY_CURRENT_ACTIVITY = 6;
-    private static final int DELETE_LAST_DIARY_ENTRY = 7;
-    private static final int REOPEN_LAST_DIARY_ENTRY = 8;
-    private static final int UNDELETE_ACTIVITY = 9;
-
-    private static final String[] DIARY_PROJ = new String[] {
-            Contract.Diary.ACT_ID,
-            Contract.Diary.START,
-            Contract.Diary.END,
-            Contract.Diary.TABLE_NAME + "." + Contract.Diary._ID,
-            Contract.Diary.NOTE
-    };
-    private static final String[] ACTIVITIES_PROJ = new String[] {
-            Contract.DiaryActivity._ID,
-            Contract.DiaryActivity.NAME,
-            Contract.DiaryActivity.COLOR
-    };
-    private static final String SELECTION = Contract.DiaryActivity._DELETED + "=0";
-
-    public static final ActivityHelper helper = new ActivityHelper();
-
-    /* list of all activities, not including deleted ones */
-    private List<DiaryActivity> activities;
-    /* unsortedActivities is not allowed to be modified */
-    private final List<DiaryActivity> unsortedActivities;
-
-    private DiaryActivity mCurrentActivity = null;
-    final Date mCurrentActivityStartTime;
-    private @Nullable Uri mCurrentDiaryUri;
-    private /* @NonNull */ String mCurrentNote;
-    private final Condition[] conditions;
-
-//    private DetailViewModel viewModel;
-
-    private final Handler mHandler = new Handler(Looper.getMainLooper()) {
-        /*
-         * handleMessage() defines the operations to perform when
-         * the Handler receives a new Message to process.
-         */
-        @Override
-        public void handleMessage(Message inputMessage) {
-            // so far we only have one message here so no need to look at the details
-            // just assume that at least one Condition evaluation is finished and we check
-            // whether all are done
-            boolean allDone = true;
-            for(Condition c:conditions){
-                if(c.isActive()){
-                    allDone = false;
-                    break;
-                }
-            }
-            if(allDone) {
-                reorderActivites();
-            }
-        }
-
-    };
-
-    /* to be used only in the UI thread, consider getActivitiesCopy() */
-    public List<DiaryActivity> getActivities() {
-        return activities;
-    }
-
-    /* get a list of the activities as non-modifable copy, not guaranteed to be up to date */
-    public List<DiaryActivity> getUnsortedActivities() {
-        List<DiaryActivity> result = new ArrayList<>(unsortedActivities.size());
-        synchronized (this){
-            if(unsortedActivities.isEmpty()){
-                /* activities not yet loaded, so it doesn't make sense yet to read the activities */
-                try {
-                    Thread.sleep(50);
-                } catch (InterruptedException e) {
-                    /* intended empty */
-                }
-            }
-
-            result.addAll(unsortedActivities);
-        }
-        return result;
-    }
-
-    public static ArrayList<DiaryActivity> sortedActivities(String query) {
-        ArrayList<DiaryActivity> filtered = new ArrayList<>(ActivityHelper.helper.activities.size());
-        ArrayList<Integer> filteredDist = new ArrayList<>(ActivityHelper.helper.activities.size());
-        for(DiaryActivity a : ActivityHelper.helper.activities){
-            int dist = ActivityHelper.searchDistance(query, a.getName());
-            int pos = 0;
-            // search where to enter it
-            for(Integer i : filteredDist){
-                if(dist > i){
-                    pos++;
-                }else{
-                    break;
-                }
-            }
-            filteredDist.add(pos, dist);
-            filtered.add(pos, a);
-        }
-        return filtered;
-    }
-
-    public interface DataChangedListener{
-        /**
-         * Called when the data has changed and no further specification is possible.
-         * => everything needs to be refreshed!
-         */
-        void onActivityDataChanged();
-
-        /**
-         * Called when the data of one activity was changed.
-         */
-        void onActivityDataChanged(DiaryActivity activity);
-
-        /**
-         * Called on addition of an activity.
-         */
-        void onActivityAdded(DiaryActivity activity);
-
-        /**
-         * Called on removal of an activity.
-         */
-        void onActivityRemoved(DiaryActivity activity);
-
-        /**
-         * Called on change of the current activity.
-         */
-        void onActivityChanged();
-
-        /**
-         * Called on change of the activity order due to likelyhood.
-         */
-        void onActivityOrderChanged();
-
-    }
-    private final List<DataChangedListener> mDataChangeListeners;
-
-    public void registerDataChangeListener(DataChangedListener listener){
-        mDataChangeListeners.add(listener);
-    }
-
-    public void unregisterDataChangeListener(DataChangedListener listener){
-        mDataChangeListeners.remove(listener);
-    }
-
-    /* Access only allowed via ActivityHelper.helper singleton */
-    private ActivityHelper(){
-        super(MVApplication.getAppContext().getContentResolver());
-        mDataChangeListeners = new ArrayList<>(3);
-        activities = new ArrayList<>(50);
-        unsortedActivities = new ArrayList<>(50);
-
-        conditions = new Condition[]{
-                new AlphabeticalCondition(this),
-                new GlobalOccurrenceCondition(this),
-                new RecentOccurrenceCondition(this),
-        };
-        reloadAll();
-
-        LocationHelper.helper.updateLocation();
-        mCurrentActivityStartTime = new Date();
-    }
-
-    /* reload all the activities from the database */
-    public void reloadAll(){
-        ContentResolver resolver = MVApplication.getAppContext().getContentResolver();
-        ContentProviderClient client = resolver.acquireContentProviderClient(Contract.AUTHORITY);
-        LDContentProvider provider = (LDContentProvider) client.getLocalContentProvider();
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
-            client.close();
-        } else {
-            client.release();
-        }
-        provider.resetDatabase();
-
-        startQuery(QUERY_ALL_ACTIVITIES, null, Contract.DiaryActivity.CONTENT_URI,
-                ACTIVITIES_PROJ, SELECTION, null,
-                null);
-    }
-
-    /* start the query to read the current activity
-     * will trigger the update of currentActivity and send notifications afterwards */
-    public void readCurrentActivity() {
-        startQuery(QUERY_CURRENT_ACTIVITY, null, Contract.Diary.CONTENT_URI,
-                DIARY_PROJ, Contract.Diary.START + " = (SELECT MAX("
-                + Contract.Diary.START + ") FROM "
-                + Contract.Diary.TABLE_NAME + " WHERE " + SELECTION +")"
-                , null,
-                Contract.Diary.START + " DESC");
-    }
-
-    @SuppressLint("Range")
-    @Override
-    protected void onQueryComplete(int token, Object cookie,
-                                   Cursor cursor) {
-        if ((cursor != null) && cursor.moveToFirst()) {
-            if (token == QUERY_ALL_ACTIVITIES) {
-                synchronized (this) {
-                    activities.clear();
-                    unsortedActivities.clear();
-                    while (!cursor.isAfterLast()) {
-                        DiaryActivity act = new DiaryActivity(cursor.getInt(cursor.getColumnIndex(Contract.DiaryActivity._ID)),
-                                cursor.getString(cursor.getColumnIndex(Contract.DiaryActivity.NAME)),
-                                cursor.getInt(cursor.getColumnIndex(Contract.DiaryActivity.COLOR)));
-                        /* TODO: optimize by keeping a map with id as key and the DiaryActivities */
-                        activities.add(act);
-                        unsortedActivities.add(act);
-                        cursor.moveToNext();
-                    }
-                }
-                readCurrentActivity();
-                for (DataChangedListener listener : mDataChangeListeners) {
-                    listener.onActivityDataChanged();
-                }
-            } else if (token == QUERY_CURRENT_ACTIVITY) {
-                if (!cursor.isNull(cursor.getColumnIndex(Contract.Diary.END))) {
-                    /* no current activity */
-                    mCurrentNote = "";
-                    mCurrentDiaryUri = null;
-                    mCurrentActivityStartTime.setTime(cursor.getLong(cursor.getColumnIndex(Contract.Diary.END)));
-                } else {
-                    mCurrentActivity = activityWithId(cursor.getInt(cursor.getColumnIndex(Contract.Diary.ACT_ID)));
-                    mCurrentActivityStartTime.setTime(cursor.getLong(cursor.getColumnIndex(Contract.Diary.START)));
-                    mCurrentNote = cursor.getString(cursor.getColumnIndex(Contract.Diary.NOTE));
-                    mCurrentDiaryUri = Uri.withAppendedPath(Contract.Diary.CONTENT_URI,
-                                        Long.toString(cursor.getLong(cursor.getColumnIndex(Contract.Diary._ID))));
-
-                }
-//                showCurrentActivityNotification();
-
-                for (DataChangedListener listener : mDataChangeListeners) {
-                    listener.onActivityChanged();
-                }
-            } else if (token == UNDELETE_ACTIVITY){
-
-                DiaryActivity act = (DiaryActivity)cookie;
-                act.setColor(cursor.getInt(cursor.getColumnIndex(Contract.DiaryActivity.COLOR)));
-                act.setName(cursor.getString(cursor.getColumnIndex(Contract.DiaryActivity.NAME)));
-                act.setId(cursor.getInt(cursor.getColumnIndex(Contract.DiaryActivity._ID)));
-
-                for(DataChangedListener listener : mDataChangeListeners) {
-                    // notify about the (re-)added activity
-                    listener.onActivityAdded(act);
-                }
-
-            }
-        }
-        if (cursor != null) {
-            cursor.close();
-        }
-    }
-
-    public DiaryActivity getCurrentActivity(){
-        return mCurrentActivity;
-    }
-    public Date getCurrentActivityStartTime() { return mCurrentActivityStartTime;}
-    public String getCurrentNote() { return mCurrentNote;}
-    public void setCurrentNote(String str) { mCurrentNote = str;}
-
-    public void setCurrentActivity(@Nullable DiaryActivity activity){
-        /* update the current diary entry to "finish" it
-         * in theory there should be only one entry with end = NULL in the diary table
-         * but who knows? -> Let's update all. */
-        if(mCurrentActivity != activity) {
-            ContentValues values = new ContentValues();
-            Long timestamp = System.currentTimeMillis();
-            values.put(Contract.Diary.END, timestamp);
-
-            startUpdate(UPDATE_CLOSE_ACTIVITY, timestamp, Contract.Diary.CONTENT_URI,
-                    values, Contract.Diary.END + " is NULL", null);
-
-            mCurrentActivity = activity;
-            mCurrentDiaryUri = null;
-            mCurrentActivityStartTime.setTime(timestamp);
-            mCurrentNote = "";
-            if(mCurrentActivity == null){
-                // activity terminated, so we have to notify here...
-                for(DataChangedListener listener : mDataChangeListeners) {
-                    listener.onActivityChanged();
-                }
-            }
-            LocationHelper.helper.updateLocation();
-//            showCurrentActivityNotification();
-        }
-    }
-
-    /* undo the last activity selection by deleteing all open entries
-     *
-     * */
-    public void undoLastActivitySelection() {
-        if(mCurrentActivity != null) {
-            startDelete(DELETE_LAST_DIARY_ENTRY, null,
-                    Contract.Diary.CONTENT_URI,
-                    Contract.Diary.END + " is NULL",
-                    null);
-        }
-    }
-
-    @Override
-    protected void onUpdateComplete(int token, Object cookie, int result) {
-        if(token == UPDATE_CLOSE_ACTIVITY) {
-            if(mCurrentActivity != null) {
-                /* create a new diary entry */
-                ContentValues values = new ContentValues();
-
-                values.put(Contract.Diary.ACT_ID, mCurrentActivity.getId());
-                values.put(Contract.Diary.START, (Long)cookie);
-
-                startInsert(INSERT_NEW_DIARY_ENTRY, cookie, Contract.Diary.CONTENT_URI,
-                        values);
-            }
-        }else if(token == UPDATE_ACTIVITY){
-            for(DataChangedListener listener : mDataChangeListeners) {
-                listener.onActivityDataChanged((DiaryActivity)cookie);
-            }
-        }else if(token == REOPEN_LAST_DIARY_ENTRY){
-            mCurrentActivity = null;
-            readCurrentActivity();
-        }else if(token == UNDELETE_ACTIVITY){
-            DiaryActivity act = (DiaryActivity)cookie;
-
-            startQuery(UNDELETE_ACTIVITY, cookie,
-                    Contract.DiaryActivity.CONTENT_URI,
-                    ACTIVITIES_PROJ, Contract.DiaryActivity._ID + " = " + act.getId(),
-                    null,
-                    null);
-        }
-    }
-
-
-    @Override
-    protected void onDeleteComplete(int token, Object cookie, int result) {
-        if(token == DELETE_LAST_DIARY_ENTRY){
-            ContentValues values = new ContentValues();
-            values.putNull(Contract.Diary.END);
-
-            startUpdate(REOPEN_LAST_DIARY_ENTRY, null,
-                    Contract.Diary.CONTENT_URI,
-                    values,
-                    Contract.Diary.END + "=(SELECT MAX(" + Contract.Diary.END + ") FROM " + Contract.Diary.TABLE_NAME + " )",
-                    null
-            );
-        }
-    }
-
-    @Override
-    protected void onInsertComplete(int token, Object cookie, Uri uri) {
-        if (token == INSERT_NEW_DIARY_ENTRY) {
-            mCurrentDiaryUri = uri;
-            for(DataChangedListener listener : mDataChangeListeners) {
-                listener.onActivityChanged();
-            }
-
-        } else if (token == INSERT_NEW_ACTIVITY) {
-
-            DiaryActivity act = (DiaryActivity)cookie;
-            act.setId(Integer.parseInt(uri.getLastPathSegment()));
-            synchronized (this) {
-                activities.add(act);
-                unsortedActivities.add(act);
-            }
-            for(DataChangedListener listener : mDataChangeListeners) {
-                listener.onActivityAdded(act);
-            }
-            if(PreferenceManager
-                    .getDefaultSharedPreferences(MVApplication.getAppContext())
-                    .getBoolean(SettingsActivity.KEY_PREF_AUTO_SELECT, true)){
-                setCurrentActivity(act);
-            }
-        }
-    }
-
-    public void updateActivity(DiaryActivity act) {
-        startUpdate(UPDATE_ACTIVITY,
-                act,
-                ContentUris.withAppendedId(Contract.DiaryActivity.CONTENT_URI, act.getId()),
-                contentFor(act),
-                null,
-                null);
-
-        for(DataChangedListener listener : mDataChangeListeners) {
-            listener.onActivityDataChanged(act);
-        }
-    }
-
-    /* undelete an activity with given ID */
-    public DiaryActivity undeleteActivity(int id, String name){
-        DiaryActivity result = new DiaryActivity(id, name, 0);
-        ContentValues values = new ContentValues();
-        values.put(Contract.Diary._DELETED, 0);
-
-        startUpdate(UNDELETE_ACTIVITY, result, Contract.Diary.CONTENT_URI,
-                values, Contract.Diary._ID + " = " + id, null);
-
-        activities.add(result);
-        unsortedActivities.add(result);
-        return result;
-    }
-
-    /* inserts a new activity and sets it as the current one if configured in the preferences */
-    public void insertActivity(DiaryActivity act){
-        startInsert(INSERT_NEW_ACTIVITY,
-                act,
-                Contract.DiaryActivity.CONTENT_URI,
-                contentFor(act));
-    }
-
-    public void deleteActivity(DiaryActivity act) {
-        if(act == mCurrentActivity){
-            setCurrentActivity(null);
-        }
-        ContentValues values = new ContentValues();
-        values.put(Contract.DiaryActivity._DELETED, "1");
-
-        startUpdate(UPDATE_DELETE_ACTIVITY,
-                act,
-                ContentUris.withAppendedId(Contract.DiaryActivity.CONTENT_URI, act.getId()),
-                values,
-                null, /* entry selected via URI */
-                null);
-        synchronized (this) {
-            if (activities.remove(act)) {
-                unsortedActivities.remove(act);
-            } else {
-                Log.e(TAG, "removal of activity " + act + " failed");
-            }
-        }
-        for(DataChangedListener listener : mDataChangeListeners) {
-            listener.onActivityRemoved(act);
-        }
-    }
-
-    @Nullable
-    public DiaryActivity activityWithId(int id){
-        /* TODO improve performance by storing the DiaryActivities in a map or Hashtable instead of a list */
-        synchronized (this) {
-            if(unsortedActivities.isEmpty()){
-                /* activities not yet loaded, so it doesn't make sense yet to read the activities */
-                try {
-                    Thread.sleep(50);
-                } catch (InterruptedException e) {
-                    /* intended empty */
-                }
-            }
-            for (DiaryActivity a : activities) {
-//                System.out.println("activity: " + a.getName());
-                if (a.getId() == id) {
-                    return a;
-                }
-            }
-        }
-        return null;
-    }
-
-    private static ContentValues contentFor(DiaryActivity act){
-        ContentValues result = new ContentValues();
-        result.put(Contract.DiaryActivity.NAME, act.getName());
-        result.put(Contract.DiaryActivity.COLOR, act.getColor());
-        return result;
-    }
-
-    public @Nullable Uri getCurrentDiaryUri(){
-        return mCurrentDiaryUri;
-    }
-
-    /* calculate the "search" distance between search string and model
-     * Code based on Levensthein distance from https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#Java
-     */
-    public static int searchDistance(CharSequence inSearch, CharSequence inModel) {
-        String search = inSearch.toString().toLowerCase(Locale.getDefault()); // s0
-        String model = inModel.toString().toLowerCase(Locale.getDefault());   // s1
-        int result;
-        int len0 = search.length() + 1;
-        int len1 = model.length() + 1;
-
-
-        // the array of distances
-        int[] cost = new int[len0];
-        int[] newcost = new int[len0];
-
-        // initial cost of skipping prefix in String s0
-        for (int i = 0; i < len0; i++) cost[i] = i;
-
-        // dynamically computing the array of distances
-
-        // transformation cost for each letter in s1
-        for (int j = 1; j < len1; j++) {
-            // initial cost of skipping prefix in String s1
-            newcost[0] = j;
-
-            // transformation cost for each letter in s0
-            for(int i = 1; i < len0; i++) {
-                // matching current letters in both strings
-                int match = (search.charAt(i - 1) == model.charAt(j - 1)) ? 0 : 1;
-
-                // computing cost for each transformation
-                int cost_replace = cost[i - 1] + match;
-                int cost_insert  = cost[i] + 1;
-                int cost_delete  = newcost[i - 1] + 1;
-
-                // keep minimum cost
-                newcost[i] = Math.min(Math.min(cost_insert, cost_delete), cost_replace);
-            }
-
-            // swap cost/newcost arrays
-            int[] swap = cost; cost = newcost; newcost = swap;
-        }
-
-        // the distance is the cost for transforming all letters in both strings
-        result = cost[len0 - 1];
-
-        // we want to give some preference for true substrings and character occurrences
-        if(model.contains(search)){
-            result = result - 30;
-        }
-        if(model.startsWith(search)){
-            result = result - 10;
-        }
-        for(int i = 0; i < search.length(); i++){
-            int idx = model.indexOf(search.charAt(i));
-            if(idx < 0){
-                result = result + 4;
-            }
-        }
-        return result;
-    }
-
-    /* reevaluate ALL conditions, very heavy operation, do not trigger without need */
-    public void evaluateAllConditions() {
-        for (Condition c : conditions) {
-            c.refresh();
-        }
-    }
-
-    private HashMap<DiaryActivity, Double> likeliActivites = new HashMap<>(1);
-    public double likelihoodFor(DiaryActivity a){
-        if(likeliActivites.containsKey(a)){
-            //noinspection ConstantConditions
-            return likeliActivites.get(a);
-        }
-        return 0.0;
-    }
-
-    public void reorderActivites() {
-        synchronized (this) {
-            List<DiaryActivity> as = activities;
-            likeliActivites = new HashMap<>(as.size());
-
-            for (DiaryActivity a : as) {
-                likeliActivites.put(a, 0.0);
-            }
-
-            // reevaluate the conditions
-            for (Condition c : conditions) {
-                List<Condition.Likelihood> s = c.likelihoods();
-                for (Condition.Likelihood l : s) {
-                    if (!likeliActivites.containsKey(l.activity)) {
-                        Log.e(TAG, String.format("Activity %s not in likeliActivites %s", l.activity, as.contains(l.activity)));
-                    } else {
-                        Double lv = likeliActivites.get(l.activity);
-                        if (lv == null) {
-                            Log.e(TAG, String.format("Activity %s has no likelyhood in Condition %s", l.activity, c.getClass().getSimpleName()));
-                        } else {
-                            likeliActivites.put(l.activity, lv + l.likelihood);
-                        }
-                    }
-                }
-            }
-
-            List<DiaryActivity> list = new ArrayList<>(likeliActivites.keySet());
-
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
-                Collections.sort(list, Collections.reverseOrder(Comparator.comparing(o -> Objects.requireNonNull(likeliActivites.get(o)))));
-            }
-            activities = list;
-
-            /* is one of the conditions currently evaluating? */
-//            boolean reorderingInProgress = false;
-        }
-
-        for(DataChangedListener listener : mDataChangeListeners) {
-            listener.onActivityOrderChanged();
-        }
-
-//        updateNotification();
-    }
-
-    /*
-     * collect results from all Conditions (if all are finished)
-     * can be called from any Thread
-     */
-    public void conditionEvaluationFinished() {
-        Message completeMessage =
-                mHandler.obtainMessage();
-        completeMessage.sendToTarget();
-    }
-
-    /* perform cyclic actions like update of timing on current activity and checking time based Conditions */
-    public void cyclicUpdate(){
-        // TODO add a service like RefreshService, to call this with configurable cycle time
-    }
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/helpers/ActivityHelper.kt b/app/src/main/java/com/mdiqentw/lifedots/helpers/ActivityHelper.kt
new file mode 100755
index 0000000..f558ed7
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/helpers/ActivityHelper.kt
@@ -0,0 +1,666 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2018 Bc. Ondrej Janitor
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.helpers
+
+import android.annotation.SuppressLint
+import android.content.AsyncQueryHandler
+import android.content.ContentUris
+import android.content.ContentValues
+import android.database.Cursor
+import android.net.Uri
+import android.os.Build
+import android.os.Handler
+import android.os.Looper
+import android.os.Message
+import android.util.Log
+import androidx.preference.PreferenceManager
+import com.mdiqentw.lifedots.MVApplication
+import com.mdiqentw.lifedots.db.Contract
+import com.mdiqentw.lifedots.db.LDContentProvider
+import com.mdiqentw.lifedots.model.DiaryActivity
+import com.mdiqentw.lifedots.model.conditions.AlphabeticalCondition
+import com.mdiqentw.lifedots.model.conditions.Condition
+import com.mdiqentw.lifedots.model.conditions.GlobalOccurrenceCondition
+import com.mdiqentw.lifedots.model.conditions.RecentOccurrenceCondition
+import com.mdiqentw.lifedots.ui.settings.SettingsActivity
+import java.util.*
+import kotlin.math.min
+
+/**
+ * provide a smooth interface to an OO abstraction of the data for our diary.
+ */
+class ActivityHelper private constructor() : AsyncQueryHandler(MVApplication.appContext!!.contentResolver) {
+    /* list of all activities, not including deleted ones */
+    internal var activities: MutableList<DiaryActivity>
+
+    /* unsortedActivities is not allowed to be modified */
+    private val unsortedActivities: MutableList<DiaryActivity>
+    private var mCurrentActivity: DiaryActivity? = null
+    val currentActivityStartTime: Date
+    var currentDiaryUri: Uri? = null
+        private set
+    /* @NonNull */  var currentNote: String? = null
+    private lateinit var conditions: Array<Condition>
+
+    //    private DetailViewModel viewModel;
+    private val mHandler: Handler = object : Handler(Looper.getMainLooper()) {
+        /*
+         * handleMessage() defines the operations to perform when
+         * the Handler receives a new Message to process.
+         */
+        override fun handleMessage(inputMessage: Message) {
+            // so far we only have one message here so no need to look at the details
+            // just assume that at least one Condition evaluation is finished and we check
+            // whether all are done
+            var allDone = true
+            for (c in conditions) {
+                if (c.isActive) {
+                    allDone = false
+                    break
+                }
+            }
+            if (allDone) {
+                reorderActivites()
+            }
+        }
+    }
+
+    /* to be used only in the UI thread, consider getActivitiesCopy() */
+    fun getActivities(): List<DiaryActivity> {
+        return activities
+    }
+
+    /* get a list of the activities as non-modifable copy, not guaranteed to be up to date */
+    fun getUnsortedActivities(): List<DiaryActivity> {
+        val result: MutableList<DiaryActivity> = ArrayList(unsortedActivities.size)
+        synchronized(this) {
+            if (unsortedActivities.isEmpty()) {
+                /* activities not yet loaded, so it doesn't make sense yet to read the activities */
+                try {
+                    Thread.sleep(50)
+                } catch (e: InterruptedException) {
+                    /* intended empty */
+                }
+            }
+            result.addAll(unsortedActivities)
+        }
+        return result
+    }
+
+    interface DataChangedListener {
+        /**
+         * Called when the data has changed and no further specification is possible.
+         * => everything needs to be refreshed!
+         */
+        fun onActivityDataChanged()
+
+        /**
+         * Called when the data of one activity was changed.
+         */
+        fun onActivityDataChanged(activity: DiaryActivity)
+
+        /**
+         * Called on addition of an activity.
+         */
+        fun onActivityAdded(activity: DiaryActivity)
+
+        /**
+         * Called on removal of an activity.
+         */
+        fun onActivityRemoved(activity: DiaryActivity)
+
+        /**
+         * Called on change of the current activity.
+         */
+        fun onActivityChanged()
+
+        /**
+         * Called on change of the activity order due to likelyhood.
+         */
+        fun onActivityOrderChanged()
+    }
+
+    private val mDataChangeListeners: MutableList<DataChangedListener>
+    fun registerDataChangeListener(listener: DataChangedListener) {
+        mDataChangeListeners.add(listener)
+    }
+
+    fun unregisterDataChangeListener(listener: DataChangedListener) {
+        mDataChangeListeners.remove(listener)
+    }
+
+    /* reload all the activities from the database */
+    fun reloadAll() {
+        val resolver = MVApplication.appContext!!.contentResolver
+        val client = resolver.acquireContentProviderClient(Contract.AUTHORITY)
+        val provider = client!!.localContentProvider as LDContentProvider
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
+            client.close()
+        } else {
+            client.release()
+        }
+        provider.resetDatabase()
+        startQuery(
+            QUERY_ALL_ACTIVITIES, null, Contract.DiaryActivity.CONTENT_URI,
+            ACTIVITIES_PROJ, SELECTION, null,
+            null
+        )
+    }
+
+    /* start the query to read the current activity
+     * will trigger the update of currentActivity and send notifications afterwards */
+    fun readCurrentActivity() {
+        startQuery(
+            QUERY_CURRENT_ACTIVITY, null, Contract.Diary.CONTENT_URI,
+            DIARY_PROJ, Contract.Diary.START + " = (SELECT MAX("
+                    + Contract.Diary.START + ") FROM "
+                    + Contract.Diary.TABLE_NAME + " WHERE " + SELECTION + ")", null,
+            Contract.Diary.START + " DESC"
+        )
+    }
+
+    @SuppressLint("Range")
+    override fun onQueryComplete(
+        token: Int, cookie: Any?,
+        cursor: Cursor
+    ) {
+        if (cursor.moveToFirst()) {
+            when (token) {
+                QUERY_ALL_ACTIVITIES -> {
+                    synchronized(this) {
+                        activities.clear()
+                        unsortedActivities.clear()
+                        while (!cursor.isAfterLast) {
+                            val act = DiaryActivity(
+                                cursor.getInt(cursor.getColumnIndex(Contract.DiaryActivity._ID)),
+                                cursor.getString(cursor.getColumnIndex(Contract.DiaryActivity.NAME)),
+                                cursor.getInt(cursor.getColumnIndex(Contract.DiaryActivity.COLOR))
+                            )
+                            /* TODO: optimize by keeping a map with id as key and the DiaryActivities */activities.add(
+                                act
+                            )
+                            unsortedActivities.add(act)
+                            cursor.moveToNext()
+                        }
+                    }
+                    readCurrentActivity()
+                    for (listener in mDataChangeListeners) {
+                        listener.onActivityDataChanged()
+                    }
+                }
+
+                QUERY_CURRENT_ACTIVITY -> {
+                    if (!cursor.isNull(cursor.getColumnIndex(Contract.Diary.END))) {
+                        /* no current activity */
+                        currentNote = ""
+                        currentDiaryUri = null
+                        currentActivityStartTime.time = cursor.getLong(cursor.getColumnIndex(Contract.Diary.END))
+                    } else {
+                        mCurrentActivity =
+                            activityWithId(cursor.getInt(cursor.getColumnIndex(Contract.Diary.ACT_ID)))
+                        currentActivityStartTime.time = cursor.getLong(cursor.getColumnIndex(Contract.Diary.START))
+                        currentNote = cursor.getString(cursor.getColumnIndex(Contract.Diary.NOTE))
+                        currentDiaryUri = Uri.withAppendedPath(
+                            Contract.Diary.CONTENT_URI,
+                            cursor.getLong(cursor.getColumnIndex(Contract.Diary._ID)).toString()
+                        )
+                    }
+                    //                showCurrentActivityNotification();
+                    for (listener in mDataChangeListeners) {
+                        listener.onActivityChanged()
+                    }
+                }
+
+                UNDELETE_ACTIVITY -> {
+                    if (cookie != null) {
+                        val act = cookie as DiaryActivity
+                        act.mColor = cursor.getInt(cursor.getColumnIndex(Contract.DiaryActivity.COLOR))
+                        act.mName = cursor.getString(cursor.getColumnIndex(Contract.DiaryActivity.NAME))
+                        act.mId = cursor.getInt(cursor.getColumnIndex(Contract.DiaryActivity._ID))
+                        for (listener in mDataChangeListeners) {
+                            // notify about the (re-)added activity
+                            listener.onActivityAdded(act)
+                        }
+                    }
+                }
+            }
+        }
+        cursor.close()
+    }// activity terminated, so we have to notify here...
+
+    //            showCurrentActivityNotification();
+    /* update the current diary entry to "finish" it
+       * in theory there should be only one entry with end = NULL in the diary table
+       * but who knows? -> Let's update all. */
+    var currentActivity: DiaryActivity?
+        get() = mCurrentActivity
+        set(activity) {
+            /* update the current diary entry to "finish" it
+         * in theory there should be only one entry with end = NULL in the diary table
+         * but who knows? -> Let's update all. */
+            if (mCurrentActivity !== activity) {
+                val values = ContentValues()
+                val timestamp = System.currentTimeMillis()
+                values.put(Contract.Diary.END, timestamp)
+                startUpdate(
+                    UPDATE_CLOSE_ACTIVITY, timestamp, Contract.Diary.CONTENT_URI,
+                    values, Contract.Diary.END + " is NULL", null
+                )
+                mCurrentActivity = activity
+                currentDiaryUri = null
+                currentActivityStartTime.time = timestamp
+                currentNote = ""
+                if (mCurrentActivity == null) {
+                    // activity terminated, so we have to notify here...
+                    for (listener in mDataChangeListeners) {
+                        listener.onActivityChanged()
+                    }
+                }
+                LocationHelper.helper.updateLocation(false)
+                //            showCurrentActivityNotification();
+            }
+        }
+
+    /* undo the last activity selection by deleteing all open entries
+     *
+     * */
+    fun undoLastActivitySelection() {
+        if (mCurrentActivity != null) {
+            startDelete(
+                DELETE_LAST_DIARY_ENTRY, null,
+                Contract.Diary.CONTENT_URI,
+                Contract.Diary.END + " is NULL",
+                null
+            )
+        }
+    }
+
+    override fun onUpdateComplete(token: Int, cookie: Any?, result: Int) {
+        if (token == UPDATE_CLOSE_ACTIVITY) {
+            if (mCurrentActivity != null) {
+                /* create a new diary entry */
+                val values = ContentValues()
+                values.put(Contract.Diary.ACT_ID, mCurrentActivity!!.mId)
+                values.put(Contract.Diary.START, cookie as Long)
+                startInsert(
+                    INSERT_NEW_DIARY_ENTRY, cookie, Contract.Diary.CONTENT_URI,
+                    values
+                )
+            }
+        } else if (token == UPDATE_ACTIVITY) {
+            for (listener in mDataChangeListeners) {
+                listener.onActivityDataChanged(cookie as DiaryActivity)
+            }
+        } else if (token == REOPEN_LAST_DIARY_ENTRY) {
+            mCurrentActivity = null
+            readCurrentActivity()
+        } else if (token == UNDELETE_ACTIVITY) {
+            val act = cookie as DiaryActivity
+            startQuery(
+                UNDELETE_ACTIVITY, cookie,
+                Contract.DiaryActivity.CONTENT_URI,
+                ACTIVITIES_PROJ, Contract.DiaryActivity._ID + " = " + act.mId,
+                null,
+                null
+            )
+        }
+    }
+
+    override fun onDeleteComplete(token: Int, cookie: Any, result: Int) {
+        if (token == DELETE_LAST_DIARY_ENTRY) {
+            val values = ContentValues()
+            values.putNull(Contract.Diary.END)
+            startUpdate(
+                REOPEN_LAST_DIARY_ENTRY, null,
+                Contract.Diary.CONTENT_URI,
+                values,
+                Contract.Diary.END + "=(SELECT MAX(" + Contract.Diary.END + ") FROM " + Contract.Diary.TABLE_NAME + " )",
+                null
+            )
+        }
+    }
+
+    override fun onInsertComplete(token: Int, cookie: Any, uri: Uri) {
+        if (token == INSERT_NEW_DIARY_ENTRY) {
+            currentDiaryUri = uri
+            for (listener in mDataChangeListeners) {
+                listener.onActivityChanged()
+            }
+        } else if (token == INSERT_NEW_ACTIVITY) {
+            val act = cookie as DiaryActivity
+            act.mId = uri.lastPathSegment!!.toInt()
+            synchronized(this) {
+                activities.add(act)
+                unsortedActivities.add(act)
+            }
+            for (listener in mDataChangeListeners) {
+                listener.onActivityAdded(act)
+            }
+            if (PreferenceManager
+                    .getDefaultSharedPreferences(MVApplication.appContext!!)
+                    .getBoolean(SettingsActivity.KEY_PREF_AUTO_SELECT, true)
+            ) {
+                currentActivity = act
+            }
+        }
+    }
+
+    fun updateActivity(act: DiaryActivity) {
+        startUpdate(
+            UPDATE_ACTIVITY,
+            act,
+            ContentUris.withAppendedId(Contract.DiaryActivity.CONTENT_URI, act.mId.toLong()),
+            contentFor(act),
+            null,
+            null
+        )
+        for (listener in mDataChangeListeners) {
+            listener.onActivityDataChanged(act)
+        }
+    }
+
+    /* undelete an activity with given ID */
+    fun undeleteActivity(id: Int, name: String): DiaryActivity {
+        val result = DiaryActivity(id, name, 0)
+        val values = ContentValues()
+        values.put(Contract.Diary._DELETED, 0)
+        startUpdate(
+            UNDELETE_ACTIVITY, result, Contract.Diary.CONTENT_URI,
+            values, Contract.Diary._ID + " = " + id, null
+        )
+        activities.add(result)
+        unsortedActivities.add(result)
+        return result
+    }
+
+    /* inserts a new activity and sets it as the current one if configured in the preferences */
+    fun insertActivity(act: DiaryActivity) {
+        startInsert(
+            INSERT_NEW_ACTIVITY,
+            act,
+            Contract.DiaryActivity.CONTENT_URI,
+            contentFor(act)
+        )
+    }
+
+    fun deleteActivity(act: DiaryActivity) {
+        if (act === mCurrentActivity) {
+            currentActivity = null
+        }
+        val values = ContentValues()
+        values.put(Contract.DiaryActivity._DELETED, "1")
+        startUpdate(
+            UPDATE_DELETE_ACTIVITY,
+            act,
+            ContentUris.withAppendedId(Contract.DiaryActivity.CONTENT_URI, act.mId.toLong()),
+            values,
+            null,  /* entry selected via URI */
+            null
+        )
+        synchronized(this) {
+            if (activities.remove(act)) {
+                unsortedActivities.remove(act)
+            } else {
+                Log.e(TAG, "removal of activity $act failed")
+            }
+        }
+        for (listener in mDataChangeListeners) {
+            listener.onActivityRemoved(act)
+        }
+    }
+
+    fun activityWithId(id: Int): DiaryActivity? {
+        /* TODO improve performance by storing the DiaryActivities in a map or Hashtable instead of a list */
+        synchronized(this) {
+            if (unsortedActivities.isEmpty()) {
+                /* activities not yet loaded, so it doesn't make sense yet to read the activities */
+                try {
+                    Thread.sleep(50)
+                } catch (e: InterruptedException) {
+                    /* intended empty */
+                }
+            }
+            for (a in activities) {
+                if (a.mId == id) {
+                    return a
+                }
+            }
+        }
+        return null
+    }
+
+    /* reevaluate ALL conditions, very heavy operation, do not trigger without need */
+    fun evaluateAllConditions() {
+        for (c in conditions) {
+            c.refresh()
+        }
+    }
+
+    private var likeliActivites = HashMap<DiaryActivity, Double>(1)
+
+    /* Access only allowed via ActivityHelper.helper singleton */
+    init {
+        mDataChangeListeners = ArrayList(3)
+        activities = ArrayList(50)
+        unsortedActivities = ArrayList(50)
+        conditions = arrayOf(
+            AlphabeticalCondition(this),
+            GlobalOccurrenceCondition(this),
+            RecentOccurrenceCondition(this)
+        )
+        reloadAll()
+        LocationHelper.helper.updateLocation(false)
+        currentActivityStartTime = Date()
+    }
+
+    fun likelihoodFor(a: DiaryActivity): Double {
+        return if (likeliActivites.containsKey(a)) {
+            likeliActivites[a]!!
+        } else 0.0
+    }
+
+    fun reorderActivites() {
+        synchronized(this) {
+            val `as`: List<DiaryActivity> = activities
+            likeliActivites = HashMap(`as`.size)
+            for (a in `as`) {
+                likeliActivites[a] = 0.0
+            }
+
+            // reevaluate the conditions
+            for (c in conditions) {
+                val s = c.likelihoods()
+                for (l in s) {
+                    if (!likeliActivites.containsKey(l.activity)) {
+                        Log.e(
+                            TAG,
+                            String.format(
+                                "Activity %s not in likeliActivites %s",
+                                l.activity,
+                                `as`.contains(l.activity)
+                            )
+                        )
+                    } else {
+                        val lv = likeliActivites[l.activity]
+                        if (lv == null) {
+                            Log.e(
+                                TAG,
+                                String.format(
+                                    "Activity %s has no likelyhood in Condition %s",
+                                    l.activity,
+                                    c.javaClass.simpleName
+                                )
+                            )
+                        } else {
+                            likeliActivites[l.activity] = lv + l.likelihood
+                        }
+                    }
+                }
+            }
+            val list: MutableList<DiaryActivity> = ArrayList(likeliActivites.keys)
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.N) {
+                Collections.sort(list, Collections.reverseOrder(Comparator.comparing { o: DiaryActivity ->
+                        likeliActivites[o]!!
+                }))
+            }
+            activities = list
+        }
+        for (listener in mDataChangeListeners) {
+            listener.onActivityOrderChanged()
+        }
+
+//        updateNotification();
+    }
+
+    /*
+     * collect results from all Conditions (if all are finished)
+     * can be called from any Thread
+     */
+    fun conditionEvaluationFinished() {
+        val completeMessage = mHandler.obtainMessage()
+        completeMessage.sendToTarget()
+    }
+
+    /* perform cyclic actions like update of timing on current activity and checking time based Conditions */
+    fun cyclicUpdate() {
+        // TODO add a service like RefreshService, to call this with configurable cycle time
+    }
+
+    companion object {
+        private val TAG = ActivityHelper::class.java.name
+        private const val QUERY_ALL_ACTIVITIES = 0
+        private const val UPDATE_CLOSE_ACTIVITY = 1
+        private const val INSERT_NEW_DIARY_ENTRY = 2
+        private const val UPDATE_ACTIVITY = 3
+        private const val INSERT_NEW_ACTIVITY = 4
+        private const val UPDATE_DELETE_ACTIVITY = 5
+        private const val QUERY_CURRENT_ACTIVITY = 6
+        private const val DELETE_LAST_DIARY_ENTRY = 7
+        private const val REOPEN_LAST_DIARY_ENTRY = 8
+        private const val UNDELETE_ACTIVITY = 9
+        private val DIARY_PROJ = arrayOf(
+            Contract.Diary.ACT_ID,
+            Contract.Diary.START,
+            Contract.Diary.END,
+            Contract.Diary.TABLE_NAME + "." + Contract.Diary._ID,
+            Contract.Diary.NOTE
+        )
+        private val ACTIVITIES_PROJ = arrayOf(
+            Contract.DiaryActivity._ID,
+            Contract.DiaryActivity.NAME,
+            Contract.DiaryActivity.COLOR
+        )
+        private const val SELECTION = Contract.DiaryActivity._DELETED + "=0"
+        @JvmField
+        val helper = ActivityHelper()
+        @JvmStatic
+        fun sortedActivities(query: String): ArrayList<DiaryActivity> {
+            val filtered = ArrayList<DiaryActivity>(helper.activities.size)
+            val filteredDist = ArrayList<Int>(helper.activities.size)
+            for (a in helper.activities) {
+                val dist = searchDistance(query, a.mName)
+                var pos = 0
+                // search where to enter it
+                for (i in filteredDist) {
+                    if (dist > i) {
+                        pos++
+                    } else {
+                        break
+                    }
+                }
+                filteredDist.add(pos, dist)
+                filtered.add(pos, a)
+            }
+            return filtered
+        }
+
+        private fun contentFor(act: DiaryActivity): ContentValues {
+            val result = ContentValues()
+            result.put(Contract.DiaryActivity.NAME, act.mName)
+            result.put(Contract.DiaryActivity.COLOR, act.mColor)
+            return result
+        }
+
+        /* calculate the "search" distance between search string and model
+     * Code based on Levensthein distance from https://en.wikibooks.org/wiki/Algorithm_Implementation/Strings/Levenshtein_distance#Java
+     */
+        fun searchDistance(inSearch: CharSequence, inModel: CharSequence): Int {
+            val search = inSearch.toString().lowercase(Locale.getDefault()) // s0
+            val model = inModel.toString().lowercase(Locale.getDefault()) // s1
+            var result: Int
+            val len0 = search.length + 1
+            val len1 = model.length + 1
+
+
+            // the array of distances
+            var cost = IntArray(len0)
+            var newcost = IntArray(len0)
+
+            // initial cost of skipping prefix in String s0
+            for (i in 0 until len0) cost[i] = i
+
+            // dynamically computing the array of distances
+
+            // transformation cost for each letter in s1
+            for (j in 1 until len1) {
+                // initial cost of skipping prefix in String s1
+                newcost[0] = j
+
+                // transformation cost for each letter in s0
+                for (i in 1 until len0) {
+                    // matching current letters in both strings
+                    val match = if (search[i - 1] == model[j - 1]) 0 else 1
+
+                    // computing cost for each transformation
+                    val cost_replace = cost[i - 1] + match
+                    val cost_insert = cost[i] + 1
+                    val cost_delete = newcost[i - 1] + 1
+
+                    // keep minimum cost
+                    newcost[i] = min(min(cost_insert, cost_delete), cost_replace)
+                }
+
+                // swap cost/newcost arrays
+                val swap = cost
+                cost = newcost
+                newcost = swap
+            }
+
+            // the distance is the cost for transforming all letters in both strings
+            result = cost[len0 - 1]
+
+            // we want to give some preference for true substrings and character occurrences
+            if (model.contains(search)) {
+                result -= 30
+            }
+            if (model.startsWith(search)) {
+                result -= 10
+            }
+            for (element in search) {
+                val idx = model.indexOf(element)
+                if (idx < 0) {
+                    result += 4
+                }
+            }
+            return result
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/helpers/DateHelper.kt b/app/src/main/java/com/mdiqentw/lifedots/helpers/DateHelper.kt
old mode 100644
new mode 100755
index 0621d14..b1c1979
--- a/app/src/main/java/com/mdiqentw/lifedots/helpers/DateHelper.kt
+++ b/app/src/main/java/com/mdiqentw/lifedots/helpers/DateHelper.kt
@@ -2,6 +2,7 @@
  * LifeDots
  *
  * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -24,24 +25,6 @@ import java.lang.RuntimeException
 import java.text.SimpleDateFormat
 import java.util.*
 
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
 object DateHelper {
     const val FULLDAY = 3324
     const val FULLWEEK = 3407
@@ -75,7 +58,7 @@ object DateHelper {
 
     @JvmStatic
     fun dateFormat(field: Int): SimpleDateFormat {
-        val res = MVApplication.getAppContext().resources
+        val res = MVApplication.appContext!!.resources
         val result: SimpleDateFormat = when (field) {
             Calendar.DAY_OF_MONTH, Calendar.DAY_OF_WEEK, Calendar.DAY_OF_WEEK_IN_MONTH, Calendar.DAY_OF_YEAR -> SimpleDateFormat(res.getString(R.string.day_format))
             Calendar.WEEK_OF_YEAR -> SimpleDateFormat(res.getString(R.string.week_format))
diff --git a/app/src/main/java/com/mdiqentw/lifedots/helpers/GraphicsHelper.kt b/app/src/main/java/com/mdiqentw/lifedots/helpers/GraphicsHelper.kt
old mode 100644
new mode 100755
index c7c9287..4670238
--- a/app/src/main/java/com/mdiqentw/lifedots/helpers/GraphicsHelper.kt
+++ b/app/src/main/java/com/mdiqentw/lifedots/helpers/GraphicsHelper.kt
@@ -2,6 +2,7 @@
  * LifeDots
  *
  * Copyright (C) 2017 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -35,25 +36,6 @@ import java.util.*
 import kotlin.math.ln
 import kotlin.math.sqrt
 
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
 object GraphicsHelper {
     const val TAG = "GraphicsHelper"
 
@@ -63,7 +45,7 @@ object GraphicsHelper {
 
     @JvmStatic
     fun imageStorageDirectory(): File {
-        val root = File(MVApplication.getAppContext().getExternalFilesDir("/"), "")
+        val root = File(MVApplication.appContext!!.getExternalFilesDir("/"), "")
         if (!root.exists()) {
             if (!root.mkdirs()) {
                 Log.e(TAG, "failed to create directory")
@@ -113,7 +95,7 @@ object GraphicsHelper {
      * */
     fun getFileExifRotation(uri: Uri?): Int {
         return try {
-            val inputStream = MVApplication.getAppContext().contentResolver.openInputStream(uri!!)
+            val inputStream = MVApplication.appContext!!.contentResolver.openInputStream(uri!!)
             val exifInterface = ExifInterface(inputStream!!)
             when (exifInterface.getAttributeInt(ExifInterface.TAG_ORIENTATION, ExifInterface.ORIENTATION_NORMAL)) {
                 ExifInterface.ORIENTATION_ROTATE_90 -> 90
@@ -136,7 +118,7 @@ object GraphicsHelper {
     @Suppress("UNUSED_PARAMETER")
     @JvmStatic
     fun textColorOnBackground(color: Int): Int {
-        return ContextCompat.getColor(MVApplication.getAppContext(), R.color.activityTextColorLight)
+        return ContextCompat.getColor(MVApplication.appContext!!, R.color.activityTextColorLight)
 //        return ContextCompat.getColor(MVApplication.getAppContext(), color)
     }
 
@@ -151,7 +133,7 @@ object GraphicsHelper {
         for (c in activityColorPalette) {
             var dist = 0.0
             for (a in acts) {
-                dist += ln(1 + colorDistance(c, a.color).toDouble())
+                dist += ln(1 + colorDistance(c, a.mColor).toDouble())
             }
             if (dist > maxDistance) {
                 // this one is better than the last
diff --git a/app/src/main/java/com/mdiqentw/lifedots/helpers/LocationHelper.kt b/app/src/main/java/com/mdiqentw/lifedots/helpers/LocationHelper.kt
old mode 100644
new mode 100755
index a8d3216..e110320
--- a/app/src/main/java/com/mdiqentw/lifedots/helpers/LocationHelper.kt
+++ b/app/src/main/java/com/mdiqentw/lifedots/helpers/LocationHelper.kt
@@ -2,7 +2,8 @@
  * LifeDots
  *
  * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
- *
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+`*
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
  * the Free Software Foundation, either version 3 of the License, or
@@ -36,53 +37,65 @@ import com.mdiqentw.lifedots.MVApplication
 import com.mdiqentw.lifedots.db.Contract
 import com.mdiqentw.lifedots.helpers.DateHelper.DAY_IN_MS
 import com.mdiqentw.lifedots.ui.settings.SettingsActivity
+import java.util.*
 import kotlin.math.*
 
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-class LocationHelper : AsyncQueryHandler(MVApplication.getAppContext().contentResolver),
+class LocationHelper : AsyncQueryHandler(MVApplication.appContext!!.contentResolver),
     LocationListener, OnSharedPreferenceChangeListener {
 
+    private var startTime: Long = 0
+    private var stopTime: Long = 24
     private var minTime: Long = 0
     private var minDist = 0f
     private var setting: String? = null
     var currentLocation: Location private set
     private val locationManager: LocationManager =
-        MVApplication.getAppContext().getSystemService(Context.LOCATION_SERVICE) as LocationManager
+        MVApplication.appContext!!.getSystemService(Context.LOCATION_SERVICE) as LocationManager
     private val sharedPreferences: SharedPreferences =
-        PreferenceManager.getDefaultSharedPreferences(MVApplication.getAppContext())
+        PreferenceManager.getDefaultSharedPreferences(MVApplication.appContext!!)
     private val mHandler: Handler
 
     private lateinit var refreshJobInfo: JobInfo
 
-    fun updateLocation() {
+    fun isOutOfHours() : Boolean {
+        val cal: Calendar = Calendar.getInstance()
+        val hourofday = cal[Calendar.HOUR_OF_DAY]
+
+        if (startTime <= stopTime) {
+            if (hourofday < startTime || hourofday > stopTime) {
+//                println("no location tracking out of hour $startTime $stopTime")
+                return true
+            }
+        } else {
+            if (hourofday > startTime || hourofday < stopTime) {
+//                println("no location tracking out of hour $startTime $stopTime")
+                return true
+            }
+        }
+
+//        println("location tracking in hour $startTime $stopTime")
+        return false
+    }
+
+    fun isTrackingSet() : Boolean {
+        return setting != "off"
+    }
+
+    fun updateLocation(scheduled : Boolean) {
         if (setting == "off") return
 
+        if (scheduled && isOutOfHours()) return
+
+        println("LocationHelper: getting location")
+
         var permissionCheckFine = PackageManager.PERMISSION_DENIED
         var permissionCheckCoarse = PackageManager.PERMISSION_DENIED
         if (setting == "gps" && locationManager.allProviders.contains(LocationManager.GPS_PROVIDER)) {
-            permissionCheckFine = ContextCompat.checkSelfPermission(MVApplication.getAppContext(),
+            permissionCheckFine = ContextCompat.checkSelfPermission(MVApplication.appContext!!,
                 Manifest.permission.ACCESS_FINE_LOCATION)
             permissionCheckCoarse = permissionCheckFine
         } else if (locationManager.allProviders.contains(LocationManager.NETWORK_PROVIDER)) {
-            permissionCheckCoarse = ContextCompat.checkSelfPermission(MVApplication.getAppContext(),
+            permissionCheckCoarse = ContextCompat.checkSelfPermission(MVApplication.appContext!!,
                 Manifest.permission.ACCESS_COARSE_LOCATION)
         }
 
@@ -98,7 +111,7 @@ class LocationHelper : AsyncQueryHandler(MVApplication.getAppContext().contentRe
             var updated = false
             if (location != null) {
                 locAge = System.currentTimeMillis() - location.time
-                println("LastLocation: " + location.longitude + ":" + location.latitude + " " + locAge)
+//                println("LastLocation: " + location.longitude + ":" + location.latitude + " " + locAge)
 
                 if (locAge < minTime && location.time != currentLocation.time) {
                     onLocationChanged(location)
@@ -113,14 +126,14 @@ class LocationHelper : AsyncQueryHandler(MVApplication.getAppContext().contentRe
 //                    println("calling getCurrentLocation")
                     locationManager.getCurrentLocation(locationProvider,
                         null,
-                        MVApplication.getAppContext().mainExecutor
+                        MVApplication.appContext!!.mainExecutor
                     ) {
                         fun accept(location: Location) {
                             onLocationChanged(location)
                         }
                     }
                 } else {
-                    println("calling requestSingleUpdate")
+//                    println("calling requestSingleUpdate")
                     @Suppress("DEPRECATION")
                     locationManager.requestSingleUpdate(
                         locationProvider, this, Looper.getMainLooper())
@@ -182,18 +195,18 @@ class LocationHelper : AsyncQueryHandler(MVApplication.getAppContext().contentRe
     override fun onLocationChanged(location: Location) {
         stopLocationUpdates()
 
-        @Suppress("SENSELESS_COMPARISON", "DEPRECATION")
+        @Suppress("SENSELESS_COMPARISON")
         if (location == null || isAtZero(location)) return
 
         val distFromCur = distance(location, currentLocation)
-        println("onLocationChanged: " + location.time + " " +
-                location.longitude + " " + location.latitude + " " +
-                distFromCur + " " + minDist)
+//        println("onLocationChanged: " + location.time + " " +
+//                location.longitude + " " + location.latitude + " " +
+//                distFromCur + " " + minDist)
 
         if (System.currentTimeMillis() - currentLocation.time < DAY_IN_MS &&
             distFromCur < minDist) return
 
-        println("Adding location point: " + location.time + " " + location.longitude + " " + location.latitude)
+//        println("Adding location point: " + location.time + " " + location.longitude + " " + location.latitude)
         val values = ContentValues()
         currentLocation = location
         values.put(Contract.DiaryLocation.TIMESTAMP, location.time)
@@ -228,6 +241,7 @@ class LocationHelper : AsyncQueryHandler(MVApplication.getAppContext().contentRe
     }
 
     // deprecated for Android Q
+    @Deprecated("Deprecated in Java")
     override fun onStatusChanged(provider: String, status: Int, extras: Bundle) {}
 
     /**
@@ -250,32 +264,42 @@ class LocationHelper : AsyncQueryHandler(MVApplication.getAppContext().contentRe
 
     override fun onSharedPreferenceChanged(sharedPreferences: SharedPreferences, key: String) {
         if (key == SettingsActivity.KEY_PREF_USE_LOCATION ||
+            key == SettingsActivity.KEY_PREF_LOCATION_START ||
+            key == SettingsActivity.KEY_PREF_LOCATION_STOP ||
             key == SettingsActivity.KEY_PREF_LOCATION_AGE ||
             key == SettingsActivity.KEY_PREF_LOCATION_DIST) {
             loadFromPreferences()
-            updateLocation()
+            updateLocation(false)
         }
     }
 
     private fun loadFromPreferences() {
         try {
             setting = sharedPreferences.getString(SettingsActivity.KEY_PREF_USE_LOCATION, "off")
-            val minTimeS = sharedPreferences.getString(SettingsActivity.KEY_PREF_LOCATION_AGE, (MIN_TIME_DEF).toString())
-            minTime = MIN_TIME_FACTOR * (minTimeS!!.toLong())
-            val minDistS = sharedPreferences.getString(SettingsActivity.KEY_PREF_LOCATION_DIST, MIN_DISTANCE_DEF.toString())
-            minDist = minDistS!!.toFloat()
+            var startTimeS = sharedPreferences.getString(SettingsActivity.KEY_PREF_LOCATION_START, (START_TIME_DEF).toString())
+            if (startTimeS == null) startTimeS = "0"
+            startTime = startTimeS.toLong()
+            var stopTimeS = sharedPreferences.getString(SettingsActivity.KEY_PREF_LOCATION_STOP, (STOP_TIME_DEF).toString())
+            if (stopTimeS == null) stopTimeS = "24"
+            stopTime = stopTimeS.toLong()
+            var minTimeS = sharedPreferences.getString(SettingsActivity.KEY_PREF_LOCATION_AGE, (MIN_TIME_DEF).toString())
+            if (minTimeS == null) minTimeS = "10"
+            minTime = MIN_TIME_FACTOR * (minTimeS.toLong())
+            var minDistS = sharedPreferences.getString(SettingsActivity.KEY_PREF_LOCATION_DIST, MIN_DISTANCE_DEF.toString())
+            if (minDistS == null) minDistS = "50"
+            minDist = minDistS.toFloat()
         } catch (e: NumberFormatException) {
             /* no change in settings on invalid config */
         }
     }
 
     fun scheduleRefresh() {
-        val componentName = ComponentName(MVApplication.getAppContext(), RefreshService::class.java)
+        val componentName = ComponentName(MVApplication.appContext!!, RefreshService::class.java)
         val builder = JobInfo.Builder(ACTIVITY_HELPER_REFRESH_JOB, componentName)
         builder.setMinimumLatency(minTime)
         refreshJobInfo = builder.build()
-        println("Job scheduled: $minTime")
-        val jobScheduler = MVApplication.getAppContext()
+//        println("Job scheduled: $minTime")
+        val jobScheduler = MVApplication.appContext!!
             .getSystemService(Context.JOB_SCHEDULER_SERVICE) as JobScheduler
         val resultCode = jobScheduler.schedule(refreshJobInfo)
         if (resultCode != JobScheduler.RESULT_SUCCESS) {
@@ -289,6 +313,10 @@ class LocationHelper : AsyncQueryHandler(MVApplication.getAppContext().contentRe
         val helper = LocationHelper()
         private const val LOCATION_UPDATE = 1
         private const val MIN_TIME_DEF: Long = 5 // for now every 5 minutes
+        private const val START_TIME_DEF: Long = 0 // for now every 5 minutes
+        private const val STOP_TIME_DEF: Long = 24 // for now every 5 minutes
+
+        private const val HOUR_FACTOR = (1000 * 60 * 60).toLong()
         private const val MIN_TIME_FACTOR = (1000 * 60).toLong()
         private const val MIN_DISTANCE_DEF = 50.0f
         private const val ACTIVITY_HELPER_REFRESH_JOB = 0
diff --git a/app/src/main/java/com/mdiqentw/lifedots/helpers/RefreshService.java b/app/src/main/java/com/mdiqentw/lifedots/helpers/RefreshService.java
deleted file mode 100644
index 540dfe5..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/helpers/RefreshService.java
+++ /dev/null
@@ -1,89 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots.helpers;
-
-import android.app.job.JobParameters;
-import android.app.job.JobService;
-import android.util.Log;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
- * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-public class RefreshService extends JobService {
-    private static final String TAG = RefreshService.class.getName();
-    boolean isWorking = false;
-    boolean jobCancelled = false;
-
-    // Called by the Android system when it's time to run the job
-    @Override
-    public boolean onStartJob(JobParameters jobParameters) {
-        Log.d(TAG, "Refreshing...");
-        isWorking = true;
-
-        /* UI refresh is so fast we can do it directly here */
-//        ActivityHelper.helper.updateNotification();
-
-        // We need 'jobParameters' so we can call 'jobFinished'
-        startWorkOnNewThread(jobParameters);
-
-        return isWorking;
-    }
-
-    private void startWorkOnNewThread(final JobParameters jobParameters) {
-        new Thread(() -> refresh(jobParameters)).start();
-    }
-
-    private void refresh(JobParameters jobParameters) {
-        if (jobCancelled)
-            return;
-
-        isWorking = false;
-//        boolean needsReschedule = false;
-        LocationHelper.helper.scheduleRefresh();
-        LocationHelper.helper.updateLocation();
-        jobFinished(jobParameters, false);
-    }
-
-    // Called if the job was cancelled before being finished
-    @Override
-    public boolean onStopJob(JobParameters jobParameters) {
-        jobCancelled = true;
-        boolean needsReschedule = isWorking;
-        jobFinished(jobParameters, needsReschedule);
-        return needsReschedule;
-    }
-}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/helpers/RefreshService.kt b/app/src/main/java/com/mdiqentw/lifedots/helpers/RefreshService.kt
new file mode 100755
index 0000000..200ce12
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/helpers/RefreshService.kt
@@ -0,0 +1,69 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.helpers
+
+import android.app.job.JobParameters
+import android.app.job.JobService
+import android.util.Log
+
+class RefreshService : JobService() {
+    var isWorking = false
+    var jobCancelled = false
+
+    // Called by the Android system when it's time to run the job
+    override fun onStartJob(jobParameters: JobParameters): Boolean {
+        Log.d(TAG, "Job started... $jobParameters")
+        isWorking = true
+
+        /* UI refresh is so fast we can do it directly here */
+//        ActivityHelper.helper.updateNotification();
+
+        // We need 'jobParameters' so we can call 'jobFinished'
+        startWorkOnNewThread(jobParameters)
+        return isWorking
+    }
+
+    private fun startWorkOnNewThread(jobParameters: JobParameters) {
+        Thread { refresh(jobParameters) }.start()
+    }
+
+    private fun refresh(jobParameters: JobParameters) {
+        Log.d(TAG, "Job refreshing... $jobParameters")
+        if (jobCancelled) return
+        isWorking = false
+        //        boolean needsReschedule = false;
+        LocationHelper.helper.scheduleRefresh()
+        LocationHelper.helper.updateLocation(true)
+        jobFinished(jobParameters, false)
+    }
+
+    // Called if the job was cancelled before being finished
+    override fun onStopJob(jobParameters: JobParameters): Boolean {
+        Log.d(TAG, "Job stopping... $jobParameters")
+        jobCancelled = true
+        val needsReschedule = isWorking
+        jobFinished(jobParameters, needsReschedule)
+        return needsReschedule
+    }
+
+    companion object {
+        private val TAG = RefreshService::class.java.name
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/helpers/TimeSpanFormatter.kt b/app/src/main/java/com/mdiqentw/lifedots/helpers/TimeSpanFormatter.kt
old mode 100644
new mode 100755
index fee3844..834df40
--- a/app/src/main/java/com/mdiqentw/lifedots/helpers/TimeSpanFormatter.kt
+++ b/app/src/main/java/com/mdiqentw/lifedots/helpers/TimeSpanFormatter.kt
@@ -1,8 +1,8 @@
 /*
  * LifeDots
  *
+ * Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
  * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -48,7 +48,7 @@ object TimeSpanFormatter {
 
     @JvmStatic
     fun fuzzyFormat(start: Date, end: Date): String {
-        val res = MVApplication.getAppContext().resources
+        val res = MVApplication.appContext!!.resources
         val delta = (end.time - start.time + 500) / 1000
 
         return when {
@@ -85,10 +85,10 @@ object TimeSpanFormatter {
         if (duration < 1E4) {
             return (duration / 100f).toString() + "%"
         }
-        val res = MVApplication.getAppContext().resources
+        val res = MVApplication.appContext!!.resources
         val delta = duration / 1000
         val displayFormat = PreferenceManager
-                .getDefaultSharedPreferences(MVApplication.getAppContext())
+                .getDefaultSharedPreferences(MVApplication.appContext!!)
                 .getString(SettingsActivity.KEY_PREF_DURATION_FORMAT, "dynamic")
         var result = ""
         val sec = (delta % 60).toInt()
diff --git a/app/src/main/java/com/mdiqentw/lifedots/model/DetailViewModel.java b/app/src/main/java/com/mdiqentw/lifedots/model/DetailViewModel.java
deleted file mode 100644
index 528f14b..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/model/DetailViewModel.java
+++ /dev/null
@@ -1,107 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots.model;
-
-import androidx.annotation.Nullable;
-import androidx.lifecycle.LiveData;
-import androidx.lifecycle.MutableLiveData;
-import androidx.lifecycle.ViewModel;
-import android.net.Uri;
-
-import com.mdiqentw.lifedots.db.Contract;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-/* the viewmodel for the details of a diary entry */
-public class DetailViewModel extends ViewModel {
-    public final MutableLiveData<String> mNote;
-    public final MutableLiveData<String> mDuration;
-//    public MutableLiveData<String> mAvgDuration;
-//    public MutableLiveData<String> mStartOfLast;
-    public final MutableLiveData<String> mTotalToday;
-    public final MutableLiveData<String> mTotalWeek;
-    public final MutableLiveData<String> mTotalMonth;
-
-    public final MutableLiveData<DiaryActivity> mCurrentActivity;
-    /* TODO: note and starttime from ActivityHelper to here, or even use directly the ContentProvider
-     * register a listener to get updates directly from the ContentProvider */
-
-    public final MutableLiveData<Long> mDiaryEntryId;
-
-    public DetailViewModel()
-    {
-        mNote = new MutableLiveData<>();
-        mDuration = new MutableLiveData<>();
-//        mAvgDuration = new MutableLiveData<>();
-//        mStartOfLast = new MutableLiveData<>();
-        mTotalToday = new MutableLiveData<>();
-        mTotalWeek = new MutableLiveData<>();
-        mTotalMonth = new MutableLiveData<>();
-        mCurrentActivity = new MutableLiveData<>();
-        mDiaryEntryId = new MutableLiveData<>();
-    }
-
-    public LiveData<String> note() {
-        return mNote;
-    }
-
-    public LiveData<String> duration() {
-        return mDuration;
-    }
-
-    public LiveData<DiaryActivity> currentActivity() {
-        return mCurrentActivity;
-    }
-
-    @Nullable
-    public Uri getCurrentDiaryUri(){
-        if(mCurrentActivity.getValue() == null){
-            return null;
-        } else {
-            // TODO: this is not fully correct until the entry is stored in the DB and the ID is updated...
-            return Uri.withAppendedPath(Contract.Diary.CONTENT_URI,
-                    Long.toString(mDiaryEntryId.getValue()));
-        }
-    }
-
-    public void setCurrentDiaryUri(Uri currentDiaryUri) {
-        if(currentDiaryUri != null) {
-            mDiaryEntryId.setValue(Long.parseLong(currentDiaryUri.getLastPathSegment()));
-        }
-    }
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/model/DetailViewModel.kt b/app/src/main/java/com/mdiqentw/lifedots/model/DetailViewModel.kt
new file mode 100755
index 0000000..9504ae8
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/model/DetailViewModel.kt
@@ -0,0 +1,78 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.model
+
+import android.net.Uri
+import androidx.lifecycle.LiveData
+import androidx.lifecycle.MutableLiveData
+import androidx.lifecycle.ViewModel
+import com.mdiqentw.lifedots.db.Contract
+
+/* the viewmodel for the details of a diary entry */
+class DetailViewModel : ViewModel() {
+    @JvmField
+    val mNote: MutableLiveData<String> = MutableLiveData()
+    val mDuration: MutableLiveData<String> = MutableLiveData()
+
+    //    public MutableLiveData<String> mAvgDuration;
+    //    public MutableLiveData<String> mStartOfLast;
+    @JvmField
+    val mTotalToday: MutableLiveData<String> = MutableLiveData()
+
+    @JvmField
+    val mTotalWeek: MutableLiveData<String> = MutableLiveData()
+
+    @JvmField
+    val mTotalMonth: MutableLiveData<String> = MutableLiveData()
+    val mCurrentActivity: MutableLiveData<DiaryActivity?> = MutableLiveData()
+
+    /* TODO: note and starttime from ActivityHelper to here, or even use directly the ContentProvider
+     * register a listener to get updates directly from the ContentProvider */
+    val mDiaryEntryId: MutableLiveData<Long> = MutableLiveData()
+
+    fun note(): LiveData<String> {
+        return mNote
+    }
+
+    fun duration(): LiveData<String> {
+        return mDuration
+    }
+
+    fun currentActivity(): LiveData<DiaryActivity?> {
+        return mCurrentActivity
+    }
+
+    // TODO: this is not fully correct until the entry is stored in the DB and the ID is updated...
+    var currentDiaryUri: Uri?
+        get() = if (mCurrentActivity.value == null) {
+            null
+        } else {
+            // TODO: this is not fully correct until the entry is stored in the DB and the ID is updated...
+            Uri.withAppendedPath(
+                Contract.Diary.CONTENT_URI,
+                (mDiaryEntryId.value!!).toString()
+            )
+        }
+        set(currentDiaryUri) {
+            if (currentDiaryUri != null) {
+                mDiaryEntryId.value = currentDiaryUri.lastPathSegment!!.toLong()
+            }
+        }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/model/DiaryActivity.java b/app/src/main/java/com/mdiqentw/lifedots/model/DiaryActivity.java
deleted file mode 100644
index b231cec..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/model/DiaryActivity.java
+++ /dev/null
@@ -1,82 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2017 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots.model;
-
-import androidx.annotation.NonNull;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-public class DiaryActivity{
-    private String mName;
-    private int mId;
-    private int mColor;
-
-    public DiaryActivity(int id, String name, int color){
-        mId = id;
-        mName = name;
-        mColor = color;
-    }
-
-    public String getName(){
-        return mName;
-    }
-    public void setName(String name){ mName = name;}
-
-    public int getColor(){
-        return mColor;
-    }
-    public void setColor(int color){ mColor = color;}
-
-    public int getId() { return mId;}
-    public void setId(int id) { mId = id;}
-
-    public boolean equals(Object other){
-        return other instanceof DiaryActivity && ((DiaryActivity) other).mName.equals(mName);
-    }
-
-    @NonNull
-    @Override
-    public String toString(){
-        return mName + " (" + mId + ")";
-    }
-
-    @Override
-    public int hashCode(){
-        return mId;
-    }
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/model/DiaryActivity.kt b/app/src/main/java/com/mdiqentw/lifedots/model/DiaryActivity.kt
new file mode 100755
index 0000000..837659c
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/model/DiaryActivity.kt
@@ -0,0 +1,35 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2017 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.model
+
+class DiaryActivity(var mId: Int, var mName: String, var mColor: Int) {
+
+    override fun equals(other: Any?): Boolean {
+        return other is DiaryActivity && other.mName == mName
+    }
+
+    override fun toString(): String {
+        return "$mName ($mId)"
+    }
+
+    override fun hashCode(): Int {
+        return mId
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/model/conditions/AlphabeticalCondition.java b/app/src/main/java/com/mdiqentw/lifedots/model/conditions/AlphabeticalCondition.java
deleted file mode 100644
index ed1e29a..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/model/conditions/AlphabeticalCondition.java
+++ /dev/null
@@ -1,133 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots.model.conditions;
-
-import com.mdiqentw.lifedots.helpers.ActivityHelper;
-import com.mdiqentw.lifedots.model.DiaryActivity;
-import com.mdiqentw.lifedots.ui.settings.SettingsActivity;
-
-import java.util.ArrayList;
-import java.util.Collections;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-/**
- * Model the likelihood of the activities based on the alphabetical sorting of their names
- */
-public class AlphabeticalCondition extends Condition
-        implements ActivityHelper.DataChangedListener {
-
-    public AlphabeticalCondition(ActivityHelper helper){
-        helper.registerDataChangeListener(this);
-    }
-
-    protected void doEvaluation(){
-        weight = Double.parseDouble(sharedPreferences.getString(SettingsActivity.KEY_PREF_COND_ALPHA, "5"));
-        ArrayList<Likelihood> result = new ArrayList<>(ActivityHelper.helper.getUnsortedActivities().size());
-        if(weight > 0.001) {
-
-            ArrayList<DiaryActivity> sort = new ArrayList<>(ActivityHelper.helper.getUnsortedActivities());
-            Collections.sort(sort, (o1, o2) -> {
-                if(o1 == o2) {
-                    return 0;
-                } else if(o1 == null) {
-                    return -1;
-                } else if(o2 == null) {
-                    return 1;
-                } else{
-                    return o2.getName().compareTo(o1.getName());
-                }
-            });
-            double step = weight / sort.size();
-            int no = 0;
-            for (DiaryActivity a : sort) {
-                result.add(new Likelihood(a, step * no));
-                no++;
-            }
-        }
-        this.setResult(result);
-    }
-
-    /**
-     * Called when the data has changed and no further specification is possible.
-     * => everything needs to be refreshed!
-     *
-     */
-    @Override
-    public void onActivityDataChanged() {
-        refresh();
-    }
-
-    /**
-     * Called when the data of one activity was changed.
-     *
-     * @param activity
-     */
-    @Override
-    public void onActivityDataChanged(DiaryActivity activity) {
-        refresh();
-    }
-
-    /**
-     * Called on addition of an activity.
-     *
-     * @param activity
-     */
-    @Override
-    public void onActivityAdded(DiaryActivity activity) {
-        refresh();
-    }
-
-    /**
-     * Called on removale of an activity.
-     *
-     * @param activity
-     */
-    @Override
-    public void onActivityRemoved(DiaryActivity activity) {
-        refresh();
-    }
-
-    /**
-     * Called on change of the current activity.
-     */
-    @Override
-    public void onActivityChanged() {
-        // no influence on likelhood for this Condition
-    }
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/model/conditions/AlphabeticalCondition.kt b/app/src/main/java/com/mdiqentw/lifedots/model/conditions/AlphabeticalCondition.kt
new file mode 100755
index 0000000..037b734
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/model/conditions/AlphabeticalCondition.kt
@@ -0,0 +1,102 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.model.conditions
+
+import com.mdiqentw.lifedots.helpers.ActivityHelper
+import com.mdiqentw.lifedots.helpers.ActivityHelper.DataChangedListener
+import com.mdiqentw.lifedots.model.DiaryActivity
+import com.mdiqentw.lifedots.ui.settings.SettingsActivity
+import java.util.*
+
+/**
+ * Model the likelihood of the activities based on the alphabetical sorting of their names
+ */
+class AlphabeticalCondition(helper: ActivityHelper) : Condition(), DataChangedListener {
+    init {
+        helper.registerDataChangeListener(this)
+    }
+
+    override fun doEvaluation() {
+        weight = sharedPreferences.getString(SettingsActivity.KEY_PREF_COND_ALPHA, "5")!!.toDouble()
+        val result = ArrayList<Likelihood>(ActivityHelper.helper.getUnsortedActivities().size)
+        if (weight > 0.001) {
+            val sort = ArrayList(ActivityHelper.helper.getUnsortedActivities())
+            Collections.sort(sort) { o1: DiaryActivity?, o2: DiaryActivity? ->
+                if (o1 === o2) {
+                    return@sort 0
+                } else if (o1 == null) {
+                    return@sort -1
+                } else if (o2 == null) {
+                    return@sort 1
+                } else {
+                    return@sort o2.mName.compareTo(o1.mName)
+                }
+            }
+            val step = weight / sort.size
+            for ((no, a) in sort.withIndex()) {
+                result.add(Likelihood(a!!, step * no))
+            }
+        }
+        setResult(result)
+    }
+
+    /**
+     * Called when the data has changed and no further specification is possible.
+     * => everything needs to be refreshed!
+     *
+     */
+    override fun onActivityDataChanged() {
+        refresh()
+    }
+
+    /**
+     * Called when the data of one activity was changed.
+     *
+     * @param activity
+     */
+    override fun onActivityDataChanged(activity: DiaryActivity) {
+        refresh()
+    }
+
+    /**
+     * Called on addition of an activity.
+     *
+     * @param activity
+     */
+    override fun onActivityAdded(activity: DiaryActivity) {
+        refresh()
+    }
+
+    /**
+     * Called on removale of an activity.
+     *
+     * @param activity
+     */
+    override fun onActivityRemoved(activity: DiaryActivity) {
+        refresh()
+    }
+
+    /**
+     * Called on change of the current activity.
+     */
+    override fun onActivityChanged() {
+        // no influence on likelhood for this Condition
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/model/conditions/Condition.java b/app/src/main/java/com/mdiqentw/lifedots/model/conditions/Condition.java
deleted file mode 100644
index 144a645..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/model/conditions/Condition.java
+++ /dev/null
@@ -1,156 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots.model.conditions;
-
-import android.content.SharedPreferences;
-import androidx.annotation.NonNull;
-import androidx.preference.PreferenceManager;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import com.mdiqentw.lifedots.MVApplication;
-import com.mdiqentw.lifedots.db.LocalDBHelper;
-import com.mdiqentw.lifedots.helpers.ActivityHelper;
-import com.mdiqentw.lifedots.model.DiaryActivity;
-
-import static java.lang.Thread.State.NEW;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-/*
- * Conditions model a specific aspect which influences the likelihood of the activities.
- **/
-public abstract class Condition {
-    final SharedPreferences sharedPreferences = PreferenceManager.getDefaultSharedPreferences(MVApplication.getAppContext());
-
-    public static class Likelihood{
-        public final DiaryActivity activity;
-        public double likelihood;
-
-        public Likelihood(DiaryActivity a, double likelihood){
-            activity = a;
-            this.likelihood = likelihood;
-        }
-    }
-
-    /* it seems most conditions will need dedicated database operations, and we don't want
-     * to mess up with the ContentProvider, so let's get a new helper here */
-    static final LocalDBHelper mOpenHelper = new LocalDBHelper(MVApplication.getAppContext());
-
-    /* storage for the likelyhoods */
-    private @NonNull List<Likelihood> result = new ArrayList<>(1);
-
-    /* is the worker thread for the current Condition evaluating */
-    private boolean isActive = false;
-
-    protected double weight;
-
-    private final Thread worker = new Thread(() -> {
-        android.os.Process.setThreadPriority(android.os.Process.THREAD_PRIORITY_BACKGROUND);
-        while(true){
-            if(isActive) {
-                doEvaluation();
-                isActive = false;
-                ActivityHelper.helper.conditionEvaluationFinished();
-            }
-            try {
-                Thread.sleep(1000);
-            }catch(InterruptedException e){
-
-            }
-        }
-    });
-
-    /*
-     * return the likelihoods
-     * return a list of DiaryActivities which have a non-zero likelihood under this condition
-     * all activities not in the result are assumed to have likelyhood zero
-     */
-    public synchronized @NonNull List<Likelihood> likelihoods(){
-        return result;
-    }
-
-    /*
-     * set the result from the doEvaluation method in subclasses
-     */
-    protected synchronized void setResult(@NonNull List<Likelihood> likelihoods){
-        result = likelihoods;
-    }
-
-    /*
-     * trigger the likelyhood evaluation
-     * callable in any thread, creates thread and evaluates
-     */
-    public void refresh(){
-        // TODO: it seems to be a good idea to put the thread somehow into the WAIT state
-        if(worker.getState() == NEW){
-            worker.start();
-            worker.setName(this.getClass().getSimpleName() + "-" + worker.getName());
-        }else {
-            worker.interrupt();
-        }
-        isActive = true;
-    }
-
-    /*
-     * return TRUE if the evaluation is in progress
-     * callable from everywhere
-     */
-    public synchronized boolean isActive(){
-        return isActive;
-    }
-
-    /*
-     * the likelyhood evaluation, to be executed in Condition thread
-     * this shall call Condition.setResult on finish, and NOT modify result directly
-     */
-    protected abstract void doEvaluation();
-
-    /**
-     * Called on change of the activity order due to likelyhood.
-     */
-    public final void onActivityOrderChanged() {
-        // would be very bad to add code here :-)
-    }
-
-    public String name() {
-        return getClass().getName();
-    }
-}
-
diff --git a/app/src/main/java/com/mdiqentw/lifedots/model/conditions/Condition.kt b/app/src/main/java/com/mdiqentw/lifedots/model/conditions/Condition.kt
new file mode 100755
index 0000000..49f1eaf
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/model/conditions/Condition.kt
@@ -0,0 +1,122 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.model.conditions
+
+import android.os.Process
+import androidx.preference.PreferenceManager
+import com.mdiqentw.lifedots.MVApplication
+import com.mdiqentw.lifedots.db.LocalDBHelper
+import com.mdiqentw.lifedots.helpers.ActivityHelper
+import com.mdiqentw.lifedots.model.DiaryActivity
+
+/*
+ * Conditions model a specific aspect which influences the likelihood of the activities.
+ **/
+abstract class Condition {
+    @JvmField
+    val sharedPreferences = PreferenceManager.getDefaultSharedPreferences(MVApplication.appContext!!)
+
+    class Likelihood(val activity: DiaryActivity, var likelihood: Double)
+
+    /* storage for the likelyhoods */
+    private var result: List<Likelihood> = ArrayList(1)
+
+    /*
+     * return TRUE if the evaluation is in progress
+     * callable from everywhere
+     */
+    /* is the worker thread for the current Condition evaluating */
+    @get:Synchronized
+    var isActive = false
+        private set
+    @JvmField
+    protected var weight = 0.0
+    private val worker = Thread {
+        Process.setThreadPriority(Process.THREAD_PRIORITY_BACKGROUND)
+        while (true) {
+            if (isActive) {
+                doEvaluation()
+                isActive = false
+                ActivityHelper.helper.conditionEvaluationFinished()
+            }
+            try {
+                Thread.sleep(1000)
+            } catch (e: InterruptedException) {
+            }
+        }
+    }
+
+    /*
+     * return the likelihoods
+     * return a list of DiaryActivities which have a non-zero likelihood under this condition
+     * all activities not in the result are assumed to have likelyhood zero
+     */
+    @Synchronized
+    fun likelihoods(): List<Likelihood> {
+        return result
+    }
+
+    /*
+     * set the result from the doEvaluation method in subclasses
+     */
+    @Synchronized
+    protected fun setResult(likelihoods: List<Likelihood>) {
+        result = likelihoods
+    }
+
+    /*
+     * trigger the likelyhood evaluation
+     * callable in any thread, creates thread and evaluates
+     */
+    fun refresh() {
+        // TODO: it seems to be a good idea to put the thread somehow into the WAIT state
+        if (worker.state == Thread.State.NEW) {
+            worker.start()
+            worker.name = this.javaClass.simpleName + "-" + worker.name
+        } else {
+            worker.interrupt()
+        }
+        isActive = true
+    }
+
+    /*
+     * the likelyhood evaluation, to be executed in Condition thread
+     * this shall call Condition.setResult on finish, and NOT modify result directly
+     */
+    protected abstract fun doEvaluation()
+
+    /**
+     * Called on change of the activity order due to likelyhood.
+     */
+    fun onActivityOrderChanged() {
+        // would be very bad to add code here :-)
+    }
+
+    fun name(): String {
+        return javaClass.name
+    }
+
+    companion object {
+        /* it seems most conditions will need dedicated database operations, and we don't want
+     * to mess up with the ContentProvider, so let's get a new helper here */
+        @JvmField
+        val mOpenHelper = LocalDBHelper(MVApplication.appContext!!)
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/model/conditions/DayTimeCondition.java b/app/src/main/java/com/mdiqentw/lifedots/model/conditions/DayTimeCondition.java
deleted file mode 100644
index 03c6d19..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/model/conditions/DayTimeCondition.java
+++ /dev/null
@@ -1,207 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots.model.conditions;
-
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-
-import java.util.ArrayList;
-import java.util.Calendar;
-import java.util.HashMap;
-import java.util.List;
-
-import com.mdiqentw.lifedots.db.Contract;
-import com.mdiqentw.lifedots.helpers.ActivityHelper;
-import com.mdiqentw.lifedots.model.DiaryActivity;
-import com.mdiqentw.lifedots.ui.settings.SettingsActivity;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-public class DayTimeCondition extends Condition implements ActivityHelper.DataChangedListener {
-    final HashMap<DiaryActivity, Float> activityStartTimeMean = new HashMap<>(127);
-    final HashMap<DiaryActivity, Float> activityStartTimeVar = new HashMap<>(127);
-
-    public DayTimeCondition(ActivityHelper helper){
-        helper.registerDataChangeListener(this);
-    }
-
-    private void updateStartTimes(){
-        SQLiteDatabase db = mOpenHelper.getReadableDatabase();
-// TODO: mean should consider "modulo" - i.e. agv of (23h and 1h) should be 0h
-// TODO: extend to multiple peaks per day (configurable or better by generic k-means)
-// TODO: check if utc handling is really correct...
-        Cursor c = db.rawQuery(
-                        "SELECT " + Contract.Diary.TABLE_NAME + "."
-                        + Contract.Diary.ACT_ID
-                        + ", sub.m as mean, "
-                        + "AVG(  (   (    strftime('%s'," + Contract.Diary.TABLE_NAME + "." + Contract.Diary.START
-                        +                      "/1000, 'unixepoch', 'utc')"
-                        +             " - strftime('%s',datetime(" + Contract.Diary.TABLE_NAME + "." + Contract.Diary.START
-                        +                      "/1000, 'unixepoch', 'start of day', 'utc'), 'utc')"
-                        +           ") - sub.m"
-                        +      " )*( (    strftime('%s'," + Contract.Diary.TABLE_NAME + "." + Contract.Diary.START
-                        +                      "/1000, 'unixepoch', 'utc')"
-                        +             " - strftime('%s',datetime(" + Contract.Diary.TABLE_NAME + "." + Contract.Diary.START
-                        +                      "/1000, 'unixepoch', 'start of day', 'utc'), 'utc')"
-                        +           ") - sub.m"
-                        +         ")"
-                        +    ") as var "
-                        + "FROM " + Contract.Diary.TABLE_NAME + ", "
-                        + "(SELECT " + Contract.Diary.ACT_ID + ", "
-                        + "   AVG(    strftime('%s'," + Contract.Diary.START
-                        +                      "/1000, 'unixepoch', 'utc')"
-                        +             " - strftime('%s',datetime(" + Contract.Diary.START
-                        +                      "/1000, 'unixepoch', 'start of day', 'utc'), 'utc')"
-                        +        ") as m "
-                        + " FROM " + Contract.Diary.TABLE_NAME + " GROUP BY " + Contract.Diary.ACT_ID + ") as sub "
-                        + "WHERE " + Contract.Diary.TABLE_NAME + "." + Contract.Diary.ACT_ID + "=sub." + Contract.Diary.ACT_ID
-                        + " AND " + Contract.Diary.TABLE_NAME + "." + Contract.Diary._DELETED + "=0 "
-                        + "GROUP BY " + Contract.Diary.TABLE_NAME + "." + Contract.Diary.ACT_ID
-                ,null);
-        c.moveToFirst();
-        while (!c.isAfterLast()) {
-            DiaryActivity a = ActivityHelper.helper.activityWithId(c.getInt(0));
-            if(a != null) {
-                Float mean = c.getFloat(1);
-                activityStartTimeMean.put(a, mean);
-                float var = c.getFloat(2);
-                if(var < 0.1){
-                    // we use a sd of 30min for those activities which are only there once
-                    var = (float)(30 * 60) * (30 * 60);
-                }
-                activityStartTimeVar.put(a, var);
-            }
-            c.moveToNext();
-        }
-        c.close();
-    }
-
-    @Override
-    protected void doEvaluation() {
-        double weight = Double.parseDouble(sharedPreferences.getString(SettingsActivity.KEY_PREF_COND_DAYTIME, "20"));
-        ArrayList<Likelihood> result = new ArrayList<>(ActivityHelper.helper.getUnsortedActivities().size());
-
-        if(weight > 0.0000001) {
-            Calendar c = Calendar.getInstance();
-            long nowm = c.getTimeInMillis();
-            c.set(Calendar.HOUR_OF_DAY, 0);
-            c.set(Calendar.MINUTE, 0);
-            c.set(Calendar.SECOND, 0);
-            c.set(Calendar.MILLISECOND, 0);
-            long passed = nowm - c.getTimeInMillis();
-            float now = passed / 1000.0f;
-            List<DiaryActivity> list = ActivityHelper.helper.getUnsortedActivities();
-            for (DiaryActivity a:list) {
-                float DAY = 24 * 60 * 60;
-                float mean = DAY / 2.0f;
-                float var = 30*60*30*60;
-
-                Float meanF = activityStartTimeMean.get(a);
-                Float varF = activityStartTimeVar.get(a);
-                if(meanF != null && varF != null){
-                    mean = meanF;
-                    var = varF;
-                }
-
-                /*
-                 modulo time distance would be
-                float delta = Math.abs(now - mean);
-                float dist = Math.min(delta, DAY - delta);
-                */
-
-                double ld = DAY / 180 / Math.sqrt(2 * Math.PI * var); // Math.sqrt(2 * Math.PI);
-                ld = ld * Math.exp(-((now - mean) * (now - mean) / (2 * var)));
-
-                ld = ld * weight;
-                Likelihood l = new Likelihood(a, ld);
-                result.add(l);
-            }
-        }
-        setResult(result);
-    }
-
-    /**
-     * Called when the data has changed and no further specification is possible.
-     * => everything needs to be refreshed!
-     */
-    @Override
-    public void onActivityDataChanged() {
-        updateStartTimes();
-        refresh();
-    }
-
-    /**
-     * Called when the data of one activity was changed.
-     *
-     * @param activity
-     */
-    @Override
-    public void onActivityDataChanged(DiaryActivity activity) {
-
-    }
-
-    /**
-     * Called on addition of an activity.
-     *
-     * @param activity
-     */
-    @Override
-    public void onActivityAdded(DiaryActivity activity) {
-
-    }
-
-    /**
-     * Called on removal of an activity.
-     *
-     * @param activity
-     */
-    @Override
-    public void onActivityRemoved(DiaryActivity activity) {
-
-    }
-
-    /**
-     * Called on change of the current activity.
-     */
-    @Override
-    public void onActivityChanged() {
-        // TODO: optimize performance: update only for the current newly selected ID
-        updateStartTimes();
-    }
-
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/model/conditions/GlobalOccurrenceCondition.java b/app/src/main/java/com/mdiqentw/lifedots/model/conditions/GlobalOccurrenceCondition.java
deleted file mode 100644
index b81865a..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/model/conditions/GlobalOccurrenceCondition.java
+++ /dev/null
@@ -1,160 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots.model.conditions;
-
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteQueryBuilder;
-import android.util.Log;
-
-import java.util.ArrayList;
-import java.util.List;
-
-import com.mdiqentw.lifedots.db.Contract;
-import com.mdiqentw.lifedots.helpers.ActivityHelper;
-import com.mdiqentw.lifedots.model.DiaryActivity;
-import com.mdiqentw.lifedots.ui.settings.SettingsActivity;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-/**
- * Model the likelihood of the activities based on its predecessors in the diary
- */
-
-public class GlobalOccurrenceCondition extends Condition
-        implements ActivityHelper.DataChangedListener {
-
-    public GlobalOccurrenceCondition(ActivityHelper helper){
-        helper.registerDataChangeListener(this);
-    }
-
-    protected String selectionString() {
-        return  "D." + Contract.Diary._DELETED + " = 0 " +
-                "AND D." + Contract.Diary.ACT_ID + " = A." + Contract.DiaryActivity._ID +
-                " AND A. " + Contract.DiaryActivity._DELETED + " = 0 ";
-    }
-
-    protected void setWeight() {
-        weight = Double.parseDouble(sharedPreferences.getString(SettingsActivity.KEY_PREF_COND_OCCURRENCE, "0"));
-    }
-
-    @Override
-    protected void doEvaluation() {
-        setWeight();
-        List<DiaryActivity> all = ActivityHelper.helper.getUnsortedActivities();
-        ArrayList<Likelihood> result = new ArrayList<>(all.size());
-
-        if(weight > 0.000001) {
-            SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder();
-            SQLiteDatabase db = mOpenHelper.getReadableDatabase();
-
-            qBuilder.setTables(Contract.Diary.TABLE_NAME + " D, " + Contract.DiaryActivity.TABLE_NAME + " A");
-            Cursor c = qBuilder.query(db,
-                    new String[]{"D." + Contract.Diary.ACT_ID, "COUNT(D." + Contract.Diary.ACT_ID + ")"},
-                    selectionString(),
-                    null,
-                    "D." + Contract.Diary.ACT_ID,
-                    null,
-                    null);
-            c.moveToFirst();
-            long total = 0;
-            long max = 0;
-            while (!c.isAfterLast()) {
-                DiaryActivity a = ActivityHelper.helper.activityWithId(c.getInt(0));
-                if (a == null) {
-                    Log.i("doEvaluation", String.format("ID: %d links to no activity %d", c.getInt(0), c.getInt(1)));
-                } else {
-                    total = total + c.getInt(1);
-                    max = Math.max(max, c.getInt(1));
-                    result.add(new Likelihood(a, c.getInt(1)));
-                }
-                c.moveToNext();
-            }
-
-            c.close();
-
-            for (Likelihood l : result) {
-                l.likelihood = l.likelihood / max * weight;
-            }
-        }
-        setResult(result);
-    }
-
-    /**
-     * Called when the data has changed and no further specification is possible.
-     * => everything needs to be refreshed!
-     */
-    @Override
-    public void onActivityDataChanged() { }
-
-    /**
-     * Called when the data of one activity was changed.
-     *
-     * @param activity
-     */
-    @Override
-    public void onActivityDataChanged(DiaryActivity activity) { }
-
-    /**
-     * Called on addition of an activity.
-     *
-     * @param activity
-     */
-    @Override
-    public void onActivityAdded(DiaryActivity activity) {
-        refresh();
-    }
-
-    /**
-     * Called on removale of an activity.
-     *
-     * @param activity
-     */
-    @Override
-    public void onActivityRemoved(DiaryActivity activity) {
-        refresh();
-    }
-
-    /**
-     * Called on change of the current activity.
-     */
-    @Override
-    public void onActivityChanged() {
-        refresh();
-    }
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/model/conditions/GlobalOccurrenceCondition.kt b/app/src/main/java/com/mdiqentw/lifedots/model/conditions/GlobalOccurrenceCondition.kt
new file mode 100755
index 0000000..da44b3f
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/model/conditions/GlobalOccurrenceCondition.kt
@@ -0,0 +1,124 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.model.conditions
+
+import android.database.sqlite.SQLiteQueryBuilder
+import android.util.Log
+import com.mdiqentw.lifedots.db.Contract
+import com.mdiqentw.lifedots.helpers.ActivityHelper
+import com.mdiqentw.lifedots.helpers.ActivityHelper.DataChangedListener
+import com.mdiqentw.lifedots.model.DiaryActivity
+import com.mdiqentw.lifedots.ui.settings.SettingsActivity
+import kotlin.math.max
+
+/**
+ * Model the likelihood of the activities based on its predecessors in the diary
+ */
+open class GlobalOccurrenceCondition(helper: ActivityHelper) : Condition(), DataChangedListener {
+    init {
+        helper.registerDataChangeListener(this)
+    }
+
+    protected open fun selectionString(): String? {
+        return "D." + Contract.Diary._DELETED + " = 0 " +
+                "AND D." + Contract.Diary.ACT_ID + " = A." + Contract.DiaryActivity._ID +
+                " AND A. " + Contract.DiaryActivity._DELETED + " = 0 "
+    }
+
+    protected open fun setWeight() {
+        weight = sharedPreferences.getString(SettingsActivity.KEY_PREF_COND_OCCURRENCE, "0")!!.toDouble()
+    }
+
+    override fun doEvaluation() {
+        setWeight()
+        val all = ActivityHelper.helper.getUnsortedActivities()
+        val result = ArrayList<Likelihood>(all.size)
+        if (weight > 0.000001) {
+            val qBuilder = SQLiteQueryBuilder()
+            val db = mOpenHelper.readableDatabase
+            qBuilder.tables = Contract.Diary.TABLE_NAME + " D, " + Contract.DiaryActivity.TABLE_NAME + " A"
+            val c = qBuilder.query(
+                db, arrayOf("D." + Contract.Diary.ACT_ID, "COUNT(D." + Contract.Diary.ACT_ID + ")"),
+                selectionString(),
+                null,
+                "D." + Contract.Diary.ACT_ID,
+                null,
+                null
+            )
+            c.moveToFirst()
+            var total: Long = 0
+            var max: Long = 0
+            while (!c.isAfterLast) {
+                val a = ActivityHelper.helper.activityWithId(c.getInt(0))
+                if (a == null) {
+                    Log.i("doEvaluation", String.format("ID: %d links to no activity %d", c.getInt(0), c.getInt(1)))
+                } else {
+                    total += c.getInt(1)
+                    max = max(max, c.getInt(1).toLong())
+                    result.add(Likelihood(a, c.getInt(1).toDouble()))
+                }
+                c.moveToNext()
+            }
+            c.close()
+            for (l in result) {
+                l.likelihood = l.likelihood / max * weight
+            }
+        }
+        setResult(result)
+    }
+
+    /**
+     * Called when the data has changed and no further specification is possible.
+     * => everything needs to be refreshed!
+     */
+    override fun onActivityDataChanged() {}
+
+    /**
+     * Called when the data of one activity was changed.
+     *
+     * @param activity
+     */
+    override fun onActivityDataChanged(activity: DiaryActivity) {}
+
+    /**
+     * Called on addition of an activity.
+     *
+     * @param activity
+     */
+    override fun onActivityAdded(activity: DiaryActivity) {
+        refresh()
+    }
+
+    /**
+     * Called on removale of an activity.
+     *
+     * @param activity
+     */
+    override fun onActivityRemoved(activity: DiaryActivity) {
+        refresh()
+    }
+
+    /**
+     * Called on change of the current activity.
+     */
+    override fun onActivityChanged() {
+        refresh()
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/model/conditions/PausedCondition.java b/app/src/main/java/com/mdiqentw/lifedots/model/conditions/PausedCondition.java
deleted file mode 100644
index 9ac5afa..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/model/conditions/PausedCondition.java
+++ /dev/null
@@ -1,161 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots.model.conditions;
-
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteQueryBuilder;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.Map;
-
-import com.mdiqentw.lifedots.db.Contract;
-import com.mdiqentw.lifedots.helpers.ActivityHelper;
-import com.mdiqentw.lifedots.model.DiaryActivity;
-import com.mdiqentw.lifedots.ui.settings.SettingsActivity;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-public class PausedCondition extends Condition implements ActivityHelper.DataChangedListener {
-    HashMap<DiaryActivity, Float> activityStartTimeMean = new HashMap<>(127);
-    HashMap<DiaryActivity, Float> activityStartTimeVar = new HashMap<>(127);
-    private static final long TIMEFRAME = 1000 * 60 * 60 * 24 * 10; // let's consider 10 days
-
-    public PausedCondition(ActivityHelper helper){
-        helper.registerDataChangeListener(this);
-    }
-
-    @Override
-    protected void doEvaluation() {
-        double weight;
-        weight = Double.parseDouble(sharedPreferences.getString(SettingsActivity.KEY_PREF_PAUSED, "10"));
-        ArrayList<Likelihood> result = new ArrayList<>(ActivityHelper.helper.getUnsortedActivities().size());
-        HashMap<DiaryActivity,Double> m = new HashMap<>(result.size());
-
-        if(weight > 0.0000001) {
-            SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder();
-            SQLiteDatabase db = mOpenHelper.getReadableDatabase();
-
-            qBuilder.setTables(Contract.Diary.TABLE_NAME + " D, " + Contract.DiaryActivity.TABLE_NAME + " A");
-            Cursor c = qBuilder.query(db,
-                    new String[]{"D." + Contract.Diary.ACT_ID},
-                    "D." + Contract.Diary._DELETED + " = 0 " +
-                            "AND D." + Contract.Diary.ACT_ID + " = A." + Contract.DiaryActivity._ID + " AND A." + Contract.DiaryActivity._DELETED + " = 0 " +
-                            "AND D." + Contract.Diary.END + " > " + (System.currentTimeMillis() - TIMEFRAME),
-                    null,
-                    null,
-                    null,
-                    "D." + Contract.Diary.END + " DESC");
-            c.moveToFirst();
-            long cnt = 1;
-            while (!c.isAfterLast()) {
-                DiaryActivity a = ActivityHelper.helper.activityWithId(c.getInt(0));
-                double w = weight * Math.exp((1 - cnt) / 3.0);
-                if(m.containsKey(a)){
-                    w = w + m.get(a);
-                }
-                m.put(a, w);
-                c.moveToNext();
-                cnt++;
-            }
-
-            for(Map.Entry<DiaryActivity, Double> entry : m.entrySet()) {
-                result.add(new Likelihood(entry.getKey(), entry.getValue()));
-            }
-
-            c.close();
-
-        }
-        setResult(result);
-    }
-
-    /**
-     * Called when the data has changed and no further specification is possible.
-     * => everything needs to be refreshed!
-     */
-    @Override
-    public void onActivityDataChanged() {
-        refresh();
-    }
-
-    /**
-     * update the last 10 Days
-     */
-    private void updateHistory() {
-    }
-
-    /**
-     * Called when the data of one activity was changed.
-     *
-     * @param activity
-     */
-    @Override
-    public void onActivityDataChanged(DiaryActivity activity) {
-
-    }
-
-    /**
-     * Called on addition of an activity.
-     *
-     * @param activity
-     */
-    @Override
-    public void onActivityAdded(DiaryActivity activity) {
-
-    }
-
-    /**
-     * Called on removal of an activity.
-     *
-     * @param activity
-     */
-    @Override
-    public void onActivityRemoved(DiaryActivity activity) {
-
-    }
-
-    /**
-     * Called on change of the current activity.
-     */
-    @Override
-    public void onActivityChanged() {
-        refresh();
-    }
-
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/model/conditions/PredecessorCondition.java b/app/src/main/java/com/mdiqentw/lifedots/model/conditions/PredecessorCondition.java
deleted file mode 100644
index 8c7514b..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/model/conditions/PredecessorCondition.java
+++ /dev/null
@@ -1,152 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots.model.conditions;
-
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.database.sqlite.SQLiteQueryBuilder;
-
-import java.util.ArrayList;
-
-import com.mdiqentw.lifedots.db.Contract;
-import com.mdiqentw.lifedots.helpers.ActivityHelper;
-import com.mdiqentw.lifedots.model.DiaryActivity;
-import com.mdiqentw.lifedots.ui.settings.SettingsActivity;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-/**
- * Model the likelihood of the activities based on its predecessors in the diary
- */
-
-public class PredecessorCondition extends Condition implements ActivityHelper.DataChangedListener {
-    public PredecessorCondition(ActivityHelper helper){
-        helper.registerDataChangeListener(this);
-    }
-
-    @Override
-    protected void doEvaluation() {
-        double weight = Double.parseDouble(sharedPreferences.getString(SettingsActivity.KEY_PREF_COND_PREDECESSOR, "20"));
-        DiaryActivity current = ActivityHelper.helper.getCurrentActivity();
-        ArrayList<Likelihood> result = new ArrayList<>(ActivityHelper.helper.getUnsortedActivities().size());
-
-        if(weight > 0.0000001 && current != null) {
-
-            SQLiteQueryBuilder qBuilder = new SQLiteQueryBuilder();
-            SQLiteDatabase db = mOpenHelper.getReadableDatabase();
-
-            qBuilder.setTables(Contract.Diary.TABLE_NAME + " A, " + Contract.Diary.TABLE_NAME + " B, " +
-                    Contract.DiaryActivity.TABLE_NAME + " C, " + Contract.DiaryActivity.TABLE_NAME + " D");
-            Cursor c = qBuilder.query(db,
-                    new String[]{"A." + Contract.Diary.ACT_ID, "COUNT(A." + Contract.Diary.ACT_ID + ")"},
-                    " B." + Contract.Diary.ACT_ID + " = ? AND (A." +
-                            Contract.Diary.START + " >= B." + Contract.Diary.END + " - 500) AND (A." +
-                            Contract.Diary.START + " < B." + Contract.Diary.END + " + 50)" +
-                            "AND A." + Contract.Diary._DELETED + " = 0 AND B." + Contract.Diary._DELETED + " = 0 " +
-                            "AND A." + Contract.Diary.ACT_ID + " = C." + Contract.DiaryActivity._ID + " AND C. " + Contract.DiaryActivity._DELETED + " = 0 " +
-                            "AND B." + Contract.Diary.ACT_ID + " = D." + Contract.DiaryActivity._ID + " AND D. " + Contract.DiaryActivity._DELETED + " = 0"
-                    ,
-                    new String[]{Long.toString(current.getId())},
-                    "A." + Contract.Diary.ACT_ID,
-                    null,
-                    null);
-            c.moveToFirst();
-            long total = 0;
-            while (!c.isAfterLast()) {
-                DiaryActivity a = ActivityHelper.helper.activityWithId(c.getInt(0));
-                total = total + c.getInt(1);
-                result.add(new Likelihood(a, c.getInt(1)));
-                c.moveToNext();
-            }
-
-            for (Likelihood l : result) {
-                l.likelihood = l.likelihood / total * weight;
-            }
-
-            c.close();
-        }
-        setResult(result);
-    }
-
-    /**
-     * Called when the data has changed and no further specification is possible.
-     * => everything needs to be refreshed!
-     */
-    @Override
-    public void onActivityDataChanged() {
-
-    }
-
-    /**
-     * Called when the data of one activity was changed.
-     *
-     * @param activity
-     */
-    @Override
-    public void onActivityDataChanged(DiaryActivity activity) {
-
-    }
-
-    /**
-     * Called on addition of an activity.
-     *
-     * @param activity
-     */
-    @Override
-    public void onActivityAdded(DiaryActivity activity) {
-
-    }
-
-    /**
-     * Called on removale of an activity.
-     *
-     * @param activity
-     */
-    @Override
-    public void onActivityRemoved(DiaryActivity activity) {
-
-    }
-
-    /**
-     * Called on change of the current activity.
-     */
-    @Override
-    public void onActivityChanged() {
-        refresh();
-    }
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/model/conditions/RecentOccurrenceCondition.java b/app/src/main/java/com/mdiqentw/lifedots/model/conditions/RecentOccurrenceCondition.java
deleted file mode 100644
index 0e85864..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/model/conditions/RecentOccurrenceCondition.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots.model.conditions;
-
-import com.mdiqentw.lifedots.db.Contract;
-import com.mdiqentw.lifedots.helpers.ActivityHelper;
-import com.mdiqentw.lifedots.ui.settings.SettingsActivity;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-/**
- * Model the likelihood of the activities based on its predecessors in the diary
- */
-
-public class RecentOccurrenceCondition extends GlobalOccurrenceCondition {
-    public static final long MS_Per_Day = 1000 * 60 * 60 * 24;
-
-    public RecentOccurrenceCondition(ActivityHelper helper){
-        super(helper);
-        helper.registerDataChangeListener(this);
-    }
-
-    @Override
-    protected String selectionString() {
-        long threeMonthsAgo = System.currentTimeMillis() - 90 * MS_Per_Day;
-
-        return  "D." + Contract.Diary._DELETED + " = 0 " +
-                "AND D." + Contract.Diary.ACT_ID + " = A." + Contract.DiaryActivity._ID +
-                " AND A. " + Contract.DiaryActivity._DELETED + " = 0 AND D." +
-                Contract.Diary.START + " >= " + threeMonthsAgo;
-    }
-
-    @Override
-    protected void setWeight() {
-        weight = Double.parseDouble(sharedPreferences.getString(SettingsActivity.KEY_PREF_COND_RECENCY, "20"));
-    }
-
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/model/conditions/RecentOccurrenceCondition.kt b/app/src/main/java/com/mdiqentw/lifedots/model/conditions/RecentOccurrenceCondition.kt
new file mode 100755
index 0000000..7eb9c1e
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/model/conditions/RecentOccurrenceCondition.kt
@@ -0,0 +1,49 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.model.conditions
+
+import com.mdiqentw.lifedots.db.Contract
+import com.mdiqentw.lifedots.helpers.ActivityHelper
+import com.mdiqentw.lifedots.ui.settings.SettingsActivity
+
+/**
+ * Model the likelihood of the activities based on its predecessors in the diary
+ */
+class RecentOccurrenceCondition(helper: ActivityHelper) : GlobalOccurrenceCondition(helper) {
+    init {
+        helper.registerDataChangeListener(this)
+    }
+
+    override fun selectionString(): String {
+        val threeMonthsAgo = System.currentTimeMillis() - 90 * MS_Per_Day
+        return "D." + Contract.Diary._DELETED + " = 0 " +
+                "AND D." + Contract.Diary.ACT_ID + " = A." + Contract.DiaryActivity._ID +
+                " AND A. " + Contract.DiaryActivity._DELETED + " = 0 AND D." +
+                Contract.Diary.START + " >= " + threeMonthsAgo
+    }
+
+    override fun setWeight() {
+        weight = sharedPreferences.getString(SettingsActivity.KEY_PREF_COND_RECENCY, "20")!!.toDouble()
+    }
+
+    companion object {
+        const val MS_Per_Day = (1000 * 60 * 60 * 24).toLong()
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/generic/AboutActivity.java b/app/src/main/java/com/mdiqentw/lifedots/ui/generic/AboutActivity.java
deleted file mode 100644
index 7462d66..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/generic/AboutActivity.java
+++ /dev/null
@@ -1,114 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2017 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots.ui.generic;
-
-
-import android.os.Build;
-import android.os.Bundle;
-import android.text.Html;
-import android.text.method.LinkMovementMethod;
-import android.widget.TextView;
-
-import androidx.databinding.DataBindingUtil;
-
-import com.mdiqentw.lifedots.BuildConfig;
-import com.mdiqentw.lifedots.R;
-import com.mdiqentw.lifedots.databinding.ActivityAboutBinding;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-public class AboutActivity extends BaseActivity {
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        ActivityAboutBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_about);
-        setContent(binding.getRoot());
-
-        TextView aboutText = binding.aboutTextView;
-
-        String appName = getResources().getString(R.string.app_name);
-        String contributors = getResources().getString(R.string.contributors);
-        String libraries = getResources().getString(R.string.libraries);
-        String versionName = BuildConfig.VERSION_NAME;
-
-        String mergedAboutText = "<h1>" + appName + "</h1>";
-        mergedAboutText += getResources().getString(R.string.about_text_version, versionName);
-        mergedAboutText += "<p>" + getResources().getString(R.string.about_text_intro) + "</p>";
-        mergedAboutText += "<p>" + getResources().getString(R.string.about_fork) + "</p>";
-
-        mergedAboutText += "<h1>" + getResources().getString(R.string.about_text_licence_h) + "</h1>";
-        mergedAboutText += "<p>" + getResources().getString(R.string.about_text_licence, appName) + "</p>";
-        mergedAboutText += "<p>" + getResources().getString(R.string.about_text_license_2) + "</p>";
-
-        mergedAboutText += "<h1>" + getResources().getString(R.string.about_text_privacy_h) + "</h1>";
-        mergedAboutText += "<p>" + getResources().getString(R.string.about_text_privacy, appName) + "</p>";
-
-        mergedAboutText += "<h1>" + getResources().getString(R.string.about_text_contact_h) + "</h1>";
-        mergedAboutText += "<p>" + getResources().getString(R.string.about_text_contact) + "</p>";
-        mergedAboutText += "<p>" + getResources().getString(R.string.about_text_contact_2) + "</p>";
-
-        mergedAboutText += "<h1>" + getResources().getString(R.string.about_text_support_h) + "</h1>";
-        mergedAboutText += "<p>" + getResources().getString(R.string.about_text_support, appName) + "</p>";
-
-        mergedAboutText += "<h1>" + getResources().getString(R.string.about_text_cont_h) + "</h1>";
-        mergedAboutText += "<p>" + contributors + "</p>";
-        mergedAboutText += "<p>" + getResources().getString(R.string.about_text_cont_2) + "</p>";
-
-        mergedAboutText += "<h1>" + getResources().getString(R.string.about_text_lib_h) + "</h1>";
-        mergedAboutText += "<p>" + getResources().getString(R.string.about_text_lib) + "</p>";
-        mergedAboutText += "<p>" + libraries + "</p>";
-
-        if (Build.VERSION.SDK_INT >= 24) {
-            aboutText.setText(Html.fromHtml(mergedAboutText, Html.FROM_HTML_MODE_LEGACY));
-        } else {
-            aboutText.setText(Html.fromHtml(mergedAboutText));
-        }
-
-        aboutText.setMovementMethod(LinkMovementMethod.getInstance());
-
-        mDrawerToggle.setDrawerIndicatorEnabled(false);
-    }
-
-    @Override
-    public void onResume(){
-        mNavigationView.getMenu().findItem(R.id.nav_about).setChecked(true);
-        super.onResume();
-    }
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/generic/AboutActivity.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/generic/AboutActivity.kt
new file mode 100755
index 0000000..5eb8597
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/generic/AboutActivity.kt
@@ -0,0 +1,74 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2017 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.ui.generic
+
+import android.os.Build
+import android.os.Bundle
+import android.text.Html
+import android.text.method.LinkMovementMethod
+import androidx.databinding.DataBindingUtil
+import com.mdiqentw.lifedots.BuildConfig
+import com.mdiqentw.lifedots.R
+import com.mdiqentw.lifedots.databinding.ActivityAboutBinding
+
+class AboutActivity : BaseActivity() {
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        val binding = DataBindingUtil.setContentView<ActivityAboutBinding>(this, R.layout.activity_about)
+        setContent(binding.root)
+        val aboutText = binding.aboutTextView
+        val appName = resources.getString(R.string.app_name)
+        val contributors = resources.getString(R.string.contributors)
+        val libraries = resources.getString(R.string.libraries)
+        val versionName = BuildConfig.VERSION_NAME
+        var mergedAboutText = "<h1>$appName</h1>"
+        mergedAboutText += resources.getString(R.string.about_text_version, versionName)
+        mergedAboutText += "<p>" + resources.getString(R.string.about_text_intro) + "</p>"
+        mergedAboutText += "<p>" + resources.getString(R.string.about_fork) + "</p>"
+        mergedAboutText += "<h1>" + resources.getString(R.string.about_text_licence_h) + "</h1>"
+        mergedAboutText += "<p>" + resources.getString(R.string.about_text_licence, appName) + "</p>"
+        mergedAboutText += "<p>" + resources.getString(R.string.about_text_license_2) + "</p>"
+        mergedAboutText += "<h1>" + resources.getString(R.string.about_text_privacy_h) + "</h1>"
+        mergedAboutText += "<p>" + resources.getString(R.string.about_text_privacy, appName) + "</p>"
+        mergedAboutText += "<h1>" + resources.getString(R.string.about_text_contact_h) + "</h1>"
+        mergedAboutText += "<p>" + resources.getString(R.string.about_text_contact) + "</p>"
+        mergedAboutText += "<p>" + resources.getString(R.string.about_text_contact_2) + "</p>"
+        mergedAboutText += "<h1>" + resources.getString(R.string.about_text_support_h) + "</h1>"
+        mergedAboutText += "<p>" + resources.getString(R.string.about_text_support, appName) + "</p>"
+        mergedAboutText += "<h1>" + resources.getString(R.string.about_text_cont_h) + "</h1>"
+        mergedAboutText += "<p>$contributors</p>"
+        mergedAboutText += "<p>" + resources.getString(R.string.about_text_cont_2) + "</p>"
+        mergedAboutText += "<h1>" + resources.getString(R.string.about_text_lib_h) + "</h1>"
+        mergedAboutText += "<p>" + resources.getString(R.string.about_text_lib) + "</p>"
+        mergedAboutText += "<p>$libraries</p>"
+        if (Build.VERSION.SDK_INT >= 24) {
+            aboutText.text = Html.fromHtml(mergedAboutText, Html.FROM_HTML_MODE_LEGACY)
+        } else {
+            aboutText.text = Html.fromHtml(mergedAboutText)
+        }
+        aboutText.movementMethod = LinkMovementMethod.getInstance()
+        mDrawerToggle.isDrawerIndicatorEnabled = false
+    }
+
+    public override fun onResume() {
+        mNavigationView.menu.findItem(R.id.nav_about).isChecked = true
+        super.onResume()
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/generic/BaseActivity.java b/app/src/main/java/com/mdiqentw/lifedots/ui/generic/BaseActivity.java
deleted file mode 100644
index db3d27e..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/generic/BaseActivity.java
+++ /dev/null
@@ -1,186 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2017 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-package com.mdiqentw.lifedots.ui.generic;
-
-import android.content.Intent;
-import android.content.res.Configuration;
-import android.os.Bundle;
-import android.view.MenuItem;
-import android.view.View;
-import android.widget.FrameLayout;
-import android.widget.Toast;
-
-import androidx.annotation.NonNull;
-import androidx.appcompat.app.ActionBarDrawerToggle;
-import androidx.appcompat.app.AppCompatActivity;
-import androidx.appcompat.widget.Toolbar;
-import androidx.core.view.GravityCompat;
-import androidx.databinding.DataBindingUtil;
-import androidx.drawerlayout.widget.DrawerLayout;
-
-import com.google.android.material.navigation.NavigationView;
-import com.mdiqentw.lifedots.R;
-import com.mdiqentw.lifedots.databinding.ActivityBaseBinding;
-import com.mdiqentw.lifedots.ui.history.HistoryActivity;
-import com.mdiqentw.lifedots.ui.history.MapActivity;
-import com.mdiqentw.lifedots.ui.main.MainActivity;
-import com.mdiqentw.lifedots.ui.settings.SettingsActivity;
-import com.mdiqentw.lifedots.ui.history.AnalyticsActivity;
-
-import java.util.Objects;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-/*
- * MainActivity to show most of the UI, based on switching the fragements
- *
- * */
-public class BaseActivity extends AppCompatActivity {
-    ActivityBaseBinding baseBinding;
-
-    protected DrawerLayout mDrawerLayout;
-    protected ActionBarDrawerToggle mDrawerToggle;
-    protected NavigationView mNavigationView;
-
-    protected Toolbar toolbar;
-
-    protected void setupDrawer() {
-        mDrawerLayout = baseBinding.drawerLayout;
-        mDrawerToggle = new ActionBarDrawerToggle(
-                this,
-                mDrawerLayout,
-                R.string.drawer_open,
-                R.string.drawer_close
-        );
-        mDrawerLayout.addDrawerListener(mDrawerToggle);
-
-        Objects.requireNonNull(getSupportActionBar()).setDisplayHomeAsUpEnabled(true);
-        getSupportActionBar().setHomeButtonEnabled(true);
-    }
-
-    protected void setupNavs() {
-        mNavigationView = baseBinding.navigationView;
-        mNavigationView.setNavigationItemSelectedListener(menuItem -> {
-            int mid = menuItem.getItemId();
-            if (mid == R.id.nav_main) {
-                if(!menuItem.isChecked()) {
-                    // start activity only if it is not currently checked
-                    Intent intentmain = new Intent(BaseActivity.this, MainActivity.class);
-                    intentmain.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP);
-                    startActivity(intentmain);
-                }
-            } else if (mid == R.id.nav_activity_manager) {
-                Intent intentmanage = new Intent(BaseActivity.this, ManageActivity.class);
-                startActivity(intentmanage);
-            } else if (mid == R.id.nav_diary) {
-                Intent intentdiary = new Intent(BaseActivity.this, HistoryActivity.class);
-                startActivity(intentdiary);
-            } else if (mid == R.id.nav_map) {
-                Intent intentmap = new Intent(BaseActivity.this, MapActivity.class);
-                startActivity(intentmap);
-            } else if (mid == R.id.nav_statistics) {
-                Intent intentstats = new Intent(BaseActivity.this, AnalyticsActivity.class);
-                startActivity(intentstats);
-            } else if (mid == R.id.nav_about) {
-                Intent intentabout = new Intent(BaseActivity.this, AboutActivity.class);
-                startActivity(intentabout);
-            } else if (mid == R.id.nav_privacy) {
-                Intent intentpriv = new Intent(BaseActivity.this, PrivacyPolicyActivity.class);
-                startActivity(intentpriv);
-            } else if (mid == R.id.nav_settings) {
-                Intent intentsettings = new Intent(BaseActivity.this, SettingsActivity.class);
-                startActivity(intentsettings);
-            } else
-                Toast.makeText(BaseActivity.this, menuItem.getTitle() + " is not yet implemented :-(", Toast.LENGTH_LONG).show();
-
-            mDrawerLayout.closeDrawers();
-            return true;
-        });
-    }
-
-    protected void initNavigation() {
-        toolbar = baseBinding.mainToolbar;
-        setSupportActionBar(toolbar);
-
-        setupDrawer();
-        setupNavs();
-    }
-
-    @Override
-    protected void onPostCreate(Bundle savedInstanceState) {
-        super.onPostCreate(savedInstanceState);
-        // Sync the toggle state after onRestoreInstanceState has occurred.
-        mDrawerToggle.syncState();
-    }
-
-    @Override
-    public void onConfigurationChanged(@NonNull Configuration newConfig) {
-        super.onConfigurationChanged(newConfig);
-        mDrawerToggle.onConfigurationChanged(newConfig);
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        // Pass the event to ActionBarDrawerToggle, if it returns
-        // true, then it has handled the app icon touch event
-        if (mDrawerToggle.onOptionsItemSelected(item)) {
-            return true;
-        }else if(item.getItemId() == android.R.id.home){
-            finish();
-        }
-
-        return super.onOptionsItemSelected(item);
-    }
-
-    @Override
-    public void onBackPressed() {
-        if(mDrawerLayout.isDrawerOpen(GravityCompat.START)) {
-            mDrawerLayout.closeDrawer(GravityCompat.START);
-        } else {
-            super.onBackPressed();
-        }
-    }
-
-    protected void setContent(View contentView){
-        baseBinding = DataBindingUtil.setContentView(this, R.layout.activity_base);
-        FrameLayout content = baseBinding.contentFragment;
-        content.removeAllViews();
-        content.addView(contentView);
-
-        initNavigation();
-    }
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/generic/BaseActivity.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/generic/BaseActivity.kt
new file mode 100755
index 0000000..0ee1591
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/generic/BaseActivity.kt
@@ -0,0 +1,158 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2017 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.ui.generic
+
+import android.content.Intent
+import android.content.res.Configuration
+import android.os.Bundle
+import android.view.MenuItem
+import android.view.View
+import android.widget.Toast
+import androidx.appcompat.app.ActionBarDrawerToggle
+import androidx.appcompat.app.AppCompatActivity
+import androidx.appcompat.widget.Toolbar
+import androidx.core.view.GravityCompat
+import androidx.databinding.DataBindingUtil
+import androidx.drawerlayout.widget.DrawerLayout
+import com.google.android.material.navigation.NavigationView
+import com.mdiqentw.lifedots.R
+import com.mdiqentw.lifedots.databinding.ActivityBaseBinding
+import com.mdiqentw.lifedots.ui.history.AnalyticsActivity
+import com.mdiqentw.lifedots.ui.history.HistoryActivity
+import com.mdiqentw.lifedots.ui.history.MapActivity
+import com.mdiqentw.lifedots.ui.main.MainActivity
+import com.mdiqentw.lifedots.ui.settings.SettingsActivity
+import java.util.*
+
+/*
+ * MainActivity to show most of the UI, based on switching the fragements
+ *
+ * */
+open class BaseActivity : AppCompatActivity() {
+    lateinit var baseBinding: ActivityBaseBinding
+
+    protected lateinit var mDrawerLayout: DrawerLayout
+//    @JvmField
+    protected lateinit var mDrawerToggle: ActionBarDrawerToggle
+//    @JvmField
+    protected lateinit var mNavigationView: NavigationView
+    protected lateinit var toolbar: Toolbar
+
+    protected fun setupDrawer() {
+        mDrawerLayout = baseBinding.drawerLayout
+        mDrawerToggle = ActionBarDrawerToggle(
+            this,
+            mDrawerLayout,
+            R.string.drawer_open,
+            R.string.drawer_close
+        )
+        mDrawerLayout.addDrawerListener(mDrawerToggle)
+        Objects.requireNonNull(supportActionBar!!).setDisplayHomeAsUpEnabled(true)
+        supportActionBar!!.setHomeButtonEnabled(true)
+    }
+
+    protected fun setupNavs() {
+        mNavigationView = baseBinding.navigationView
+        mNavigationView.setNavigationItemSelectedListener { menuItem: MenuItem ->
+            val mid = menuItem.itemId
+            if (mid == R.id.nav_main) {
+                if (!menuItem.isChecked) {
+                    // start activity only if it is not currently checked
+                    val intentmain = Intent(this@BaseActivity, MainActivity::class.java)
+                    intentmain.addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP)
+                    startActivity(intentmain)
+                }
+            } else if (mid == R.id.nav_activity_manager) {
+                val intentmanage = Intent(this@BaseActivity, ManageActivity::class.java)
+                startActivity(intentmanage)
+            } else if (mid == R.id.nav_diary) {
+                val intentdiary = Intent(this@BaseActivity, HistoryActivity::class.java)
+                startActivity(intentdiary)
+            } else if (mid == R.id.nav_map) {
+                val intentmap = Intent(this@BaseActivity, MapActivity::class.java)
+                startActivity(intentmap)
+            } else if (mid == R.id.nav_statistics) {
+                val intentstats = Intent(this@BaseActivity, AnalyticsActivity::class.java)
+                startActivity(intentstats)
+            } else if (mid == R.id.nav_about) {
+                val intentabout = Intent(this@BaseActivity, AboutActivity::class.java)
+                startActivity(intentabout)
+            } else if (mid == R.id.nav_privacy) {
+                val intentpriv = Intent(this@BaseActivity, PrivacyPolicyActivity::class.java)
+                startActivity(intentpriv)
+            } else if (mid == R.id.nav_settings) {
+                val intentsettings = Intent(this@BaseActivity, SettingsActivity::class.java)
+                startActivity(intentsettings)
+            } else Toast.makeText(
+                this@BaseActivity,
+                menuItem.title.toString() + " is not yet implemented :-(",
+                Toast.LENGTH_LONG
+            ).show()
+            mDrawerLayout.closeDrawers()
+            true
+        }
+    }
+
+    protected fun initNavigation() {
+        toolbar = baseBinding.mainToolbar
+        setSupportActionBar(toolbar)
+        setupDrawer()
+        setupNavs()
+    }
+
+    override fun onPostCreate(savedInstanceState: Bundle?) {
+        super.onPostCreate(savedInstanceState)
+        // Sync the toggle state after onRestoreInstanceState has occurred.
+        mDrawerToggle.syncState()
+    }
+
+    override fun onConfigurationChanged(newConfig: Configuration) {
+        super.onConfigurationChanged(newConfig)
+        mDrawerToggle.onConfigurationChanged(newConfig)
+    }
+
+    override fun onOptionsItemSelected(item: MenuItem): Boolean {
+        // Pass the event to ActionBarDrawerToggle, if it returns
+        // true, then it has handled the app icon touch event
+        if (mDrawerToggle.onOptionsItemSelected(item)) {
+            return true
+        } else if (item.itemId == android.R.id.home) {
+            finish()
+        }
+        return super.onOptionsItemSelected(item)
+    }
+
+    @Deprecated("Deprecated in Java")
+    override fun onBackPressed() {
+        if (mDrawerLayout.isDrawerOpen(GravityCompat.START)) {
+            mDrawerLayout.closeDrawer(GravityCompat.START)
+        } else {
+            super.onBackPressed()
+        }
+    }
+
+    protected fun setContent(contentView: View?) {
+        baseBinding = DataBindingUtil.setContentView(this, R.layout.activity_base)
+        val content = baseBinding.contentFragment
+        content.removeAllViews()
+        content.addView(contentView)
+        initNavigation()
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/generic/DetailRecyclerViewAdapter.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/generic/DetailRecyclerViewAdapter.kt
old mode 100644
new mode 100755
index 5a3017f..ad85cff
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/generic/DetailRecyclerViewAdapter.kt
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/generic/DetailRecyclerViewAdapter.kt
@@ -2,7 +2,7 @@
  * LifeDots
  *
  * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -40,27 +40,10 @@ import com.mdiqentw.lifedots.helpers.GraphicsHelper
 import com.squareup.picasso.Picasso
 import java.io.File
 
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
+
 class DetailRecyclerViewAdapter(act: BaseActivity, details: Cursor?) :
     RecyclerView.Adapter<DetailViewHolders>(), DetailViewHolders.SelectListener {
-    private class QHandler : AsyncQueryHandler(MVApplication.getAppContext().contentResolver)
+    private class QHandler : AsyncQueryHandler(MVApplication.appContext!!.contentResolver)
 
     private val mQHandler = QHandler()
     private var mCursor: Cursor?
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/generic/DetailViewHolders.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/generic/DetailViewHolders.kt
old mode 100644
new mode 100755
index 68fd11c..45d79fd
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/generic/DetailViewHolders.kt
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/generic/DetailViewHolders.kt
@@ -2,6 +2,7 @@
  * LifeDots
  *
  * Copyright (C) 2017 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -25,24 +26,6 @@ import android.widget.ImageView
 import android.widget.TextView
 import com.mdiqentw.lifedots.databinding.DetailRecyclerItemBinding
 
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
 class DetailViewHolders(listener: SelectListener, bind: DetailRecyclerItemBinding) : RecyclerView.ViewHolder(bind.root), View.OnClickListener, OnLongClickListener {
     interface SelectListener {
         fun onDetailItemClick(adapterPosition: Int)
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/generic/EditActivity.java b/app/src/main/java/com/mdiqentw/lifedots/ui/generic/EditActivity.java
deleted file mode 100644
index db0e0ec..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/generic/EditActivity.java
+++ /dev/null
@@ -1,462 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- * Copyright (C) 2018 Sam Partee
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-package com.mdiqentw.lifedots.ui.generic;
-
-import android.annotation.SuppressLint;
-import android.content.AsyncQueryHandler;
-import android.content.ContentUris;
-import android.content.ContentValues;
-import android.content.Intent;
-import android.database.Cursor;
-import android.os.Build;
-import android.os.Bundle;
-import android.text.Editable;
-import android.text.TextWatcher;
-import android.view.Menu;
-import android.view.MenuInflater;
-import android.view.MenuItem;
-import android.view.View;
-import android.widget.Toast;
-
-import androidx.annotation.Nullable;
-import androidx.appcompat.widget.TooltipCompat;
-import androidx.databinding.DataBindingUtil;
-
-import com.flask.colorpicker.ColorPickerView;
-import com.flask.colorpicker.builder.ColorPickerDialogBuilder;
-import com.mdiqentw.lifedots.MVApplication;
-import com.mdiqentw.lifedots.R;
-import com.mdiqentw.lifedots.databinding.ActivityEditContentBinding;
-import com.mdiqentw.lifedots.db.Contract;
-import com.mdiqentw.lifedots.helpers.ActivityHelper;
-import com.mdiqentw.lifedots.helpers.GraphicsHelper;
-import com.mdiqentw.lifedots.model.DiaryActivity;
-
-import java.lang.ref.WeakReference;
-import java.util.Objects;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-/*
- * EditActivity to add and modify activities
- *
- * */
-public class EditActivity extends BaseActivity implements ActivityHelper.DataChangedListener {
-    @Nullable
-    private DiaryActivity currentActivity; /* null is for creating a new object */
-
-    private static final int QUERY_NAMES = 1;
-    private static final int RENAME_DELETED_ACTIVITY = 2;
-    private static final int TEST_DELETED_NAME = 3;
-//    private static final int SIMILAR_ACTIVITY = 4;
-
-    private static final String COLOR_KEY = "COLOR";
-    private static final String NAME_KEY = "NAME";
-
-    private static final int CHECK_STATE_CHECKING = 0;
-    private static final int CHECK_STATE_OK = 1;
-//    private static final int CHECK_STATE_WARNING = 2;
-    private static final int CHECK_STATE_ERROR = 3;
-    private static final String[] NAME_TEST_PROJ = new String[]{Contract.DiaryActivity.NAME};
-
-    private int checkState = CHECK_STATE_CHECKING;
-
-    ActivityEditContentBinding binding;
-
-    private int mActivityColor;
-
-    private void setCheckState(int checkState) {
-        this.checkState = checkState;
-        if(checkState == CHECK_STATE_CHECKING){
-            binding.editActivityNameTil.setError("...");
-        }
-    }
-
-    public void doTokenQueryName(Cursor cursor, AsyncQueryHandler handler) {
-        binding.btnRename.setVisibility(View.GONE);
-        binding.btnRename.setOnClickListener(null);
-        if(cursor.moveToFirst()) {
-//            binding.btnQuickfix.setVisibility(View.VISIBLE);
-            @SuppressLint("Range") boolean deleted = (cursor.getLong(cursor.getColumnIndex(Contract.DiaryActivity._DELETED)) != 0);
-            @SuppressLint("Range") int actId = cursor.getInt(cursor.getColumnIndex(Contract.DiaryActivity._ID));
-            @SuppressLint("Range") String name = cursor.getString(cursor.getColumnIndex(Contract.DiaryActivity.NAME));
-            setCheckState(CHECK_STATE_ERROR);
-
-            if (deleted) {
-                CharSequence str = getResources().getString(R.string.error_name_already_used_in_deleted, cursor.getString(0));
-                binding.btnRename.setVisibility(View.VISIBLE);
-                setBtnTooltip(binding.btnRename, getResources().getString(R.string.tooltip_quickfix_btn_rename_deleted));
-                binding.btnRename.setContentDescription(getResources().getString(R.string.contentDesc_renameDeletedActivity));
-
-                binding.editActivityNameTil.setError(str);
-                binding.btnRename.setOnClickListener(v -> {
-                    setCheckState(CHECK_STATE_CHECKING);
-
-                    ContentValues values = new ContentValues();
-                    String newName = name + "_deleted";
-                    Toast.makeText(this,
-                            getResources().getString(R.string.renamed_deleted_activity_toast, newName),
-                            Toast.LENGTH_LONG).show();
-
-                    values.put(Contract.DiaryActivity.NAME, newName);
-                    values.put(Contract.DiaryActivity._ID, Long.valueOf(actId));
-                    handler.startQuery(TEST_DELETED_NAME,
-                            values,
-                            Contract.DiaryActivity.CONTENT_URI,
-                            NAME_TEST_PROJ,
-                            Contract.DiaryActivity.NAME + " = ?",
-                            new String[]{newName},
-                            null
-                    );
-                    setCheckState(CHECK_STATE_OK);
-                });
-            } else {
-                binding.editActivityNameTil.setError(getResources().getString(R.string.error_name_already_used, cursor.getString(0)));
-                setCheckState(CHECK_STATE_ERROR);
-            }
-        } else {
-            binding.editActivityNameTil.setError("");
-            setCheckState(CHECK_STATE_OK);
-        }
-    }
-
-    private static class QHandler extends AsyncQueryHandler {
-        final EditActivity act;
-
-        /* Access only allowed via ActivityHelper.helper singleton */
-        private QHandler(EditActivity act){
-            super(MVApplication.getAppContext().getContentResolver());
-            this.act = new WeakReference<>(act).get();
-        }
-
-        @Override
-        protected void onQueryComplete(int token, Object cookie, Cursor cursor) {
-            if ((cursor != null)) {
-                switch (token) {
-                    case QUERY_NAMES:
-                        act.doTokenQueryName(cursor, this);
-                        break;
-                    case TEST_DELETED_NAME:
-                        ContentValues values = (ContentValues) cookie;
-                        if (cursor.moveToFirst()) {
-                            // name already exists, choose another one
-                            String triedName = (String) values.get(Contract.Diary.NAME);
-                            String newName = triedName.replaceFirst("-\\d+$", "");
-                            String idx;
-                            if (triedName.length() == newName.length()) {
-                                // no "-x" at the end so far
-                                idx = "-2";
-                            } else {
-                                String x = triedName.substring(newName.length() + 1);
-                                idx = "-" + (Integer.parseInt(x) + 1);
-                            }
-                            newName += idx;
-                            values.put(Contract.DiaryActivity.NAME, newName);
-                            startQuery(TEST_DELETED_NAME, values,
-                                    Contract.DiaryActivity.CONTENT_URI,
-                                    NAME_TEST_PROJ,
-                                    Contract.DiaryActivity.NAME + " = ?",
-                                    new String[]{newName},
-                                    null
-                            );
-
-                        } else {
-                            // name not found, use it for the deleted one
-                            Long actId = (Long) values.get(Contract.Diary._ID);
-                            values.remove(Contract.Diary._ID);
-                            startUpdate(RENAME_DELETED_ACTIVITY, null,
-                                    ContentUris.withAppendedId(Contract.DiaryActivity.CONTENT_URI, actId),
-                                    values, Contract.Diary._ID + " = " + actId, null);
-                        }
-                        break;
-                }
-                cursor.close();
-            }
-            else {
-                System.out.println("cursor was null");
-            }
-        }
-
-        @Override
-        protected void onUpdateComplete(int token, Object cookie, int result) {
-            super.onUpdateComplete(token, cookie, result);
-            if (token == RENAME_DELETED_ACTIVITY) {
-                act.checkConstraints();
-            } else {
-                act.setCheckState(CHECK_STATE_OK);
-            }
-        }
-    }
-
-    private static void setBtnTooltip(View view, @Nullable CharSequence tooltipText) {
-        if (Build.VERSION.SDK_INT < 26) {
-            TooltipCompat.setTooltipText(view, tooltipText);
-        }else{
-            view.setTooltipText(tooltipText);
-        }
-    }
-
-    /* refresh all view elements depending on currentActivity */
-    private void refreshElements() {
-        if (currentActivity != null) {
-            binding.editActivityName.setText(currentActivity.getName());
-            Objects.requireNonNull(getSupportActionBar()).setTitle(currentActivity.getName());
-            mActivityColor = currentActivity.getColor();
-        } else {
-            mActivityColor = GraphicsHelper.prepareColorForNextActivity();
-        }
-        binding.editActivityColor.setBackgroundColor(mActivityColor);
-    }
-
-    private final QHandler mQHandler = new QHandler(this);
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        binding = DataBindingUtil.setContentView(this, R.layout.activity_edit_content);
-        setContent(binding.getRoot());
-
-        setCheckState(CHECK_STATE_CHECKING);
-
-        Intent i = getIntent();
-        int actId = i.getIntExtra("activityID", -1);
-//        System.out.println("ActId: " + actId);
-        if (actId == -1) {
-            currentActivity = null;
-        } else {
-            currentActivity = ActivityHelper.helper.activityWithId(actId);
-        }
-
-        binding.editActivityName.addTextChangedListener(new TextWatcher(){
-            @Override
-            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
-            }
-
-            @Override
-            public void onTextChanged(CharSequence s, int start, int before, int count) {
-            }
-
-            @Override
-            public void afterTextChanged(Editable s) {
-                checkConstraints();
-//                checkSimilarNames();
-            }
-        });
-
-        binding.editActivityColor.setOnClickListener(v -> ColorPickerDialogBuilder
-                .with(EditActivity.this)
-                .setTitle("Choose color")
-                .initialColor(R.color.activityTextColorLight)
-                .wheelType(ColorPickerView.WHEEL_TYPE.FLOWER)
-                .density(12)
-                .setOnColorSelectedListener(selectedColor -> {
-//                                toast("onColorSelected: 0x" + Integer.toHexString(selectedColor));
-                })
-                .setPositiveButton("ok", (dialog, selectedColor, allColors) -> {
-                    mActivityColor = selectedColor;
-                    binding.editActivityColor.setBackgroundColor(mActivityColor);
-//                                changeBackgroundColor(selectedColor);
-                })
-                .setNegativeButton("cancel", (dialog, which) -> {
-                })
-                .build()
-                .show());
-
-        if(savedInstanceState != null) {
-            String name = savedInstanceState.getString(NAME_KEY);
-            mActivityColor = savedInstanceState.getInt(COLOR_KEY);
-            binding.editActivityName.setText(name);
-            Objects.requireNonNull(getSupportActionBar()).setTitle(name);
-            checkConstraints();
-        }else{
-            refreshElements();
-        }
-        mDrawerToggle.setDrawerIndicatorEnabled(false);
-        Objects.requireNonNull(getSupportActionBar()).setHomeAsUpIndicator(R.drawable.ic_close_cancel);
-        checkConstraints();
-    }
-
-    @Override
-    public void onResume(){
-        if(currentActivity == null) {
-//            mNavigationView.getMenu().findItem(R.id.nav_add_activity).setChecked(true);
-        }
-        ActivityHelper.helper.registerDataChangeListener(this);
-
-        super.onResume();
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        ActivityHelper.helper.unregisterDataChangeListener(this);
-    }
-
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        outState.putString(NAME_KEY, Objects.requireNonNull(binding.editActivityName.getText()).toString());
-        outState.putInt(COLOR_KEY, mActivityColor);
-        // call superclass to save any view hierarchy
-        super.onSaveInstanceState(outState);
-    }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        MenuInflater inflater = getMenuInflater();
-        inflater.inflate(R.menu.edit_menu, menu);
-        return true;
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        int mid = item.getItemId();
-        if (mid == R.id.action_edit_delete) {
-            if(currentActivity != null){
-                ActivityHelper.helper.deleteActivity(currentActivity);
-            }
-            finish();
-        } else if (mid == R.id.action_edit_done) {
-            if(checkState != CHECK_STATE_CHECKING) {
-                if (checkState == CHECK_STATE_ERROR) {
-                    Toast.makeText(EditActivity.this,
-                            binding.editActivityNameTil.getError(),
-                            Toast.LENGTH_LONG
-                    ).show();
-                } else {
-                    if (currentActivity == null) {
-                        ActivityHelper.helper.insertActivity(new DiaryActivity(-1, Objects.requireNonNull(binding.editActivityName.getText()).toString(), mActivityColor));
-                    } else {
-                        currentActivity.setName(Objects.requireNonNull(binding.editActivityName.getText()).toString());
-                        currentActivity.setColor(mActivityColor);
-                        ActivityHelper.helper.updateActivity(currentActivity);
-                    }
-                    finish();
-                }
-            }
-        } else if (mid == android.R.id.home) {
-            finish();
-        }
-        return super.onOptionsItemSelected(item);
-    }
-
-    public void checkConstraints() {
-        setCheckState(CHECK_STATE_CHECKING);
-
-        if (currentActivity == null) {
-            mQHandler.startQuery(QUERY_NAMES,
-                    null,
-                    Contract.DiaryActivity.CONTENT_URI,
-                    new String[]{Contract.DiaryActivity.NAME, Contract.DiaryActivity._DELETED, Contract.DiaryActivity._ID},
-                    Contract.DiaryActivity.NAME + "=?",
-                    new String[]{Objects.requireNonNull(binding.editActivityName.getText()).toString()}, null);
-        } else {
-            mQHandler.startQuery(QUERY_NAMES,
-                    null,
-                    Contract.DiaryActivity.CONTENT_URI,
-                    new String[]{Contract.DiaryActivity.NAME, Contract.DiaryActivity._DELETED, Contract.DiaryActivity._ID},
-                    Contract.DiaryActivity.NAME + "=? AND " +
-                            Contract.DiaryActivity._ID + " != ?",
-                    new String[]{Objects.requireNonNull(binding.editActivityName.getText()).toString(), Long.toString(currentActivity.getId())},
-                    null);
-        }
-    }
-
-    /**
-     * Called when the data has changed and no further specification is possible.
-     * => everything needs to be refreshed!
-     */
-    @Override
-    public void onActivityDataChanged() {
-        refreshElements();
-    }
-
-    /**
-     * Called when the data of one activity was changed.
-     *
-     * @param activity
-     */
-    @Override
-    public void onActivityDataChanged(DiaryActivity activity) {
-        if(activity == currentActivity){
-            refreshElements();
-        }
-    }
-
-    /**
-     * Called on addition of an activity.
-     *
-     * @param activity
-     */
-    @Override
-    public void onActivityAdded(DiaryActivity activity) {
-        if(activity == currentActivity){
-            refreshElements();
-        }
-    }
-
-    /**
-     * Called on removale of an activity.
-     *
-     * @param activity
-     */
-    @Override
-    public void onActivityRemoved(DiaryActivity activity) {
-        if(activity == currentActivity){
-            refreshElements();
-            // TODO: handle deletion of the activity while in editing it...
-        }
-    }
-
-    /**
-     * Called on change of the current activity.
-     */
-    @Override
-    public void onActivityChanged() {
-
-    }
-
-    /**
-     * Called on change of the activity order due to likelyhood.
-     */
-    @Override
-    public void onActivityOrderChanged() {
-
-    }
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/generic/EditActivity.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/generic/EditActivity.kt
new file mode 100755
index 0000000..0ed4eb1
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/generic/EditActivity.kt
@@ -0,0 +1,414 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2018 Sam Partee
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.ui.generic
+
+import android.annotation.SuppressLint
+import android.content.AsyncQueryHandler
+import android.content.ContentUris
+import android.content.ContentValues
+import android.content.DialogInterface
+import android.database.Cursor
+import android.os.Build
+import android.os.Bundle
+import android.text.Editable
+import android.text.TextWatcher
+import android.view.Menu
+import android.view.MenuItem
+import android.view.View
+import android.widget.Toast
+import androidx.appcompat.widget.TooltipCompat
+import androidx.databinding.DataBindingUtil
+import com.flask.colorpicker.ColorPickerView
+import com.flask.colorpicker.builder.ColorPickerDialogBuilder
+import com.mdiqentw.lifedots.MVApplication
+import com.mdiqentw.lifedots.R
+import com.mdiqentw.lifedots.databinding.ActivityEditContentBinding
+import com.mdiqentw.lifedots.db.Contract
+import com.mdiqentw.lifedots.helpers.ActivityHelper
+import com.mdiqentw.lifedots.helpers.ActivityHelper.DataChangedListener
+import com.mdiqentw.lifedots.helpers.GraphicsHelper.prepareColorForNextActivity
+import com.mdiqentw.lifedots.model.DiaryActivity
+import java.lang.ref.WeakReference
+import java.util.*
+
+/*
+ * EditActivity to add and modify activities
+ *
+ * */
+class EditActivity : BaseActivity(), DataChangedListener {
+    private var currentActivity /* null is for creating a new object */: DiaryActivity? = null
+    private var checkState = CHECK_STATE_CHECKING
+    lateinit var binding: ActivityEditContentBinding
+    private var mActivityColor = 0
+    private fun setCheckState(checkState: Int) {
+        this.checkState = checkState
+        if (checkState == CHECK_STATE_CHECKING) {
+            binding.editActivityNameTil.error = "..."
+        }
+    }
+
+    fun doTokenQueryName(cursor: Cursor, handler: AsyncQueryHandler) {
+        binding.btnRename.visibility = View.GONE
+        binding.btnRename.setOnClickListener(null)
+        if (cursor.moveToFirst()) {
+//            binding.btnQuickfix.setVisibility(View.VISIBLE);
+            @SuppressLint("Range") val deleted =
+                cursor.getLong(cursor.getColumnIndex(Contract.DiaryActivity._DELETED)) != 0L
+            @SuppressLint("Range") val actId = cursor.getInt(cursor.getColumnIndex(Contract.DiaryActivity._ID))
+            @SuppressLint("Range") val name = cursor.getString(cursor.getColumnIndex(Contract.DiaryActivity.NAME))
+            setCheckState(CHECK_STATE_ERROR)
+            if (deleted) {
+                val str: CharSequence =
+                    resources.getString(R.string.error_name_already_used_in_deleted, cursor.getString(0))
+                binding.btnRename.visibility = View.VISIBLE
+                setBtnTooltip(binding.btnRename, resources.getString(R.string.tooltip_quickfix_btn_rename_deleted))
+                binding.btnRename.contentDescription = resources.getString(R.string.contentDesc_renameDeletedActivity)
+                binding.editActivityNameTil.error = str
+                binding.btnRename.setOnClickListener { _: View? ->
+                    setCheckState(CHECK_STATE_CHECKING)
+                    val values = ContentValues()
+                    val newName = name + "_deleted"
+                    Toast.makeText(
+                        this,
+                        resources.getString(R.string.renamed_deleted_activity_toast, newName),
+                        Toast.LENGTH_LONG
+                    ).show()
+                    values.put(Contract.DiaryActivity.NAME, newName)
+                    values.put(Contract.DiaryActivity._ID, java.lang.Long.valueOf(actId.toLong()))
+                    handler.startQuery(
+                        TEST_DELETED_NAME,
+                        values,
+                        Contract.DiaryActivity.CONTENT_URI,
+                        NAME_TEST_PROJ,
+                        Contract.DiaryActivity.NAME + " = ?", arrayOf(newName),
+                        null
+                    )
+                    setCheckState(CHECK_STATE_OK)
+                }
+            } else {
+                binding.editActivityNameTil.error =
+                    resources.getString(R.string.error_name_already_used, cursor.getString(0))
+                setCheckState(CHECK_STATE_ERROR)
+            }
+        } else {
+            binding.editActivityNameTil.error = ""
+            setCheckState(CHECK_STATE_OK)
+        }
+    }
+
+    private class QHandler(act: EditActivity) :
+        AsyncQueryHandler(MVApplication.appContext!!.contentResolver) {
+        val act: EditActivity?
+
+        /* Access only allowed via ActivityHelper.helper singleton */
+        init {
+            this.act = WeakReference(act).get()
+        }
+
+        override fun onQueryComplete(token: Int, cookie: Any?, cursor: Cursor) {
+            when (token) {
+                QUERY_NAMES -> act!!.doTokenQueryName(cursor, this)
+                TEST_DELETED_NAME -> {
+                    if (cookie != null) {
+                        val values = cookie as ContentValues
+                        if (cursor.moveToFirst()) {
+                            // name already exists, choose another one
+                            val triedName = values[Contract.Diary.NAME] as String
+                            var newName = triedName.replaceFirst("-\\d+$".toRegex(), "")
+                            val idx: String = if (triedName.length == newName.length) {
+                                // no "-x" at the end so far
+                                "-2"
+                            } else {
+                                val x = triedName.substring(newName.length + 1)
+                                "-" + (x.toInt() + 1)
+                            }
+                            newName += idx
+                            values.put(Contract.DiaryActivity.NAME, newName)
+                            startQuery(
+                                TEST_DELETED_NAME, values,
+                                Contract.DiaryActivity.CONTENT_URI,
+                                NAME_TEST_PROJ,
+                                Contract.DiaryActivity.NAME + " = ?", arrayOf(newName),
+                                null
+                            )
+                        } else {
+                            // name not found, use it for the deleted one
+                            val actId = values[Contract.Diary._ID] as Long
+                            values.remove(Contract.Diary._ID)
+                            startUpdate(
+                                RENAME_DELETED_ACTIVITY, null,
+                                ContentUris.withAppendedId(Contract.DiaryActivity.CONTENT_URI, actId),
+                                values, Contract.Diary._ID + " = " + actId, null
+                            )
+                        }
+                    }
+                }
+            }
+            cursor.close()
+        }
+
+        override fun onUpdateComplete(token: Int, cookie: Any?, result: Int) {
+            super.onUpdateComplete(token, cookie, result)
+            if (token == RENAME_DELETED_ACTIVITY) {
+                act!!.checkConstraints()
+            } else {
+                act!!.setCheckState(CHECK_STATE_OK)
+            }
+        }
+    }
+
+    /* refresh all view elements depending on currentActivity */
+    private fun refreshElements() {
+        if (currentActivity != null) {
+            binding.editActivityName.setText(currentActivity!!.mName)
+            supportActionBar!!.title = currentActivity!!.mName
+            mActivityColor = currentActivity!!.mColor
+        } else {
+            mActivityColor = prepareColorForNextActivity()
+        }
+        binding.editActivityColor.setBackgroundColor(mActivityColor)
+    }
+
+    private val mQHandler = QHandler(this)
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        binding = DataBindingUtil.setContentView(this, R.layout.activity_edit_content)
+        setContent(binding.root)
+        setCheckState(CHECK_STATE_CHECKING)
+        val i = intent
+        val actId = i.getIntExtra("activityID", -1)
+        //        System.out.println("ActId: " + actId);
+        currentActivity = if (actId == -1) {
+            null
+        } else {
+            ActivityHelper.helper.activityWithId(actId)
+        }
+        binding.editActivityName.addTextChangedListener(object : TextWatcher {
+            override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {}
+            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {}
+            override fun afterTextChanged(s: Editable) {
+                checkConstraints()
+                //                checkSimilarNames();
+            }
+        })
+        binding.editActivityColor.setOnClickListener { _: View? ->
+            ColorPickerDialogBuilder
+                .with(this@EditActivity)
+                .setTitle("Choose color")
+                .initialColor(R.color.activityTextColorLight)
+                .wheelType(ColorPickerView.WHEEL_TYPE.FLOWER)
+                .density(12)
+                .setOnColorSelectedListener { _: Int -> }
+                .setPositiveButton("ok") { _: DialogInterface?, selectedColor: Int, _: Array<Int?>? ->
+                    mActivityColor = selectedColor
+                    binding.editActivityColor.setBackgroundColor(mActivityColor)
+                }
+                .setNegativeButton("cancel") { _: DialogInterface?, _: Int -> }
+                .build()
+                .show()
+        }
+        if (savedInstanceState != null) {
+            val name = savedInstanceState.getString(NAME_KEY)
+            mActivityColor = savedInstanceState.getInt(COLOR_KEY)
+            binding.editActivityName.setText(name)
+            supportActionBar!!.title = name
+            checkConstraints()
+        } else {
+            refreshElements()
+        }
+        mDrawerToggle.isDrawerIndicatorEnabled = false
+        supportActionBar!!.setHomeAsUpIndicator(R.drawable.ic_close_cancel)
+        checkConstraints()
+    }
+
+    public override fun onResume() {
+        if (currentActivity == null) {
+//            mNavigationView.getMenu().findItem(R.id.nav_add_activity).setChecked(true);
+        }
+        ActivityHelper.helper.registerDataChangeListener(this)
+        super.onResume()
+    }
+
+    public override fun onPause() {
+        super.onPause()
+        ActivityHelper.helper.unregisterDataChangeListener(this)
+    }
+
+    public override fun onSaveInstanceState(outState: Bundle) {
+        outState.putString(NAME_KEY, Objects.requireNonNull(binding.editActivityName.text).toString())
+        outState.putInt(COLOR_KEY, mActivityColor)
+        // call superclass to save any view hierarchy
+        super.onSaveInstanceState(outState)
+    }
+
+    override fun onCreateOptionsMenu(menu: Menu): Boolean {
+        val inflater = menuInflater
+        inflater.inflate(R.menu.edit_menu, menu)
+        return true
+    }
+
+    override fun onOptionsItemSelected(item: MenuItem): Boolean {
+        val mid = item.itemId
+        if (mid == R.id.action_edit_delete) {
+            if (currentActivity != null) {
+                ActivityHelper.helper.deleteActivity(currentActivity!!)
+            }
+            finish()
+        } else if (mid == R.id.action_edit_done) {
+            if (checkState != CHECK_STATE_CHECKING) {
+                if (checkState == CHECK_STATE_ERROR) {
+                    Toast.makeText(
+                        this@EditActivity,
+                        binding.editActivityNameTil.error,
+                        Toast.LENGTH_LONG
+                    ).show()
+                } else {
+                    if (currentActivity == null) {
+                        ActivityHelper.helper.insertActivity(
+                            DiaryActivity(
+                                -1, Objects.requireNonNull(
+                                    binding.editActivityName.text
+                                ).toString(), mActivityColor
+                            )
+                        )
+                    } else {
+                        currentActivity!!.mName = Objects.requireNonNull(binding.editActivityName.text).toString()
+                        currentActivity!!.mColor = mActivityColor
+                        ActivityHelper.helper.updateActivity(currentActivity!!)
+                    }
+                    finish()
+                }
+            }
+        } else if (mid == android.R.id.home) {
+            finish()
+        }
+        return super.onOptionsItemSelected(item)
+    }
+
+    fun checkConstraints() {
+        setCheckState(CHECK_STATE_CHECKING)
+        if (currentActivity == null) {
+            mQHandler.startQuery(
+                QUERY_NAMES,
+                null,
+                Contract.DiaryActivity.CONTENT_URI,
+                arrayOf(Contract.DiaryActivity.NAME, Contract.DiaryActivity._DELETED, Contract.DiaryActivity._ID),
+                Contract.DiaryActivity.NAME + "=?",
+                arrayOf(
+                    Objects.requireNonNull(
+                        binding.editActivityName.text
+                    ).toString()
+                ),
+                null
+            )
+        } else {
+            mQHandler.startQuery(
+                QUERY_NAMES,
+                null,
+                Contract.DiaryActivity.CONTENT_URI,
+                arrayOf(Contract.DiaryActivity.NAME, Contract.DiaryActivity._DELETED, Contract.DiaryActivity._ID),
+                Contract.DiaryActivity.NAME + "=? AND " +
+                        Contract.DiaryActivity._ID + " != ?",
+                arrayOf(
+                    Objects.requireNonNull(
+                        binding.editActivityName.text
+                    ).toString(), currentActivity!!.mId.toLong().toString()
+                ),
+                null
+            )
+        }
+    }
+
+    /**
+     * Called when the data has changed and no further specification is possible.
+     * => everything needs to be refreshed!
+     */
+    override fun onActivityDataChanged() {
+        refreshElements()
+    }
+
+    /**
+     * Called when the data of one activity was changed.
+     *
+     * @param activity
+     */
+    override fun onActivityDataChanged(activity: DiaryActivity) {
+        if (activity === currentActivity) {
+            refreshElements()
+        }
+    }
+
+    /**
+     * Called on addition of an activity.
+     *
+     * @param activity
+     */
+    override fun onActivityAdded(activity: DiaryActivity) {
+        if (activity === currentActivity) {
+            refreshElements()
+        }
+    }
+
+    /**
+     * Called on removale of an activity.
+     *
+     * @param activity
+     */
+    override fun onActivityRemoved(activity: DiaryActivity) {
+        if (activity === currentActivity) {
+            refreshElements()
+            // TODO: handle deletion of the activity while in editing it...
+        }
+    }
+
+    /**
+     * Called on change of the current activity.
+     */
+    override fun onActivityChanged() {}
+
+    /**
+     * Called on change of the activity order due to likelyhood.
+     */
+    override fun onActivityOrderChanged() {}
+
+    companion object {
+        private const val QUERY_NAMES = 1
+        private const val RENAME_DELETED_ACTIVITY = 2
+        private const val TEST_DELETED_NAME = 3
+
+        //    private static final int SIMILAR_ACTIVITY = 4;
+        private const val COLOR_KEY = "COLOR"
+        private const val NAME_KEY = "NAME"
+        private const val CHECK_STATE_CHECKING = 0
+        private const val CHECK_STATE_OK = 1
+
+        //    private static final int CHECK_STATE_WARNING = 2;
+        private const val CHECK_STATE_ERROR = 3
+        private val NAME_TEST_PROJ = arrayOf(Contract.DiaryActivity.NAME)
+        private fun setBtnTooltip(view: View, tooltipText: CharSequence?) {
+            if (Build.VERSION.SDK_INT < 26) {
+                TooltipCompat.setTooltipText(view, tooltipText)
+            } else {
+                view.tooltipText = tooltipText
+            }
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/generic/ManageActivity.java b/app/src/main/java/com/mdiqentw/lifedots/ui/generic/ManageActivity.java
deleted file mode 100644
index b0b103e..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/generic/ManageActivity.java
+++ /dev/null
@@ -1,251 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2017 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots.ui.generic;
-
-import android.annotation.SuppressLint;
-import android.content.AsyncQueryHandler;
-import android.content.ContentUris;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.Intent;
-import android.database.Cursor;
-import android.graphics.Paint;
-import android.os.Bundle;
-import android.view.Menu;
-import android.view.MenuInflater;
-import android.view.MenuItem;
-import android.view.View;
-import android.widget.AdapterView;
-import android.widget.GridView;
-import android.widget.RelativeLayout;
-import android.widget.ResourceCursorAdapter;
-import android.widget.TextView;
-
-import androidx.annotation.NonNull;
-import androidx.appcompat.app.AlertDialog;
-import androidx.databinding.DataBindingUtil;
-import androidx.loader.app.LoaderManager;
-import androidx.loader.content.CursorLoader;
-import androidx.loader.content.Loader;
-
-import com.mdiqentw.lifedots.MVApplication;
-import com.mdiqentw.lifedots.R;
-import com.mdiqentw.lifedots.databinding.ActivityManageContentBinding;
-import com.mdiqentw.lifedots.db.Contract;
-import com.mdiqentw.lifedots.helpers.GraphicsHelper;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-/*
- * MainActivity to show most of the UI, based on switching the fragements
- *
- * */
-public class ManageActivity extends BaseActivity
-        implements LoaderManager.LoaderCallbacks<Cursor> {
-
-    private static final String[] PROJECTION = new String[] {
-            Contract.DiaryActivity._ID,
-            Contract.DiaryActivity.NAME,
-            Contract.DiaryActivity.COLOR,
-            Contract.DiaryActivity._DELETED
-    };
-    private static final String SELECTION = Contract.DiaryActivity._DELETED + "=0";
-
-    /* are deleted items currently visible? */
-    private boolean showDeleted = false;
-
-    private static class QHandler extends AsyncQueryHandler {
-        /* Access only allowed via ActivityHelper.helper singleton */
-        private QHandler(){
-            super(MVApplication.getAppContext().getContentResolver());
-        }
-    }
-
-    private final QHandler mQHandler = new QHandler();
-
-    private static class DiaryActivityAdapter extends ResourceCursorAdapter {
-
-        public DiaryActivityAdapter(ManageActivity act) {
-            super(act, R.layout.lifedot_row, null, 0);
-        }
-
-        @SuppressLint("Range")
-        @Override
-        public void bindView(View view, Context context, Cursor cursor){
-            String name = cursor.getString(cursor.getColumnIndex(Contract.DiaryActivity.NAME));
-            int color = cursor.getInt(cursor.getColumnIndex(Contract.DiaryActivity.COLOR));
-
-//            ActivityRowBinding bindRow = DataBindingUtil.setContentView(ManageActivity.this, R.layout.activity_row);
-
-            TextView actName = view.findViewById(R.id.name);
-            actName.setText(name);
-            if(cursor.getInt(cursor.getColumnIndex(Contract.DiaryActivity._DELETED)) == 0) {
-                actName.setPaintFlags(actName.getPaintFlags() & ~Paint.STRIKE_THRU_TEXT_FLAG);
-            } else {
-                actName.setPaintFlags(actName.getPaintFlags()| Paint.STRIKE_THRU_TEXT_FLAG);
-            }
-            RelativeLayout bgrd = view.findViewById(R.id.background);
-            bgrd.setBackgroundColor(color);
-
-            actName.setTextColor(GraphicsHelper.textColorOnBackground(color));
-        }
-    }
-
-    private DiaryActivityAdapter mActivitiyListAdapter;
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        /* TODO: save and restore state */
-
-        ActivityManageContentBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_manage_content);
-        setContent(binding.getRoot());
-        GridView mList = binding.manageActivityList;
-
-        mActivitiyListAdapter = new DiaryActivityAdapter(this);
-        mList.setAdapter(mActivitiyListAdapter);
-
-        mList.setOnItemClickListener(mOnClickListener);
-
-        // Prepare the loader.  Either re-connect with an existing one,
-        // or start a new one.
-    /* TODO: refactor to use the ActivityHelper instead of directly a Loader; 2017-12-02, RMk: not sure whether we should do this... */
-    /* TODO: add a clear way to ensure loader ID uniqueness */
-        LoaderManager.getInstance(this).initLoader(-2, null, this);
-        mDrawerToggle.setDrawerIndicatorEnabled(false);
-    }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        MenuInflater inflater = getMenuInflater();
-        inflater.inflate(R.menu.manage_menu, menu);
-        return true;
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        // Handle your other action bar items...
-        int mid = item.getItemId();
-        if (mid == R.id.action_add_activity) {
-            Intent intentaddact = new Intent(ManageActivity.this, EditActivity.class);
-            startActivity(intentaddact);
-        } else if (mid == R.id.action_show_hide_deleted) {
-            showDeleted = !showDeleted;
-            LoaderManager.getInstance(this).restartLoader(-2, null, this);
-            if(showDeleted) {
-                item.setIcon(R.drawable.ic_hide_deleted);
-                item.setTitle(R.string.nav_hide_deleted);
-            } else {
-                item.setIcon(R.drawable.ic_show_deleted);
-                item.setTitle(R.string.nav_show_deleted);
-            }
-        } else if (mid == android.R.id.home)
-            finish();
-
-        return super.onOptionsItemSelected(item);
-    }
-
-    // Called when a new Loader needs to be created
-    @NonNull
-    public Loader<Cursor> onCreateLoader(int id, Bundle args) {
-        // Now create and return a CursorLoader that will take care of
-        // creating a Cursor for the data being displayed.
-        return new CursorLoader(this, Contract.DiaryActivity.CONTENT_URI,
-                PROJECTION,
-                showDeleted ? "" : SELECTION,
-                null, null);
-    }
-
-    // Called when a previously created loader has finished loading
-    public void onLoadFinished(@NonNull Loader<Cursor> loader, Cursor data) {
-        // Swap the new cursor in.  (The framework will take care of closing the
-        // old cursor once we return.)
-        mActivitiyListAdapter.swapCursor(data);
-    }
-
-    // Called when a previously created loader is reset, making the data unavailable
-    public void onLoaderReset(@NonNull Loader<Cursor> loader) {
-        // This is called when the last Cursor provided to onLoadFinished()
-        // above is about to be closed.  We need to make sure we are no
-        // longer using it.
-        mActivitiyListAdapter.swapCursor(null);
-    }
-
-    @SuppressLint("Range")
-    private final AdapterView.OnItemClickListener mOnClickListener = (parent, v, position, id) -> {
-        Cursor c = (Cursor)parent.getItemAtPosition(position);
-        if(c.getInt(c.getColumnIndex(Contract.DiaryActivity._DELETED)) == 0) {
-            Intent i = new Intent(ManageActivity.this, EditActivity.class);
-            i.putExtra("activityID", c.getInt(c.getColumnIndex(Contract.DiaryActivity._ID)));
-            startActivity(i);
-        } else {
-            // selected item is deleted. Ask for undeleting it.
-            AlertDialog.Builder builder = new AlertDialog.Builder(ManageActivity.this)
-                    .setTitle(R.string.dlg_undelete_activity_title)
-                    .setMessage(getResources().getString(R.string.dlg_undelete_activity_text,
-                            c.getString(c.getColumnIndex(Contract.DiaryActivity.NAME))))
-                    .setPositiveButton(android.R.string.yes, (dialog, whichButton) -> {
-                        ContentValues values = new ContentValues();
-                        values.put(Contract.DiaryActivity._DELETED, 0);
-
-                        mQHandler.startUpdate(0,
-                                null,
-                                ContentUris.withAppendedId(Contract.DiaryActivity.CONTENT_URI,
-                                        c.getLong(c.getColumnIndex(Contract.DiaryActivity._ID))),
-                                values,
-                                Contract.DiaryActivity._ID + "=?",
-                                new String[]{c.getString(c.getColumnIndex(Contract.DiaryActivity._ID))}
-                        );
-
-                    })
-                    .setNegativeButton(android.R.string.no, null);
-
-            builder.create().show();
-
-        }
-    };
-
-    /* TODO #24: implement swipe for parent / child navigation */
-    /* TODO #24: add number of child activities in view */
-
-    @Override
-    public void onResume(){
-        mNavigationView.getMenu().findItem(R.id.nav_activity_manager).setChecked(true);
-        super.onResume();
-    }
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/generic/ManageActivity.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/generic/ManageActivity.kt
new file mode 100755
index 0000000..0eec3f5
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/generic/ManageActivity.kt
@@ -0,0 +1,202 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2017 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.ui.generic
+
+import android.annotation.SuppressLint
+import android.content.*
+import android.database.Cursor
+import android.graphics.Paint
+import android.os.Bundle
+import android.view.Menu
+import android.view.MenuItem
+import android.view.View
+import android.widget.*
+import android.widget.AdapterView.OnItemClickListener
+import androidx.appcompat.app.AlertDialog
+import androidx.databinding.DataBindingUtil
+import androidx.loader.app.LoaderManager
+import androidx.loader.content.CursorLoader
+import androidx.loader.content.Loader
+import com.mdiqentw.lifedots.MVApplication
+import com.mdiqentw.lifedots.R
+import com.mdiqentw.lifedots.databinding.ActivityManageContentBinding
+import com.mdiqentw.lifedots.db.Contract
+import com.mdiqentw.lifedots.helpers.GraphicsHelper.textColorOnBackground
+
+/*
+ * MainActivity to show most of the UI, based on switching the fragements
+ *
+ * */
+class ManageActivity : BaseActivity(), LoaderManager.LoaderCallbacks<Cursor> {
+    /* are deleted items currently visible? */
+    private var showDeleted = false
+
+    /* Access only allowed via ActivityHelper.helper singleton */
+    private class QHandler : AsyncQueryHandler(MVApplication.appContext!!.contentResolver)
+
+    private val mQHandler = QHandler()
+
+    private class DiaryActivityAdapter(act: ManageActivity?) :
+        ResourceCursorAdapter(act, R.layout.lifedot_row, null, 0) {
+        @SuppressLint("Range")
+        override fun bindView(view: View, context: Context, cursor: Cursor) {
+            val name = cursor.getString(cursor.getColumnIndex(Contract.DiaryActivity.NAME))
+            val color = cursor.getInt(cursor.getColumnIndex(Contract.DiaryActivity.COLOR))
+
+//            ActivityRowBinding bindRow = DataBindingUtil.setContentView(ManageActivity.this, R.layout.activity_row);
+            val actName = view.findViewById<TextView>(R.id.name)
+            actName.text = name
+            if (cursor.getInt(cursor.getColumnIndex(Contract.DiaryActivity._DELETED)) == 0) {
+                actName.paintFlags = actName.paintFlags and Paint.STRIKE_THRU_TEXT_FLAG.inv()
+            } else {
+                actName.paintFlags = actName.paintFlags or Paint.STRIKE_THRU_TEXT_FLAG
+            }
+            val bgrd = view.findViewById<RelativeLayout>(R.id.background)
+            bgrd.setBackgroundColor(color)
+            actName.setTextColor(textColorOnBackground(color))
+        }
+    }
+
+    private var mActivitiyListAdapter: DiaryActivityAdapter? = null
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        /* TODO: save and restore state */
+        val binding =
+            DataBindingUtil.setContentView<ActivityManageContentBinding>(this, R.layout.activity_manage_content)
+        setContent(binding.root)
+        val mList = binding.manageActivityList
+        mActivitiyListAdapter = DiaryActivityAdapter(this)
+        mList.adapter = mActivitiyListAdapter
+        mList.onItemClickListener = mOnClickListener
+
+        // Prepare the loader.  Either re-connect with an existing one,
+        // or start a new one.
+        /* TODO: refactor to use the ActivityHelper instead of directly a Loader; 2017-12-02, RMk: not sure whether we should do this... */
+        /* TODO: add a clear way to ensure loader ID uniqueness */LoaderManager.getInstance(this)
+            .initLoader(-2, null, this)
+        mDrawerToggle.isDrawerIndicatorEnabled = false
+    }
+
+    override fun onCreateOptionsMenu(menu: Menu): Boolean {
+        val inflater = menuInflater
+        inflater.inflate(R.menu.manage_menu, menu)
+        return true
+    }
+
+    override fun onOptionsItemSelected(item: MenuItem): Boolean {
+        // Handle your other action bar items...
+        val mid = item.itemId
+        if (mid == R.id.action_add_activity) {
+            val intentaddact = Intent(this@ManageActivity, EditActivity::class.java)
+            startActivity(intentaddact)
+        } else if (mid == R.id.action_show_hide_deleted) {
+            showDeleted = !showDeleted
+            LoaderManager.getInstance(this).restartLoader(-2, null, this)
+            if (showDeleted) {
+                item.setIcon(R.drawable.ic_hide_deleted)
+                item.setTitle(R.string.nav_hide_deleted)
+            } else {
+                item.setIcon(R.drawable.ic_show_deleted)
+                item.setTitle(R.string.nav_show_deleted)
+            }
+        } else if (mid == android.R.id.home) finish()
+        return super.onOptionsItemSelected(item)
+    }
+
+    // Called when a new Loader needs to be created
+    override fun onCreateLoader(id: Int, args: Bundle?): Loader<Cursor> {
+        // Now create and return a CursorLoader that will take care of
+        // creating a Cursor for the data being displayed.
+        return CursorLoader(
+            this, Contract.DiaryActivity.CONTENT_URI,
+            PROJECTION,
+            if (showDeleted) "" else SELECTION,
+            null, null
+        )
+    }
+
+    // Called when a previously created loader has finished loading
+    override fun onLoadFinished(loader: Loader<Cursor>, data: Cursor) {
+        // Swap the new cursor in.  (The framework will take care of closing the
+        // old cursor once we return.)
+        mActivitiyListAdapter!!.swapCursor(data)
+    }
+
+    // Called when a previously created loader is reset, making the data unavailable
+    override fun onLoaderReset(loader: Loader<Cursor>) {
+        // This is called when the last Cursor provided to onLoadFinished()
+        // above is about to be closed.  We need to make sure we are no
+        // longer using it.
+        mActivitiyListAdapter!!.swapCursor(null)
+    }
+
+    @SuppressLint("Range")
+    private val mOnClickListener = OnItemClickListener { parent: AdapterView<*>, _: View?, position: Int, _: Long ->
+        val c = parent.getItemAtPosition(position) as Cursor
+        if (c.getInt(c.getColumnIndex(Contract.DiaryActivity._DELETED)) == 0) {
+            val i = Intent(this@ManageActivity, EditActivity::class.java)
+            i.putExtra("activityID", c.getInt(c.getColumnIndex(Contract.DiaryActivity._ID)))
+            startActivity(i)
+        } else {
+            // selected item is deleted. Ask for undeleting it.
+            val builder = AlertDialog.Builder(this@ManageActivity)
+                .setTitle(R.string.dlg_undelete_activity_title)
+                .setMessage(
+                    resources.getString(
+                        R.string.dlg_undelete_activity_text,
+                        c.getString(c.getColumnIndex(Contract.DiaryActivity.NAME))
+                    )
+                )
+                .setPositiveButton(android.R.string.yes) { _: DialogInterface?, _: Int ->
+                    val values = ContentValues()
+                    values.put(Contract.DiaryActivity._DELETED, 0)
+                    mQHandler.startUpdate(
+                        0,
+                        null,
+                        ContentUris.withAppendedId(
+                            Contract.DiaryActivity.CONTENT_URI,
+                            c.getLong(c.getColumnIndex(Contract.DiaryActivity._ID))
+                        ),
+                        values,
+                        Contract.DiaryActivity._ID + "=?",
+                        arrayOf(c.getString(c.getColumnIndex(Contract.DiaryActivity._ID)))
+                    )
+                }
+                .setNegativeButton(android.R.string.no, null)
+            builder.create().show()
+        }
+    }
+
+    /* TODO #24: implement swipe for parent / child navigation */ /* TODO #24: add number of child activities in view */
+    public override fun onResume() {
+        mNavigationView.menu.findItem(R.id.nav_activity_manager).isChecked = true
+        super.onResume()
+    }
+
+    companion object {
+        private val PROJECTION = arrayOf(
+            Contract.DiaryActivity._ID,
+            Contract.DiaryActivity.NAME,
+            Contract.DiaryActivity.COLOR,
+            Contract.DiaryActivity._DELETED
+        )
+        private const val SELECTION = Contract.DiaryActivity._DELETED + "=0"
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/generic/PrivacyPolicyActivity.java b/app/src/main/java/com/mdiqentw/lifedots/ui/generic/PrivacyPolicyActivity.java
deleted file mode 100644
index 3c5548d..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/generic/PrivacyPolicyActivity.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots.ui.generic;
-
-import android.os.Build;
-import android.os.Bundle;
-import android.text.Html;
-import android.text.method.LinkMovementMethod;
-import android.widget.TextView;
-
-import androidx.databinding.DataBindingUtil;
-
-import com.mdiqentw.lifedots.R;
-import com.mdiqentw.lifedots.databinding.ActivityPrivacyPolicyBinding;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-public class PrivacyPolicyActivity extends BaseActivity {
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        ActivityPrivacyPolicyBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_privacy_policy);
-        setContent(binding.getRoot());
-
-        // TODO: need to et logo to the image
-
-        TextView policyText = findViewById(R.id.policyTextView);
-
-        String mergedPolicyText = "<h1>" + getResources().getString(R.string.activity_title_privacy_policy) + "</h1>";
-        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_text) + "</p>";
-        mergedPolicyText += "<h2>" + getResources().getString(R.string.privacy_intro_title) + "</h2>";
-        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_intro_text1) + "</p>";
-        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_intro_text2) + "</p>";
-        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_intro_text3) + "</p>";
-        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_intro_text4) + "</p>";
-        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_intro_text5) + "</p>";
-        mergedPolicyText += "<h2>" + getResources().getString(R.string.privacy_what_title) + "</h2>";
-        mergedPolicyText += "<h3>" + getResources().getString(R.string.privacy_what_subTitle1) + "</h3>";
-        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_what_subText1a) + "</p>";
-        mergedPolicyText += "<h3>" + getResources().getString(R.string.privacy_what_subTitle2) + "</h3>";
-        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_what_subText2a) + "</p>";
-//        mergedPolicyText += "<h3>" + getResources().getString(R.string.privacy_what_subTitle3) + "</h3>";
-//        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_what_subText3a) + "</p>";
-        mergedPolicyText += "<h3>" + getResources().getString(R.string.privacy_what_subTitle4) + "</h3>";
-        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_what_subText4a) + "</p>";
-        mergedPolicyText += "<h3>" + getResources().getString(R.string.privacy_what_subTitle5) + "</h3>";
-        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_what_subText5a) + "</p>";
-//        mergedPolicyText += "<h3>" + getResources().getString(R.string.privacy_what_subTitle6) + "</h3>";
-//        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_what_subText6a) + "</p>";
-//        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_what_subText6b) + "</p>";
-//        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_what_subText6c) + "</p>";
-//        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_what_subText6d) + "</p>";
-        mergedPolicyText += "<h2>" + getResources().getString(R.string.privacy_why_title) + "</h2>";
-        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_why_text1) + "</p>";
-        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_why_text2) + "</p>";
-        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_why_text3) + "</p>";
-        mergedPolicyText += "<h2>" + getResources().getString(R.string.privacy_how_title) + "</h2>";
-        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_how_text1) + "</p>";
-        mergedPolicyText += "<h2>" + getResources().getString(R.string.privacy_security_title) + "</h2>";
-        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_security_text) + "</p>";
-        mergedPolicyText += "<h2>" + getResources().getString(R.string.privacy_rights_title) + "</h2>";
-        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_rights_text) + "</p>";
-        mergedPolicyText += "<h2>" + getResources().getString(R.string.privacy_contact_title) + "</h2>";
-        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_contact_address) + "</p>";
-        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_contact_email) + "</p>";
-
-        if (Build.VERSION.SDK_INT >= 24) {
-            policyText.setText(Html.fromHtml(mergedPolicyText, Html.FROM_HTML_MODE_LEGACY));
-        } else {
-            policyText.setText(Html.fromHtml(mergedPolicyText));
-        }
-
-        policyText.setMovementMethod(LinkMovementMethod.getInstance());
-
-        mDrawerToggle.setDrawerIndicatorEnabled(false);
-    }
-
-    @Override
-    public void onResume(){
-        mNavigationView.getMenu().findItem(R.id.nav_privacy).setChecked(true);
-        super.onResume();
-    }
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/generic/PrivacyPolicyActivity.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/generic/PrivacyPolicyActivity.kt
new file mode 100755
index 0000000..f860092
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/generic/PrivacyPolicyActivity.kt
@@ -0,0 +1,90 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.ui.generic
+
+import android.os.Build
+import android.os.Bundle
+import android.text.Html
+import android.text.method.LinkMovementMethod
+import android.widget.TextView
+import androidx.databinding.DataBindingUtil
+import com.mdiqentw.lifedots.R
+import com.mdiqentw.lifedots.databinding.ActivityPrivacyPolicyBinding
+
+class PrivacyPolicyActivity : BaseActivity() {
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        val binding =
+            DataBindingUtil.setContentView<ActivityPrivacyPolicyBinding>(this, R.layout.activity_privacy_policy)
+        setContent(binding.root)
+
+        // TODO: need to et logo to the image
+        val policyText = findViewById<TextView>(R.id.policyTextView)
+        var mergedPolicyText = "<h1>" + resources.getString(R.string.activity_title_privacy_policy) + "</h1>"
+        mergedPolicyText += "<p>" + resources.getString(R.string.privacy_text) + "</p>"
+        mergedPolicyText += "<h2>" + resources.getString(R.string.privacy_intro_title) + "</h2>"
+        mergedPolicyText += "<p>" + resources.getString(R.string.privacy_intro_text1) + "</p>"
+        mergedPolicyText += "<p>" + resources.getString(R.string.privacy_intro_text2) + "</p>"
+        mergedPolicyText += "<p>" + resources.getString(R.string.privacy_intro_text3) + "</p>"
+        mergedPolicyText += "<p>" + resources.getString(R.string.privacy_intro_text4) + "</p>"
+        mergedPolicyText += "<p>" + resources.getString(R.string.privacy_intro_text5) + "</p>"
+        mergedPolicyText += "<h2>" + resources.getString(R.string.privacy_what_title) + "</h2>"
+        mergedPolicyText += "<h3>" + resources.getString(R.string.privacy_what_subTitle1) + "</h3>"
+        mergedPolicyText += "<p>" + resources.getString(R.string.privacy_what_subText1a) + "</p>"
+        mergedPolicyText += "<h3>" + resources.getString(R.string.privacy_what_subTitle2) + "</h3>"
+        mergedPolicyText += "<p>" + resources.getString(R.string.privacy_what_subText2a) + "</p>"
+        //        mergedPolicyText += "<h3>" + getResources().getString(R.string.privacy_what_subTitle3) + "</h3>";
+//        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_what_subText3a) + "</p>";
+        mergedPolicyText += "<h3>" + resources.getString(R.string.privacy_what_subTitle4) + "</h3>"
+        mergedPolicyText += "<p>" + resources.getString(R.string.privacy_what_subText4a) + "</p>"
+        mergedPolicyText += "<h3>" + resources.getString(R.string.privacy_what_subTitle5) + "</h3>"
+        mergedPolicyText += "<p>" + resources.getString(R.string.privacy_what_subText5a) + "</p>"
+        //        mergedPolicyText += "<h3>" + getResources().getString(R.string.privacy_what_subTitle6) + "</h3>";
+//        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_what_subText6a) + "</p>";
+//        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_what_subText6b) + "</p>";
+//        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_what_subText6c) + "</p>";
+//        mergedPolicyText += "<p>" + getResources().getString(R.string.privacy_what_subText6d) + "</p>";
+        mergedPolicyText += "<h2>" + resources.getString(R.string.privacy_why_title) + "</h2>"
+        mergedPolicyText += "<p>" + resources.getString(R.string.privacy_why_text1) + "</p>"
+        mergedPolicyText += "<p>" + resources.getString(R.string.privacy_why_text2) + "</p>"
+        mergedPolicyText += "<p>" + resources.getString(R.string.privacy_why_text3) + "</p>"
+        mergedPolicyText += "<h2>" + resources.getString(R.string.privacy_how_title) + "</h2>"
+        mergedPolicyText += "<p>" + resources.getString(R.string.privacy_how_text1) + "</p>"
+        mergedPolicyText += "<h2>" + resources.getString(R.string.privacy_security_title) + "</h2>"
+        mergedPolicyText += "<p>" + resources.getString(R.string.privacy_security_text) + "</p>"
+        mergedPolicyText += "<h2>" + resources.getString(R.string.privacy_rights_title) + "</h2>"
+        mergedPolicyText += "<p>" + resources.getString(R.string.privacy_rights_text) + "</p>"
+        mergedPolicyText += "<h2>" + resources.getString(R.string.privacy_contact_title) + "</h2>"
+        mergedPolicyText += "<p>" + resources.getString(R.string.privacy_contact_address) + "</p>"
+        mergedPolicyText += "<p>" + resources.getString(R.string.privacy_contact_email) + "</p>"
+        if (Build.VERSION.SDK_INT >= 24) {
+            policyText.text = Html.fromHtml(mergedPolicyText, Html.FROM_HTML_MODE_LEGACY)
+        } else {
+            policyText.text = Html.fromHtml(mergedPolicyText)
+        }
+        policyText.movementMethod = LinkMovementMethod.getInstance()
+        mDrawerToggle.isDrawerIndicatorEnabled = false
+    }
+
+    public override fun onResume() {
+        mNavigationView.menu.findItem(R.id.nav_privacy).isChecked = true
+        super.onResume()
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/history/AnalyticsActivity.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/history/AnalyticsActivity.kt
old mode 100644
new mode 100755
index 10da71d..971f543
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/history/AnalyticsActivity.kt
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/history/AnalyticsActivity.kt
@@ -1,7 +1,7 @@
 /*
  * LifeDots
  *
- * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -56,24 +56,6 @@ import kotlin.math.max
 import kotlin.math.min
 import kotlin.math.roundToInt
 
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
 class AnalyticsActivity : BaseActivity(),
     LoaderManager.LoaderCallbacks<Cursor?>,
     AdapterView.OnItemSelectedListener,
@@ -529,6 +511,6 @@ class AnalyticsActivity : BaseActivity(),
                 Contract.DiaryStats.PORTION,
                 Contract.DiaryStats.DURATION
         )
-        val mOpenHelper = LocalDBHelper(MVApplication.getAppContext())
+        val mOpenHelper = LocalDBHelper(MVApplication.appContext!!)
     }
 }
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/history/EventDetailActivity.java b/app/src/main/java/com/mdiqentw/lifedots/ui/history/EventDetailActivity.java
deleted file mode 100644
index 6560fe5..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/history/EventDetailActivity.java
+++ /dev/null
@@ -1,564 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-package com.mdiqentw.lifedots.ui.history;
-
-import android.annotation.SuppressLint;
-import android.app.DatePickerDialog;
-import android.app.Dialog;
-import android.app.TimePickerDialog;
-import android.content.AsyncQueryHandler;
-import android.content.ContentUris;
-import android.content.ContentValues;
-import android.content.Intent;
-import android.database.Cursor;
-import android.os.Bundle;
-import android.text.Editable;
-import android.text.TextWatcher;
-import android.text.format.DateFormat;
-import android.view.Menu;
-import android.view.MenuInflater;
-import android.view.MenuItem;
-import android.view.View;
-
-import androidx.annotation.NonNull;
-import androidx.databinding.DataBindingUtil;
-import androidx.fragment.app.DialogFragment;
-import androidx.loader.app.LoaderManager;
-import androidx.loader.content.CursorLoader;
-import androidx.loader.content.Loader;
-import androidx.recyclerview.widget.RecyclerView;
-import androidx.recyclerview.widget.StaggeredGridLayoutManager;
-
-import com.mdiqentw.lifedots.MVApplication;
-import com.mdiqentw.lifedots.R;
-import com.mdiqentw.lifedots.databinding.ActivityEventDetailContentBinding;
-import com.mdiqentw.lifedots.db.Contract;
-import com.mdiqentw.lifedots.helpers.ActivityHelper;
-import com.mdiqentw.lifedots.ui.generic.BaseActivity;
-import com.mdiqentw.lifedots.ui.generic.DetailRecyclerViewAdapter;
-
-import java.lang.ref.WeakReference;
-import java.util.Arrays;
-import java.util.Calendar;
-import java.util.Objects;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-/*
- * HistoryDetailActivity to show details of and modify diary entries
- *
- * */
-public class EventDetailActivity extends BaseActivity
-        implements LoaderManager.LoaderCallbacks<Cursor> {
-
-    private static final String[] PROJECTION_IMG = new String[] {
-            Contract.DiaryImage.URI,
-            Contract.DiaryImage._ID
-    };
-
-    private static final int READ_ALL = 1;
-    private static final int UPDATE_ENTRY = 2;
-    private static final int UPDATE_PRE = 3;
-    private static final int UPDATE_SUCC = 4;
-
-    ActivityEventDetailContentBinding binding;
-
-    private DetailRecyclerViewAdapter detailAdapter;
-
-    private final boolean[] mUpdatePending = new boolean[UPDATE_SUCC + 1];
-//    private static final int OVERLAP_CHECK = 5;
-
-    private final String[] ENTRY_PROJ = new String[]{
-            Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivity.NAME,
-            Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivity.COLOR,
-            Contract.Diary.TABLE_NAME + "." + Contract.Diary.ACT_ID,
-            Contract.Diary.TABLE_NAME + "." + Contract.Diary._ID,
-            Contract.Diary.NOTE,
-            Contract.Diary.START,
-            Contract.Diary.END};
-
-    private static final String DIRAY_ENTRY_ID_KEY = "ENTRY_ID";
-    private static final String UPDATE_VALUE_KEY = "UPDATE_VALUE";
-    private static final String ADJUST_ADJACENT_KEY = "ADJUST_ADJACENT";
-
-    final String dateFormatString = MVApplication.getAppContext().getResources().getString(R.string.date_format);
-    final String timeFormatString = MVApplication.getAppContext().getResources().getString(R.string.time_format);
-//    private final SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(MVApplication.getAppContext());
-
-    /* the id of the currently displayed diary entry */
-    private long diaryEntryID;
-//    private int actId;
-
-    private Calendar start, storedStart;
-    private Calendar end, storedEnd;
-
-    private ContentValues updateValues = new ContentValues();
-    private boolean mIsCurrent;
-
-    public static class TimePickerFragment extends DialogFragment{
-        private int hour, minute;
-        private TimePickerDialog.OnTimeSetListener listener;
-
-        public void setData(TimePickerDialog.OnTimeSetListener listener,
-                           int hour, int minute){
-            this.hour = hour;
-            this.minute = minute;
-            this.listener = listener;
-        }
-
-        @NonNull
-        @Override
-        public Dialog onCreateDialog(Bundle savedInstanceState) {
-            // Use the current time as the default values for the picker
-            // Create a new instance of TimePickerDialog and return it
-            return new TimePickerDialog(getActivity(), listener, hour, minute,
-                    DateFormat.is24HourFormat(getActivity()));
-        }
-    }
-
-    public static class DatePickerFragment extends DialogFragment{
-        private int year, month, day;
-        private DatePickerDialog.OnDateSetListener listener;
-
-        public void setData(DatePickerDialog.OnDateSetListener listener,
-                            int year, int mount, int day){
-            this.year = year;
-            this.month = mount;
-            this.day = day;
-            this.listener = listener;
-        }
-
-        @NonNull
-        @Override
-        public Dialog onCreateDialog(Bundle savedInstanceState) {
-            // Use the current time as the default values for the picker
-            // Create a new instance of TimePickerDialog and return it
-            return new DatePickerDialog(getActivity(), listener, year, month, day);
-        }
-    }
-
-    @SuppressLint("Range")
-    public void doTokenReadAll(Cursor cursor) {
-        if(cursor.moveToFirst()) {
-            start = Calendar.getInstance();
-            storedStart = Calendar.getInstance();
-            start.setTimeInMillis(cursor.getLong(cursor.getColumnIndex(Contract.Diary.START)));
-            storedStart.setTimeInMillis(cursor.getLong(cursor.getColumnIndex(Contract.Diary.START)));
-            end = Calendar.getInstance();
-            storedEnd = Calendar.getInstance();
-            long endMillis = cursor.getLong(cursor.getColumnIndex(Contract.Diary.END));
-            storedEnd.setTimeInMillis(endMillis);
-            if (endMillis != 0) {
-                end.setTimeInMillis(endMillis);
-                mIsCurrent = false;
-            } else {
-                mIsCurrent = true;
-            }
-
-            if(!updateValues.containsKey(Contract.Diary.NOTE)) {
-                binding.editActivityNote.setText(cursor.getString(cursor.getColumnIndex(Contract.Diary.NOTE)));
-            }
-//            actId = cursor.getInt(cursor.getColumnIndex(Contract.Diary.ACT_ID));
-//            System.out.println("Contract.DiaryActivity: " + cursor.getString(cursor.getColumnIndex(Contract.DiaryActivity.NAME)) +
-//                    " " + actId);
-            binding.row.name.setText(
-                    cursor.getString(cursor.getColumnIndex(Contract.DiaryActivity.NAME)));
-//            binding.activityCard.setOnLongClickListener((view) -> {
-//                Intent i = new Intent(EventDetailActivity.this, EditActivity.class);
-//                i.putExtra("activityID", actId);
-//                startActivity(i);
-//                return true;
-//            });
-            binding.row.background.setBackgroundColor(cursor.getInt(cursor.getColumnIndex(Contract.DiaryActivity.COLOR)));
-
-            if(diaryEntryID == -1){
-                diaryEntryID = cursor.getLong(cursor.getColumnIndex(Contract.Diary._ID));
-            }
-            overrideUpdates();
-        }
-    }
-
-    public void doUpdateTokens(int token) {
-        if(token == UPDATE_ENTRY){
-            mUpdatePending[UPDATE_ENTRY] = false;
-        }
-        if(token == UPDATE_SUCC){
-            mUpdatePending[UPDATE_SUCC] = false;
-        }
-        if(token == UPDATE_PRE){
-            mUpdatePending[UPDATE_PRE] = false;
-        }
-        int i;
-        for(i = 0; i < mUpdatePending.length; i++){
-            if(mUpdatePending[i]){
-                break;
-            }
-        }
-        if(i >= mUpdatePending.length) {
-            if(mIsCurrent) {
-                ActivityHelper.helper.readCurrentActivity();
-            }
-            finish();
-        }
-    }
-
-    private static class QHandler extends AsyncQueryHandler {
-        final EventDetailActivity act;
-
-        private QHandler(EventDetailActivity act){
-            super(MVApplication.getAppContext().getContentResolver());
-            this.act = new WeakReference<>(act).get();
-        }
-
-        @SuppressLint("Range")
-        @Override
-        protected void onQueryComplete(int token, Object cookie, Cursor cursor) {
-            if (cursor != null) {
-                if(token == READ_ALL) act.doTokenReadAll(cursor);
-                cursor.close();
-            }
-        }
-
-        @Override
-        protected void onUpdateComplete(int token, Object cookie, int result) {
-            super.onUpdateComplete(token, cookie, result);
-            act.doUpdateTokens(token);
-        }
-    }
-
-    // override the UI by the values in updateValues
-    private void overrideUpdates() {
-        if(updateValues.containsKey(Contract.Diary.NOTE)) {
-            binding.editActivityNote.setText((CharSequence) updateValues.get(Contract.Diary.NOTE));
-        }
-        if(updateValues.containsKey(Contract.Diary.START)) {
-            start.setTimeInMillis(updateValues.getAsLong(Contract.Diary.START));
-        }
-        if(updateValues.containsKey(Contract.Diary.END)) {
-            end.setTimeInMillis(updateValues.getAsLong(Contract.Diary.END));
-        }
-        updateDateTimes();
-    }
-
-    private void updateDateTimes() {
-        binding.dateStart.setText(DateFormat.format(dateFormatString, start));
-        binding.timeStart.setText(DateFormat.format(timeFormatString, start));
-        binding.dateEnd.setText(DateFormat.format(dateFormatString, end));
-        binding.timeEnd.setText(DateFormat.format(timeFormatString, end));
-        checkConstraints();
-    }
-
-    private final QHandler mQHandler = new QHandler(this);
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        binding = DataBindingUtil.setContentView(this, R.layout.activity_event_detail_content);
-        setContent(binding.getRoot());
-        binding.setActivity(this);
-
-        Intent i = getIntent();
-        diaryEntryID = i.getIntExtra("diaryEntryID", -1);
-
-        binding.editActivityNote.addTextChangedListener(new TextWatcher() {
-            @Override
-            public void beforeTextChanged(CharSequence s, int start, int count, int after) {
-                // empty
-            }
-
-            @Override
-            public void onTextChanged(CharSequence s, int start, int before, int count) {
-                // empty
-            }
-
-            @Override
-            public void afterTextChanged(Editable s) {
-                String ss = s.toString();
-                updateValues.put(Contract.Diary.NOTE, ss);
-            }
-        });
-
-        start = Calendar.getInstance();
-        end = Calendar.getInstance();
-
-        RecyclerView.LayoutManager layoutMan = new StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL);
-        binding.pictureRecycler.setLayoutManager(layoutMan);
-        detailAdapter = new DetailRecyclerViewAdapter(this,null);
-        binding.pictureRecycler.setAdapter(detailAdapter);
-
-        LoaderManager.getInstance(this).restartLoader(0, null, this);
-
-        if(savedInstanceState != null) {
-            updateValues = savedInstanceState.getParcelable(UPDATE_VALUE_KEY);
-            diaryEntryID = savedInstanceState.getLong(DIRAY_ENTRY_ID_KEY);
-            binding.adjustAdjacent.setChecked(savedInstanceState.getBoolean(ADJUST_ADJACENT_KEY));
-            overrideUpdates();
-        }
-        Arrays.fill(mUpdatePending, false);
-        if(diaryEntryID == -1) {
-            mQHandler.startQuery(READ_ALL,
-                    null,
-                    Contract.Diary.CONTENT_URI,
-                    ENTRY_PROJ,
-                    Contract.Diary.TABLE_NAME + "." + Contract.Diary._ID
-                            + " = (SELECT MAX(" + Contract.Diary._ID + ") FROM " + Contract.Diary.TABLE_NAME + ")",
-                    null,
-                    null);
-        }else {
-            mQHandler.startQuery(READ_ALL,
-                    null,
-                    Contract.Diary.CONTENT_URI,
-                    ENTRY_PROJ,
-                    Contract.Diary.TABLE_NAME + "." + Contract.Diary._ID + "=?",
-                    new String[]{Long.toString(diaryEntryID)},
-                    null);
-        }
-
-        mDrawerToggle.setDrawerIndicatorEnabled(false);
-        Objects.requireNonNull(getSupportActionBar()).setHomeAsUpIndicator(R.drawable.ic_close_cancel);
-    }
-
-    @Override
-    public void onResume(){
-        mNavigationView.getMenu().findItem(R.id.nav_diary).setChecked(true);
-        super.onResume();
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-    }
-
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        outState.putBoolean(ADJUST_ADJACENT_KEY, binding.adjustAdjacent.isChecked());
-        outState.putLong(DIRAY_ENTRY_ID_KEY, diaryEntryID);
-        outState.putParcelable(UPDATE_VALUE_KEY, updateValues);
-        // call superclass to save any view hierarchy
-        super.onSaveInstanceState(outState);
-    }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        MenuInflater inflater = getMenuInflater();
-        inflater.inflate(R.menu.edit_diary_entry_menu, menu);
-        return true;
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        int mid = item.getItemId();
-//        if (mid == R.id.action_edit_delete) {
-//            /* TODO: DELETE diary entry */
-//            Toast.makeText(this, R.string.delete_event_entry_msg, Toast.LENGTH_SHORT).show();
-//            finish();
-//        } else
-        if (mid == android.R.id.home) {
-            /* cancel edit */
-            finish();
-        } else if (mid == R.id.action_edit_done) {
-            /* finish edit and save */
-            if(checkConstraints()) {
-                if (updateValues.size() > 0) {
-                    mQHandler.startUpdate(UPDATE_ENTRY, null,
-                            ContentUris.withAppendedId(Contract.Diary.CONTENT_URI, diaryEntryID),
-                            updateValues, null, null);
-                    mUpdatePending[UPDATE_ENTRY] = true;
-
-                    if (binding.adjustAdjacent.isChecked()) {
-                        if (updateValues.containsKey(Contract.Diary.START)) {
-                            // update also the predecessor
-                            ContentValues updateEndTime = new ContentValues();
-                            updateEndTime.put(Contract.Diary.END, updateValues.getAsString(Contract.Diary.START));
-                            mQHandler.startUpdate(UPDATE_PRE, null,
-                                    Contract.Diary.CONTENT_URI,
-                                    updateEndTime,
-                                    Contract.Diary.END + "=?",
-                                    new String[]{Long.toString(storedStart.getTimeInMillis())});
-                            mUpdatePending[UPDATE_PRE] = true;
-
-                        }
-                        if (updateValues.containsKey(Contract.Diary.END)) {
-                            // update also the successor
-                            ContentValues updateStartTime = new ContentValues();
-                            updateStartTime.put(Contract.Diary.START, updateValues.getAsString(Contract.Diary.END));
-                            mQHandler.startUpdate(UPDATE_SUCC, null,
-                                    Contract.Diary.CONTENT_URI,
-                                    updateStartTime,
-                                    Contract.Diary.START + "=?",
-                                    new String[]{Long.toString(storedEnd.getTimeInMillis())});
-                            mUpdatePending[UPDATE_SUCC] = true;
-                        }
-                    }
-                } else finish();
-            }
-        }
-        return super.onOptionsItemSelected(item);
-    }
-
-    private boolean checkConstraints(){
-        boolean result = true;
-        if(end.getTimeInMillis() != 0 && !end.after(start)){
-            result = false;
-            binding.timeError.setText(R.string.constraint_positive_duration);
-        }
-
-        checkForOverlap();
-        // TODO
-        // end >= start + 1000
-        // no overlap OR adjust adjacent (but still no oerlap with the next next and last last
-
-        if(!result) {
-            // TODO: make animation here, and do so only if it is not already visibile
-            binding.timeError.setVisibility(View.VISIBLE);
-        }else{
-            binding.timeError.setVisibility(View.GONE);
-        }
-        return result;
-    }
-
-    private void checkForOverlap() {
-/*        mQHandler.startQuery(OVERLAP_CHECK,
-                null,
-                Contract.Diary.CONTENT_URI,
-                new String[]{
-                        Contract.Diary._ID
-                },
-                Contract.Diary.TABLE_NAME + "." + Contract.Diary._ID + "=?",
-                new String[]{Long.toString(start.getTimeInMillis()), Long.toString(end.getTimeInMillis())},
-                null);
-                */
-    }
-
-    /**
-     * Instantiate and return a new Loader for the given ID.
-     *
-     * @param id   The ID whose loader is to be created.
-     * @param args Any arguments supplied by the caller.
-     * @return Return a new Loader instance that is ready to start loading.
-     */
-    // Called when a new Loader needs to be created
-    @NonNull
-    @Override
-    public Loader<Cursor> onCreateLoader(int id, Bundle args) {
-        // Now create and return a CursorLoader that will take care of
-        // creating a Cursor for the data being displayed.
-        return new CursorLoader(this, Contract.DiaryImage.CONTENT_URI,
-                PROJECTION_IMG,
-                Contract.DiaryImage.TABLE_NAME + "." + Contract.DiaryImage.DIARY_ID + "=? AND "
-                        + Contract.DiaryImage._DELETED + "=0",
-                new String[]{Long.toString(diaryEntryID)},
-                Contract.DiaryImage.SORT_ORDER_DEFAULT);
-    }
-
-    // Called when a previously created loader has finished loading
-    public void onLoadFinished(@NonNull Loader<Cursor> loader, Cursor data) {
-        // Swap the new cursor in
-        detailAdapter.swapCursor(data);
-    }
-
-    // Called when a previously created loader is reset, making the data unavailable
-    public void onLoaderReset(@NonNull Loader<Cursor> loader) {
-        // This is called when the last Cursor provided to onLoadFinished()
-        // above is about to be closed.  We need to make sure we are no
-        // longer using it.
-        detailAdapter.swapCursor(null);
-    }
-
-    public void showStartTimePickerDialog(View v) {
-        TimePickerFragment newFragment = new TimePickerFragment();
-        newFragment.setData((view, hourOfDay, minute) -> {
-            start.set(Calendar.HOUR_OF_DAY, hourOfDay);
-            start.set(Calendar.MINUTE, minute);
-            start.set(Calendar.SECOND, 0);
-            start.set(Calendar.MILLISECOND, 0);
-
-            Long newStart = start.getTimeInMillis();
-            updateValues.put(Contract.Diary.START, newStart);
-            updateDateTimes();
-        }
-                , start.get(Calendar.HOUR_OF_DAY), start.get(Calendar.MINUTE));
-        newFragment.show(getSupportFragmentManager(), "startTimePicker");
-    }
-
-    public void showEndTimePickerDialog(View v) {
-        TimePickerFragment newFragment = new TimePickerFragment();
-        newFragment.setData((view, hourOfDay, minute) -> {
-            end.set(Calendar.HOUR_OF_DAY, hourOfDay);
-            end.set(Calendar.MINUTE, minute);
-            end.set(Calendar.SECOND, 0);
-            end.set(Calendar.MILLISECOND, 0);
-
-            Long newEnd = end.getTimeInMillis();
-            updateValues.put(Contract.Diary.END, newEnd);
-            updateDateTimes();
-        }
-                , end.get(Calendar.HOUR_OF_DAY), end.get(Calendar.MINUTE));
-        newFragment.show(getSupportFragmentManager(), "endTimePicker");
-    }
-
-    public void showStartDatePickerDialog(View v) {
-        DatePickerFragment newFragment = new DatePickerFragment();
-        newFragment.setData((view, year, month, dayOfMonth) -> {
-                    start.set(Calendar.YEAR, year);
-                    start.set(Calendar.MONTH, month);
-                    start.set(Calendar.DAY_OF_MONTH, dayOfMonth);
-
-                    Long newStart = start.getTimeInMillis();
-                    updateValues.put(Contract.Diary.START, newStart);
-                    updateDateTimes();
-                }
-                , start.get(Calendar.YEAR), start.get(Calendar.MONTH), start.get(Calendar.DAY_OF_MONTH));
-        newFragment.show(getSupportFragmentManager(), "startDatePicker");
-    }
-
-    public void showEndDatePickerDialog(View v) {
-        DatePickerFragment newFragment = new DatePickerFragment();
-        newFragment.setData((view, year, month, dayOfMonth) -> {
-            end.set(Calendar.YEAR, year);
-            end.set(Calendar.MONTH, month);
-            end.set(Calendar.DAY_OF_MONTH, dayOfMonth);
-
-            Long newEnd = end.getTimeInMillis();
-            updateValues.put(Contract.Diary.END, newEnd);
-            updateDateTimes();
-        }
-                , end.get(Calendar.YEAR), end.get(Calendar.MONTH), end.get(Calendar.DAY_OF_MONTH));
-        newFragment.show(getSupportFragmentManager(), "endDatePicker");
-    }
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/history/EventDetailActivity.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/history/EventDetailActivity.kt
new file mode 100755
index 0000000..78860cf
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/history/EventDetailActivity.kt
@@ -0,0 +1,521 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.ui.history
+
+import android.annotation.SuppressLint
+import android.app.DatePickerDialog
+import android.app.DatePickerDialog.OnDateSetListener
+import android.app.Dialog
+import android.app.TimePickerDialog
+import android.app.TimePickerDialog.OnTimeSetListener
+import android.content.AsyncQueryHandler
+import android.content.ContentUris
+import android.content.ContentValues
+import android.database.Cursor
+import android.os.Bundle
+import android.text.Editable
+import android.text.TextWatcher
+import android.text.format.DateFormat
+import android.view.Menu
+import android.view.MenuItem
+import android.view.View
+import android.widget.DatePicker
+import android.widget.TimePicker
+import androidx.databinding.DataBindingUtil
+import androidx.fragment.app.DialogFragment
+import androidx.loader.app.LoaderManager
+import androidx.loader.content.CursorLoader
+import androidx.loader.content.Loader
+import androidx.recyclerview.widget.RecyclerView
+import androidx.recyclerview.widget.StaggeredGridLayoutManager
+import com.mdiqentw.lifedots.MVApplication
+import com.mdiqentw.lifedots.R
+import com.mdiqentw.lifedots.databinding.ActivityEventDetailContentBinding
+import com.mdiqentw.lifedots.db.Contract
+import com.mdiqentw.lifedots.helpers.ActivityHelper
+import com.mdiqentw.lifedots.ui.generic.BaseActivity
+import com.mdiqentw.lifedots.ui.generic.DetailRecyclerViewAdapter
+import java.lang.ref.WeakReference
+import java.util.*
+
+/*
+ * HistoryDetailActivity to show details of and modify diary entries
+ *
+ * */
+class EventDetailActivity : BaseActivity(), LoaderManager.LoaderCallbacks<Cursor> {
+    lateinit var binding: ActivityEventDetailContentBinding
+    private var detailAdapter: DetailRecyclerViewAdapter? = null
+    private val mUpdatePending = BooleanArray(UPDATE_SUCC + 1)
+
+    //    private static final int OVERLAP_CHECK = 5;
+    private val ENTRY_PROJ = arrayOf(
+        Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivity.NAME,
+        Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivity.COLOR,
+        Contract.Diary.TABLE_NAME + "." + Contract.Diary.ACT_ID,
+        Contract.Diary.TABLE_NAME + "." + Contract.Diary._ID,
+        Contract.Diary.NOTE,
+        Contract.Diary.START,
+        Contract.Diary.END
+    )
+    val dateFormatString = MVApplication.appContext!!.resources.getString(R.string.date_format)
+    val timeFormatString = MVApplication.appContext!!.resources.getString(R.string.time_format)
+
+    //    private final SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(MVApplication.getAppContext());
+    /* the id of the currently displayed diary entry */
+    private var diaryEntryID: Long = 0
+
+    //    private int actId;
+    private var start: Calendar? = null
+    private var storedStart: Calendar? = null
+    private var end: Calendar? = null
+    private var storedEnd: Calendar? = null
+    private var updateValues: ContentValues? = ContentValues()
+    private var mIsCurrent = false
+
+    class TimePickerFragment : DialogFragment() {
+        private var hour = 0
+        private var minute = 0
+        private var listener: OnTimeSetListener? = null
+        fun setData(
+            listener: OnTimeSetListener?,
+            hour: Int, minute: Int
+        ) {
+            this.hour = hour
+            this.minute = minute
+            this.listener = listener
+        }
+
+        override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
+            // Use the current time as the default values for the picker
+            // Create a new instance of TimePickerDialog and return it
+            return TimePickerDialog(
+                activity, listener, hour, minute,
+                DateFormat.is24HourFormat(activity)
+            )
+        }
+    }
+
+    class DatePickerFragment : DialogFragment() {
+        private var year = 0
+        private var month = 0
+        private var day = 0
+        private var listener: OnDateSetListener? = null
+        fun setData(
+            listener: OnDateSetListener?,
+            year: Int, mount: Int, day: Int
+        ) {
+            this.year = year
+            month = mount
+            this.day = day
+            this.listener = listener
+        }
+
+        override fun onCreateDialog(savedInstanceState: Bundle?): Dialog {
+            // Use the current time as the default values for the picker
+            // Create a new instance of TimePickerDialog and return it
+            return DatePickerDialog(requireActivity(), listener, year, month, day)
+        }
+    }
+
+    @SuppressLint("Range")
+    fun doTokenReadAll(cursor: Cursor) {
+        if (cursor.moveToFirst()) {
+            start = Calendar.getInstance()
+            storedStart = Calendar.getInstance()
+            start!!.timeInMillis = cursor.getLong(cursor.getColumnIndex(Contract.Diary.START))
+            storedStart!!.timeInMillis = cursor.getLong(cursor.getColumnIndex(Contract.Diary.START))
+            end = Calendar.getInstance()
+            storedEnd = Calendar.getInstance()
+            val endMillis = cursor.getLong(cursor.getColumnIndex(Contract.Diary.END))
+            storedEnd!!.timeInMillis = endMillis
+            mIsCurrent = if (endMillis != 0L) {
+                end!!.timeInMillis = endMillis
+                false
+            } else {
+                true
+            }
+            if (!updateValues!!.containsKey(Contract.Diary.NOTE)) {
+                binding.editActivityNote.setText(cursor.getString(cursor.getColumnIndex(Contract.Diary.NOTE)))
+            }
+            //            actId = cursor.getInt(cursor.getColumnIndex(Contract.Diary.ACT_ID));
+//            System.out.println("Contract.DiaryActivity: " + cursor.getString(cursor.getColumnIndex(Contract.DiaryActivity.NAME)) +
+//                    " " + actId);
+            binding.row.name.text =
+                cursor.getString(cursor.getColumnIndex(Contract.DiaryActivity.NAME))
+            //            binding.activityCard.setOnLongClickListener((view) -> {
+//                Intent i = new Intent(EventDetailActivity.this, EditActivity.class);
+//                i.putExtra("activityID", actId);
+//                startActivity(i);
+//                return true;
+//            });
+            binding.row.background.setBackgroundColor(cursor.getInt(cursor.getColumnIndex(Contract.DiaryActivity.COLOR)))
+            if (diaryEntryID == -1L) {
+                diaryEntryID = cursor.getLong(cursor.getColumnIndex(Contract.Diary._ID))
+            }
+            overrideUpdates()
+        }
+    }
+
+    fun doUpdateTokens(token: Int) {
+        if (token == UPDATE_ENTRY) {
+            mUpdatePending[UPDATE_ENTRY] = false
+        }
+        if (token == UPDATE_SUCC) {
+            mUpdatePending[UPDATE_SUCC] = false
+        }
+        if (token == UPDATE_PRE) {
+            mUpdatePending[UPDATE_PRE] = false
+        }
+        var i = 0
+        while (i < mUpdatePending.size) {
+            if (mUpdatePending[i]) {
+                break
+            }
+            i++
+        }
+        if (i >= mUpdatePending.size) {
+            if (mIsCurrent) {
+                ActivityHelper.helper.readCurrentActivity()
+            }
+            finish()
+        }
+    }
+
+    private class QHandler(act: EventDetailActivity) :
+        AsyncQueryHandler(MVApplication.appContext!!.contentResolver) {
+        val act: EventDetailActivity?
+
+        init {
+            this.act = WeakReference(act).get()
+        }
+
+        @SuppressLint("Range")
+        override fun onQueryComplete(token: Int, cookie: Any?, cursor: Cursor) {
+            if (token == READ_ALL) act!!.doTokenReadAll(cursor)
+            cursor.close()
+        }
+
+        override fun onUpdateComplete(token: Int, cookie: Any?, result: Int) {
+            super.onUpdateComplete(token, cookie, result)
+            act!!.doUpdateTokens(token)
+        }
+    }
+
+    // override the UI by the values in updateValues
+    private fun overrideUpdates() {
+        if (updateValues!!.containsKey(Contract.Diary.NOTE)) {
+            binding.editActivityNote.setText(updateValues!![Contract.Diary.NOTE] as CharSequence)
+        }
+        if (updateValues!!.containsKey(Contract.Diary.START)) {
+            start!!.timeInMillis = updateValues!!.getAsLong(Contract.Diary.START)
+        }
+        if (updateValues!!.containsKey(Contract.Diary.END)) {
+            end!!.timeInMillis = updateValues!!.getAsLong(Contract.Diary.END)
+        }
+        updateDateTimes()
+    }
+
+    private fun updateDateTimes() {
+        binding.dateStart.text = DateFormat.format(dateFormatString, start)
+        binding.timeStart.text = DateFormat.format(timeFormatString, start)
+        binding.dateEnd.text = DateFormat.format(dateFormatString, end)
+        binding.timeEnd.text = DateFormat.format(timeFormatString, end)
+        checkConstraints()
+    }
+
+    private val mQHandler = QHandler(this)
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        binding = DataBindingUtil.setContentView(this, R.layout.activity_event_detail_content)
+        setContent(binding.root)
+        binding.activity = this
+        val i = intent
+        diaryEntryID = i.getIntExtra("diaryEntryID", -1).toLong()
+        binding.editActivityNote.addTextChangedListener(object : TextWatcher {
+            override fun beforeTextChanged(s: CharSequence, start: Int, count: Int, after: Int) {
+                // empty
+            }
+
+            override fun onTextChanged(s: CharSequence, start: Int, before: Int, count: Int) {
+                // empty
+            }
+
+            override fun afterTextChanged(s: Editable) {
+                val ss = s.toString()
+                updateValues!!.put(Contract.Diary.NOTE, ss)
+            }
+        })
+        start = Calendar.getInstance()
+        end = Calendar.getInstance()
+        val layoutMan: RecyclerView.LayoutManager = StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL)
+        binding.pictureRecycler.layoutManager = layoutMan
+        detailAdapter = DetailRecyclerViewAdapter(this, null)
+        binding.pictureRecycler.adapter = detailAdapter
+        LoaderManager.getInstance(this).restartLoader(0, null, this)
+        if (savedInstanceState != null) {
+            updateValues = savedInstanceState.getParcelable(UPDATE_VALUE_KEY)
+            diaryEntryID = savedInstanceState.getLong(DIRAY_ENTRY_ID_KEY)
+            binding.adjustAdjacent.isChecked = savedInstanceState.getBoolean(ADJUST_ADJACENT_KEY)
+            overrideUpdates()
+        }
+        Arrays.fill(mUpdatePending, false)
+        if (diaryEntryID == -1L) {
+            mQHandler.startQuery(
+                READ_ALL,
+                null,
+                Contract.Diary.CONTENT_URI,
+                ENTRY_PROJ,
+                Contract.Diary.TABLE_NAME + "." + Contract.Diary._ID
+                        + " = (SELECT MAX(" + Contract.Diary._ID + ") FROM " + Contract.Diary.TABLE_NAME + ")",
+                null,
+                null
+            )
+        } else {
+            mQHandler.startQuery(
+                READ_ALL,
+                null,
+                Contract.Diary.CONTENT_URI,
+                ENTRY_PROJ,
+                Contract.Diary.TABLE_NAME + "." + Contract.Diary._ID + "=?",
+                arrayOf(diaryEntryID.toString()),
+                null
+            )
+        }
+        mDrawerToggle.isDrawerIndicatorEnabled = false
+        supportActionBar!!.setHomeAsUpIndicator(R.drawable.ic_close_cancel)
+    }
+
+    public override fun onResume() {
+        mNavigationView.menu.findItem(R.id.nav_diary).isChecked = true
+        super.onResume()
+    }
+
+    public override fun onPause() {
+        super.onPause()
+    }
+
+    public override fun onSaveInstanceState(outState: Bundle) {
+        outState.putBoolean(ADJUST_ADJACENT_KEY, binding.adjustAdjacent.isChecked)
+        outState.putLong(DIRAY_ENTRY_ID_KEY, diaryEntryID)
+        outState.putParcelable(UPDATE_VALUE_KEY, updateValues)
+        // call superclass to save any view hierarchy
+        super.onSaveInstanceState(outState)
+    }
+
+    override fun onCreateOptionsMenu(menu: Menu): Boolean {
+        val inflater = menuInflater
+        inflater.inflate(R.menu.edit_diary_entry_menu, menu)
+        return true
+    }
+
+    override fun onOptionsItemSelected(item: MenuItem): Boolean {
+        val mid = item.itemId
+        //        if (mid == R.id.action_edit_delete) {
+//            /* TODO: DELETE diary entry */
+//            Toast.makeText(this, R.string.delete_event_entry_msg, Toast.LENGTH_SHORT).show();
+//            finish();
+//        } else
+        if (mid == android.R.id.home) {
+            /* cancel edit */
+            finish()
+        } else if (mid == R.id.action_edit_done) {
+            /* finish edit and save */
+            if (checkConstraints()) {
+                if (updateValues!!.size() > 0) {
+                    mQHandler.startUpdate(
+                        UPDATE_ENTRY, null,
+                        ContentUris.withAppendedId(Contract.Diary.CONTENT_URI, diaryEntryID),
+                        updateValues, null, null
+                    )
+                    mUpdatePending[UPDATE_ENTRY] = true
+                    if (binding.adjustAdjacent.isChecked) {
+                        if (updateValues!!.containsKey(Contract.Diary.START)) {
+                            // update also the predecessor
+                            val updateEndTime = ContentValues()
+                            updateEndTime.put(Contract.Diary.END, updateValues!!.getAsString(Contract.Diary.START))
+                            mQHandler.startUpdate(
+                                UPDATE_PRE, null,
+                                Contract.Diary.CONTENT_URI,
+                                updateEndTime,
+                                Contract.Diary.END + "=?", arrayOf(
+                                    storedStart!!.timeInMillis.toString()
+                                )
+                            )
+                            mUpdatePending[UPDATE_PRE] = true
+                        }
+                        if (updateValues!!.containsKey(Contract.Diary.END)) {
+                            // update also the successor
+                            val updateStartTime = ContentValues()
+                            updateStartTime.put(Contract.Diary.START, updateValues!!.getAsString(Contract.Diary.END))
+                            mQHandler.startUpdate(
+                                UPDATE_SUCC, null,
+                                Contract.Diary.CONTENT_URI,
+                                updateStartTime,
+                                Contract.Diary.START + "=?", arrayOf(
+                                    storedEnd!!.timeInMillis.toString()
+                                )
+                            )
+                            mUpdatePending[UPDATE_SUCC] = true
+                        }
+                    }
+                } else finish()
+            }
+        }
+        return super.onOptionsItemSelected(item)
+    }
+
+    private fun checkConstraints(): Boolean {
+        var result = true
+        if (end!!.timeInMillis != 0L && !end!!.after(start)) {
+            result = false
+            binding.timeError.setText(R.string.constraint_positive_duration)
+        }
+        checkForOverlap()
+        // TODO
+        // end >= start + 1000
+        // no overlap OR adjust adjacent (but still no oerlap with the next next and last last
+        if (!result) {
+            // TODO: make animation here, and do so only if it is not already visibile
+            binding.timeError.visibility = View.VISIBLE
+        } else {
+            binding.timeError.visibility = View.GONE
+        }
+        return result
+    }
+
+    private fun checkForOverlap() {
+        /*        mQHandler.startQuery(OVERLAP_CHECK,
+                null,
+                Contract.Diary.CONTENT_URI,
+                new String[]{
+                        Contract.Diary._ID
+                },
+                Contract.Diary.TABLE_NAME + "." + Contract.Diary._ID + "=?",
+                new String[]{Long.toString(start.getTimeInMillis()), Long.toString(end.getTimeInMillis())},
+                null);
+                */
+    }
+
+    /**
+     * Instantiate and return a new Loader for the given ID.
+     *
+     * @param id   The ID whose loader is to be created.
+     * @param args Any arguments supplied by the caller.
+     * @return Return a new Loader instance that is ready to start loading.
+     */
+    // Called when a new Loader needs to be created
+    override fun onCreateLoader(id: Int, args: Bundle?): Loader<Cursor> {
+        // Now create and return a CursorLoader that will take care of
+        // creating a Cursor for the data being displayed.
+        return CursorLoader(
+            this, Contract.DiaryImage.CONTENT_URI,
+            PROJECTION_IMG,
+            Contract.DiaryImage.TABLE_NAME + "." + Contract.DiaryImage.DIARY_ID + "=? AND "
+                    + Contract.DiaryImage._DELETED + "=0", arrayOf(diaryEntryID.toString()),
+            Contract.DiaryImage.SORT_ORDER_DEFAULT
+        )
+    }
+
+    // Called when a previously created loader has finished loading
+    override fun onLoadFinished(loader: Loader<Cursor>, data: Cursor) {
+        // Swap the new cursor in
+        detailAdapter!!.swapCursor(data)
+    }
+
+    // Called when a previously created loader is reset, making the data unavailable
+    override fun onLoaderReset(loader: Loader<Cursor>) {
+        // This is called when the last Cursor provided to onLoadFinished()
+        // above is about to be closed.  We need to make sure we are no
+        // longer using it.
+        detailAdapter!!.swapCursor(null)
+    }
+
+    fun showStartTimePickerDialog(v: View?) {
+        val newFragment = TimePickerFragment()
+        newFragment.setData(
+            { _: TimePicker?, hourOfDay: Int, minute: Int ->
+                start!![Calendar.HOUR_OF_DAY] = hourOfDay
+                start!![Calendar.MINUTE] = minute
+                start!![Calendar.SECOND] = 0
+                start!![Calendar.MILLISECOND] = 0
+                val newStart = start!!.timeInMillis
+                updateValues!!.put(Contract.Diary.START, newStart)
+                updateDateTimes()
+            }, start!![Calendar.HOUR_OF_DAY], start!![Calendar.MINUTE])
+        newFragment.show(supportFragmentManager, "startTimePicker")
+    }
+
+    fun showEndTimePickerDialog(v: View?) {
+        val newFragment = TimePickerFragment()
+        newFragment.setData(
+            { _: TimePicker?, hourOfDay: Int, minute: Int ->
+                end!![Calendar.HOUR_OF_DAY] = hourOfDay
+                end!![Calendar.MINUTE] = minute
+                end!![Calendar.SECOND] = 0
+                end!![Calendar.MILLISECOND] = 0
+                val newEnd = end!!.timeInMillis
+                updateValues!!.put(Contract.Diary.END, newEnd)
+                updateDateTimes()
+            }, end!![Calendar.HOUR_OF_DAY], end!![Calendar.MINUTE])
+        newFragment.show(supportFragmentManager, "endTimePicker")
+    }
+
+    fun showStartDatePickerDialog(v: View?) {
+        val newFragment = DatePickerFragment()
+        newFragment.setData(
+            { _: DatePicker?, year: Int, month: Int, dayOfMonth: Int ->
+                start!![Calendar.YEAR] = year
+                start!![Calendar.MONTH] = month
+                start!![Calendar.DAY_OF_MONTH] = dayOfMonth
+                val newStart = start!!.timeInMillis
+                updateValues!!.put(Contract.Diary.START, newStart)
+                updateDateTimes()
+            }, start!![Calendar.YEAR], start!![Calendar.MONTH], start!![Calendar.DAY_OF_MONTH])
+        newFragment.show(supportFragmentManager, "startDatePicker")
+    }
+
+    fun showEndDatePickerDialog(v: View?) {
+        val newFragment = DatePickerFragment()
+        newFragment.setData(
+            { _: DatePicker?, year: Int, month: Int, dayOfMonth: Int ->
+                end!![Calendar.YEAR] = year
+                end!![Calendar.MONTH] = month
+                end!![Calendar.DAY_OF_MONTH] = dayOfMonth
+                val newEnd = end!!.timeInMillis
+                updateValues!!.put(Contract.Diary.END, newEnd)
+                updateDateTimes()
+            }, end!![Calendar.YEAR], end!![Calendar.MONTH], end!![Calendar.DAY_OF_MONTH])
+        newFragment.show(supportFragmentManager, "endDatePicker")
+    }
+
+    companion object {
+        private val PROJECTION_IMG = arrayOf(
+            Contract.DiaryImage.URI,
+            Contract.DiaryImage._ID
+        )
+        private const val READ_ALL = 1
+        private const val UPDATE_ENTRY = 2
+        private const val UPDATE_PRE = 3
+        private const val UPDATE_SUCC = 4
+        private const val DIRAY_ENTRY_ID_KEY = "ENTRY_ID"
+        private const val UPDATE_VALUE_KEY = "UPDATE_VALUE"
+        private const val ADJUST_ADJACENT_KEY = "ADJUST_ADJACENT"
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/history/HistoryActivity.java b/app/src/main/java/com/mdiqentw/lifedots/ui/history/HistoryActivity.java
deleted file mode 100644
index 3e5975f..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/history/HistoryActivity.java
+++ /dev/null
@@ -1,692 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- * Copyright (C) 2018 Bc. Ondrej Janitor
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots.ui.history;
-
-import android.app.SearchManager;
-import android.content.AsyncQueryHandler;
-import android.content.ContentProviderClient;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.Intent;
-import android.content.res.Configuration;
-import android.database.Cursor;
-import android.net.Uri;
-import android.os.Bundle;
-import android.view.Menu;
-import android.view.MenuInflater;
-import android.view.MenuItem;
-import android.view.View;
-import android.view.inputmethod.EditorInfo;
-import android.widget.Toast;
-
-import androidx.annotation.NonNull;
-import androidx.annotation.Nullable;
-import androidx.appcompat.widget.SearchView;
-import androidx.core.util.Pair;
-import androidx.cursoradapter.widget.CursorAdapter;
-import androidx.databinding.DataBindingUtil;
-import androidx.fragment.app.DialogFragment;
-import androidx.loader.app.LoaderManager;
-import androidx.loader.content.CursorLoader;
-import androidx.loader.content.Loader;
-import androidx.recyclerview.widget.StaggeredGridLayoutManager;
-
-import com.google.android.material.datepicker.MaterialDatePicker;
-import com.mdiqentw.lifedots.MVApplication;
-import com.mdiqentw.lifedots.R;
-import com.mdiqentw.lifedots.databinding.ActivityHistoryContentBinding;
-import com.mdiqentw.lifedots.db.Contract;
-import com.mdiqentw.lifedots.db.LDContentProvider;
-import com.mdiqentw.lifedots.ui.generic.BaseActivity;
-import com.mdiqentw.lifedots.ui.generic.DetailRecyclerViewAdapter;
-import com.mdiqentw.lifedots.ui.main.NoteEditDialog;
-
-import java.text.ParseException;
-import java.text.SimpleDateFormat;
-import java.util.Calendar;
-import java.util.Objects;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-/*
- * Show the history of the Diary.
- * */
-public class HistoryActivity extends BaseActivity
-        implements LoaderManager.LoaderCallbacks<Cursor>,
-        NoteEditDialog.NoteEditDialogListener,
-        HistoryRecyclerViewAdapter.SelectListener,
-        MenuItem.OnMenuItemClickListener,
-        SearchView.OnCloseListener,
-        SearchView.OnQueryTextListener {
-
-    private static final String[] PROJECTION = new String[]{
-            Contract.Diary.TABLE_NAME + "." + Contract.Diary._ID,
-            Contract.Diary.ACT_ID,
-            Contract.Diary.START,
-            Contract.Diary.END,
-            Contract.Diary.NOTE,
-            Contract.DiaryActivity.NAME,
-            Contract.DiaryActivity.COLOR
-    };
-
-    private static final String SELECTION = Contract.Diary.TABLE_NAME + "." + Contract.Diary._DELETED + "=0";
-    private static final int SEARCH_SUGGESTION_DISPLAY_COUNT = 5;
-
-    private static final int LOADER_ID_HISTORY = -1;
-    private static final int SEARCH_TYPE_ACTIVITYID = 1;
-    private static final int SEARCH_TYPE_NOTE = 2;
-    private static final int SEARCH_TYPE_TEXT_ALL = 3;
-    private static final int SEARCH_TYPE_DATE = 4;
-    private static final int OBTAIN_TYPE_NOTE = 5;
-    private static final int OBTAIN_TYPE_IMAGE = 6;
-    private static final int OBTAIN_TYPE_PERIOD = 7;
-
-    public static final long MS_Per_Day = 1000 * 60 * 60 * 24;
-
-    ActivityHistoryContentBinding binding;
-
-    private HistoryRecyclerViewAdapter historyAdapter;
-    private DetailRecyclerViewAdapter[] detailAdapters;
-    private SearchView searchView;
-
-    private Long startTime, endTime, duration;
-
-    final ContentProviderClient client = MVApplication.getAppContext().getContentResolver().acquireContentProviderClient(Contract.AUTHORITY);
-    final LDContentProvider provider = (LDContentProvider) client.getLocalContentProvider();
-
-    public HistoryActivity() {
-        endTime = System.currentTimeMillis();
-        startTime = endTime - MS_Per_Day;
-        duration = MS_Per_Day;
-    }
-
-    @Override
-    public void onItemClick(HistoryViewHolders viewHolder, int adapterPosition, int diaryID) {
-        Intent i = new Intent(this, EventDetailActivity.class);
-        i.putExtra("diaryEntryID", diaryID);
-        startActivity(i);
-    }
-
-    public boolean onItemLongClick(HistoryViewHolders viewHolder, int adapterPosition, int diaryID) {
-        NoteEditDialog dialog = new NoteEditDialog();
-        dialog.setDiaryId(diaryID);
-        if (viewHolder != null) {
-            CharSequence noteText = viewHolder.mNoteLabel.getText();
-            if (noteText != null && noteText.length()>0)
-                dialog.setInputText(noteText.toString());
-        }
-        dialog.show(getSupportFragmentManager(), "NoteEditDialogFragment");
-        return true;
-    }
-
-    /**
-     * The user is attempting to close the SearchView.
-     *
-     * @return true if the listener wants to override the default behavior of clearing the
-     * text field and dismissing it, false otherwise.
-     */
-    @Override
-    public boolean onClose() {
-        filterHistoryView(null);
-        return false;
-    }
-
-    @Override
-    public boolean onQueryTextSubmit(String query) {
-        // handled via Intent
-        return false;
-    }
-
-
-    @Override
-    public void onBackPressed() {
-        if (!searchView.isIconified()) {
-            searchView.setIconified(true);
-        } else {
-            super.onBackPressed();
-        }
-    }
-
-    /**
-     * Called when the query text is changed by the user.
-     *
-     * @param newText the new content of the query text field.
-     * @return false if the SearchView should perform the default action of showing any
-     * suggestions if available, true if the action was handled by the listener.
-     */
-    @Override
-    public boolean onQueryTextChange(String newText) {
-        // no dynamic change before starting the search...
-        setDefaultColorSearchText();
-        return true;
-    }
-
-    public boolean onMenuItemClick(MenuItem item) {
-        int mid = item.getItemId();
-        if (mid == R.id.menu_notes) {
-            obtainHistoryNotes();
-        } else if (mid == R.id.menu_dates) {
-            MaterialDatePicker<Pair<Long, Long>> picker = MaterialDatePicker.Builder.dateRangePicker().build();
-            picker.show(getSupportFragmentManager(), picker.toString());
-            picker.addOnPositiveButtonClickListener(selection -> {
-                startTime = selection.first;
-                endTime = selection.second;
-                duration = endTime - startTime;
-
-                binding.hisRangeTextView.setText(String.format("%d Days", duration / MS_Per_Day));
-                obtainHistoryInPeriod();
-            });
-//        } else if (item.getItemId() == R.id.menu_images) {
-//            obtainHistoryImages();
-        }
-
-        return true;
-    }
-
-    protected static class QHandler extends AsyncQueryHandler {
-        /* Access only allowed via ActivityHelper.helper singleton */
-        private QHandler() {
-            super(MVApplication.getAppContext().getContentResolver());
-        }
-    }
-
-    protected final QHandler mQHandler = new QHandler();
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        binding = DataBindingUtil.setContentView(this, R.layout.activity_history_content);
-        setContent(binding.getRoot());
-        binding.setActivity(this);
-
-        Intent i = getIntent();
-        long tstart = i.getLongExtra("StartTime", 0L);
-        long tend = i.getLongExtra("EndTime", 0L);
-        if (tstart > 0L && tend > 0L) {
-            startTime = tstart;
-            endTime = tend;
-        }
-
-        detailAdapters = new DetailRecyclerViewAdapter[5];
-
-        StaggeredGridLayoutManager detailLayoutManager;
-        int hov;
-        if(getResources().getConfiguration().orientation == Configuration.ORIENTATION_LANDSCAPE)
-            hov = StaggeredGridLayoutManager.HORIZONTAL;
-        else
-            hov = StaggeredGridLayoutManager.VERTICAL;
-
-        detailLayoutManager = new MyStaggeredGridLayoutManager(hov);
-
-//        detailLayoutManager.setAutoMeasureEnabled(true);
-
-        binding.historyList.setLayoutManager(detailLayoutManager);
-
-        historyAdapter = new HistoryRecyclerViewAdapter(HistoryActivity.this, this, null);
-        binding.historyList.setAdapter(historyAdapter);
-
-        binding.hisRangeTextView.setText(String.format("%d Days", duration / MS_Per_Day));
-        binding.hisImgEarlier.setOnClickListener(v -> {
-            endTime = startTime;
-            startTime -= duration;
-            filterHistoryView(null);
-        });
-        binding.hisImgLater.setOnClickListener(v -> {
-            startTime = endTime;
-            endTime += duration;
-            filterHistoryView(null);
-        });
-
-        // Prepare the loader.  Either re-connect with an existing one,
-        // or start a new one.
-        // and yes, for performance reasons it is good to do it the relational way and not with an OO design
-        LoaderManager.getInstance(this).initLoader(LOADER_ID_HISTORY, null, this);
-        mDrawerToggle.setDrawerIndicatorEnabled(false);
-
-        // Get the intent, verify the action and get the query
-        handleIntent(getIntent());
-    }
-
-    public void showDatePickerDialog(View v) {
-        EventDetailActivity.DatePickerFragment newFragment = new EventDetailActivity.DatePickerFragment();
-        Calendar date = Calendar.getInstance();
-        date.setTimeInMillis(startTime+duration/2);
-        newFragment.setData((view, year, month, dayOfMonth) -> {
-            date.set(Calendar.YEAR, year);
-            date.set(Calendar.MONTH, month);
-            date.set(Calendar.DAY_OF_MONTH, dayOfMonth);
-            startTime = date.getTimeInMillis() - duration/2;
-            endTime = date.getTimeInMillis() + duration/2;
-            filterHistoryView(null);
-        }
-                , date.get(Calendar.YEAR), date.get(Calendar.MONTH), date.get(Calendar.DAY_OF_MONTH));
-        newFragment.show(getSupportFragmentManager(), "startDatePicker");
-    }
-
-    @Override
-    protected void onNewIntent(Intent intent) {
-        super.onNewIntent(intent);
-        setIntent(intent);
-        handleIntent(intent);
-    }
-
-    private void handleIntent(Intent intent) {
-        String query = null;
-        String action = intent.getAction();
-        if (LDContentProvider.SEARCH_ACTIVITY.equals(action)) {
-            query = intent.getStringExtra(SearchManager.QUERY);
-            Uri data = intent.getData();
-            if (data != null) {
-                query = data.getLastPathSegment();
-                long id = Long.decode(data.getLastPathSegment());
-                filterHistoryView(id);
-            }
-        } else if (LDContentProvider.SEARCH_NOTE.equals(action)) {
-            Uri data = intent.getData();
-            if (data != null) {
-                query = data.getLastPathSegment();
-                filterHistoryNotes(query);
-            }
-        } else if (LDContentProvider.SEARCH_GLOBAL.equals(action)) {
-            Uri data = intent.getData();
-            if (data != null) {
-                query = data.getLastPathSegment();
-                filterHistoryView(query);
-            }
-        } else if (LDContentProvider.SEARCH_DATE.equals(action)) {
-            Uri data = intent.getData();
-            if (data != null) {
-
-                query = data.getPath();
-                query = query.replaceFirst("/","");
-                filterHistoryDates(query);
-            }
-        } else if (Intent.ACTION_SEARCH.equals(action)) {
-            query = intent.getStringExtra(SearchManager.QUERY);
-            action = LDContentProvider.SEARCH_GLOBAL;
-            filterHistoryView(query);
-        }
-        /*
-            if query was searched, then insert query into suggestion table
-         */
-        if (query != null) {
-            Uri uri = Contract.DiarySearchSuggestion.CONTENT_URI;
-
-            ContentValues values = new ContentValues();
-
-            getContentResolver().delete(uri,
-                    Contract.DiarySearchSuggestion.SUGGESTION + " LIKE ? AND "
-                    + Contract.DiarySearchSuggestion.ACTION + " LIKE ?",
-                    new String[]{query, action});
-
-            values.put(Contract.DiarySearchSuggestion.SUGGESTION, query);
-            values.put(Contract.DiarySearchSuggestion.ACTION, action);
-            getContentResolver().insert(uri, values);
-
-            getContentResolver().delete(uri,
-                    Contract.DiarySearchSuggestion._ID +
-                    " IN (SELECT " + Contract.DiarySearchSuggestion._ID +
-                    " FROM " + Contract.DiarySearchSuggestion.TABLE_NAME +
-                    " ORDER BY " + Contract.DiarySearchSuggestion._ID + " DESC LIMIT " + SEARCH_SUGGESTION_DISPLAY_COUNT + ",1)",
-                    null);
-        }
-    }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        MenuInflater inflater = getMenuInflater();
-        inflater.inflate(R.menu.history_menu, menu);
-
-        MenuItem notesMenuItem = menu.findItem(R.id.menu_notes);
-        notesMenuItem.setOnMenuItemClickListener(this);
-
-        MenuItem datesMenuItem = menu.findItem(R.id.menu_dates);
-        datesMenuItem.setOnMenuItemClickListener(this);
-
-//        MenuItem imagesMenuItem = menu.findItem(R.id.menu_images);
-//        imagesMenuItem.setOnMenuItemClickListener(this);
-//
-        // Get the SearchView and set the searchable configuration
-        SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE);
-        MenuItem searchMenuItem = menu.findItem(R.id.action_filter);
-        searchView = (SearchView) searchMenuItem.getActionView();
-        searchView.setIconifiedByDefault(true);
-        // Assumes current activity is the searchable activity
-        searchView.setSearchableInfo(searchManager.getSearchableInfo(getComponentName()));
-        searchView.setOnCloseListener(this);
-        searchView.setOnQueryTextListener(this);
-        searchView.setOnSuggestionListener(new SearchView.OnSuggestionListener() {
-            @Override
-            public boolean onSuggestionSelect(int position) {
-                return false;
-            }
-
-            @Override
-            public boolean onSuggestionClick(int position) {
-                CursorAdapter selectedView = searchView.getSuggestionsAdapter();
-                Cursor cursor = (Cursor) selectedView.getItem(position);
-                int index = cursor.getColumnIndexOrThrow(SearchManager.SUGGEST_COLUMN_QUERY);
-                String q = cursor.getString(index);
-                searchView.setQuery(q, false);
-                return false; // let super handle all the real search stuff
-            }
-        });
-
-        searchView.setImeOptions(searchView.getImeOptions() | EditorInfo.IME_ACTION_SEARCH);
-//TODO to make it look nice
-//        searchView.setSuggestionsAdapter(new ExampleAdapter(this, cursor, items));
-
-        return true;
-    }
-
-
-    /**
-     * @param query the search string, if null resets the filter
-     */
-    private void filterHistoryView(@Nullable String query) {
-        if (query == null) {
-            LoaderManager.getInstance(this).restartLoader(LOADER_ID_HISTORY, null, this);
-        } else {
-            Bundle args = new Bundle();
-            args.putInt("TYPE", SEARCH_TYPE_TEXT_ALL);
-            args.putString("TEXT", query);
-            LoaderManager.getInstance(this).restartLoader(LOADER_ID_HISTORY, args, this);
-        }
-    }
-
-    /* show only activity with id activityId
-     */
-    private void filterHistoryView(long activityId) {
-        Bundle args = new Bundle();
-        args.putInt("TYPE", SEARCH_TYPE_ACTIVITYID);
-        args.putLong("ACTIVITY_ID", activityId);
-        LoaderManager.getInstance(this).restartLoader(LOADER_ID_HISTORY, args, this);
-    }
-
-    /* show only activity that contains note
-     */
-    private void filterHistoryNotes(String notetext) {
-        Bundle args = new Bundle();
-        args.putInt("TYPE", SEARCH_TYPE_NOTE);
-        args.putString("TEXT", notetext);
-        LoaderManager.getInstance(this).restartLoader(LOADER_ID_HISTORY, args, this);
-    }
-
-    private void obtainHistoryNotes() {
-        Bundle args = new Bundle();
-        args.putInt("TYPE",OBTAIN_TYPE_NOTE);
-        LoaderManager.getInstance(this).restartLoader(LOADER_ID_HISTORY, args, this);
-    }
-
-    private void obtainHistoryInPeriod() {
-        Bundle args = new Bundle();
-        args.putInt("TYPE", OBTAIN_TYPE_PERIOD);
-        args.putLong("START", startTime);
-        args.putLong("END",endTime);
-        LoaderManager.getInstance(this).restartLoader(LOADER_ID_HISTORY, args, this);
-    }
-
-    private void obtainHistoryImages() {
-        Bundle args = new Bundle();
-        args.putInt("TYPE",OBTAIN_TYPE_IMAGE);
-        LoaderManager.getInstance(this).restartLoader(LOADER_ID_HISTORY, args, this);
-    }
-
-    /* show only activities that match date
-     */
-    private void filterHistoryDates(String date) {
-        Long dateInMilis = checkDateFormatAndParse(date);
-        if (dateInMilis != null) {
-            Bundle args = new Bundle();
-            args.putInt("TYPE", SEARCH_TYPE_DATE);
-            args.putLong("MILLIS", dateInMilis);
-            LoaderManager.getInstance(this).restartLoader(LOADER_ID_HISTORY, args, this);
-        }
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        // Handle your other action bar items...
-        if (item.getItemId() == R.id.action_map) {
-            Intent map = new Intent(HistoryActivity.this, MapActivity.class);
-            map.putExtra("StartTime", startTime);
-            map.putExtra("EndTime", endTime);
-            startActivity(map);
-        }
-        return super.onOptionsItemSelected(item);
-    }
-
-    // Called when a new Loader needs to be created
-    @NonNull
-    public Loader<Cursor> onCreateLoader(int id, Bundle args) {
-        // Now create and return a CursorLoader that will take care of
-        // creating a Cursor for the data being displayed.
-        if (id == LOADER_ID_HISTORY) {
-            String sel = SELECTION;
-            String[] sel_args = null;
-            if (args != null) {
-                switch (args.getInt("TYPE")) {
-                    case SEARCH_TYPE_ACTIVITYID:
-                        sel = sel + " AND " + Contract.Diary.ACT_ID + " = ?";
-                        sel_args = new String[]{Long.toString(args.getLong("ACTIVITY_ID"))};
-                        break;
-                    case SEARCH_TYPE_NOTE:
-                        sel = sel + " AND " + Contract.Diary.NOTE + " LIKE ?";
-                        sel_args = new String[]{"%" + args.getString("TEXT") + "%"};
-                        break;
-                    case OBTAIN_TYPE_NOTE:
-                        sel =  sel + " AND " + Contract.Diary.NOTE + " IS NOT NULL AND " +
-                                Contract.Diary.NOTE + " != ''" ;
-                        sel_args = null;
-                        break;
-//                    case OBTAIN_TYPE_IMAGE:
-//                        sel =  sel + " AND " + Contract.Diary. + " IS NOT NULL AND " +
-//                                Contract.Diary.NOTE + " != ''" ;
-//                        sel_args = null;
-//                        break;
-                    case OBTAIN_TYPE_PERIOD:
-                        sel = sel + " AND " + Contract.Diary.END + " >= " + args.getLong("START")
-                            + " AND " + Contract.Diary.START + " <= " + args.getLong("END");
-                        sel_args = null;
-                        break;
-                    case SEARCH_TYPE_TEXT_ALL:
-                        sel = sel + " AND (" + Contract.Diary.NOTE + " LIKE ?"
-                                + " OR " + Contract.DiaryActivity.NAME + " LIKE ?)";
-                        sel_args = new String[]{"%" + args.getString("TEXT") + "%",
-                                "%" + args.getString("TEXT") + "%"};
-                        break;
-                    case SEARCH_TYPE_DATE:
-                        // TOOD: calling here this provider method is a bit strange...
-                        String searchResultQuery = provider.searchDate(args.getLong("MILLIS"));
-                        sel = sel + " AND " + searchResultQuery;
-                        sel_args = null;
-                        break;
-                    default:
-                        break;
-                }
-            } else {
-                sel = sel + " AND " + Contract.Diary.END + " >= " + startTime
-                        + " AND " + Contract.Diary.START + " <= " + endTime;
-                sel_args = null;
-            }
-            return new CursorLoader(this, Contract.Diary.CONTENT_URI,
-                    PROJECTION, sel, sel_args, null);
-        } else {
-            return new CursorLoader(HistoryActivity.this,
-                    Contract.DiaryImage.CONTENT_URI,
-                    new String[] {Contract.DiaryImage._ID,
-                            Contract.DiaryImage.URI},
-                    Contract.DiaryImage.DIARY_ID + "=? AND "
-                            + Contract.DiaryImage._DELETED + "=0",
-                    new String[]{Long.toString(args.getLong("DiaryID"))},
-                    null);
-        }
-    }
-
-    // Called when a previously created loader has finished loading
-    public void onLoadFinished(Loader<Cursor> loader, Cursor data) {
-        // Swap the new cursor in.  (The framework will take care of closing the
-        // old cursor once we return.)
-        int i = loader.getId();
-        if (i == LOADER_ID_HISTORY) {
-            historyAdapter.swapCursor(data);
-        } else {
-            detailAdapters[i].swapCursor(data);
-        }
-    }
-
-    // Called when a previously created loader is reset, making the data unavailable
-    public void onLoaderReset(Loader<Cursor> loader) {
-        // This is called when the last Cursor provided to onLoadFinished()
-        // above is about to be closed.  We need to make sure we are no
-        // longer using it.
-        int i = loader.getId();
-        if (i == LOADER_ID_HISTORY) {
-            historyAdapter.swapCursor(null);
-        } else {
-            detailAdapters[i].swapCursor(null);
-        }
-
-    }
-
-    @Override
-    public void onNoteEditPositiveClick(String str, DialogFragment dialog) {
-        /* update note */
-        NoteEditDialog dlg = (NoteEditDialog) dialog;
-
-        ContentValues values = new ContentValues();
-        values.put(Contract.Diary.NOTE, str);
-
-        mQHandler.startUpdate(0,
-                null,
-                Uri.withAppendedPath(Contract.Diary.CONTENT_URI,
-                        Long.toString(dlg.getDiaryId())),
-                values,
-                null, null);
-    }
-
-    @Override
-    public void onResume() {
-        mNavigationView.getMenu().findItem(R.id.nav_diary).setChecked(true);
-        super.onResume();
-        historyAdapter.notifyDataSetChanged(); /* redraw the complete recyclerview to take care of e.g. date format changes in teh preferences etc. #36 */
-    }
-
-    public void addDetailAdapter(long diaryEntryId, DetailRecyclerViewAdapter adapter) {
-        /* ensure size of detailsAdapters */
-        if (detailAdapters.length <= adapter.getAdapterId()) {
-            int i = 0;
-            DetailRecyclerViewAdapter[] newArray = new DetailRecyclerViewAdapter[adapter.getAdapterId() + 4];
-            for (DetailRecyclerViewAdapter a : detailAdapters) {
-                newArray[i] = a;
-                i++;
-            }
-            detailAdapters = newArray;
-        }
-
-        Bundle b = new Bundle();
-        b.putLong("DiaryID", diaryEntryId);
-        b.putInt("DetailAdapterID", adapter.getAdapterId());
-
-        detailAdapters[adapter.getAdapterId()] = adapter;
-        LoaderManager.getInstance(this).initLoader(adapter.getAdapterId(), b, this);
-
-    }
-
-    /** Checks date format and also checks date can be parsed (used for not existing dates like 35.13.2000)
-     * (in case format not exists or date is incorrect Toast about wrong format is displayed)
-     * @param date input that is checked
-     * @return millis of parsed input
-     */
-    @Nullable
-    private Long checkDateFormatAndParse(String date){
-        // TODO: generalize data format for search
-        String[] formats = {
-                getResources().getString(R.string.date_format),                                                                 //get default format from strings.xml
-                ((SimpleDateFormat) android.text.format.DateFormat.getDateFormat(getApplicationContext())).toLocalizedPattern() //locale format
-        };
-
-        SimpleDateFormat simpleDateFormat;
-
-        for (String format: formats){
-            simpleDateFormat = new SimpleDateFormat(format);
-            simpleDateFormat.setLenient(false);
-            try {
-                return Objects.requireNonNull(simpleDateFormat.parse(date)).getTime();
-            } catch (ParseException e){
-                /* intentionally no further handling. We try the next date format and onyl if we cannot parse the date with any
-                 * supported format we return null afterwards. */
-            }
-        }
-
-        setWrongColorSearchText();
-        Toast.makeText(getApplication().getBaseContext(), getResources().getString(R.string.wrongFormat), Toast.LENGTH_LONG).show();
-        return null;
-    }
-
-    /**
-     * Sets searched text to default color (white) in case it is set to red
-     */
-    private void setDefaultColorSearchText(){
-//        TextView textView =  searchView.findViewById(androidx.appcompat.R.id.search_src_text);
-//        if (textView.getCurrentTextColor() == ContextCompat.getColor(MVApplication.getAppContext(), R.color.colorWrongText))
-//            textView.setTextColor(ContextCompat.getColor(MVApplication.getAppContext(), R.color.activityTextColorLight));
-    }
-
-    /**
-     * Sets searched text to color which indicates wrong searching (red)
-     */
-    private void setWrongColorSearchText(){
-//        TextView textView =  searchView.findViewById(androidx.appcompat.R.id.search_src_text);
-//        textView.setTextColor(ContextCompat.getColor(MVApplication.getAppContext(), R.color.colorWrongText));
-    }
-
-    private static class MyStaggeredGridLayoutManager extends StaggeredGridLayoutManager {
-        public MyStaggeredGridLayoutManager(int hov) {
-            super(1, hov);
-        }
-
-        @Override
-        public boolean isAutoMeasureEnabled () {
-            return true;
-        }
-    }
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/history/HistoryActivity.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/history/HistoryActivity.kt
new file mode 100755
index 0000000..450b40a
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/history/HistoryActivity.kt
@@ -0,0 +1,614 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2018 Bc. Ondrej Janitor
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.ui.history
+
+import android.app.SearchManager
+import android.content.AsyncQueryHandler
+import android.content.ContentValues
+import android.content.Intent
+import android.content.res.Configuration
+import android.database.Cursor
+import android.net.Uri
+import android.os.Bundle
+import android.text.format.DateFormat
+import android.view.Menu
+import android.view.MenuItem
+import android.view.View
+import android.view.inputmethod.EditorInfo
+import android.widget.DatePicker
+import android.widget.Toast
+import androidx.appcompat.widget.SearchView
+import androidx.core.util.Pair
+import androidx.databinding.DataBindingUtil
+import androidx.fragment.app.DialogFragment
+import androidx.loader.app.LoaderManager
+import androidx.loader.content.CursorLoader
+import androidx.loader.content.Loader
+import androidx.recyclerview.widget.StaggeredGridLayoutManager
+import com.google.android.material.datepicker.MaterialDatePicker
+import com.mdiqentw.lifedots.MVApplication
+import com.mdiqentw.lifedots.R
+import com.mdiqentw.lifedots.databinding.ActivityHistoryContentBinding
+import com.mdiqentw.lifedots.db.Contract
+import com.mdiqentw.lifedots.db.LDContentProvider
+import com.mdiqentw.lifedots.ui.generic.BaseActivity
+import com.mdiqentw.lifedots.ui.generic.DetailRecyclerViewAdapter
+import com.mdiqentw.lifedots.ui.history.EventDetailActivity.DatePickerFragment
+import com.mdiqentw.lifedots.ui.main.NoteEditDialog
+import com.mdiqentw.lifedots.ui.main.NoteEditDialog.NoteEditDialogListener
+import java.text.ParseException
+import java.text.SimpleDateFormat
+import java.util.*
+
+/*
+ * Show the history of the Diary.
+ * */
+class HistoryActivity : BaseActivity(), LoaderManager.LoaderCallbacks<Cursor>, NoteEditDialogListener,
+    HistoryRecyclerViewAdapter.SelectListener, MenuItem.OnMenuItemClickListener, SearchView.OnCloseListener,
+    SearchView.OnQueryTextListener {
+    lateinit var binding: ActivityHistoryContentBinding
+    private var historyAdapter: HistoryRecyclerViewAdapter? = null
+    private lateinit var detailAdapters: Array<DetailRecyclerViewAdapter?>
+    private var searchView: SearchView? = null
+    private var startTime: Long
+    private var endTime: Long
+    private var duration: Long
+    val client = MVApplication.appContext!!.contentResolver.acquireContentProviderClient(Contract.AUTHORITY)
+    val provider = client!!.localContentProvider as LDContentProvider?
+
+    override fun onItemClick(viewHolder: HistoryViewHolders?, adapterPosition: Int, diaryID: Int) {
+        val i = Intent(this, EventDetailActivity::class.java)
+        i.putExtra("diaryEntryID", diaryID)
+        startActivity(i)
+    }
+
+    override fun onItemLongClick(viewHolder: HistoryViewHolders?, adapterPosition: Int, diaryID: Int): Boolean {
+        val dialog = NoteEditDialog()
+        dialog.diaryId = diaryID.toLong()
+        if (viewHolder != null) {
+            val noteText = viewHolder.mNoteLabel.text
+            if (noteText != null && noteText.isNotEmpty()) dialog.inputText = noteText.toString()
+        }
+        dialog.show(supportFragmentManager, "NoteEditDialogFragment")
+        return true
+    }
+
+    /**
+     * The user is attempting to close the SearchView.
+     *
+     * @return true if the listener wants to override the default behavior of clearing the
+     * text field and dismissing it, false otherwise.
+     */
+    override fun onClose(): Boolean {
+        filterHistoryView(null)
+        return false
+    }
+
+    override fun onQueryTextSubmit(query: String): Boolean {
+        // handled via Intent
+        return false
+    }
+
+    @Deprecated("Deprecated in Java")
+    override fun onBackPressed() {
+        if (!searchView!!.isIconified) {
+            searchView!!.isIconified = true
+        } else {
+            super.onBackPressed()
+        }
+    }
+
+    /**
+     * Called when the query text is changed by the user.
+     *
+     * @param newText the new content of the query text field.
+     * @return false if the SearchView should perform the default action of showing any
+     * suggestions if available, true if the action was handled by the listener.
+     */
+    override fun onQueryTextChange(newText: String): Boolean {
+        // no dynamic change before starting the search...
+        setDefaultColorSearchText()
+        return true
+    }
+
+    override fun onMenuItemClick(item: MenuItem): Boolean {
+        val mid = item.itemId
+        if (mid == R.id.menu_notes) {
+            obtainHistoryNotes()
+        } else if (mid == R.id.menu_dates) {
+            val picker = MaterialDatePicker.Builder.dateRangePicker().build()
+            picker.show(supportFragmentManager, picker.toString())
+            picker.addOnPositiveButtonClickListener { selection: Pair<Long, Long> ->
+                startTime = selection.first
+                endTime = selection.second
+                duration = endTime - startTime
+                binding.hisRangeTextView.text = String.format("%d Days", duration / MS_Per_Day)
+                obtainHistoryInPeriod()
+            }
+            //        } else if (item.getItemId() == R.id.menu_images) {
+//            obtainHistoryImages();
+        }
+        return true
+    }
+
+    private class QHandler  /* Access only allowed via ActivityHelper.helper singleton */ :
+        AsyncQueryHandler(MVApplication.appContext!!.contentResolver)
+
+    private val mQHandler = QHandler()
+
+    init {
+        endTime = System.currentTimeMillis()
+        startTime = endTime - MS_Per_Day
+        duration = MS_Per_Day
+    }
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        binding = DataBindingUtil.setContentView(this, R.layout.activity_history_content)
+        setContent(binding.root)
+        binding.activity = this
+        val i = intent
+        val tstart = i.getLongExtra("StartTime", 0L)
+        val tend = i.getLongExtra("EndTime", 0L)
+        if (tstart > 0L && tend > 0L) {
+            startTime = tstart
+            endTime = tend
+        }
+        detailAdapters = arrayOfNulls(5)
+        val detailLayoutManager: StaggeredGridLayoutManager
+        val hov: Int = if (resources.configuration.orientation == Configuration.ORIENTATION_LANDSCAPE) StaggeredGridLayoutManager.HORIZONTAL else StaggeredGridLayoutManager.VERTICAL
+        detailLayoutManager = MyStaggeredGridLayoutManager(hov)
+
+//        detailLayoutManager.setAutoMeasureEnabled(true);
+        binding.historyList.layoutManager = detailLayoutManager
+        historyAdapter = HistoryRecyclerViewAdapter(this@HistoryActivity, this, null)
+        binding.historyList.adapter = historyAdapter
+        binding.hisRangeTextView.text = String.format("%d Days", duration / MS_Per_Day)
+        binding.hisImgEarlier.setOnClickListener { _: View? ->
+            endTime = startTime
+            startTime -= duration
+            filterHistoryView(null)
+        }
+        binding.hisImgLater.setOnClickListener { _: View? ->
+            startTime = endTime
+            endTime += duration
+            filterHistoryView(null)
+        }
+
+        // Prepare the loader.  Either re-connect with an existing one,
+        // or start a new one.
+        // and yes, for performance reasons it is good to do it the relational way and not with an OO design
+        LoaderManager.getInstance(this).initLoader(LOADER_ID_HISTORY, null, this)
+        mDrawerToggle.isDrawerIndicatorEnabled = false
+
+        // Get the intent, verify the action and get the query
+        handleIntent(intent)
+    }
+
+    fun showDatePickerDialog(v: View?) {
+        val newFragment = DatePickerFragment()
+        val date = Calendar.getInstance()
+        date.timeInMillis = startTime + duration / 2
+        newFragment.setData(
+            { _: DatePicker?, year: Int, month: Int, dayOfMonth: Int ->
+                date[Calendar.YEAR] = year
+                date[Calendar.MONTH] = month
+                date[Calendar.DAY_OF_MONTH] = dayOfMonth
+                startTime = date.timeInMillis - duration / 2
+                endTime = date.timeInMillis + duration / 2
+                filterHistoryView(null)
+            }, date[Calendar.YEAR], date[Calendar.MONTH], date[Calendar.DAY_OF_MONTH])
+        newFragment.show(supportFragmentManager, "startDatePicker")
+    }
+
+    override fun onNewIntent(intent: Intent) {
+        super.onNewIntent(intent)
+        setIntent(intent)
+        handleIntent(intent)
+    }
+
+    private fun handleIntent(intent: Intent) {
+        var query: String? = null
+        var action = intent.action
+        if (LDContentProvider.SEARCH_ACTIVITY == action) {
+            query = intent.getStringExtra(SearchManager.QUERY)
+            val data = intent.data
+            if (data != null) {
+                query = data.lastPathSegment
+                if (query != null) {
+                    val id = java.lang.Long.decode(query)
+                    filterHistoryView(id)
+                }
+            }
+        } else if (LDContentProvider.SEARCH_NOTE == action) {
+            val data = intent.data
+            if (data != null) {
+                query = data.lastPathSegment
+                filterHistoryNotes(query)
+            }
+        } else if (LDContentProvider.SEARCH_GLOBAL == action) {
+            val data = intent.data
+            if (data != null) {
+                query = data.lastPathSegment
+                filterHistoryView(query)
+            }
+        } else if (LDContentProvider.SEARCH_DATE == action) {
+            val data = intent.data
+            if (data != null) {
+                query = data.path
+                query = query!!.replaceFirst("/".toRegex(), "")
+                filterHistoryDates(query)
+            }
+        } else if (Intent.ACTION_SEARCH == action) {
+            query = intent.getStringExtra(SearchManager.QUERY)
+            action = LDContentProvider.SEARCH_GLOBAL
+            filterHistoryView(query)
+        }
+        /*
+            if query was searched, then insert query into suggestion table
+         */if (query != null) {
+            val uri = Contract.DiarySearchSuggestion.CONTENT_URI
+            val values = ContentValues()
+            contentResolver.delete(
+                uri,
+                Contract.DiarySearchSuggestion.SUGGESTION + " LIKE ? AND "
+                        + Contract.DiarySearchSuggestion.ACTION + " LIKE ?", arrayOf(query, action)
+            )
+            values.put(Contract.DiarySearchSuggestion.SUGGESTION, query)
+            values.put(Contract.DiarySearchSuggestion.ACTION, action)
+            contentResolver.insert(uri, values)
+            contentResolver.delete(
+                uri,
+                Contract.DiarySearchSuggestion._ID +
+                        " IN (SELECT " + Contract.DiarySearchSuggestion._ID +
+                        " FROM " + Contract.DiarySearchSuggestion.TABLE_NAME +
+                        " ORDER BY " + Contract.DiarySearchSuggestion._ID + " DESC LIMIT " + SEARCH_SUGGESTION_DISPLAY_COUNT + ",1)",
+                null
+            )
+        }
+    }
+
+    override fun onCreateOptionsMenu(menu: Menu): Boolean {
+        val inflater = menuInflater
+        inflater.inflate(R.menu.history_menu, menu)
+        val notesMenuItem = menu.findItem(R.id.menu_notes)
+        notesMenuItem.setOnMenuItemClickListener(this)
+        val datesMenuItem = menu.findItem(R.id.menu_dates)
+        datesMenuItem.setOnMenuItemClickListener(this)
+
+//        MenuItem imagesMenuItem = menu.findItem(R.id.menu_images);
+//        imagesMenuItem.setOnMenuItemClickListener(this);
+//
+        // Get the SearchView and set the searchable configuration
+        val searchManager = getSystemService(SEARCH_SERVICE) as SearchManager
+        val searchMenuItem = menu.findItem(R.id.action_filter)
+        searchView = searchMenuItem.actionView as SearchView?
+        searchView!!.setIconifiedByDefault(true)
+        // Assumes current activity is the searchable activity
+        searchView!!.setSearchableInfo(searchManager.getSearchableInfo(componentName))
+        searchView!!.setOnCloseListener(this)
+        searchView!!.setOnQueryTextListener(this)
+        searchView!!.setOnSuggestionListener(object : SearchView.OnSuggestionListener {
+            override fun onSuggestionSelect(position: Int): Boolean {
+                return false
+            }
+
+            override fun onSuggestionClick(position: Int): Boolean {
+                val selectedView = searchView!!.suggestionsAdapter
+                val cursor = selectedView.getItem(position) as Cursor
+                val index = cursor.getColumnIndexOrThrow(SearchManager.SUGGEST_COLUMN_QUERY)
+                val q = cursor.getString(index)
+                searchView!!.setQuery(q, false)
+                return false // let super handle all the real search stuff
+            }
+        })
+        searchView!!.imeOptions = searchView!!.imeOptions or EditorInfo.IME_ACTION_SEARCH
+        //TODO to make it look nice
+//        searchView.setSuggestionsAdapter(new ExampleAdapter(this, cursor, items));
+        return true
+    }
+
+    /**
+     * @param query the search string, if null resets the filter
+     */
+    private fun filterHistoryView(query: String?) {
+        if (query == null) {
+            LoaderManager.getInstance(this).restartLoader(LOADER_ID_HISTORY, null, this)
+        } else {
+            val args = Bundle()
+            args.putInt("TYPE", SEARCH_TYPE_TEXT_ALL)
+            args.putString("TEXT", query)
+            LoaderManager.getInstance(this).restartLoader(LOADER_ID_HISTORY, args, this)
+        }
+    }
+
+    /* show only activity with id activityId
+     */
+    private fun filterHistoryView(activityId: Long) {
+        val args = Bundle()
+        args.putInt("TYPE", SEARCH_TYPE_ACTIVITYID)
+        args.putLong("ACTIVITY_ID", activityId)
+        LoaderManager.getInstance(this).restartLoader(LOADER_ID_HISTORY, args, this)
+    }
+
+    /* show only activity that contains note
+     */
+    private fun filterHistoryNotes(notetext: String?) {
+        val args = Bundle()
+        args.putInt("TYPE", SEARCH_TYPE_NOTE)
+        args.putString("TEXT", notetext)
+        LoaderManager.getInstance(this).restartLoader(LOADER_ID_HISTORY, args, this)
+    }
+
+    private fun obtainHistoryNotes() {
+        val args = Bundle()
+        args.putInt("TYPE", OBTAIN_TYPE_NOTE)
+        LoaderManager.getInstance(this).restartLoader(LOADER_ID_HISTORY, args, this)
+    }
+
+    private fun obtainHistoryInPeriod() {
+        val args = Bundle()
+        args.putInt("TYPE", OBTAIN_TYPE_PERIOD)
+        args.putLong("START", startTime)
+        args.putLong("END", endTime)
+        LoaderManager.getInstance(this).restartLoader(LOADER_ID_HISTORY, args, this)
+    }
+
+    private fun obtainHistoryImages() {
+        val args = Bundle()
+        args.putInt("TYPE", OBTAIN_TYPE_IMAGE)
+        LoaderManager.getInstance(this).restartLoader(LOADER_ID_HISTORY, args, this)
+    }
+
+    /* show only activities that match date
+     */
+    private fun filterHistoryDates(date: String) {
+        val dateInMilis = checkDateFormatAndParse(date)
+        if (dateInMilis != null) {
+            val args = Bundle()
+            args.putInt("TYPE", SEARCH_TYPE_DATE)
+            args.putLong("MILLIS", dateInMilis)
+            LoaderManager.getInstance(this).restartLoader(LOADER_ID_HISTORY, args, this)
+        }
+    }
+
+    override fun onOptionsItemSelected(item: MenuItem): Boolean {
+        // Handle your other action bar items...
+        if (item.itemId == R.id.action_map) {
+            val map = Intent(this@HistoryActivity, MapActivity::class.java)
+            map.putExtra("StartTime", startTime)
+            map.putExtra("EndTime", endTime)
+            startActivity(map)
+        }
+        return super.onOptionsItemSelected(item)
+    }
+
+    // Called when a new Loader needs to be created
+    override fun onCreateLoader(id: Int, args: Bundle?): Loader<Cursor> {
+        // Now create and return a CursorLoader that will take care of
+        // creating a Cursor for the data being displayed.
+        return if (id == LOADER_ID_HISTORY) {
+            var sel = SELECTION
+            var sel_args: Array<String>? = null
+            if (args != null) {
+                when (args.getInt("TYPE")) {
+                    SEARCH_TYPE_ACTIVITYID -> {
+                        sel = sel + " AND " + Contract.Diary.ACT_ID + " = ?"
+                        sel_args = arrayOf(args.getLong("ACTIVITY_ID").toString())
+                    }
+
+                    SEARCH_TYPE_NOTE -> {
+                        sel = sel + " AND " + Contract.Diary.NOTE + " LIKE ?"
+                        sel_args = arrayOf("%" + args.getString("TEXT") + "%")
+                    }
+
+                    OBTAIN_TYPE_NOTE -> {
+                        sel = sel + " AND " + Contract.Diary.NOTE + " IS NOT NULL AND " +
+                                Contract.Diary.NOTE + " != ''"
+                        sel_args = null
+                    }
+
+                    OBTAIN_TYPE_PERIOD -> {
+                        sel = (sel + " AND " + Contract.Diary.END + " >= " + args.getLong("START")
+                                + " AND " + Contract.Diary.START + " <= " + args.getLong("END"))
+                        sel_args = null
+                    }
+
+                    SEARCH_TYPE_TEXT_ALL -> {
+                        sel = (sel + " AND (" + Contract.Diary.NOTE + " LIKE ?"
+                                + " OR " + Contract.DiaryActivity.NAME + " LIKE ?)")
+                        sel_args = arrayOf(
+                            "%" + args.getString("TEXT") + "%",
+                            "%" + args.getString("TEXT") + "%"
+                        )
+                    }
+
+                    SEARCH_TYPE_DATE -> {
+                        // TOOD: calling here this provider method is a bit strange...
+                        val searchResultQuery = provider!!.searchDate(args.getLong("MILLIS"))
+                        sel = "$sel AND $searchResultQuery"
+                        sel_args = null
+                    }
+
+                    else -> {}
+                }
+            } else {
+                sel = (sel + " AND " + Contract.Diary.END + " >= " + startTime
+                        + " AND " + Contract.Diary.START + " <= " + endTime)
+                sel_args = null
+            }
+            CursorLoader(
+                this, Contract.Diary.CONTENT_URI,
+                PROJECTION, sel, sel_args, null
+            )
+        } else {
+            CursorLoader(
+                this@HistoryActivity,
+                Contract.DiaryImage.CONTENT_URI, arrayOf(
+                    Contract.DiaryImage._ID,
+                    Contract.DiaryImage.URI
+                ),
+                Contract.DiaryImage.DIARY_ID + "=? AND "
+                        + Contract.DiaryImage._DELETED + "=0", arrayOf(
+                    args!!.getLong("DiaryID").toString()
+                ),
+                null
+            )
+        }
+    }
+
+    // Called when a previously created loader has finished loading
+    override fun onLoadFinished(loader: Loader<Cursor>, data: Cursor) {
+        // Swap the new cursor in.  (The framework will take care of closing the
+        // old cursor once we return.)
+        val i = loader.id
+        if (i == LOADER_ID_HISTORY) {
+            historyAdapter!!.swapCursor(data)
+        } else {
+            detailAdapters[i]!!.swapCursor(data)
+        }
+    }
+
+    // Called when a previously created loader is reset, making the data unavailable
+    override fun onLoaderReset(loader: Loader<Cursor>) {
+        // This is called when the last Cursor provided to onLoadFinished()
+        // above is about to be closed.  We need to make sure we are no
+        // longer using it.
+        val i = loader.id
+        if (i == LOADER_ID_HISTORY) {
+            historyAdapter!!.swapCursor(null)
+        } else {
+            detailAdapters[i]!!.swapCursor(null)
+        }
+    }
+
+    override fun onNoteEditPositiveClick(str: String?, dialog: DialogFragment?) {
+        /* update note */
+        val dlg = dialog as NoteEditDialog?
+        val values = ContentValues()
+        values.put(Contract.Diary.NOTE, str)
+        mQHandler.startUpdate(
+            0,
+            null,
+            Uri.withAppendedPath(
+                Contract.Diary.CONTENT_URI,
+                dlg!!.diaryId.toString()
+            ),
+            values,
+            null, null
+        )
+    }
+
+    public override fun onResume() {
+        mNavigationView.menu.findItem(R.id.nav_diary).isChecked = true
+        super.onResume()
+        historyAdapter!!.notifyDataSetChanged() /* redraw the complete recyclerview to take care of e.g. date format changes in teh preferences etc. #36 */
+    }
+
+    fun addDetailAdapter(diaryEntryId: Long, adapter: DetailRecyclerViewAdapter) {
+        /* ensure size of detailsAdapters */
+        if (detailAdapters.size <= adapter.adapterId) {
+            val newArray = arrayOfNulls<DetailRecyclerViewAdapter>(adapter.adapterId + 4)
+            for ((i, a) in detailAdapters.withIndex()) {
+                newArray[i] = a
+            }
+            detailAdapters = newArray
+        }
+        val b = Bundle()
+        b.putLong("DiaryID", diaryEntryId)
+        b.putInt("DetailAdapterID", adapter.adapterId)
+        detailAdapters[adapter.adapterId] = adapter
+        LoaderManager.getInstance(this).initLoader(adapter.adapterId, b, this)
+    }
+
+    /** Checks date format and also checks date can be parsed (used for not existing dates like 35.13.2000)
+     * (in case format not exists or date is incorrect Toast about wrong format is displayed)
+     * @param date input that is checked
+     * @return millis of parsed input
+     */
+    private fun checkDateFormatAndParse(date: String): Long? {
+        // TODO: generalize data format for search
+        val formats = arrayOf(
+            resources.getString(R.string.date_format),  //get default format from strings.xml
+            (DateFormat.getDateFormat(applicationContext) as SimpleDateFormat).toLocalizedPattern() //locale format
+        )
+        var simpleDateFormat: SimpleDateFormat
+        for (format in formats) {
+            simpleDateFormat = SimpleDateFormat(format)
+            simpleDateFormat.isLenient = false
+            try {
+                return Objects.requireNonNull(simpleDateFormat.parse(date)).time
+            } catch (e: ParseException) {
+                /* intentionally no further handling. We try the next date format and onyl if we cannot parse the date with any
+                 * supported format we return null afterwards. */
+            }
+        }
+        setWrongColorSearchText()
+        Toast.makeText(application.baseContext, resources.getString(R.string.wrongFormat), Toast.LENGTH_LONG).show()
+        return null
+    }
+
+    /**
+     * Sets searched text to default color (white) in case it is set to red
+     */
+    private fun setDefaultColorSearchText() {
+//        TextView textView =  searchView.findViewById(androidx.appcompat.R.id.search_src_text);
+//        if (textView.getCurrentTextColor() == ContextCompat.getColor(MVApplication.getAppContext(), R.color.colorWrongText))
+//            textView.setTextColor(ContextCompat.getColor(MVApplication.getAppContext(), R.color.activityTextColorLight));
+    }
+
+    /**
+     * Sets searched text to color which indicates wrong searching (red)
+     */
+    private fun setWrongColorSearchText() {
+//        TextView textView =  searchView.findViewById(androidx.appcompat.R.id.search_src_text);
+//        textView.setTextColor(ContextCompat.getColor(MVApplication.getAppContext(), R.color.colorWrongText));
+    }
+
+    private class MyStaggeredGridLayoutManager(hov: Int) : StaggeredGridLayoutManager(1, hov) {
+        override fun isAutoMeasureEnabled(): Boolean {
+            return true
+        }
+    }
+
+    companion object {
+        private val PROJECTION = arrayOf(
+            Contract.Diary.TABLE_NAME + "." + Contract.Diary._ID,
+            Contract.Diary.ACT_ID,
+            Contract.Diary.START,
+            Contract.Diary.END,
+            Contract.Diary.NOTE,
+            Contract.DiaryActivity.NAME,
+            Contract.DiaryActivity.COLOR
+        )
+        private const val SELECTION = Contract.Diary.TABLE_NAME + "." + Contract.Diary._DELETED + "=0"
+        private const val SEARCH_SUGGESTION_DISPLAY_COUNT = 5
+        private const val LOADER_ID_HISTORY = -1
+        private const val SEARCH_TYPE_ACTIVITYID = 1
+        private const val SEARCH_TYPE_NOTE = 2
+        private const val SEARCH_TYPE_TEXT_ALL = 3
+        private const val SEARCH_TYPE_DATE = 4
+        private const val OBTAIN_TYPE_NOTE = 5
+        private const val OBTAIN_TYPE_IMAGE = 6
+        private const val OBTAIN_TYPE_PERIOD = 7
+        const val MS_Per_Day = (1000 * 60 * 60 * 24).toLong()
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/history/HistoryRecyclerViewAdapter.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/history/HistoryRecyclerViewAdapter.kt
old mode 100644
new mode 100755
index 231fb6f..12e10e4
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/history/HistoryRecyclerViewAdapter.kt
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/history/HistoryRecyclerViewAdapter.kt
@@ -2,6 +2,7 @@
  * LifeDots
  *
  * Copyright (C) 2017 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -41,24 +42,6 @@ import com.mdiqentw.lifedots.helpers.TimeSpanFormatter
 import com.mdiqentw.lifedots.ui.generic.DetailRecyclerViewAdapter
 import com.mdiqentw.lifedots.ui.settings.SettingsActivity
 
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
 class HistoryRecyclerViewAdapter(private val mContext: HistoryActivity,
                                  private val mListener: SelectListener,
                                  private var mCursor: Cursor?) :
@@ -151,10 +134,10 @@ class HistoryRecyclerViewAdapter(private val mContext: HistoryActivity,
             holder.mSeparator.visibility = View.GONE
 
         holder.mName.text = name
-        val sharedPref = PreferenceManager.getDefaultSharedPreferences(MVApplication.getAppContext())
+        val sharedPref = PreferenceManager.getDefaultSharedPreferences(MVApplication.appContext!!)
         val formatString = sharedPref.getString(SettingsActivity.KEY_PREF_DATETIME_FORMAT,
                 mContext.resources.getString(R.string.default_datetime_format))
-        /* TODO: #36 register listener on preference change to redraw the date time formatting */holder.mStartLabel.text = MVApplication.getAppContext().resources.getString(R.string.history_start, DateFormat.format(formatString, start))
+        /* TODO: #36 register listener on preference change to redraw the date time formatting */holder.mStartLabel.text = MVApplication.appContext!!.resources.getString(R.string.history_start, DateFormat.format(formatString, start))
         var noteStr: String? = ""
         if (!mCursor!!.isNull(noteRowIdx)) {
             noteStr = mCursor!!.getString(noteRowIdx)
@@ -165,16 +148,16 @@ class HistoryRecyclerViewAdapter(private val mContext: HistoryActivity,
         holder.mNoteLabel.text = noteStr
         val duration: String
         if (end == null)
-            duration = MVApplication.getAppContext().resources.getString(R.string.duration_description, TimeSpanFormatter.fuzzyFormat(start, Date()))
+            duration = MVApplication.appContext!!.resources.getString(R.string.duration_description, TimeSpanFormatter.fuzzyFormat(start, Date()))
         else {
-            holder.mStartLabel.text = MVApplication.getAppContext().resources.getString(R.string.history_start, DateFormat.format(formatString, start))
-            duration = MVApplication.getAppContext().resources.getString(R.string.history_end, DateFormat.format(formatString, end),
+            holder.mStartLabel.text = MVApplication.appContext!!.resources.getString(R.string.history_start, DateFormat.format(formatString, start))
+            duration = MVApplication.appContext!!.resources.getString(R.string.history_end, DateFormat.format(formatString, end),
                     TimeSpanFormatter.format(end.time - start.time))
         }
         holder.mDurationLabel.text = duration
 
         /* TODO #33: set activity picture (icon + main pciture if available) */holder.mDetailAdapter = DetailRecyclerViewAdapter(mContext, null)
-        mContext.addDetailAdapter(mCursor!!.getLong(idRowIdx), holder.mDetailAdapter)
+        mContext.addDetailAdapter(mCursor!!.getLong(idRowIdx), holder.mDetailAdapter!!)
 
         /* TODO: make it a configuration option how many picture columns we should show */
         val layoutMan: RecyclerView.LayoutManager = StaggeredGridLayoutManager(3, StaggeredGridLayoutManager.VERTICAL)
@@ -188,7 +171,7 @@ class HistoryRecyclerViewAdapter(private val mContext: HistoryActivity,
         else 0
     }
 
-    fun swapCursor(newCursor: Cursor) {
+    fun swapCursor(newCursor: Cursor?) {
         if (newCursor === mCursor) {
 //            if (newCursor != null) {
 //                newCursor.close();    // not sure if this should be closed,  leave it open for now
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/history/HistoryViewHolders.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/history/HistoryViewHolders.kt
old mode 100644
new mode 100755
index c2f2084..9e64f33
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/history/HistoryViewHolders.kt
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/history/HistoryViewHolders.kt
@@ -2,6 +2,7 @@
  * LifeDots
  *
  * Copyright (C) 2017 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -27,24 +28,6 @@ import androidx.recyclerview.widget.RecyclerView
 import com.mdiqentw.lifedots.databinding.ActivityHistoryEntryBinding
 import com.mdiqentw.lifedots.ui.generic.DetailRecyclerViewAdapter
 
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
 class HistoryViewHolders(val detailLoaderID: Int, listener: HistoryRecyclerViewAdapter.SelectListener, bind: ActivityHistoryEntryBinding) : RecyclerView.ViewHolder(bind.root), View.OnClickListener, OnLongClickListener {
     var diaryEntryID = 0
     @JvmField
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/history/MapActivity.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/history/MapActivity.kt
old mode 100644
new mode 100755
index 1b8c98a..ff4281e
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/history/MapActivity.kt
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/history/MapActivity.kt
@@ -1,7 +1,7 @@
 /*
  * LifeDots
  *
- * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -59,24 +59,6 @@ import java.text.SimpleDateFormat
 import java.util.*
 import kotlin.math.abs
 
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
 class MapActivity : BaseActivity(),
     LoaderManager.LoaderCallbacks<Cursor?>, MenuItem.OnMenuItemClickListener {
 
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/main/DetailNoteFragment.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/main/DetailNoteFragment.kt
old mode 100644
new mode 100755
index c65ea9e..4ed30f8
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/main/DetailNoteFragment.kt
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/main/DetailNoteFragment.kt
@@ -2,6 +2,7 @@
  * LifeDots
  *
  * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -30,24 +31,6 @@ import com.mdiqentw.lifedots.R
 import com.mdiqentw.lifedots.databinding.FragmentDetailNoteBinding
 import com.mdiqentw.lifedots.model.DetailViewModel
 
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
 class DetailNoteFragment : Fragment() {
     private var viewModel: DetailViewModel? = null
 
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/main/DetailPictureFragement.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/main/DetailPictureFragement.kt
old mode 100644
new mode 100755
index b1ac723..c1a6593
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/main/DetailPictureFragement.kt
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/main/DetailPictureFragement.kt
@@ -2,6 +2,7 @@
  * LifeDots
  *
  * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -38,24 +39,7 @@ import com.mdiqentw.lifedots.ui.generic.DetailRecyclerViewAdapter
 
 //import androidx.gridlayout.widget.GridLayoutManager;
 //import androidx.recyclerview.widget.LinearLayoutManager;
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
+
 class DetailPictureFragement : Fragment(), LoaderManager.LoaderCallbacks<Cursor> {
 
     private lateinit var detailRecyclerView: RecyclerView
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/main/DetailStatFragement.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/main/DetailStatFragement.kt
old mode 100644
new mode 100755
index 2668abb..96dd527
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/main/DetailStatFragement.kt
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/main/DetailStatFragement.kt
@@ -2,6 +2,7 @@
  * LifeDots
  *
  * Copyright (C) 2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -37,24 +38,6 @@ import com.mdiqentw.lifedots.model.DetailViewModel
 import com.mdiqentw.lifedots.ui.history.EventDetailActivity
 import java.util.*
 
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
 class DetailStatFragement : Fragment() {
     private val updateDurationHandler = Handler(Looper.myLooper()!!)
     private var viewModel: DetailViewModel? = null
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/main/MainActivity.java b/app/src/main/java/com/mdiqentw/lifedots/ui/main/MainActivity.java
deleted file mode 100644
index 9e9a7cc..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/main/MainActivity.java
+++ /dev/null
@@ -1,617 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-package com.mdiqentw.lifedots.ui.main;
-
-import android.annotation.SuppressLint;
-import android.app.SearchManager;
-import android.content.AsyncQueryHandler;
-import android.content.ContentResolver;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.database.Cursor;
-import android.net.Uri;
-import android.os.Bundle;
-import android.provider.MediaStore;
-import android.util.Log;
-import android.util.TypedValue;
-import android.view.Menu;
-import android.view.MenuInflater;
-import android.view.MenuItem;
-import android.view.View;
-import android.view.WindowManager;
-import android.widget.Toast;
-
-import androidx.annotation.NonNull;
-import androidx.appcompat.widget.SearchView;
-import androidx.core.content.ContextCompat;
-import androidx.core.content.FileProvider;
-import androidx.databinding.DataBindingUtil;
-import androidx.fragment.app.DialogFragment;
-import androidx.fragment.app.Fragment;
-import androidx.fragment.app.FragmentManager;
-import androidx.fragment.app.FragmentPagerAdapter;
-import androidx.lifecycle.ViewModelProvider;
-import androidx.preference.PreferenceManager;
-import androidx.viewpager.widget.ViewPager;
-
-import com.google.android.flexbox.FlexDirection;
-import com.google.android.flexbox.FlexboxLayoutManager;
-import com.google.android.flexbox.JustifyContent;
-import com.mdiqentw.lifedots.BuildConfig;
-import com.mdiqentw.lifedots.R;
-import com.mdiqentw.lifedots.databinding.ActivityMainContentBinding;
-import com.mdiqentw.lifedots.db.Contract;
-import com.mdiqentw.lifedots.helpers.ActivityHelper;
-import com.mdiqentw.lifedots.helpers.DateHelper;
-import com.mdiqentw.lifedots.helpers.GraphicsHelper;
-import com.mdiqentw.lifedots.helpers.TimeSpanFormatter;
-import com.mdiqentw.lifedots.model.DetailViewModel;
-import com.mdiqentw.lifedots.model.DiaryActivity;
-import com.mdiqentw.lifedots.ui.generic.BaseActivity;
-import com.mdiqentw.lifedots.ui.generic.EditActivity;
-import com.mdiqentw.lifedots.ui.history.EventDetailActivity;
-import com.mdiqentw.lifedots.ui.settings.SettingsActivity;
-
-import java.io.File;
-import java.util.ArrayList;
-import java.util.Calendar;
-import java.util.List;
-import java.util.Objects;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-/*
- * MainActivity to show most of the UI, based on switching the fragements
- *
- * */
-public class MainActivity extends BaseActivity
-        implements SelectRecyclerViewAdapter.SelectListener,
-        ActivityHelper.DataChangedListener,
-        NoteEditDialog.NoteEditDialogListener,
-        View.OnLongClickListener,
-        SearchView.OnQueryTextListener,
-        SearchView.OnCloseListener {
-
-    private static final String TAG = MainActivity.class.getSimpleName();
-    private static final int REQUEST_IMAGE_CAPTURE = 1;
-//    private static final int PERMISSIONS_REQUEST_WRITE_EXTERNAL_STORAGE = 4711;
-
-    private static final int QUERY_CURRENT_ACTIVITY_STATS = 1;
-    private static final int QUERY_CURRENT_ACTIVITY_TOTAL = 2;
-
-    ActivityMainContentBinding binding;
-
-    private DetailViewModel viewModel;
-
-    private String mCurrentPhotoPath;
-
-    FlexboxLayoutManager layoutManager;
-    private SelectRecyclerViewAdapter selectAdapter;
-
-    private String filter = "";
-    private SearchView searchView;
-
-    private void setSearchMode(boolean searchMode){
-        if (searchMode) {
-            binding.headerArea.setVisibility(View.GONE);
-            binding.fabAttachPicture.hide();
-            getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE);
-        } else {
-            getWindow().setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN);
-            binding.headerArea.setVisibility(View.VISIBLE);
-            binding.fabAttachPicture.show();
-        }
-    }
-
-    private MainAsyncQueryHandler mQHandler;
-
-    @Override
-    public void onSaveInstanceState(Bundle outState) {
-        outState.putString("currentPhotoPath", mCurrentPhotoPath);
-
-        // call superclass to save any view hierarchy
-        super.onSaveInstanceState(outState);
-    }
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        binding = DataBindingUtil.setContentView(this, R.layout.activity_main_content);
-        setContent(binding.getRoot());
-//        initNavigation();
-
-        viewModel = new ViewModelProvider(this).get(DetailViewModel.class);
-        mQHandler = new MainAsyncQueryHandler(getApplicationContext().getContentResolver(), viewModel);
-
-        // recovering the instance state
-        if (savedInstanceState != null) {
-            mCurrentPhotoPath = savedInstanceState.getString("currentPhotoPath");
-        }
-
-        setupViewPager(binding.viewpager);
-        binding.tablayout.setupWithViewPager(binding.viewpager);
-
-        binding.row.background.setOnLongClickListener(this);
-        binding.row.background.setOnClickListener(v -> {
-            if (PreferenceManager
-                    .getDefaultSharedPreferences(getApplicationContext())
-                    .getBoolean(SettingsActivity.KEY_PREF_DISABLE_CURRENT, true)) {
-                ActivityHelper.helper.setCurrentActivity(null);
-            } else {
-                Intent i = new Intent(MainActivity.this, EventDetailActivity.class);
-                // no diaryEntryID will edit the last one
-                startActivity(i);
-            }
-        });
-
-        TypedValue value = new TypedValue();
-        getTheme().resolveAttribute(android.R.attr.listPreferredItemHeightSmall, value, true);
-
-        layoutManager = new FlexboxLayoutManager(this);
-        layoutManager.setFlexDirection(FlexDirection.ROW);
-        layoutManager.setJustifyContent(JustifyContent.FLEX_START);
-        binding.selectRecycler.setLayoutManager(layoutManager);
-
-        Objects.requireNonNull(Objects.requireNonNull(getSupportActionBar())).setSubtitle(getResources().getString(R.string.activity_subtitle_main));
-
-        likelyhoodSort();
-
-        binding.fabAttachPicture.setOnClickListener(v -> {
-            // Handle the click on the FAB
-            if(viewModel.currentActivity() != null && viewModel.currentActivity().getValue() != null) {
-                Intent takePictureIntent = new Intent(MediaStore.ACTION_IMAGE_CAPTURE);
-
-                if (takePictureIntent.resolveActivity(getPackageManager()) != null) {
-                    File photoFile = GraphicsHelper.createImageFile();
-                    Log.i(TAG, "create file for image capture " + photoFile.getAbsolutePath());
-
-                    // Continue only if the File was successfully created
-                    // Save a file: path for use with ACTION_VIEW intents
-                    mCurrentPhotoPath = photoFile.getAbsolutePath();
-
-                    Uri photoURI = FileProvider.getUriForFile(MainActivity.this,
-                            BuildConfig.APPLICATION_ID + ".fileprovider",
-                            photoFile);
-                    takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI);
-                    takePictureIntent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION);
-                    startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE);
-                }
-            } else
-                Toast.makeText(MainActivity.this, getResources().getString(R.string.no_active_activity_error), Toast.LENGTH_LONG).show();
-        });
-
-        PackageManager pm = getPackageManager();
-
-        if (pm.hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY))
-            binding.fabAttachPicture.show();
-        else
-            binding.fabAttachPicture.hide();
-
-        // Get the intent, verify the action and get the search query
-        Intent intent = getIntent();
-        if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
-            String query = intent.getStringExtra(SearchManager.QUERY);
-            filterActivityView(query);
-        }
-        // TODO: this is crazy to call onActivityChagned here,
-        //  as it reloads the statistics and refills the viewModel...
-        //  Completely against the idea of the viewmodel :-(
-        onActivityChanged(); /* do this at the very end to ensure that no Loader finishes its data loading before */
-    }
-
-    @Override
-    public void onResume() {
-        mNavigationView.getMenu().findItem(R.id.nav_main).setChecked(true);
-        ActivityHelper.helper.registerDataChangeListener(this);
-        onActivityChanged(); /* refresh the current activity data */
-        super.onResume();
-
-        selectAdapter.notifyDataSetChanged(); // redraw the complete recyclerview
-        ActivityHelper.helper.evaluateAllConditions(); // this is quite heavy and I am not so sure whether it is a good idea to do it unconditionally here...
-    }
-
-    @Override
-    public void onPause() {
-        ActivityHelper.helper.unregisterDataChangeListener(this);
-
-        super.onPause();
-    }
-
-    @Override
-    public boolean onLongClick(View view) {
-        if(viewModel.currentActivity().getValue() != null) {
-            Intent i = new Intent(MainActivity.this, EditActivity.class);
-            i.putExtra("activityID", Objects.requireNonNull(Objects.requireNonNull(viewModel.currentActivity().getValue())).getId());
-            startActivity(i);
-        }
-        return true;
-    }
-
-    @Override
-    public boolean onItemLongClick(int adapterPosition){
-        Intent i = new Intent(MainActivity.this, EditActivity.class);
-        i.putExtra("activityID", selectAdapter.item(adapterPosition).getId());
-        startActivity(i);
-        return true;
-    }
-
-    @Override
-    public void onItemClick(int adapterPosition) {
-        DiaryActivity newAct = selectAdapter.item(adapterPosition);
-        if(newAct != ActivityHelper.helper.getCurrentActivity()) {
-            ActivityHelper.helper.setCurrentActivity(newAct);
-
-            searchView.setQuery("", false);
-            searchView.setIconified(true);
-        }
-    }
-
-    public void onActivityChanged(){
-        DiaryActivity newAct = ActivityHelper.helper.getCurrentActivity();
-        viewModel.mCurrentActivity.setValue(newAct);
-
-        if(newAct != null) queryAllTotals();
-
-        viewModel.setCurrentDiaryUri(ActivityHelper.helper.getCurrentDiaryUri());
-        // TODO: move this logic into the DetailViewModel??
-//        viewModel.mAvgDuration.setValue("-");
-//        viewModel.mStartOfLast.setValue("-");
-//        viewModel.mTotalToday.setValue("-");
-        /* stats are updated after query finishes in mQHelper */
-
-        if(viewModel.currentActivity().getValue() != null) {
-            binding.row.name.setText(Objects.requireNonNull(Objects.requireNonNull(viewModel.currentActivity().getValue())).getName());
-            binding.row.background.setBackgroundColor(Objects.requireNonNull(Objects.requireNonNull(viewModel.currentActivity().getValue())).getColor());
-            binding.row.name.setTextColor(GraphicsHelper.textColorOnBackground(Objects.requireNonNull(Objects.requireNonNull(viewModel.currentActivity().getValue())).getColor()));
-            viewModel.mNote.setValue(ActivityHelper.helper.getCurrentNote());
-        }else{
-            int col = ContextCompat.getColor(getApplicationContext(), R.color.colorPrimary);
-            binding.row.name.setText(getResources().getString(R.string.activity_title_no_selected_act));
-            binding.row.background.setBackgroundColor(col);
-            binding.row.name.setTextColor(GraphicsHelper.textColorOnBackground(col));
-            viewModel.mDuration.setValue("-");
-            viewModel.mNote.setValue("");
-        }
-        layoutManager.scrollToPosition(0);
-    }
-
-    public void queryAllTotals() {
-        // TODO: move this into the DetailStatFragement
-        DiaryActivity a = viewModel.mCurrentActivity.getValue();
-        if(a != null) {
-            int id = a.getId();
-
-//            TODO: need better display format
-            long end = System.currentTimeMillis();
-            long oneDayAgo = end - DateHelper.DAY_IN_MS ;
-            queryTotal(Calendar.DAY_OF_YEAR, oneDayAgo, end, id);
-//            queryTotal(DateHelper.FULLDAY, oneDayAgo, end, id);
-            long sevenDaysAgo = end - (7 * DateHelper.DAY_IN_MS);
-            queryTotal(Calendar.WEEK_OF_YEAR, sevenDaysAgo, end, id);
-            long thirtyDaysAgo = end - (30 * DateHelper.DAY_IN_MS);
-            queryTotal(Calendar.MONTH, thirtyDaysAgo, end, id);
-//            queryTotal(Calendar.WEEK_OF_YEAR, end, id);
-//            queryTotal(Calendar.MONTH, end, id);
-        }
-    }
-
-    private void queryTotal(int field, long start, long end, int actID) {
-        Uri u = Contract.DiaryStats.CONTENT_URI;
-        u = Uri.withAppendedPath(u, Long.toString(start));
-        u = Uri.withAppendedPath(u, Long.toString(end));
-
-        mQHandler.startQuery(QUERY_CURRENT_ACTIVITY_TOTAL, new StatParam(field, end),
-                u,
-                new String[] {
-                        Contract.DiaryStats.DURATION
-                },
-                Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivity._ID
-                        + " = ?",
-                new String[] {
-                        Integer.toString(actID)
-                },
-                null);
-    }
-
-    /**
-     * Called on change of the activity order due to likelyhood.
-     */
-    @Override
-    public void onActivityOrderChanged() {
-        /* only do likelihood sort in case we are not in a search */
-        if (filter.length() == 0) likelyhoodSort();
-    }
-
-    /**
-     * Called when the data has changed.
-     */
-    @Override
-    public void onActivityDataChanged() {
-        selectAdapter.notifyDataSetChanged();
-    }
-
-    @Override
-    public void onActivityDataChanged(DiaryActivity activity){
-        selectAdapter.notifyItemChanged(selectAdapter.positionOf(activity));
-    }
-
-    /**
-     * Called on addition of an activity.
-     *
-     */
-    @Override
-    public void onActivityAdded(DiaryActivity activity) {
-        /* no need to add it, as due to the reevaluation of the conditions the order change will happen */
-    }
-
-    /**
-     * Called on removale of an activity.
-     */
-    @Override
-    public void onActivityRemoved(DiaryActivity activity) {
-        selectAdapter.notifyDataSetChanged();
-    }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        MenuInflater inflater = getMenuInflater();
-        inflater.inflate(R.menu.main_menu, menu);
-
-        // Get the SearchView and set the searchable configuration
-        SearchManager searchManager = (SearchManager) getSystemService(Context.SEARCH_SERVICE);
-        MenuItem searchMenuItem = menu.findItem(R.id.action_filter);
-        searchView = (SearchView) searchMenuItem.getActionView();
-        // Assumes current activity is the searchable activity
-        searchView.setSearchableInfo(searchManager.getSearchableInfo(getComponentName()));
-
-        searchView.setOnCloseListener(this);
-        searchView.setOnQueryTextListener(this);
-        // setOnSuggestionListener -> for selection of a suggestion
-        // setSuggestionsAdapter
-        searchView.setOnSearchClickListener(v -> setSearchMode(true));
-        return true;
-    }
-
-    @Override
-    public boolean onOptionsItemSelected(MenuItem item) {
-        if (item.getItemId() == R.id.action_add_activity) {
-            startActivity(new Intent(this, EditActivity.class));
-        }
-        return super.onOptionsItemSelected(item);
-    }
-
-    @Override
-    protected void onNewIntent(Intent intent) {
-        super.onNewIntent(intent);
-        if (Intent.ACTION_SEARCH.equals(intent.getAction())) {
-            String query = intent.getStringExtra(SearchManager.QUERY);
-            filterActivityView(query);
-        }
-
-        if (intent.hasExtra("SELECT_ACTIVITY_WITH_ID")) {
-            int id = intent.getIntExtra("SELECT_ACTIVITY_WITH_ID", -1);
-            ActivityHelper.helper.setCurrentActivity(ActivityHelper.helper.activityWithId(id));
-        }
-    }
-
-    private void filterActivityView(String query){
-        this.filter = query;
-        if(filter.length() == 0) {
-            likelyhoodSort();
-        } else {
-            ArrayList<DiaryActivity> filtered = ActivityHelper.sortedActivities(query);
-//
-            selectAdapter = new SelectRecyclerViewAdapter(MainActivity.this, filtered);
-            binding.selectRecycler.swapAdapter(selectAdapter, false);
-            binding.selectRecycler.scrollToPosition(0);
-        }
-    }
-
-    private void likelyhoodSort() {
-        if (selectAdapter == null || selectAdapter != binding.selectRecycler.getAdapter()) {
-            selectAdapter = new SelectRecyclerViewAdapter(MainActivity.this, ActivityHelper.helper.getActivities());
-            binding.selectRecycler.swapAdapter(selectAdapter, false);
-        } else {
-            selectAdapter.setActivities(ActivityHelper.helper.getActivities());
-        }
-    }
-
-    @Override
-    public boolean onClose() {
-        setSearchMode(false);
-        likelyhoodSort();
-        return false; /* we wanna clear and close the search */
-    }
-
-    @Override
-    public boolean onQueryTextSubmit(String query) {
-        setSearchMode(false);
-        return false;
-    }
-
-    @Override
-    public boolean onQueryTextChange(String newText) {
-        filterActivityView(newText);
-        return true; /* we handle the search directly, so no suggestions need to be show even if #70 is implemented */
-    }
-
-    @Override
-    public void onNoteEditPositiveClick(String str, DialogFragment dialog) {
-        ContentValues values = new ContentValues();
-        values.put(Contract.Diary.NOTE, str);
-
-        mQHandler.startUpdate(0,
-                null,
-                viewModel.getCurrentDiaryUri(),
-                values,
-                null, null);
-
-        viewModel.mNote.postValue(str);
-        ActivityHelper.helper.setCurrentNote(str);
-    }
-
-    @Override
-    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-        super.onActivityResult(requestCode, resultCode, data);
-        if (requestCode == REQUEST_IMAGE_CAPTURE && resultCode == RESULT_OK) {
-            if(mCurrentPhotoPath != null && viewModel.getCurrentDiaryUri() != null) {
-                GraphicsHelper.compressAndSaveImage(mCurrentPhotoPath);
-
-                Uri photoURI = FileProvider.getUriForFile(MainActivity.this,
-                        BuildConfig.APPLICATION_ID + ".fileprovider",
-                        new File(mCurrentPhotoPath));
-                ContentValues values = new ContentValues();
-                values.put(Contract.DiaryImage.URI, photoURI.toString());
-                values.put(Contract.DiaryImage.DIARY_ID, viewModel.getCurrentDiaryUri().getLastPathSegment());
-
-                mQHandler.startInsert(0,
-                        null,
-                        Contract.DiaryImage.CONTENT_URI,
-                        values);
-            }
-        }
-    }
-
-    private void setupViewPager(ViewPager viewPager) {
-        ViewPagerAdapter adapter = new ViewPagerAdapter(getSupportFragmentManager());
-        adapter.addFragment(new DetailStatFragement(), getResources().getString(R.string.fragment_detail_stats_title));
-        adapter.addFragment(new DetailNoteFragment(), getResources().getString(R.string.fragment_detail_note_title));
-        adapter.addFragment(new DetailPictureFragement(), getResources().getString(R.string.fragment_detail_pictures_title));
-        viewPager.setAdapter(adapter);
-    }
-
-    static class ViewPagerAdapter extends FragmentPagerAdapter {
-        private final List<Fragment> mFragmentList = new ArrayList<>(50);
-        private final List<String> mFragmentTitleList = new ArrayList<>(50);
-
-        public ViewPagerAdapter(FragmentManager manager) {
-            super(manager);
-        }
-
-        @NonNull
-        @Override
-        public Fragment getItem(int position) {
-            return mFragmentList.get(position);
-        }
-
-        @Override
-        public int getCount() {
-            return mFragmentList.size();
-        }
-
-        public void addFragment(Fragment fragment, String title) {
-            mFragmentList.add(fragment);
-            mFragmentTitleList.add(title);
-        }
-
-        @Override
-        public CharSequence getPageTitle(int position) {
-            return mFragmentTitleList.get(position);
-        }
-    }
-
-    private static class MainAsyncQueryHandler extends AsyncQueryHandler{
-        final DetailViewModel viewModel;
-
-        public MainAsyncQueryHandler(ContentResolver cr, DetailViewModel viewModel) {
-            super(cr);
-            this.viewModel = viewModel;
-        }
-
-        @Override
-        public void startQuery(int token, Object cookie, Uri uri, String[] projection, String selection, String[] selectionArgs, String orderBy) {
-            super.startQuery(token, cookie, uri, projection, selection, selectionArgs, orderBy);
-        }
-
-        @Override
-        protected void onQueryComplete(int token, Object cookie, Cursor cursor) {
-            super.onQueryComplete(token, cookie, cursor);
-            if ((cursor != null) && cursor.moveToFirst()) {
-                if (token == QUERY_CURRENT_ACTIVITY_STATS) {
-//                    long avg = cursor.getLong(cursor.getColumnIndex(Contract.DiaryActivity.X_AVG_DURATION));
-//                    viewModel.mAvgDuration.setValue(getResources().
-//                            getString(R.string.avg_duration_description, TimeSpanFormatter.format(avg)));
-
-//                    SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
-//                    String formatString = sharedPref.getString(SettingsActivity.KEY_PREF_DATETIME_FORMAT,
-//                            getResources().getString(R.string.default_datetime_format));
-//
-//                    long start = cursor.getLong(cursor.getColumnIndex(Contract.DiaryActivity.X_START_OF_LAST));
-//
-//                    viewModel.mStartOfLast.setValue(getResources().
-//                            getString(R.string.last_done_description, DateFormat.format(formatString, start)));
-
-                }
-                else if(token == QUERY_CURRENT_ACTIVITY_TOTAL) {
-                    StatParam p = (StatParam)cookie;
-                    @SuppressLint("Range") long total = cursor.getLong(cursor.getColumnIndex(Contract.DiaryStats.DURATION));
-
-                    String x = DateHelper.dateFormat(p.field).format(p.end);
-                    x = x + ": " + TimeSpanFormatter.format(total);
-                    switch(p.field){
-                        case Calendar.DAY_OF_YEAR:
-                            viewModel.mTotalToday.setValue(x);
-                            break;
-                        case Calendar.WEEK_OF_YEAR:
-                            viewModel.mTotalWeek.setValue(x);
-                            break;
-                        case Calendar.MONTH:
-                            viewModel.mTotalMonth.setValue(x);
-                            break;
-                        default:
-                            break;
-                    }
-                }
-            }
-
-            if (cursor != null) cursor.close();
-        }
-    }
-
-    private static class StatParam {
-        public final int field;
-        public final long end;
-        public StatParam(int field, long end) {
-            this.field = field;
-            this.end = end;
-        }
-    }
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/main/MainActivity.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/main/MainActivity.kt
new file mode 100755
index 0000000..e805ac9
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/main/MainActivity.kt
@@ -0,0 +1,519 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.ui.main
+
+import android.annotation.SuppressLint
+import android.app.SearchManager
+import android.content.AsyncQueryHandler
+import android.content.ContentResolver
+import android.content.ContentValues
+import android.content.Intent
+import android.content.pm.PackageManager
+import android.database.Cursor
+import android.net.Uri
+import android.os.Bundle
+import android.provider.MediaStore
+import android.util.Log
+import android.util.TypedValue
+import android.view.*
+import android.view.View.OnLongClickListener
+import android.widget.Toast
+import androidx.appcompat.widget.SearchView
+import androidx.core.content.ContextCompat
+import androidx.core.content.FileProvider
+import androidx.databinding.DataBindingUtil
+import androidx.fragment.app.DialogFragment
+import androidx.fragment.app.Fragment
+import androidx.fragment.app.FragmentManager
+import androidx.fragment.app.FragmentPagerAdapter
+import androidx.lifecycle.ViewModelProvider
+import androidx.preference.PreferenceManager
+import androidx.viewpager.widget.ViewPager
+import com.google.android.flexbox.FlexDirection
+import com.google.android.flexbox.FlexboxLayoutManager
+import com.google.android.flexbox.JustifyContent
+import com.mdiqentw.lifedots.BuildConfig
+import com.mdiqentw.lifedots.R
+import com.mdiqentw.lifedots.databinding.ActivityMainContentBinding
+import com.mdiqentw.lifedots.db.Contract
+import com.mdiqentw.lifedots.helpers.ActivityHelper
+import com.mdiqentw.lifedots.helpers.ActivityHelper.DataChangedListener
+import com.mdiqentw.lifedots.helpers.DateHelper
+import com.mdiqentw.lifedots.helpers.DateHelper.dateFormat
+import com.mdiqentw.lifedots.helpers.GraphicsHelper.compressAndSaveImage
+import com.mdiqentw.lifedots.helpers.GraphicsHelper.createImageFile
+import com.mdiqentw.lifedots.helpers.GraphicsHelper.textColorOnBackground
+import com.mdiqentw.lifedots.helpers.TimeSpanFormatter.format
+import com.mdiqentw.lifedots.model.DetailViewModel
+import com.mdiqentw.lifedots.model.DiaryActivity
+import com.mdiqentw.lifedots.ui.generic.BaseActivity
+import com.mdiqentw.lifedots.ui.generic.EditActivity
+import com.mdiqentw.lifedots.ui.history.EventDetailActivity
+import com.mdiqentw.lifedots.ui.main.NoteEditDialog.NoteEditDialogListener
+import com.mdiqentw.lifedots.ui.settings.SettingsActivity
+import java.io.File
+import java.util.*
+
+/*
+ * MainActivity to show most of the UI, based on switching the fragements
+ *
+ * */
+class MainActivity : BaseActivity(), SelectRecyclerViewAdapter.SelectListener, DataChangedListener,
+    NoteEditDialogListener, OnLongClickListener, SearchView.OnQueryTextListener, SearchView.OnCloseListener {
+    lateinit var binding: ActivityMainContentBinding
+    private var viewModel: DetailViewModel? = null
+    private var mCurrentPhotoPath: String? = null
+    var layoutManager: FlexboxLayoutManager? = null
+    private var selectAdapter: SelectRecyclerViewAdapter? = null
+    private var filter: String? = ""
+    private var searchView: SearchView? = null
+    private fun setSearchMode(searchMode: Boolean) {
+        if (searchMode) {
+            binding.headerArea.visibility = View.GONE
+            binding.fabAttachPicture.hide()
+            window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_RESIZE)
+        } else {
+            window.setSoftInputMode(WindowManager.LayoutParams.SOFT_INPUT_ADJUST_PAN)
+            binding.headerArea.visibility = View.VISIBLE
+            binding.fabAttachPicture.show()
+        }
+    }
+
+    private var mQHandler: MainAsyncQueryHandler? = null
+    public override fun onSaveInstanceState(outState: Bundle) {
+        outState.putString("currentPhotoPath", mCurrentPhotoPath)
+
+        // call superclass to save any view hierarchy
+        super.onSaveInstanceState(outState)
+    }
+
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        binding = DataBindingUtil.setContentView(this, R.layout.activity_main_content)
+        setContent(binding.root)
+        //        initNavigation();
+        viewModel = ViewModelProvider(this)[DetailViewModel::class.java]
+        mQHandler = MainAsyncQueryHandler(applicationContext.contentResolver, viewModel)
+
+        // recovering the instance state
+        if (savedInstanceState != null) {
+            mCurrentPhotoPath = savedInstanceState.getString("currentPhotoPath")
+        }
+        setupViewPager(binding.viewpager)
+        binding.tablayout.setupWithViewPager(binding.viewpager)
+        binding.row.background.setOnLongClickListener(this)
+        binding.row.background.setOnClickListener { _: View? ->
+            if (PreferenceManager
+                    .getDefaultSharedPreferences(applicationContext)
+                    .getBoolean(SettingsActivity.KEY_PREF_DISABLE_CURRENT, true)
+            ) {
+                ActivityHelper.helper.currentActivity = null
+            } else {
+                val i = Intent(this@MainActivity, EventDetailActivity::class.java)
+                // no diaryEntryID will edit the last one
+                startActivity(i)
+            }
+        }
+        val value = TypedValue()
+        theme.resolveAttribute(android.R.attr.listPreferredItemHeightSmall, value, true)
+        layoutManager = FlexboxLayoutManager(this)
+        layoutManager!!.flexDirection = FlexDirection.ROW
+        layoutManager!!.justifyContent = JustifyContent.FLEX_START
+        binding.selectRecycler.layoutManager = layoutManager
+        supportActionBar!!.subtitle = resources.getString(R.string.activity_subtitle_main)
+        likelyhoodSort()
+        binding.fabAttachPicture.setOnClickListener { _: View? ->
+            // Handle the click on the FAB
+            if (viewModel!!.currentActivity() != null && viewModel!!.currentActivity().value != null) {
+                val takePictureIntent = Intent(MediaStore.ACTION_IMAGE_CAPTURE)
+                if (takePictureIntent.resolveActivity(packageManager) != null) {
+                    val photoFile = createImageFile()
+                    Log.i(TAG, "create file for image capture " + photoFile.absolutePath)
+
+                    // Continue only if the File was successfully created
+                    // Save a file: path for use with ACTION_VIEW intents
+                    mCurrentPhotoPath = photoFile.absolutePath
+                    val photoURI = FileProvider.getUriForFile(
+                        this@MainActivity,
+                        BuildConfig.APPLICATION_ID + ".fileprovider",
+                        photoFile
+                    )
+                    takePictureIntent.putExtra(MediaStore.EXTRA_OUTPUT, photoURI)
+                    takePictureIntent.addFlags(Intent.FLAG_GRANT_WRITE_URI_PERMISSION)
+                    startActivityForResult(takePictureIntent, REQUEST_IMAGE_CAPTURE)
+                }
+            } else Toast.makeText(
+                this@MainActivity,
+                resources.getString(R.string.no_active_activity_error),
+                Toast.LENGTH_LONG
+            ).show()
+        }
+        val pm = packageManager
+        if (pm.hasSystemFeature(PackageManager.FEATURE_CAMERA_ANY)) binding.fabAttachPicture.show() else binding.fabAttachPicture.hide()
+
+        // Get the intent, verify the action and get the search query
+        val intent = intent
+        if (Intent.ACTION_SEARCH == intent.action) {
+            val query = intent.getStringExtra(SearchManager.QUERY)
+            filterActivityView(query)
+        }
+        // TODO: this is crazy to call onActivityChagned here,
+        //  as it reloads the statistics and refills the viewModel...
+        //  Completely against the idea of the viewmodel :-(
+        onActivityChanged() /* do this at the very end to ensure that no Loader finishes its data loading before */
+    }
+
+    public override fun onResume() {
+        mNavigationView.menu.findItem(R.id.nav_main).isChecked = true
+        ActivityHelper.helper.registerDataChangeListener(this)
+        onActivityChanged() /* refresh the current activity data */
+        super.onResume()
+        selectAdapter!!.notifyDataSetChanged() // redraw the complete recyclerview
+        ActivityHelper.helper.evaluateAllConditions() // this is quite heavy and I am not so sure whether it is a good idea to do it unconditionally here...
+    }
+
+    public override fun onPause() {
+        ActivityHelper.helper.unregisterDataChangeListener(this)
+        super.onPause()
+    }
+
+    override fun onLongClick(view: View): Boolean {
+        if (viewModel!!.currentActivity().value != null) {
+            val i = Intent(this@MainActivity, EditActivity::class.java)
+            i.putExtra("activityID", viewModel!!.currentActivity().value!!.mId)
+            startActivity(i)
+        }
+        return true
+    }
+
+    override fun onItemLongClick(adapterPosition: Int): Boolean {
+        val i = Intent(this@MainActivity, EditActivity::class.java)
+        i.putExtra("activityID", selectAdapter!!.item(adapterPosition).mId)
+        startActivity(i)
+        return true
+    }
+
+    override fun onItemClick(adapterPosition: Int) {
+        val newAct = selectAdapter!!.item(adapterPosition)
+        if (newAct !== ActivityHelper.helper.currentActivity) {
+            ActivityHelper.helper.currentActivity = newAct
+            searchView!!.setQuery("", false)
+            searchView!!.isIconified = true
+        }
+    }
+
+    override fun onActivityChanged() {
+        val newAct = ActivityHelper.helper.currentActivity
+        viewModel!!.mCurrentActivity.value = newAct
+        if (newAct != null) queryAllTotals()
+        viewModel!!.currentDiaryUri = ActivityHelper.helper.currentDiaryUri
+        // TODO: move this logic into the DetailViewModel??
+//        viewModel.mAvgDuration.setValue("-");
+//        viewModel.mStartOfLast.setValue("-");
+//        viewModel.mTotalToday.setValue("-");
+        /* stats are updated after query finishes in mQHelper */
+        if (viewModel!!.currentActivity().value != null) {
+            binding.row.name.text = viewModel!!.currentActivity().value!!.mName
+            binding.row.background.setBackgroundColor(viewModel!!.currentActivity().value!!.mColor)
+            binding.row.name.setTextColor(
+                textColorOnBackground(viewModel!!.currentActivity().value!!.mColor))
+            viewModel!!.mNote.setValue(ActivityHelper.helper.currentNote)
+        } else {
+            val col = ContextCompat.getColor(applicationContext, R.color.colorPrimary)
+            binding.row.name.text = resources.getString(R.string.activity_title_no_selected_act)
+            binding.row.background.setBackgroundColor(col)
+            binding.row.name.setTextColor(textColorOnBackground(col))
+            viewModel!!.mDuration.value = "-"
+            viewModel!!.mNote.setValue("")
+        }
+        layoutManager!!.scrollToPosition(0)
+    }
+
+    fun queryAllTotals() {
+        // TODO: move this into the DetailStatFragement
+        val a = viewModel!!.mCurrentActivity.value
+        if (a != null) {
+            val id = a.mId
+
+//            TODO: need better display format
+            val end = System.currentTimeMillis()
+            val oneDayAgo = end - DateHelper.DAY_IN_MS
+            queryTotal(Calendar.DAY_OF_YEAR, oneDayAgo, end, id)
+            //            queryTotal(DateHelper.FULLDAY, oneDayAgo, end, id);
+            val sevenDaysAgo = end - 7 * DateHelper.DAY_IN_MS
+            queryTotal(Calendar.WEEK_OF_YEAR, sevenDaysAgo, end, id)
+            val thirtyDaysAgo = end - 30 * DateHelper.DAY_IN_MS
+            queryTotal(Calendar.MONTH, thirtyDaysAgo, end, id)
+            //            queryTotal(Calendar.WEEK_OF_YEAR, end, id);
+//            queryTotal(Calendar.MONTH, end, id);
+        }
+    }
+
+    private fun queryTotal(field: Int, start: Long, end: Long, actID: Int) {
+        var u = Contract.DiaryStats.CONTENT_URI
+        u = Uri.withAppendedPath(u, start.toString())
+        u = Uri.withAppendedPath(u, end.toString())
+        mQHandler!!.startQuery(
+            QUERY_CURRENT_ACTIVITY_TOTAL, StatParam(field, end),
+            u, arrayOf(Contract.DiaryStats.DURATION),
+            Contract.DiaryActivity.TABLE_NAME + "." + Contract.DiaryActivity._ID
+                    + " = ?", arrayOf(
+                actID.toString()
+            ), null
+        )
+    }
+
+    /**
+     * Called on change of the activity order due to likelyhood.
+     */
+    override fun onActivityOrderChanged() {
+        /* only do likelihood sort in case we are not in a search */
+        if (filter!!.isEmpty()) likelyhoodSort()
+    }
+
+    /**
+     * Called when the data has changed.
+     */
+    override fun onActivityDataChanged() {
+        selectAdapter!!.notifyDataSetChanged()
+    }
+
+    override fun onActivityDataChanged(activity: DiaryActivity) {
+        selectAdapter!!.notifyItemChanged(selectAdapter!!.positionOf(activity))
+    }
+
+    /**
+     * Called on addition of an activity.
+     *
+     */
+    override fun onActivityAdded(activity: DiaryActivity) {
+        /* no need to add it, as due to the reevaluation of the conditions the order change will happen */
+    }
+
+    /**
+     * Called on removale of an activity.
+     */
+    override fun onActivityRemoved(activity: DiaryActivity) {
+        selectAdapter!!.notifyDataSetChanged()
+    }
+
+    override fun onCreateOptionsMenu(menu: Menu): Boolean {
+        val inflater = menuInflater
+        inflater.inflate(R.menu.main_menu, menu)
+
+        // Get the SearchView and set the searchable configuration
+        val searchManager = getSystemService(SEARCH_SERVICE) as SearchManager
+        val searchMenuItem = menu.findItem(R.id.action_filter)
+        searchView = searchMenuItem.actionView as SearchView?
+        // Assumes current activity is the searchable activity
+        searchView!!.setSearchableInfo(searchManager.getSearchableInfo(componentName))
+        searchView!!.setOnCloseListener(this)
+        searchView!!.setOnQueryTextListener(this)
+        // setOnSuggestionListener -> for selection of a suggestion
+        // setSuggestionsAdapter
+        searchView!!.setOnSearchClickListener { _: View? -> setSearchMode(true) }
+        return true
+    }
+
+    override fun onOptionsItemSelected(item: MenuItem): Boolean {
+        if (item.itemId == R.id.action_add_activity) {
+            startActivity(Intent(this, EditActivity::class.java))
+        }
+        return super.onOptionsItemSelected(item)
+    }
+
+    override fun onNewIntent(intent: Intent) {
+        super.onNewIntent(intent)
+        if (Intent.ACTION_SEARCH == intent.action) {
+            val query = intent.getStringExtra(SearchManager.QUERY)
+            filterActivityView(query)
+        }
+        if (intent.hasExtra("SELECT_ACTIVITY_WITH_ID")) {
+            val id = intent.getIntExtra("SELECT_ACTIVITY_WITH_ID", -1)
+            ActivityHelper.helper.currentActivity = ActivityHelper.helper.activityWithId(id)
+        }
+    }
+
+    private fun filterActivityView(query: String?) {
+        filter = query
+        if (filter == null || filter!!.isEmpty()) {
+            likelyhoodSort()
+        } else {
+            val filtered = ActivityHelper.sortedActivities(query!!)
+            //
+            selectAdapter = SelectRecyclerViewAdapter(this@MainActivity, filtered)
+            binding.selectRecycler.swapAdapter(selectAdapter, false)
+            binding.selectRecycler.scrollToPosition(0)
+        }
+    }
+
+    private fun likelyhoodSort() {
+        if (selectAdapter == null || selectAdapter != binding.selectRecycler.adapter) {
+            selectAdapter = SelectRecyclerViewAdapter(this@MainActivity, ActivityHelper.helper.activities)
+            binding.selectRecycler.swapAdapter(selectAdapter, false)
+        } else {
+            selectAdapter!!.setActivities(ActivityHelper.helper.activities)
+        }
+    }
+
+    override fun onClose(): Boolean {
+        setSearchMode(false)
+        likelyhoodSort()
+        return false /* we wanna clear and close the search */
+    }
+
+    override fun onQueryTextSubmit(query: String): Boolean {
+        setSearchMode(false)
+        return false
+    }
+
+    override fun onQueryTextChange(newText: String): Boolean {
+        filterActivityView(newText)
+        return true /* we handle the search directly, so no suggestions need to be show even if #70 is implemented */
+    }
+
+    override fun onNoteEditPositiveClick(str: String?, dialog: DialogFragment?) {
+        val values = ContentValues()
+        values.put(Contract.Diary.NOTE, str)
+        mQHandler!!.startUpdate(
+            0,
+            null,
+            viewModel!!.currentDiaryUri,
+            values,
+            null, null
+        )
+        viewModel!!.mNote.postValue(str)
+        ActivityHelper.helper.currentNote = str
+    }
+
+    @Deprecated("Deprecated in Java")
+    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
+        super.onActivityResult(requestCode, resultCode, data)
+        if (requestCode == REQUEST_IMAGE_CAPTURE && resultCode == RESULT_OK) {
+            if (mCurrentPhotoPath != null && viewModel!!.currentDiaryUri != null) {
+                compressAndSaveImage(mCurrentPhotoPath!!)
+                val photoURI = FileProvider.getUriForFile(
+                    this@MainActivity,
+                    BuildConfig.APPLICATION_ID + ".fileprovider",
+                    File(mCurrentPhotoPath!!)
+                )
+                val values = ContentValues()
+                values.put(Contract.DiaryImage.URI, photoURI.toString())
+                values.put(Contract.DiaryImage.DIARY_ID, viewModel!!.currentDiaryUri!!.lastPathSegment)
+                mQHandler!!.startInsert(
+                    0,
+                    null,
+                    Contract.DiaryImage.CONTENT_URI,
+                    values
+                )
+            }
+        }
+    }
+
+    private fun setupViewPager(viewPager: ViewPager) {
+        val adapter = ViewPagerAdapter(supportFragmentManager)
+        adapter.addFragment(DetailStatFragement(), resources.getString(R.string.fragment_detail_stats_title))
+        adapter.addFragment(DetailNoteFragment(), resources.getString(R.string.fragment_detail_note_title))
+        adapter.addFragment(DetailPictureFragement(), resources.getString(R.string.fragment_detail_pictures_title))
+        viewPager.adapter = adapter
+    }
+
+    internal class ViewPagerAdapter(manager: FragmentManager?) : FragmentPagerAdapter(
+        manager!!
+    ) {
+        private val mFragmentList: MutableList<Fragment> = ArrayList(50)
+        private val mFragmentTitleList: MutableList<String> = ArrayList(50)
+        override fun getItem(position: Int): Fragment {
+            return mFragmentList[position]
+        }
+
+        override fun getCount(): Int {
+            return mFragmentList.size
+        }
+
+        fun addFragment(fragment: Fragment, title: String) {
+            mFragmentList.add(fragment)
+            mFragmentTitleList.add(title)
+        }
+
+        override fun getPageTitle(position: Int): CharSequence {
+            return mFragmentTitleList[position]
+        }
+    }
+
+    private class MainAsyncQueryHandler(cr: ContentResolver?, val viewModel: DetailViewModel?) : AsyncQueryHandler(cr) {
+        override fun startQuery(
+            token: Int,
+            cookie: Any,
+            uri: Uri,
+            projection: Array<String>,
+            selection: String,
+            selectionArgs: Array<String>,
+            orderBy: String?
+        ) {
+            super.startQuery(token, cookie, uri, projection, selection, selectionArgs, orderBy)
+        }
+
+        override fun onQueryComplete(token: Int, cookie: Any?, cursor: Cursor) {
+            super.onQueryComplete(token, cookie, cursor)
+            if (cursor.moveToFirst()) {
+                if (token == QUERY_CURRENT_ACTIVITY_STATS) {
+//                    long avg = cursor.getLong(cursor.getColumnIndex(Contract.DiaryActivity.X_AVG_DURATION));
+//                    viewModel.mAvgDuration.setValue(getResources().
+//                            getString(R.string.avg_duration_description, TimeSpanFormatter.format(avg)));
+
+//                    SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(getApplicationContext());
+//                    String formatString = sharedPref.getString(SettingsActivity.KEY_PREF_DATETIME_FORMAT,
+//                            getResources().getString(R.string.default_datetime_format));
+//
+//                    long start = cursor.getLong(cursor.getColumnIndex(Contract.DiaryActivity.X_START_OF_LAST));
+//
+//                    viewModel.mStartOfLast.setValue(getResources().
+//                            getString(R.string.last_done_description, DateFormat.format(formatString, start)));
+                } else if (token == QUERY_CURRENT_ACTIVITY_TOTAL) {
+                    if (cookie != null) {
+                        val p = cookie as StatParam
+                        @SuppressLint("Range") val total =
+                            cursor.getLong(cursor.getColumnIndex(Contract.DiaryStats.DURATION))
+                        var x = dateFormat(p.field).format(p.end)
+                        x = x + ": " + format(total)
+                        when (p.field) {
+                            Calendar.DAY_OF_YEAR -> viewModel!!.mTotalToday.setValue(x)
+                            Calendar.WEEK_OF_YEAR -> viewModel!!.mTotalWeek.setValue(x)
+                            Calendar.MONTH -> viewModel!!.mTotalMonth.setValue(x)
+                            else -> {}
+                        }
+                    }
+                }
+            }
+            cursor.close()
+        }
+    }
+
+    private class StatParam(val field: Int, val end: Long)
+    companion object {
+        private val TAG = MainActivity::class.java.simpleName
+        private const val REQUEST_IMAGE_CAPTURE = 1
+
+        //    private static final int PERMISSIONS_REQUEST_WRITE_EXTERNAL_STORAGE = 4711;
+        private const val QUERY_CURRENT_ACTIVITY_STATS = 1
+        private const val QUERY_CURRENT_ACTIVITY_TOTAL = 2
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/main/NoteEditDialog.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/main/NoteEditDialog.kt
old mode 100644
new mode 100755
index 9605219..89a1808
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/main/NoteEditDialog.kt
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/main/NoteEditDialog.kt
@@ -2,6 +2,7 @@
  * LifeDots
  *
  * Copyright (C) 2017 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -30,25 +31,6 @@ import androidx.appcompat.app.AlertDialog
 import androidx.fragment.app.DialogFragment
 import com.mdiqentw.lifedots.R
 
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
 class NoteEditDialog : DialogFragment() {
 
     private var note: String? = null
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/main/SelectRecyclerViewAdapter.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/main/SelectRecyclerViewAdapter.kt
old mode 100644
new mode 100755
index 35524cc..7327177
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/main/SelectRecyclerViewAdapter.kt
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/main/SelectRecyclerViewAdapter.kt
@@ -2,6 +2,7 @@
  * LifeDots
  *
  * Copyright (C) 2017 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -27,24 +28,6 @@ import com.mdiqentw.lifedots.databinding.SelectRecyclerItemBinding
 import com.mdiqentw.lifedots.helpers.GraphicsHelper
 import com.mdiqentw.lifedots.model.DiaryActivity
 
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
 class SelectRecyclerViewAdapter(private val mSelectListener: SelectListener, private var mActivityList: List<DiaryActivity>) : RecyclerView.Adapter<SelectViewHolders>() {
     override fun onCreateViewHolder(parent: ViewGroup, viewType: Int): SelectViewHolders {
         val binding: SelectRecyclerItemBinding = DataBindingUtil.inflate(
@@ -58,13 +41,13 @@ class SelectRecyclerViewAdapter(private val mSelectListener: SelectListener, pri
     override fun onBindViewHolder(holder: SelectViewHolders, position: Int) {
         val act = mActivityList[position]
 //        val formatter: NumberFormat = DecimalFormat("#0.00")
-        holder.mName.text = act.name
+        holder.mName.text = act.mName
 
         // show likelyhood in activity name
         //     holder.mName.setText(act.getName() + " (" + formatter.format(ActivityHelper.helper.likelihoodFor(act)) + ")");
         // TODO #33:        holder.mSymbol.setImageResource(act.getPhoto());
-        holder.mBackground.setBackgroundColor(act.color)
-        holder.mName.setTextColor(GraphicsHelper.textColorOnBackground(act.color))
+        holder.mBackground.setBackgroundColor(act.mColor)
+        holder.mName.setTextColor(GraphicsHelper.textColorOnBackground(act.mColor))
 
         // TODO #31: set the width based on the likelyhood
     }
@@ -84,7 +67,7 @@ class SelectRecyclerViewAdapter(private val mSelectListener: SelectListener, pri
     }
 
     override fun getItemId(position: Int): Long {
-        return mActivityList[position].id.toLong()
+        return mActivityList[position].mId.toLong()
     }
 
     fun positionOf(activity: DiaryActivity): Int {
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/main/SelectViewHolders.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/main/SelectViewHolders.kt
old mode 100644
new mode 100755
index aa9e615..7fdb5ea
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/main/SelectViewHolders.kt
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/main/SelectViewHolders.kt
@@ -2,6 +2,7 @@
  * LifeDots
  *
  * Copyright (C) 2017 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
  *
  * This program is free software: you can redistribute it and/or modify
  * it under the terms of the GNU General Public License as published by
@@ -25,24 +26,6 @@ import androidx.recyclerview.widget.RecyclerView
 import com.mdiqentw.lifedots.databinding.LifedotRowBinding
 import com.mdiqentw.lifedots.databinding.SelectRecyclerItemBinding
 
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
 class SelectViewHolders(listener: SelectRecyclerViewAdapter.SelectListener, bind: SelectRecyclerItemBinding) : RecyclerView.ViewHolder(bind.root), View.OnClickListener, OnLongClickListener {
     val binding: LifedotRowBinding
     @JvmField
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/settings/SettingsActivity.java b/app/src/main/java/com/mdiqentw/lifedots/ui/settings/SettingsActivity.java
deleted file mode 100644
index 9986b7d..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/settings/SettingsActivity.java
+++ /dev/null
@@ -1,617 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots.ui.settings;
-
-
-import android.Manifest;
-import android.content.Context;
-import android.content.Intent;
-import android.content.SharedPreferences;
-import android.content.pm.PackageManager;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.net.Uri;
-import android.os.Build;
-import android.os.Bundle;
-import android.text.format.DateFormat;
-import android.util.Log;
-import android.widget.Toast;
-
-import androidx.annotation.NonNull;
-import androidx.core.app.ActivityCompat;
-import androidx.core.content.ContextCompat;
-import androidx.databinding.DataBindingUtil;
-import androidx.preference.EditTextPreference;
-import androidx.preference.ListPreference;
-import androidx.preference.Preference;
-import androidx.preference.PreferenceManager;
-
-import com.mdiqentw.lifedots.MVApplication;
-import com.mdiqentw.lifedots.R;
-import com.mdiqentw.lifedots.databinding.ActivitySettingsBinding;
-import com.mdiqentw.lifedots.db.LocalDBHelper;
-import com.mdiqentw.lifedots.db.Contract;
-import com.mdiqentw.lifedots.helpers.ActivityHelper;
-import com.mdiqentw.lifedots.helpers.LocationHelper;
-import com.mdiqentw.lifedots.ui.generic.BaseActivity;
-
-import org.jetbrains.annotations.NonNls;
-
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-public class SettingsActivity extends BaseActivity
-        implements SharedPreferences.OnSharedPreferenceChangeListener {
-    private static final String TAG = SettingsActivity.class.getName();
-
-    public static final String KEY_PREF_DATETIME_FORMAT = "pref_datetimeFormat";
-    public static final String KEY_PREF_AUTO_SELECT = "pref_auto_select_new";
-    public static final String KEY_PREF_DB_EXPORT = "pref_db_export";
-    public static final String KEY_PREF_DB_IMPORT = "pref_db_import";
-    public static final String KEY_PREF_COND_ALPHA = "pref_cond_alpha";
-    public static final String KEY_PREF_COND_PREDECESSOR = "pref_cond_predecessor";
-    public static final String KEY_PREF_COND_OCCURRENCE = "pref_cond_occurrence";
-    public static final String KEY_PREF_COND_RECENCY = "pref_cond_recency";
-//    public static final String KEY_PREF_NOTIF_SHOW_CUR_ACT = "pref_show_cur_activity_notification";
-//    public static final String KEY_PREF_SILENT_RENOTIFICATIONS = "pref_silent_renotification";
-    public static final String KEY_PREF_DISABLE_CURRENT = "pref_disable_current_on_click";
-    public static final String KEY_PREF_COND_DAYTIME = "pref_cond_daytime";
-    public static final String KEY_PREF_USE_LOCATION = "pref_use_location";
-    public static final String KEY_PREF_LOCATION_AGE = "pref_location_age";
-    public static final String KEY_PREF_LOCATION_DIST = "pref_location_dist";
-    public static final String KEY_PREF_PAUSED = "pref_cond_paused";
-    public static final String KEY_PREF_DURATION_FORMAT = "pref_duration_format";
-
-    public static final int ACTIVITIY_RESULT_EXPORT = 17;
-    public static final int ACTIVITIY_RESULT_IMPORT = 18;
-
-    static LocalDBHelper mOpenHelper = new LocalDBHelper(MVApplication.getAppContext());
-
-    private Preference dateformatPref;
-    private ListPreference durationFormatPref;
-    private Preference autoSelectPref;
-//    private Preference storageFolderPref;
-//    private Preference tagImagesPref;
-    private Preference condAlphaPref;
-    private Preference condOccurrencePref;
-    private Preference condRecencyPref;
-//    private Preference nofifShowCurActPref;
-//    private Preference silentRenotifPref;
-    private Preference disableOnClickPref;
-    private ListPreference useLocationPref;
-    private EditTextPreference locationAgePref;
-    private EditTextPreference locationDistPref;
-
-    private PreferenceManager mPreferenceManager;
-
-    public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,
-                                          String key) {
-        switch (key) {
-            case KEY_PREF_DATETIME_FORMAT:
-                String def = getResources().getString(R.string.default_datetime_format);
-                // Set summary to be the user-description for the selected value
-                dateformatPref.setSummary(DateFormat.format(sharedPreferences.getString(key, def), new Date()));
-                break;
-            case KEY_PREF_AUTO_SELECT:
-                updateAutoSelectSummary();
-                break;
-            case KEY_PREF_COND_ALPHA:
-                updateCondAlphaSummary();
-                break;
-            case KEY_PREF_COND_OCCURRENCE:
-                updateCondOccurenceSummary();
-                break;
-            case KEY_PREF_COND_RECENCY:
-                updateCondRecencySummary();
-                break;
-//            case KEY_PREF_NOTIF_SHOW_CUR_ACT:
-//                updateNotifShowCurActivity();
-//                break;
-//            case KEY_PREF_SILENT_RENOTIFICATIONS:
-//                updateSilentNotifications();
-//                break;
-            case KEY_PREF_DISABLE_CURRENT:
-                updateDisableCurrent();
-                break;
-            case KEY_PREF_USE_LOCATION:
-                updateUseLocation();
-                break;
-            case KEY_PREF_LOCATION_AGE:
-                updateLocationAge();
-                break;
-            case KEY_PREF_LOCATION_DIST:
-                updateLocationDist();
-                break;
-            case KEY_PREF_DURATION_FORMAT:
-                updateDurationFormat();
-                break;
-        }
-    }
-
-    private void updateDurationFormat() {
-
-        String value = PreferenceManager
-                .getDefaultSharedPreferences(getApplicationContext())
-                .getString(KEY_PREF_DURATION_FORMAT, "dynamic");
-
-        switch (value) {
-            case "dynamic":
-                durationFormatPref.setSummary(getResources().getString(R.string.setting_duration_format_summary_dynamic));
-                break;
-            case "nodays":
-                durationFormatPref.setSummary(getResources().getString(R.string.setting_duration_format_summary_nodays));
-                break;
-            case "precise":
-                durationFormatPref.setSummary(getResources().getString(R.string.setting_duration_format_summary_precise));
-                break;
-            case "hour_min":
-                durationFormatPref.setSummary(getResources().getString(R.string.setting_duration_format_summary_hour_min));
-                break;
-        }
-    }
-
-    private void updateUseLocation() {
-        int permissionCheckFine;
-        int permissionCheckCoarse;
-
-        @NonNls String value = PreferenceManager
-                .getDefaultSharedPreferences(getApplicationContext())
-                .getString(KEY_PREF_USE_LOCATION, "off");
-
-        if (value.equals("off")) {
-            locationAgePref.setEnabled(false);
-            locationDistPref.setEnabled(false);
-            useLocationPref.setSummary(getResources().getString(R.string.setting_use_location_off_summary));
-        } else {
-            locationAgePref.setEnabled(true);
-            locationDistPref.setEnabled(true);
-            useLocationPref.setSummary(getResources().getString(R.string.setting_use_location_summary, useLocationPref.getEntry()));
-        }
-
-        if (value.equals("gps")) {
-            permissionCheckFine = ContextCompat.checkSelfPermission(getApplicationContext(),
-                    Manifest.permission.ACCESS_FINE_LOCATION);
-            if (permissionCheckFine != PackageManager.PERMISSION_GRANTED) {
-                if (ActivityCompat.shouldShowRequestPermissionRationale(this,
-                        Manifest.permission.ACCESS_FINE_LOCATION))
-                    Toast.makeText(this, R.string.perm_location_xplain, Toast.LENGTH_LONG).show();
-
-                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
-                    ActivityCompat.requestPermissions(this,
-                            new String[]{Manifest.permission.ACCESS_BACKGROUND_LOCATION,
-                                    Manifest.permission.ACCESS_FINE_LOCATION},
-                            4711);
-                } else {
-                    ActivityCompat.requestPermissions(this,
-                            new String[]{Manifest.permission.ACCESS_FINE_LOCATION},
-                            4712);
-                }
-            }
-        } else if (value.equals("network")) {
-            permissionCheckCoarse = ContextCompat.checkSelfPermission(getApplicationContext(),
-                    Manifest.permission.ACCESS_COARSE_LOCATION);
-            if (permissionCheckCoarse != PackageManager.PERMISSION_GRANTED) {
-                if (ActivityCompat.shouldShowRequestPermissionRationale(this,
-                        Manifest.permission.ACCESS_COARSE_LOCATION))
-                    Toast.makeText(this, R.string.perm_location_xplain, Toast.LENGTH_LONG).show();
-
-                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
-                    ActivityCompat.requestPermissions(this,
-                            new String[]{Manifest.permission.ACCESS_BACKGROUND_LOCATION,
-                                    Manifest.permission.ACCESS_COARSE_LOCATION},
-                            4711);
-                } else {
-                    ActivityCompat.requestPermissions(this,
-                            new String[]{Manifest.permission.ACCESS_COARSE_LOCATION},
-                            4713);
-                }
-            }
-        }
-    }
-
-    @Override
-    public void onRequestPermissionsResult(int requestCode, @NonNull String[] permissions, @NonNull int[] grantResults) {
-        super.onRequestPermissionsResult(requestCode, permissions, grantResults);
-        if (requestCode == 4712 || requestCode == 4713) {
-            if (grantResults[0] == 0) {
-                LocationHelper.helper.updateLocation();
-            }
-        }
-    }
-
-    private void updateLocationDist() {
-        String def = getResources().getString(R.string.pref_location_dist_default);
-        @NonNls String value = PreferenceManager
-                .getDefaultSharedPreferences(getApplicationContext())
-                .getString(KEY_PREF_LOCATION_DIST, def);
-
-        int v = Integer.parseInt(value.replaceAll("\\D",""));
-        if (v < 5) {
-            v = 5;
-        }
-        String nvalue = Integer.toString(v);
-        if(!value.equals(nvalue)){
-            SharedPreferences.Editor editor = PreferenceManager
-                    .getDefaultSharedPreferences(getApplicationContext()).edit();
-            editor.putString(KEY_PREF_LOCATION_DIST, nvalue);
-            editor.apply();
-            value = PreferenceManager
-                    .getDefaultSharedPreferences(getApplicationContext())
-                    .getString(KEY_PREF_LOCATION_DIST, def);
-        }
-
-        locationDistPref.setSummary(getResources().getString(R.string.pref_location_dist, value));
-    }
-
-    private void updateLocationAge() {
-        String def = getResources().getString(R.string.pref_location_age_default);
-        @NonNls String value = PreferenceManager
-                .getDefaultSharedPreferences(getApplicationContext())
-                .getString(KEY_PREF_LOCATION_AGE, def);
-        int v = Integer.parseInt(value.replaceAll("\\D",""));
-        if (v < 2) {
-            v = 2;
-        } else if (v > 720){
-            v = 720;
-        }
-        String nvalue = Integer.toString(v);
-        if(!value.equals(nvalue)){
-            SharedPreferences.Editor editor = PreferenceManager
-                    .getDefaultSharedPreferences(getApplicationContext()).edit();
-            editor.putString(KEY_PREF_LOCATION_AGE, nvalue);
-            editor.apply();
-            value = PreferenceManager
-                    .getDefaultSharedPreferences(getApplicationContext())
-                    .getString(KEY_PREF_LOCATION_AGE, def);
-        }
-        locationAgePref.setSummary(getResources().getString(R.string.pref_location_age, value));
-    }
-
-    private void updateDisableCurrent() {
-        if(PreferenceManager
-                .getDefaultSharedPreferences(getApplicationContext())
-                .getBoolean(KEY_PREF_DISABLE_CURRENT, true)){
-            disableOnClickPref.setSummary(getResources().getString(R.string.setting_disable_on_click_summary_active));
-        }else{
-            disableOnClickPref.setSummary(getResources().getString(R.string.setting_disable_on_click_summary_inactive));
-        }
-    }
-
-    private void updateCondAlphaSummary() {
-        String def = getResources().getString(R.string.pref_cond_alpha_default);
-        String value = PreferenceManager
-                .getDefaultSharedPreferences(getApplicationContext())
-                .getString(KEY_PREF_COND_ALPHA, def);
-
-        if (Double.parseDouble(value) == 0.0) {
-            condAlphaPref.setSummary(getResources().getString(R.string.setting_cond_alpha_not_used_summary));
-        }else {
-            condAlphaPref.setSummary(getResources().getString(R.string.setting_cond_alpha_summary, value));
-        }
-    }
-
-    private void updateCondOccurenceSummary() {
-        String def = getResources().getString(R.string.pref_cond_occurrence_default);
-        String value = PreferenceManager
-                .getDefaultSharedPreferences(getApplicationContext())
-                .getString(KEY_PREF_COND_OCCURRENCE, def);
-
-        if (Double.parseDouble(value) == 0.0) {
-            condOccurrencePref.setSummary(getResources().getString(R.string.setting_cond_occurrence_not_used_summary));
-        }else {
-            condOccurrencePref.setSummary(getResources().getString(R.string.setting_cond_occurrence_summary, value));
-        }
-    }
-
-    private void updateCondRecencySummary() {
-        String def = getResources().getString(R.string.pref_cond_recency_default);
-        String value = PreferenceManager
-                .getDefaultSharedPreferences(getApplicationContext())
-                .getString(KEY_PREF_COND_RECENCY, def);
-
-        if(Double.parseDouble(value) == 0.0){
-            condRecencyPref.setSummary(getResources().getString(R.string.setting_cond_recency_not_used_summary));
-        }else {
-            condRecencyPref.setSummary(getResources().getString(R.string.setting_cond_recency_summary, value));
-        }
-    }
-
-    private void updateAutoSelectSummary() {
-        if(PreferenceManager
-                .getDefaultSharedPreferences(getApplicationContext())
-                .getBoolean(KEY_PREF_AUTO_SELECT, true)){
-            autoSelectPref.setSummary(getResources().getString(R.string.setting_auto_select_new_summary_active));
-        }else{
-            autoSelectPref.setSummary(getResources().getString(R.string.setting_auto_select_new_summary_inactive));
-        }
-    }
-
-//    private void updateNotifShowCurActivity() {
-//        if(PreferenceManager
-//                .getDefaultSharedPreferences(getApplicationContext())
-//                .getBoolean(KEY_PREF_NOTIF_SHOW_CUR_ACT, false)){
-//            nofifShowCurActPref.setSummary(getResources().getString(R.string.setting_show_cur_activitiy_notification_summary_active));
-//        }else{
-//            nofifShowCurActPref.setSummary(getResources().getString(R.string.setting_show_cur_activitiy_notification_summary_inactive));
-//        }
-//        ActivityHelper.helper.showCurrentActivityNotification();
-//    }
-
-//    private void updateSilentNotifications() {
-//        if(PreferenceManager
-//                .getDefaultSharedPreferences(getApplicationContext())
-//                .getBoolean(KEY_PREF_SILENT_RENOTIFICATIONS, true)){
-//            silentRenotifPref.setSummary(getResources().getString(R.string.setting_silent_reconfication_summary_active));
-//        }else{
-//            silentRenotifPref.setSummary(getResources().getString(R.string.setting_silent_reconfication_summary_inactive));
-//        }
-//        ActivityHelper.helper.showCurrentActivityNotification();
-//    }
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        ActivitySettingsBinding binding = DataBindingUtil.setContentView(this, R.layout.activity_settings);
-
-//        View contentView = View.inflate(this, R.layout.activity_settings, null);
-//        setContent(contentView);
-        SettingsFragment sf = (SettingsFragment)getSupportFragmentManager().findFragmentById(R.id.settings_fragment);
-
-        setContent(binding.getRoot());
-
-        mPreferenceManager = sf.getPreferenceManager();
-        dateformatPref = mPreferenceManager.findPreference(KEY_PREF_DATETIME_FORMAT);
-
-        String def = getResources().getString(R.string.default_datetime_format);
-
-        dateformatPref.setSummary(DateFormat.format(
-                PreferenceManager
-                        .getDefaultSharedPreferences(getApplicationContext())
-                        .getString(KEY_PREF_DATETIME_FORMAT, def)
-                , new Date()));
-
-        durationFormatPref = mPreferenceManager.findPreference(KEY_PREF_DURATION_FORMAT);
-        autoSelectPref = mPreferenceManager.findPreference(KEY_PREF_AUTO_SELECT);
-        disableOnClickPref = mPreferenceManager.findPreference(KEY_PREF_DISABLE_CURRENT);
-//        storageFolderPref = mPreferenceManager.findPreference(KEY_PREF_STORAGE_FOLDER);
-        useLocationPref = mPreferenceManager.findPreference(KEY_PREF_USE_LOCATION);
-        locationAgePref = mPreferenceManager.findPreference(KEY_PREF_LOCATION_AGE);
-        locationDistPref = mPreferenceManager.findPreference(KEY_PREF_LOCATION_DIST);
-
-//        tagImagesPref = mPreferenceManager.findPreference(KEY_PREF_TAG_IMAGES);
-//        nofifShowCurActPref = mPreferenceManager.findPreference(KEY_PREF_NOTIF_SHOW_CUR_ACT);
-//        silentRenotifPref = mPreferenceManager.findPreference(KEY_PREF_SILENT_RENOTIFICATIONS);
-
-        Preference exportPref = mPreferenceManager.findPreference(KEY_PREF_DB_EXPORT);
-        exportPref.setOnPreferenceClickListener(preference -> {
-            /* export database */
-            Intent intent = new Intent(Intent.ACTION_CREATE_DOCUMENT);
-            intent.setType("application/x-sqlite3");
-            intent.putExtra(Intent.EXTRA_TITLE, getResources().getString(R.string.db_export_name_suggestion) + "_" +
-                    new SimpleDateFormat("yyyy-MM-dd").format(new Date()) + ".sqlite3");
-            intent.addCategory(Intent.CATEGORY_OPENABLE);
-
-            startActivityForResult(Intent.createChooser(intent, getResources().getString(R.string.db_export_selection)), ACTIVITIY_RESULT_EXPORT);
-            return true;
-        });
-        Preference importPref = mPreferenceManager.findPreference(KEY_PREF_DB_IMPORT);
-        importPref.setOnPreferenceClickListener(preference -> {
-            /* import database */
-            Intent intent = new Intent(Intent.ACTION_GET_CONTENT);
-            intent.setType("application/*");
-            intent.addCategory(Intent.CATEGORY_OPENABLE);
-            startActivityForResult(Intent.createChooser(intent, getResources().getString(R.string.db_import_selection)), ACTIVITIY_RESULT_IMPORT);
-            return true;
-        });
-
-        condAlphaPref = mPreferenceManager.findPreference(KEY_PREF_COND_ALPHA);
-        condOccurrencePref = mPreferenceManager.findPreference(KEY_PREF_COND_OCCURRENCE);
-        condRecencyPref = mPreferenceManager.findPreference(KEY_PREF_COND_RECENCY);
-
-//        updateAutoSelectSummary();
-//        updateStorageFolderSummary();
-//        updateTagImageSummary();
-//        updateCondAlphaSummary();
-//        updateCondOccurenceSummary();
-//        updateNotifShowCurActivity();
-//        updateSilentNotifications();
-//        updateDisableCurrent();
-//        updateUseLocation();
-//        updateLocationAge();
-//        updateLocationDist();
-//        updateDurationFormat();
-
-        mDrawerToggle.setDrawerIndicatorEnabled(false);
-    }
-    
-    @Override
-    public void onResume(){
-        mNavigationView.getMenu().findItem(R.id.nav_settings).setChecked(true);
-        super.onResume();
-        mPreferenceManager.getPreferenceScreen().getSharedPreferences()
-                .registerOnSharedPreferenceChangeListener(this);
-
-    }
-
-    @Override
-    protected void onPause() {
-        super.onPause();
-        mPreferenceManager.getPreferenceScreen().getSharedPreferences()
-                .unregisterOnSharedPreferenceChangeListener(this);
-    }
-
-    @Override
-    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-        super.onActivityResult(requestCode, resultCode, data);
-        if (requestCode == ACTIVITIY_RESULT_IMPORT && resultCode == RESULT_OK) {
-            Uri selectedfile = data.getData(); //The uri with the location of the file
-            // import
-            checkpointIfWALEnabled(getApplicationContext());
-
-            File db = new File(getApplicationContext().getDatabasePath(Contract.AUTHORITY).getPath());
-            File bak = new File(getApplicationContext().getDatabasePath(Contract.AUTHORITY).getPath() + ".bak");
-            InputStream inputStream = null;
-            OutputStream outputStream = null;
-            try {
-                db.renameTo(bak);
-
-                String s = getResources().getString(R.string.db_import_success, data.getData().toString());
-                inputStream = getContentResolver().openInputStream(data.getData());
-                outputStream = new FileOutputStream(db);
-                byte[] buff = new byte[4048];
-                int len;
-                while ((len = inputStream.read(buff)) > 0) {
-                    outputStream.write(buff, 0, len);
-                    outputStream.flush();
-                }
-                outputStream.close();
-                outputStream = null;
-                inputStream.close();
-                inputStream = null;
-
-                SQLiteDatabase sdb = SQLiteDatabase.openDatabase(db.getPath(), null, SQLiteDatabase.OPEN_READONLY);
-                int v = sdb.getVersion();
-                sdb.close();
-                if (v > LocalDBHelper.CURRENT_VERSION) {
-                    throw new Exception("selected file has version " + v + " which is too high...");
-                }
-
-                ActivityHelper.helper.reloadAll();
-                Toast.makeText(SettingsActivity.this, s, Toast.LENGTH_LONG).show();
-            } catch (Exception e) {
-                if (inputStream != null) {
-                    try {
-                        inputStream.close();
-                    } catch (IOException e1) {
-                        /* ignore */
-                    }
-                }
-                if (outputStream != null) {
-                    try {
-                        outputStream.close();
-                    } catch (IOException e1) {
-                        /* ignore */
-                    }
-                }
-                bak.renameTo(db);
-                Log.e(TAG, "error on database import: " + e.getMessage());
-                String s = getResources().getString(R.string.db_import_error, data.getData().toString());
-                Toast.makeText(SettingsActivity.this, s, Toast.LENGTH_LONG).show();
-                bak.renameTo(db);
-
-            }
-        }
-        if (requestCode == ACTIVITIY_RESULT_EXPORT && resultCode == RESULT_OK) {
-
-            // export
-            checkpointIfWALEnabled(getApplicationContext());
-
-//            System.out.println(getApplicationContext().getDatabasePath(Contract.AUTHORITY).getPath());
-            File db = new File(getApplicationContext().getDatabasePath(Contract.AUTHORITY).getPath());
-            try {
-                String s = getResources().getString(R.string.db_export_success, data.getData().toString());
-                InputStream inputStream = new FileInputStream(db);
-                OutputStream outputStream = getContentResolver().openOutputStream(data.getData());
-                byte[] buff = new byte[4048];
-                int len;
-                while ((len = inputStream.read(buff)) > 0) {
-                    outputStream.write(buff, 0, len);
-                    outputStream.flush();
-                }
-                outputStream.close();
-                inputStream.close();
-
-                Toast.makeText(SettingsActivity.this, s, Toast.LENGTH_LONG).show();
-            } catch (Exception e) {
-                Log.e(TAG, "error on database export: " + e.getMessage());
-                String s = getResources().getString(R.string.db_export_error, data.getData().toString());
-                Toast.makeText(SettingsActivity.this, s, Toast.LENGTH_LONG).show();
-            }
-        }
-    }
-
-    private static void checkpointIfWALEnabled(Context context) {
-        final String TAGLocal = "WALCHKPNT";
-        Cursor csr;
-        int wal_busy = -99, wal_log = -99, wal_checkpointed = -99;
-        SQLiteDatabase db = SQLiteDatabase.openDatabase(context.getDatabasePath(Contract.AUTHORITY).getPath(),null,SQLiteDatabase.OPEN_READWRITE);
-        csr = db.rawQuery("PRAGMA journal_mode",null);
-        if (csr.moveToFirst()) {
-            String mode = csr.getString(0);
-            //Log.d(TAGLocal, "Mode is " + mode);
-            if (mode.equalsIgnoreCase("wal")) {
-                Cursor csr1 = db.rawQuery("PRAGMA wal_checkpoint",null);
-                if (csr1.moveToFirst()) {
-                    wal_busy = csr1.getInt(0);
-                    wal_log = csr1.getInt(1);
-                    wal_checkpointed = csr1.getInt(2);
-                }
-                Log.d(TAGLocal,"Checkpoint pre checkpointing Busy = " + wal_busy + " LOG = " +
-                        wal_log + " CHECKPOINTED = " + wal_checkpointed);
-                csr1.close();
-                
-                Cursor csr2 = db.rawQuery("PRAGMA wal_checkpoint(TRUNCATE)",null);
-                csr2.getCount();
-                csr2.close();
-                
-                Cursor csr3 = db.rawQuery("PRAGMA wal_checkpoint",null);
-                if (csr3.moveToFirst()) {
-                    wal_busy = csr3.getInt(0);
-                    wal_log = csr3.getInt(1);
-                    wal_checkpointed = csr3.getInt(2);
-                }
-                Log.d(TAGLocal,"Checkpoint post checkpointing Busy = " + wal_busy + " LOG = " +
-                        wal_log + " CHECKPOINTED = " + wal_checkpointed);
-                csr3.close();
-            }
-        }
-        csr.close();
-        db.close();
-    }
-}
-
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/settings/SettingsActivity.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/settings/SettingsActivity.kt
new file mode 100755
index 0000000..0c309f6
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/settings/SettingsActivity.kt
@@ -0,0 +1,631 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.ui.settings
+
+import android.Manifest
+import android.content.Context
+import android.content.Intent
+import android.content.SharedPreferences
+import android.content.SharedPreferences.OnSharedPreferenceChangeListener
+import android.content.pm.PackageManager
+import android.database.Cursor
+import android.database.sqlite.SQLiteDatabase
+import android.os.Build
+import android.os.Bundle
+import android.text.format.DateFormat
+import android.util.Log
+import android.widget.Toast
+import androidx.core.app.ActivityCompat
+import androidx.core.content.ContextCompat
+import androidx.core.text.isDigitsOnly
+import androidx.databinding.DataBindingUtil
+import androidx.preference.EditTextPreference
+import androidx.preference.ListPreference
+import androidx.preference.Preference
+import androidx.preference.PreferenceManager
+import com.mdiqentw.lifedots.MVApplication
+import com.mdiqentw.lifedots.R
+import com.mdiqentw.lifedots.databinding.ActivitySettingsBinding
+import com.mdiqentw.lifedots.db.Contract
+import com.mdiqentw.lifedots.db.LocalDBHelper
+import com.mdiqentw.lifedots.helpers.ActivityHelper
+import com.mdiqentw.lifedots.helpers.LocationHelper
+import com.mdiqentw.lifedots.ui.generic.BaseActivity
+import org.jetbrains.annotations.NonNls
+import java.io.*
+import java.text.SimpleDateFormat
+import java.util.*
+
+class SettingsActivity : BaseActivity(), OnSharedPreferenceChangeListener {
+    private var dateformatPref: Preference? = null
+    private var durationFormatPref: ListPreference? = null
+    private var autoSelectPref: Preference? = null
+
+    //    private Preference storageFolderPref;
+    //    private Preference tagImagesPref;
+    private var condAlphaPref: Preference? = null
+    private var condOccurrencePref: Preference? = null
+    private var condRecencyPref: Preference? = null
+
+    //    private Preference nofifShowCurActPref;
+    //    private Preference silentRenotifPref;
+    private var disableOnClickPref: Preference? = null
+    private var useLocationPref: ListPreference? = null
+    private var locationStartPref: EditTextPreference? = null
+    private var locationStopPref: EditTextPreference? = null
+    private var locationAgePref: EditTextPreference? = null
+    private var locationDistPref: EditTextPreference? = null
+    private lateinit var mPreferenceManager: PreferenceManager
+
+    override fun onSharedPreferenceChanged(
+        sharedPreferences: SharedPreferences,
+        key: String
+    ) {
+        when (key) {
+            KEY_PREF_DATETIME_FORMAT -> {
+                val def = resources.getString(R.string.default_datetime_format)
+                // Set summary to be the user-description for the selected value
+                dateformatPref!!.summary =
+                    DateFormat.format(sharedPreferences.getString(key, def), Date())
+            }
+
+            KEY_PREF_AUTO_SELECT -> updateAutoSelectSummary()
+            KEY_PREF_COND_ALPHA -> updateCondAlphaSummary()
+            KEY_PREF_COND_OCCURRENCE -> updateCondOccurenceSummary()
+            KEY_PREF_COND_RECENCY -> updateCondRecencySummary()
+            KEY_PREF_DISABLE_CURRENT -> updateDisableCurrent()
+            KEY_PREF_USE_LOCATION -> updateUseLocation()
+            KEY_PREF_LOCATION_START -> updateLocationStart()
+            KEY_PREF_LOCATION_STOP -> updateLocationStop()
+            KEY_PREF_LOCATION_AGE -> updateLocationAge()
+            KEY_PREF_LOCATION_DIST -> updateLocationDist()
+            KEY_PREF_DURATION_FORMAT -> updateDurationFormat()
+        }
+    }
+
+    private fun updateDurationFormat() {
+        val value = PreferenceManager
+            .getDefaultSharedPreferences(applicationContext)
+            .getString(KEY_PREF_DURATION_FORMAT, "dynamic")
+        when (value) {
+            "dynamic" -> durationFormatPref!!.summary =
+                resources.getString(R.string.setting_duration_format_summary_dynamic)
+
+            "nodays" -> durationFormatPref!!.summary =
+                resources.getString(R.string.setting_duration_format_summary_nodays)
+
+            "precise" -> durationFormatPref!!.summary =
+                resources.getString(R.string.setting_duration_format_summary_precise)
+
+            "hour_min" -> durationFormatPref!!.summary =
+                resources.getString(R.string.setting_duration_format_summary_hour_min)
+        }
+    }
+
+    private fun updateUseLocation() {
+        val permissionCheckFine: Int
+        val permissionCheckCoarse: Int
+        @NonNls val value = PreferenceManager
+            .getDefaultSharedPreferences(applicationContext)
+            .getString(KEY_PREF_USE_LOCATION, "off")
+        if (value == "off") {
+            locationStartPref!!.isEnabled = false
+            locationStopPref!!.isEnabled = false
+            locationAgePref!!.isEnabled = false
+            locationDistPref!!.isEnabled = false
+            useLocationPref!!.summary = resources.getString(R.string.setting_use_location_off_summary)
+        } else {
+            locationStartPref!!.isEnabled = true
+            locationStopPref!!.isEnabled = true
+            locationAgePref!!.isEnabled = true
+            locationDistPref!!.isEnabled = true
+            useLocationPref!!.summary =
+                resources.getString(R.string.setting_use_location_summary, useLocationPref!!.entry)
+        }
+        if (value == "gps") {
+            permissionCheckFine = ContextCompat.checkSelfPermission(
+                applicationContext,
+                Manifest.permission.ACCESS_FINE_LOCATION
+            )
+            if (permissionCheckFine != PackageManager.PERMISSION_GRANTED) {
+                if (ActivityCompat.shouldShowRequestPermissionRationale(
+                        this,
+                        Manifest.permission.ACCESS_FINE_LOCATION
+                    )
+                ) Toast.makeText(this, R.string.perm_location_xplain, Toast.LENGTH_LONG).show()
+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
+                    ActivityCompat.requestPermissions(
+                        this, arrayOf(
+                            Manifest.permission.ACCESS_BACKGROUND_LOCATION,
+                            Manifest.permission.ACCESS_FINE_LOCATION
+                        ),
+                        4711
+                    )
+                } else {
+                    ActivityCompat.requestPermissions(
+                        this, arrayOf(Manifest.permission.ACCESS_FINE_LOCATION),
+                        4712
+                    )
+                }
+            }
+        } else if (value == "network") {
+            permissionCheckCoarse = ContextCompat.checkSelfPermission(
+                applicationContext,
+                Manifest.permission.ACCESS_COARSE_LOCATION
+            )
+            if (permissionCheckCoarse != PackageManager.PERMISSION_GRANTED) {
+                if (ActivityCompat.shouldShowRequestPermissionRationale(
+                        this,
+                        Manifest.permission.ACCESS_COARSE_LOCATION
+                    )
+                ) Toast.makeText(this, R.string.perm_location_xplain, Toast.LENGTH_LONG).show()
+                if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.Q) {
+                    ActivityCompat.requestPermissions(
+                        this, arrayOf(
+                            Manifest.permission.ACCESS_BACKGROUND_LOCATION,
+                            Manifest.permission.ACCESS_COARSE_LOCATION
+                        ),
+                        4711
+                    )
+                } else {
+                    ActivityCompat.requestPermissions(
+                        this, arrayOf(Manifest.permission.ACCESS_COARSE_LOCATION),
+                        4713
+                    )
+                }
+            }
+        }
+    }
+
+    override fun onRequestPermissionsResult(requestCode: Int, permissions: Array<String>, grantResults: IntArray) {
+        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
+        if (requestCode == 4712 || requestCode == 4713) {
+            if (grantResults[0] == 0) {
+                LocationHelper.helper.updateLocation(false)
+            }
+        }
+    }
+
+    private fun updateLocationDist() {
+        val def = resources.getString(R.string.pref_location_dist_default)
+        @NonNls var value = PreferenceManager
+            .getDefaultSharedPreferences(applicationContext)
+            .getString(KEY_PREF_LOCATION_DIST, def)
+        if (value.isNullOrBlank() || !value.isDigitsOnly()) value = def
+
+        var v = value.replace("\\D".toRegex(), "").toInt()
+        if (v < 5) {
+            v = 5
+        }
+        val nvalue = v.toString()
+        if (value != nvalue) {
+            val editor = PreferenceManager
+                .getDefaultSharedPreferences(applicationContext).edit()
+            editor.putString(KEY_PREF_LOCATION_DIST, nvalue)
+            editor.apply()
+            value = PreferenceManager
+                .getDefaultSharedPreferences(applicationContext)
+                .getString(KEY_PREF_LOCATION_DIST, def)
+        }
+        locationDistPref!!.summary = resources.getString(R.string.pref_location_dist, value)
+    }
+
+    private fun updateLocationAge() {
+        val def = resources.getString(R.string.pref_location_age_default)
+        var value = PreferenceManager
+            .getDefaultSharedPreferences(applicationContext)
+            .getString(KEY_PREF_LOCATION_AGE, def)
+        if (value.isNullOrBlank() || !value.isDigitsOnly()) value = def
+
+        var v = value.replace("\\D".toRegex(), "").toInt()
+        if (v < 2) {
+            v = 2
+        } else if (v > 720) {
+            v = 720
+        }
+        val nvalue = v.toString()
+        if (value != nvalue) {
+            val editor = PreferenceManager
+                .getDefaultSharedPreferences(applicationContext).edit()
+            editor.putString(KEY_PREF_LOCATION_AGE, nvalue)
+            editor.apply()
+            value = PreferenceManager
+                .getDefaultSharedPreferences(applicationContext)
+                .getString(KEY_PREF_LOCATION_AGE, def)
+        }
+        locationAgePref!!.summary = resources.getString(R.string.pref_location_age, value)
+    }
+
+    private fun updateLocationStart() {
+        val def = resources.getString(R.string.pref_location_start_default)
+        var value = PreferenceManager
+            .getDefaultSharedPreferences(applicationContext)
+            .getString(KEY_PREF_LOCATION_START, def)
+        if (value.isNullOrBlank() || !value.isDigitsOnly()) value = def
+
+        var v = value.replace("\\D".toRegex(), "").toInt()
+        if (v < 0) {
+            v = 0
+        } else if (v > 24) {
+            v = 24
+        }
+        val nvalue = v.toString()
+        if (value != nvalue) {
+            val editor = PreferenceManager
+                .getDefaultSharedPreferences(applicationContext).edit()
+            editor.putString(KEY_PREF_LOCATION_START, nvalue)
+            editor.apply()
+            value = PreferenceManager
+                .getDefaultSharedPreferences(applicationContext)
+                .getString(KEY_PREF_LOCATION_START, def)
+        }
+        locationStartPref!!.summary = resources.getString(R.string.pref_location_start, value)
+    }
+
+    private fun updateLocationStop() {
+        val def = resources.getString(R.string.pref_location_stop_default)
+        var value = PreferenceManager
+            .getDefaultSharedPreferences(applicationContext)
+            .getString(KEY_PREF_LOCATION_STOP, def)
+        if (value.isNullOrBlank() || !value.isDigitsOnly()) value = def
+
+        var v = value.replace("\\D".toRegex(), "").toInt()
+        if (v < 0) {
+            v = 0
+        } else if (v > 24) {
+            v = 24
+        }
+        val nvalue = v.toString()
+        if (value != nvalue) {
+            val editor = PreferenceManager
+                .getDefaultSharedPreferences(applicationContext).edit()
+            editor.putString(KEY_PREF_LOCATION_STOP, nvalue)
+            editor.apply()
+            value = PreferenceManager
+                .getDefaultSharedPreferences(applicationContext)
+                .getString(KEY_PREF_LOCATION_STOP, def)
+        }
+        locationStopPref!!.summary = resources.getString(R.string.pref_location_stop, value)
+    }
+
+    private fun updateDisableCurrent() {
+        if (PreferenceManager
+                .getDefaultSharedPreferences(applicationContext)
+                .getBoolean(KEY_PREF_DISABLE_CURRENT, true)
+        ) {
+            disableOnClickPref!!.summary = resources.getString(R.string.setting_disable_on_click_summary_active)
+        } else {
+            disableOnClickPref!!.summary = resources.getString(R.string.setting_disable_on_click_summary_inactive)
+        }
+    }
+
+    private fun updateCondAlphaSummary() {
+        val def = resources.getString(R.string.pref_cond_alpha_default)
+        val value = PreferenceManager
+            .getDefaultSharedPreferences(applicationContext)
+            .getString(KEY_PREF_COND_ALPHA, def)
+        if (value!!.toDouble() == 0.0) {
+            condAlphaPref!!.summary = resources.getString(R.string.setting_cond_alpha_not_used_summary)
+        } else {
+            condAlphaPref!!.summary = resources.getString(R.string.setting_cond_alpha_summary, value)
+        }
+    }
+
+    private fun updateCondOccurenceSummary() {
+        val def = resources.getString(R.string.pref_cond_occurrence_default)
+        val value = PreferenceManager
+            .getDefaultSharedPreferences(applicationContext)
+            .getString(KEY_PREF_COND_OCCURRENCE, def)
+        if (value!!.toDouble() == 0.0) {
+            condOccurrencePref!!.summary = resources.getString(R.string.setting_cond_occurrence_not_used_summary)
+        } else {
+            condOccurrencePref!!.summary = resources.getString(R.string.setting_cond_occurrence_summary, value)
+        }
+    }
+
+    private fun updateCondRecencySummary() {
+        val def = resources.getString(R.string.pref_cond_recency_default)
+        val value = PreferenceManager
+            .getDefaultSharedPreferences(applicationContext)
+            .getString(KEY_PREF_COND_RECENCY, def)
+        if (value!!.toDouble() == 0.0) {
+            condRecencyPref!!.summary = resources.getString(R.string.setting_cond_recency_not_used_summary)
+        } else {
+            condRecencyPref!!.summary = resources.getString(R.string.setting_cond_recency_summary, value)
+        }
+    }
+
+    private fun updateAutoSelectSummary() {
+        if (PreferenceManager
+                .getDefaultSharedPreferences(applicationContext)
+                .getBoolean(KEY_PREF_AUTO_SELECT, true)
+        ) {
+            autoSelectPref!!.summary = resources.getString(R.string.setting_auto_select_new_summary_active)
+        } else {
+            autoSelectPref!!.summary = resources.getString(R.string.setting_auto_select_new_summary_inactive)
+        }
+    }
+
+    //    private void updateNotifShowCurActivity() {
+    //        if(PreferenceManager
+    //                .getDefaultSharedPreferences(getApplicationContext())
+    //                .getBoolean(KEY_PREF_NOTIF_SHOW_CUR_ACT, false)){
+    //            nofifShowCurActPref.setSummary(getResources().getString(R.string.setting_show_cur_activitiy_notification_summary_active));
+    //        }else{
+    //            nofifShowCurActPref.setSummary(getResources().getString(R.string.setting_show_cur_activitiy_notification_summary_inactive));
+    //        }
+    //        ActivityHelper.helper.showCurrentActivityNotification();
+    //    }
+    //    private void updateSilentNotifications() {
+    //        if(PreferenceManager
+    //                .getDefaultSharedPreferences(getApplicationContext())
+    //                .getBoolean(KEY_PREF_SILENT_RENOTIFICATIONS, true)){
+    //            silentRenotifPref.setSummary(getResources().getString(R.string.setting_silent_reconfication_summary_active));
+    //        }else{
+    //            silentRenotifPref.setSummary(getResources().getString(R.string.setting_silent_reconfication_summary_inactive));
+    //        }
+    //        ActivityHelper.helper.showCurrentActivityNotification();
+    //    }
+    override fun onCreate(savedInstanceState: Bundle?) {
+        super.onCreate(savedInstanceState)
+        val binding = DataBindingUtil.setContentView<ActivitySettingsBinding>(this, R.layout.activity_settings)
+
+//        View contentView = View.inflate(this, R.layout.activity_settings, null);
+//        setContent(contentView);
+        val sf = supportFragmentManager.findFragmentById(R.id.settings_fragment) as SettingsFragment?
+        setContent(binding.root)
+        mPreferenceManager = sf!!.preferenceManager
+        dateformatPref = mPreferenceManager.findPreference(KEY_PREF_DATETIME_FORMAT)
+        val def = resources.getString(R.string.default_datetime_format)
+        dateformatPref!!.summary = DateFormat.format(
+            PreferenceManager
+                .getDefaultSharedPreferences(applicationContext)
+                .getString(KEY_PREF_DATETIME_FORMAT, def), Date()
+        )
+        durationFormatPref = mPreferenceManager.findPreference(KEY_PREF_DURATION_FORMAT)
+        autoSelectPref = mPreferenceManager.findPreference(KEY_PREF_AUTO_SELECT)
+        disableOnClickPref = mPreferenceManager.findPreference(KEY_PREF_DISABLE_CURRENT)
+        //        storageFolderPref = mPreferenceManager.findPreference(KEY_PREF_STORAGE_FOLDER);
+        useLocationPref = mPreferenceManager.findPreference(KEY_PREF_USE_LOCATION)
+        locationStartPref = mPreferenceManager.findPreference(KEY_PREF_LOCATION_START)
+        locationStopPref = mPreferenceManager.findPreference(KEY_PREF_LOCATION_STOP)
+        locationAgePref = mPreferenceManager.findPreference(KEY_PREF_LOCATION_AGE)
+        locationDistPref = mPreferenceManager.findPreference(KEY_PREF_LOCATION_DIST)
+
+//        tagImagesPref = mPreferenceManager.findPreference(KEY_PREF_TAG_IMAGES);
+//        nofifShowCurActPref = mPreferenceManager.findPreference(KEY_PREF_NOTIF_SHOW_CUR_ACT);
+//        silentRenotifPref = mPreferenceManager.findPreference(KEY_PREF_SILENT_RENOTIFICATIONS);
+        val exportPref = mPreferenceManager.findPreference<Preference>(KEY_PREF_DB_EXPORT)
+        exportPref!!.onPreferenceClickListener = Preference.OnPreferenceClickListener { _: Preference? ->
+            /* export database */
+            val intent = Intent(Intent.ACTION_CREATE_DOCUMENT)
+            intent.type = "application/x-sqlite3"
+            intent.putExtra(
+                Intent.EXTRA_TITLE, resources.getString(R.string.db_export_name_suggestion) + "_" +
+                        SimpleDateFormat("yyyy-MM-dd").format(Date()) + ".sqlite3"
+            )
+            intent.addCategory(Intent.CATEGORY_OPENABLE)
+            startActivityForResult(
+                Intent.createChooser(intent, resources.getString(R.string.db_export_selection)),
+                ACTIVITIY_RESULT_EXPORT
+            )
+            true
+        }
+        val importPref = mPreferenceManager.findPreference<Preference>(KEY_PREF_DB_IMPORT)
+        importPref!!.onPreferenceClickListener = Preference.OnPreferenceClickListener { _: Preference? ->
+            /* import database */
+            val intent = Intent(Intent.ACTION_GET_CONTENT)
+            intent.type = "application/*"
+            intent.addCategory(Intent.CATEGORY_OPENABLE)
+            startActivityForResult(
+                Intent.createChooser(intent, resources.getString(R.string.db_import_selection)),
+                ACTIVITIY_RESULT_IMPORT
+            )
+            true
+        }
+        condAlphaPref = mPreferenceManager.findPreference(KEY_PREF_COND_ALPHA)
+        condOccurrencePref = mPreferenceManager.findPreference(KEY_PREF_COND_OCCURRENCE)
+        condRecencyPref = mPreferenceManager.findPreference(KEY_PREF_COND_RECENCY)
+
+//        updateAutoSelectSummary();
+//        updateStorageFolderSummary();
+//        updateTagImageSummary();
+//        updateCondAlphaSummary();
+//        updateCondOccurenceSummary();
+//        updateNotifShowCurActivity();
+//        updateSilentNotifications();
+//        updateDisableCurrent();
+//        updateUseLocation();
+//        updateLocationAge();
+//        updateLocationDist();
+//        updateDurationFormat();
+        mDrawerToggle.isDrawerIndicatorEnabled = false
+    }
+
+    public override fun onResume() {
+        mNavigationView.menu.findItem(R.id.nav_settings).isChecked = true
+        super.onResume()
+        mPreferenceManager.preferenceScreen.sharedPreferences!!
+            .registerOnSharedPreferenceChangeListener(this)
+    }
+
+    override fun onPause() {
+        super.onPause()
+        mPreferenceManager.preferenceScreen.sharedPreferences!!
+            .unregisterOnSharedPreferenceChangeListener(this)
+    }
+
+    @Deprecated("Deprecated in Java")
+    override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
+        super.onActivityResult(requestCode, resultCode, data)
+        if (requestCode == ACTIVITIY_RESULT_IMPORT && resultCode == RESULT_OK) {
+            val selectedfile = data!!.data //The uri with the location of the file
+            // import
+            checkpointIfWALEnabled(applicationContext)
+            val db = File(applicationContext.getDatabasePath(Contract.AUTHORITY).path)
+            val bak = File(applicationContext.getDatabasePath(Contract.AUTHORITY).path + ".bak")
+            var inputStream: InputStream? = null
+            var outputStream: OutputStream? = null
+            try {
+                db.renameTo(bak)
+                val s = resources.getString(R.string.db_import_success, data.data.toString())
+                inputStream = contentResolver.openInputStream(data.data!!)
+                outputStream = FileOutputStream(db)
+                val buff = ByteArray(4048)
+                var len: Int
+                while (inputStream!!.read(buff).also { len = it } > 0) {
+                    outputStream.write(buff, 0, len)
+                    outputStream.flush()
+                }
+                outputStream.close()
+                outputStream = null
+                inputStream.close()
+                inputStream = null
+                val sdb = SQLiteDatabase.openDatabase(db.path, null, SQLiteDatabase.OPEN_READONLY)
+                val v = sdb.version
+                sdb.close()
+                if (v > LocalDBHelper.CURRENT_VERSION) {
+                    throw Exception("selected file has version $v which is too high...")
+                }
+                ActivityHelper.helper.reloadAll()
+                Toast.makeText(this@SettingsActivity, s, Toast.LENGTH_LONG).show()
+            } catch (e: Exception) {
+                if (inputStream != null) {
+                    try {
+                        inputStream.close()
+                    } catch (e1: IOException) {
+                        /* ignore */
+                    }
+                }
+                if (outputStream != null) {
+                    try {
+                        outputStream.close()
+                    } catch (e1: IOException) {
+                        /* ignore */
+                    }
+                }
+                bak.renameTo(db)
+                Log.e(TAG, "error on database import: " + e.message)
+                val s = resources.getString(R.string.db_import_error, data.data.toString())
+                Toast.makeText(this@SettingsActivity, s, Toast.LENGTH_LONG).show()
+                bak.renameTo(db)
+            }
+        }
+        if (requestCode == ACTIVITIY_RESULT_EXPORT && resultCode == RESULT_OK) {
+
+            // export
+            checkpointIfWALEnabled(applicationContext)
+
+//            System.out.println(getApplicationContext().getDatabasePath(Contract.AUTHORITY).getPath());
+            val db = File(applicationContext.getDatabasePath(Contract.AUTHORITY).path)
+            try {
+                val s = resources.getString(R.string.db_export_success, data!!.data.toString())
+                val inputStream: InputStream = FileInputStream(db)
+                val outputStream = contentResolver.openOutputStream(data.data!!)
+                val buff = ByteArray(4048)
+                var len: Int
+                while (inputStream.read(buff).also { len = it } > 0) {
+                    outputStream!!.write(buff, 0, len)
+                    outputStream.flush()
+                }
+                outputStream!!.close()
+                inputStream.close()
+                Toast.makeText(this@SettingsActivity, s, Toast.LENGTH_LONG).show()
+            } catch (e: Exception) {
+                Log.e(TAG, "error on database export: " + e.message)
+                val s = resources.getString(R.string.db_export_error, data!!.data.toString())
+                Toast.makeText(this@SettingsActivity, s, Toast.LENGTH_LONG).show()
+            }
+        }
+    }
+
+    companion object {
+        private val TAG = SettingsActivity::class.java.name
+        const val KEY_PREF_DATETIME_FORMAT = "pref_datetimeFormat"
+        const val KEY_PREF_AUTO_SELECT = "pref_auto_select_new"
+        const val KEY_PREF_DB_EXPORT = "pref_db_export"
+        const val KEY_PREF_DB_IMPORT = "pref_db_import"
+        const val KEY_PREF_COND_ALPHA = "pref_cond_alpha"
+        const val KEY_PREF_COND_PREDECESSOR = "pref_cond_predecessor"
+        const val KEY_PREF_COND_OCCURRENCE = "pref_cond_occurrence"
+        const val KEY_PREF_COND_RECENCY = "pref_cond_recency"
+
+        //    public static final String KEY_PREF_NOTIF_SHOW_CUR_ACT = "pref_show_cur_activity_notification";
+        //    public static final String KEY_PREF_SILENT_RENOTIFICATIONS = "pref_silent_renotification";
+        const val KEY_PREF_DISABLE_CURRENT = "pref_disable_current_on_click"
+        const val KEY_PREF_COND_DAYTIME = "pref_cond_daytime"
+        const val KEY_PREF_USE_LOCATION = "pref_use_location"
+        const val KEY_PREF_LOCATION_START = "pref_location_start"
+        const val KEY_PREF_LOCATION_STOP = "pref_location_stop"
+        const val KEY_PREF_LOCATION_AGE = "pref_location_age"
+        const val KEY_PREF_LOCATION_DIST = "pref_location_dist"
+        const val KEY_PREF_PAUSED = "pref_cond_paused"
+        const val KEY_PREF_DURATION_FORMAT = "pref_duration_format"
+        const val ACTIVITIY_RESULT_EXPORT = 17
+        const val ACTIVITIY_RESULT_IMPORT = 18
+        var mOpenHelper = LocalDBHelper(MVApplication.appContext!!)
+        private fun checkpointIfWALEnabled(context: Context) {
+            val TAGLocal = "WALCHKPNT"
+            val csr: Cursor
+            var wal_busy = -99
+            var wal_log = -99
+            var wal_checkpointed = -99
+            val db = SQLiteDatabase.openDatabase(
+                context.getDatabasePath(Contract.AUTHORITY).path,
+                null,
+                SQLiteDatabase.OPEN_READWRITE
+            )
+            csr = db.rawQuery("PRAGMA journal_mode", null)
+            if (csr.moveToFirst()) {
+                val mode = csr.getString(0)
+                //Log.d(TAGLocal, "Mode is " + mode);
+                if (mode.equals("wal", ignoreCase = true)) {
+                    val csr1 = db.rawQuery("PRAGMA wal_checkpoint", null)
+                    if (csr1.moveToFirst()) {
+                        wal_busy = csr1.getInt(0)
+                        wal_log = csr1.getInt(1)
+                        wal_checkpointed = csr1.getInt(2)
+                    }
+                    Log.d(
+                        TAGLocal, "Checkpoint pre checkpointing Busy = " + wal_busy + " LOG = " +
+                                wal_log + " CHECKPOINTED = " + wal_checkpointed
+                    )
+                    csr1.close()
+                    val csr2 = db.rawQuery("PRAGMA wal_checkpoint(TRUNCATE)", null)
+                    csr2.count
+                    csr2.close()
+                    val csr3 = db.rawQuery("PRAGMA wal_checkpoint", null)
+                    if (csr3.moveToFirst()) {
+                        wal_busy = csr3.getInt(0)
+                        wal_log = csr3.getInt(1)
+                        wal_checkpointed = csr3.getInt(2)
+                    }
+                    Log.d(
+                        TAGLocal, "Checkpoint post checkpointing Busy = " + wal_busy + " LOG = " +
+                                wal_log + " CHECKPOINTED = " + wal_checkpointed
+                    )
+                    csr3.close()
+                }
+            }
+            csr.close()
+            db.close()
+        }
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/settings/SettingsFragment.java b/app/src/main/java/com/mdiqentw/lifedots/ui/settings/SettingsFragment.java
deleted file mode 100644
index 74c362f..0000000
--- a/app/src/main/java/com/mdiqentw/lifedots/ui/settings/SettingsFragment.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * LifeDots
- *
- * Copyright (C) 2017 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-package com.mdiqentw.lifedots.ui.settings;
-
-import android.os.Bundle;
-import androidx.preference.PreferenceFragmentCompat;
-
-import com.mdiqentw.lifedots.R;
-
-/*
- * LifeDots
- *
- * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
-  ~ Copyright (C) 2017-2018 Raphael Mack http://www.raphael-mack.de
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program.  If not, see <https://www.gnu.org/licenses/>.
- */
-
-public class SettingsFragment extends PreferenceFragmentCompat {
-
-    @Override
-    public void onCreatePreferences(Bundle savedInstanceState, String rootKey) {
-        // Load the Preferences from the XML file
-        addPreferencesFromResource(R.xml.app_preferences);
-    }
-}
diff --git a/app/src/main/java/com/mdiqentw/lifedots/ui/settings/SettingsFragment.kt b/app/src/main/java/com/mdiqentw/lifedots/ui/settings/SettingsFragment.kt
new file mode 100755
index 0000000..d3c0de1
--- /dev/null
+++ b/app/src/main/java/com/mdiqentw/lifedots/ui/settings/SettingsFragment.kt
@@ -0,0 +1,31 @@
+/*
+ * LifeDots
+ *
+ * Copyright (C) 2017 Raphael Mack http://www.raphael-mack.de
+ * Copyright (C) 2020 Xilin Jia https://github.com/XilinJia
+ *
+ * This program is free software: you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation, either version 3 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program.  If not, see <https://www.gnu.org/licenses/>.
+ */
+package com.mdiqentw.lifedots.ui.settings
+
+import android.os.Bundle
+import androidx.preference.PreferenceFragmentCompat
+import com.mdiqentw.lifedots.R
+
+class SettingsFragment : PreferenceFragmentCompat() {
+    override fun onCreatePreferences(savedInstanceState: Bundle?, rootKey: String?) {
+        // Load the Preferences from the XML file
+        addPreferencesFromResource(R.xml.app_preferences)
+    }
+}
\ No newline at end of file
