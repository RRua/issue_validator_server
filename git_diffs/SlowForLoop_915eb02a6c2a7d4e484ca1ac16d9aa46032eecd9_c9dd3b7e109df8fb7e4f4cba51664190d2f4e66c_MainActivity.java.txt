diff --git a/src/aws/apps/usbDeviceEnumerator/activities/MainActivity.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/activities/MainActivity.java
similarity index 97%
rename from src/aws/apps/usbDeviceEnumerator/activities/MainActivity.java
rename to app/src/main/java/aws/apps/usbDeviceEnumerator/activities/MainActivity.java
index 2dbc15e..89815fa 100644
--- a/src/aws/apps/usbDeviceEnumerator/activities/MainActivity.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/activities/MainActivity.java
@@ -1,509 +1,509 @@
-/*******************************************************************************
- * Copyright 2011 Alexandros Schillings
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-package aws.apps.usbDeviceEnumerator.activities;
-
-import java.io.BufferedInputStream;
-import java.io.File;
-import java.io.FileOutputStream;
-import java.io.InputStream;
-import java.io.OutputStream;
-import java.net.URL;
-import java.net.URLConnection;
-import java.text.MessageFormat;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.HashMap;
-
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.app.DialogFragment;
-import android.app.Fragment;
-import android.app.FragmentTransaction;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.hardware.usb.UsbDevice;
-import android.hardware.usb.UsbManager;
-import android.os.AsyncTask;
-import android.os.Bundle;
-import android.os.Environment;
-import android.util.Log;
-import android.util.Pair;
-import android.view.Gravity;
-import android.view.Menu;
-import android.view.MenuInflater;
-import android.view.MenuItem;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.AdapterView;
-import android.widget.AdapterView.OnItemClickListener;
-import android.widget.ArrayAdapter;
-import android.widget.LinearLayout.LayoutParams;
-import android.widget.ListView;
-import android.widget.TabHost;
-import android.widget.TabHost.OnTabChangeListener;
-import android.widget.TabHost.TabSpec;
-import android.widget.TabWidget;
-import android.widget.TextView;
-import android.widget.Toast;
-import aws.apps.usbDeviceEnumerator.R;
-import aws.apps.usbDeviceEnumerator.data.DbAccessCompany;
-import aws.apps.usbDeviceEnumerator.data.DbAccessUsb;
-import aws.apps.usbDeviceEnumerator.data.ZipAccessCompany;
-import aws.apps.usbDeviceEnumerator.fragments.AbstractUsbDeviceInfoFragment;
-import aws.apps.usbDeviceEnumerator.fragments.ProgressDialogFragment;
-import aws.apps.usbDeviceEnumerator.fragments.UsbDeviceInfoAndroidFragment;
-import aws.apps.usbDeviceEnumerator.fragments.UsbDeviceInfoLinuxFragment;
-import aws.apps.usbDeviceEnumerator.usb.sysbususb.SysBusUsbDevice;
-import aws.apps.usbDeviceEnumerator.usb.sysbususb.SysBusUsbManager;
-import aws.apps.usbDeviceEnumerator.util.UsefulBits;
-
-public class MainActivity extends Activity implements OnTabChangeListener{
-	final String TAG =  this.getClass().getName();
-	private final String DIALOG_FRAGMENT_TAG = "progress_dialog";
-	
-	private final static String TAB_ANDROID_INFO = "Android";
-	private final static String TAB_LINUX_INFO = "Linux";
-
-	private UsefulBits mUsefulBits;
-	
-	private ListView mListUsbAndroid;
-	private TextView mTvDeviceCountAndroid;
-
-	private ListView mListUsbLinux;
-	private TextView mTvDeviceCountLinux;
-
-	private UsbManager mUsbManAndroid;
-	private SysBusUsbManager mUsbManagerLinux;
-
-	private DbAccessUsb mDbUsb;
-	private DbAccessCompany mDbComp;
-	private ZipAccessCompany mZipComp;
-	
-	private TabHost mTabHost;
-	private TabWidget mTabWidget;
-	private HashMap<String, UsbDevice> mAndroidUsbDeviceList;
-	private HashMap<String, SysBusUsbDevice> mLinuxUsbDeviceList;	
-
-	private boolean mIsSmallScreen = true;
-
-	private void dialogFragmentDismiss(String tag){
-		Log.d(TAG, "^ Dimissing Fragment : " + tag);
-		
-		DialogFragment dialog = (DialogFragment) getFragmentManager().findFragmentByTag(tag); 
-		if (dialog != null) { 
-			if(DIALOG_FRAGMENT_TAG.equals(tag)){
-				Log.d(TAG, "^ Dimissing Fragment!");
-				((ProgressDialogFragment) dialog).dismissAllowingStateLoss();
-			} else {
-				dialog.dismiss();
-			}
-		}
-	}
-
-	private void dialogFragmentShow(String tag){
-		FragmentTransaction ft = getFragmentManager().beginTransaction();
-	    Fragment prev = getFragmentManager().findFragmentByTag(tag);
-	    if (prev != null) {
-	        ft.remove(prev);
-	    }
-	    ft.addToBackStack(null);
-	    
-		DialogFragment newFragment = null;
-		if(DIALOG_FRAGMENT_TAG.equals(tag)){
-			newFragment	= ProgressDialogFragment.newInstance(getString(R.string.text_downloading_files), null);
-		}
-		ft.add(newFragment, tag);
-        ft.commitAllowingStateLoss();
-	}
-
-	private void dialogFragmentUpdate(String tag, String title, Integer progress){
-		DialogFragment dialogFragment = (DialogFragment) getFragmentManager().findFragmentByTag(tag); 
-		if (dialogFragment != null) { 
-			if(title != null){
-				((ProgressDialogFragment) dialogFragment).setTitle(title);
-			}
-			if(progress != null){
-				((ProgressDialogFragment) dialogFragment).setProgress(progress);
-			}
-		}
-	}
-	
-	private void displayAndroidUsbDeviceInfo(String device){
-		if(mIsSmallScreen){
-			Intent i = new Intent(getApplicationContext(), UsbInfoActivity.class);
-            i.putExtra(UsbInfoActivity.EXTRA_TYPE, AbstractUsbDeviceInfoFragment.TYPE_ANDROID_INFO);
-            i.putExtra(UsbInfoActivity.EXTRA_DATA_ANDROID, device);
-            startActivity(i);
-		} else {
-			stackAFragment(device);
-		}
-	}
-
-	private void displayLinuxUsbDeviceInfo(SysBusUsbDevice device){
-		if(mIsSmallScreen){
-			Intent i = new Intent(getApplicationContext(), UsbInfoActivity.class);
-            i.putExtra(UsbInfoActivity.EXTRA_TYPE, AbstractUsbDeviceInfoFragment.TYPE_LINUX_INFO);
-            i.putExtra(UsbInfoActivity.EXTRA_DATA_LINUX, device);
-            startActivity(i);
-		} else {
-			stackAFragment(device);
-		}
-	}
-
-	private View getListViewEmptyView(String text){
-		TextView emptyView = new TextView(getApplicationContext());
-		emptyView.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));
-		emptyView.setText(text);
-		emptyView.setTextSize(20f);
-		emptyView.setGravity(Gravity.CENTER_VERTICAL | Gravity.CENTER_HORIZONTAL);
-		return emptyView;
-	}
-
-	private void initialiseDbComponents(){
-		// Prompt user to DL db if it is missing.
-		if (!new File(mDbUsb.getLocalDbFullPath()).exists()){
-			mUsefulBits.ShowAlert(getString(R.string.alert_db_not_found_title), 
-					getString(R.string.alert_db_not_found_instructions), 
-					getString(android.R.string.ok));
-			Log.w(TAG, "^ Database not found: " + mDbUsb.getLocalDbFullPath());
-			return;
-		}
-	}
-
-	private boolean isSmallScreen(){
-		Boolean res;
-		if(findViewById(R.id.fragment_container) == null){
-			res = true;
-		} else {
-			res = false;
-		}
-		Log.d(TAG, "^ Is this device a small screen? " + res);
-		return res;
-	}
-
-	private TabSpec newTab(String tag, int labelId, int tabContentId) {
-		TabSpec tabSpec = mTabHost.newTabSpec(tag);
-		tabSpec.setIndicator(tag);
-		tabSpec.setContent(tabContentId);
-		return tabSpec;
-	}
-
-	/** Called when the activity is first created. */
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.act_main);
-		mIsSmallScreen = isSmallScreen();
-		mUsefulBits = new UsefulBits(this);
-
-		mUsbManAndroid = (UsbManager) getSystemService(Context.USB_SERVICE);
-		mUsbManagerLinux = new SysBusUsbManager();
-		mTvDeviceCountAndroid = (TextView) findViewById(R.id.lbl_devices_api);
-		mTvDeviceCountLinux = (TextView) findViewById(R.id.lbl_devices_linux);
-
-		mTabHost = (TabHost)findViewById(android.R.id.tabhost);
-	
-		mDbUsb = new DbAccessUsb(this);
-		mDbComp = new DbAccessCompany(this);
-		mZipComp = new ZipAccessCompany(this);
-		
-		mListUsbAndroid = (ListView) findViewById(R.id.usb_list_api);
-		mListUsbAndroid.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
-		mListUsbAndroid.setOnItemClickListener(new OnItemClickListener() {
-
-			@Override
-			public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-				mListUsbAndroid.setItemChecked(position, true);
-				displayAndroidUsbDeviceInfo(((TextView) view).getText().toString());
-			}
-		});
-		View emptyView = getListViewEmptyView(getString(R.string.label_empty_list));
-		((ViewGroup) mListUsbAndroid.getParent()).addView(emptyView);
-		mListUsbAndroid.setEmptyView(emptyView);
-		///
-		mListUsbLinux = (ListView) findViewById(R.id.usb_list_linux);
-		mListUsbLinux.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
-		mListUsbLinux.setOnItemClickListener(new OnItemClickListener() {
-
-			@Override
-			public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-				mListUsbLinux.setItemChecked(position, true);
-				displayLinuxUsbDeviceInfo( mLinuxUsbDeviceList.get(((TextView) view).getText().toString()));
-			}
-		});
-
-		emptyView = getListViewEmptyView(getString(R.string.label_empty_list));
-		((ViewGroup) mListUsbLinux.getParent()).addView(emptyView);
-		mListUsbLinux.setEmptyView(emptyView);
-
-		setupTabs();
-
-		initialiseDbComponents();
-		refreshUsbDevices();
-	}
-
-	/** Creates the menu items */
-	public boolean onCreateOptionsMenu(Menu menu) {
-		MenuInflater inflater = getMenuInflater();
-		inflater.inflate(R.menu.main_menu, menu);
-		return true;
-	}
-
-	/** Handles item selections */
-	public boolean onOptionsItemSelected(MenuItem item) {
-		switch (item.getItemId()) {
-		case R.id.menu_about:			
-			mUsefulBits.showAboutDialogue();
-			return true;
-		case R.id.menu_update_db:
-			if (!Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
-				Log.d(TAG, "^ SD card not available.");
-				mUsefulBits.showToast(getString(R.string.sd_not_available), Toast.LENGTH_SHORT, Gravity.TOP,0,0);
-				return true;
-			}
-
-			if (!mUsefulBits.createDirectories(mDbUsb.getLocalDbLocation())){return true;}
-			if (!mUsefulBits.createDirectories(mDbComp.getLocalDbLocation())){return true;}
-			if (!mUsefulBits.createDirectories(mZipComp.getLocalZipLocation())){return true;}
-
-			if (!mUsefulBits.isOnline()){  // If we are not online, cancel everything
-				mUsefulBits.ShowAlert(
-						getString(R.string.text_device_offline), 
-						getString(R.string.text_device_offline_instructions), 
-						getString(android.R.string.ok));
-				return true;
-			}
-
-			AlertDialog.Builder builder = new AlertDialog.Builder(this);
-			builder.setMessage(getString(R.string.alert_update_db))
-			.setPositiveButton(getString(android.R.string.yes), new DialogInterface.OnClickListener(){
-				@SuppressWarnings("unchecked")
-				@Override
-				public void onClick(DialogInterface dialog, int which) {
-					ArrayList<Pair<String, String>> downloads = new ArrayList<Pair<String, String>>();
-					
-					downloads.add(new Pair<String, String>(
-							getString(R.string.url_usb_db), 
-							mDbUsb.getLocalDbFullPath()));
-	
-					downloads.add(new Pair<String, String>(
-							getString(R.string.url_company_db), 
-							mDbComp.getLocalDbFullPath()));
-					
-					downloads.add(new Pair<String, String>(
-							getString(R.string.url_company_logo_zip), 
-							mZipComp.getLocalZipFullPath()));
-					
-					new DownloadFile().execute(downloads);
-				}
-
-			})
-			.setNegativeButton(getString(android.R.string.no), null).show();
-			return true;
-		case R.id.menu_refresh:
-			refreshUsbDevices();
-			return true;
-		}
-
-		return false;
-	}
-
-	@Override
-	public void onTabChanged(String tabId) {
-		if(mIsSmallScreen){ return; }
-		int position = -1;
-
-		if(tabId.equals(TAB_ANDROID_INFO)){
-			position = mListUsbAndroid.getCheckedItemPosition();
-			if(position != ListView.INVALID_POSITION){
-				String text = (String) mListUsbAndroid.getItemAtPosition(position);
-				stackAFragment(text);
-			}else{
-				stackAFragment(new String());
-			}
-		}
-		else if(tabId.equals(TAB_LINUX_INFO)){
-			position = mListUsbLinux.getCheckedItemPosition();
-			if(position != ListView.INVALID_POSITION){
-				String text = (String) mListUsbLinux.getItemAtPosition(position);
-				stackAFragment(mLinuxUsbDeviceList.get(text));
-			}else{
-				stackAFragment(new String());
-			}
-
-		}
-	}
-
-
-	private void refreshUsbDevices(){
-
-		// Getting devices from API
-		{
-			mAndroidUsbDeviceList = mUsbManAndroid.getDeviceList();
-			String[] array = mAndroidUsbDeviceList.keySet().toArray(new String[mAndroidUsbDeviceList.keySet().size()]);
-
-			Arrays.sort(array);
-			
-			ArrayAdapter<String> adaptor = new ArrayAdapter<String>(getApplicationContext(), R.layout.list_item, array);
-			mListUsbAndroid.setAdapter(adaptor);
-			mTvDeviceCountAndroid.setText("Device List (" + mAndroidUsbDeviceList.size()+ "):");
-		}
-
-		// Getting devices from Linux subsystem
-		{
-			mLinuxUsbDeviceList = mUsbManagerLinux.getUsbDevices();
-			String[] array = mLinuxUsbDeviceList.keySet().toArray(new String[mLinuxUsbDeviceList.keySet().size()]);
-
-			Arrays.sort(array);
-			
-			ArrayAdapter<String> adaptor = new ArrayAdapter<String>(getApplicationContext(), R.layout.list_item, array);
-			mListUsbLinux.setAdapter(adaptor);
-			mTvDeviceCountLinux.setText("Device List (" + mLinuxUsbDeviceList.size()+ "):");
-		}
-	}
-
-	private void setupTabs() {
-		mTabHost.setup(); // you must call this before adding your tabs!
-		
-		mTabHost.addTab(newTab(TAB_ANDROID_INFO, R.string.label_tab_api, R.id.tab_1));
-		mTabHost.addTab(newTab(TAB_LINUX_INFO, R.string.label_tab_linux, R.id.tab_2));
-
-		mTabWidget = mTabHost.getTabWidget();
-		
-		for (int i = 0; i < mTabWidget.getChildCount(); i ++){
-			final TextView tv = (TextView) mTabWidget.getChildAt(i).findViewById(android.R.id.title);        
-			tv.setTextColor(this.getResources().getColorStateList(R.drawable.tab_text_selector));
-		}
-
-		mTabHost.setOnTabChangedListener(this);
-	}
-
-	private void stackAFragment(String usbKey) {
-		Fragment f = new UsbDeviceInfoAndroidFragment(usbKey);
-
-		FragmentTransaction ft = getFragmentManager().beginTransaction();
-		ft.replace(R.id.fragment_container, f);
-		ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN);
-
-		ft.commit();
-	}
-	
-	private void stackAFragment(SysBusUsbDevice usbDevice) {
-		Fragment f = new UsbDeviceInfoLinuxFragment(usbDevice);
-
-		FragmentTransaction ft = getFragmentManager().beginTransaction();
-		ft.replace(R.id.fragment_container, f);
-		ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN);
-
-		ft.commit();
-	}
-
-	private class DownloadFile extends AsyncTask<ArrayList<Pair<String, String>>, Integer, Boolean>{
-		// This is the message which will be shown on the progress bar
-		MessageFormat form = new MessageFormat("Downloading file: {0} of {1}...");
-
-		@Override
-		protected Boolean doInBackground(ArrayList<Pair<String, String>>... downloadLists ) {
-			int count;
-
-			URL url;
-			String filePath = "";
-			URLConnection conection;
-			InputStream is;
-			OutputStream os;
-			Boolean bOK = true;
-
-			
-			ArrayList<Pair<String, String>> downloads = downloadLists[0];
-			
-			int downloadCounter = 0;
-					
-			for( Pair<String, String> download : downloads){
-				try {
-					url = new URL(download.first);
-					filePath = download.second;
-
-					Log.d(TAG, "^ Downloading: " + url);
-					Log.d(TAG, "^ To         : " + filePath);
-
-					conection = url.openConnection();
-					conection.connect();
-					int lenghtOfFile = conection.getContentLength();
-
-					// download the file
-					is = new BufferedInputStream(url.openStream());
-					os = new FileOutputStream(filePath);
-
-					byte data[] = new byte[1024];
-
-					long total = 0;
-
-					while ((count = is.read(data)) != -1) {
-						total += count;
-						// The first number is the current file
-						// The second is the total number of files to download
-						// The third is the current progress
-						publishProgress(downloadCounter+1, downloads.size(), (int)(total*100/lenghtOfFile));
-						os.write(data, 0, count);
-					}
-
-					os.flush();
-					os.close();
-					is.close();
-					
-				} catch (Exception e) {
-					Log.e(TAG, "^ Error while downloading.", e);
-					bOK = false;
-					e.printStackTrace();
-				}	
-				
-				downloadCounter += 1;
-			}
-			
-			
-			
-//			String[][] pair = list[0];
-//			for(int i = 0; i < list[0].length; i++){
-//				
-//			}
-			return bOK;
-		}
-
-		@Override
-		protected void onPostExecute(Boolean result) {
-
-			if(result){ // The download is ok.
-				Toast.makeText(MainActivity.this, getString(R.string.download_ok), Toast.LENGTH_SHORT).show();
-			}else{     // There was an error.
-				Toast.makeText(MainActivity.this, getString(R.string.download_error), Toast.LENGTH_SHORT).show();
-			}
-
-			dialogFragmentDismiss(DIALOG_FRAGMENT_TAG);
-		}
-
-		@Override
-		protected void onPreExecute(){
-			dialogFragmentShow(DIALOG_FRAGMENT_TAG);
-		}
-		
-		@Override
-		public void onProgressUpdate(Integer... args){
-			Object[] testArgs = {args[0],args[1]};
-			dialogFragmentUpdate(DIALOG_FRAGMENT_TAG, form.format(testArgs), args[2]);
-		}
-	}
-}
+/*******************************************************************************
+ * Copyright 2011 Alexandros Schillings
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package aws.apps.usbDeviceEnumerator.activities;
+
+import java.io.BufferedInputStream;
+import java.io.File;
+import java.io.FileOutputStream;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.URL;
+import java.net.URLConnection;
+import java.text.MessageFormat;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.HashMap;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.DialogFragment;
+import android.app.Fragment;
+import android.app.FragmentTransaction;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.hardware.usb.UsbDevice;
+import android.hardware.usb.UsbManager;
+import android.os.AsyncTask;
+import android.os.Bundle;
+import android.os.Environment;
+import android.util.Log;
+import android.util.Pair;
+import android.view.Gravity;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.AdapterView.OnItemClickListener;
+import android.widget.ArrayAdapter;
+import android.widget.LinearLayout.LayoutParams;
+import android.widget.ListView;
+import android.widget.TabHost;
+import android.widget.TabHost.OnTabChangeListener;
+import android.widget.TabHost.TabSpec;
+import android.widget.TabWidget;
+import android.widget.TextView;
+import android.widget.Toast;
+import aws.apps.usbDeviceEnumerator.R;
+import aws.apps.usbDeviceEnumerator.data.DbAccessCompany;
+import aws.apps.usbDeviceEnumerator.data.DbAccessUsb;
+import aws.apps.usbDeviceEnumerator.data.ZipAccessCompany;
+import aws.apps.usbDeviceEnumerator.fragments.AbstractUsbDeviceInfoFragment;
+import aws.apps.usbDeviceEnumerator.fragments.ProgressDialogFragment;
+import aws.apps.usbDeviceEnumerator.fragments.UsbDeviceInfoAndroidFragment;
+import aws.apps.usbDeviceEnumerator.fragments.UsbDeviceInfoLinuxFragment;
+import aws.apps.usbDeviceEnumerator.usb.sysbususb.SysBusUsbDevice;
+import aws.apps.usbDeviceEnumerator.usb.sysbususb.SysBusUsbManager;
+import aws.apps.usbDeviceEnumerator.util.UsefulBits;
+
+public class MainActivity extends Activity implements OnTabChangeListener{
+	final String TAG =  this.getClass().getName();
+	private final String DIALOG_FRAGMENT_TAG = "progress_dialog";
+	
+	private final static String TAB_ANDROID_INFO = "Android";
+	private final static String TAB_LINUX_INFO = "Linux";
+
+	private UsefulBits mUsefulBits;
+	
+	private ListView mListUsbAndroid;
+	private TextView mTvDeviceCountAndroid;
+
+	private ListView mListUsbLinux;
+	private TextView mTvDeviceCountLinux;
+
+	private UsbManager mUsbManAndroid;
+	private SysBusUsbManager mUsbManagerLinux;
+
+	private DbAccessUsb mDbUsb;
+	private DbAccessCompany mDbComp;
+	private ZipAccessCompany mZipComp;
+	
+	private TabHost mTabHost;
+	private TabWidget mTabWidget;
+	private HashMap<String, UsbDevice> mAndroidUsbDeviceList;
+	private HashMap<String, SysBusUsbDevice> mLinuxUsbDeviceList;	
+
+	private boolean mIsSmallScreen = true;
+
+	private void dialogFragmentDismiss(String tag){
+		Log.d(TAG, "^ Dimissing Fragment : " + tag);
+		
+		DialogFragment dialog = (DialogFragment) getFragmentManager().findFragmentByTag(tag); 
+		if (dialog != null) { 
+			if(DIALOG_FRAGMENT_TAG.equals(tag)){
+				Log.d(TAG, "^ Dimissing Fragment!");
+				((ProgressDialogFragment) dialog).dismissAllowingStateLoss();
+			} else {
+				dialog.dismiss();
+			}
+		}
+	}
+
+	private void dialogFragmentShow(String tag){
+		FragmentTransaction ft = getFragmentManager().beginTransaction();
+	    Fragment prev = getFragmentManager().findFragmentByTag(tag);
+	    if (prev != null) {
+	        ft.remove(prev);
+	    }
+	    ft.addToBackStack(null);
+	    
+		DialogFragment newFragment = null;
+		if(DIALOG_FRAGMENT_TAG.equals(tag)){
+			newFragment	= ProgressDialogFragment.newInstance(getString(R.string.text_downloading_files), null);
+		}
+		ft.add(newFragment, tag);
+        ft.commitAllowingStateLoss();
+	}
+
+	private void dialogFragmentUpdate(String tag, String title, Integer progress){
+		DialogFragment dialogFragment = (DialogFragment) getFragmentManager().findFragmentByTag(tag); 
+		if (dialogFragment != null) { 
+			if(title != null){
+				((ProgressDialogFragment) dialogFragment).setTitle(title);
+			}
+			if(progress != null){
+				((ProgressDialogFragment) dialogFragment).setProgress(progress);
+			}
+		}
+	}
+	
+	private void displayAndroidUsbDeviceInfo(String device){
+		if(mIsSmallScreen){
+			Intent i = new Intent(getApplicationContext(), UsbInfoActivity.class);
+            i.putExtra(UsbInfoActivity.EXTRA_TYPE, AbstractUsbDeviceInfoFragment.TYPE_ANDROID_INFO);
+            i.putExtra(UsbInfoActivity.EXTRA_DATA_ANDROID, device);
+            startActivity(i);
+		} else {
+			stackAFragment(device);
+		}
+	}
+
+	private void displayLinuxUsbDeviceInfo(SysBusUsbDevice device){
+		if(mIsSmallScreen){
+			Intent i = new Intent(getApplicationContext(), UsbInfoActivity.class);
+            i.putExtra(UsbInfoActivity.EXTRA_TYPE, AbstractUsbDeviceInfoFragment.TYPE_LINUX_INFO);
+            i.putExtra(UsbInfoActivity.EXTRA_DATA_LINUX, device);
+            startActivity(i);
+		} else {
+			stackAFragment(device);
+		}
+	}
+
+	private View getListViewEmptyView(String text){
+		TextView emptyView = new TextView(getApplicationContext());
+		emptyView.setLayoutParams(new LayoutParams(LayoutParams.FILL_PARENT, LayoutParams.FILL_PARENT));
+		emptyView.setText(text);
+		emptyView.setTextSize(20f);
+		emptyView.setGravity(Gravity.CENTER_VERTICAL | Gravity.CENTER_HORIZONTAL);
+		return emptyView;
+	}
+
+	private void initialiseDbComponents(){
+		// Prompt user to DL db if it is missing.
+		if (!new File(mDbUsb.getLocalDbFullPath()).exists()){
+			mUsefulBits.ShowAlert(getString(R.string.alert_db_not_found_title), 
+					getString(R.string.alert_db_not_found_instructions), 
+					getString(android.R.string.ok));
+			Log.w(TAG, "^ Database not found: " + mDbUsb.getLocalDbFullPath());
+			return;
+		}
+	}
+
+	private boolean isSmallScreen(){
+		Boolean res;
+		if(findViewById(R.id.fragment_container) == null){
+			res = true;
+		} else {
+			res = false;
+		}
+		Log.d(TAG, "^ Is this device a small screen? " + res);
+		return res;
+	}
+
+	private TabSpec newTab(String tag, int labelId, int tabContentId) {
+		TabSpec tabSpec = mTabHost.newTabSpec(tag);
+		tabSpec.setIndicator(tag);
+		tabSpec.setContent(tabContentId);
+		return tabSpec;
+	}
+
+	/** Called when the activity is first created. */
+	@Override
+	public void onCreate(Bundle savedInstanceState) {
+		super.onCreate(savedInstanceState);
+		setContentView(R.layout.act_main);
+		mIsSmallScreen = isSmallScreen();
+		mUsefulBits = new UsefulBits(this);
+
+		mUsbManAndroid = (UsbManager) getSystemService(Context.USB_SERVICE);
+		mUsbManagerLinux = new SysBusUsbManager();
+		mTvDeviceCountAndroid = (TextView) findViewById(R.id.lbl_devices_api);
+		mTvDeviceCountLinux = (TextView) findViewById(R.id.lbl_devices_linux);
+
+		mTabHost = (TabHost)findViewById(android.R.id.tabhost);
+	
+		mDbUsb = new DbAccessUsb(this);
+		mDbComp = new DbAccessCompany(this);
+		mZipComp = new ZipAccessCompany(this);
+		
+		mListUsbAndroid = (ListView) findViewById(R.id.usb_list_api);
+		mListUsbAndroid.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
+		mListUsbAndroid.setOnItemClickListener(new OnItemClickListener() {
+
+			@Override
+			public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
+				mListUsbAndroid.setItemChecked(position, true);
+				displayAndroidUsbDeviceInfo(((TextView) view).getText().toString());
+			}
+		});
+		View emptyView = getListViewEmptyView(getString(R.string.label_empty_list));
+		((ViewGroup) mListUsbAndroid.getParent()).addView(emptyView);
+		mListUsbAndroid.setEmptyView(emptyView);
+		///
+		mListUsbLinux = (ListView) findViewById(R.id.usb_list_linux);
+		mListUsbLinux.setChoiceMode(ListView.CHOICE_MODE_SINGLE);
+		mListUsbLinux.setOnItemClickListener(new OnItemClickListener() {
+
+			@Override
+			public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
+				mListUsbLinux.setItemChecked(position, true);
+				displayLinuxUsbDeviceInfo( mLinuxUsbDeviceList.get(((TextView) view).getText().toString()));
+			}
+		});
+
+		emptyView = getListViewEmptyView(getString(R.string.label_empty_list));
+		((ViewGroup) mListUsbLinux.getParent()).addView(emptyView);
+		mListUsbLinux.setEmptyView(emptyView);
+
+		setupTabs();
+
+		initialiseDbComponents();
+		refreshUsbDevices();
+	}
+
+	/** Creates the menu items */
+	public boolean onCreateOptionsMenu(Menu menu) {
+		MenuInflater inflater = getMenuInflater();
+		inflater.inflate(R.menu.main_menu, menu);
+		return true;
+	}
+
+	/** Handles item selections */
+	public boolean onOptionsItemSelected(MenuItem item) {
+		switch (item.getItemId()) {
+		case R.id.menu_about:			
+			mUsefulBits.showAboutDialogue();
+			return true;
+		case R.id.menu_update_db:
+			if (!Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
+				Log.d(TAG, "^ SD card not available.");
+				mUsefulBits.showToast(getString(R.string.sd_not_available), Toast.LENGTH_SHORT, Gravity.TOP,0,0);
+				return true;
+			}
+
+			if (!mUsefulBits.createDirectories(mDbUsb.getLocalDbLocation())){return true;}
+			if (!mUsefulBits.createDirectories(mDbComp.getLocalDbLocation())){return true;}
+			if (!mUsefulBits.createDirectories(mZipComp.getLocalZipLocation())){return true;}
+
+			if (!mUsefulBits.isOnline()){  // If we are not online, cancel everything
+				mUsefulBits.ShowAlert(
+						getString(R.string.text_device_offline), 
+						getString(R.string.text_device_offline_instructions), 
+						getString(android.R.string.ok));
+				return true;
+			}
+
+			AlertDialog.Builder builder = new AlertDialog.Builder(this);
+			builder.setMessage(getString(R.string.alert_update_db))
+			.setPositiveButton(getString(android.R.string.yes), new DialogInterface.OnClickListener(){
+				@SuppressWarnings("unchecked")
+				@Override
+				public void onClick(DialogInterface dialog, int which) {
+					ArrayList<Pair<String, String>> downloads = new ArrayList<Pair<String, String>>();
+					
+					downloads.add(new Pair<String, String>(
+							getString(R.string.url_usb_db), 
+							mDbUsb.getLocalDbFullPath()));
+	
+					downloads.add(new Pair<String, String>(
+							getString(R.string.url_company_db), 
+							mDbComp.getLocalDbFullPath()));
+					
+					downloads.add(new Pair<String, String>(
+							getString(R.string.url_company_logo_zip), 
+							mZipComp.getLocalZipFullPath()));
+					
+					new DownloadFile().execute(downloads);
+				}
+
+			})
+			.setNegativeButton(getString(android.R.string.no), null).show();
+			return true;
+		case R.id.menu_refresh:
+			refreshUsbDevices();
+			return true;
+		}
+
+		return false;
+	}
+
+	@Override
+	public void onTabChanged(String tabId) {
+		if(mIsSmallScreen){ return; }
+		int position = -1;
+
+		if(tabId.equals(TAB_ANDROID_INFO)){
+			position = mListUsbAndroid.getCheckedItemPosition();
+			if(position != ListView.INVALID_POSITION){
+				String text = (String) mListUsbAndroid.getItemAtPosition(position);
+				stackAFragment(text);
+			}else{
+				stackAFragment(new String());
+			}
+		}
+		else if(tabId.equals(TAB_LINUX_INFO)){
+			position = mListUsbLinux.getCheckedItemPosition();
+			if(position != ListView.INVALID_POSITION){
+				String text = (String) mListUsbLinux.getItemAtPosition(position);
+				stackAFragment(mLinuxUsbDeviceList.get(text));
+			}else{
+				stackAFragment(new String());
+			}
+
+		}
+	}
+
+
+	private void refreshUsbDevices(){
+
+		// Getting devices from API
+		{
+			mAndroidUsbDeviceList = mUsbManAndroid.getDeviceList();
+			String[] array = mAndroidUsbDeviceList.keySet().toArray(new String[mAndroidUsbDeviceList.keySet().size()]);
+
+			Arrays.sort(array);
+			
+			ArrayAdapter<String> adaptor = new ArrayAdapter<String>(getApplicationContext(), R.layout.list_item, array);
+			mListUsbAndroid.setAdapter(adaptor);
+			mTvDeviceCountAndroid.setText("Device List (" + mAndroidUsbDeviceList.size()+ "):");
+		}
+
+		// Getting devices from Linux subsystem
+		{
+			mLinuxUsbDeviceList = mUsbManagerLinux.getUsbDevices();
+			String[] array = mLinuxUsbDeviceList.keySet().toArray(new String[mLinuxUsbDeviceList.keySet().size()]);
+
+			Arrays.sort(array);
+			
+			ArrayAdapter<String> adaptor = new ArrayAdapter<String>(getApplicationContext(), R.layout.list_item, array);
+			mListUsbLinux.setAdapter(adaptor);
+			mTvDeviceCountLinux.setText("Device List (" + mLinuxUsbDeviceList.size()+ "):");
+		}
+	}
+
+	private void setupTabs() {
+		mTabHost.setup(); // you must call this before adding your tabs!
+		
+		mTabHost.addTab(newTab(TAB_ANDROID_INFO, R.string.label_tab_api, R.id.tab_1));
+		mTabHost.addTab(newTab(TAB_LINUX_INFO, R.string.label_tab_linux, R.id.tab_2));
+
+		mTabWidget = mTabHost.getTabWidget();
+		
+		for (int i = 0; i < mTabWidget.getChildCount(); i ++){
+			final TextView tv = (TextView) mTabWidget.getChildAt(i).findViewById(android.R.id.title);        
+			tv.setTextColor(this.getResources().getColorStateList(R.drawable.tab_text_selector));
+		}
+
+		mTabHost.setOnTabChangedListener(this);
+	}
+
+	private void stackAFragment(String usbKey) {
+		Fragment f = new UsbDeviceInfoAndroidFragment(usbKey);
+
+		FragmentTransaction ft = getFragmentManager().beginTransaction();
+		ft.replace(R.id.fragment_container, f);
+		ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN);
+
+		ft.commit();
+	}
+	
+	private void stackAFragment(SysBusUsbDevice usbDevice) {
+		Fragment f = new UsbDeviceInfoLinuxFragment(usbDevice);
+
+		FragmentTransaction ft = getFragmentManager().beginTransaction();
+		ft.replace(R.id.fragment_container, f);
+		ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN);
+
+		ft.commit();
+	}
+
+	private class DownloadFile extends AsyncTask<ArrayList<Pair<String, String>>, Integer, Boolean>{
+		// This is the message which will be shown on the progress bar
+		MessageFormat form = new MessageFormat("Downloading file: {0} of {1}...");
+
+		@Override
+		protected Boolean doInBackground(ArrayList<Pair<String, String>>... downloadLists ) {
+			int count;
+
+			URL url;
+			String filePath = "";
+			URLConnection conection;
+			InputStream is;
+			OutputStream os;
+			Boolean bOK = true;
+
+			
+			ArrayList<Pair<String, String>> downloads = downloadLists[0];
+			
+			int downloadCounter = 0;
+					
+			for( Pair<String, String> download : downloads){
+				try {
+					url = new URL(download.first);
+					filePath = download.second;
+
+					Log.d(TAG, "^ Downloading: " + url);
+					Log.d(TAG, "^ To         : " + filePath);
+
+					conection = url.openConnection();
+					conection.connect();
+					int lenghtOfFile = conection.getContentLength();
+
+					// download the file
+					is = new BufferedInputStream(url.openStream());
+					os = new FileOutputStream(filePath);
+
+					byte data[] = new byte[1024];
+
+					long total = 0;
+
+					while ((count = is.read(data)) != -1) {
+						total += count;
+						// The first number is the current file
+						// The second is the total number of files to download
+						// The third is the current progress
+						publishProgress(downloadCounter+1, downloads.size(), (int)(total*100/lenghtOfFile));
+						os.write(data, 0, count);
+					}
+
+					os.flush();
+					os.close();
+					is.close();
+					
+				} catch (Exception e) {
+					Log.e(TAG, "^ Error while downloading.", e);
+					bOK = false;
+					e.printStackTrace();
+				}	
+				
+				downloadCounter += 1;
+			}
+			
+			
+			
+//			String[][] pair = list[0];
+//			for(int i = 0; i < list[0].length; i++){
+//				
+//			}
+			return bOK;
+		}
+
+		@Override
+		protected void onPostExecute(Boolean result) {
+
+			if(result){ // The download is ok.
+				Toast.makeText(MainActivity.this, getString(R.string.download_ok), Toast.LENGTH_SHORT).show();
+			}else{     // There was an error.
+				Toast.makeText(MainActivity.this, getString(R.string.download_error), Toast.LENGTH_SHORT).show();
+			}
+
+			dialogFragmentDismiss(DIALOG_FRAGMENT_TAG);
+		}
+
+		@Override
+		protected void onPreExecute(){
+			dialogFragmentShow(DIALOG_FRAGMENT_TAG);
+		}
+		
+		@Override
+		public void onProgressUpdate(Integer... args){
+			Object[] testArgs = {args[0],args[1]};
+			dialogFragmentUpdate(DIALOG_FRAGMENT_TAG, form.format(testArgs), args[2]);
+		}
+	}
+}
diff --git a/src/aws/apps/usbDeviceEnumerator/activities/UsbInfoActivity.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/activities/UsbInfoActivity.java
similarity index 97%
rename from src/aws/apps/usbDeviceEnumerator/activities/UsbInfoActivity.java
rename to app/src/main/java/aws/apps/usbDeviceEnumerator/activities/UsbInfoActivity.java
index b50bad3..b3f737a 100644
--- a/src/aws/apps/usbDeviceEnumerator/activities/UsbInfoActivity.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/activities/UsbInfoActivity.java
@@ -1,74 +1,74 @@
-/*******************************************************************************
- * Copyright 2011 Alexandros Schillings
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-package aws.apps.usbDeviceEnumerator.activities;
-
-import android.app.Activity;
-import android.app.Fragment;
-import android.app.FragmentTransaction;
-import android.os.Bundle;
-import aws.apps.usbDeviceEnumerator.R;
-import aws.apps.usbDeviceEnumerator.fragments.AbstractUsbDeviceInfoFragment;
-import aws.apps.usbDeviceEnumerator.fragments.UsbDeviceInfoAndroidFragment;
-import aws.apps.usbDeviceEnumerator.fragments.UsbDeviceInfoLinuxFragment;
-import aws.apps.usbDeviceEnumerator.usb.sysbususb.SysBusUsbDevice;
-
-public class UsbInfoActivity extends Activity{
-	public static final String EXTRA_TYPE =  "type";
-	public static final String EXTRA_DATA_ANDROID =  "data_android";
-	public static final String EXTRA_DATA_LINUX =  "data_linux";
-
-	/** Called when the activity is first created. */
-
-	private int mType;
-	private String mAndroidKey;
-	private SysBusUsbDevice mLinuxDevice;
-
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.act_usb_info);
-
-		Bundle b = getIntent().getExtras();
-		if(b!=null){
-			mType = b.getInt(EXTRA_TYPE);
-			mAndroidKey = b.getString(EXTRA_DATA_ANDROID);
-			mLinuxDevice = b.getParcelable(EXTRA_DATA_LINUX);
-
-			if (mType == AbstractUsbDeviceInfoFragment.TYPE_ANDROID_INFO){
-				Fragment f = new UsbDeviceInfoAndroidFragment(mAndroidKey);
-
-				FragmentTransaction ft = getFragmentManager().beginTransaction();
-				ft.replace(R.id.fragment_container, f);
-				ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN);
-
-				ft.commit();
-			} 
-			else if(mType == AbstractUsbDeviceInfoFragment.TYPE_LINUX_INFO){
-				Fragment f = new UsbDeviceInfoLinuxFragment(mLinuxDevice);
-
-				FragmentTransaction ft = getFragmentManager().beginTransaction();
-				ft.replace(R.id.fragment_container, f);
-				ft.setTransition(FragmentTransaction.TRANSIT_NONE);
-
-				ft.commit();
-			} else {
-				finish();
-			}
-		} else {
-			finish();
-		}
-	}
-}
+/*******************************************************************************
+ * Copyright 2011 Alexandros Schillings
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package aws.apps.usbDeviceEnumerator.activities;
+
+import android.app.Activity;
+import android.app.Fragment;
+import android.app.FragmentTransaction;
+import android.os.Bundle;
+import aws.apps.usbDeviceEnumerator.R;
+import aws.apps.usbDeviceEnumerator.fragments.AbstractUsbDeviceInfoFragment;
+import aws.apps.usbDeviceEnumerator.fragments.UsbDeviceInfoAndroidFragment;
+import aws.apps.usbDeviceEnumerator.fragments.UsbDeviceInfoLinuxFragment;
+import aws.apps.usbDeviceEnumerator.usb.sysbususb.SysBusUsbDevice;
+
+public class UsbInfoActivity extends Activity{
+	public static final String EXTRA_TYPE =  "type";
+	public static final String EXTRA_DATA_ANDROID =  "data_android";
+	public static final String EXTRA_DATA_LINUX =  "data_linux";
+
+	/** Called when the activity is first created. */
+
+	private int mType;
+	private String mAndroidKey;
+	private SysBusUsbDevice mLinuxDevice;
+
+	@Override
+	public void onCreate(Bundle savedInstanceState) {
+		super.onCreate(savedInstanceState);
+		setContentView(R.layout.act_usb_info);
+
+		Bundle b = getIntent().getExtras();
+		if(b!=null){
+			mType = b.getInt(EXTRA_TYPE);
+			mAndroidKey = b.getString(EXTRA_DATA_ANDROID);
+			mLinuxDevice = b.getParcelable(EXTRA_DATA_LINUX);
+
+			if (mType == AbstractUsbDeviceInfoFragment.TYPE_ANDROID_INFO){
+				Fragment f = new UsbDeviceInfoAndroidFragment(mAndroidKey);
+
+				FragmentTransaction ft = getFragmentManager().beginTransaction();
+				ft.replace(R.id.fragment_container, f);
+				ft.setTransition(FragmentTransaction.TRANSIT_FRAGMENT_OPEN);
+
+				ft.commit();
+			} 
+			else if(mType == AbstractUsbDeviceInfoFragment.TYPE_LINUX_INFO){
+				Fragment f = new UsbDeviceInfoLinuxFragment(mLinuxDevice);
+
+				FragmentTransaction ft = getFragmentManager().beginTransaction();
+				ft.replace(R.id.fragment_container, f);
+				ft.setTransition(FragmentTransaction.TRANSIT_NONE);
+
+				ft.commit();
+			} else {
+				finish();
+			}
+		} else {
+			finish();
+		}
+	}
+}
diff --git a/src/aws/apps/usbDeviceEnumerator/data/DbAccessCompany.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/data/DbAccessCompany.java
similarity index 96%
rename from src/aws/apps/usbDeviceEnumerator/data/DbAccessCompany.java
rename to app/src/main/java/aws/apps/usbDeviceEnumerator/data/DbAccessCompany.java
index 235ed0c..6652d45 100644
--- a/src/aws/apps/usbDeviceEnumerator/data/DbAccessCompany.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/data/DbAccessCompany.java
@@ -1,130 +1,130 @@
-/*******************************************************************************
- * Copyright 2011 Alexandros Schillings
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-package aws.apps.usbDeviceEnumerator.data;
-
-import java.io.File;
-
-import android.content.Context;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.os.Environment;
-import android.util.Log;
-import android.view.Gravity;
-import android.widget.Toast;
-import aws.apps.usbDeviceEnumerator.R;
-import aws.apps.usbDeviceEnumerator.util.UsefulBits;
-
-public class DbAccessCompany {
-	private final String TAG =  this.getClass().getName();
-	public final static String UNKNOWN_RESULT = "???";
-	private Context context;
-	private UsefulBits uB;
-
-	private String localDbLocation = "";
-	private String localDbFullPath = "";
-
-	private SQLiteDatabase db;
-
-	public DbAccessCompany(Context context){
-		this.context = context;
-		uB = new UsefulBits(context);
-		doDbPathStuff();
-	}
-
-	public boolean doDBChecks(){
-		if (!Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
-			Log.d(TAG, "^ SD card not available.");
-			uB.ShowAlert(context.getString(R.string.sd_error), 
-					context.getString(R.string.sd_not_available), 
-					context.getString(android.R.string.ok));
-			return false;
-		}
-
-		if (!new File(localDbFullPath).exists()){
-			uB.ShowAlert(context.getString(R.string.alert_db_not_found_title), 
-					context.getString(R.string.alert_db_not_found_instructions), 
-					context.getString(android.R.string.ok));
-			Log.e(TAG, "^ Database not found: " + localDbFullPath);
-			return false;
-		}
-
-		return true;
-	}
-
-	private void doDbPathStuff(){
-		localDbLocation = Environment.getExternalStorageDirectory() + context.getString(R.string.sd_db_location_company);
-		localDbFullPath = localDbLocation + context.getString(R.string.sd_db_name_company);
-	}
-
-	private Cursor executeQuery(String table, String[] fields, String where, String order){		
-
-		try {
-			db = SQLiteDatabase.openDatabase(localDbFullPath, null, SQLiteDatabase.OPEN_READONLY);
-
-			if(!db.isOpen()){
-				Log.e(TAG, "^ DB was not opened!");
-				uB.showToast(context.getString(R.string.error_could_not_open_db), 
-						Toast.LENGTH_SHORT, Gravity.TOP,0,0);
-				return null;
-			}
-
-			return db.query(table, fields, where, null, null, null, order);
-		} catch (Exception e) {
-			Log.e(TAG,"^ executeQuery(): " + e.getMessage());
-			if(db.isOpen()){db.close();}
-		}
-		return null;
-	}
-
-	public String getLocalDbFullPath(){
-		return localDbFullPath;
-	}
-
-	public String getLocalDbLocation(){
-		return localDbLocation;
-	}
-
-	public String getLogo(String CompanyNameString){
-		String result = "";
-		Cursor cur = executeQuery(  "companies, company_name_spellings", 
-				new String[]{"companies.logo"}, 
-				"company_name_spellings.company_name='" + CompanyNameString + 
-				"' AND company_name_spellings.companyId=companies._id", 
-				"companies.logo ASC");
-
-		if (cur!= null){
-			if(cur.getCount() > 0){
-				cur.moveToFirst();
-				result = cur.getString(cur.getColumnIndex("logo"));
-			} else {
-				result = UNKNOWN_RESULT;
-			}
-
-			if(!cur.isClosed()){cur.close();}
-			if(db.isOpen()){db.close();}
-		}
-
-		return tryNull(result, UNKNOWN_RESULT);
-	}
-
-
-	private String tryNull(String suspect, String defaultString){
-		if(suspect == null){
-			return defaultString;
-		}
-		return suspect;
-	}
-}
+/*******************************************************************************
+ * Copyright 2011 Alexandros Schillings
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package aws.apps.usbDeviceEnumerator.data;
+
+import java.io.File;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Environment;
+import android.util.Log;
+import android.view.Gravity;
+import android.widget.Toast;
+import aws.apps.usbDeviceEnumerator.R;
+import aws.apps.usbDeviceEnumerator.util.UsefulBits;
+
+public class DbAccessCompany {
+	private final String TAG =  this.getClass().getName();
+	public final static String UNKNOWN_RESULT = "???";
+	private Context context;
+	private UsefulBits uB;
+
+	private String localDbLocation = "";
+	private String localDbFullPath = "";
+
+	private SQLiteDatabase db;
+
+	public DbAccessCompany(Context context){
+		this.context = context;
+		uB = new UsefulBits(context);
+		doDbPathStuff();
+	}
+
+	public boolean doDBChecks(){
+		if (!Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
+			Log.d(TAG, "^ SD card not available.");
+			uB.ShowAlert(context.getString(R.string.sd_error), 
+					context.getString(R.string.sd_not_available), 
+					context.getString(android.R.string.ok));
+			return false;
+		}
+
+		if (!new File(localDbFullPath).exists()){
+			uB.ShowAlert(context.getString(R.string.alert_db_not_found_title), 
+					context.getString(R.string.alert_db_not_found_instructions), 
+					context.getString(android.R.string.ok));
+			Log.e(TAG, "^ Database not found: " + localDbFullPath);
+			return false;
+		}
+
+		return true;
+	}
+
+	private void doDbPathStuff(){
+		localDbLocation = Environment.getExternalStorageDirectory() + context.getString(R.string.sd_db_location_company);
+		localDbFullPath = localDbLocation + context.getString(R.string.sd_db_name_company);
+	}
+
+	private Cursor executeQuery(String table, String[] fields, String where, String order){		
+
+		try {
+			db = SQLiteDatabase.openDatabase(localDbFullPath, null, SQLiteDatabase.OPEN_READONLY);
+
+			if(!db.isOpen()){
+				Log.e(TAG, "^ DB was not opened!");
+				uB.showToast(context.getString(R.string.error_could_not_open_db), 
+						Toast.LENGTH_SHORT, Gravity.TOP,0,0);
+				return null;
+			}
+
+			return db.query(table, fields, where, null, null, null, order);
+		} catch (Exception e) {
+			Log.e(TAG,"^ executeQuery(): " + e.getMessage());
+			if(db.isOpen()){db.close();}
+		}
+		return null;
+	}
+
+	public String getLocalDbFullPath(){
+		return localDbFullPath;
+	}
+
+	public String getLocalDbLocation(){
+		return localDbLocation;
+	}
+
+	public String getLogo(String CompanyNameString){
+		String result = "";
+		Cursor cur = executeQuery(  "companies, company_name_spellings", 
+				new String[]{"companies.logo"}, 
+				"company_name_spellings.company_name='" + CompanyNameString + 
+				"' AND company_name_spellings.companyId=companies._id", 
+				"companies.logo ASC");
+
+		if (cur!= null){
+			if(cur.getCount() > 0){
+				cur.moveToFirst();
+				result = cur.getString(cur.getColumnIndex("logo"));
+			} else {
+				result = UNKNOWN_RESULT;
+			}
+
+			if(!cur.isClosed()){cur.close();}
+			if(db.isOpen()){db.close();}
+		}
+
+		return tryNull(result, UNKNOWN_RESULT);
+	}
+
+
+	private String tryNull(String suspect, String defaultString){
+		if(suspect == null){
+			return defaultString;
+		}
+		return suspect;
+	}
+}
diff --git a/src/aws/apps/usbDeviceEnumerator/data/DbAccessUsb.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/data/DbAccessUsb.java
similarity index 96%
rename from src/aws/apps/usbDeviceEnumerator/data/DbAccessUsb.java
rename to app/src/main/java/aws/apps/usbDeviceEnumerator/data/DbAccessUsb.java
index f46f92b..c7b647a 100644
--- a/src/aws/apps/usbDeviceEnumerator/data/DbAccessUsb.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/data/DbAccessUsb.java
@@ -1,157 +1,157 @@
-/*******************************************************************************
- * Copyright 2011 Alexandros Schillings
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-package aws.apps.usbDeviceEnumerator.data;
-
-import java.io.File;
-
-import android.content.Context;
-import android.database.Cursor;
-import android.database.sqlite.SQLiteDatabase;
-import android.os.Environment;
-import android.util.Log;
-import android.view.Gravity;
-import android.widget.Toast;
-import aws.apps.usbDeviceEnumerator.R;
-import aws.apps.usbDeviceEnumerator.util.UsefulBits;
-
-public class DbAccessUsb {
-	private final String TAG =  this.getClass().getName();
-	public final static String UNKNOWN_RESULT = "not in database";
-	private Context context;
-	private UsefulBits uB;
-
-	private String localDbLocation = "";
-	private String localDbFullPath = "";
-
-	private SQLiteDatabase db;
-
-	public DbAccessUsb(Context context){
-		this.context = context;
-		uB = new UsefulBits(context);
-		doDbPathStuff();
-	}
-
-	public boolean doDBChecks(){
-		if (!Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
-			Log.d(TAG, "^ SD card not available.");
-			uB.ShowAlert(context.getString(R.string.sd_error), 
-					context.getString(R.string.sd_not_available), 
-					context.getString(android.R.string.ok));
-			return false;
-		}
-
-		if (!new File(localDbFullPath).exists()){
-			uB.ShowAlert(context.getString(R.string.alert_db_not_found_title), 
-					context.getString(R.string.alert_db_not_found_instructions), 
-					context.getString(android.R.string.ok));
-			Log.e(TAG, "^ Database not found: " + localDbFullPath);
-			return false;
-		}
-
-		return true;
-	}
-
-	private void doDbPathStuff(){
-		localDbLocation = Environment.getExternalStorageDirectory() + context.getString(R.string.sd_db_location_usb);
-		localDbFullPath = localDbLocation + context.getString(R.string.sd_db_name_usb);
-	}
-	
-	private Cursor executeQuery(String table, String[] fields, String where, String order){		
-
-		try {
-			db = SQLiteDatabase.openDatabase(localDbFullPath, null, SQLiteDatabase.OPEN_READONLY);
-
-			if(!db.isOpen()){
-				Log.e(TAG, "^ DB was not opened!");
-				uB.showToast(context.getString(R.string.error_could_not_open_db), 
-						Toast.LENGTH_SHORT, Gravity.TOP,0,0);
-				return null;
-			}
-
-			return db.query(table, fields, where, null, null, null, order);
-		} catch (Exception e) {
-			Log.e(TAG,"^ executeQuery(): " + e.getMessage());
-			if(db.isOpen()){db.close();}
-		}
-		return null;
-	}
-
-
-	public String getLocalDbFullPath(){
-		return localDbFullPath;
-	}
-
-	public String getLocalDbLocation(){
-		return localDbLocation;
-	}
-
-	public String getProduct(String VID, String PID){
-		String result = "";
-		Cursor cur = executeQuery(  "usb", 
-				new String[]{"vid","vendor_name","did","device_name","ifid","interface_name"}, 
-				"did='" + PID + "' AND vid='" + VID + "'", 
-				"vid, did, ifid ASC");
-
-		if (cur!= null){
-			//Log.d(TAG, "^ getProduct(" + PID + "): " + cur.getCount());
-			if(cur.getCount() > 0){
-				cur.moveToFirst();
-				result = cur.getString(cur.getColumnIndex("device_name"));
-				cur.close();
-				db.close();
-			} else {
-				result = "not in db";
-			}
-			if(!cur.isClosed()){cur.close();}
-			if(db.isOpen()){db.close();}
-		}
-
-		return tryNull(result, UNKNOWN_RESULT);
-	}
-
-	public String getVendor(String VID){
-		String result = "";
-		Cursor cur = executeQuery(  "usb", 
-				new String[]{"vid","vendor_name","did","device_name","ifid","interface_name"}, 
-				"vid='" + VID +"' AND did=''", 
-				"vid, did, ifid ASC");
-
-		if (cur!= null){
-			//Log.d(TAG, "^ getVendor(" + VID + "): " + cur.getCount());
-			if(cur.getCount() > 0){
-				cur.moveToFirst();
-				result = cur.getString(cur.getColumnIndex("vendor_name"));
-				cur.close();
-				db.close();
-			} else {
-				result = UNKNOWN_RESULT;
-			}
-			
-			if(!cur.isClosed()){cur.close();}
-			if(db.isOpen()){db.close();}
-		}
-
-		return tryNull(result, UNKNOWN_RESULT);
-	}
-
-
-	private String tryNull(String suspect, String defaultString){
-		if(suspect == null){
-			return defaultString;
-		}
-		return suspect;
-	}
-}
+/*******************************************************************************
+ * Copyright 2011 Alexandros Schillings
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package aws.apps.usbDeviceEnumerator.data;
+
+import java.io.File;
+
+import android.content.Context;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.os.Environment;
+import android.util.Log;
+import android.view.Gravity;
+import android.widget.Toast;
+import aws.apps.usbDeviceEnumerator.R;
+import aws.apps.usbDeviceEnumerator.util.UsefulBits;
+
+public class DbAccessUsb {
+	private final String TAG =  this.getClass().getName();
+	public final static String UNKNOWN_RESULT = "not in database";
+	private Context context;
+	private UsefulBits uB;
+
+	private String localDbLocation = "";
+	private String localDbFullPath = "";
+
+	private SQLiteDatabase db;
+
+	public DbAccessUsb(Context context){
+		this.context = context;
+		uB = new UsefulBits(context);
+		doDbPathStuff();
+	}
+
+	public boolean doDBChecks(){
+		if (!Environment.MEDIA_MOUNTED.equals(Environment.getExternalStorageState())) {
+			Log.d(TAG, "^ SD card not available.");
+			uB.ShowAlert(context.getString(R.string.sd_error), 
+					context.getString(R.string.sd_not_available), 
+					context.getString(android.R.string.ok));
+			return false;
+		}
+
+		if (!new File(localDbFullPath).exists()){
+			uB.ShowAlert(context.getString(R.string.alert_db_not_found_title), 
+					context.getString(R.string.alert_db_not_found_instructions), 
+					context.getString(android.R.string.ok));
+			Log.e(TAG, "^ Database not found: " + localDbFullPath);
+			return false;
+		}
+
+		return true;
+	}
+
+	private void doDbPathStuff(){
+		localDbLocation = Environment.getExternalStorageDirectory() + context.getString(R.string.sd_db_location_usb);
+		localDbFullPath = localDbLocation + context.getString(R.string.sd_db_name_usb);
+	}
+	
+	private Cursor executeQuery(String table, String[] fields, String where, String order){		
+
+		try {
+			db = SQLiteDatabase.openDatabase(localDbFullPath, null, SQLiteDatabase.OPEN_READONLY);
+
+			if(!db.isOpen()){
+				Log.e(TAG, "^ DB was not opened!");
+				uB.showToast(context.getString(R.string.error_could_not_open_db), 
+						Toast.LENGTH_SHORT, Gravity.TOP,0,0);
+				return null;
+			}
+
+			return db.query(table, fields, where, null, null, null, order);
+		} catch (Exception e) {
+			Log.e(TAG,"^ executeQuery(): " + e.getMessage());
+			if(db.isOpen()){db.close();}
+		}
+		return null;
+	}
+
+
+	public String getLocalDbFullPath(){
+		return localDbFullPath;
+	}
+
+	public String getLocalDbLocation(){
+		return localDbLocation;
+	}
+
+	public String getProduct(String VID, String PID){
+		String result = "";
+		Cursor cur = executeQuery(  "usb", 
+				new String[]{"vid","vendor_name","did","device_name","ifid","interface_name"}, 
+				"did='" + PID + "' AND vid='" + VID + "'", 
+				"vid, did, ifid ASC");
+
+		if (cur!= null){
+			//Log.d(TAG, "^ getProduct(" + PID + "): " + cur.getCount());
+			if(cur.getCount() > 0){
+				cur.moveToFirst();
+				result = cur.getString(cur.getColumnIndex("device_name"));
+				cur.close();
+				db.close();
+			} else {
+				result = "not in db";
+			}
+			if(!cur.isClosed()){cur.close();}
+			if(db.isOpen()){db.close();}
+		}
+
+		return tryNull(result, UNKNOWN_RESULT);
+	}
+
+	public String getVendor(String VID){
+		String result = "";
+		Cursor cur = executeQuery(  "usb", 
+				new String[]{"vid","vendor_name","did","device_name","ifid","interface_name"}, 
+				"vid='" + VID +"' AND did=''", 
+				"vid, did, ifid ASC");
+
+		if (cur!= null){
+			//Log.d(TAG, "^ getVendor(" + VID + "): " + cur.getCount());
+			if(cur.getCount() > 0){
+				cur.moveToFirst();
+				result = cur.getString(cur.getColumnIndex("vendor_name"));
+				cur.close();
+				db.close();
+			} else {
+				result = UNKNOWN_RESULT;
+			}
+			
+			if(!cur.isClosed()){cur.close();}
+			if(db.isOpen()){db.close();}
+		}
+
+		return tryNull(result, UNKNOWN_RESULT);
+	}
+
+
+	private String tryNull(String suspect, String defaultString){
+		if(suspect == null){
+			return defaultString;
+		}
+		return suspect;
+	}
+}
diff --git a/src/aws/apps/usbDeviceEnumerator/data/ZipAccessCompany.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/data/ZipAccessCompany.java
similarity index 96%
rename from src/aws/apps/usbDeviceEnumerator/data/ZipAccessCompany.java
rename to app/src/main/java/aws/apps/usbDeviceEnumerator/data/ZipAccessCompany.java
index b9cff97..aae402d 100644
--- a/src/aws/apps/usbDeviceEnumerator/data/ZipAccessCompany.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/data/ZipAccessCompany.java
@@ -1,87 +1,87 @@
-/*******************************************************************************
- * Copyright 2011 Alexandros Schillings
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-package aws.apps.usbDeviceEnumerator.data;
-
-import java.io.FileInputStream;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.util.zip.ZipEntry;
-import java.util.zip.ZipInputStream;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.os.Environment;
-import android.util.Log;
-import aws.apps.usbDeviceEnumerator.R;
-
-public class ZipAccessCompany {
-	private final String TAG =  this.getClass().getName();
-	private Context context;
-
-	private String localZipLocation = "";
-	private String localZipFullPath = "";
-
-	public ZipAccessCompany(Context context){
-		this.context = context;
-		doPathStuff();
-	}
-
-	private void doPathStuff(){
-		localZipLocation = Environment.getExternalStorageDirectory() + context.getString(R.string.sd_zip_location_company);
-		localZipFullPath = localZipLocation + context.getString(R.string.sd_zip_name_company);
-	}
-
-	public String getLocalZipFullPath(){
-		return localZipFullPath;
-	}
-	
-	public String getLocalZipLocation(){
-		return localZipLocation;
-	}
-
-	public Bitmap getLogo(final String logo){
-		Log.d(TAG, "^ Getting logo '" + logo + "' from '" + localZipFullPath +"'");
-		Bitmap result = null;
-		try {
-			FileInputStream fis = new FileInputStream(localZipFullPath);
-			ZipInputStream zis = new ZipInputStream(fis);
-			ZipEntry ze = null;
-
-			// Until we find their map, or we run out of options
-			if(zis.getNextEntry()!=null) ze = zis.getNextEntry();
-
-			while ((ze = zis.getNextEntry()) != null) {
-                if (ze.getName().equals(logo)) {
-                	Log.d(TAG, "^ Found it!");
-                	result = BitmapFactory.decodeStream(zis);
-                    break;
-                } else {
-                	
-                }
-            } 
-			
-		} catch (FileNotFoundException e) {
-			Log.e(TAG, "^ Error opening zip file: ", e);
-			e.printStackTrace();
-		} catch (IOException e) {
-			Log.e(TAG, "^ Error opening zip file: ", e);
-			e.printStackTrace();
-		} 
-		
-		return result;
-	}
-}
+/*******************************************************************************
+ * Copyright 2011 Alexandros Schillings
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package aws.apps.usbDeviceEnumerator.data;
+
+import java.io.FileInputStream;
+import java.io.FileNotFoundException;
+import java.io.IOException;
+import java.util.zip.ZipEntry;
+import java.util.zip.ZipInputStream;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.BitmapFactory;
+import android.os.Environment;
+import android.util.Log;
+import aws.apps.usbDeviceEnumerator.R;
+
+public class ZipAccessCompany {
+	private final String TAG =  this.getClass().getName();
+	private Context context;
+
+	private String localZipLocation = "";
+	private String localZipFullPath = "";
+
+	public ZipAccessCompany(Context context){
+		this.context = context;
+		doPathStuff();
+	}
+
+	private void doPathStuff(){
+		localZipLocation = Environment.getExternalStorageDirectory() + context.getString(R.string.sd_zip_location_company);
+		localZipFullPath = localZipLocation + context.getString(R.string.sd_zip_name_company);
+	}
+
+	public String getLocalZipFullPath(){
+		return localZipFullPath;
+	}
+	
+	public String getLocalZipLocation(){
+		return localZipLocation;
+	}
+
+	public Bitmap getLogo(final String logo){
+		Log.d(TAG, "^ Getting logo '" + logo + "' from '" + localZipFullPath +"'");
+		Bitmap result = null;
+		try {
+			FileInputStream fis = new FileInputStream(localZipFullPath);
+			ZipInputStream zis = new ZipInputStream(fis);
+			ZipEntry ze = null;
+
+			// Until we find their map, or we run out of options
+			if(zis.getNextEntry()!=null) ze = zis.getNextEntry();
+
+			while ((ze = zis.getNextEntry()) != null) {
+                if (ze.getName().equals(logo)) {
+                	Log.d(TAG, "^ Found it!");
+                	result = BitmapFactory.decodeStream(zis);
+                    break;
+                } else {
+                	
+                }
+            } 
+			
+		} catch (FileNotFoundException e) {
+			Log.e(TAG, "^ Error opening zip file: ", e);
+			e.printStackTrace();
+		} catch (IOException e) {
+			Log.e(TAG, "^ Error opening zip file: ", e);
+			e.printStackTrace();
+		} 
+		
+		return result;
+	}
+}
diff --git a/src/aws/apps/usbDeviceEnumerator/fragments/AbstractUsbDeviceInfoFragment.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/fragments/AbstractUsbDeviceInfoFragment.java
similarity index 97%
rename from src/aws/apps/usbDeviceEnumerator/fragments/AbstractUsbDeviceInfoFragment.java
rename to app/src/main/java/aws/apps/usbDeviceEnumerator/fragments/AbstractUsbDeviceInfoFragment.java
index 1ab6158..5b8c754 100644
--- a/src/aws/apps/usbDeviceEnumerator/fragments/AbstractUsbDeviceInfoFragment.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/fragments/AbstractUsbDeviceInfoFragment.java
@@ -1,55 +1,55 @@
-/*******************************************************************************
- * Copyright 2011 Alexandros Schillings
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-package aws.apps.usbDeviceEnumerator.fragments;
-
-import android.app.Fragment;
-import android.os.Bundle;
-import android.view.Menu;
-import android.view.MenuInflater;
-import android.view.MenuItem;
-import aws.apps.usbDeviceEnumerator.R;
-import aws.apps.usbDeviceEnumerator.util.UsefulBits;
-
-public abstract class AbstractUsbDeviceInfoFragment extends Fragment{
-	public final static int TYPE_ANDROID_INFO = 0;
-	public final static int TYPE_LINUX_INFO = 1;
-	
-	public abstract int getType();
-	@Override
-    public void onCreate(Bundle saved) {
-        super.onCreate(saved);
-        setHasOptionsMenu(true);
-    }
-	
-    @Override
-    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
-    	inflater.inflate(R.menu.frag_menu, menu);
-        super.onCreateOptionsMenu(menu, inflater);
-
-    }
-    
-	@Override
-	public boolean onOptionsItemSelected(MenuItem item) {
-		switch (item.getItemId()) {
-		case R.id.menu_export:
-				UsefulBits.share(getActivity(), "USB Info", this.toString());
-				return true;
-		}
-		return false;
-	}
-	
-    public abstract String toString();
-}
+/*******************************************************************************
+ * Copyright 2011 Alexandros Schillings
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package aws.apps.usbDeviceEnumerator.fragments;
+
+import android.app.Fragment;
+import android.os.Bundle;
+import android.view.Menu;
+import android.view.MenuInflater;
+import android.view.MenuItem;
+import aws.apps.usbDeviceEnumerator.R;
+import aws.apps.usbDeviceEnumerator.util.UsefulBits;
+
+public abstract class AbstractUsbDeviceInfoFragment extends Fragment{
+	public final static int TYPE_ANDROID_INFO = 0;
+	public final static int TYPE_LINUX_INFO = 1;
+	
+	public abstract int getType();
+	@Override
+    public void onCreate(Bundle saved) {
+        super.onCreate(saved);
+        setHasOptionsMenu(true);
+    }
+	
+    @Override
+    public void onCreateOptionsMenu(Menu menu, MenuInflater inflater) {
+    	inflater.inflate(R.menu.frag_menu, menu);
+        super.onCreateOptionsMenu(menu, inflater);
+
+    }
+    
+	@Override
+	public boolean onOptionsItemSelected(MenuItem item) {
+		switch (item.getItemId()) {
+		case R.id.menu_export:
+				UsefulBits.share(getActivity(), "USB Info", this.toString());
+				return true;
+		}
+		return false;
+	}
+	
+    public abstract String toString();
+}
diff --git a/src/aws/apps/usbDeviceEnumerator/fragments/ProgressDialogFragment.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/fragments/ProgressDialogFragment.java
similarity index 96%
rename from src/aws/apps/usbDeviceEnumerator/fragments/ProgressDialogFragment.java
rename to app/src/main/java/aws/apps/usbDeviceEnumerator/fragments/ProgressDialogFragment.java
index 9618cbe..3355c62 100644
--- a/src/aws/apps/usbDeviceEnumerator/fragments/ProgressDialogFragment.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/fragments/ProgressDialogFragment.java
@@ -1,61 +1,61 @@
-package aws.apps.usbDeviceEnumerator.fragments;
-
-import android.app.Dialog;
-import android.app.DialogFragment;
-import android.app.ProgressDialog;
-import android.os.Bundle;
-
-public class ProgressDialogFragment extends DialogFragment {
-
-	public static ProgressDialogFragment newInstance(String title, String message) {
-		ProgressDialogFragment frag = new ProgressDialogFragment();
-		Bundle args = new Bundle();
-		args.putString("title", title);
-		args.putString("message", message);
-		frag.setArguments(args);
-		return frag;
-	};
-
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setRetainInstance(true);
-	}
-
-	@Override
-	public Dialog onCreateDialog(Bundle savedInstanceState) {
-		String title = getArguments().getString("title");
-		String message = getArguments().getString("message");
-
-		ProgressDialog dialog = new ProgressDialog(getActivity());
-		dialog.setTitle(title);
-
-		if (message != null) {
-			dialog.setMessage(message);
-		}
-		dialog.setIndeterminate(false);
-		dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
-		dialog.setCancelable(false);
-		dialog.setCanceledOnTouchOutside(false);
-		return dialog;
-	}
-
-	public void setMessage(String message) {
-		 ((ProgressDialog) this.getDialog()).setMessage(message);
-	}
-
-	public void setTitle(String message) {
-		 ((ProgressDialog) this.getDialog()).setTitle(message);
-	}
-
-	public void setProgress(int progress) {
-		 ((ProgressDialog) this.getDialog()).setProgress(progress);
-	}
-
-	@Override
-	public void onDestroyView() {
-		if (getDialog() != null && getRetainInstance())
-			getDialog().setDismissMessage(null);
-		super.onDestroyView();
-	}
-}
+package aws.apps.usbDeviceEnumerator.fragments;
+
+import android.app.Dialog;
+import android.app.DialogFragment;
+import android.app.ProgressDialog;
+import android.os.Bundle;
+
+public class ProgressDialogFragment extends DialogFragment {
+
+	public static ProgressDialogFragment newInstance(String title, String message) {
+		ProgressDialogFragment frag = new ProgressDialogFragment();
+		Bundle args = new Bundle();
+		args.putString("title", title);
+		args.putString("message", message);
+		frag.setArguments(args);
+		return frag;
+	};
+
+	@Override
+	public void onCreate(Bundle savedInstanceState) {
+		super.onCreate(savedInstanceState);
+		setRetainInstance(true);
+	}
+
+	@Override
+	public Dialog onCreateDialog(Bundle savedInstanceState) {
+		String title = getArguments().getString("title");
+		String message = getArguments().getString("message");
+
+		ProgressDialog dialog = new ProgressDialog(getActivity());
+		dialog.setTitle(title);
+
+		if (message != null) {
+			dialog.setMessage(message);
+		}
+		dialog.setIndeterminate(false);
+		dialog.setProgressStyle(ProgressDialog.STYLE_HORIZONTAL);
+		dialog.setCancelable(false);
+		dialog.setCanceledOnTouchOutside(false);
+		return dialog;
+	}
+
+	public void setMessage(String message) {
+		 ((ProgressDialog) this.getDialog()).setMessage(message);
+	}
+
+	public void setTitle(String message) {
+		 ((ProgressDialog) this.getDialog()).setTitle(message);
+	}
+
+	public void setProgress(int progress) {
+		 ((ProgressDialog) this.getDialog()).setProgress(progress);
+	}
+
+	@Override
+	public void onDestroyView() {
+		if (getDialog() != null && getRetainInstance())
+			getDialog().setDismissMessage(null);
+		super.onDestroyView();
+	}
+}
diff --git a/src/aws/apps/usbDeviceEnumerator/fragments/UsbDeviceInfoAndroidFragment.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/fragments/UsbDeviceInfoAndroidFragment.java
similarity index 97%
rename from src/aws/apps/usbDeviceEnumerator/fragments/UsbDeviceInfoAndroidFragment.java
rename to app/src/main/java/aws/apps/usbDeviceEnumerator/fragments/UsbDeviceInfoAndroidFragment.java
index 93cf2d5..2ce8089 100644
--- a/src/aws/apps/usbDeviceEnumerator/fragments/UsbDeviceInfoAndroidFragment.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/fragments/UsbDeviceInfoAndroidFragment.java
@@ -1,226 +1,226 @@
-/*******************************************************************************
- * Copyright 2011 Alexandros Schillings
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-package aws.apps.usbDeviceEnumerator.fragments;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.drawable.BitmapDrawable;
-import android.graphics.drawable.Drawable;
-import android.hardware.usb.UsbDevice;
-import android.hardware.usb.UsbEndpoint;
-import android.hardware.usb.UsbInterface;
-import android.hardware.usb.UsbManager;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ImageButton;
-import android.widget.LinearLayout;
-import android.widget.TableLayout;
-import android.widget.TableRow;
-import android.widget.TextView;
-import aws.apps.usbDeviceEnumerator.R;
-import aws.apps.usbDeviceEnumerator.data.DbAccessCompany;
-import aws.apps.usbDeviceEnumerator.data.DbAccessUsb;
-import aws.apps.usbDeviceEnumerator.data.ZipAccessCompany;
-import aws.apps.usbDeviceEnumerator.usb.UsbConstants;
-import aws.apps.usbDeviceEnumerator.util.UsefulBits;
-
-public class UsbDeviceInfoAndroidFragment extends AbstractUsbDeviceInfoFragment {
-	private final String TAG =  this.getClass().getName();
-
-	private final static String BUNDLE_USB_KEY = "BUNDLE_USBKEY";
-
-	public final static int TYPE_ANDROID_INFO = 0;
-	public final static int TYPE_LINUX_INFO = 1;	
-
-	public final static String DEFAULT_STRING = "???";
-	private String usbKey = DEFAULT_STRING;
-	private TableLayout tblUsbInfoHeader;
-	private TableLayout tblUsbInfoTop;
-	private TableLayout tblUsbInfoBottom;
-	private TextView tvVID;
-	private TextView tvPID;
-	private TextView tvVendorDb;
-	private TextView tvProductDb;		
-	private TextView tvDevicePath;
-	private TextView tvDeviceClass;
-	private ImageButton btnLogo;
-	private UsbManager usbMan;
-	private DbAccessUsb dbUsb;
-	private DbAccessCompany dbComp;
-	private ZipAccessCompany zipComp;
-
-	private Context context;
-	public UsbDeviceInfoAndroidFragment() {
-
-	}
-
-	public UsbDeviceInfoAndroidFragment(String usbKey) {
-		this.usbKey = usbKey;
-	}
-
-	private void addDataRow(LayoutInflater inflater, TableLayout tlb, String cell1Text, String cell2Text){
-		TableRow row = (TableRow)inflater.inflate(R.layout.usb_table_row_data, null);
-		TextView tv1 = (TextView) row.findViewById(R.id.usb_tablerow_cell1);
-		TextView tv2 = (TextView) row.findViewById(R.id.usb_tablerow_cell2);
-		tv1.setText(cell1Text);
-		tv2.setText(cell2Text);
-		tlb.addView(row);
-	}
-
-	@Override
-	public int getType() {
-		return TYPE_ANDROID_INFO;
-	}
-
-	private void loadLogo(String logo){
-		Drawable d = context.getResources().getDrawable(R.drawable.no_image);
-		Bitmap b = zipComp.getLogo(logo);
-
-		if(b != null){
-			d = new BitmapDrawable(b);
-		} else {
-			Log.w(TAG, "^ Bitmap is null");
-		}
-
-		btnLogo.setImageDrawable(d);
-	}
-
-	/**
-	 * If we are being created with saved state, restore our state
-	 */
-	@Override
-	public void onCreate(Bundle saved) {
-		super.onCreate(saved);
-		if (null != saved) {
-			usbKey = saved.getString(BUNDLE_USB_KEY);
-		}
-	}
-
-
-	@Override
-	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle saved) {   	
-		View v = new LinearLayout(getActivity().getApplicationContext());
-		context = getActivity().getApplicationContext();
-		usbMan = (UsbManager) context.getSystemService(Context.USB_SERVICE);
-
-
-		if (usbMan == null || usbMan.getDeviceList().get(usbKey) == null) {
-			return v;
-		} else {
-			v = inflater.inflate(R.layout.usb_info_android, container, false);
-		}
-
-		tblUsbInfoHeader = (TableLayout) v.findViewById(R.id.tblUsbInfo_title);
-		tblUsbInfoTop = (TableLayout) v.findViewById(R.id.tblUsbInfo_top);
-		tblUsbInfoBottom = (TableLayout) v.findViewById(R.id.tblUsbInfo_bottom);
-		tvVID = ((TextView) v.findViewById(R.id.tvVID));
-		tvPID = ((TextView) v.findViewById(R.id.tvPID));
-		tvProductDb = ((TextView) v.findViewById(R.id.tvProductDb));
-		tvVendorDb = ((TextView) v.findViewById(R.id.tvVendorDb));
-		tvDevicePath = ((TextView) v.findViewById(R.id.tvDevicePath));
-		tvDeviceClass = ((TextView) v.findViewById(R.id.tvDeviceClass));
-		btnLogo = (ImageButton) v.findViewById(R.id.btnLogo);
-		btnLogo.setImageDrawable(context.getResources().getDrawable(R.drawable.no_image));
-		dbUsb = new DbAccessUsb(context);
-		dbComp = new DbAccessCompany(context);
-		zipComp = new ZipAccessCompany(context);
-
-		populateAndroidTable(inflater);
-
-		return v;
-	}
-
-	@Override
-	public void onSaveInstanceState(Bundle toSave) {
-		toSave.putString(BUNDLE_USB_KEY, usbKey);
-	}
-
-	private String padLeft(String string, String padding, int size){
-		String pad = "";
-		while((pad+string).length() < size){
-			pad += padding + pad;
-		}
-		return pad+string;
-	}
-
-	private void populateAndroidTable(LayoutInflater inflater){
-		UsbDevice device = usbMan.getDeviceList().get(usbKey);
-		tvDevicePath.setText(usbKey);
-
-		if(device != null){  		
-			tvVID.setText(padLeft(Integer.toHexString(device.getVendorId()),"0",4));
-			tvPID.setText(padLeft(Integer.toHexString(device.getDeviceId()),"0",4));
-			tvDeviceClass.setText(UsbConstants.resolveUsbClass(device.getDeviceClass()));
-			if(dbUsb.doDBChecks()){
-				String vid = tvVID.getText().toString();
-				String pid = tvPID.getText().toString();
-				String vendor_name = dbUsb.getVendor(vid);
-
-				tvVendorDb.setText(vendor_name);
-				tvProductDb.setText(dbUsb.getProduct(vid, pid));
-
-
-				if(dbComp.doDBChecks()){
-					String logo = dbComp.getLogo(vendor_name);
-					loadLogo(logo);
-				}
-			}
-
-			UsbInterface iface;
-			for(int i = 0 ; i < device.getInterfaceCount() ; i++){
-				iface = device.getInterface(i);
-				if(iface != null){
-
-					addDataRow(inflater, tblUsbInfoBottom, getActivity().getString(R.string.interface_) + i, "");
-					addDataRow(inflater, tblUsbInfoBottom, getActivity().getString(R.string.class_), UsbConstants.resolveUsbClass((iface.getInterfaceClass())));
-
-					String endpointText = getActivity().getString(R.string.none);
-					if(iface.getEndpointCount() > 0){
-						UsbEndpoint endpoint;
-						for(int j=0; j < iface.getEndpointCount(); j++){
-							endpoint = iface.getEndpoint(j);
-							endpointText = "#" + j + "\n";
-							endpointText += getActivity().getString(R.string.address_) + endpoint.getAddress() + " (" + padLeft(Integer.toBinaryString(endpoint.getAddress()), "0", 8) + ")\n";
-							endpointText += getActivity().getString(R.string.number_) + endpoint.getEndpointNumber() + "\n";
-							endpointText += getActivity().getString(R.string.direction_) + UsbConstants.resolveUsbEndpointDirection(endpoint.getDirection()) + "\n";        					
-							endpointText += getActivity().getString(R.string.type_) + UsbConstants.resolveUsbEndpointType(endpoint.getType()) + "\n";
-							endpointText += getActivity().getString(R.string.poll_interval_) + endpoint.getInterval() + "\n";
-							endpointText += getActivity().getString(R.string.max_packet_size_) + endpoint.getMaxPacketSize() + "\n";
-							endpointText += getActivity().getString(R.string.attributes_) + padLeft(Integer.toBinaryString(endpoint.getAttributes()), "0", 8);
-							addDataRow(inflater, tblUsbInfoBottom, "\t" + getActivity().getString(R.string.endpoint_), endpointText);
-						}
-					} else {
-						addDataRow(inflater, tblUsbInfoBottom, "\tEndpoints:", "none");
-					}
-				}
-			}
-		}
-	}
-
-	@Override
-	public String toString() {
-		StringBuilder sb = new StringBuilder();
-		UsefulBits uB = new UsefulBits(getActivity());
-		sb.append(uB.tableToString(tblUsbInfoHeader));
-		sb.append(uB.tableToString(tblUsbInfoTop));
-		sb.append("\n");
-		sb.append(uB.tableToString(tblUsbInfoBottom));
-		return sb.toString();
-	}
-}
+/*******************************************************************************
+ * Copyright 2011 Alexandros Schillings
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package aws.apps.usbDeviceEnumerator.fragments;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.hardware.usb.UsbDevice;
+import android.hardware.usb.UsbEndpoint;
+import android.hardware.usb.UsbInterface;
+import android.hardware.usb.UsbManager;
+import android.os.Bundle;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageButton;
+import android.widget.LinearLayout;
+import android.widget.TableLayout;
+import android.widget.TableRow;
+import android.widget.TextView;
+import aws.apps.usbDeviceEnumerator.R;
+import aws.apps.usbDeviceEnumerator.data.DbAccessCompany;
+import aws.apps.usbDeviceEnumerator.data.DbAccessUsb;
+import aws.apps.usbDeviceEnumerator.data.ZipAccessCompany;
+import aws.apps.usbDeviceEnumerator.usb.UsbConstants;
+import aws.apps.usbDeviceEnumerator.util.UsefulBits;
+
+public class UsbDeviceInfoAndroidFragment extends AbstractUsbDeviceInfoFragment {
+	private final String TAG =  this.getClass().getName();
+
+	private final static String BUNDLE_USB_KEY = "BUNDLE_USBKEY";
+
+	public final static int TYPE_ANDROID_INFO = 0;
+	public final static int TYPE_LINUX_INFO = 1;	
+
+	public final static String DEFAULT_STRING = "???";
+	private String usbKey = DEFAULT_STRING;
+	private TableLayout tblUsbInfoHeader;
+	private TableLayout tblUsbInfoTop;
+	private TableLayout tblUsbInfoBottom;
+	private TextView tvVID;
+	private TextView tvPID;
+	private TextView tvVendorDb;
+	private TextView tvProductDb;		
+	private TextView tvDevicePath;
+	private TextView tvDeviceClass;
+	private ImageButton btnLogo;
+	private UsbManager usbMan;
+	private DbAccessUsb dbUsb;
+	private DbAccessCompany dbComp;
+	private ZipAccessCompany zipComp;
+
+	private Context context;
+	public UsbDeviceInfoAndroidFragment() {
+
+	}
+
+	public UsbDeviceInfoAndroidFragment(String usbKey) {
+		this.usbKey = usbKey;
+	}
+
+	private void addDataRow(LayoutInflater inflater, TableLayout tlb, String cell1Text, String cell2Text){
+		TableRow row = (TableRow)inflater.inflate(R.layout.usb_table_row_data, null);
+		TextView tv1 = (TextView) row.findViewById(R.id.usb_tablerow_cell1);
+		TextView tv2 = (TextView) row.findViewById(R.id.usb_tablerow_cell2);
+		tv1.setText(cell1Text);
+		tv2.setText(cell2Text);
+		tlb.addView(row);
+	}
+
+	@Override
+	public int getType() {
+		return TYPE_ANDROID_INFO;
+	}
+
+	private void loadLogo(String logo){
+		Drawable d = context.getResources().getDrawable(R.drawable.no_image);
+		Bitmap b = zipComp.getLogo(logo);
+
+		if(b != null){
+			d = new BitmapDrawable(b);
+		} else {
+			Log.w(TAG, "^ Bitmap is null");
+		}
+
+		btnLogo.setImageDrawable(d);
+	}
+
+	/**
+	 * If we are being created with saved state, restore our state
+	 */
+	@Override
+	public void onCreate(Bundle saved) {
+		super.onCreate(saved);
+		if (null != saved) {
+			usbKey = saved.getString(BUNDLE_USB_KEY);
+		}
+	}
+
+
+	@Override
+	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle saved) {   	
+		View v = new LinearLayout(getActivity().getApplicationContext());
+		context = getActivity().getApplicationContext();
+		usbMan = (UsbManager) context.getSystemService(Context.USB_SERVICE);
+
+
+		if (usbMan == null || usbMan.getDeviceList().get(usbKey) == null) {
+			return v;
+		} else {
+			v = inflater.inflate(R.layout.usb_info_android, container, false);
+		}
+
+		tblUsbInfoHeader = (TableLayout) v.findViewById(R.id.tblUsbInfo_title);
+		tblUsbInfoTop = (TableLayout) v.findViewById(R.id.tblUsbInfo_top);
+		tblUsbInfoBottom = (TableLayout) v.findViewById(R.id.tblUsbInfo_bottom);
+		tvVID = ((TextView) v.findViewById(R.id.tvVID));
+		tvPID = ((TextView) v.findViewById(R.id.tvPID));
+		tvProductDb = ((TextView) v.findViewById(R.id.tvProductDb));
+		tvVendorDb = ((TextView) v.findViewById(R.id.tvVendorDb));
+		tvDevicePath = ((TextView) v.findViewById(R.id.tvDevicePath));
+		tvDeviceClass = ((TextView) v.findViewById(R.id.tvDeviceClass));
+		btnLogo = (ImageButton) v.findViewById(R.id.btnLogo);
+		btnLogo.setImageDrawable(context.getResources().getDrawable(R.drawable.no_image));
+		dbUsb = new DbAccessUsb(context);
+		dbComp = new DbAccessCompany(context);
+		zipComp = new ZipAccessCompany(context);
+
+		populateAndroidTable(inflater);
+
+		return v;
+	}
+
+	@Override
+	public void onSaveInstanceState(Bundle toSave) {
+		toSave.putString(BUNDLE_USB_KEY, usbKey);
+	}
+
+	private String padLeft(String string, String padding, int size){
+		String pad = "";
+		while((pad+string).length() < size){
+			pad += padding + pad;
+		}
+		return pad+string;
+	}
+
+	private void populateAndroidTable(LayoutInflater inflater){
+		UsbDevice device = usbMan.getDeviceList().get(usbKey);
+		tvDevicePath.setText(usbKey);
+
+		if(device != null){  		
+			tvVID.setText(padLeft(Integer.toHexString(device.getVendorId()),"0",4));
+			tvPID.setText(padLeft(Integer.toHexString(device.getDeviceId()),"0",4));
+			tvDeviceClass.setText(UsbConstants.resolveUsbClass(device.getDeviceClass()));
+			if(dbUsb.doDBChecks()){
+				String vid = tvVID.getText().toString();
+				String pid = tvPID.getText().toString();
+				String vendor_name = dbUsb.getVendor(vid);
+
+				tvVendorDb.setText(vendor_name);
+				tvProductDb.setText(dbUsb.getProduct(vid, pid));
+
+
+				if(dbComp.doDBChecks()){
+					String logo = dbComp.getLogo(vendor_name);
+					loadLogo(logo);
+				}
+			}
+
+			UsbInterface iface;
+			for(int i = 0 ; i < device.getInterfaceCount() ; i++){
+				iface = device.getInterface(i);
+				if(iface != null){
+
+					addDataRow(inflater, tblUsbInfoBottom, getActivity().getString(R.string.interface_) + i, "");
+					addDataRow(inflater, tblUsbInfoBottom, getActivity().getString(R.string.class_), UsbConstants.resolveUsbClass((iface.getInterfaceClass())));
+
+					String endpointText = getActivity().getString(R.string.none);
+					if(iface.getEndpointCount() > 0){
+						UsbEndpoint endpoint;
+						for(int j=0; j < iface.getEndpointCount(); j++){
+							endpoint = iface.getEndpoint(j);
+							endpointText = "#" + j + "\n";
+							endpointText += getActivity().getString(R.string.address_) + endpoint.getAddress() + " (" + padLeft(Integer.toBinaryString(endpoint.getAddress()), "0", 8) + ")\n";
+							endpointText += getActivity().getString(R.string.number_) + endpoint.getEndpointNumber() + "\n";
+							endpointText += getActivity().getString(R.string.direction_) + UsbConstants.resolveUsbEndpointDirection(endpoint.getDirection()) + "\n";        					
+							endpointText += getActivity().getString(R.string.type_) + UsbConstants.resolveUsbEndpointType(endpoint.getType()) + "\n";
+							endpointText += getActivity().getString(R.string.poll_interval_) + endpoint.getInterval() + "\n";
+							endpointText += getActivity().getString(R.string.max_packet_size_) + endpoint.getMaxPacketSize() + "\n";
+							endpointText += getActivity().getString(R.string.attributes_) + padLeft(Integer.toBinaryString(endpoint.getAttributes()), "0", 8);
+							addDataRow(inflater, tblUsbInfoBottom, "\t" + getActivity().getString(R.string.endpoint_), endpointText);
+						}
+					} else {
+						addDataRow(inflater, tblUsbInfoBottom, "\tEndpoints:", "none");
+					}
+				}
+			}
+		}
+	}
+
+	@Override
+	public String toString() {
+		StringBuilder sb = new StringBuilder();
+		UsefulBits uB = new UsefulBits(getActivity());
+		sb.append(uB.tableToString(tblUsbInfoHeader));
+		sb.append(uB.tableToString(tblUsbInfoTop));
+		sb.append("\n");
+		sb.append(uB.tableToString(tblUsbInfoBottom));
+		return sb.toString();
+	}
+}
diff --git a/src/aws/apps/usbDeviceEnumerator/fragments/UsbDeviceInfoLinuxFragment.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/fragments/UsbDeviceInfoLinuxFragment.java
similarity index 97%
rename from src/aws/apps/usbDeviceEnumerator/fragments/UsbDeviceInfoLinuxFragment.java
rename to app/src/main/java/aws/apps/usbDeviceEnumerator/fragments/UsbDeviceInfoLinuxFragment.java
index 04e683a..ef8d948 100644
--- a/src/aws/apps/usbDeviceEnumerator/fragments/UsbDeviceInfoLinuxFragment.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/fragments/UsbDeviceInfoLinuxFragment.java
@@ -1,208 +1,208 @@
-/*******************************************************************************
- * Copyright 2011 Alexandros Schillings
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-package aws.apps.usbDeviceEnumerator.fragments;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.drawable.BitmapDrawable;
-import android.graphics.drawable.Drawable;
-import android.os.Bundle;
-import android.util.Log;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ImageButton;
-import android.widget.LinearLayout;
-import android.widget.TableLayout;
-import android.widget.TableRow;
-import android.widget.TextView;
-import aws.apps.usbDeviceEnumerator.R;
-import aws.apps.usbDeviceEnumerator.data.DbAccessCompany;
-import aws.apps.usbDeviceEnumerator.data.DbAccessUsb;
-import aws.apps.usbDeviceEnumerator.data.ZipAccessCompany;
-import aws.apps.usbDeviceEnumerator.usb.UsbConstants;
-import aws.apps.usbDeviceEnumerator.usb.sysbususb.SysBusUsbDevice;
-import aws.apps.usbDeviceEnumerator.util.UsefulBits;
-
-public class UsbDeviceInfoLinuxFragment extends AbstractUsbDeviceInfoFragment {
-	private final String TAG =  this.getClass().getName();
-	private final static String BUNDLE_MY_USB_INFO = "BUNDLE_MY_USB_INFO";
-
-	public final static int TYPE_ANDROID_INFO = 0;
-	public final static int TYPE_LINUX_INFO = 1;	
-
-	public final static String DEFAULT_STRING = "???";
-	private TableLayout tblUsbInfoHeader;
-	private TableLayout tblUsbInfoTop;
-	private TableLayout tblUsbInfoBottom;
-	private TextView tvVID;
-	private TextView tvPID;
-	private TextView tvVendorReported;
-	private TextView tvProductReported;
-	private TextView tvVendorDb;
-	private TextView tvProductDb;		
-	private TextView tvDevicePath;
-	private TextView tvDeviceClass;
-	private ImageButton btnLogo;
-	private DbAccessUsb dbUsb;
-	private DbAccessCompany dbComp;
-	private ZipAccessCompany zipComp;
-	private SysBusUsbDevice myUsbDevice;
-
-
-	private Context context;
-	public UsbDeviceInfoLinuxFragment() {}
-
+/*******************************************************************************
+ * Copyright 2011 Alexandros Schillings
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package aws.apps.usbDeviceEnumerator.fragments;
+
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.os.Bundle;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageButton;
+import android.widget.LinearLayout;
+import android.widget.TableLayout;
+import android.widget.TableRow;
+import android.widget.TextView;
+import aws.apps.usbDeviceEnumerator.R;
+import aws.apps.usbDeviceEnumerator.data.DbAccessCompany;
+import aws.apps.usbDeviceEnumerator.data.DbAccessUsb;
+import aws.apps.usbDeviceEnumerator.data.ZipAccessCompany;
+import aws.apps.usbDeviceEnumerator.usb.UsbConstants;
+import aws.apps.usbDeviceEnumerator.usb.sysbususb.SysBusUsbDevice;
+import aws.apps.usbDeviceEnumerator.util.UsefulBits;
+
+public class UsbDeviceInfoLinuxFragment extends AbstractUsbDeviceInfoFragment {
+	private final String TAG =  this.getClass().getName();
+	private final static String BUNDLE_MY_USB_INFO = "BUNDLE_MY_USB_INFO";
+
+	public final static int TYPE_ANDROID_INFO = 0;
+	public final static int TYPE_LINUX_INFO = 1;	
+
+	public final static String DEFAULT_STRING = "???";
+	private TableLayout tblUsbInfoHeader;
+	private TableLayout tblUsbInfoTop;
+	private TableLayout tblUsbInfoBottom;
+	private TextView tvVID;
+	private TextView tvPID;
+	private TextView tvVendorReported;
+	private TextView tvProductReported;
+	private TextView tvVendorDb;
+	private TextView tvProductDb;		
+	private TextView tvDevicePath;
+	private TextView tvDeviceClass;
+	private ImageButton btnLogo;
+	private DbAccessUsb dbUsb;
+	private DbAccessCompany dbComp;
+	private ZipAccessCompany zipComp;
+	private SysBusUsbDevice myUsbDevice;
+
+
+	private Context context;
+	public UsbDeviceInfoLinuxFragment() {}
+
 
 	public UsbDeviceInfoLinuxFragment(SysBusUsbDevice myUsbDevice) {
-		this.myUsbDevice = myUsbDevice;
-	}
-
-	private void addDataRow(LayoutInflater inflater, TableLayout tlb, String cell1Text, String cell2Text){
-		TableRow row = (TableRow)inflater.inflate(R.layout.usb_table_row_data, null);
-		TextView tv1 = (TextView) row.findViewById(R.id.usb_tablerow_cell1);
-		TextView tv2 = (TextView) row.findViewById(R.id.usb_tablerow_cell2);
-		tv1.setText(cell1Text);
-		tv2.setText(cell2Text);
-		tlb.addView(row);
-	}
-
-	@Override
-	public int getType() {
-		return TYPE_LINUX_INFO;
-	}
-
-	private void loadLogo(String logo){
-		Drawable d = context.getResources().getDrawable(R.drawable.no_image);
-		Bitmap b = zipComp.getLogo(logo);
-
-		if(b != null){
-			d = new BitmapDrawable(b);
-		} else {
-			Log.w(TAG, "^ Bitmap is null");
-		}
-
-		btnLogo.setImageDrawable(d);
-	}
-
-
-	/**
-	 * If we are being created with saved state, restore our state
-	 */
-	@Override
-	public void onCreate(Bundle saved) {
-		super.onCreate(saved);
-		if (null != saved) {
-			myUsbDevice = (SysBusUsbDevice) saved.getParcelable(BUNDLE_MY_USB_INFO);
-		}
-	}
-
-	@Override
-	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle saved) {   	
-		View v = new LinearLayout(getActivity().getApplicationContext());
-		context = getActivity().getApplicationContext();
-
-		if(myUsbDevice == null){
-			return v;
-		} else {
-			v = inflater.inflate(R.layout.usb_info_linux, container, false);
-		}
-
-		tblUsbInfoHeader = (TableLayout) v.findViewById(R.id.tblUsbInfo_title);
-		tblUsbInfoTop = (TableLayout) v.findViewById(R.id.tblUsbInfo_top);
-		tblUsbInfoBottom = (TableLayout) v.findViewById(R.id.tblUsbInfo_bottom);
-		tvVID = ((TextView) v.findViewById(R.id.tvVID));
-		tvPID = ((TextView) v.findViewById(R.id.tvPID));
-		tvProductDb = ((TextView) v.findViewById(R.id.tvProductDb));
-		tvVendorDb = ((TextView) v.findViewById(R.id.tvVendorDb));
-		tvProductReported = ((TextView) v.findViewById(R.id.tvProductReported));
-		tvVendorReported = ((TextView) v.findViewById(R.id.tvVendorReported));
-		tvDevicePath = ((TextView) v.findViewById(R.id.tvDevicePath));
-		tvDeviceClass = ((TextView) v.findViewById(R.id.tvDeviceClass));
-		btnLogo = (ImageButton) v.findViewById(R.id.btnLogo);
-		btnLogo.setImageDrawable(context.getResources().getDrawable(R.drawable.no_image));
-		dbUsb = new DbAccessUsb(context);
-		dbComp = new DbAccessCompany(context);
-		zipComp = new ZipAccessCompany(context);
-
-		populateLinuxTable(inflater);
-
-		return v;
-	}
-
-	@Override
-	public void onSaveInstanceState(Bundle toSave) {
-		toSave.putParcelable(BUNDLE_MY_USB_INFO, myUsbDevice);
-	}
-
-	private String padLeft(String string, String padding, int size){
-		String pad = "";
-		while((pad+string).length() < size){
-			pad += padding + pad;
-		}
-		return pad+string;
-	}
-
-	private void populateLinuxTable(LayoutInflater inflater){
-		if(myUsbDevice == null){return;}
-		tvDevicePath.setText(myUsbDevice.getDevicePath());
-
-		tvVID.setText(padLeft(myUsbDevice.getVID(),"0",4));
-		tvPID.setText(padLeft(myUsbDevice.getPID(),"0",4));
-		tvDeviceClass.setText(UsbConstants.resolveUsbClass(myUsbDevice.getDeviceClass()));
-
-		tvVendorReported.setText(myUsbDevice.getReportedVendorName());
-		tvProductReported.setText(myUsbDevice.getReportedProductName());
-
-		if(dbUsb.doDBChecks()){
-			String vid = tvVID.getText().toString();
-			String pid = tvPID.getText().toString();
-			tvVendorDb.setText(dbUsb.getVendor(vid));
-			tvProductDb.setText(dbUsb.getProduct(vid, pid));
-		}
-
-		if(dbComp.doDBChecks()){
-			String searchFor = "";
-
-			if(tvVendorDb.getText().toString().trim().length() > 0){
-				searchFor = tvVendorDb.getText().toString();
-			}else{
-				searchFor = myUsbDevice.getReportedVendorName();
-			}
-			Log.d(TAG, "^ Searching for '"+searchFor+"'");
-			loadLogo(dbComp.getLogo(searchFor));
-		}
-		addDataRow(inflater, tblUsbInfoBottom, getActivity().getString(R.string.usb_version_),myUsbDevice.getUsbVersion());
-		addDataRow(inflater, tblUsbInfoBottom, getActivity().getString(R.string.speed_),myUsbDevice.getSpeed());
-		addDataRow(inflater, tblUsbInfoBottom, getActivity().getString(R.string.protocol_), myUsbDevice.getDeviceProtocol());
-		addDataRow(inflater, tblUsbInfoBottom, getActivity().getString(R.string.maximum_power_),myUsbDevice.getMaxPower());
-		addDataRow(inflater, tblUsbInfoBottom, getActivity().getString(R.string.serial_number_),myUsbDevice.getSerialNumber());
-
-		//addHeaderRow(inflater, tblUsbInfo, "Interfaces");
-
-	}
-
-	@Override
-	public String toString() {
-		StringBuilder sb = new StringBuilder();
-		UsefulBits uB = new UsefulBits(getActivity());
-		sb.append(uB.tableToString(tblUsbInfoHeader));
-		sb.append(uB.tableToString(tblUsbInfoTop));
-		sb.append("\n");
-		sb.append(uB.tableToString(tblUsbInfoBottom));
-		return sb.toString();
-	}
-}
+		this.myUsbDevice = myUsbDevice;
+	}
+
+	private void addDataRow(LayoutInflater inflater, TableLayout tlb, String cell1Text, String cell2Text){
+		TableRow row = (TableRow)inflater.inflate(R.layout.usb_table_row_data, null);
+		TextView tv1 = (TextView) row.findViewById(R.id.usb_tablerow_cell1);
+		TextView tv2 = (TextView) row.findViewById(R.id.usb_tablerow_cell2);
+		tv1.setText(cell1Text);
+		tv2.setText(cell2Text);
+		tlb.addView(row);
+	}
+
+	@Override
+	public int getType() {
+		return TYPE_LINUX_INFO;
+	}
+
+	private void loadLogo(String logo){
+		Drawable d = context.getResources().getDrawable(R.drawable.no_image);
+		Bitmap b = zipComp.getLogo(logo);
+
+		if(b != null){
+			d = new BitmapDrawable(b);
+		} else {
+			Log.w(TAG, "^ Bitmap is null");
+		}
+
+		btnLogo.setImageDrawable(d);
+	}
+
+
+	/**
+	 * If we are being created with saved state, restore our state
+	 */
+	@Override
+	public void onCreate(Bundle saved) {
+		super.onCreate(saved);
+		if (null != saved) {
+			myUsbDevice = (SysBusUsbDevice) saved.getParcelable(BUNDLE_MY_USB_INFO);
+		}
+	}
+
+	@Override
+	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle saved) {   	
+		View v = new LinearLayout(getActivity().getApplicationContext());
+		context = getActivity().getApplicationContext();
+
+		if(myUsbDevice == null){
+			return v;
+		} else {
+			v = inflater.inflate(R.layout.usb_info_linux, container, false);
+		}
+
+		tblUsbInfoHeader = (TableLayout) v.findViewById(R.id.tblUsbInfo_title);
+		tblUsbInfoTop = (TableLayout) v.findViewById(R.id.tblUsbInfo_top);
+		tblUsbInfoBottom = (TableLayout) v.findViewById(R.id.tblUsbInfo_bottom);
+		tvVID = ((TextView) v.findViewById(R.id.tvVID));
+		tvPID = ((TextView) v.findViewById(R.id.tvPID));
+		tvProductDb = ((TextView) v.findViewById(R.id.tvProductDb));
+		tvVendorDb = ((TextView) v.findViewById(R.id.tvVendorDb));
+		tvProductReported = ((TextView) v.findViewById(R.id.tvProductReported));
+		tvVendorReported = ((TextView) v.findViewById(R.id.tvVendorReported));
+		tvDevicePath = ((TextView) v.findViewById(R.id.tvDevicePath));
+		tvDeviceClass = ((TextView) v.findViewById(R.id.tvDeviceClass));
+		btnLogo = (ImageButton) v.findViewById(R.id.btnLogo);
+		btnLogo.setImageDrawable(context.getResources().getDrawable(R.drawable.no_image));
+		dbUsb = new DbAccessUsb(context);
+		dbComp = new DbAccessCompany(context);
+		zipComp = new ZipAccessCompany(context);
+
+		populateLinuxTable(inflater);
+
+		return v;
+	}
+
+	@Override
+	public void onSaveInstanceState(Bundle toSave) {
+		toSave.putParcelable(BUNDLE_MY_USB_INFO, myUsbDevice);
+	}
+
+	private String padLeft(String string, String padding, int size){
+		String pad = "";
+		while((pad+string).length() < size){
+			pad += padding + pad;
+		}
+		return pad+string;
+	}
+
+	private void populateLinuxTable(LayoutInflater inflater){
+		if(myUsbDevice == null){return;}
+		tvDevicePath.setText(myUsbDevice.getDevicePath());
+
+		tvVID.setText(padLeft(myUsbDevice.getVID(),"0",4));
+		tvPID.setText(padLeft(myUsbDevice.getPID(),"0",4));
+		tvDeviceClass.setText(UsbConstants.resolveUsbClass(myUsbDevice.getDeviceClass()));
+
+		tvVendorReported.setText(myUsbDevice.getReportedVendorName());
+		tvProductReported.setText(myUsbDevice.getReportedProductName());
+
+		if(dbUsb.doDBChecks()){
+			String vid = tvVID.getText().toString();
+			String pid = tvPID.getText().toString();
+			tvVendorDb.setText(dbUsb.getVendor(vid));
+			tvProductDb.setText(dbUsb.getProduct(vid, pid));
+		}
+
+		if(dbComp.doDBChecks()){
+			String searchFor = "";
+
+			if(tvVendorDb.getText().toString().trim().length() > 0){
+				searchFor = tvVendorDb.getText().toString();
+			}else{
+				searchFor = myUsbDevice.getReportedVendorName();
+			}
+			Log.d(TAG, "^ Searching for '"+searchFor+"'");
+			loadLogo(dbComp.getLogo(searchFor));
+		}
+		addDataRow(inflater, tblUsbInfoBottom, getActivity().getString(R.string.usb_version_),myUsbDevice.getUsbVersion());
+		addDataRow(inflater, tblUsbInfoBottom, getActivity().getString(R.string.speed_),myUsbDevice.getSpeed());
+		addDataRow(inflater, tblUsbInfoBottom, getActivity().getString(R.string.protocol_), myUsbDevice.getDeviceProtocol());
+		addDataRow(inflater, tblUsbInfoBottom, getActivity().getString(R.string.maximum_power_),myUsbDevice.getMaxPower());
+		addDataRow(inflater, tblUsbInfoBottom, getActivity().getString(R.string.serial_number_),myUsbDevice.getSerialNumber());
+
+		//addHeaderRow(inflater, tblUsbInfo, "Interfaces");
+
+	}
+
+	@Override
+	public String toString() {
+		StringBuilder sb = new StringBuilder();
+		UsefulBits uB = new UsefulBits(getActivity());
+		sb.append(uB.tableToString(tblUsbInfoHeader));
+		sb.append(uB.tableToString(tblUsbInfoTop));
+		sb.append("\n");
+		sb.append(uB.tableToString(tblUsbInfoBottom));
+		return sb.toString();
+	}
+}
diff --git a/src/aws/apps/usbDeviceEnumerator/ui/MyAlertBox.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/MyAlertBox.java
similarity index 97%
rename from src/aws/apps/usbDeviceEnumerator/ui/MyAlertBox.java
rename to app/src/main/java/aws/apps/usbDeviceEnumerator/ui/MyAlertBox.java
index bd33aa4..8e948aa 100644
--- a/src/aws/apps/usbDeviceEnumerator/ui/MyAlertBox.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/ui/MyAlertBox.java
@@ -1,54 +1,54 @@
-/*******************************************************************************
- * Copyright 2011 Alexandros Schillings
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-package aws.apps.usbDeviceEnumerator.ui;
-
-import android.app.AlertDialog;
-import android.content.Context;
-import android.text.SpannableString;
-import android.text.method.LinkMovementMethod;
-import android.text.util.Linkify;
-import android.widget.ScrollView;
-import android.widget.TextView;
-
-public class MyAlertBox {
-
-	 public static AlertDialog create(Context context, String text, String title, String button) {
-	  return new AlertDialog.Builder(context)
-	   .setTitle(title)
-	   .setCancelable(true)
-	   .setIcon(android.R.drawable.ic_dialog_info)
-	   .setPositiveButton(button, null)
-	   .setView(LinkifyText(context, text))
-	   .create();
-	 }
-
-		public static ScrollView LinkifyText(Context context, String message) 
-		{
-		    ScrollView svMessage = new ScrollView(context); 
-		    TextView tvMessage = new TextView(context);
-		
-		    SpannableString spanText = new SpannableString(message);
-		
-		    Linkify.addLinks(spanText, Linkify.ALL);
-		    tvMessage.setText(spanText);
-		    tvMessage.setMovementMethod(LinkMovementMethod.getInstance());
-		    
-		    svMessage.setPadding(14, 2, 10, 12);
-		    svMessage.addView(tvMessage);
-		
-		    return svMessage;
-		}
-}
+/*******************************************************************************
+ * Copyright 2011 Alexandros Schillings
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package aws.apps.usbDeviceEnumerator.ui;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.text.SpannableString;
+import android.text.method.LinkMovementMethod;
+import android.text.util.Linkify;
+import android.widget.ScrollView;
+import android.widget.TextView;
+
+public class MyAlertBox {
+
+	 public static AlertDialog create(Context context, String text, String title, String button) {
+	  return new AlertDialog.Builder(context)
+	   .setTitle(title)
+	   .setCancelable(true)
+	   .setIcon(android.R.drawable.ic_dialog_info)
+	   .setPositiveButton(button, null)
+	   .setView(LinkifyText(context, text))
+	   .create();
+	 }
+
+		public static ScrollView LinkifyText(Context context, String message) 
+		{
+		    ScrollView svMessage = new ScrollView(context); 
+		    TextView tvMessage = new TextView(context);
+		
+		    SpannableString spanText = new SpannableString(message);
+		
+		    Linkify.addLinks(spanText, Linkify.ALL);
+		    tvMessage.setText(spanText);
+		    tvMessage.setMovementMethod(LinkMovementMethod.getInstance());
+		    
+		    svMessage.setPadding(14, 2, 10, 12);
+		    svMessage.addView(tvMessage);
+		
+		    return svMessage;
+		}
+}
diff --git a/src/aws/apps/usbDeviceEnumerator/usb/UsbConstants.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/usb/UsbConstants.java
similarity index 97%
rename from src/aws/apps/usbDeviceEnumerator/usb/UsbConstants.java
rename to app/src/main/java/aws/apps/usbDeviceEnumerator/usb/UsbConstants.java
index 059efda..ed15e89 100644
--- a/src/aws/apps/usbDeviceEnumerator/usb/UsbConstants.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/usb/UsbConstants.java
@@ -1,132 +1,132 @@
-/*******************************************************************************
- * Copyright 2011 Alexandros Schillings
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-package aws.apps.usbDeviceEnumerator.usb;
-
-public class UsbConstants {
-
-	private final static int USB_CLASS_PER_INTERFACE 		= 0x00;
-	private final static int USB_CLASS_AUDIO 				= 0x01;
-	private final static int USB_CLASS_COMM 				= 0x02;
-	private final static int USB_CLASS_HID 					= 0x03;
-	private final static int USB_CLASS_PHYSICAL				= 0x05;
-	private final static int USB_CLASS_STILL_IMAGE			= 0x06;
-	private final static int USB_CLASS_PRINTER				= 0x07;
-	private final static int USB_CLASS_MASS_STORAGE			= 0x08;
-	private final static int USB_CLASS_HUB					= 0x09;
-	private final static int USB_CLASS_CDC_DATA				= 0x0a;
-	private final static int USB_CLASS_CSCID 				= 0x0b; /* chip + smart card */
-	private final static int USB_CLASS_CONTENT_SEC 			= 0x0d; /* content security */
-	private final static int USB_CLASS_VIDEO 				= 0x0e;
-	private final static int USB_CLASS_PERSONAL_HEALTH		= 0x0f;
-	private final static int USB_CLASS_DIAGNOSTICS			= 0xdc;
-	private final static int USB_CLASS_WIRELESS_CONTROLLER  = 0xe0;
-	private final static int USB_CLASS_MISC 				= 0xef;
-	private final static int USB_CLASS_APP_SPEC 			= 0xfe;
-	private final static int USB_CLASS_VENDOR_SPEC 			= 0xff;
-
-	private final static int USB_DIR_OUT = 0;
-	private final static int USB_DIR_IN = 128;
-
-	private final static int  USB_ENDPOINT_XFER_CONTROL = 0;
-	private final static int  USB_ENDPOINT_XFER_ISOC = 1;
-	private final static int  USB_ENDPOINT_XFER_BULK = 2;
-	private final static int  USB_ENDPOINT_XFER_INT = 3;
-
-
-
-	public static String resolveUsbClass(int usbClass){
-		switch(usbClass){
-		case USB_CLASS_PER_INTERFACE:
-			return "Use class information in the Interface Descriptors (0x"+Integer.toHexString(usbClass) + ")";		
-		case USB_CLASS_AUDIO:
-			return "Audio Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_COMM:
-			return "Communication Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_HID:
-			return "Human Interaction Device (0x"+Integer.toHexString(usbClass) + ")";			
-		case USB_CLASS_PHYSICAL:
-			return "Physical Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_STILL_IMAGE:
-			return "Still Image Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_PRINTER:
-			return "Printer (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_MASS_STORAGE:
-			return "Mass Storage Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_HUB:
-			return "USB Hub (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_CDC_DATA:
-			return "Communication Device Class (CDC) (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_CSCID:
-			return "Content SmartCard Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_CONTENT_SEC:
-			return "Content Security Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_APP_SPEC:
-			return "Application Specific (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_VENDOR_SPEC:
-			return "Vendor Specific (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_VIDEO:
-			return "Video Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_PERSONAL_HEALTH:
-			return "Personal Healthcare Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_DIAGNOSTICS:
-			return "Diagnostics Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_WIRELESS_CONTROLLER:
-			return "Wireless Controller (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_MISC:
-			return "Miscellaneous (0x"+Integer.toHexString(usbClass) + ")";
-		default:
-			return "Unknown (0x"+Integer.toHexString(usbClass) + ")";
-		}
-	}
-
-	public static String resolveUsbClass(String usbClass){
-		try{
-			return resolveUsbClass(Integer.parseInt(usbClass));
-		} catch(Exception e){
-			return "";
-		}
-	}
-
-	public static String resolveUsbEndpointDirection(int usbEndpointDirection){
-
-		switch(usbEndpointDirection){
-		case USB_DIR_OUT:
-			return "Outbound (0x"+Integer.toHexString(usbEndpointDirection) + ")";		
-		case USB_DIR_IN:
-			return "Inbound (0x"+Integer.toHexString(usbEndpointDirection) + ")";
-		default:
-			return "Unknown (0x"+Integer.toHexString(usbEndpointDirection) + ")";
-		}
-	}
-	
-	public static String resolveUsbEndpointType(int usbEndpointType) {
-
-		switch(usbEndpointType){
-		case USB_ENDPOINT_XFER_CONTROL:
-			return "Control (0x"+Integer.toHexString(usbEndpointType) + ")";		
-		case USB_ENDPOINT_XFER_ISOC:
-			return "Isochronous (0x"+Integer.toHexString(usbEndpointType) + ")";
-		case USB_ENDPOINT_XFER_BULK:
-			return "Bulk (0x"+Integer.toHexString(usbEndpointType) + ")";
-		case USB_ENDPOINT_XFER_INT:
-			return "Intrrupt (0x"+Integer.toHexString(usbEndpointType) + ")";				
-		default:
-			return "Unknown (0x"+Integer.toHexString(usbEndpointType) + ")";
-		}
-	}
-
-
-}
+/*******************************************************************************
+ * Copyright 2011 Alexandros Schillings
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package aws.apps.usbDeviceEnumerator.usb;
+
+public class UsbConstants {
+
+	private final static int USB_CLASS_PER_INTERFACE 		= 0x00;
+	private final static int USB_CLASS_AUDIO 				= 0x01;
+	private final static int USB_CLASS_COMM 				= 0x02;
+	private final static int USB_CLASS_HID 					= 0x03;
+	private final static int USB_CLASS_PHYSICAL				= 0x05;
+	private final static int USB_CLASS_STILL_IMAGE			= 0x06;
+	private final static int USB_CLASS_PRINTER				= 0x07;
+	private final static int USB_CLASS_MASS_STORAGE			= 0x08;
+	private final static int USB_CLASS_HUB					= 0x09;
+	private final static int USB_CLASS_CDC_DATA				= 0x0a;
+	private final static int USB_CLASS_CSCID 				= 0x0b; /* chip + smart card */
+	private final static int USB_CLASS_CONTENT_SEC 			= 0x0d; /* content security */
+	private final static int USB_CLASS_VIDEO 				= 0x0e;
+	private final static int USB_CLASS_PERSONAL_HEALTH		= 0x0f;
+	private final static int USB_CLASS_DIAGNOSTICS			= 0xdc;
+	private final static int USB_CLASS_WIRELESS_CONTROLLER  = 0xe0;
+	private final static int USB_CLASS_MISC 				= 0xef;
+	private final static int USB_CLASS_APP_SPEC 			= 0xfe;
+	private final static int USB_CLASS_VENDOR_SPEC 			= 0xff;
+
+	private final static int USB_DIR_OUT = 0;
+	private final static int USB_DIR_IN = 128;
+
+	private final static int  USB_ENDPOINT_XFER_CONTROL = 0;
+	private final static int  USB_ENDPOINT_XFER_ISOC = 1;
+	private final static int  USB_ENDPOINT_XFER_BULK = 2;
+	private final static int  USB_ENDPOINT_XFER_INT = 3;
+
+
+
+	public static String resolveUsbClass(int usbClass){
+		switch(usbClass){
+		case USB_CLASS_PER_INTERFACE:
+			return "Use class information in the Interface Descriptors (0x"+Integer.toHexString(usbClass) + ")";		
+		case USB_CLASS_AUDIO:
+			return "Audio Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_COMM:
+			return "Communication Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_HID:
+			return "Human Interaction Device (0x"+Integer.toHexString(usbClass) + ")";			
+		case USB_CLASS_PHYSICAL:
+			return "Physical Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_STILL_IMAGE:
+			return "Still Image Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_PRINTER:
+			return "Printer (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_MASS_STORAGE:
+			return "Mass Storage Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_HUB:
+			return "USB Hub (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_CDC_DATA:
+			return "Communication Device Class (CDC) (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_CSCID:
+			return "Content SmartCard Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_CONTENT_SEC:
+			return "Content Security Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_APP_SPEC:
+			return "Application Specific (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_VENDOR_SPEC:
+			return "Vendor Specific (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_VIDEO:
+			return "Video Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_PERSONAL_HEALTH:
+			return "Personal Healthcare Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_DIAGNOSTICS:
+			return "Diagnostics Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_WIRELESS_CONTROLLER:
+			return "Wireless Controller (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_MISC:
+			return "Miscellaneous (0x"+Integer.toHexString(usbClass) + ")";
+		default:
+			return "Unknown (0x"+Integer.toHexString(usbClass) + ")";
+		}
+	}
+
+	public static String resolveUsbClass(String usbClass){
+		try{
+			return resolveUsbClass(Integer.parseInt(usbClass));
+		} catch(Exception e){
+			return "";
+		}
+	}
+
+	public static String resolveUsbEndpointDirection(int usbEndpointDirection){
+
+		switch(usbEndpointDirection){
+		case USB_DIR_OUT:
+			return "Outbound (0x"+Integer.toHexString(usbEndpointDirection) + ")";		
+		case USB_DIR_IN:
+			return "Inbound (0x"+Integer.toHexString(usbEndpointDirection) + ")";
+		default:
+			return "Unknown (0x"+Integer.toHexString(usbEndpointDirection) + ")";
+		}
+	}
+	
+	public static String resolveUsbEndpointType(int usbEndpointType) {
+
+		switch(usbEndpointType){
+		case USB_ENDPOINT_XFER_CONTROL:
+			return "Control (0x"+Integer.toHexString(usbEndpointType) + ")";		
+		case USB_ENDPOINT_XFER_ISOC:
+			return "Isochronous (0x"+Integer.toHexString(usbEndpointType) + ")";
+		case USB_ENDPOINT_XFER_BULK:
+			return "Bulk (0x"+Integer.toHexString(usbEndpointType) + ")";
+		case USB_ENDPOINT_XFER_INT:
+			return "Intrrupt (0x"+Integer.toHexString(usbEndpointType) + ")";				
+		default:
+			return "Unknown (0x"+Integer.toHexString(usbEndpointType) + ")";
+		}
+	}
+
+
+}
diff --git a/src/aws/apps/usbDeviceEnumerator/usb/sysbususb/SysBusUsbConstantsResolver.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/usb/sysbususb/SysBusUsbConstantsResolver.java
similarity index 97%
rename from src/aws/apps/usbDeviceEnumerator/usb/sysbususb/SysBusUsbConstantsResolver.java
rename to app/src/main/java/aws/apps/usbDeviceEnumerator/usb/sysbususb/SysBusUsbConstantsResolver.java
index f21341d..7cfa420 100644
--- a/src/aws/apps/usbDeviceEnumerator/usb/sysbususb/SysBusUsbConstantsResolver.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/usb/sysbususb/SysBusUsbConstantsResolver.java
@@ -1,120 +1,120 @@
-/*******************************************************************************
- * Copyright 2011 Alexandros Schillings
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-package aws.apps.usbDeviceEnumerator.usb.sysbususb;
-
-class SysBusUsbConstantsResolver {
-
-	private final static int USB_CLASS_PER_INTERFACE 		= 0x00;
-	private final static int USB_CLASS_AUDIO 				= 0x01;
-	private final static int USB_CLASS_COMM 				= 0x02;
-	private final static int USB_CLASS_HID 					= 0x03;
-	private final static int USB_CLASS_PHYSICAL				= 0x05;
-	private final static int USB_CLASS_STILL_IMAGE			= 0x06;
-	private final static int USB_CLASS_PRINTER				= 0x07;
-	private final static int USB_CLASS_MASS_STORAGE			= 0x08;
-	private final static int USB_CLASS_HUB					= 0x09;
-	private final static int USB_CLASS_CDC_DATA				= 0x0a;
-	private final static int USB_CLASS_CSCID 				= 0x0b; /* chip + smart card */
-	private final static int USB_CLASS_CONTENT_SEC 			= 0x0d; /* content security */
-	private final static int USB_CLASS_VIDEO 				= 0x0e;
-	private final static int USB_CLASS_PERSONAL_HEALTH		= 0x0f;
-	private final static int USB_CLASS_DIAGNOSTICS			= 0xdc;
-	private final static int USB_CLASS_WIRELESS_CONTROLLER  = 0xe0;
-	private final static int USB_CLASS_MISC 				= 0xef;
-	private final static int USB_CLASS_APP_SPEC 			= 0xfe;
-	private final static int USB_CLASS_VENDOR_SPEC 			= 0xff;
-
-	private final static int USB_DIR_OUT = 0;
-	private final static int USB_DIR_IN = 128;
-
-	private final static int  USB_ENDPOINT_XFER_CONTROL = 0;
-	private final static int  USB_ENDPOINT_XFER_ISOC = 1;
-	private final static int  USB_ENDPOINT_XFER_BULK = 2;
-	private final static int  USB_ENDPOINT_XFER_INT = 3;
-
-	protected static String resolveUsbClass(int usbClass){
-		switch(usbClass){
-		case USB_CLASS_PER_INTERFACE:
-			return "Use class information in the Interface Descriptors (0x"+Integer.toHexString(usbClass) + ")";		
-		case USB_CLASS_AUDIO:
-			return "Audio Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_COMM:
-			return "Communication Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_HID:
-			return "Human Interaction Device (0x"+Integer.toHexString(usbClass) + ")";			
-		case USB_CLASS_PHYSICAL:
-			return "Physical Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_STILL_IMAGE:
-			return "Still Image Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_PRINTER:
-			return "Printer (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_MASS_STORAGE:
-			return "Mass Storage Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_HUB:
-			return "USB Hub (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_CDC_DATA:
-			return "Communication Device Class (CDC) (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_CSCID:
-			return "Content SmartCard Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_CONTENT_SEC:
-			return "Content Security Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_APP_SPEC:
-			return "Application Specific (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_VENDOR_SPEC:
-			return "Vendor Specific (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_VIDEO:
-			return "Video Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_PERSONAL_HEALTH:
-			return "Personal Healthcare Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_DIAGNOSTICS:
-			return "Diagnostics Device (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_WIRELESS_CONTROLLER:
-			return "Wireless Controller (0x"+Integer.toHexString(usbClass) + ")";
-		case USB_CLASS_MISC:
-			return "Miscellaneous (0x"+Integer.toHexString(usbClass) + ")";
-		default:
-			return "Unknown (0x"+Integer.toHexString(usbClass) + ")";
-		}
-	}
-
-	protected static String resolveUsbEndpointDirection(int usbEndpointDirection){
-
-		switch(usbEndpointDirection){
-		case USB_DIR_OUT:
-			return "Outbound (0x"+Integer.toHexString(usbEndpointDirection) + ")";		
-		case USB_DIR_IN:
-			return "Inbound (0x"+Integer.toHexString(usbEndpointDirection) + ")";
-		default:
-			return "Unknown (0x"+Integer.toHexString(usbEndpointDirection) + ")";
-		}
-	}
-
-	protected static String resolveUsbEndpointType(int usbEndpointType) {
-
-		switch(usbEndpointType){
-		case USB_ENDPOINT_XFER_CONTROL:
-			return "Control (0x"+Integer.toHexString(usbEndpointType) + ")";		
-		case USB_ENDPOINT_XFER_ISOC:
-			return "Isochronous (0x"+Integer.toHexString(usbEndpointType) + ")";
-		case USB_ENDPOINT_XFER_BULK:
-			return "Bulk (0x"+Integer.toHexString(usbEndpointType) + ")";
-		case USB_ENDPOINT_XFER_INT:
-			return "Intrrupt (0x"+Integer.toHexString(usbEndpointType) + ")";				
-		default:
-			return "Unknown (0x"+Integer.toHexString(usbEndpointType) + ")";
-		}
-	}
-}
+/*******************************************************************************
+ * Copyright 2011 Alexandros Schillings
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package aws.apps.usbDeviceEnumerator.usb.sysbususb;
+
+class SysBusUsbConstantsResolver {
+
+	private final static int USB_CLASS_PER_INTERFACE 		= 0x00;
+	private final static int USB_CLASS_AUDIO 				= 0x01;
+	private final static int USB_CLASS_COMM 				= 0x02;
+	private final static int USB_CLASS_HID 					= 0x03;
+	private final static int USB_CLASS_PHYSICAL				= 0x05;
+	private final static int USB_CLASS_STILL_IMAGE			= 0x06;
+	private final static int USB_CLASS_PRINTER				= 0x07;
+	private final static int USB_CLASS_MASS_STORAGE			= 0x08;
+	private final static int USB_CLASS_HUB					= 0x09;
+	private final static int USB_CLASS_CDC_DATA				= 0x0a;
+	private final static int USB_CLASS_CSCID 				= 0x0b; /* chip + smart card */
+	private final static int USB_CLASS_CONTENT_SEC 			= 0x0d; /* content security */
+	private final static int USB_CLASS_VIDEO 				= 0x0e;
+	private final static int USB_CLASS_PERSONAL_HEALTH		= 0x0f;
+	private final static int USB_CLASS_DIAGNOSTICS			= 0xdc;
+	private final static int USB_CLASS_WIRELESS_CONTROLLER  = 0xe0;
+	private final static int USB_CLASS_MISC 				= 0xef;
+	private final static int USB_CLASS_APP_SPEC 			= 0xfe;
+	private final static int USB_CLASS_VENDOR_SPEC 			= 0xff;
+
+	private final static int USB_DIR_OUT = 0;
+	private final static int USB_DIR_IN = 128;
+
+	private final static int  USB_ENDPOINT_XFER_CONTROL = 0;
+	private final static int  USB_ENDPOINT_XFER_ISOC = 1;
+	private final static int  USB_ENDPOINT_XFER_BULK = 2;
+	private final static int  USB_ENDPOINT_XFER_INT = 3;
+
+	protected static String resolveUsbClass(int usbClass){
+		switch(usbClass){
+		case USB_CLASS_PER_INTERFACE:
+			return "Use class information in the Interface Descriptors (0x"+Integer.toHexString(usbClass) + ")";		
+		case USB_CLASS_AUDIO:
+			return "Audio Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_COMM:
+			return "Communication Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_HID:
+			return "Human Interaction Device (0x"+Integer.toHexString(usbClass) + ")";			
+		case USB_CLASS_PHYSICAL:
+			return "Physical Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_STILL_IMAGE:
+			return "Still Image Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_PRINTER:
+			return "Printer (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_MASS_STORAGE:
+			return "Mass Storage Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_HUB:
+			return "USB Hub (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_CDC_DATA:
+			return "Communication Device Class (CDC) (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_CSCID:
+			return "Content SmartCard Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_CONTENT_SEC:
+			return "Content Security Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_APP_SPEC:
+			return "Application Specific (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_VENDOR_SPEC:
+			return "Vendor Specific (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_VIDEO:
+			return "Video Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_PERSONAL_HEALTH:
+			return "Personal Healthcare Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_DIAGNOSTICS:
+			return "Diagnostics Device (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_WIRELESS_CONTROLLER:
+			return "Wireless Controller (0x"+Integer.toHexString(usbClass) + ")";
+		case USB_CLASS_MISC:
+			return "Miscellaneous (0x"+Integer.toHexString(usbClass) + ")";
+		default:
+			return "Unknown (0x"+Integer.toHexString(usbClass) + ")";
+		}
+	}
+
+	protected static String resolveUsbEndpointDirection(int usbEndpointDirection){
+
+		switch(usbEndpointDirection){
+		case USB_DIR_OUT:
+			return "Outbound (0x"+Integer.toHexString(usbEndpointDirection) + ")";		
+		case USB_DIR_IN:
+			return "Inbound (0x"+Integer.toHexString(usbEndpointDirection) + ")";
+		default:
+			return "Unknown (0x"+Integer.toHexString(usbEndpointDirection) + ")";
+		}
+	}
+
+	protected static String resolveUsbEndpointType(int usbEndpointType) {
+
+		switch(usbEndpointType){
+		case USB_ENDPOINT_XFER_CONTROL:
+			return "Control (0x"+Integer.toHexString(usbEndpointType) + ")";		
+		case USB_ENDPOINT_XFER_ISOC:
+			return "Isochronous (0x"+Integer.toHexString(usbEndpointType) + ")";
+		case USB_ENDPOINT_XFER_BULK:
+			return "Bulk (0x"+Integer.toHexString(usbEndpointType) + ")";
+		case USB_ENDPOINT_XFER_INT:
+			return "Intrrupt (0x"+Integer.toHexString(usbEndpointType) + ")";				
+		default:
+			return "Unknown (0x"+Integer.toHexString(usbEndpointType) + ")";
+		}
+	}
+}
diff --git a/src/aws/apps/usbDeviceEnumerator/usb/sysbususb/SysBusUsbDevice.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/usb/sysbususb/SysBusUsbDevice.java
similarity index 95%
rename from src/aws/apps/usbDeviceEnumerator/usb/sysbususb/SysBusUsbDevice.java
rename to app/src/main/java/aws/apps/usbDeviceEnumerator/usb/sysbususb/SysBusUsbDevice.java
index 58fa39c..d8655cf 100644
--- a/src/aws/apps/usbDeviceEnumerator/usb/sysbususb/SysBusUsbDevice.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/usb/sysbususb/SysBusUsbDevice.java
@@ -1,200 +1,200 @@
-/*******************************************************************************
- * Copyright 2011 Alexandros Schillings
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-package aws.apps.usbDeviceEnumerator.usb.sysbususb;
-
-import android.os.Parcel;
-import android.os.Parcelable;
-
-public class SysBusUsbDevice implements Parcelable {
-	private String VID;
-	private String PID;
-	private String ReportedProductName;
-	private String ReportedVendorName;
-	private String SerialNumber;
-	private String Speed;
-	private String DeviceClass;
-	private String DeviceProtocol;
-	private String MaxPower;
-	private String DeviceSubClass;
-	private String BusNumber;
-	private String DeviceNumber;
-	private String UsbVersion;
-	private String DevicePath;
-
-	public static final Parcelable.Creator<SysBusUsbDevice> CREATOR = new Parcelable.Creator<SysBusUsbDevice>() {
-		public SysBusUsbDevice createFromParcel(Parcel in) {
-			return new SysBusUsbDevice(in);
-		}
-
-		public SysBusUsbDevice[] newArray(int size) {
-			return new SysBusUsbDevice[size];
-		}
-	};
-	
-	public SysBusUsbDevice(){}
-	
-	public SysBusUsbDevice(Parcel in) {
-		VID = in.readString();
-		PID = in.readString();
-		ReportedProductName = in.readString();
-		ReportedVendorName = in.readString();
-		SerialNumber = in.readString();
-		Speed = in.readString();
-		DeviceClass = in.readString();
-		DeviceProtocol = in.readString();
-		MaxPower = in.readString();
-		DeviceSubClass = in.readString();
-		BusNumber = in.readString();
-		DeviceNumber = in.readString();
-		UsbVersion = in.readString();
-		DevicePath = in.readString();
-	}
-
-	@Override
-	public int describeContents() {
-		return 0;
-	}
-
-	public String getBusNumber() {
-		return BusNumber;
-	}
-
-	public String getDeviceClass() {
-		return DeviceClass;
-	}
-
-	public String getDeviceNumber() {
-		return DeviceNumber;
-	}
-
-	public String getDevicePath() {
-		return DevicePath;
-	}
-
-	public String getDeviceProtocol() {
-		return DeviceProtocol;
-	}
-
-	public String getDeviceSubClass() {
-		return DeviceSubClass;
-	}
-
-	public String getMaxPower() {
-		return MaxPower;
-	}
-
-	public String getPID() {
-		return PID;
-	}
-
-	public String getReportedProductName() {
-		return ReportedProductName;
-	}
-
-	public String getReportedVendorName() {
-		return ReportedVendorName;
-	}
-
-	public String getSerialNumber() {
-		return SerialNumber;
-	}
-
-	public String getSpeed() {
-		return Speed;
-	}
-
-	public String getUsbVersion() {
-		return UsbVersion;
-	}
-
-	public String getVID() {
-		return VID;
-	}
-
-	public void setBusNumber(String busNumber) {
-		BusNumber = busNumber;
-	}
-
-	public void setDeviceClass(String deviceClass) {
-		DeviceClass = deviceClass;
-	}
-
-	public void setDeviceNumber(String deviceNumber) {
-		DeviceNumber = deviceNumber;
-	}
-
-	public void setDevicePath(String devicePath) {
-		DevicePath = devicePath;
-	}
-
-	public void setDeviceProtocol(String deviceProtocol) {
-		DeviceProtocol = deviceProtocol;
-	}
-
-	public void setDeviceSubClass(String deviceSubClass) {
-		DeviceSubClass = deviceSubClass;
-	}
-
-	public void setMaxPower(String maxPower) {
-		MaxPower = maxPower;
-	}
-
-	public void setPID(String pID) {
-		PID = pID;
-	}
-
-	public void setReportedProductName(String reportedProductName) {
-		ReportedProductName = reportedProductName;
-	}
-
-	public void setReportedVendorName(String reportedVendorName) {
-		ReportedVendorName = reportedVendorName;
-	}
-
-	public void setSerialNumber(String serial) {
-		SerialNumber = serial;
-	}
-
-	public void setSpeed(String speed) {
-		Speed = speed;
-	}
-
-	public void setUsbVersion(String usbVersion) {
-		UsbVersion = usbVersion;
-	}
-
-	public void setVID(String vID) {
-		VID = vID;
-	}
-
-	@Override
-	public void writeToParcel(Parcel dest, int flags) {
-		dest.writeString(VID);
-		dest.writeString(PID);
-		dest.writeString(ReportedProductName);
-		dest.writeString(ReportedVendorName);
-		dest.writeString(SerialNumber);
-		dest.writeString(Speed);
-		dest.writeString(DeviceClass);
-		dest.writeString(DeviceProtocol);
-		dest.writeString(MaxPower);
-		dest.writeString(DeviceSubClass);
-		dest.writeString(BusNumber);
-		dest.writeString(DeviceNumber);
-		dest.writeString(UsbVersion);
-		dest.writeString(DevicePath);
-	}
-}
+/*******************************************************************************
+ * Copyright 2011 Alexandros Schillings
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package aws.apps.usbDeviceEnumerator.usb.sysbususb;
+
+import android.os.Parcel;
+import android.os.Parcelable;
+
+public class SysBusUsbDevice implements Parcelable {
+	private String VID;
+	private String PID;
+	private String ReportedProductName;
+	private String ReportedVendorName;
+	private String SerialNumber;
+	private String Speed;
+	private String DeviceClass;
+	private String DeviceProtocol;
+	private String MaxPower;
+	private String DeviceSubClass;
+	private String BusNumber;
+	private String DeviceNumber;
+	private String UsbVersion;
+	private String DevicePath;
+
+	public static final Parcelable.Creator<SysBusUsbDevice> CREATOR = new Parcelable.Creator<SysBusUsbDevice>() {
+		public SysBusUsbDevice createFromParcel(Parcel in) {
+			return new SysBusUsbDevice(in);
+		}
+
+		public SysBusUsbDevice[] newArray(int size) {
+			return new SysBusUsbDevice[size];
+		}
+	};
+	
+	public SysBusUsbDevice(){}
+	
+	public SysBusUsbDevice(Parcel in) {
+		VID = in.readString();
+		PID = in.readString();
+		ReportedProductName = in.readString();
+		ReportedVendorName = in.readString();
+		SerialNumber = in.readString();
+		Speed = in.readString();
+		DeviceClass = in.readString();
+		DeviceProtocol = in.readString();
+		MaxPower = in.readString();
+		DeviceSubClass = in.readString();
+		BusNumber = in.readString();
+		DeviceNumber = in.readString();
+		UsbVersion = in.readString();
+		DevicePath = in.readString();
+	}
+
+	@Override
+	public int describeContents() {
+		return 0;
+	}
+
+	public String getBusNumber() {
+		return BusNumber;
+	}
+
+	public String getDeviceClass() {
+		return DeviceClass;
+	}
+
+	public String getDeviceNumber() {
+		return DeviceNumber;
+	}
+
+	public String getDevicePath() {
+		return DevicePath;
+	}
+
+	public String getDeviceProtocol() {
+		return DeviceProtocol;
+	}
+
+	public String getDeviceSubClass() {
+		return DeviceSubClass;
+	}
+
+	public String getMaxPower() {
+		return MaxPower;
+	}
+
+	public String getPID() {
+		return PID;
+	}
+
+	public String getReportedProductName() {
+		return ReportedProductName;
+	}
+
+	public String getReportedVendorName() {
+		return ReportedVendorName;
+	}
+
+	public String getSerialNumber() {
+		return SerialNumber;
+	}
+
+	public String getSpeed() {
+		return Speed;
+	}
+
+	public String getUsbVersion() {
+		return UsbVersion;
+	}
+
+	public String getVID() {
+		return VID;
+	}
+
+	public void setBusNumber(String busNumber) {
+		BusNumber = busNumber;
+	}
+
+	public void setDeviceClass(String deviceClass) {
+		DeviceClass = deviceClass;
+	}
+
+	public void setDeviceNumber(String deviceNumber) {
+		DeviceNumber = deviceNumber;
+	}
+
+	public void setDevicePath(String devicePath) {
+		DevicePath = devicePath;
+	}
+
+	public void setDeviceProtocol(String deviceProtocol) {
+		DeviceProtocol = deviceProtocol;
+	}
+
+	public void setDeviceSubClass(String deviceSubClass) {
+		DeviceSubClass = deviceSubClass;
+	}
+
+	public void setMaxPower(String maxPower) {
+		MaxPower = maxPower;
+	}
+
+	public void setPID(String pID) {
+		PID = pID;
+	}
+
+	public void setReportedProductName(String reportedProductName) {
+		ReportedProductName = reportedProductName;
+	}
+
+	public void setReportedVendorName(String reportedVendorName) {
+		ReportedVendorName = reportedVendorName;
+	}
+
+	public void setSerialNumber(String serial) {
+		SerialNumber = serial;
+	}
+
+	public void setSpeed(String speed) {
+		Speed = speed;
+	}
+
+	public void setUsbVersion(String usbVersion) {
+		UsbVersion = usbVersion;
+	}
+
+	public void setVID(String vID) {
+		VID = vID;
+	}
+
+	@Override
+	public void writeToParcel(Parcel dest, int flags) {
+		dest.writeString(VID);
+		dest.writeString(PID);
+		dest.writeString(ReportedProductName);
+		dest.writeString(ReportedVendorName);
+		dest.writeString(SerialNumber);
+		dest.writeString(Speed);
+		dest.writeString(DeviceClass);
+		dest.writeString(DeviceProtocol);
+		dest.writeString(MaxPower);
+		dest.writeString(DeviceSubClass);
+		dest.writeString(BusNumber);
+		dest.writeString(DeviceNumber);
+		dest.writeString(UsbVersion);
+		dest.writeString(DevicePath);
+	}
+}
diff --git a/src/aws/apps/usbDeviceEnumerator/usb/sysbususb/SysBusUsbManager.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/usb/sysbususb/SysBusUsbManager.java
similarity index 97%
rename from src/aws/apps/usbDeviceEnumerator/usb/sysbususb/SysBusUsbManager.java
rename to app/src/main/java/aws/apps/usbDeviceEnumerator/usb/sysbususb/SysBusUsbManager.java
index 69ae748..11215f3 100644
--- a/src/aws/apps/usbDeviceEnumerator/usb/sysbususb/SysBusUsbManager.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/usb/sysbususb/SysBusUsbManager.java
@@ -1,145 +1,145 @@
-/*******************************************************************************
- * Copyright 2011 Alexandros Schillings
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-package aws.apps.usbDeviceEnumerator.usb.sysbususb;
-
-import java.io.BufferedReader;
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.FileReader;
-import java.io.IOException;
-import java.util.HashMap;
-
-import aws.apps.usbDeviceEnumerator.util.ExecTerminal;
-
-public class SysBusUsbManager {
-	//final String TAG =  this.getClass().getName();
-	private HashMap<String, SysBusUsbDevice> myUsbDevices;
-	
-	private static final String PATH_SYS_BUS_USB = "/sys/bus/usb/devices/";
-	private static final String DEVICE_START = "__DEV_START__";
-	private static final String DEVICE_END = "__DEV_END__";
-	
-	private static final String COMMAND_GET_USB_INFO = "for DEVICE in /sys/bus/usb/devices/*; do " +
-			" echo "+ DEVICE_START + ";" +
-			" [ -f $DEVICE/idProduct ] && echo PID: $(cat $DEVICE/idProduct);" +
-			" [ -f $DEVICE/idVendor ] && echo BUSNUM: $(cat $DEVICE/busnum);" +
-			" [ -f $DEVICE/idVendor ] && echo DEVCLASS: $(cat $DEVICE/bDeviceClass);" +
-			" [ -f $DEVICE/idVendor ] && echo DEVNUM: $(cat $DEVICE/devnum);" +
-			" [ -f $DEVICE/idVendor ] && echo DEVPROTOCOL: $(cat $DEVICE/bDeviceProtocol);" +
-			" [ -f $DEVICE/idVendor ] && echo DEVSUBCLASS: $(cat $DEVICE/bDeviceSubClass);" +
-			" [ -f $DEVICE/idVendor ] && echo MAXPOWER: $(cat $DEVICE/bMaxPower);" +
-			" [ -f $DEVICE/idVendor ] && echo SERIAL: $(cat $DEVICE/serial);" +
-			" [ -f $DEVICE/idVendor ] && echo SPEED: $(cat $DEVICE/speed);" +
-			" [ -f $DEVICE/idVendor ] && echo VERSION: $(cat $DEVICE/version);" +			
-			" [ -f $DEVICE/idVendor ] && echo VID: $(cat $DEVICE/idVendor);" +
-			" [ -f $DEVICE/product ] && echo MANUFACTURER: $(cat $DEVICE/manufacturer);"  +
-			" [ -f $DEVICE/product ] && echo PRODUCT: $(cat $DEVICE/product);"  +
-			" echo "+ DEVICE_END + ";" +
-			" done";
-
-	public static String getUsbInfoViaShell(){
-		String res = (new ExecTerminal()).exec(COMMAND_GET_USB_INFO);
-		
-		res = res.replace(DEVICE_START + "\n" + DEVICE_END + "\n", "");
-		return res;
-	}
-
-	public SysBusUsbManager(){
-		myUsbDevices = new HashMap<String, SysBusUsbDevice>();
-	}
-
-	public HashMap<String, SysBusUsbDevice> getUsbDevices(){
-		populateList(PATH_SYS_BUS_USB);
-		
-		return myUsbDevices;
-	}
-
-	private void populateList(String path){
-		SysBusUsbDevice usb;
-		
-		myUsbDevices.clear();	
-		
-		File dir = new File(path);
-		
-		if (!dir.isDirectory()){return;}
-		
-		for (File child : dir.listFiles()) {
-			
-			if (".".equals(child.getName()) || "..".equals(child.getName())) {
-				continue;  // Ignore the self and parent aliases.
-			}
-			
-			String parentPath = child.getAbsolutePath() + File.separator;
-			
-			usb = new SysBusUsbDevice();
-			usb.setDevicePath(parentPath);
-			usb.setBusNumber(readFileContents(parentPath + "busnum"));
-			usb.setDeviceClass(readFileContents(parentPath + "bDeviceClass"));
-			usb.setDeviceNumber(readFileContents(parentPath + "devnum"));
-			usb.setDeviceProtocol(readFileContents(parentPath + "bDeviceProtocol"));
-			usb.setDeviceSubClass(readFileContents(parentPath + "bDeviceSubClass"));
-			usb.setMaxPower(readFileContents(parentPath + "bMaxPower"));
-			usb.setPID(readFileContents(parentPath + "idProduct"));
-			usb.setReportedProductName(readFileContents(parentPath + "product"));
-			usb.setReportedVendorName(readFileContents(parentPath + "manufacturer"));
-			usb.setSerialNumber(readFileContents(parentPath + "serial"));
-			usb.setSpeed(readFileContents(parentPath + "speed"));
-			usb.setVID(readFileContents(parentPath + "idVendor"));
-			usb.setUsbVersion(readFileContents(parentPath + "version"));
-
-			if(usb.getBusNumber().length() > 0 && usb.getDeviceNumber().length() > 0){
-				String key = child.getName();
-				myUsbDevices.put(key, usb);
-			}
-		}
-	}
-
-	private String readFileContents(String filePath){
-		File file = new File(filePath);
-		if(!file.exists()){return "";}
-		if(file.isDirectory()){return "";}
-		
-        StringBuffer fileData = new StringBuffer(1000);
-        BufferedReader reader;
-		try {
-			reader = new BufferedReader(new FileReader(filePath));
-
-        char[] buf = new char[1024];
-        int numRead=0;
-        
-        while((numRead=reader.read(buf)) != -1){
-            String readData = String.valueOf(buf, 0, numRead);
-            fileData.append(readData);
-            buf = new char[1024];
-        }
-        
-        reader.close();
-        
-		} catch (FileNotFoundException e) {
-			e.printStackTrace();
-			return "";
-		} catch (IOException e) {
-			e.printStackTrace();
-			return "";
-		}
-
-		String res = fileData.toString();
-		if(res == null){
-			res = "";
-		}
-        return res.trim();
-	}
-}
+/*******************************************************************************
+ * Copyright 2011 Alexandros Schillings
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package aws.apps.usbDeviceEnumerator.usb.sysbususb;
+
+import java.io.BufferedReader;
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.io.FileReader;
+import java.io.IOException;
+import java.util.HashMap;
+
+import aws.apps.usbDeviceEnumerator.util.ExecTerminal;
+
+public class SysBusUsbManager {
+	//final String TAG =  this.getClass().getName();
+	private HashMap<String, SysBusUsbDevice> myUsbDevices;
+	
+	private static final String PATH_SYS_BUS_USB = "/sys/bus/usb/devices/";
+	private static final String DEVICE_START = "__DEV_START__";
+	private static final String DEVICE_END = "__DEV_END__";
+	
+	private static final String COMMAND_GET_USB_INFO = "for DEVICE in /sys/bus/usb/devices/*; do " +
+			" echo "+ DEVICE_START + ";" +
+			" [ -f $DEVICE/idProduct ] && echo PID: $(cat $DEVICE/idProduct);" +
+			" [ -f $DEVICE/idVendor ] && echo BUSNUM: $(cat $DEVICE/busnum);" +
+			" [ -f $DEVICE/idVendor ] && echo DEVCLASS: $(cat $DEVICE/bDeviceClass);" +
+			" [ -f $DEVICE/idVendor ] && echo DEVNUM: $(cat $DEVICE/devnum);" +
+			" [ -f $DEVICE/idVendor ] && echo DEVPROTOCOL: $(cat $DEVICE/bDeviceProtocol);" +
+			" [ -f $DEVICE/idVendor ] && echo DEVSUBCLASS: $(cat $DEVICE/bDeviceSubClass);" +
+			" [ -f $DEVICE/idVendor ] && echo MAXPOWER: $(cat $DEVICE/bMaxPower);" +
+			" [ -f $DEVICE/idVendor ] && echo SERIAL: $(cat $DEVICE/serial);" +
+			" [ -f $DEVICE/idVendor ] && echo SPEED: $(cat $DEVICE/speed);" +
+			" [ -f $DEVICE/idVendor ] && echo VERSION: $(cat $DEVICE/version);" +			
+			" [ -f $DEVICE/idVendor ] && echo VID: $(cat $DEVICE/idVendor);" +
+			" [ -f $DEVICE/product ] && echo MANUFACTURER: $(cat $DEVICE/manufacturer);"  +
+			" [ -f $DEVICE/product ] && echo PRODUCT: $(cat $DEVICE/product);"  +
+			" echo "+ DEVICE_END + ";" +
+			" done";
+
+	public static String getUsbInfoViaShell(){
+		String res = (new ExecTerminal()).exec(COMMAND_GET_USB_INFO);
+		
+		res = res.replace(DEVICE_START + "\n" + DEVICE_END + "\n", "");
+		return res;
+	}
+
+	public SysBusUsbManager(){
+		myUsbDevices = new HashMap<String, SysBusUsbDevice>();
+	}
+
+	public HashMap<String, SysBusUsbDevice> getUsbDevices(){
+		populateList(PATH_SYS_BUS_USB);
+		
+		return myUsbDevices;
+	}
+
+	private void populateList(String path){
+		SysBusUsbDevice usb;
+		
+		myUsbDevices.clear();	
+		
+		File dir = new File(path);
+		
+		if (!dir.isDirectory()){return;}
+		
+		for (File child : dir.listFiles()) {
+			
+			if (".".equals(child.getName()) || "..".equals(child.getName())) {
+				continue;  // Ignore the self and parent aliases.
+			}
+			
+			String parentPath = child.getAbsolutePath() + File.separator;
+			
+			usb = new SysBusUsbDevice();
+			usb.setDevicePath(parentPath);
+			usb.setBusNumber(readFileContents(parentPath + "busnum"));
+			usb.setDeviceClass(readFileContents(parentPath + "bDeviceClass"));
+			usb.setDeviceNumber(readFileContents(parentPath + "devnum"));
+			usb.setDeviceProtocol(readFileContents(parentPath + "bDeviceProtocol"));
+			usb.setDeviceSubClass(readFileContents(parentPath + "bDeviceSubClass"));
+			usb.setMaxPower(readFileContents(parentPath + "bMaxPower"));
+			usb.setPID(readFileContents(parentPath + "idProduct"));
+			usb.setReportedProductName(readFileContents(parentPath + "product"));
+			usb.setReportedVendorName(readFileContents(parentPath + "manufacturer"));
+			usb.setSerialNumber(readFileContents(parentPath + "serial"));
+			usb.setSpeed(readFileContents(parentPath + "speed"));
+			usb.setVID(readFileContents(parentPath + "idVendor"));
+			usb.setUsbVersion(readFileContents(parentPath + "version"));
+
+			if(usb.getBusNumber().length() > 0 && usb.getDeviceNumber().length() > 0){
+				String key = child.getName();
+				myUsbDevices.put(key, usb);
+			}
+		}
+	}
+
+	private String readFileContents(String filePath){
+		File file = new File(filePath);
+		if(!file.exists()){return "";}
+		if(file.isDirectory()){return "";}
+		
+        StringBuffer fileData = new StringBuffer(1000);
+        BufferedReader reader;
+		try {
+			reader = new BufferedReader(new FileReader(filePath));
+
+        char[] buf = new char[1024];
+        int numRead=0;
+        
+        while((numRead=reader.read(buf)) != -1){
+            String readData = String.valueOf(buf, 0, numRead);
+            fileData.append(readData);
+            buf = new char[1024];
+        }
+        
+        reader.close();
+        
+		} catch (FileNotFoundException e) {
+			e.printStackTrace();
+			return "";
+		} catch (IOException e) {
+			e.printStackTrace();
+			return "";
+		}
+
+		String res = fileData.toString();
+		if(res == null){
+			res = "";
+		}
+        return res.trim();
+	}
+}
diff --git a/src/aws/apps/usbDeviceEnumerator/util/ExecTerminal.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/util/ExecTerminal.java
similarity index 96%
rename from src/aws/apps/usbDeviceEnumerator/util/ExecTerminal.java
rename to app/src/main/java/aws/apps/usbDeviceEnumerator/util/ExecTerminal.java
index 5736e70..a7d50e6 100644
--- a/src/aws/apps/usbDeviceEnumerator/util/ExecTerminal.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/util/ExecTerminal.java
@@ -1,104 +1,104 @@
-/*******************************************************************************
- * Copyright 2011 Alexandros Schillings
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-package aws.apps.usbDeviceEnumerator.util;
-
-import java.io.BufferedReader;
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.io.InputStreamReader;
-
-import android.util.Log;
-
-public class ExecTerminal {
-	final String TAG =  this.getClass().getName();
-
-	public String exec(String cmd) {
-		Log.d(TAG, "^ Executing '" + cmd + "'");
-		try {
-			Process process = Runtime.getRuntime().exec("sh");
-			DataInputStream is = new DataInputStream(process.getInputStream());
-			DataOutputStream os = new DataOutputStream(process.getOutputStream());
-			os.writeBytes(cmd + "\n");
-			os.writeBytes("exit\n");
-			os.flush();
-			os.close();
-
-			BufferedReader reader = new BufferedReader(
-					new InputStreamReader(is));
-			try {
-				String fullOutput = "";
-				String line;
-				while ((line = reader.readLine()) != null) {
-					fullOutput = fullOutput + line + "\n";
-				}
-				return fullOutput;
-			} catch (IOException e) {
-				Log.e(TAG, "^ exec, IOException 1");
-				e.printStackTrace();
-			}
-
-			process.waitFor();
-
-		} catch (IOException e) {
-			Log.e(TAG, "^ exec, IOException 2");
-			e.printStackTrace();
-
-		} catch (InterruptedException e) {
-			Log.e(TAG, "^ exec, InterruptedException");
-			e.printStackTrace();
-		}
-		return "";
-	}
-
-	public String execSu(String cmd) {
-		Log.d(TAG, "^ Executing as SU '" + cmd + "'");
-		try {
-			Process process = Runtime.getRuntime().exec("su");
-			DataInputStream is = new DataInputStream(process.getInputStream());
-			DataOutputStream os = new DataOutputStream(process
-					.getOutputStream());
-			os.writeBytes(cmd + "\n");
-			os.writeBytes("exit\n");
-			os.flush();
-			os.close();
-
-			BufferedReader reader = new BufferedReader(new InputStreamReader(is));
-
-			try {
-				String fullOutput = "";
-				String line;
-				while ((line = reader.readLine()) != null) {
-					fullOutput = fullOutput + line + "\n";
-				}
-				return fullOutput;
-			} catch (IOException e) {// It seems IOException is thrown when it reaches EOF.
-				e.printStackTrace();
-				Log.e(TAG, "^ execSU, IOException 1");
-			}
-			process.waitFor();
-
-		} catch (IOException e) {
-			e.printStackTrace();
-			Log.e(TAG, "^ execSU, IOException 2");
-		} catch (InterruptedException e) {
-			e.printStackTrace();
-			Log.e(TAG, "^ execSU, InterruptedException");
-		}
-		return "";
-	}
-}
-
+/*******************************************************************************
+ * Copyright 2011 Alexandros Schillings
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package aws.apps.usbDeviceEnumerator.util;
+
+import java.io.BufferedReader;
+import java.io.DataInputStream;
+import java.io.DataOutputStream;
+import java.io.IOException;
+import java.io.InputStreamReader;
+
+import android.util.Log;
+
+public class ExecTerminal {
+	final String TAG =  this.getClass().getName();
+
+	public String exec(String cmd) {
+		Log.d(TAG, "^ Executing '" + cmd + "'");
+		try {
+			Process process = Runtime.getRuntime().exec("sh");
+			DataInputStream is = new DataInputStream(process.getInputStream());
+			DataOutputStream os = new DataOutputStream(process.getOutputStream());
+			os.writeBytes(cmd + "\n");
+			os.writeBytes("exit\n");
+			os.flush();
+			os.close();
+
+			BufferedReader reader = new BufferedReader(
+					new InputStreamReader(is));
+			try {
+				String fullOutput = "";
+				String line;
+				while ((line = reader.readLine()) != null) {
+					fullOutput = fullOutput + line + "\n";
+				}
+				return fullOutput;
+			} catch (IOException e) {
+				Log.e(TAG, "^ exec, IOException 1");
+				e.printStackTrace();
+			}
+
+			process.waitFor();
+
+		} catch (IOException e) {
+			Log.e(TAG, "^ exec, IOException 2");
+			e.printStackTrace();
+
+		} catch (InterruptedException e) {
+			Log.e(TAG, "^ exec, InterruptedException");
+			e.printStackTrace();
+		}
+		return "";
+	}
+
+	public String execSu(String cmd) {
+		Log.d(TAG, "^ Executing as SU '" + cmd + "'");
+		try {
+			Process process = Runtime.getRuntime().exec("su");
+			DataInputStream is = new DataInputStream(process.getInputStream());
+			DataOutputStream os = new DataOutputStream(process
+					.getOutputStream());
+			os.writeBytes(cmd + "\n");
+			os.writeBytes("exit\n");
+			os.flush();
+			os.close();
+
+			BufferedReader reader = new BufferedReader(new InputStreamReader(is));
+
+			try {
+				String fullOutput = "";
+				String line;
+				while ((line = reader.readLine()) != null) {
+					fullOutput = fullOutput + line + "\n";
+				}
+				return fullOutput;
+			} catch (IOException e) {// It seems IOException is thrown when it reaches EOF.
+				e.printStackTrace();
+				Log.e(TAG, "^ execSU, IOException 1");
+			}
+			process.waitFor();
+
+		} catch (IOException e) {
+			e.printStackTrace();
+			Log.e(TAG, "^ execSU, IOException 2");
+		} catch (InterruptedException e) {
+			e.printStackTrace();
+			Log.e(TAG, "^ execSU, InterruptedException");
+		}
+		return "";
+	}
+}
+
diff --git a/src/aws/apps/usbDeviceEnumerator/util/UsefulBits.java b/app/src/main/java/aws/apps/usbDeviceEnumerator/util/UsefulBits.java
similarity index 96%
rename from src/aws/apps/usbDeviceEnumerator/util/UsefulBits.java
rename to app/src/main/java/aws/apps/usbDeviceEnumerator/util/UsefulBits.java
index 11b7ddd..36aada1 100644
--- a/src/aws/apps/usbDeviceEnumerator/util/UsefulBits.java
+++ b/app/src/main/java/aws/apps/usbDeviceEnumerator/util/UsefulBits.java
@@ -1,230 +1,230 @@
-/*******************************************************************************
- * Copyright 2011 Alexandros Schillings
- * 
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- * 
- *   http://www.apache.org/licenses/LICENSE-2.0
- * 
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- ******************************************************************************/
-package aws.apps.usbDeviceEnumerator.util;
-
-import java.io.BufferedWriter;
-import java.io.File;
-import java.io.FileWriter;
-import java.text.Format;
-import java.text.SimpleDateFormat;
-import java.util.Calendar;
-import java.util.Date;
-
-import android.app.AlertDialog;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager.NameNotFoundException;
-import android.net.ConnectivityManager;
-import android.util.Log;
-import android.view.Gravity;
-import android.view.View;
-import android.widget.EditText;
-import android.widget.TableLayout;
-import android.widget.TableRow;
-import android.widget.TextView;
-import android.widget.Toast;
-import aws.apps.usbDeviceEnumerator.R;
-import aws.apps.usbDeviceEnumerator.ui.MyAlertBox;
-
-public class UsefulBits {
-	
-	public static void share(Context context, String subject, String text){
-		Intent intent = new Intent(Intent.ACTION_SEND);
-		
-		intent.setType("text/plain");
-		intent.putExtra(Intent.EXTRA_TEXT, text);
-		intent.putExtra(Intent.EXTRA_SUBJECT, subject);
-		intent.addCategory(Intent.CATEGORY_DEFAULT);
-		Intent share = Intent.createChooser(intent, context.getString(R.string.share_result_via));
-		context.startActivity(share);
-	}
-	final String TAG =  this.getClass().getName();
-
-	private Context c;
-
-	public UsefulBits(Context cntx) {
-		c = cntx;
-	}
-
-	public Calendar convertMillisToDate(long millis){
-		Calendar calendar = Calendar.getInstance();
-		calendar.setTimeInMillis(millis);
-		return calendar;
-	}
-	
-	public boolean createDirectories(String dirs){
-		Log.d(TAG, "^ createDirectories - Attempting to create: " + dirs);
-		try{
-
-			if (new File(dirs).exists()){
-				Log.d(TAG, "^ createDirectories - Directory already exist:" + dirs);
-				return true;
-			}
-
-			// create a File object for the parent directory
-			File newDirectories = new File(dirs);
-			// have the object build the directory structure, if needed.
-			if(newDirectories.mkdirs()){
-				showToast("Directories created: " + dirs, 
-						Toast.LENGTH_SHORT, Gravity.TOP,0,0);
-				Log.d(TAG, "^ createDirectories - Directory created:" + dirs);
-				return true;					
-			} else {
-				showToast("Could not create: " + dirs, 
-						Toast.LENGTH_SHORT, Gravity.TOP,0,0);
-				Log.e(TAG, "^ createDirectories - Could not create:" + dirs);
-				return false;
-			}
-
-		}catch (Exception e){//Catch exception if any
-			showToast("Could not create: " + dirs, 
-					Toast.LENGTH_SHORT, Gravity.TOP,0,0);
-			Log.e(TAG, "^ createDirectories - something went wrong (" + dirs + ") " + e.getMessage());	
-			return false;
-		}
-	} 
-
-	public String formatDateTime(String formatString, Date d){
-		Format formatter = new SimpleDateFormat(formatString);
-		return formatter.format(d);
-	}
-
-	public String getAppVersion(){
-		PackageInfo pi;
-		try {
-			pi = c.getPackageManager().getPackageInfo(c.getPackageName(), 0);
-			return pi.versionName;
-		} catch (NameNotFoundException e) {
-			return "";
-		}
-	}
-	
-	public boolean isOnline() {
-		try{ 
-			ConnectivityManager cm = (ConnectivityManager) c.getSystemService(Context.CONNECTIVITY_SERVICE);
-			
-			if (cm != null) {
-				Log.d(TAG, "^ isOnline()=true");
-				return cm.getActiveNetworkInfo().isConnected();
-			} else {
-				Log.d(TAG, "^ isOnline()=false");
-				return false;
-			}
-					
-			}catch(Exception e){
-				Log.e(TAG, "^ isOnline()=false", e);
-				return false;
-			}
-	}
-
-	public void saveToFile(String fileName, File directory, String contents){
-
-		if (android.os.Environment.getExternalStorageState().equals(
-				android.os.Environment.MEDIA_MOUNTED)){
-			try {
-
-				if (directory.canWrite()){
-					File gpxfile = new File(directory, fileName);
-					FileWriter gpxwriter = new FileWriter(gpxfile);
-					BufferedWriter out = new BufferedWriter(gpxwriter);
-					out.write(contents);
-					out.close();
-					showToast("Saved to SD as '" + directory.getAbsolutePath() + "/" + fileName + "'", 
-							Toast.LENGTH_SHORT, Gravity.TOP,0,0);
-				}
-
-			} catch (Exception e) {
-				showToast("Could not write file:\n+ e.getMessage()", 
-						Toast.LENGTH_SHORT, Gravity.TOP,0,0);
-				Log.e(TAG, "^ Could not write file " + e.getMessage());
-			}
-
-		}else{
-			showToast("No SD card is mounted...", Toast.LENGTH_SHORT, Gravity.TOP,0,0);
-			Log.e(TAG, "^ No SD card is mounted.");		
-		}
-	}
-
-	public void showAboutDialogue(){
-		String title = c.getString(R.string.app_name) + " v"+ getAppVersion();
-		
-		StringBuffer sb = new StringBuffer();
-		
-		sb.append(c.getString(R.string.app_changelog));
-		sb.append("\n\n");
-		sb.append(c.getString(R.string.app_notes));
-		sb.append("\n\n");
-		sb.append(c.getString(R.string.app_acknowledgements));
-		sb.append("\n\n");		
-		sb.append(c.getString(R.string.app_copyright));
-		
-		MyAlertBox.create(c, sb.toString(), title, c.getString(android.R.string.ok)).show();
-	}
-
-	public void ShowAlert(String title, String text, String button){
-		if (button.equals("")){button = c.getString(android.R.string.ok);}
-
-		try{
-			AlertDialog.Builder ad = new AlertDialog.Builder(c);
-			ad.setTitle( title );
-			ad.setMessage(text);
-
-			ad.setPositiveButton( button, null );
-			ad.show();
-		}catch (Exception e){
-			Log.e(TAG, "^ ShowAlert()", e);
-		}	
-	}
-	
-	public void showToast(String message, int duration, int location, int x_offset, int y_offset){
-		Toast toast = Toast.makeText(c.getApplicationContext(), message, duration);
-		toast.setGravity(location,x_offset,y_offset);
-		toast.show();
-	}
-	
-	public String tableToString(TableLayout t) {
-		String res = "";
-		if(t==null){return res;}
-
-		for (int i=0; i <= t.getChildCount()-1; i++){
-			TableRow row = (TableRow) t.getChildAt(i);
-
-			for (int j=0; j <= row.getChildCount()-1; j++){
-				View v = row.getChildAt(j);
-
-				try {
-					if(v.getClass() == Class.forName("android.widget.TextView")){
-						TextView tmp = (TextView) v;
-						res += tmp.getText();
-
-						if(j==0){res += " ";}
-					} else if(v.getClass() == Class.forName("android.widget.EditText")){
-						EditText tmp = (EditText) v;
-						res += tmp.getText().toString();
-					} else {
-						//do nothing
-					}
-				} catch (Exception e) {
-					res = e.toString();
-					Log.e(TAG, "^ ERROR: tableToString: " + res);
-				}
-			}
-			res +="\n";
-		}
-		return res;
-	}
-}
+/*******************************************************************************
+ * Copyright 2011 Alexandros Schillings
+ * 
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ * 
+ *   http://www.apache.org/licenses/LICENSE-2.0
+ * 
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ ******************************************************************************/
+package aws.apps.usbDeviceEnumerator.util;
+
+import java.io.BufferedWriter;
+import java.io.File;
+import java.io.FileWriter;
+import java.text.Format;
+import java.text.SimpleDateFormat;
+import java.util.Calendar;
+import java.util.Date;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.net.ConnectivityManager;
+import android.util.Log;
+import android.view.Gravity;
+import android.view.View;
+import android.widget.EditText;
+import android.widget.TableLayout;
+import android.widget.TableRow;
+import android.widget.TextView;
+import android.widget.Toast;
+import aws.apps.usbDeviceEnumerator.R;
+import aws.apps.usbDeviceEnumerator.ui.MyAlertBox;
+
+public class UsefulBits {
+	
+	public static void share(Context context, String subject, String text){
+		Intent intent = new Intent(Intent.ACTION_SEND);
+		
+		intent.setType("text/plain");
+		intent.putExtra(Intent.EXTRA_TEXT, text);
+		intent.putExtra(Intent.EXTRA_SUBJECT, subject);
+		intent.addCategory(Intent.CATEGORY_DEFAULT);
+		Intent share = Intent.createChooser(intent, context.getString(R.string.share_result_via));
+		context.startActivity(share);
+	}
+	final String TAG =  this.getClass().getName();
+
+	private Context c;
+
+	public UsefulBits(Context cntx) {
+		c = cntx;
+	}
+
+	public Calendar convertMillisToDate(long millis){
+		Calendar calendar = Calendar.getInstance();
+		calendar.setTimeInMillis(millis);
+		return calendar;
+	}
+	
+	public boolean createDirectories(String dirs){
+		Log.d(TAG, "^ createDirectories - Attempting to create: " + dirs);
+		try{
+
+			if (new File(dirs).exists()){
+				Log.d(TAG, "^ createDirectories - Directory already exist:" + dirs);
+				return true;
+			}
+
+			// create a File object for the parent directory
+			File newDirectories = new File(dirs);
+			// have the object build the directory structure, if needed.
+			if(newDirectories.mkdirs()){
+				showToast("Directories created: " + dirs, 
+						Toast.LENGTH_SHORT, Gravity.TOP,0,0);
+				Log.d(TAG, "^ createDirectories - Directory created:" + dirs);
+				return true;					
+			} else {
+				showToast("Could not create: " + dirs, 
+						Toast.LENGTH_SHORT, Gravity.TOP,0,0);
+				Log.e(TAG, "^ createDirectories - Could not create:" + dirs);
+				return false;
+			}
+
+		}catch (Exception e){//Catch exception if any
+			showToast("Could not create: " + dirs, 
+					Toast.LENGTH_SHORT, Gravity.TOP,0,0);
+			Log.e(TAG, "^ createDirectories - something went wrong (" + dirs + ") " + e.getMessage());	
+			return false;
+		}
+	} 
+
+	public String formatDateTime(String formatString, Date d){
+		Format formatter = new SimpleDateFormat(formatString);
+		return formatter.format(d);
+	}
+
+	public String getAppVersion(){
+		PackageInfo pi;
+		try {
+			pi = c.getPackageManager().getPackageInfo(c.getPackageName(), 0);
+			return pi.versionName;
+		} catch (NameNotFoundException e) {
+			return "";
+		}
+	}
+	
+	public boolean isOnline() {
+		try{ 
+			ConnectivityManager cm = (ConnectivityManager) c.getSystemService(Context.CONNECTIVITY_SERVICE);
+			
+			if (cm != null) {
+				Log.d(TAG, "^ isOnline()=true");
+				return cm.getActiveNetworkInfo().isConnected();
+			} else {
+				Log.d(TAG, "^ isOnline()=false");
+				return false;
+			}
+					
+			}catch(Exception e){
+				Log.e(TAG, "^ isOnline()=false", e);
+				return false;
+			}
+	}
+
+	public void saveToFile(String fileName, File directory, String contents){
+
+		if (android.os.Environment.getExternalStorageState().equals(
+				android.os.Environment.MEDIA_MOUNTED)){
+			try {
+
+				if (directory.canWrite()){
+					File gpxfile = new File(directory, fileName);
+					FileWriter gpxwriter = new FileWriter(gpxfile);
+					BufferedWriter out = new BufferedWriter(gpxwriter);
+					out.write(contents);
+					out.close();
+					showToast("Saved to SD as '" + directory.getAbsolutePath() + "/" + fileName + "'", 
+							Toast.LENGTH_SHORT, Gravity.TOP,0,0);
+				}
+
+			} catch (Exception e) {
+				showToast("Could not write file:\n+ e.getMessage()", 
+						Toast.LENGTH_SHORT, Gravity.TOP,0,0);
+				Log.e(TAG, "^ Could not write file " + e.getMessage());
+			}
+
+		}else{
+			showToast("No SD card is mounted...", Toast.LENGTH_SHORT, Gravity.TOP,0,0);
+			Log.e(TAG, "^ No SD card is mounted.");		
+		}
+	}
+
+	public void showAboutDialogue(){
+		String title = c.getString(R.string.app_name) + " v"+ getAppVersion();
+		
+		StringBuffer sb = new StringBuffer();
+		
+		sb.append(c.getString(R.string.app_changelog));
+		sb.append("\n\n");
+		sb.append(c.getString(R.string.app_notes));
+		sb.append("\n\n");
+		sb.append(c.getString(R.string.app_acknowledgements));
+		sb.append("\n\n");		
+		sb.append(c.getString(R.string.app_copyright));
+		
+		MyAlertBox.create(c, sb.toString(), title, c.getString(android.R.string.ok)).show();
+	}
+
+	public void ShowAlert(String title, String text, String button){
+		if (button.equals("")){button = c.getString(android.R.string.ok);}
+
+		try{
+			AlertDialog.Builder ad = new AlertDialog.Builder(c);
+			ad.setTitle( title );
+			ad.setMessage(text);
+
+			ad.setPositiveButton( button, null );
+			ad.show();
+		}catch (Exception e){
+			Log.e(TAG, "^ ShowAlert()", e);
+		}	
+	}
+	
+	public void showToast(String message, int duration, int location, int x_offset, int y_offset){
+		Toast toast = Toast.makeText(c.getApplicationContext(), message, duration);
+		toast.setGravity(location,x_offset,y_offset);
+		toast.show();
+	}
+	
+	public String tableToString(TableLayout t) {
+		String res = "";
+		if(t==null){return res;}
+
+		for (int i=0; i <= t.getChildCount()-1; i++){
+			TableRow row = (TableRow) t.getChildAt(i);
+
+			for (int j=0; j <= row.getChildCount()-1; j++){
+				View v = row.getChildAt(j);
+
+				try {
+					if(v.getClass() == Class.forName("android.widget.TextView")){
+						TextView tmp = (TextView) v;
+						res += tmp.getText();
+
+						if(j==0){res += " ";}
+					} else if(v.getClass() == Class.forName("android.widget.EditText")){
+						EditText tmp = (EditText) v;
+						res += tmp.getText().toString();
+					} else {
+						//do nothing
+					}
+				} catch (Exception e) {
+					res = e.toString();
+					Log.e(TAG, "^ ERROR: tableToString: " + res);
+				}
+			}
+			res +="\n";
+		}
+		return res;
+	}
+}
