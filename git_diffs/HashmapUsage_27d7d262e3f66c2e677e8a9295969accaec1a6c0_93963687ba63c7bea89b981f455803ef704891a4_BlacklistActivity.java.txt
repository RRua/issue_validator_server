diff --git a/project/app/src/main/java/android/media/RemoteController.java b/project/app/src/main/java/android/media/RemoteController.java
index 3c676bdd..64f36562 100644
--- a/project/app/src/main/java/android/media/RemoteController.java
+++ b/project/app/src/main/java/android/media/RemoteController.java
@@ -23,6 +23,10 @@ import android.content.Context;
 import android.graphics.Bitmap;
 import android.view.KeyEvent;
 
+/*
+    This is needed to avoid of exceptions on
+    pre-KitKat platforms.
+ */
 public class RemoteController {
 
     public RemoteController(Context context, OnClientUpdateListener l) {
diff --git a/project/app/src/main/java/com/achep/acdisplay/App.java b/project/app/src/main/java/com/achep/acdisplay/App.java
index 2158d433..1658dac4 100644
--- a/project/app/src/main/java/com/achep/acdisplay/App.java
+++ b/project/app/src/main/java/com/achep/acdisplay/App.java
@@ -19,19 +19,35 @@
 package com.achep.acdisplay;
 
 import android.app.Application;
-import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Base64;
+import android.util.Log;
 
 import com.achep.acdisplay.blacklist.Blacklist;
 import com.achep.acdisplay.services.KeyguardService;
 import com.achep.acdisplay.services.SensorsDumpService;
 import com.achep.acdisplay.services.activemode.ActiveModeService;
-import com.achep.acdisplay.utils.ToastUtils;
+import com.achep.base.Build;
+
+import org.solovyev.android.checkout.Billing;
+import org.solovyev.android.checkout.Checkout;
+import org.solovyev.android.checkout.Inventory;
+import org.solovyev.android.checkout.ProductTypes;
+import org.solovyev.android.checkout.Products;
+import org.solovyev.android.checkout.RobotmediaDatabase;
+import org.solovyev.android.checkout.RobotmediaInventory;
+
+import java.util.Arrays;
+import java.util.concurrent.Executor;
 
 /**
  * Created by Artem on 22.02.14.
  */
 public class App extends Application {
 
+    private static final String TAG = "App";
+
     public static final int ID_NOTIFY_INIT = 30;
     public static final int ID_NOTIFY_TEST = 40;
     public static final int ID_NOTIFY_BATH = 50;
@@ -48,12 +64,109 @@ public class App extends Application {
     public static final String ACTION_INTERNAL_TIMEOUT = "TIMEOUT";
     public static final String ACTION_INTERNAL_PING_SENSORS = "PING_SENSORS";
 
+    @NonNull
+    private static final Products sProducts = Products.create()
+            .add(ProductTypes.IN_APP, Arrays.asList(
+                    "donation_1",
+                    "donation_4",
+                    "donation_10",
+                    "donation_20",
+                    "donation_50",
+                    "donation_99"))
+            .add(ProductTypes.SUBSCRIPTION, Arrays.asList(""));
+
+    /**
+     * For better performance billing class should be used as singleton
+     */
+    @NonNull
+    private final Billing mBilling = new Billing(this, new Billing.DefaultConfiguration() {
+
+        @NonNull
+        @Override
+        public String getPublicKey() {
+            // TODO: Somehow replace those local variables on build.
+            // final String k = "__BUILD_SCRIPT__:ENCRYPTED_PUBLIC_KEY:";
+            // final String s = "__BUILD_SCRIPT__:ENCRYPTED_PUBLIC_KEY_SALT:";
+            final String k = Build.GOOGLE_PLAY_PUBLIC_KEY_ENCRYPTED;
+            final String s = Build.GOOGLE_PLAY_PUBLIC_KEY_SALT;
+            try {
+                return fromX(k, s);
+            } catch (IllegalArgumentException e) {
+                Log.e(TAG, "Failed to decode the public Google Play key!");
+            }
+            return "fail";
+        }
+
+        @Nullable
+        @Override
+        public Inventory getFallbackInventory(@NonNull Checkout checkout,
+                                              @NonNull Executor onLoadExecutor) {
+            if (RobotmediaDatabase.exists(mBilling.getContext())) {
+                return new RobotmediaInventory(checkout, onLoadExecutor);
+            } else {
+                return null;
+            }
+        }
+
+    });
+
+    /**
+     * Application wide {@link org.solovyev.android.checkout.Checkout} instance
+     * (can be used anywhere in the app). This instance contains all available
+     * products in the app.
+     */
+    @NonNull
+    private final Checkout mCheckout = Checkout.forApplication(mBilling, sProducts);
+
+    /**
+     * Method deciphers previously ciphered message
+     *
+     * @param message ciphered message
+     * @param salt    salt which was used for ciphering
+     * @return deciphered message
+     */
+    @NonNull
+    static String fromX(@NonNull String message, @NonNull String salt)
+            throws IllegalArgumentException {
+        return x(new String(Base64.decode(message, Base64.URL_SAFE)), salt);
+    }
+
+    /**
+     * Symmetric algorithm used for ciphering/deciphering.
+     *
+     * @param message message
+     * @param salt    salt
+     * @return ciphered/deciphered message
+     */
+    @NonNull
+    static String x(@NonNull String message, @NonNull String salt) {
+        final char[] m = message.toCharArray();
+        final char[] s = salt.toCharArray();
+
+        final int ml = m.length;
+        final int sl = s.length;
+        final char[] result = new char[ml];
+
+        for (int i = 0; i < ml; i++) {
+            result[i] = (char) (m[i] ^ s[i % sl]);
+        }
+        return new String(result);
+    }
+
+    @NonNull
+    private static App instance;
+
+    public App() {
+        instance = this;
+    }
+
     @Override
     public void onCreate() {
         Config.getInstance().init(this);
         Blacklist.getInstance().init(this);
 
         super.onCreate();
+        mBilling.connect();
 
         // Launch keyguard and (or) active mode on
         // app launch.
@@ -64,17 +177,19 @@ public class App extends Application {
 
     @Override
     public void onLowMemory() {
-        super.onLowMemory();
         Config.getInstance().onLowMemory();
         Blacklist.getInstance().onLowMemory();
+        super.onLowMemory();
     }
 
-    /**
-     * Starts Easter Eggs' activity.
-     */
-    // TODO: Put an Easter egg here.
-    public static void startEasterEggs(Context context) {
-        if (Build.DEBUG) ToastUtils.showShort(context, "There will be an Easter Egg.");
+    @NonNull
+    public static App get() {
+        return instance;
+    }
+
+    @NonNull
+    public static Checkout getCheckout() {
+        return instance.mCheckout;
     }
 
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/Atomic.java b/project/app/src/main/java/com/achep/acdisplay/Atomic.java
index 10980729..375bde43 100644
--- a/project/app/src/main/java/com/achep/acdisplay/Atomic.java
+++ b/project/app/src/main/java/com/achep/acdisplay/Atomic.java
@@ -22,6 +22,8 @@ import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Log;
 
+import static com.achep.base.Build.DEBUG;
+
 /**
  * A class for atomic handling start & stop events.
  *
@@ -50,13 +52,21 @@ public final class Atomic {
         mTag = tag == null ? getClass().getSimpleName() : tag;
     }
 
+    public void react(boolean start, Object... objects) {
+        if (start) {
+            start(objects);
+        } else {
+            stop(objects);
+        }
+    }
+
     public void start(Object... objects) {
         synchronized (this) {
             if (!mStarted) {
                 mStarted = true;
                 mCallback.onStart(objects);
             } else {
-                if (Build.DEBUG) Log.d(mTag, "Starting already started.");
+                if (DEBUG) Log.d(mTag, "Starting already started.");
             }
         }
     }
@@ -67,13 +77,15 @@ public final class Atomic {
                 mStarted = false;
                 mCallback.onStop(objects);
             } else {
-                if (Build.DEBUG) Log.d(mTag, "Stopping already stopped.");
+                if (DEBUG) Log.d(mTag, "Stopping already stopped.");
             }
         }
     }
 
     public boolean isRunning() {
-        return mStarted;
+        synchronized (this) {
+            return mStarted;
+        }
     }
 
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/Build.java b/project/app/src/main/java/com/achep/acdisplay/Build.java
deleted file mode 100644
index 86d65a69..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/Build.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.acdisplay;
-
-/**
- * Created by Artem on 30.12.13.
- */
-public final class Build {
-
-    public static final boolean DEBUG = BuildConfig.MY_DEBUG;
-    public static final String TIME_STAMP = BuildConfig.MY_TIME_STAMP;
-    public static final String GOOGLE_PLAY_PUBLIC_KEY = BuildConfig.MY_GOOGLE_PLAY_PUBLIC_KEY;
-
-    public static final String SUPPORT_EMAIL = "support@artemchep.com";
-
-    /**
-     * It contains most of links of AcDisplay.
-     */
-    public static class Links {
-
-        public static final String DEVELOPER_PROFILE = "https://plus.google.com/+АртёмЧепурной";
-
-        public static final String TRANSLATE = "http://translate.acdisplay.org";
-        public static final String DONATE = "http://goo.gl/UrecGo";
-
-        public static final String LIST_OF_DONATORS = "https://plus.google.com/102696863054832206920/posts/7wi3WfWGSfH";
-
-    }
-
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/Config.java b/project/app/src/main/java/com/achep/acdisplay/Config.java
index e195cb51..df27dc91 100644
--- a/project/app/src/main/java/com/achep/acdisplay/Config.java
+++ b/project/app/src/main/java/com/achep/acdisplay/Config.java
@@ -21,29 +21,17 @@ package com.achep.acdisplay;
 import android.content.Context;
 import android.content.SharedPreferences;
 import android.content.res.Resources;
-import android.preference.CheckBoxPreference;
-import android.preference.Preference;
-import android.preference.PreferenceScreen;
 import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 import android.util.DisplayMetrics;
-import android.util.Log;
 import android.util.TypedValue;
 
-import com.achep.acdisplay.interfaces.IOnLowMemory;
-import com.achep.acdisplay.powertoggles.ToggleReceiver;
+import com.achep.acdisplay.plugins.powertoggles.ToggleReceiver;
 import com.achep.acdisplay.services.KeyguardService;
 import com.achep.acdisplay.services.SensorsDumpService;
 import com.achep.acdisplay.services.activemode.ActiveModeService;
 import com.achep.acdisplay.utils.AccessUtils;
+import com.achep.base.content.ConfigBase;
 
-import org.apache.commons.lang.builder.EqualsBuilder;
-import org.apache.commons.lang.builder.HashCodeBuilder;
-
-import java.lang.ref.SoftReference;
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
 import java.util.HashMap;
 
 /**
@@ -53,17 +41,16 @@ import java.util.HashMap;
  * @since 21.01.14
  */
 @SuppressWarnings("ConstantConditions")
-public class Config implements IOnLowMemory {
+public final class Config extends ConfigBase {
 
     private static final String TAG = "Config";
 
-    private static final String PREFERENCES_FILE_NAME = "config";
-
     public static final String KEY_ENABLED = "enabled";
     public static final String KEY_ONLY_WHILE_CHARGING = "only_while_charging";
 
     // notifications
-    public static final String KEY_NOTIFY_LOW_PRIORITY = "notify_low_priority";
+    public static final String KEY_NOTIFY_MIN_PRIORITY = "notify_min_priority";
+    public static final String KEY_NOTIFY_MAX_PRIORITY = "notify_max_priority";
     public static final String KEY_NOTIFY_WAKE_UP_ON = "notify_wake_up_on";
 
     // inactive time
@@ -77,6 +64,7 @@ public class Config implements IOnLowMemory {
 
     // keyguard
     public static final String KEY_KEYGUARD = "keyguard";
+    public static final String KEY_KEYGUARD_WITHOUT_NOTIFICATIONS = "keyguard_without_notifications";
 
     // active mode
     public static final String KEY_ACTIVE_MODE = "active_mode";
@@ -85,17 +73,16 @@ public class Config implements IOnLowMemory {
     // interface
     public static final String KEY_UI_FULLSCREEN = "ui_fullscreen";
     public static final String KEY_UI_WALLPAPER_SHOWN = "wallpaper_shown";
-    public static final String KEY_UI_SHADOW_TOGGLE = "shadow_toggle";
     public static final String KEY_UI_DYNAMIC_BACKGROUND_MODE = "dynamic_background_mode";
     public static final int DYNAMIC_BG_ARTWORK_MASK = 1;
     public static final int DYNAMIC_BG_NOTIFICATION_MASK = 2;
-    public static final String KEY_UI_MIRRORED_TIMEOUT_BAR = "mirrored_timeout_progress_bar";
-    public static final String KEY_UI_NOTIFY_CIRCLED_ICON = "notify_circled_icon";
     public static final String KEY_UI_STATUS_BATTERY_STICKY = "ui_status_battery_sticky";
     public static final String KEY_UI_ICON_SIZE = "ui_condensed_view_size";
     public static final String ICON_SIZE_PX = "px";
     public static final String ICON_SIZE_DP = "dp";
     public static final String KEY_UI_UNLOCK_ANIMATION = "unlock_animation";
+    public static final String KEY_UI_CIRCLE_COLOR_INNER = "ui_circle_color_inner";
+    public static final String KEY_UI_CIRCLE_COLOR_OUTER = "ui_circle_color_outer";
 
     // behavior
     public static final String KEY_FEEL_SCREEN_OFF_AFTER_LAST_NOTIFY = "feel_widget_screen_off_after_last_notify";
@@ -107,174 +94,47 @@ public class Config implements IOnLowMemory {
 
     // triggers
     public static final String KEY_TRIG_PREVIOUS_VERSION = "trigger_previous_version";
-    public static final String KEY_TRIG_HELP_READ = "trigger_help_read";
+    public static final String KEY_TRIG_HELP_READ = "trigger_dialog_help";
     public static final String KEY_TRIG_TRANSLATED = "trigger_translated";
+    public static final String KEY_TRIG_LAUNCH_COUNT = "trigger_launch_count";
+    public static final String KEY_TRIG_DONATION_ASKED = "trigger_donation_asked";
 
     private static Config sConfig;
 
     private boolean mAcDisplayEnabled;
     private boolean mKeyguardEnabled;
+    private boolean mKeyguardWithoutNotifies;
     private boolean mActiveMode;
     private boolean mActiveModeWithoutNotifies;
     private boolean mEnabledOnlyWhileCharging;
     private boolean mScreenOffAfterLastNotify;
     private boolean mFeelWidgetPinnable;
     private boolean mFeelWidgetReadable;
-    private boolean mNotifyLowPriority;
     private boolean mNotifyWakeUpOn;
+    private int mNotifyMinPriority;
+    private int mNotifyMaxPriority;
     private int mTimeoutNormal;
     private int mTimeoutShort;
     private int mInactiveTimeFrom;
     private int mInactiveTimeTo;
     private int mUiDynamicBackground;
     private int mUiIconSize; // dp.
+    private int mUiCircleColorInner;
+    private int mUiCircleColorOuter;
     private boolean mInactiveTimeEnabled;
     private boolean mUiFullScreen;
     private boolean mUiWallpaper;
-    private boolean mUiWallpaperShadow;
-    private boolean mUiMirroredTimeoutBar;
     private boolean mUiBatterySticky;
-    private boolean mUiNotifyCircledIcon;
     private boolean mUiUnlockAnimation;
 
     private boolean mDevSensorsDump;
 
     private final Triggers mTriggers;
     private int mTrigPreviousVersion;
+    private int mTrigLaunchCount;
     private boolean mTrigTranslated;
     private boolean mTrigHelpRead;
-
-    @NonNull
-    private SoftReference<HashMap<String, Option>> mHashMapRef = new SoftReference<>(null);
-
-    public static class Option {
-        private final String setterName;
-        private final String getterName;
-        private final Class clazz;
-        private final int minSdkVersion;
-
-        public Option(String setterName,
-                      String getterName,
-                      Class clazz) {
-            this(setterName, getterName, clazz, 0);
-        }
-
-        public Option(String setterName,
-                      String getterName,
-                      Class clazz, int minSdkVersion) {
-            this.setterName = setterName;
-            this.getterName = getterName;
-            this.clazz = clazz;
-            this.minSdkVersion = minSdkVersion;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public int hashCode() {
-            return new HashCodeBuilder(11, 31)
-                    .append(setterName)
-                    .append(getterName)
-                    .append(clazz)
-                    .toHashCode();
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public boolean equals(Object o) {
-            if (o == null)
-                return false;
-            if (o == this)
-                return true;
-            if (!(o instanceof Option))
-                return false;
-
-            Option option = (Option) o;
-            return new EqualsBuilder()
-                    .append(setterName, option.setterName)
-                    .append(getterName, option.getterName)
-                    .append(clazz, option.clazz)
-                    .isEquals();
-        }
-
-        /**
-         * Reads an option from given config instance.</br>
-         * Reading is done using reflections!
-         *
-         * @param config a config to read from.
-         * @throws java.lang.RuntimeException if failed to read given config.
-         */
-        @NonNull
-        public Object read(@NonNull Config config) {
-            Object configInstance = getConfigInstance(config);
-            Class configClass = configInstance.getClass();
-            try {
-                Method method = configClass.getDeclaredMethod(getterName);
-                method.setAccessible(true);
-                return method.invoke(configInstance);
-            } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
-                throw new RuntimeException("Failed to access " + clazz.getName() + "." + getterName + " method.");
-            }
-        }
-
-
-        /**
-         * Writes new value to the option to given config instance.</br>
-         * Writing is done using reflections!
-         *
-         * @param config a config to write to.
-         * @throws java.lang.RuntimeException if failed to read given config.
-         */
-        public void write(@NonNull Config config, @NonNull Context context,
-                          @NonNull Object newValue, @Nullable OnConfigChangedListener listener) {
-            Object configInstance = getConfigInstance(config);
-            Class configClass = configInstance.getClass();
-            try {
-                Method method = configClass.getDeclaredMethod(setterName,
-                        Context.class, clazz,
-                        Config.OnConfigChangedListener.class);
-                method.setAccessible(true);
-                method.invoke(configInstance, context, newValue, listener);
-            } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
-                throw new RuntimeException("Failed to access " + clazz.getName() + "." + setterName + " method.");
-            }
-        }
-
-        @NonNull
-        protected Object getConfigInstance(Config config) {
-            return config;
-        }
-
-    }
-
-    private ArrayList<OnConfigChangedListener> mListeners;
-    private Context mContext;
-
-    // //////////////////////////////////////////
-    // /////////// -- LISTENERS -- //////////////
-    // //////////////////////////////////////////
-
-    public interface OnConfigChangedListener {
-        public void onConfigChanged(
-                @NonNull Config config,
-                @NonNull String key,
-                @NonNull Object value);
-    }
-
-    public void registerListener(@NonNull OnConfigChangedListener listener) {
-        mListeners.add(listener);
-    }
-
-    public void unregisterListener(@NonNull OnConfigChangedListener listener) {
-        mListeners.remove(listener);
-    }
-
-    // //////////////////////////////////////////
-    // ///////////// -- INIT -- /////////////////
-    // //////////////////////////////////////////
+    private boolean mTrigDonationAsked;
 
     @NonNull
     public static synchronized Config getInstance() {
@@ -288,33 +148,29 @@ public class Config implements IOnLowMemory {
         mTriggers = new Triggers();
     }
 
-    @Override
-    public void onLowMemory() {
-        // Clear hash-map; it will be recreated on #getHashMap().
-        mHashMapRef.clear();
-    }
-
     /**
      * Loads saved values from shared preferences.
      * This is called on {@link App app's} create.
      */
     void init(@NonNull Context context) {
-        mListeners = new ArrayList<>(6);
-
         Resources res = context.getResources();
         SharedPreferences prefs = getSharedPreferences(context);
         mAcDisplayEnabled = prefs.getBoolean(KEY_ENABLED,
                 res.getBoolean(R.bool.config_default_enabled));
         mKeyguardEnabled = prefs.getBoolean(KEY_KEYGUARD,
                 res.getBoolean(R.bool.config_default_keyguard_enabled));
+        mKeyguardWithoutNotifies = prefs.getBoolean(KEY_KEYGUARD_WITHOUT_NOTIFICATIONS,
+                res.getBoolean(R.bool.config_default_keyguard_without_notifies_enabled));
         mActiveMode = prefs.getBoolean(KEY_ACTIVE_MODE,
                 res.getBoolean(R.bool.config_default_active_mode_enabled));
         mActiveModeWithoutNotifies = prefs.getBoolean(KEY_ACTIVE_MODE_WITHOUT_NOTIFICATIONS,
                 res.getBoolean(R.bool.config_default_active_mode_without_notifies_enabled));
 
         // notifications
-        mNotifyLowPriority = prefs.getBoolean(KEY_NOTIFY_LOW_PRIORITY,
-                res.getBoolean(R.bool.config_default_notify_low_priority));
+        mNotifyMinPriority = prefs.getInt(KEY_NOTIFY_MIN_PRIORITY,
+                res.getInteger(R.integer.config_default_notify_min_priority));
+        mNotifyMaxPriority = prefs.getInt(KEY_NOTIFY_MAX_PRIORITY,
+                res.getInteger(R.integer.config_default_notify_max_priority));
         mNotifyWakeUpOn = prefs.getBoolean(KEY_NOTIFY_WAKE_UP_ON,
                 res.getBoolean(R.bool.config_default_notify_wake_up_on));
 
@@ -335,14 +191,8 @@ public class Config implements IOnLowMemory {
         // interface
         mUiWallpaper = prefs.getBoolean(KEY_UI_WALLPAPER_SHOWN,
                 res.getBoolean(R.bool.config_default_ui_show_wallpaper));
-        mUiWallpaperShadow = prefs.getBoolean(KEY_UI_SHADOW_TOGGLE,
-                res.getBoolean(R.bool.config_default_ui_show_shadow));
         mUiDynamicBackground = prefs.getInt(KEY_UI_DYNAMIC_BACKGROUND_MODE,
                 res.getInteger(R.integer.config_default_ui_show_shadow_dynamic_bg));
-        mUiMirroredTimeoutBar = prefs.getBoolean(KEY_UI_MIRRORED_TIMEOUT_BAR,
-                res.getBoolean(R.bool.config_default_ui_mirrored_timeout_bar));
-        mUiNotifyCircledIcon = prefs.getBoolean(KEY_UI_NOTIFY_CIRCLED_ICON,
-                res.getBoolean(R.bool.config_default_ui_notify_circled_icon));
         mUiBatterySticky = prefs.getBoolean(KEY_UI_STATUS_BATTERY_STICKY,
                 res.getBoolean(R.bool.config_default_ui_status_battery_sticky));
         mUiFullScreen = prefs.getBoolean(KEY_UI_FULLSCREEN,
@@ -351,6 +201,8 @@ public class Config implements IOnLowMemory {
                 res.getBoolean(R.bool.config_default_ui_unlock_animation));
         mUiIconSize = prefs.getInt(KEY_UI_ICON_SIZE,
                 res.getInteger(R.integer.config_default_ui_icon_size_dp));
+        mUiCircleColorInner = prefs.getInt(KEY_UI_CIRCLE_COLOR_INNER, 0xFFF0F0F0);
+        mUiCircleColorOuter = prefs.getInt(KEY_UI_CIRCLE_COLOR_OUTER, 0xFF303030);
 
         // development
         mDevSensorsDump = prefs.getBoolean(KEY_DEV_SENSORS_DUMP,
@@ -370,77 +222,67 @@ public class Config implements IOnLowMemory {
         mTrigHelpRead = prefs.getBoolean(KEY_TRIG_HELP_READ, false);
         mTrigTranslated = prefs.getBoolean(KEY_TRIG_TRANSLATED, false);
         mTrigPreviousVersion = prefs.getInt(KEY_TRIG_PREVIOUS_VERSION, 0);
+        mTrigLaunchCount = prefs.getInt(KEY_TRIG_LAUNCH_COUNT, 0);
+        mTrigDonationAsked = prefs.getBoolean(KEY_TRIG_TRANSLATED, false);
     }
 
-    static SharedPreferences getSharedPreferences(Context context) {
-        return context.getSharedPreferences(PREFERENCES_FILE_NAME, Context.MODE_PRIVATE);
-    }
-
-    /**
-     * You may get a context from here only on
-     * {@link Config.OnConfigChangedListener#onConfigChanged(Config, String, Object) config change}.
-     */
-    public Context getContext() {
-        return mContext;
-    }
-
-    @NonNull
-    public HashMap<String, Option> getHashMap() {
-        HashMap<String, Option> hashMap = mHashMapRef.get();
-        if (hashMap == null) {
-            hashMap = new HashMap<>();
-            hashMap.put(KEY_ENABLED, new Option(
-                    "setEnabled", "isEnabled", boolean.class));
-            hashMap.put(KEY_KEYGUARD, new Option(
-                    "setKeyguardEnabled", "isKeyguardEnabled", boolean.class));
-            hashMap.put(KEY_ACTIVE_MODE, new Option(
-                    "setActiveModeEnabled", "isActiveModeEnabled", boolean.class));
-            hashMap.put(KEY_ACTIVE_MODE_WITHOUT_NOTIFICATIONS, new Option(
-                    "setActiveModeWithoutNotificationsEnabled",
-                    "isActiveModeWithoutNotifiesEnabled", boolean.class));
-            hashMap.put(KEY_NOTIFY_LOW_PRIORITY, new Option(
-                    "setLowPriorityNotificationsAllowed",
-                    "isLowPriorityNotificationsAllowed", boolean.class));
-            hashMap.put(KEY_NOTIFY_WAKE_UP_ON, new Option(
-                    "setWakeUpOnNotifyEnabled",
-                    "isNotifyWakingUp", boolean.class));
-            hashMap.put(KEY_ONLY_WHILE_CHARGING, new Option(
-                    "setEnabledOnlyWhileCharging",
-                    "isEnabledOnlyWhileCharging", boolean.class));
-            hashMap.put(KEY_UI_FULLSCREEN, new Option(
-                    "setFullScreen", "isFullScreen", boolean.class));
-            hashMap.put(KEY_UI_WALLPAPER_SHOWN, new Option(
-                    "setWallpaperShown", "isWallpaperShown", boolean.class));
-            hashMap.put(KEY_UI_SHADOW_TOGGLE, new Option(
-                    "setShadowEnabled", "isShadowEnabled", boolean.class));
-            hashMap.put(KEY_UI_MIRRORED_TIMEOUT_BAR, new Option(
-                    "setMirroredTimeoutProgressBarEnabled",
-                    "isMirroredTimeoutProgressBarEnabled", boolean.class));
-            hashMap.put(KEY_UI_NOTIFY_CIRCLED_ICON, new Option(
-                    "setCircledLargeIconEnabled",
-                    "isCircledLargeIconEnabled", boolean.class));
-            hashMap.put(KEY_UI_STATUS_BATTERY_STICKY, new Option(
-                    "setStatusBatterySticky",
-                    "isStatusBatterySticky", boolean.class));
-            hashMap.put(KEY_UI_UNLOCK_ANIMATION, new Option(
-                    "setUnlockAnimationEnabled",
-                    "isUnlockAnimationEnabled", boolean.class));
-            hashMap.put(KEY_FEEL_SCREEN_OFF_AFTER_LAST_NOTIFY, new Option(
-                    "setScreenOffAfterLastNotify",
-                    "isScreenOffAfterLastNotify", boolean.class));
-            hashMap.put(KEY_FEEL_WIDGET_PINNABLE, new Option(
-                    "setWidgetPinnable",
-                    "isWidgetPinnable", boolean.class));
-            hashMap.put(KEY_FEEL_WIDGET_READABLE, new Option(
-                    "setWidgetReadable",
-                    "isWidgetReadable", boolean.class));
-            hashMap.put(KEY_DEV_SENSORS_DUMP, new Option(
-                    "setDevSensorsDumpEnabled",
-                    "isDevSensorsDumpEnabled", boolean.class));
-
-            mHashMapRef = new SoftReference<>(hashMap);
-        }
-        return hashMap;
+    @Override
+    protected void onCreateHashMap(@NonNull HashMap<String, ConfigBase.Option> hashMap) {
+        hashMap.put(KEY_ENABLED, new ConfigBase.Option(
+                "setEnabled", "isEnabled", boolean.class));
+        hashMap.put(KEY_KEYGUARD, new ConfigBase.Option(
+                "setKeyguardEnabled", "isKeyguardEnabled", boolean.class));
+        hashMap.put(KEY_KEYGUARD_WITHOUT_NOTIFICATIONS, new ConfigBase.Option(
+                "setKeyguardWithoutNotificationsEnabled",
+                "isKeyguardWithoutNotifiesEnabled", boolean.class));
+        hashMap.put(KEY_ACTIVE_MODE, new ConfigBase.Option(
+                "setActiveModeEnabled", "isActiveModeEnabled", boolean.class));
+        hashMap.put(KEY_ACTIVE_MODE_WITHOUT_NOTIFICATIONS, new ConfigBase.Option(
+                "setActiveModeWithoutNotificationsEnabled",
+                "isActiveModeWithoutNotifiesEnabled", boolean.class));
+        hashMap.put(KEY_NOTIFY_WAKE_UP_ON, new ConfigBase.Option(
+                "setWakeUpOnNotifyEnabled",
+                "isNotifyWakingUp", boolean.class));
+        hashMap.put(KEY_NOTIFY_MIN_PRIORITY, new ConfigBase.Option(
+                "setNotifyMinPriority",
+                "getNotifyMinPriority", int.class));
+        hashMap.put(KEY_NOTIFY_MAX_PRIORITY, new ConfigBase.Option(
+                "setNotifyMaxPriority",
+                "getNotifyMaxPriority", int.class));
+        hashMap.put(KEY_ONLY_WHILE_CHARGING, new ConfigBase.Option(
+                "setEnabledOnlyWhileCharging",
+                "isEnabledOnlyWhileCharging", boolean.class));
+        hashMap.put(KEY_UI_FULLSCREEN, new ConfigBase.Option(
+                "setFullScreen", "isFullScreen", boolean.class));
+        hashMap.put(KEY_UI_WALLPAPER_SHOWN, new ConfigBase.Option(
+                "setWallpaperShown", "isWallpaperShown", boolean.class));
+        hashMap.put(KEY_UI_STATUS_BATTERY_STICKY, new ConfigBase.Option(
+                "setStatusBatterySticky",
+                "isStatusBatterySticky", boolean.class));
+        hashMap.put(KEY_UI_DYNAMIC_BACKGROUND_MODE, new ConfigBase.Option(
+                "setDynamicBackgroundMode",
+                "getDynamicBackgroundMode", int.class));
+        hashMap.put(KEY_UI_CIRCLE_COLOR_INNER, new ConfigBase.Option(
+                "setCircleInnerColor",
+                "getCircleInnerColor", int.class));
+        hashMap.put(KEY_UI_CIRCLE_COLOR_OUTER, new ConfigBase.Option(
+                "setCircleOuterColor",
+                "getCircleOuterColor", int.class));
+        hashMap.put(KEY_UI_UNLOCK_ANIMATION, new ConfigBase.Option(
+                "setUnlockAnimationEnabled",
+                "isUnlockAnimationEnabled", boolean.class));
+        hashMap.put(KEY_FEEL_SCREEN_OFF_AFTER_LAST_NOTIFY, new ConfigBase.Option(
+                "setScreenOffAfterLastNotify",
+                "isScreenOffAfterLastNotify", boolean.class));
+        hashMap.put(KEY_FEEL_WIDGET_PINNABLE, new ConfigBase.Option(
+                "setWidgetPinnable",
+                "isWidgetPinnable", boolean.class));
+        hashMap.put(KEY_FEEL_WIDGET_READABLE, new ConfigBase.Option(
+                "setWidgetReadable",
+                "isWidgetReadable", boolean.class));
+        hashMap.put(KEY_DEV_SENSORS_DUMP, new ConfigBase.Option(
+                "setDevSensorsDumpEnabled",
+                "isDevSensorsDumpEnabled", boolean.class));
     }
 
     /**
@@ -451,39 +293,6 @@ public class Config implements IOnLowMemory {
         return mTriggers;
     }
 
-    private void notifyConfigChanged(String key, Object value, OnConfigChangedListener listener) {
-        for (OnConfigChangedListener l : mListeners) {
-            if (l == listener) continue;
-            l.onConfigChanged(this, key, value);
-        }
-    }
-
-    private void saveOption(Context context, String key, Object value,
-                            OnConfigChangedListener listener, boolean changed) {
-        if (!changed) {
-            // Don't update preferences if this change is a lie.
-            return;
-        }
-
-        if (Build.DEBUG) Log.d(TAG, "Writing \"" + key + "=" + value + "\" to config.");
-
-        SharedPreferences.Editor editor = getSharedPreferences(context).edit();
-        if (value instanceof Boolean) {
-            editor.putBoolean(key, (Boolean) value);
-        } else if (value instanceof Integer) {
-            editor.putInt(key, (Integer) value);
-        } else if (value instanceof Float) {
-            editor.putFloat(key, (Float) value);
-        } else if (value instanceof String) {
-            editor.putString(key, (String) value);
-        } else throw new IllegalArgumentException("Unknown option type.");
-        editor.apply();
-
-        mContext = context;
-        notifyConfigChanged(key, value, listener);
-        mContext = null;
-    }
-
     // //////////////////////////////////////////
     // ///////////// -- OPTIONS -- //////////////
     // //////////////////////////////////////////
@@ -527,6 +336,11 @@ public class Config implements IOnLowMemory {
         }
     }
 
+    public void setKeyguardWithoutNotificationsEnabled(Context context, boolean enabled, OnConfigChangedListener listener) {
+        boolean changed = mKeyguardWithoutNotifies != (mKeyguardWithoutNotifies = enabled);
+        saveOption(context, KEY_KEYGUARD_WITHOUT_NOTIFICATIONS, enabled, listener, changed);
+    }
+
     /**
      * Setter to enable the active mode.
      */
@@ -558,15 +372,6 @@ public class Config implements IOnLowMemory {
         }
     }
 
-    /**
-     * Setter to allow notifications with a lower priority like Google Now.
-     */
-    public void setLowPriorityNotificationsAllowed(Context context, boolean enabled,
-                                                   OnConfigChangedListener listener) {
-        boolean changed = mNotifyLowPriority != (mNotifyLowPriority = enabled);
-        saveOption(context, KEY_NOTIFY_LOW_PRIORITY, enabled, listener, changed);
-    }
-
     public void setWakeUpOnNotifyEnabled(Context context, boolean enabled,
                                          OnConfigChangedListener listener) {
         boolean changed = mNotifyWakeUpOn != (mNotifyWakeUpOn = enabled);
@@ -623,11 +428,6 @@ public class Config implements IOnLowMemory {
         saveOption(context, KEY_UI_WALLPAPER_SHOWN, shown, listener, changed);
     }
 
-    public void setShadowEnabled(Context context, boolean shown, OnConfigChangedListener listener) {
-        boolean changed = mUiWallpaperShadow != (mUiWallpaperShadow = shown);
-        saveOption(context, KEY_UI_SHADOW_TOGGLE, shown, listener, changed);
-    }
-
     /**
      * Allow the background to change based on the notification.
      */
@@ -636,19 +436,6 @@ public class Config implements IOnLowMemory {
         saveOption(context, KEY_UI_DYNAMIC_BACKGROUND_MODE, mode, listener, changed);
     }
 
-    /**
-     * Allow the timeout bar to move in from both sides.
-     */
-    public void setMirroredTimeoutProgressBarEnabled(Context context, boolean enabled, OnConfigChangedListener listener) {
-        boolean changed = mUiMirroredTimeoutBar != (mUiMirroredTimeoutBar = enabled);
-        saveOption(context, KEY_UI_MIRRORED_TIMEOUT_BAR, enabled, listener, changed);
-    }
-
-    public void setCircledLargeIconEnabled(Context context, boolean enabled, OnConfigChangedListener listener) {
-        boolean changed = mUiNotifyCircledIcon != (mUiNotifyCircledIcon = enabled);
-        saveOption(context, KEY_UI_NOTIFY_CIRCLED_ICON, enabled, listener, changed);
-    }
-
     public void setStatusBatterySticky(Context context, boolean visible, OnConfigChangedListener listener) {
         boolean changed = mUiBatterySticky != (mUiBatterySticky = visible);
         saveOption(context, KEY_UI_STATUS_BATTERY_STICKY, visible, listener, changed);
@@ -709,6 +496,70 @@ public class Config implements IOnLowMemory {
         }
     }
 
+    public void setCircleInnerColor(Context context, int color, OnConfigChangedListener listener) {
+        boolean changed = mUiCircleColorInner != (mUiCircleColorInner = color);
+        saveOption(context, KEY_UI_CIRCLE_COLOR_INNER, color, listener, changed);
+    }
+
+    public void setCircleOuterColor(Context context, int color, OnConfigChangedListener listener) {
+        boolean changed = mUiCircleColorOuter != (mUiCircleColorOuter = color);
+        saveOption(context, KEY_UI_CIRCLE_COLOR_OUTER, color, listener, changed);
+    }
+
+    /**
+     * Sets the minimum notification's priority to be shown.
+     *
+     * @param priority minimum notification's priority to be shown.
+     * @see #getNotifyMinPriority()
+     * @see #setNotifyMaxPriority(Context, int, OnConfigChangedListener)
+     * @see android.app.Notification#priority
+     */
+    public void setNotifyMinPriority(Context context, int priority, OnConfigChangedListener listener) {
+        boolean changed = mNotifyMinPriority != (mNotifyMinPriority = priority);
+        saveOption(context, KEY_NOTIFY_MIN_PRIORITY, priority, listener, changed);
+    }
+
+    /**
+     * Sets the maximum notification's priority to be shown.
+     *
+     * @param priority maximum notification's priority to be shown.
+     * @see #getNotifyMaxPriority()
+     * @see #setNotifyMinPriority(Context, int, OnConfigChangedListener)
+     * @see android.app.Notification#priority
+     */
+    public void setNotifyMaxPriority(Context context, int priority, OnConfigChangedListener listener) {
+        boolean changed = mNotifyMaxPriority != (mNotifyMaxPriority = priority);
+        saveOption(context, KEY_NOTIFY_MAX_PRIORITY, priority, listener, changed);
+    }
+
+    /**
+     * @return minimal {@link android.app.Notification#priority} of notification to be shown.
+     * @see #setNotifyMinPriority(Context, int, OnConfigChangedListener)
+     * @see #getNotifyMaxPriority()
+     * @see android.app.Notification#priority
+     */
+    public int getNotifyMinPriority() {
+        return mNotifyMinPriority;
+    }
+
+    /**
+     * @return maximum {@link android.app.Notification#priority} of notification to be shown.
+     * @see #setNotifyMaxPriority(Context, int, OnConfigChangedListener)
+     * @see #getNotifyMinPriority()
+     * @see android.app.Notification#priority
+     */
+    public int getNotifyMaxPriority() {
+        return mNotifyMaxPriority;
+    }
+
+    public int getCircleInnerColor() {
+        return mUiCircleColorInner;
+    }
+
+    public int getCircleOuterColor() {
+        return mUiCircleColorOuter;
+    }
+
     public int getTimeoutNormal() {
         return mTimeoutNormal;
     }
@@ -763,6 +614,10 @@ public class Config implements IOnLowMemory {
         return mKeyguardEnabled;
     }
 
+    public boolean isKeyguardWithoutNotifiesEnabled() {
+        return mKeyguardWithoutNotifies;
+    }
+
     public boolean isActiveModeEnabled() {
         return mActiveMode;
     }
@@ -779,22 +634,10 @@ public class Config implements IOnLowMemory {
         return mNotifyWakeUpOn;
     }
 
-    public boolean isLowPriorityNotificationsAllowed() {
-        return mNotifyLowPriority;
-    }
-
     public boolean isWallpaperShown() {
         return mUiWallpaper;
     }
 
-    public boolean isShadowEnabled() {
-        return mUiWallpaperShadow;
-    }
-
-    public boolean isCircledLargeIconEnabled() {
-        return mUiNotifyCircledIcon;
-    }
-
     public boolean isStatusBatterySticky() {
         return mUiBatterySticky;
     }
@@ -807,10 +650,6 @@ public class Config implements IOnLowMemory {
         return mFeelWidgetReadable;
     }
 
-    public boolean isMirroredTimeoutProgressBarEnabled() {
-        return mUiMirroredTimeoutBar;
-    }
-
     public boolean isInactiveTimeEnabled() {
         return mInactiveTimeEnabled;
     }
@@ -831,155 +670,6 @@ public class Config implements IOnLowMemory {
         return mDevSensorsDump;
     }
 
-    /**
-     * A class that syncs {@link android.preference.Preference} with its
-     * value in config.
-     *
-     * @author Artem Chepurnoy
-     */
-    public static class Syncer {
-
-        private final ArrayList<Group> mGroups;
-        private final Context mContext;
-        private final Config mConfig;
-
-        private boolean mBroadcasting;
-        private boolean mStarted;
-
-        private final Preference.OnPreferenceChangeListener mPreferenceListener = new Preference.OnPreferenceChangeListener() {
-            @Override
-            public boolean onPreferenceChange(Preference preference, Object newValue) {
-                if (mBroadcasting) {
-                    return true;
-                }
-
-                Group group = null;
-                for (Group c : mGroups) {
-                    if (preference == c.preference) {
-                        group = c;
-                        break;
-                    }
-                }
-
-                assert group != null;
-
-                group.option.write(mConfig, mContext, newValue, mConfigListener);
-                return true;
-            }
-        };
-
-        private final OnConfigChangedListener mConfigListener = new OnConfigChangedListener() {
-
-            @Override
-            public void onConfigChanged(@NonNull Config config, @NonNull String key,
-                                        @NonNull Object value) {
-                Group group = null;
-                for (Group c : mGroups) {
-                    if (key.equals(c.preference.getKey())) {
-                        group = c;
-                        break;
-                    }
-                }
-
-                if (group == null) {
-                    return;
-                }
-
-                setPreferenceValue(group, value);
-            }
-
-        };
-
-        private void setPreferenceValue(@NonNull Group group, @NonNull Object value) {
-            mBroadcasting = true;
-
-            Option option = group.option;
-            if (option.clazz.equals(boolean.class)) {
-                CheckBoxPreference preference = (CheckBoxPreference) group.preference;
-                preference.setChecked((boolean) value);
-            }
-
-            mBroadcasting = false;
-        }
-
-        /**
-         * A class-merge of {@link android.preference.Preference}
-         * and its {@link com.achep.acdisplay.Config.Option}.
-         *
-         * @author Artem Chepurnoy
-         */
-        private static class Group {
-            final Preference preference;
-            final Option option;
-
-            public Group(@NonNull Config config, @NonNull Preference preference) {
-                this.preference = preference;
-                this.option = config.getHashMap().get(preference.getKey());
-            }
-        }
-
-        public Syncer(@NonNull Context context, @NonNull Config config) {
-            mGroups = new ArrayList<>(10);
-            mContext = context;
-            mConfig = config;
-        }
-
-        @NonNull
-        public Syncer addPreference(@Nullable PreferenceScreen preferenceScreen,
-                                    @NonNull Preference preference) {
-            Group group;
-            if (preference instanceof CheckBoxPreference) {
-                group = new Group(mConfig, preference);
-            } else {
-                throw new IllegalArgumentException("Syncer only supports some kinds of Preferences");
-            }
-
-            // Remove preference from preference screen
-            // if needed.
-            if (preferenceScreen != null) {
-                if (!Device.hasTargetApi(group.option.minSdkVersion)) {
-                    preferenceScreen.removePreference(preference);
-                    return this;
-                }
-            }
-
-            mGroups.add(group);
-
-            if (mStarted) {
-                startListeningGroup(group);
-            }
-
-            return this;
-        }
-
-        /**
-         * Updates all preferences and starts to listen to the changes.
-         */
-        public void start() {
-            mStarted = true;
-            mConfig.registerListener(mConfigListener);
-            for (Group group : mGroups) {
-                startListeningGroup(group);
-            }
-        }
-
-        private void startListeningGroup(@NonNull Group group) {
-            group.preference.setOnPreferenceChangeListener(mPreferenceListener);
-            setPreferenceValue(group, group.option.read(mConfig));
-        }
-
-        /**
-         * Stops to listen to the changes.
-         */
-        public void stop() {
-            mStarted = false;
-            mConfig.unregisterListener(mConfigListener);
-            for (Group group : mGroups) {
-                group.preference.setOnPreferenceChangeListener(null);
-            }
-        }
-    }
-
     // //////////////////////////////////////////
     // //////////// -- TRIGGERS -- //////////////
     // //////////////////////////////////////////
@@ -1001,16 +691,43 @@ public class Config implements IOnLowMemory {
             saveOption(context, KEY_TRIG_HELP_READ, isRead, listener, changed);
         }
 
+        public void setDonationAsked(Context context, boolean isAsked, OnConfigChangedListener listener) {
+            boolean changed = mTrigDonationAsked != (mTrigDonationAsked = isAsked);
+            saveOption(context, KEY_TRIG_DONATION_ASKED, isAsked, listener, changed);
+        }
+
         public void setTranslated(Context context, boolean translated, OnConfigChangedListener listener) {
             boolean changed = mTrigTranslated != (mTrigTranslated = translated);
             saveOption(context, KEY_TRIG_TRANSLATED, translated, listener, changed);
         }
 
         /**
-         * As set by {@link com.achep.acdisplay.activities.MainActivity}, it returns version
+         * @param context
+         * @param listener
+         * @see #setLaunchCount(android.content.Context, int, com.achep.base.content.ConfigBase.OnConfigChangedListener)
+         * @see #getLaunchCount()
+         */
+        public void incrementLaunchCount(Context context, OnConfigChangedListener listener) {
+            setLaunchCount(context, getLaunchCount() + 1, listener);
+        }
+
+        /**
+         * @param context
+         * @param launchCount
+         * @param listener
+         * @see #incrementLaunchCount(android.content.Context, com.achep.base.content.ConfigBase.OnConfigChangedListener)
+         * @see #getLaunchCount()
+         */
+        public void setLaunchCount(Context context, int launchCount, OnConfigChangedListener listener) {
+            boolean changed = mTrigLaunchCount != (mTrigLaunchCount = launchCount);
+            saveOption(context, KEY_TRIG_LAUNCH_COUNT, launchCount, listener, changed);
+        }
+
+        /**
+         * As set by {@link com.achep.acdisplay.ui.activities.MainActivity}, it returns version
          * code of previously installed AcDisplay, {@code 0} if first install.
          *
-         * @return version code of previously installed AcDisplay, {@code 0} if first install.
+         * @return version code of previously installed AcDisplay, {@code 0} on first installation.
          * @see #setPreviousVersion(android.content.Context, int, Config.OnConfigChangedListener)
          */
         public int getPreviousVersion() {
@@ -1018,7 +735,17 @@ public class Config implements IOnLowMemory {
         }
 
         /**
-         * @return {@code true} if {@link com.achep.acdisplay.fragments.HelpDialog} been read, {@code false} otherwise
+         * @return the number of {@link com.achep.acdisplay.ui.activities.AcDisplayActivity}'s creations.
+         * @see #incrementLaunchCount(android.content.Context, com.achep.base.content.ConfigBase.OnConfigChangedListener)
+         * @see #setLaunchCount(android.content.Context, int, com.achep.base.content.ConfigBase.OnConfigChangedListener)
+         */
+        public int getLaunchCount() {
+            return mTrigLaunchCount;
+        }
+
+        /**
+         * @return {@code true} if {@link com.achep.base.ui.fragments.dialogs.HelpDialog} been read,
+         * {@code false} otherwise
          * @see #setHelpRead(android.content.Context, boolean, Config.OnConfigChangedListener)
          */
         public boolean isHelpRead() {
@@ -1028,11 +755,16 @@ public class Config implements IOnLowMemory {
         /**
          * @return {@code true} if the app is fully translated to currently used locale,
          * {@code false} otherwise.
+         * @see #setDonationAsked(android.content.Context, boolean, com.achep.base.content.ConfigBase.OnConfigChangedListener)
          */
         public boolean isTranslated() {
             return mTrigTranslated;
         }
 
+        public boolean isDonationAsked() {
+            return mTrigDonationAsked;
+        }
+
     }
 
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/DialogHelper.java b/project/app/src/main/java/com/achep/acdisplay/DialogHelper.java
index ef1d9f13..c84d2dcd 100644
--- a/project/app/src/main/java/com/achep/acdisplay/DialogHelper.java
+++ b/project/app/src/main/java/com/achep/acdisplay/DialogHelper.java
@@ -18,33 +18,22 @@
  */
 package com.achep.acdisplay;
 
-/**
- * Created by Artem on 28.01.14.
- */
-
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.app.DialogFragment;
-import android.app.Fragment;
-import android.app.FragmentManager;
-import android.app.FragmentTransaction;
-import android.content.Context;
-import android.graphics.drawable.Drawable;
-import android.text.TextUtils;
-import android.text.method.LinkMovementMethod;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.TextView;
-
-import com.achep.acdisplay.fragments.AboutDialog;
-import com.achep.acdisplay.fragments.SetupPermissionsDialog;
-import com.achep.acdisplay.fragments.FeedbackDialog;
-import com.achep.acdisplay.fragments.HelpDialog;
-import com.achep.acdisplay.iab.DonationFragment;
-
-import org.apache.commons.lang.builder.EqualsBuilder;
-import org.apache.commons.lang.builder.HashCodeBuilder;
+import android.content.res.Resources;
+import android.support.annotation.NonNull;
+import android.support.v4.app.DialogFragment;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentManager;
+import android.support.v4.app.FragmentTransaction;
+import android.support.v7.app.ActionBarActivity;
+import android.text.Html;
+
+import com.achep.acdisplay.ui.fragments.dialogs.SetupPermissionsDialog;
+import com.achep.acdisplay.ui.fragments.dialogs.WelcomeDialog;
+import com.achep.base.ui.DialogBuilder;
+import com.achep.base.ui.fragments.dialogs.AboutDialog;
+import com.achep.base.ui.fragments.dialogs.DonateDialog;
+import com.achep.base.ui.fragments.dialogs.FeedbackDialog;
+import com.achep.base.ui.fragments.dialogs.HelpDialog;
 
 /**
  * Helper class for showing fragment dialogs.
@@ -56,29 +45,50 @@ public class DialogHelper {
     public static final String TAG_FRAGMENT_HELP = "dialog_help";
     public static final String TAG_FRAGMENT_DONATION = "dialog_donate";
     public static final String TAG_FRAGMENT_FEEDBACK = "dialog_feedback";
+    public static final String TAG_FRAGMENT_WELCOME = "dialog_welcome";
 
-    public static void showAboutDialog(Activity activity) {
+    public static void showAboutDialog(@NonNull ActionBarActivity activity) {
         showDialog(activity, AboutDialog.class, TAG_FRAGMENT_ABOUT);
     }
 
-    public static void showSetupPermissionsDialog(Activity activity) {
-        showDialog(activity, SetupPermissionsDialog.class, TAG_FRAGMENT_SETUP_PERMISSIONS);
+    public static void showHelpDialog(@NonNull ActionBarActivity activity) {
+        showDialog(activity, HelpDialog.class, TAG_FRAGMENT_HELP);
     }
 
-    public static void showHelpDialog(Activity activity) {
-        showDialog(activity, HelpDialog.class, TAG_FRAGMENT_HELP);
+    public static void showDonateDialog(@NonNull ActionBarActivity activity) {
+        showDialog(activity, DonateDialog.class, TAG_FRAGMENT_DONATION);
     }
 
-    public static void showDonateDialog(Activity activity) {
-        showDialog(activity, DonationFragment.class, TAG_FRAGMENT_DONATION);
+    public static void showCryDialog(@NonNull ActionBarActivity activity) {
+        Resources res = activity.getResources();
+        CharSequence message = Html.fromHtml(res.getString(R.string.cry_dialog_message));
+
+        new DialogBuilder(activity)
+                .setIcon(R.drawable.ic_action_about_white)
+                .setTitle(R.string.cry_dialog_title)
+                .setMessage(message)
+                .createAlertDialogBuilder()
+                .setNegativeButton(R.string.close, null)
+                .create()
+                .show();
     }
 
-    public static void showFeedbackDialog(Activity activity) {
+    public static void showFeedbackDialog(@NonNull ActionBarActivity activity) {
         showDialog(activity, FeedbackDialog.class, TAG_FRAGMENT_FEEDBACK);
     }
 
-    private static void showDialog(Activity activity, Class clazz, String tag) {
-        FragmentManager fm = activity.getFragmentManager();
+    public static void showWelcomeDialog(@NonNull ActionBarActivity activity) {
+        showDialog(activity, WelcomeDialog.class, TAG_FRAGMENT_WELCOME);
+    }
+
+    public static void showSetupPermissionsDialog(@NonNull ActionBarActivity activity) {
+        showDialog(activity, SetupPermissionsDialog.class, TAG_FRAGMENT_SETUP_PERMISSIONS);
+    }
+
+    private static void showDialog(@NonNull ActionBarActivity activity,
+                                   @NonNull Class clazz,
+                                   @NonNull String tag) {
+        FragmentManager fm = activity.getSupportFragmentManager();
         FragmentTransaction ft = fm.beginTransaction();
         Fragment prev = fm.findFragmentByTag(tag);
         if (prev != null) {
@@ -93,231 +103,4 @@ public class DialogHelper {
         }
     }
 
-    /**
-     * Helper class to implement custom dialog's design.
-     */
-    public static class Builder {
-
-        /**
-         * Layout where content's layout exists in a {@link android.widget.ScrollView}.
-         * This is nice to display simple layout without scrollable elements such as
-         * {@link android.widget.ListView} or any similar. Use {@link #LAYOUT_SKELETON}
-         * for them.
-         *
-         * @see #LAYOUT_SKELETON
-         * @see #createCommonView()
-         * @see #wrap(int)
-         */
-        public static final int LAYOUT_COMMON = 0;
-
-        /**
-         * The skeleton of dialog's layout. The only thing that is here is the custom
-         * view you set and the title / icon. Use it to display scrollable elements such as
-         * {@link android.widget.ListView}.
-         *
-         * @see #LAYOUT_COMMON
-         * @see #createSkeletonView()
-         * @see #wrap(int)
-         */
-        public static final int LAYOUT_SKELETON = 1;
-
-        protected final Context mContext;
-
-        private Drawable mIcon;
-        private CharSequence mTitleText;
-        private CharSequence mMessageText;
-        private View mView;
-        private int mViewRes;
-
-        public Builder(Context context) {
-            mContext = context;
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public int hashCode() {
-            return new HashCodeBuilder(201, 17)
-                    .append(mContext)
-                    .append(mIcon)
-                    .append(mTitleText)
-                    .append(mMessageText)
-                    .append(mViewRes)
-                    .append(mView)
-                    .toHashCode();
-        }
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public boolean equals(Object o) {
-            if (o == null)
-                return false;
-            if (o == this)
-                return true;
-            if (!(o instanceof Builder))
-                return false;
-
-            Builder builder = (Builder) o;
-            return new EqualsBuilder()
-                    .append(mContext, builder.mContext)
-                    .append(mIcon, builder.mIcon)
-                    .append(mTitleText, builder.mTitleText)
-                    .append(mMessageText, builder.mMessageText)
-                    .append(mViewRes, builder.mViewRes)
-                    .append(mView, builder.mView)
-                    .isEquals();
-        }
-
-        public Builder setIcon(Drawable icon) {
-            mIcon = icon;
-            return this;
-        }
-
-        public Builder setTitle(CharSequence title) {
-            mTitleText = title;
-            return this;
-        }
-
-        public Builder setMessage(CharSequence message) {
-            mMessageText = message;
-            return this;
-        }
-
-        public Builder setIcon(int iconRes) {
-            return setIcon(iconRes == 0 ? null : mContext.getResources().getDrawable(iconRes));
-        }
-
-        public Builder setTitle(int titleRes) {
-            return setTitle(titleRes == 0 ? null : getString(titleRes));
-        }
-
-        public Builder setMessage(int messageRes) {
-            return setMessage(messageRes == 0 ? null : getString(messageRes));
-        }
-
-        private String getString(int stringRes) {
-            return mContext.getResources().getString(stringRes);
-        }
-
-        public Builder setView(View view) {
-            mView = view;
-            mViewRes = 0;
-            return this;
-        }
-
-        public Builder setView(int layoutRes) {
-            mView = null;
-            mViewRes = layoutRes;
-            return this;
-        }
-
-        /**
-         * Builds dialog's view
-         *
-         * @throws IllegalArgumentException when type is not one of defined.
-         * @see #LAYOUT_COMMON
-         * @see #LAYOUT_SKELETON
-         */
-        public View createView(int type) {
-            switch (type) {
-                case LAYOUT_COMMON:
-                    return createCommonView();
-                case LAYOUT_SKELETON:
-                    return createSkeletonView();
-                default:
-                    throw new IllegalArgumentException();
-            }
-        }
-
-        /**
-         * Builds view that based on simple {@link android.widget.ScrollView} container.
-         * This is nice to display simple layout without scrollable elements such as
-         * {@link android.widget.ListView} or any similar. Use {@link #createSkeletonView()}
-         * for them.
-         *
-         * @see #LAYOUT_COMMON
-         * @see #createView(int)
-         */
-        public View createCommonView() {
-
-            // Creating skeleton layout will also try
-            // to add custom view. Avoid of doing it.
-            int customViewRes = mViewRes;
-            View customView = mView;
-            mViewRes = 0;
-            mView = null;
-
-            LayoutInflater inflater = (LayoutInflater) mContext
-                    .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-
-            ViewGroup rootLayout = (ViewGroup) createSkeletonView();
-            View bodyRootView = inflater.inflate(R.layout.dialog, rootLayout, false);
-            ViewGroup bodyLayout = (ViewGroup) bodyRootView.findViewById(R.id.content);
-            TextView messageView = (TextView) bodyLayout.findViewById(R.id.message);
-
-            rootLayout.addView(bodyRootView);
-
-            // Setup content
-            bodyLayout.removeView(messageView);
-            if (!TextUtils.isEmpty(mMessageText)) {
-                messageView.setMovementMethod(new LinkMovementMethod());
-                messageView.setText(mMessageText);
-                bodyLayout.addView(messageView);
-            }
-
-            // Custom view
-            if (customViewRes != 0) customView = inflater.inflate(customViewRes, bodyLayout, false);
-            if (customView != null) bodyLayout.addView(customView);
-            mView = customView;
-
-            return rootLayout;
-        }
-
-        /**
-         * @see #LAYOUT_SKELETON
-         * @see #createView(int)
-         */
-        public View createSkeletonView() {
-            LayoutInflater inflater = (LayoutInflater) mContext
-                    .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-
-            ViewGroup rootLayout = (ViewGroup) inflater.inflate(R.layout.dialog_skeleton, null);
-            TextView titleView = (TextView) rootLayout.findViewById(R.id.title);
-
-            // Setup title
-            if (mTitleText != null) {
-                titleView.setText(mTitleText);
-                titleView.setCompoundDrawablesWithIntrinsicBounds(mIcon, null, null, null);
-            } else {
-                // This also removes an icon.
-                rootLayout.removeView(titleView);
-            }
-
-            // Custom view
-            if (mViewRes != 0) mView = inflater.inflate(mViewRes, rootLayout, false);
-            if (mView != null) rootLayout.addView(mView);
-
-            return rootLayout;
-        }
-
-        public AlertDialog.Builder wrap() {
-            return wrap(LAYOUT_COMMON);
-        }
-
-        /**
-         * Creates view and {@link AlertDialog.Builder#setView(android.view.View) sets}
-         * to new {@link AlertDialog.Builder}.
-         *
-         * @param type type of container layout
-         * @return AlertDialog.Builder with set custom view
-         */
-        public AlertDialog.Builder wrap(int type) {
-            return new AlertDialog.Builder(mContext).setView(createView(type));
-        }
-
-    }
-
 }
\ No newline at end of file
diff --git a/project/app/src/main/java/com/achep/acdisplay/Presenter.java b/project/app/src/main/java/com/achep/acdisplay/Presenter.java
index 007c4389..e4957fff 100644
--- a/project/app/src/main/java/com/achep/acdisplay/Presenter.java
+++ b/project/app/src/main/java/com/achep/acdisplay/Presenter.java
@@ -18,18 +18,21 @@
  */
 package com.achep.acdisplay;
 
-import android.app.Activity;
 import android.content.Context;
 import android.content.Intent;
 import android.os.PowerManager;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.telephony.TelephonyManager;
 import android.util.Log;
 
-import com.achep.acdisplay.acdisplay.AcDisplayActivity;
-import com.achep.acdisplay.activities.KeyguardActivity;
-import com.achep.acdisplay.utils.PowerUtils;
-
-import java.util.ArrayList;
+import com.achep.acdisplay.blacklist.Blacklist;
+import com.achep.acdisplay.notifications.NotificationPresenter;
+import com.achep.acdisplay.notifications.OpenNotification;
+import com.achep.acdisplay.services.activemode.sensors.ProximitySensor;
+import com.achep.acdisplay.ui.activities.AcDisplayActivity;
+import com.achep.acdisplay.ui.activities.KeyguardActivity;
+import com.achep.base.utils.power.PowerUtils;
 
 /**
  * Created by Artem on 07.03.14.
@@ -39,26 +42,70 @@ public class Presenter {
     private static final String TAG = "AcDisplayPresenter";
     private static final String WAKE_LOCK_TAG = "AcDisplay launcher.";
 
-    /**
-     * Requests to lock screen from AcDisplay activity.
-     *
-     * @return true if locked, false otherwise
-     */
-    @Deprecated
-    public boolean stop(Context context) {
-        //noinspection SimplifiableIfStatement
-        if (mActivity != null
-                && PowerUtils.isScreenOn(context)) {
-            return mActivity.lock();
+    private static Presenter sPresenter;
+
+    @Nullable
+    private AcDisplayActivity mActivity;
+
+    public static synchronized Presenter getInstance() {
+        if (sPresenter == null) {
+            sPresenter = new Presenter();
         }
-        return false;
+        return sPresenter;
     }
 
-    public void start(Context context) {
+    public void attachActivity(@Nullable AcDisplayActivity activity) {
+        mActivity = activity;
+    }
+
+    public void detachActivity() {
+        attachActivity(null);
+    }
+
+    public void kill() {
+        if (mActivity != null) mActivity.finish();
+    }
+
+    //-- START-UP -------------------------------------------------------------
+
+    public boolean tryStartGuiCauseNotification(@NonNull Context context,
+                                                @NonNull OpenNotification n) {
+        NotificationPresenter np = NotificationPresenter.getInstance();
+        if (!np.isTestNotification(context, n)) { // force test notification to be shown
+            Config config = Config.getInstance();
+            if (!config.isEnabled() || !config.isNotifyWakingUp()
+                    // Inactive time
+                    || config.isInactiveTimeEnabled()
+                    && InactiveTimeHelper.isInactiveTime(config)
+                    // Only while charging
+                    || config.isEnabledOnlyWhileCharging()
+                    && !PowerUtils.isPlugged(context)) {
+                // Don't turn screen on due to user settings.
+                return false;
+            }
+
+            if (ProximitySensor.isNear()) {
+                // Don't display while device is face down.
+                return false;
+            }
+
+            String packageName = n.getPackageName();
+            Blacklist blacklist = Blacklist.getInstance();
+            if (blacklist.getAppConfig(packageName).isRestricted()) {
+                // Don't display due to app settings.
+                return false;
+            }
+        }
+
+        return tryStartGuiCauseSensor(context);
+    }
+
+    public boolean tryStartGuiCauseSensor(@NonNull Context context) {
         PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
         TelephonyManager ts = (TelephonyManager) context.getSystemService(Context.TELEPHONY_SERVICE);
         if (PowerUtils.isScreenOn(pm) || ts.getCallState() != TelephonyManager.CALL_STATE_IDLE) {
-            return;
+            // Screen is on || phone call.
+            return false;
         }
 
         // Wake up from possible deep sleep.
@@ -72,88 +119,23 @@ public class Presenter {
         //      `---------'
         pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, WAKE_LOCK_TAG).acquire(1000);
 
-        Config config = Config.getInstance();
-
         kill();
-        context.startActivity(new Intent(Intent.ACTION_MAIN, null)
+        context.startActivity(new Intent(context, AcDisplayActivity.class)
                 .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
                         | Intent.FLAG_ACTIVITY_NO_USER_ACTION
                         | Intent.FLAG_ACTIVITY_NO_ANIMATION
                         | Intent.FLAG_FROM_BACKGROUND)
-                .putExtra(KeyguardActivity.EXTRA_TURN_SCREEN_ON, true)
-                .putExtra(KeyguardActivity.EXTRA_FINISH_ON_SCREEN_OFF, !config.isKeyguardEnabled())
-                .setClass(context, AcDisplayActivity.class));
+                .putExtra(KeyguardActivity.EXTRA_TURN_SCREEN_ON, true));
 
         Log.i(TAG, "Launching AcDisplay activity.");
+        return true;
     }
 
-    public void kill() {
-        if (mActivity != null) mActivity.finish();
-    }
-
-    /**
-     * Listener to ActiveDisplayPresenter state.
-     */
-    public interface OnActiveDisplayStateChangedListener {
-        public void OnActiveDisplayStateChanged(Activity activity);
-    }
-
-    private static Presenter sPresenter;
-
-    private ArrayList<OnActiveDisplayStateChangedListener> mListeners;
-    private AcDisplayActivity mActivity;
-
-    public static synchronized Presenter getInstance() {
-        if (sPresenter == null) {
-            sPresenter = new Presenter();
-        }
-        return sPresenter;
-    }
-
-    private Presenter() {
-        mListeners = new ArrayList<>(4);
-    }
-
-    public void registerListener(OnActiveDisplayStateChangedListener listener) {
-        mListeners.add(listener);
-    }
-
-    public void unregisterListener(OnActiveDisplayStateChangedListener listener) {
-        mListeners.remove(listener);
-    }
-
-    public void attachActivity(AcDisplayActivity activity) {
-        mActivity = activity;
-
-        for (OnActiveDisplayStateChangedListener listener : mListeners) {
-            listener.OnActiveDisplayStateChanged(mActivity);
-        }
-    }
-
-    public void detachActivity() {
-        attachActivity(null);
-    }
-
-    public boolean isActivityAttached() {
-        return mActivity != null;
-    }
-
-    public AcDisplayActivity getActivity() {
-        return mActivity;
-    }
-
-    public void launchAcDisplay(Context context) {
-        if (mActivity != null) {
-        }
-
-        context.startActivity(new Intent(Intent.ACTION_MAIN, null)
+    public boolean tryStartGuiCauseKeyguard(@NonNull Context context) {
+        context.startActivity(new Intent(context, AcDisplayActivity.class)
                 .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
-                        | Intent.FLAG_ACTIVITY_NO_USER_ACTION
-                        | Intent.FLAG_ACTIVITY_NO_ANIMATION
-                        | Intent.FLAG_FROM_BACKGROUND)
-                .putExtra(KeyguardActivity.EXTRA_TURN_SCREEN_ON, true)
-                .putExtra(KeyguardActivity.EXTRA_FINISH_ON_SCREEN_OFF, true)
-                .setClass(context, AcDisplayActivity.class));
+                        | Intent.FLAG_ACTIVITY_NO_ANIMATION));
+        return true;
     }
 
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/RepositoryUrlBuilder.java b/project/app/src/main/java/com/achep/acdisplay/RepositoryUrlBuilder.java
deleted file mode 100644
index ecb8b1ec..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/RepositoryUrlBuilder.java
+++ /dev/null
@@ -1,101 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-package com.achep.acdisplay;
-
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-
-/**
- * Builder of the links to remote repository.
- *
- * @author Artem Chepurnoy
- */
-public class RepositoryUrlBuilder {
-
-    public static final String PROJECT_NAME = "project";
-    public static final String MODULE_NAME = "app";
-
-    private static final String USERNAME = "AChep";
-    private static final String PROJECT = "AcDisplay";
-    private static final String FORMATTER = "https://%1$s/%2$s/%3$s/%4$s/";
-
-    private String mBranch;
-    private String mFileName;
-    private StringBuilder mPathBuilder;
-    private boolean mRawAccess = false;
-
-    @NonNull
-    public RepositoryUrlBuilder setBranch(@Nullable String branch) {
-        mBranch = branch;
-        return this;
-    }
-
-    @NonNull
-    public RepositoryUrlBuilder setRawAccess(boolean rawAccess) {
-        mRawAccess = rawAccess;
-        return this;
-    }
-
-    @NonNull
-    public RepositoryUrlBuilder setFile(String fileName) {
-        mFileName = fileName;
-        return this;
-    }
-
-    @NonNull
-    public RepositoryUrlBuilder changeDirectory(@NonNull String dir) {
-        if (mPathBuilder == null) {
-            mPathBuilder = new StringBuilder();
-        }
-        mPathBuilder.append(dir).append('/');
-        return this;
-    }
-
-    @NonNull
-    public String build() {
-        if (mBranch == null) mBranch = "master";
-
-        String branch;
-        String domain;
-        String path = mPathBuilder == null ? "" : mPathBuilder.toString();
-
-        do {
-            if (mFileName != null) {
-                path += mFileName;
-                if (mRawAccess) {
-                    domain = "raw.githubusercontent.com";
-                    branch = "";
-                    break;
-                } else {
-                    branch = "blob/";
-                }
-            } else {
-                branch = "tree/";
-            }
-
-            domain = "www.github.com";
-        } while (false);
-
-        branch += mBranch;
-
-        return String.format(FORMATTER, domain, USERNAME, PROJECT, branch) + path;
-    }
-
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/Timeout.java b/project/app/src/main/java/com/achep/acdisplay/Timeout.java
index 1cd5dcd8..645fd349 100644
--- a/project/app/src/main/java/com/achep/acdisplay/Timeout.java
+++ b/project/app/src/main/java/com/achep/acdisplay/Timeout.java
@@ -22,10 +22,10 @@ import android.os.Handler;
 import android.os.Message;
 import android.os.SystemClock;
 import android.view.animation.LinearInterpolator;
+import android.widget.ProgressBar;
 
-import com.achep.acdisplay.animations.ProgressBarAnimation;
-import com.achep.acdisplay.utils.MathUtils;
-import com.achep.acdisplay.widgets.ProgressBar;
+import com.achep.acdisplay.ui.animations.ProgressBarAnimation;
+import com.achep.base.utils.MathUtils;
 
 import java.util.ArrayList;
 
@@ -201,7 +201,7 @@ public class Timeout {
     }
 
     /**
-     * Displays timeout's events in given {@link com.achep.acdisplay.widgets.ProgressBar}.
+     * Displays timeout's events in given {@link com.achep.acdisplay.ui.widgets.ProgressBar}.
      */
     public static class Gui implements Timeout.OnTimeoutEventListener {
 
diff --git a/project/app/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayActivity.java b/project/app/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayActivity.java
deleted file mode 100644
index 93310c5a..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayActivity.java
+++ /dev/null
@@ -1,318 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.acdisplay.acdisplay;
-
-import android.animation.Animator;
-import android.animation.AnimatorListenerAdapter;
-import android.annotation.SuppressLint;
-import android.app.FragmentManager;
-import android.app.FragmentTransaction;
-import android.content.Intent;
-import android.graphics.Bitmap;
-import android.os.Bundle;
-import android.support.v4.content.LocalBroadcastManager;
-import android.view.View;
-import android.view.Window;
-import android.view.WindowManager;
-import android.widget.ImageView;
-
-import com.achep.acdisplay.App;
-import com.achep.acdisplay.Config;
-import com.achep.acdisplay.Device;
-import com.achep.acdisplay.Operator;
-import com.achep.acdisplay.Presenter;
-import com.achep.acdisplay.R;
-import com.achep.acdisplay.Timeout;
-import com.achep.acdisplay.activities.KeyguardActivity;
-import com.achep.acdisplay.fragments.PocketFragment;
-import com.achep.acdisplay.services.media.MediaController;
-
-/**
- * Created by Artem on 25.01.14.
- */
-public class AcDisplayActivity extends KeyguardActivity implements
-        Timeout.OnTimeoutEventListener,
-        PocketFragment.OnSleepRequestListener {
-
-    private static final String TAG = "AcDisplayActivity";
-
-    private ImageView mBackgroundView;
-    private boolean mCustomBackgroundShown;
-
-    private Timeout mTimeout;
-    private Config mConfig = Config.getInstance();
-
-    private MediaController mMediaController;
-
-    private PocketFragment mPocketFragment;
-
-    @Override
-    public void onWindowFocusChanged(boolean hasFocus) {
-        super.onWindowFocusChanged(hasFocus);
-        populateFlags(hasFocus);
-    }
-
-    @SuppressLint("NewApi")
-    private void populateFlags(boolean windowHasFocus) {
-        Window window = getWindow();
-        View decorView = window.getDecorView();
-
-        int windowFlags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
-
-        if (windowHasFocus) {
-            int visibilityUi = View.SYSTEM_UI_FLAG_LAYOUT_STABLE
-                    | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
-                    | View.SYSTEM_UI_FLAG_LOW_PROFILE;
-
-            if (mConfig.isFullScreen()) {
-                // Hide status bar if fullscreen mode is enabled.
-                visibilityUi = visibilityUi
-                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
-                        | View.SYSTEM_UI_FLAG_FULLSCREEN;
-            }
-
-            if (Device.hasKitKatApi()) {
-                // Hide navigation bar and flag sticky.
-                visibilityUi = visibilityUi
-                        | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
-                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
-            }
-
-            decorView.setSystemUiVisibility(visibilityUi);
-            window.addFlags(windowFlags);
-
-            mTimeout.resume();
-            mTimeout.setTimeoutDelayed(mConfig.getTimeoutNormal(), true);
-        } else {
-            int visibilityUi = decorView.getSystemUiVisibility();
-            if (Device.hasKitKatApi()) {
-                // Clear immersive sticky flag.
-                // Hopefully it will fix annoying Android feature: IMMERSIVE_PANIC
-                visibilityUi ^= View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY;
-            }
-
-            decorView.setSystemUiVisibility(visibilityUi);
-            window.clearFlags(windowFlags);
-
-            mTimeout.setTimeoutDelayed(mConfig.getTimeoutNormal(), true);
-            mTimeout.pause();
-        }
-    }
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        mMediaController = new MediaController();
-        mMediaController.onCreate(this);
-
-        mTimeout = new Timeout();
-        mTimeout.registerListener(this);
-
-        super.onCreate(savedInstanceState);
-
-        if (mConfig.isWallpaperShown()) {
-            if (mConfig.isShadowEnabled()) {
-                setTheme(R.style.AcDisplayTheme_Wallpaper_WithShadow);
-            } else {
-                setTheme(R.style.AcDisplayTheme_Wallpaper);
-            }
-        }
-
-        setContentView(R.layout.acdisplay);
-        mBackgroundView = (ImageView) findViewById(R.id.background);
-
-        // Initialize non-UI fragments.
-        if (savedInstanceState == null) {
-            initInternalFragments();
-        } else {
-
-            // Find fragments.
-            FragmentManager fm = getFragmentManager();
-            mPocketFragment = (PocketFragment) fm.findFragmentByTag(PocketFragment.TAG);
-            // TODO: Maybe remove PocketFragment if active mode is disabled?
-        }
-
-        // Setup fragments.
-        if (mPocketFragment != null) {
-            mPocketFragment.setListener(this);
-        }
-
-        Presenter.getInstance().attachActivity(this);
-    }
-
-    /**
-     * Initializes non-UI fragments such as {@link com.achep.acdisplay.fragments.PocketFragment}.
-     */
-    private void initInternalFragments() {
-        FragmentTransaction ft = getFragmentManager().beginTransaction();
-
-        // Turns screen off inside of your pocket.
-        if (mConfig.isActiveModeEnabled()) {
-            mPocketFragment = PocketFragment.newInstance();
-            ft.add(mPocketFragment, PocketFragment.TAG);
-        }
-
-        ft.commit();
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-
-        hideHeadsUpApp(true);
-        populateFlags(true);
-        mMediaController.onStart();
-    }
-
-    @Override
-    protected void onPause() {
-        super.onPause();
-
-        hideHeadsUpApp(false);
-        populateFlags(false);
-        mMediaController.onStop();
-    }
-
-    /**
-     * Asks HeadsUp (https://play.google.com/store/apps/details?id=com.achep.headsup) to
-     * pause or continue showing its floating notifications.
-     *
-     * @param hideHeadsUp {@code true} to disallow showing floating notifications,
-     *                    {@code false} to allow.
-     */
-    private void hideHeadsUpApp(boolean hideHeadsUp) {
-        Intent intent = new Intent(hideHeadsUp
-                ? "com.achep.headsup.ACTION_DISALLOW_HEADSUP"
-                : "com.achep.headsup.ACTION_ALLOW_HEADSUP");
-        sendBroadcast(intent);
-    }
-
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-        mMediaController.onDestroy();
-
-        mTimeout.unregisterListener(this);
-        mTimeout.clear();
-        mTimeout = null;
-
-        Presenter.getInstance().detachActivity();
-    }
-
-    @Override
-    public void onTimeoutEvent(Timeout timeout, int event) {
-        switch (event) {
-            case Timeout.EVENT_TIMEOUT:
-                final boolean lockedSuccessful = lock();
-
-                if (lockedSuccessful) {
-                    LocalBroadcastManager manager = LocalBroadcastManager.getInstance(this);
-                    manager.sendBroadcast(new Intent(App.ACTION_INTERNAL_TIMEOUT));
-
-                    // TODO: Detect if user has really missed this wake-up or no.
-                    manager.sendBroadcast(new Intent(App.ACTION_INTERNAL_PING_SENSORS));
-                }
-                break;
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onSleepRequest() {
-        // Probably it's not the best solution, but not worst too.
-        // Check if user does not interact with app before locking.
-        if (!mTimeout.isPaused()) {
-
-            lock();
-        }
-    }
-
-    /**
-     * Clears background.
-     *
-     * @see #dispatchSetBackground(android.graphics.Bitmap, int)
-     */
-    public void dispatchClearBackground() {
-        dispatchSetBackground(null);
-    }
-
-    /**
-     * Smoothly sets the background. This feature is known as "Dynamic background".
-     *
-     * @param bitmap the bitmap to display, or {@code null} to hide previous background.
-     * @param mask   one of the following:
-     *               {@link Config#DYNAMIC_BG_ARTWORK_MASK},
-     *               {@link Config#DYNAMIC_BG_NOTIFICATION_MASK} or
-     *               {@code 0} to bypass mask checking.
-     * @see #dispatchClearBackground()
-     */
-    public void dispatchSetBackground(Bitmap bitmap, int mask) {
-        if (mask == 0 || Operator.bitAnd(mConfig.getDynamicBackgroundMode(), mask)) {
-            dispatchSetBackground(bitmap);
-        }
-    }
-
-    /**
-     * Smoothly sets the background.
-     */
-    private void dispatchSetBackground(Bitmap bitmap) {
-        if (bitmap == null) {
-            if (mCustomBackgroundShown) {
-                mBackgroundView.animate().cancel();
-                mBackgroundView.animate().alpha(0f).setListener(
-                        new AnimatorListenerAdapter() {
-                            @Override
-                            public void onAnimationEnd(Animator animation) {
-                                super.onAnimationEnd(animation);
-                                mBackgroundView.setImageBitmap(null);
-                                mBackgroundView.setVisibility(View.GONE);
-                            }
-                        }
-                );
-            }
-            mCustomBackgroundShown = false;
-            return;
-        }
-
-        // TODO: Crossfade background change animation would be really nice.
-        float alphaStart = mBackgroundView.getVisibility() == View.GONE ? 0f : 0.4f;
-
-        mCustomBackgroundShown = true;
-        mBackgroundView.setAlpha(alphaStart);
-        mBackgroundView.setImageBitmap(bitmap);
-        mBackgroundView.setVisibility(View.VISIBLE);
-
-        mBackgroundView.animate().cancel();
-        mBackgroundView.animate().alpha(1f).setListener(null);
-    }
-
-    public Config getConfig() {
-        return mConfig;
-    }
-
-    public Timeout getTimeout() {
-        return mTimeout;
-    }
-
-    public MediaController getCustomMediaController() {
-        return mMediaController;
-    }
-
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayFragment.java b/project/app/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayFragment.java
deleted file mode 100644
index 176b41d6..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayFragment.java
+++ /dev/null
@@ -1,938 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-package com.achep.acdisplay.acdisplay;
-
-import android.annotation.SuppressLint;
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.Fragment;
-import android.content.res.Resources;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.Message;
-import android.os.SystemClock;
-import android.transition.ChangeBounds;
-import android.transition.Fade;
-import android.transition.Transition;
-import android.transition.TransitionManager;
-import android.transition.TransitionSet;
-import android.util.Log;
-import android.view.HapticFeedbackConstants;
-import android.view.LayoutInflater;
-import android.view.MotionEvent;
-import android.view.VelocityTracker;
-import android.view.View;
-import android.view.ViewConfiguration;
-import android.view.ViewGroup;
-import android.view.animation.Animation;
-import android.view.animation.Transformation;
-import android.widget.GridLayout;
-
-import com.achep.acdisplay.Build;
-import com.achep.acdisplay.Config;
-import com.achep.acdisplay.Device;
-import com.achep.acdisplay.R;
-import com.achep.acdisplay.acdisplay.components.NotifyWidget;
-import com.achep.acdisplay.acdisplay.components.Widget;
-import com.achep.acdisplay.animations.AnimationListenerAdapter;
-import com.achep.acdisplay.compat.SceneCompat;
-import com.achep.acdisplay.notifications.NotificationPresenter;
-import com.achep.acdisplay.notifications.NotificationUtils;
-import com.achep.acdisplay.notifications.OpenNotification;
-import com.achep.acdisplay.utils.MathUtils;
-import com.achep.acdisplay.utils.ViewUtils;
-import com.achep.acdisplay.view.ForwardingLayout;
-import com.achep.acdisplay.view.ForwardingListener;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.ArrayList;
-import java.util.HashMap;
-
-/**
- * This is main fragment of ActiveDisplay app.
- */
-// TODO: Put main scene inside of widget.
-public class AcDisplayFragment extends Fragment implements
-        NotificationPresenter.OnNotificationListChangedListener,
-        ForwardingLayout.OnForwardedEventListener, View.OnTouchListener,
-        Widget.Callback, Config.OnConfigChangedListener {
-
-    private static final String TAG = "AcDisplayFragment";
-
-    private static final int MSG_RESET_SCENE = 0;
-
-    private View mDividerView;
-    private ForwardingLayout mSceneContainer;
-    private ForwardingLayout mIconsForwarder;
-    private GridLayout mIconsContainer;
-    private ForwardingListener mSceneForwardingListener;
-    private ForwardingListener mIconsForwardingListener;
-    private final Handler mTouchHandler = new Handler();
-
-    // Pinnable widgets
-    private boolean mHasPinnedWidget;
-
-    private int mConfigWidgetPinDuration;
-    private int mConfigWidgetSelectDelay;
-
-    // Animations
-    private DismissAnimation mSceneContainerDismissAnim;
-
-    // Swipe to dismiss
-    private VelocityTracker mVelocityTracker;
-    private int mMaxFlingVelocity;
-    private int mMinFlingVelocity;
-
-    private final HashMap<View, Widget> mWidgetsMap = new HashMap<>();
-    private final HashMap<String, SceneCompat> mScenesMap = new HashMap<>();
-    private Widget mSelectedWidget;
-    private View mPressedIconView;
-
-    private SceneCompat mCurrentScene;
-    private SceneCompat mSceneMain;
-    private Transition mTransition;
-
-    /**
-     * Handler to control delayed events.
-     *
-     * @see #MSG_RESET_SCENE
-     */
-    private final Handler mHandler = new Handler() {
-        @Override
-        public void handleMessage(Message msg) {
-            super.handleMessage(msg);
-            switch (msg.what) {
-                case MSG_RESET_SCENE:
-                    resetScene();
-                    break;
-            }
-        }
-    };
-
-    /**
-     * Controller of dismiss animation.
-     */
-    private class DismissAnimation extends Animation {
-
-        private float start;
-        private Widget widget;
-
-        public DismissAnimation() {
-            super();
-            setAnimationListener(new AnimationListenerAdapter() {
-                @Override
-                public void onAnimationEnd(Animation animation) {
-                    Widget widget = DismissAnimation.this.widget;
-
-                    onWidgetDismiss(widget);
-                    if (mSelectedWidget == widget) {
-                        resetScene();
-                    }
-                }
-            });
-        }
-
-        @Override
-        protected void applyTransformation(float interpolatedTime, Transformation t) {
-            super.applyTransformation(interpolatedTime, t);
-            float value = (start + (1f - start) * interpolatedTime);
-            populateSceneContainerDismissAnimation(value);
-        }
-
-        public void setup(int duration, float start, Widget widget) {
-            if (!hasEnded()) Log.wtf(TAG, "Setting up running animation!!!");
-            setDuration(duration);
-            this.start = start;
-            this.widget = widget;
-        }
-
-    }
-
-    private boolean isPinnable() {
-        return getConfig().isWidgetPinnable();
-    }
-
-    private boolean isReadable() {
-        return getConfig().isWidgetReadable();
-    }
-
-    protected Config getConfig() {
-        return Config.getInstance();
-    }
-
-    public View getDividerView() {
-        return mDividerView;
-    }
-
-    /**
-     * @return Layout resource to be inflated as fragment's view.
-     * @see #onCreateView(android.view.LayoutInflater, android.view.ViewGroup, android.os.Bundle)
-     */
-    protected int getViewResource() {
-        return R.layout.acdisplay_fragment;
-    }
-
-    @Override
-    public void onAttach(Activity activity) {
-        super.onAttach(activity);
-
-        ViewConfiguration vc = ViewConfiguration.get(activity);
-        mMaxFlingVelocity = vc.getScaledMaximumFlingVelocity();
-        mMinFlingVelocity = vc.getScaledMinimumFlingVelocity();
-
-        mSceneContainerDismissAnim = new DismissAnimation();
-
-        Resources res = getResources();
-        mConfigWidgetPinDuration = res.getInteger(R.integer.config_maxPinTime);
-        mConfigWidgetSelectDelay = res.getInteger(R.integer.config_iconSelectDelayMillis);
-    }
-
-    @TargetApi(android.os.Build.VERSION_CODES.KITKAT)
-    @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        View root = inflater.inflate(getViewResource(), container, false);
-        assert root != null;
-
-        mDividerView = root.findViewById(R.id.divider);
-        mSceneContainer = (ForwardingLayout) root.findViewById(R.id.scene);
-        mIconsForwarder = (ForwardingLayout) root.findViewById(R.id.forwarding);
-        mIconsContainer = (GridLayout) root.findViewById(R.id.grid);
-        mIconsForwarder.setOnForwardedEventListener(this);
-        mIconsForwarder.setAllViewsForwardable(true, 1);
-        mIconsForwarder.setOnTouchListener(this);
-
-        mSceneForwardingListener = new ForwardingListener(mIconsForwarder, false, mSceneContainer);
-        mIconsForwardingListener = new ForwardingListener(mIconsForwarder, true, mIconsForwarder);
-
-        ViewGroup sceneMain = (ViewGroup) inflater.inflate(R.layout.acdisplay_scene_clock, mSceneContainer, false);
-        mSceneMain = new SceneCompat(mSceneContainer, sceneMain);
-
-        if (Device.hasKitKatApi()) {
-            mTransition = new TransitionSet()
-                    .setOrdering(TransitionSet.ORDERING_TOGETHER)
-                    .addTransition(new Fade())
-                    .addTransition(new ChangeBounds())
-            ;
-        }
-        return root;
-    }
-
-    @Override
-    public void onViewCreated(View view, Bundle savedInstanceState) {
-        super.onViewCreated(view, savedInstanceState);
-        showWidget(getFirstWidget(), false);
-    }
-
-    @Override
-    public void onStart() {
-        super.onStart();
-
-        NotificationPresenter.getInstance().registerListener(this);
-        updateNotificationList();
-
-        Config config = Config.getInstance();
-        config.registerListener(this);
-        updateIconsSize();
-
-        resetScene();
-    }
-
-    @Override
-    public void onStop() {
-        mHandler.removeCallbacksAndMessages(null);
-        mTouchHandler.removeCallbacksAndMessages(null);
-        mSceneContainer.clearAnimation();
-
-        NotificationPresenter.getInstance().unregisterListener(this);
-
-        Config config = Config.getInstance();
-        config.unregisterListener(this);
-        super.onStop();
-    }
-
-    @Override
-    public void onConfigChanged(Config config, String key, Object value) {
-        switch (key) {
-            case Config.KEY_UI_ICON_SIZE:
-                updateIconsSize();
-                break;
-        }
-    }
-
-    @Override
-    public void onNotificationListChanged(NotificationPresenter np,
-                                          OpenNotification osbn,
-                                          int event) {
-        switch (event) { // don't update on spam-change.
-            case NotificationPresenter.EVENT_REMOVED:
-                // If widget related to removed notification is pinned - unpin it.
-                if (hasPinnedWidget() && mSelectedWidget instanceof NotifyWidget) {
-                    NotifyWidget widget = (NotifyWidget) mSelectedWidget;
-                    if (NotificationUtils.hasIdenticalIds(widget.getNotification(), osbn)) {
-                        showMainWidget(); // Unpin
-                    }
-                }
-            case NotificationPresenter.EVENT_POSTED:
-            case NotificationPresenter.EVENT_CHANGED:
-            case NotificationPresenter.EVENT_BATH:
-                if (getActivity() != null) {
-                    updateNotificationList();
-                } else {
-                    Log.wtf(TAG, "List of notifications changed while fragment doesn't have an Activity! ");
-                }
-                break;
-        }
-    }
-
-    @Override
-    public void requestBackgroundUpdate(Widget widget) { /* unused */ }
-
-    @Override
-    public void requestTimeoutRestart(Widget widget) { /* unused */ }
-
-    public void unlock(Runnable runnable, boolean pendingFinish) {
-        if (runnable != null) {
-            runnable.run();
-        }
-    }
-
-    @Override
-    public void onPressedView(MotionEvent event, int activePointerId, View view) {
-        mTouchHandler.removeCallbacksAndMessages(null);
-        mHandler.removeMessages(MSG_RESET_SCENE);
-        mPressedIconView = view;
-
-        if (view != null) {
-            final Widget widget = findWidgetByIcon(view);
-            if (!isCurrentWidget(widget)) { // otherwise redundant
-                mTouchHandler.postDelayed(new Runnable() {
-                    @Override
-                    public void run() {
-                        showWidget(widget);
-                    }
-                }, event.getActionMasked() == MotionEvent.ACTION_DOWN
-                        ? 0 : mConfigWidgetSelectDelay);
-            }
-        }
-    }
-
-    @Override
-    public boolean onTouch(View v, MotionEvent event) {
-        if (v == mIconsForwarder) {
-            mSceneForwardingListener.onTouch(v, event);
-            mIconsForwardingListener.onTouch(v, event);
-            return true;
-        }
-        return false;
-    }
-
-    @Override
-    public void onForwardedEvent(MotionEvent event, int activePointerId) {
-        boolean dismiss = false;
-
-        int action = event.getActionMasked();
-        switch (action) {
-            case MotionEvent.ACTION_DOWN:
-                // Track the velocity of movement, so we
-                // can do swipe-to-dismiss.
-                mVelocityTracker = VelocityTracker.obtain();
-            case MotionEvent.ACTION_MOVE:
-            case MotionEvent.ACTION_UP:
-                populateSwipeToDismiss(event);
-
-                if (action != MotionEvent.ACTION_UP) {
-                    return; // Don't fall down.
-                }
-
-                //noinspection LoopStatementThatDoesntLoop
-                while (isDismissible(mSelectedWidget)) {
-                    mVelocityTracker.computeCurrentVelocity(1000);
-
-                    float velocityX = mVelocityTracker.getXVelocity();
-                    float velocityY = mVelocityTracker.getYVelocity();
-                    float absVelocityX = Math.abs(velocityX);
-                    float absVelocityY = Math.abs(velocityY);
-
-                    float deltaY = mSceneContainer.getTranslationY();
-                    float absDeltaY = Math.abs(deltaY);
-
-                    int height = getSceneView().getHeight();
-                    if (height == 0) {
-                        // Scene view is not measured yet.
-                        break; // Exits from loop not from the switch!
-                    } else if (absDeltaY < height / 2) {
-                        if (mMinFlingVelocity <= absVelocityY
-                                && absVelocityY <= mMaxFlingVelocity
-                                && absVelocityY > absVelocityX * 2
-                                && absDeltaY > height / 5) {
-                            // Dismiss only if flinging in the same direction as dragging
-                            dismiss = (velocityY < 0) == (deltaY < 0);
-                        }
-
-                        if (!dismiss) {
-                            break; // Exits from loop not from the switch!
-                        }
-                    }
-
-                    dismiss = true;
-
-                    if (height > absDeltaY) {
-                        int duration;
-                        duration = Math.round(1000f /* ms. */ * (height - absDeltaY) / absVelocityX);
-                        duration = Math.min(duration, 300);
-
-                        mSceneContainerDismissAnim.setup(duration,
-                                MathUtils.range(deltaY / height, 0f, 1f),
-                                mSelectedWidget);
-                        mSceneContainer.startAnimation(mSceneContainerDismissAnim);
-                        break; // Exits from loop not from the switch!
-                    }
-
-                    // Instant dismissing.
-                    onWidgetDismiss(mSelectedWidget);
-                    resetScene();
-                    break;
-                }
-
-                // Don't not reset scene while dismissing, or if
-                // pinnable.
-                if (!dismiss) {
-                    if (mPressedIconView == null || !isPinnable()) {
-                        resetScene();
-                    } else {
-                        onWidgetPinned(mSelectedWidget);
-                    }
-                }
-            case MotionEvent.ACTION_CANCEL:
-                mTouchHandler.removeCallbacksAndMessages(null);
-                mVelocityTracker.recycle();
-                mVelocityTracker = null;
-
-                if (action == MotionEvent.ACTION_CANCEL) {
-                    resetScene();
-                }
-                break;
-        }
-    }
-
-    protected boolean hasPinnedWidget() {
-        return mHasPinnedWidget;
-    }
-
-    protected void onWidgetPinned(Widget widget) {
-        mHandler.sendEmptyMessageDelayed(MSG_RESET_SCENE, mConfigWidgetPinDuration);
-        mHasPinnedWidget = true;
-    }
-
-    protected void onWidgetReadAloud(Widget widget) {
-        // TODO: Read widget aloud
-    }
-
-    /**
-     * Called when widget is going to be dismissed.
-     */
-    protected void onWidgetDismiss(Widget widget) {
-        widget.onDismiss();
-        // TODO: Clear widget from different maps and layouts
-    }
-
-    /**
-     * Resets {@link #mSceneContainer scene container}'s params and
-     * {@link #showMainWidget() shows main widget}.
-     *
-     * @see #resetSceneContainerParams()
-     */
-    protected void resetScene() {
-        resetSceneContainerParams();
-        showMainWidget();
-    }
-
-    /**
-     * Resets {@link #mSceneContainer scene container}'s params, such
-     * as: animation, alpha level, translation, rotation etc.
-     *
-     * @see #resetScene()
-     */
-    private void resetSceneContainerParams() {
-        mSceneContainer.clearAnimation();
-        mSceneContainer.setAlpha(1f);
-        mSceneContainer.setTranslationY(0);
-        mSceneContainer.setRotationX(0);
-    }
-
-    private void populateSceneContainerDismissAnimation(float progress) {
-        float height = getSceneView().getHeight();
-        float y = height * progress;
-        double degrees = Math.toDegrees(Math.acos((height - y) / height));
-
-        mSceneContainer.setAlpha(1f - progress);
-        mSceneContainer.setTranslationY(y);
-        mSceneContainer.setRotationX((float) (-degrees / 2f));
-    }
-
-    private void populateSwipeToDismiss(MotionEvent srcEvent) {
-        float y = srcEvent.getY() - mIconsContainer.getHeight();
-
-        MotionEvent dstEvent = MotionEvent.obtainNoHistory(srcEvent);
-        mVelocityTracker.addMovement(MotionEvent.obtainNoHistory(srcEvent));
-        dstEvent.recycle();
-
-        if (!isDismissible(mSelectedWidget)) {
-            return;
-        }
-
-        if (y < 0) {
-            if (mSceneContainer.getTranslationY() != 0) {
-                resetSceneContainerParams();
-            }
-            return;
-        }
-
-        float height = getSceneView().getHeight();
-        float progress = MathUtils.range(y / height, 0f, 1f);
-        populateSceneContainerDismissAnimation(progress);
-
-        if (Build.DEBUG) Log.d(TAG, "dismiss_progress=" + progress + " height=" + height);
-    }
-
-    /**
-     * Shows main widget.
-     *
-     * @see #showWidget(com.achep.acdisplay.acdisplay.components.Widget)
-     * @see #showWidget(com.achep.acdisplay.acdisplay.components.Widget, boolean)
-     * @see #getCurrentWidget()
-     */
-    public void showMainWidget() {
-        showWidget(null);
-    }
-
-    /**
-     * @see #showMainWidget()
-     * @see #showWidget(com.achep.acdisplay.acdisplay.components.Widget, boolean)
-     * @see #getCurrentWidget()
-     */
-    protected void showWidget(Widget widget) {
-        showWidget(widget, true);
-    }
-
-    /**
-     * @see #showMainWidget()
-     * @see #showWidget(com.achep.acdisplay.acdisplay.components.Widget)
-     * @see #getCurrentWidget()
-     */
-    @SuppressLint("NewApi")
-    protected void showWidget(Widget widget, boolean animate) {
-        mHandler.removeMessages(MSG_RESET_SCENE);
-        mHasPinnedWidget = false;
-
-        if (mSelectedWidget != null) {
-            if (mSelectedWidget.getIconView() != null) {
-                mSelectedWidget.getIconView().setSelected(false);
-            }
-
-            mSelectedWidget.onViewDetached();
-        }
-
-        mSelectedWidget = widget;
-        resetSceneContainerParams();
-
-        if (mSelectedWidget == null) {
-            goScene(getMainScene(), animate);
-        } else {
-            SceneCompat scene = findSceneByWidget(mSelectedWidget);
-            if (scene == null) {
-
-                // Widget doesn't have a large view, so
-                // display clock.
-                goScene(getMainScene(), animate);
-            } else if (mCurrentScene != scene) {
-                goScene(scene, animate);
-            } else if (Device.hasKitKatApi() && animate) {
-                ViewGroup viewGroup = mSelectedWidget.getView();
-                if (viewGroup != null && viewGroup.isLaidOut()) {
-                    // Automatically animate content change.
-                    TransitionManager.beginDelayedTransition(viewGroup, mTransition);
-                }
-            }
-
-            mSelectedWidget.onViewAttached();
-
-            if (mSelectedWidget.getIconView() != null) {
-                mSelectedWidget.getIconView().setSelected(true);
-                mSelectedWidget.getIconView().performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
-            }
-        }
-    }
-
-    /**
-     * @return The widget to be shown on create, or {@code null} to
-     * show main scene.
-     */
-    protected Widget getFirstWidget() {
-        return null;
-    }
-
-    /**
-     * @return Currently displayed widget, or {@code null} if main widget is displayed.
-     * @see #showWidget(com.achep.acdisplay.acdisplay.components.Widget)
-     * @see #showMainWidget()
-     */
-    protected final Widget getCurrentWidget() {
-        return mSelectedWidget;
-    }
-
-    /**
-     * @return {@code true} if current widget equals to given one, {@code false} otherwise.
-     * @see #getCurrentWidget()
-     */
-    protected final boolean isCurrentWidget(Widget widget) {
-        return widget == mSelectedWidget;
-    }
-
-    /**
-     * @return {@code true} if widget is not {@code null} and
-     * {@link Widget#isDismissible() dismissible}, {@code false} otherwise.
-     */
-    public final boolean isDismissible(Widget widget) {
-        return widget != null && widget.isDismissible();
-    }
-
-    /**
-     * Changes current scene to given one.
-     *
-     * @see #showWidget(com.achep.acdisplay.acdisplay.components.Widget)
-     * @see #showMainWidget()
-     */
-    @SuppressLint("NewApi")
-    protected final void goScene(SceneCompat sceneCompat, boolean transitions) {
-        if (mCurrentScene != sceneCompat) {
-            mCurrentScene = sceneCompat;
-            if (transitions) {
-                if (Device.hasKitKatApi()) {
-                    try {
-                        // This must be a synchronization problem with Android's Scene or TransitionManager,
-                        // but those were declared as final classes, so I have no idea how to fix it.
-                        TransitionManager.go(sceneCompat.scene, mTransition);
-                    } catch (IllegalStateException e) {
-                        Log.e(TAG, "TransitionManager has failed switching scenes.");
-
-                        ViewGroup viewGroup = (ViewGroup) getSceneView().getParent();
-                        viewGroup.removeView(getSceneView());
-
-                        try {
-                            // Reset internal scene's tag to make it work again.
-                            int id = Resources.getSystem().getIdentifier("current_scene", "id", "android");
-                            Method method = View.class.getMethod("setTagInternal", int.class, Object.class);
-                            method.setAccessible(true);
-                            method.invoke(viewGroup, id, null);
-                        } catch (NoSuchMethodException
-                                | IllegalAccessException
-                                | InvocationTargetException e2) {
-                            throw new RuntimeException(e2);
-                        }
-
-                        TransitionManager.go(sceneCompat.scene, mTransition);
-                    }
-                } else {
-                    sceneCompat.enter();
-
-                    // Animate newly applied scene.
-                    if (getActivity() != null) {
-                        // TODO: Better animation for Jelly Bean users.
-                        float density = getResources().getDisplayMetrics().density;
-                        getSceneView().setAlpha(0.4f);
-                        getSceneView().setRotationX(10f);
-                        getSceneView().setTranslationY(10f * density);
-                        getSceneView().animate().alpha(1).rotationX(0).translationY(0);
-                    } else {
-                        Log.w(TAG, "Changing scene when fragment is single!");
-                    }
-                }
-            } else sceneCompat.enter();
-        }
-    }
-
-    /**
-     * @return The main scene with huge clock.
-     */
-    protected final SceneCompat getMainScene() {
-        return mSceneMain;
-    }
-
-    /**
-     * @return Currently displayed scene.
-     * @see #goScene(com.achep.acdisplay.compat.SceneCompat, boolean)
-     * @see #getMainScene()
-     */
-    protected final SceneCompat getScene() {
-        return mCurrentScene;
-    }
-
-    protected final ViewGroup getSceneContainer() {
-        return mSceneContainer;
-    }
-
-    /**
-     * @return The view of the {@link #getScene() current scene}.
-     * @see #getSceneContainer()
-     * @see #getScene()
-     */
-    private View getSceneView() {
-        return getScene().getView();
-    }
-
-    protected SceneCompat findSceneByWidget(Widget widget) {
-        if (widget.getView() != null) {
-            String className = widget.getClass().getName();
-            return mScenesMap.get(className);
-        }
-        return null;
-    }
-
-    private Widget findWidgetByIcon(View view) {
-        return mWidgetsMap.get(view);
-    }
-
-    /**
-     * Updates the size of all widget's icons as
-     * {@link com.achep.acdisplay.Config#getIconSizePx() set} in config.
-     */
-    private void updateIconsSize() {
-        final int sizePx = Config.getInstance().getIconSizePx();
-        final int childCount = mIconsContainer.getChildCount();
-        for (int i = 0; i < childCount; i++) {
-            View child = mIconsContainer.getChildAt(i);
-            updateIconSize(child, sizePx);
-        }
-    }
-
-    private void updateIconSize(View view, int size) {
-        ViewGroup.LayoutParams lp = view.getLayoutParams();
-        lp.height = size;
-        lp.width = size;
-        view.setLayoutParams(lp);
-    }
-
-    /**
-     * Updates the visibility of divider between
-     * scenes and icons.
-     */
-    private void updateDividerVisibility() {
-        ViewUtils.setVisible(getDividerView(), mIconsContainer.getChildCount() > 0);
-    }
-
-    // TODO: Optimize it
-    // Spent hours on optimizing with no result: 0h
-    private void updateNotificationList() {
-
-        long now = SystemClock.elapsedRealtime();
-
-        ViewGroup container = mIconsContainer;
-        final int childCount = container.getChildCount();
-
-        if (Device.hasKitKatApi()) {
-            TransitionManager.beginDelayedTransition(container);
-        }
-
-        // Count the number of non-notification fragments
-        // such as unlock or music controls fragments.
-        int fragmentsExtraCount = 0;
-        for (int i = 0; i < childCount; i++) {
-            View child = container.getChildAt(i);
-            Widget fragment = findWidgetByIcon(child);
-            if (!(fragment instanceof NotifyWidget)) {
-                fragmentsExtraCount++;
-            } else {
-                // Those fragments are placed at the begin of layout
-                // so no reason to continue searching.
-                break;
-            }
-        }
-
-        final ArrayList<OpenNotification> list = NotificationPresenter.getInstance().getList();
-        final int notifyCount = list.size();
-
-        final boolean[] notifyUsed = new boolean[notifyCount];
-        final boolean[] childUsed = new boolean[childCount];
-
-        // ///////////////////
-        // ~~ NOTIFICATIONS ~~
-        // ///////////////////
-
-        // Does not need an update
-        for (int i = fragmentsExtraCount; i < childCount; i++) {
-            View child = container.getChildAt(i);
-            NotifyWidget widget = (NotifyWidget) findWidgetByIcon(child);
-            OpenNotification target = widget.getNotification();
-
-            // Try to find the notification with the same
-            // id, tag and package name as in present.
-            for (int j = 0; j < notifyCount; j++) {
-                OpenNotification n = list.get(j);
-                if (NotificationUtils.hasIdenticalIds(target, n)) {
-
-                    notifyUsed[j] = true;
-                    childUsed[i] = true;
-
-                    if (target != n) {
-                        widget.setNotification(n);
-                    }
-                    break;
-                }
-            }
-        }
-
-        // Re-use free views and remove redundant views.
-        boolean removeAllAfter = false;
-        for (int a = fragmentsExtraCount, j = 0, offset = 0; a < childCount; a++) {
-            if (childUsed[a]) continue;
-            final int i = a + offset;
-
-            View child = container.getChildAt(i);
-            removing_all_next_views:
-            {
-                if (!removeAllAfter) {
-                    for (; j < notifyCount; j++) {
-                        if (notifyUsed[j]) continue;
-
-                        assert child != null;
-                        notifyUsed[j] = true;
-
-                        NotifyWidget fragment = (NotifyWidget) findWidgetByIcon(child);
-                        fragment.setNotification(list.get(j));
-                        break removing_all_next_views;
-                    }
-                }
-                removeAllAfter = true;
-                container.removeViewAt(i);
-                mWidgetsMap.remove(child);
-                offset--;
-            }
-        }
-
-        assert getActivity() != null;
-        LayoutInflater inflater = getActivity().getLayoutInflater();
-        Config config = Config.getInstance();
-        int iconSize = config.getIconSizePx();
-
-        for (int i = 0; i < notifyCount; i++) {
-            if (notifyUsed[i]) continue;
-
-            NotifyWidget fragment = new NotifyWidget(this, this);
-            View view = fragment.createIconView(inflater, container);
-            updateIconSize(view, iconSize);
-            container.addView(view);
-
-            fragment.setNotification(list.get(i));
-            mWidgetsMap.put(view, fragment);
-        }
-
-        // ////////////
-        // ~~ EXTRAS ~~
-        // ////////////
-/*
-        int[] extras = new int[]{
-                SCENE_MUSIC_CONTROLS,
-        };
-
-        extras[0] = -1;
-
-        // Show unlock widget only if there's no any
-        // other views.
-        boolean empty = true;
-        if (notifyCount > 0) {
-            empty = false;
-        } else for (int i = 1; i < extras.length; i++)
-            if (extras[i] >= 0) {
-                empty = false;
-                break;
-            }
-
-
-        for (int i = fragmentsExtraCount - 1; i >= 0; i--) {
-            View child = container.getChildAt(i);
-            Widget fragment = findWidgetByIcon(child);
-
-            boolean found = false;
-            for (int j = 0; j < extras.length; j++) {
-                if (extras[j] == fragment.getType()) {
-                    extras[j] = -1;
-                    found = true;
-                    break;
-                }
-            }
-            if (!found) {
-                container.removeViewAt(i);
-                mWidgetsMap.remove(child);
-            }
-        }
-
-        for (int i = 0, j = 0; i < extras.length; i++) {
-            if (extras[i] >= 0) {
-                Widget fragment;
-                switch (extras[i]) {
-                    case SCENE_UNLOCK:
-                        fragment = new UnlockFragment(this);
-                        break;
-                    case SCENE_MUSIC_CONTROLS:
-                        fragment = new MusicFragment(this);
-                        break;
-                    default:
-                        throw new IllegalArgumentException("Unknown acfragment type found!");
-                }
-                View view = fragment.createIconView(inflater, container);
-                container.addView(view, j++);
-                mWidgetsMap.put(view, fragment);
-            }
-        }*/
-
-        // /////////////////////
-        // ~~ UPDATE HASH MAP ~~
-        // /////////////////////
-
-        HashMap<String, SceneCompat> map = (HashMap<String, SceneCompat>) mScenesMap.clone();
-
-        mScenesMap.clear();
-        for (Widget fragment : mWidgetsMap.values()) {
-            String type = fragment.getClass().getName();
-            SceneCompat scene = map.get(type);
-            if (scene != null) {
-                fragment.createView(null, null, scene.getView());
-            } else {
-                ViewGroup sceneView = fragment.createView(inflater, mSceneContainer, null);
-                if (sceneView != null) {
-                    scene = new SceneCompat(mSceneContainer, sceneView);
-                    map.put(type, scene);
-                }
-            }
-            if (scene != null) {
-                mScenesMap.put(type, scene);
-            }
-        }
-
-        if (Build.DEBUG) {
-            long delta = SystemClock.elapsedRealtime() - now;
-            Log.d(TAG, "Fragment list updated in " + delta + "ms.");
-        }
-
-        updateDividerVisibility();
-    }
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayFragment2.java b/project/app/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayFragment2.java
deleted file mode 100644
index ebff62f0..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/acdisplay/AcDisplayFragment2.java
+++ /dev/null
@@ -1,366 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-package com.achep.acdisplay.acdisplay;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.view.GestureDetector;
-import android.view.LayoutInflater;
-import android.view.MotionEvent;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.WindowManager;
-
-import com.achep.acdisplay.Config;
-import com.achep.acdisplay.R;
-import com.achep.acdisplay.Timeout;
-import com.achep.acdisplay.acdisplay.components.MediaWidget;
-import com.achep.acdisplay.acdisplay.components.NotifyWidget;
-import com.achep.acdisplay.acdisplay.components.Widget;
-import com.achep.acdisplay.compat.SceneCompat;
-import com.achep.acdisplay.notifications.NotificationPresenter;
-import com.achep.acdisplay.services.media.MediaController;
-import com.achep.acdisplay.utils.ViewUtils;
-import com.achep.acdisplay.widgets.CircleView;
-import com.achep.acdisplay.widgets.ProgressBar;
-
-/**
- * This is main fragment of ActiveDisplay app.
- */
-public class AcDisplayFragment2 extends AcDisplayFragment implements
-        CircleView.Callback, MediaController.MediaListener {
-
-    private AcDisplayActivity mActivity;
-    private Config mConfig;
-
-    private Timeout mTimeout;
-    private Timeout.Gui mTimeoutGui;
-
-    private View mDividerView;
-    private CircleView mCircleView;
-
-    // Media widget
-    private MediaController mMediaController;
-    private MediaWidget mMediaWidget;
-    private SceneCompat mSceneMainMedia;
-
-    @Override
-    public void onAttach(Activity activity) {
-        super.onAttach(activity);
-        mActivity = (AcDisplayActivity) activity;
-
-        mMediaController = mActivity.getCustomMediaController();
-        mMediaController.registerListener(this);
-
-        mConfig = mActivity.getConfig();
-        mTimeout = mActivity.getTimeout();
-    }
-
-    @Override
-    public View getDividerView() {
-        return mDividerView;
-    }
-
-    @Override
-    protected int getViewResource() {
-        return R.layout.fragment_acdisplay;
-    }
-
-    @Override
-    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-        View root = super.onCreateView(inflater, container, savedInstanceState);
-        assert root != null;
-        root.setOnTouchListener(new View.OnTouchListener() {
-
-            private boolean transferring;
-            private GestureDetector gestureDetector =
-                    new GestureDetector(mActivity, new GestureListener());
-
-            class GestureListener extends GestureDetector.SimpleOnGestureListener {
-
-                @Override
-                public boolean onSingleTapUp(MotionEvent e) {
-                    return false;
-                }
-
-                @Override
-                public boolean onDoubleTap(MotionEvent e) {
-                    return mActivity.lock();
-                }
-            }
-
-            @Override
-            public boolean onTouch(View v, MotionEvent event) {
-                gestureDetector.onTouchEvent(event);
-                int action = event.getAction();
-                if (action == MotionEvent.ACTION_DOWN) {
-                    float x = event.getX();
-                    float y = event.getY();
-                    int padding = 20;
-                    transferring = ViewUtils.isTouchPointInView(v, x - padding, y - padding)
-                            && ViewUtils.isTouchPointInView(v, x + padding, y + padding);
-                }
-                if (transferring) {
-                    mCircleView.onTouchEvent2(event);
-                }
-                return transferring;
-            }
-        });
-
-        View divider = root.findViewById(R.id.divider);
-        ViewGroup vg = (ViewGroup) divider.getParent();
-
-        int position = 0;
-        int length = vg.getChildCount();
-        for (int i = 0; i < length; i++) {
-            View child = vg.getChildAt(i);
-            assert child != null;
-
-            if (child.getId() == divider.getId()) {
-                position = i;
-                break;
-            }
-        }
-
-        boolean mirrored = mConfig.isMirroredTimeoutProgressBarEnabled();
-        mDividerView = inflater.inflate(mirrored
-                ? R.layout.acdisplay_progress_bar_mirrored
-                : R.layout.acdisplay_progress_bar, vg, false);
-        vg.removeViewAt(position);
-        vg.addView(mDividerView, position);
-        ProgressBar progressBar = (ProgressBar) mDividerView.findViewById(R.id.progress_bar);
-        if (mirrored) {
-            // Redirect all changes from the main progress bar
-            // to mirrored one.
-            final ProgressBar progressBarMirrored = (ProgressBar)
-                    root.findViewById(R.id.progress_bar_mirrored);
-            progressBar.setOnProgressChangeListener(new ProgressBar.OnProgressChangeListener() {
-
-                @Override
-                public void onProgressChanged(ProgressBar progressBar, int progress) {
-                    progressBarMirrored.setProgress(progress);
-                }
-
-                @Override
-                public void onMaxChanged(ProgressBar progressBar, int max) {
-                    progressBarMirrored.setMax(max);
-                }
-            });
-        }
-        mTimeoutGui = new Timeout.Gui(progressBar);
-        mTimeout.registerListener(mTimeoutGui);
-
-        mCircleView = (CircleView) root.findViewById(R.id.circle);
-        mCircleView.setCallback(this);
-
-        mMediaWidget = new MediaWidget(this, this);
-        mMediaWidget.onCreate();
-        ViewGroup sceneContainer = getSceneContainer();
-        ViewGroup sceneMainMusic = mMediaWidget.createView(inflater, sceneContainer, null);
-        mSceneMainMedia = new SceneCompat(sceneContainer, sceneMainMusic);
-
-        return root;
-    }
-
-    @Override
-    public void onDestroyView() {
-        mMediaWidget.onDestroy();
-        mTimeout.unregisterListener(mTimeoutGui);
-        super.onDestroyView();
-    }
-
-    @Override
-    public void onDetach() {
-        mMediaController.unregisterListener(this);
-        super.onDetach();
-    }
-
-    @Override
-    public void onCircleEvent(float radius, float ratio, int event) {
-        switch (event) {
-            case CircleView.ACTION_START:
-                if (hasPinnedWidget()) {
-                    resetScene();
-                }
-
-                mTimeout.setTimeoutDelayed(mConfig.getTimeoutShort());
-                mTimeout.pause();
-                break;
-            case CircleView.ACTION_UNLOCK_START:
-                mActivity.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
-                break;
-            case CircleView.ACTION_UNLOCK_CANCEL:
-                mActivity.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
-                break;
-            case CircleView.ACTION_UNLOCK:
-                mActivity.unlock(null);
-            case CircleView.ACTION_CANCELED:
-                mTimeout.resume();
-
-                int delta = (int) (2200 - mTimeout.getRemainingTime());
-                if (delta > 0) {
-                    mTimeout.delay(delta);
-                }
-                break;
-        }
-    }
-
-    public MediaController getCustomMediaController() {
-        return mActivity.getCustomMediaController();
-    }
-
-    /**
-     *
-     */
-    @Override
-    public void unlock(Runnable runnable, boolean pendingFinish) {
-        mActivity.unlockWithPendingFinish(runnable);
-    }
-
-    /**
-     * Updates dynamic background as requested by widget.
-     */
-    @Override
-    public void requestBackgroundUpdate(Widget widget) {
-        // Allow changing background to current widget only.
-        if (isCurrentWidget(widget)) {
-            mActivity.dispatchSetBackground(
-                    widget.getBackground(),
-                    widget.getBackgroundMask());
-        }
-    }
-
-    /**
-     * Restarts timeout to {@link com.achep.acdisplay.Config#getTimeoutShort()}
-     * as requested by widget.
-     */
-    @Override
-    public void requestTimeoutRestart(Widget widget) {
-        if (isCurrentWidget(widget)) {
-            mTimeout.setTimeoutDelayed(mConfig.getTimeoutShort(), true);
-        }
-    }
-
-    @Override
-    protected void showWidget(Widget widget) {
-        super.showWidget(widget);
-
-        // Add support for dynamic background
-        if (widget == null) {
-            mActivity.dispatchClearBackground();
-        } else {
-            mActivity.dispatchSetBackground(
-                    widget.getBackground(),
-                    widget.getBackgroundMask());
-        }
-
-        // Start timeout on main or media widgets, and
-        // pause it otherwise.
-        if (widget == null || widget == mMediaWidget) {
-            mTimeout.resume();
-        } else {
-            mTimeout.setTimeoutDelayed(mConfig.getTimeoutNormal(), true);
-            mTimeout.pause();
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    protected void onWidgetDismiss(Widget widget) {
-        boolean lock = false;
-
-        // Option: Screen off on dismiss last notification.
-        if (mConfig.isScreenOffAfterLastNotify() && widget instanceof NotifyWidget) {
-            NotificationPresenter np = NotificationPresenter.getInstance();
-            lock = np.getList().size() <= 1;
-        }
-
-        super.onWidgetDismiss(widget);
-
-        if (lock) {
-            mActivity.lock();
-        }
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public void onMediaChanged(MediaController controller, int event) {
-        switch (event) {
-            case MediaController.EVENT_UISTATE_CHANGED:
-                updateUiState(controller.getUiState());
-                break;
-        }
-    }
-
-    /**
-     * Shows or hides media widget.
-     *
-     * @see #isUiStateMedia()
-     */
-    private void updateUiState(int currentUiState) {
-        Widget currentWidget = getCurrentWidget();
-        switch (currentUiState) {
-            case MediaController.UISTATE_MUSIC:
-                if (currentWidget == null) {
-                    showWidget(mMediaWidget);
-                }
-                break;
-            case MediaController.UISTATE_NORMAL:
-                if (currentWidget == mMediaWidget) {
-                    showMainWidget();
-                }
-                break;
-        }
-    }
-
-    /**
-     * @return {@code true} is media widget may be shown, {@code false} otherwise.
-     * @see com.achep.acdisplay.services.media.MediaController#getUiState()
-     */
-    private boolean isUiStateMedia() {
-        int state = mMediaController.getUiState();
-        return state == MediaController.UISTATE_MUSIC;
-    }
-
-    @Override
-    public void showMainWidget() {
-        if (isUiStateMedia()) {
-            showWidget(mMediaWidget);
-            return;
-        }
-
-        super.showMainWidget();
-    }
-
-    @Override
-    protected Widget getFirstWidget() {
-        return isUiStateMedia() ? mMediaWidget : super.getFirstWidget();
-    }
-
-    @Override
-    protected SceneCompat findSceneByWidget(Widget widget) {
-        // Manually add media widget's scene
-        return widget == mMediaWidget ? mSceneMainMedia : super.findSceneByWidget(widget);
-    }
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/acdisplay/BackgroundFactoryThread.java b/project/app/src/main/java/com/achep/acdisplay/acdisplay/BackgroundFactoryThread.java
deleted file mode 100644
index 856ae790..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/acdisplay/BackgroundFactoryThread.java
+++ /dev/null
@@ -1,87 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-package com.achep.acdisplay.acdisplay;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.os.SystemClock;
-import android.util.Log;
-
-import com.achep.acdisplay.AsyncTask;
-import com.achep.acdisplay.Build;
-import com.achep.acdisplay.R;
-import com.achep.acdisplay.utils.BitmapUtils;
-
-/**
- * Factory to prepare your background for
- * {@link com.achep.acdisplay.acdisplay.AcDisplayActivity#dispatchSetBackground(android.graphics.Bitmap)}.
- */
-public class BackgroundFactoryThread extends AsyncTask<Void, Void, Bitmap> {
-
-    private static final String TAG = "DynamicBackgroundFactory";
-
-    public interface Callback {
-        void onBackgroundCreated(Bitmap bitmap);
-    }
-
-    private final int mForegroundColor;
-    private final Bitmap mBitmapOriginal;
-    private final Callback mCallback;
-
-    public BackgroundFactoryThread(Context context, Bitmap original, Callback callback) {
-        mForegroundColor = context.getResources().getColor(R.color.keyguard_background_semi);
-        mBitmapOriginal = original;
-        mCallback = callback;
-
-        if (original == null) throw new IllegalArgumentException("Bitmap may not be null!");
-        if (callback == null) throw new IllegalArgumentException("Callback may not be null!");
-    }
-
-    @Override
-    protected Bitmap doInBackground(Void... params) {
-        final long start = SystemClock.elapsedRealtime();
-
-        Bitmap origin = mBitmapOriginal;
-        Bitmap bitmap = BitmapUtils.doBlur(origin, 3, false);
-
-        if (isCancelled()) {
-            return null;
-        }
-
-        Canvas canvas = new Canvas(bitmap);
-        canvas.drawColor(mForegroundColor);
-
-        if (Build.DEBUG) {
-            long delta = SystemClock.elapsedRealtime() - start;
-            Log.d(TAG, "Dynamic background created in " + delta + " millis:"
-                    + " width=" + bitmap.getWidth()
-                    + " height=" + bitmap.getHeight());
-        }
-
-        return bitmap;
-    }
-
-    @Override
-    protected void onPostExecute(Bitmap bitmap) {
-        super.onPostExecute(bitmap);
-        mCallback.onBackgroundCreated(bitmap);
-    }
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/acdisplay/components/MediaWidget.java b/project/app/src/main/java/com/achep/acdisplay/acdisplay/components/MediaWidget.java
deleted file mode 100644
index 22fd57a9..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/acdisplay/components/MediaWidget.java
+++ /dev/null
@@ -1,239 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-package com.achep.acdisplay.acdisplay.components;
-
-import android.content.Context;
-import android.graphics.Bitmap;
-import android.media.RemoteControlClient;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.view.KeyEvent;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ImageButton;
-import android.widget.ImageView;
-import android.widget.TextView;
-
-import com.achep.acdisplay.AsyncTask;
-import com.achep.acdisplay.Config;
-import com.achep.acdisplay.R;
-import com.achep.acdisplay.acdisplay.AcDisplayFragment2;
-import com.achep.acdisplay.acdisplay.BackgroundFactoryThread;
-import com.achep.acdisplay.services.media.MediaController;
-import com.achep.acdisplay.services.media.Metadata;
-import com.achep.acdisplay.utils.ViewUtils;
-
-/**
- * Created by Artem on 02.04.2014.
- */
-public class MediaWidget extends Widget implements
-        MediaController.MediaListener,
-        View.OnClickListener,
-        View.OnLongClickListener {
-
-    private final MediaController mMediaController;
-
-    private ImageView mArtwork;
-    private TextView mTrack;
-    private TextView mArtist;
-    private ImageButton mButtonPrevious;
-    private ImageButton mButtonPlayPause;
-    private ImageButton mButtonNext;
-
-    private Bitmap mArtworkOrigin;
-    private Bitmap mArtworkBlurred;
-
-    private BackgroundFactoryThread mBlurThread;
-    private final BackgroundFactoryThread.Callback mBlurThreadCallback = new BackgroundFactoryThread.Callback() {
-        @Override
-        public void onBackgroundCreated(Bitmap bitmap) {
-            mArtworkBlurred = bitmap;
-            populateBackground();
-        }
-    };
-
-    public MediaWidget(@NonNull Callback callback, @NonNull AcDisplayFragment2 fragment) {
-        super(callback, fragment);
-        mMediaController = fragment.getCustomMediaController();
-    }
-
-    @Override
-    public void onCreate() {
-        super.onCreate();
-        mMediaController.registerListener(this);
-    }
-
-    @Override
-    public void onDestroy() {
-        super.onDestroy();
-        mMediaController.unregisterListener(this);
-    }
-
-    @Override
-    public void onMediaChanged(@NonNull MediaController controller, int event) {
-        switch (event) {
-            case MediaController.EVENT_METADATA_CHANGED:
-                updateMetadata(controller.getMetadata());
-                break;
-            case MediaController.EVENT_PLAYSTATE_CHANGED:
-                updatePlayState(controller.getPlayState());
-                break;
-        }
-    }
-
-    private void updateMetadata(@NonNull Metadata metadata) {
-        if (mArtworkOrigin == null || !mArtworkOrigin.sameAs(metadata.bitmap)) {
-            mArtworkOrigin = metadata.bitmap;
-
-            AsyncTask.stop(mBlurThread);
-            if (metadata.bitmap != null) {
-                Context context = getHostFragment().getActivity();
-                mBlurThread = new BackgroundFactoryThread(context, metadata.bitmap, mBlurThreadCallback);
-                mBlurThread.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
-            } else {
-                mArtworkBlurred = null;
-                populateBackground();
-            }
-        }
-
-        populateMetadata();
-    }
-
-    private void updatePlayState(int currentPlayState) {
-        final int imageResId;
-        final int imageDescId;
-        switch (currentPlayState) {
-            case RemoteControlClient.PLAYSTATE_ERROR:
-                imageResId = android.R.drawable.stat_sys_warning;
-                imageDescId = R.string.media_play_description;
-                break;
-            case RemoteControlClient.PLAYSTATE_PLAYING:
-                imageResId = R.drawable.ic_media_pause;
-                imageDescId = R.string.media_pause_description;
-                break;
-            case RemoteControlClient.PLAYSTATE_BUFFERING:
-                imageResId = R.drawable.ic_media_stop;
-                imageDescId = R.string.media_stop_description;
-                break;
-            case RemoteControlClient.PLAYSTATE_PAUSED:
-            default:
-                imageResId = R.drawable.ic_media_play;
-                imageDescId = R.string.media_play_description;
-                break;
-        }
-
-        mButtonPlayPause.setImageResource(imageResId);
-        mButtonPlayPause.setContentDescription(getHostFragment().getString(imageDescId));
-    }
-
-    /**
-     * Updates the content of the view to latest metadata
-     * provided by {@link com.achep.acdisplay.services.media.MediaController#getMetadata()}.
-     */
-    private void populateMetadata() {
-        Metadata metadata = mMediaController.getMetadata();
-        ViewUtils.safelySetText(mTrack, metadata.trackTitle);
-        ViewUtils.safelySetText(mArtist, metadata.artist);
-
-        if (mArtwork != null) {
-            mArtwork.setImageBitmap(metadata.bitmap);
-        }
-    }
-
-    /**
-     * Requests host to update dynamic background.
-     *
-     * @see #getBackground()
-     * @see #getBackgroundMask()
-     */
-    private void populateBackground() {
-        mCallback.requestBackgroundUpdate(this);
-    }
-
-    @Nullable
-    @Override
-    public Bitmap getBackground() {
-        return mArtworkBlurred;
-    }
-
-    @Override
-    public int getBackgroundMask() {
-        return Config.DYNAMIC_BG_ARTWORK_MASK;
-    }
-
-    @Override
-    protected ViewGroup onCreateView(
-            @NonNull LayoutInflater inflater,
-            @NonNull ViewGroup container,
-            @Nullable ViewGroup sceneView) {
-        boolean initialize = sceneView == null;
-        if (initialize) {
-            sceneView = (ViewGroup) inflater.inflate(R.layout.acdisplay_scene_music, container, false);
-            assert sceneView != null;
-        }
-
-        mArtwork = (ImageView) sceneView.findViewById(R.id.artwork);
-        mTrack = (TextView) sceneView.findViewById(R.id.track);
-        mArtist = (TextView) sceneView.findViewById(R.id.artist_album);
-        mButtonPrevious = (ImageButton) sceneView.findViewById(R.id.previous);
-        mButtonPlayPause = (ImageButton) sceneView.findViewById(R.id.play);
-        mButtonNext = (ImageButton) sceneView.findViewById(R.id.next);
-
-        if (!initialize) {
-            return sceneView;
-        }
-
-        mButtonPrevious.setOnClickListener(this);
-        mButtonPlayPause.setOnClickListener(this);
-        mButtonPlayPause.setOnLongClickListener(this);
-        mButtonNext.setOnClickListener(this);
-
-        return sceneView;
-    }
-
-    @Override
-    public void onClick(@NonNull View v) {
-        int keyCode;
-        if (v == mButtonPrevious) {
-            keyCode = KeyEvent.KEYCODE_MEDIA_PREVIOUS;
-        } else if (v == mButtonPlayPause) {
-            keyCode = KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE;
-        } else if (v == mButtonNext) {
-            keyCode = KeyEvent.KEYCODE_MEDIA_NEXT;
-        } else {
-            return;
-        }
-
-        mMediaController.sendMediaButtonClick(keyCode);
-        mCallback.requestTimeoutRestart(this);
-    }
-
-    @Override
-    public boolean onLongClick(@NonNull View v) {
-        if (v == mButtonPlayPause) {
-            mMediaController.sendMediaButtonClick(KeyEvent.KEYCODE_MEDIA_STOP);
-        } else {
-            return false;
-        }
-        mCallback.requestTimeoutRestart(this);
-        return true;
-    }
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/activities/KeyguardActivity.java b/project/app/src/main/java/com/achep/acdisplay/activities/KeyguardActivity.java
deleted file mode 100644
index 4fd94480..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/activities/KeyguardActivity.java
+++ /dev/null
@@ -1,290 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.acdisplay.activities;
-
-import android.app.Activity;
-import android.app.KeyguardManager;
-import android.app.admin.DevicePolicyManager;
-import android.content.BroadcastReceiver;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentFilter;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.SystemClock;
-import android.provider.Settings;
-import android.util.Log;
-import android.view.MotionEvent;
-import android.view.WindowManager;
-
-import com.achep.acdisplay.App;
-import com.achep.acdisplay.Build;
-import com.achep.acdisplay.Config;
-import com.achep.acdisplay.R;
-
-
-/**
- * Activity that contains some methods to emulate system keyguard.
- */
-public abstract class KeyguardActivity extends Activity {
-
-    private static final String TAG = "KeyguardActivity";
-
-    public static final String EXTRA_TURN_SCREEN_ON = "turn_screen_on";
-    public static final String EXTRA_FINISH_ON_SCREEN_OFF = "finish_on_screen_off";
-
-    private static final int UNLOCKING_MAX_TIME = 150;
-
-    private BroadcastReceiver mScreenOffReceiver;
-
-    private long mPendingFinishStartTime;
-    private int mPendingFinishMax;
-
-    private int mSystemScreenOffTimeout;
-    private boolean mSystemScreenOffTimeoutChanged;
-
-    @Override
-    public void onWindowFocusChanged(boolean hasFocus) {
-        super.onWindowFocusChanged(hasFocus);
-
-        if (!hasFocus) {
-            long now = SystemClock.elapsedRealtime();
-            long elapsedTime = now - mPendingFinishStartTime;
-            if (elapsedTime < mPendingFinishMax) {
-                finish();
-            }
-        }
-    }
-
-    @Override
-    public boolean dispatchTouchEvent(MotionEvent ev) {
-        if (ev.getActionMasked() == MotionEvent.ACTION_DOWN) {
-            mPendingFinishStartTime -= 500;
-        }
-        return super.dispatchTouchEvent(ev);
-    }
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-
-        getWindow().addFlags(
-                // Show activity above the system keyguard.
-                WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED |
-                // Allow ignoring random presses.
-                WindowManager.LayoutParams.FLAG_IGNORE_CHEEK_PRESSES);
-
-        if (getIntent() != null) {
-            Intent intent = getIntent();
-
-            // Registers a receiver to finish activity when screen goes off. 
-            if (intent.getBooleanExtra(EXTRA_FINISH_ON_SCREEN_OFF, false))
-                registerScreenOffReceiver();
-
-            // Turns screen on.
-            if (intent.getBooleanExtra(EXTRA_TURN_SCREEN_ON, false))
-                getWindow().addFlags(WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON);
-        }
-
-        mPendingFinishMax = getResources().getInteger(R.integer.config_maxPendingFinishDelayMillis);
-    }
-
-    @Override
-    protected void onDestroy() {
-        unregisterScreenOffReceiver();
-        super.onDestroy();
-    }
-
-    /**
-     * Registers a receiver to finish activity when screen goes off. 
-     * You will need to {@link #unregisterScreenOffReceiver() unregister} it
-     * later.
-     *
-     * @see #unregisterScreenOffReceiver()
-     */
-    private void registerScreenOffReceiver() {
-        mScreenOffReceiver = new BroadcastReceiver() {
-
-            @Override
-            public void onReceive(Context context, Intent intent) {
-                // Avoid of blocking this event.
-                // TODO: Double-check that #finish() is always run.
-                new Handler().post(new Runnable() {
-
-                    @Override
-                    public void run() {
-                        KeyguardActivity.this.finish();
-                    }
-                });
-            }
-        };
-
-        IntentFilter intentFilter = new IntentFilter(Intent.ACTION_SCREEN_OFF);
-        intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY - 1); // max allowed priority
-        registerReceiver(mScreenOffReceiver, intentFilter);
-    }
-
-    /**
-     * Unregisters screen off receiver if it was registered previuosly.
-     *
-     * @see #registerScreenOffReceiver()
-     */
-    private void unregisterScreenOffReceiver() {
-        if (mScreenOffReceiver != null) {
-            unregisterReceiver(mScreenOffReceiver);
-            mScreenOffReceiver = null;
-        }        
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-        overrideHomePress(true);
-
-        // Read system screen off timeout setting.
-        try {
-            mSystemScreenOffTimeout = Settings.System.getInt(
-                    getContentResolver(),
-                    Settings.System.SCREEN_OFF_TIMEOUT);
-        } catch (Settings.SettingNotFoundException e) {
-            mSystemScreenOffTimeout = -1;
-        }
-        if (Build.DEBUG) Log.d(TAG, "system_screen_off_timeout=" + mSystemScreenOffTimeout);
-
-        getWindow().clearFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
-    }
-
-    @Override
-    protected void onPause() {
-        super.onPause();
-        overrideHomePress(false);
-
-        // Put previously read timeout setting.
-//        if (mSystemScreenOffTimeout != -1 && mSystemScreenOffTimeoutChanged) {
-//            Settings.System.putInt(
-//                    getContentResolver(),
-//                    Settings.System.SCREEN_OFF_TIMEOUT,
-//                    mSystemScreenOffTimeout);
-//        }
-    }
-
-    /**
-     * Notifies Xposed module to start ignoring home button press.
-     * Please, notice that it will ignore home button click everywhere
-     * until you call {@code overrideHomePress(false)}
-     *
-     * @param override {@code true} to start ignoring, {@code false} to stop.
-     * @see com.achep.acdisplay.xposed.OverrideHomeButton
-     * @see #sendBroadcast(android.content.Intent)
-     */
-    private void overrideHomePress(boolean override) {
-        Intent intent = new Intent(override
-                ? App.ACTION_EAT_HOME_PRESS_START
-                : App.ACTION_EAT_HOME_PRESS_STOP);
-        sendBroadcast(intent);
-    }
-
-    /**
-     * Locks the device (and turns screen off).
-     *
-     * @return {@code true} if successful, {@code false} otherwise.
-     * @see DevicePolicyManager#lockNow()
-     */
-    public boolean lock() {
-        DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
-        try {
-            // TODO: Respect secure lockscreen timeout settings.
-            dpm.lockNow();
-
-            // Experimental
-//            mSystemScreenOffTimeoutChanged = true;
-//            Settings.System.putInt(
-//                    getContentResolver(),
-//                    Settings.System.SCREEN_OFF_TIMEOUT,
-//                    1000);
-            return true;
-        } catch (SecurityException e) {
-            return false; // User didn't make us an admin.
-        }
-    }
-
-    /**
-     * Unlocks keyguard and runs {@link Runnable runnable} when unlocked.
-     */
-    public void unlock(Runnable runnable) {
-        unlock(runnable, true);
-    }
-
-    public void unlockWithPendingFinish(Runnable runnable) {
-        mPendingFinishStartTime = SystemClock.elapsedRealtime();
-        unlock(runnable, false);
-    }
-
-    /**
-     * Unlocks keyguard and runs {@link Runnable runnable} when unlocked.
-     *
-     * @param finish {@code true} to finish activity, {@code false} to keep it
-     * @see #unlock(Runnable)
-     * @see #unlockWithPendingFinish(Runnable)
-     */
-    public void unlock(final Runnable runnable, final boolean finish) {
-        if (Build.DEBUG) Log.d(TAG, "Unlocking with params: finish=" + finish);
-
-        getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
-
-        // If keyguard is disabled no need to make
-        // a delay between calling this method and
-        // unlocking.
-        // Otherwise we need this delay to get new
-        // flags applied.
-        final KeyguardManager km = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);
-        final long now = SystemClock.elapsedRealtime();
-
-        final Handler handler = new Handler();
-        handler.post(new Runnable() {
-
-            @Override
-            public void run() {
-                // Loop until flag gets applied.
-                // TODO: Use somewhat trigger for detecting unlocking.
-                int delta = (int) (SystemClock.elapsedRealtime() - now);
-                if (km.isKeyguardLocked() && !km.isKeyguardSecure()
-                        && delta < UNLOCKING_MAX_TIME) {
-                    handler.postDelayed(this, 16);
-                    return;
-                }
-
-                if (runnable != null) runnable.run();
-                if (finish) {
-                    finish();
-
-                    if (Config.getInstance().isUnlockAnimationEnabled()) {
-                        overridePendingTransition(0, R.anim.activity_unlock);
-                    } else {
-                        overridePendingTransition(0, 0);
-                    }
-                }
-            }
-        });
-    }
-
-    @Override
-    public void onBackPressed() { /* override back button */ }
-
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/activities/MainActivity.java b/project/app/src/main/java/com/achep/acdisplay/activities/MainActivity.java
deleted file mode 100644
index e6a39c81..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/activities/MainActivity.java
+++ /dev/null
@@ -1,342 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.acdisplay.activities;
-
-import android.app.Activity;
-import android.app.Fragment;
-import android.app.FragmentManager;
-import android.app.Notification;
-import android.app.NotificationManager;
-import android.app.PendingIntent;
-import android.app.admin.DevicePolicyManager;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.graphics.BitmapFactory;
-import android.graphics.Typeface;
-import android.media.RingtoneManager;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.PowerManager;
-import android.text.Html;
-import android.text.SpannableStringBuilder;
-import android.text.style.StyleSpan;
-import android.util.Log;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.widget.CompoundButton;
-import android.widget.ImageView;
-import android.widget.Switch;
-
-import com.achep.acdisplay.App;
-import com.achep.acdisplay.Build;
-import com.achep.acdisplay.Config;
-import com.achep.acdisplay.Device;
-import com.achep.acdisplay.DialogHelper;
-import com.achep.acdisplay.R;
-import com.achep.acdisplay.acdisplay.AcDisplayActivity;
-import com.achep.acdisplay.fragments.AboutDialog;
-import com.achep.acdisplay.iab.DonationFragment;
-import com.achep.acdisplay.settings.Settings;
-import com.achep.acdisplay.utils.AccessUtils;
-import com.achep.acdisplay.utils.PackageUtils;
-import com.achep.acdisplay.utils.ToastUtils;
-import com.achep.acdisplay.utils.ViewUtils;
-
-/**
- * Created by Artem on 21.01.14.
- */
-public class MainActivity extends Activity implements Config.OnConfigChangedListener {
-
-    private static final String TAG = "MainActivity";
-
-    private static final boolean DEBUG_DIALOGS = Build.DEBUG && false;
-    private static final boolean DEBUG_COMPAT_TOAST = Build.DEBUG && false;
-
-    private Switch mSwitch;
-    private ImageView mSwitchAlertView;
-
-    private Config mConfig;
-    private boolean mBroadcasting;
-
-    private MenuItem mSendTestNotificationMenuItem;
-
-    @Override
-    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-
-        // Transfer in-app-billing service's events to
-        // its fragment.
-        if (requestCode == DonationFragment.RC_REQUEST) {
-            FragmentManager fm = getFragmentManager();
-            Fragment fragment = fm.findFragmentByTag(DialogHelper.TAG_FRAGMENT_DONATION);
-            if (fragment instanceof DonationFragment) {
-                fragment.onActivityResult(requestCode, resultCode, data);
-                return;
-            }
-        }
-
-        super.onActivityResult(requestCode, resultCode, data);
-    }
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        setContentView(R.layout.main);
-
-        mConfig = Config.getInstance();
-        mConfig.registerListener(this);
-
-        getActionBar().setDisplayShowCustomEnabled(true);
-        getActionBar().setCustomView(R.layout.layout_ab_switch2);
-        mSwitchAlertView = (ImageView) getActionBar().getCustomView().findViewById(R.id.icon);
-        mSwitchAlertView.setImageResource(R.drawable.ic_action_warning);
-        mSwitch = (Switch) getActionBar().getCustomView().findViewById(R.id.switch_);
-        mSwitch.setChecked(mConfig.isEnabled());
-        mSwitch.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
-
-            @Override
-            public void onCheckedChanged(CompoundButton compoundButton, boolean b) {
-                updateSendTestNotificationMenuItem();
-                if (mBroadcasting) {
-                    return;
-                }
-
-                Activity activity = MainActivity.this;
-
-                if (b && !AccessUtils.hasAllRights(activity)) {
-                    // Reset compound button and update
-                    // testing menu item.
-                    compoundButton.setChecked(false);
-                    updateSendTestNotificationMenuItem();
-
-                    // Show permission dialog.
-                    DialogHelper.showSetupPermissionsDialog(activity);
-                } else {
-                    boolean successfully = mConfig.setEnabled(activity, b, MainActivity.this);
-                    if (!successfully) {
-
-                        // Setting option failed, so we need to
-                        // sync switch with config.
-                        compoundButton.setChecked(mConfig.isEnabled());
-                        updateSendTestNotificationMenuItem();
-                    } else if (b && (!Device.hasKitKatApi() || DEBUG_COMPAT_TOAST)) {
-                        String formatter = getString(R.string.compat_formatter);
-
-                        SpannableStringBuilder builder = new SpannableStringBuilder();
-                        builder.append(getString(R.string.compat_title));
-                        builder.setSpan(new StyleSpan(Typeface.BOLD), 0, builder.length(), 0);
-                        builder.append('\n');
-
-                        if (!Device.hasJellyBeanMR2Api() || DEBUG_COMPAT_TOAST) {
-                            builder.append(String.format(formatter,
-                                    getString(R.string.compat_notifications)));
-                        }
-
-                        if (!Device.hasKitKatApi() || DEBUG_COMPAT_TOAST) {
-                            builder.append(String.format(formatter,
-                                    getString(R.string.compat_immersive_mode)));
-                            builder.append(String.format(formatter,
-                                    getString(R.string.compat_music_widget)));
-                        }
-
-                        builder.delete(builder.length() - 1, builder.length());
-                        ToastUtils.showLong(activity, builder);
-                    }
-                }
-            }
-        });
-
-        try {
-            PackageInfo pi = getPackageManager().getPackageInfo(PackageUtils.getName(this), 0);
-            Config.Triggers triggers = mConfig.getTriggers();
-
-            int oldVersionCode = triggers.getPreviousVersion();
-            if (oldVersionCode < pi.versionCode || DEBUG_DIALOGS) {
-                triggers.setPreviousVersion(this, pi.versionCode, null);
-
-                if (oldVersionCode < 15 /* v2.0- */ || DEBUG_DIALOGS) {
-                    showAlertSpeech();
-                }
-
-                if (oldVersionCode < 20 /* v2.2.1- */ || DEBUG_DIALOGS) {
-                    showAlertWelcome();
-                }
-            }
-        } catch (PackageManager.NameNotFoundException e) {
-            Log.wtf(TAG, "Failed to find my PackageInfo.");
-        }
-    }
-
-    private void showAlertSpeech() {
-        showSimpleDialog(
-                R.drawable.ic_dialog_me,
-                getString(R.string.speech_title),
-                Html.fromHtml(getString(R.string.speech_message)));
-    }
-
-    private void showAlertWelcome() {
-        showSimpleDialog(
-                R.mipmap.ic_launcher,
-                AboutDialog.getVersionName(this),
-                Html.fromHtml(getString(R.string.news_message)));
-    }
-
-    private void showSimpleDialog(int iconRes, CharSequence title, CharSequence message) {
-        new DialogHelper.Builder(this)
-                .setIcon(iconRes)
-                .setTitle(title)
-                .setMessage(message)
-                .wrap()
-                .setPositiveButton(android.R.string.ok, null)
-                .create()
-                .show();
-    }
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-
-        boolean hasAllRights = AccessUtils.hasAllRights(this);
-        mSwitch.setChecked(mSwitch.isChecked() && hasAllRights);
-        ViewUtils.setVisible(mSwitchAlertView, !hasAllRights);
-    }
-
-    private void updateSendTestNotificationMenuItem() {
-        if (mSendTestNotificationMenuItem != null) {
-            mSendTestNotificationMenuItem.setVisible(mSwitch.isChecked());
-        }
-    }
-
-    @Override
-    protected void onDestroy() {
-        super.onDestroy();
-        mConfig.unregisterListener(this);
-    }
-
-    @Override
-    public void onConfigChanged(Config config, String key, Object value) {
-        if (mBroadcasting) {
-            return;
-        }
-
-        switch (key) {
-            case Config.KEY_ENABLED:
-                mBroadcasting = true;
-                mSwitch.setChecked((Boolean) value);
-                mBroadcasting = false;
-                break;
-        }
-    }
-
-    @Override
-    public boolean onCreateOptionsMenu(Menu menu) {
-        getMenuInflater().inflate(R.menu.main, menu);
-
-        mSendTestNotificationMenuItem = menu.findItem(R.id.action_test);
-        updateSendTestNotificationMenuItem();
-        return true;
-    }
-
-    @Override
-    public boolean onMenuItemSelected(int featureId, MenuItem item) {
-        switch (item.getItemId()) {
-            case R.id.action_settings:
-                startActivity(new Intent(this, Settings.class));
-                break;
-            case R.id.action_test:
-                startAcDisplayTest(Build.DEBUG);
-                break;
-            case R.id.action_donate:
-                DialogHelper.showDonateDialog(this);
-                break;
-            case R.id.action_feedback:
-                DialogHelper.showFeedbackDialog(this);
-                break;
-            case R.id.action_about:
-                DialogHelper.showAboutDialog(this);
-                break;
-            case R.id.action_help:
-                DialogHelper.showHelpDialog(this);
-                break;
-            default:
-                return super.onMenuItemSelected(featureId, item);
-        }
-        return true;
-    }
-
-    /**
-     * Turns screen off and sends a test notification.
-     *
-     * @param fake {@code true} if it simply starts {@link AcDisplayActivity},
-     *             {@code false} if it uses notification
-     */
-    private void startAcDisplayTest(boolean fake) {
-        if (fake) {
-            startActivity(new Intent(this, AcDisplayActivity.class));
-            sendTestNotification();
-            return;
-        }
-
-        int delay = getResources().getInteger(R.integer.config_test_notification_delay);
-
-        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
-        PowerManager.WakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "Test notification.");
-        wakeLock.acquire(delay);
-
-        try {
-            // Go sleep
-            DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
-            dpm.lockNow();
-
-            new Handler().postDelayed(new Runnable() {
-                @Override
-                public void run() {
-                    sendTestNotification();
-                }
-            }, delay);
-        } catch (SecurityException e) {
-            Log.wtf(TAG, "Failed to turn screen off");
-
-            wakeLock.release();
-        }
-    }
-
-    private void sendTestNotification() {
-        int notificationId = App.ID_NOTIFY_TEST;
-        PendingIntent pendingIntent = PendingIntent.getActivity(MainActivity.this,
-                notificationId, new Intent(MainActivity.this, MainActivity.class),
-                PendingIntent.FLAG_UPDATE_CURRENT);
-        Notification.Builder builder = new Notification.Builder(MainActivity.this)
-                .setContentTitle(getString(R.string.app_name))
-                .setContentText(getString(R.string.test_notification_message))
-                .setContentIntent(pendingIntent)
-                .setLargeIcon(BitmapFactory.decodeResource(getResources(), R.mipmap.ic_launcher))
-                .setSmallIcon(R.drawable.stat_test)
-                .setPriority(Notification.PRIORITY_HIGH)
-                .setAutoCancel(true)
-                .setStyle(new Notification.BigTextStyle()
-                        .bigText(getString(R.string.test_notification_message_large)))
-                .setSound(RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION));
-
-        NotificationManager nm = (NotificationManager) getSystemService(Context.NOTIFICATION_SERVICE);
-        nm.notify(notificationId, builder.build());
-    }
-
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/blacklist/AppConfig.java b/project/app/src/main/java/com/achep/acdisplay/blacklist/AppConfig.java
index 9b2cfc2a..92c77bcc 100644
--- a/project/app/src/main/java/com/achep/acdisplay/blacklist/AppConfig.java
+++ b/project/app/src/main/java/com/achep/acdisplay/blacklist/AppConfig.java
@@ -19,8 +19,11 @@
 package com.achep.acdisplay.blacklist;
 
 import android.content.SharedPreferences;
+import android.support.annotation.NonNull;
 import android.util.Log;
 
+import com.achep.base.content.SharedList;
+
 import org.apache.commons.lang.builder.EqualsBuilder;
 import org.apache.commons.lang.builder.HashCodeBuilder;
 
@@ -158,7 +161,6 @@ public class AppConfig {
     /**
      * @return {@code true} if showing non-clearable notifications is allowed for
      * this app, {@code false} otherwise.
-     *
      * @see #setNonClearableEnabled(boolean)
      * @see #DEFAULT_NON_CLEARABLE
      * @see #DIFF_NON_CLEARABLE
@@ -186,7 +188,7 @@ public class AppConfig {
      *
      * @author Artem Chepurnoy
      */
-    static final class Saver extends com.achep.acdisplay.SharedList.Saver<AppConfig> {
+    static final class Saver extends SharedList.Saver<AppConfig> {
 
         private static final String KEY_PACKAGE = "package_name_";
         private static final String KEY_RESTRICTED = "restricted_";
@@ -196,8 +198,11 @@ public class AppConfig {
         /**
          * {@inheritDoc}
          */
+        @NonNull
         @Override
-        public SharedPreferences.Editor put(AppConfig ps, SharedPreferences.Editor editor, int position) {
+        public SharedPreferences.Editor put(@NonNull AppConfig ps,
+                                            @NonNull SharedPreferences.Editor editor,
+                                            int position) {
             editor.putString(KEY_PACKAGE + position, ps.packageName);
             editor.putBoolean(KEY_RESTRICTED + position, ps.isRestricted());
             editor.putBoolean(KEY_HIDDEN + position, ps.isHidden());
@@ -209,7 +214,7 @@ public class AppConfig {
          * {@inheritDoc}
          */
         @Override
-        public AppConfig get(SharedPreferences prefs, int position) {
+        public AppConfig get(@NonNull SharedPreferences prefs, int position) {
             String pkg = prefs.getString(KEY_PACKAGE + position, null);
             boolean restricted = prefs.getBoolean(KEY_RESTRICTED + position, DEFAULT_RESTRICTED);
             boolean hidden = prefs.getBoolean(KEY_HIDDEN + position, DEFAULT_HIDDEN);
@@ -223,7 +228,7 @@ public class AppConfig {
      *
      * @author Artem Chepurnoy
      */
-    static final class Comparator extends com.achep.acdisplay.SharedList.Comparator<AppConfig> {
+    static final class Comparator extends SharedList.Comparator<AppConfig> {
 
         /**
          * {@inheritDoc}
diff --git a/project/app/src/main/java/com/achep/acdisplay/blacklist/Blacklist.java b/project/app/src/main/java/com/achep/acdisplay/blacklist/Blacklist.java
index 3a869be4..0c9293f1 100644
--- a/project/app/src/main/java/com/achep/acdisplay/blacklist/Blacklist.java
+++ b/project/app/src/main/java/com/achep/acdisplay/blacklist/Blacklist.java
@@ -23,7 +23,7 @@ import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Log;
 
-import com.achep.acdisplay.SharedList;
+import com.achep.base.content.SharedList;
 
 /**
  * The blacklist (also known as per-app-features.)
@@ -93,16 +93,17 @@ public final class Blacklist extends SharedList<AppConfig, AppConfig.Saver> {
     /**
      * This is called on {@link com.achep.acdisplay.App#onCreate() App create}.
      *
-     * @see com.achep.acdisplay.SharedList#init(android.content.Context)
+     * @see com.achep.base.content.SharedList#init(android.content.Context)
      */
     @Override
-    public void init(Context context) {
+    public void init(@NonNull Context context) {
         super.init(context);
     }
 
     /**
      * {@inheritDoc}
      */
+    @NonNull
     @Override
     protected String getPreferencesFileName() {
         return PREF_NAME;
@@ -111,6 +112,7 @@ public final class Blacklist extends SharedList<AppConfig, AppConfig.Saver> {
     /**
      * {@inheritDoc}
      */
+    @NonNull
     @Override
     protected AppConfig.Saver onCreateSaver() {
         return new AppConfig.Saver();
@@ -128,7 +130,7 @@ public final class Blacklist extends SharedList<AppConfig, AppConfig.Saver> {
      * {@inheritDoc}
      */
     @Override
-    protected boolean isOverwriteAllowed(AppConfig object) {
+    protected boolean isOverwriteAllowed(@NonNull AppConfig object) {
         return true;
     }
 
@@ -163,7 +165,7 @@ public final class Blacklist extends SharedList<AppConfig, AppConfig.Saver> {
 
     @NonNull
     public AppConfig fill(@NonNull AppConfig config) {
-        for (AppConfig c : valuesSet()) {
+        for (AppConfig c : values()) {
             if (c.equals(config)) {
                 AppConfig.copy(c, config);
                 return config;
@@ -202,7 +204,7 @@ public final class Blacklist extends SharedList<AppConfig, AppConfig.Saver> {
      * {@inheritDoc}
      */
     @Override
-    protected final void notifyOnRemoved(AppConfig object, OnSharedListChangedListener l) {
+    protected final void notifyOnRemoved(@NonNull AppConfig object, OnSharedListChangedListener l) {
 
         // Change remove-event to event about putting
         // empty config to the list.
diff --git a/project/app/src/main/java/com/achep/acdisplay/blacklist/options/NonClearableOption.java b/project/app/src/main/java/com/achep/acdisplay/blacklist/options/NonClearableOption.java
index a97d6148..6f11c893 100644
--- a/project/app/src/main/java/com/achep/acdisplay/blacklist/options/NonClearableOption.java
+++ b/project/app/src/main/java/com/achep/acdisplay/blacklist/options/NonClearableOption.java
@@ -26,7 +26,7 @@ import com.achep.acdisplay.blacklist.AppConfig;
 import com.achep.acdisplay.blacklist.Blacklist;
 
 /**
- * An option for {@link com.achep.acdisplay.blacklist.fragments.BlacklistAppFragment app settings}
+ * An option for {@link com.achep.acdisplay.ui.fragments.BlacklistAppFragment app settings}
  * to allow enabling non-clearable notifications.
  *
  * @author Artem Chepurnoy
diff --git a/project/app/src/main/java/com/achep/acdisplay/blacklist/options/Option.java b/project/app/src/main/java/com/achep/acdisplay/blacklist/options/Option.java
index bc19d639..d5f0689f 100644
--- a/project/app/src/main/java/com/achep/acdisplay/blacklist/options/Option.java
+++ b/project/app/src/main/java/com/achep/acdisplay/blacklist/options/Option.java
@@ -23,9 +23,9 @@ import android.graphics.drawable.Drawable;
 import android.support.annotation.NonNull;
 import android.widget.CompoundButton;
 
-import com.achep.acdisplay.Operator;
 import com.achep.acdisplay.blacklist.AppConfig;
 import com.achep.acdisplay.blacklist.Blacklist;
+import com.achep.base.utils.Operator;
 
 /**
  * Created by Artem on 27.02.14.
@@ -41,9 +41,9 @@ public abstract class Option extends Blacklist.OnBlacklistChangedListener implem
     private boolean mBroadcasting;
 
     // ui
-    public Drawable icon;
-    public CharSequence title;
-    public CharSequence summary;
+    public final Drawable icon;
+    public final CharSequence title;
+    public final CharSequence summary;
 
     public Option(Context context, CompoundButton cb,
                   Blacklist blacklist, String packageName,
diff --git a/project/app/src/main/java/com/achep/acdisplay/compat/SceneCompat.java b/project/app/src/main/java/com/achep/acdisplay/compat/SceneCompat.java
index 7c12a2a9..5d77de76 100644
--- a/project/app/src/main/java/com/achep/acdisplay/compat/SceneCompat.java
+++ b/project/app/src/main/java/com/achep/acdisplay/compat/SceneCompat.java
@@ -16,46 +16,34 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
 package com.achep.acdisplay.compat;
 
-import android.annotation.SuppressLint;
-import android.transition.Scene;
+import android.transitions.everywhere.Scene;
+import android.view.View;
 import android.view.ViewGroup;
 
-import com.achep.acdisplay.Device;
-
 /**
  * This is a restricted {@link android.transition.Scene} compatibility
  * class for supporting Android 4.3 or below.
  *
  * @author Artem Chepurnoy
  */
-@SuppressLint("NewApi")
 public class SceneCompat {
 
-    private final ViewGroup mViewGroup;
     private final ViewGroup mView;
-    public Scene scene;
+    private final Scene mScene;
 
-    public SceneCompat(ViewGroup viewGroup, ViewGroup view) {
-        if (Device.hasKitKatApi()) {
-            scene = new Scene(viewGroup, view);
-        }
-        mViewGroup = viewGroup;
+    public SceneCompat(ViewGroup parent, ViewGroup view) {
+        mScene = new Scene(parent, (View) view);
         mView = view;
     }
 
-    public void enter() {
-        if (Device.hasKitKatApi()) {
-            scene.enter();
-        } else {
-            mViewGroup.removeAllViews();
-            mViewGroup.addView(mView);
-        }
+    public Scene getScene() {
+        return mScene;
     }
 
     public ViewGroup getView() {
         return mView;
     }
+
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/compat/TransitionManager.java b/project/app/src/main/java/com/achep/acdisplay/compat/TransitionManager.java
deleted file mode 100644
index 1f1b9528..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/compat/TransitionManager.java
+++ /dev/null
@@ -1,95 +0,0 @@
-package com.achep.acdisplay.compat;
-
-import android.annotation.TargetApi;
-import android.os.Build;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.transition.Transition;
-import android.view.ViewGroup;
-
-import com.achep.acdisplay.Device;
-
-/**
- * This is a class for easy calling {@link android.transition.Transition}'s methods on
- * all versions of Android.
- */
-public class TransitionManager {
-
-    @NonNull
-    private static final TransitionManagerBase INSTANCE = Device.hasKitKatApi()
-            ? new TransitionManagerKitKat()
-            : new TransitionManagerBase();
-
-    /**
-     * Convenience method to animate, using the default transition,
-     * to a new scene defined by all changes within the given scene root between
-     * calling this method and the next rendering frame.
-     * Equivalent to calling {@link #beginDelayedTransition(ViewGroup, android.transition.Transition)}
-     * with a value of <code>null</code> for the <code>transition</code> parameter.
-     *
-     * @param sceneRoot The root of the View hierarchy to run the transition on.
-     */
-    public static void beginDelayedTransition(final ViewGroup vg) {
-        beginDelayedTransition(vg, null);
-    }
-
-    /**
-     * Convenience method to animate to a new scene defined by all changes within
-     * the given scene root between calling this method and the next rendering frame.
-     * Calling this method causes TransitionManager to capture current values in the
-     * scene root and then post a request to run a transition on the next frame.
-     * At that time, the new values in the scene root will be captured and changes
-     * will be animated. There is no need to create a Scene; it is implied by
-     * changes which take place between calling this method and the next frame when
-     * the transition begins.
-     *
-     * <p>Calling this method several times before the next frame (for example, if
-     * unrelated code also wants to make dynamic changes and run a transition on
-     * the same scene root), only the first call will trigger capturing values
-     * and exiting the current scene. Subsequent calls to the method with the
-     * same scene root during the same frame will be ignored.</p>
-     *
-     * <p>Passing in <code>null</code> for the transition parameter will
-     * cause the TransitionManager to use its default transition.</p>
-     *
-     * @param sceneRoot The root of the View hierarchy to run the transition on.
-     * @param transition The transition to use for this change. A
-     * value of null causes the TransitionManager to use the default transition.
-     */
-    public static void beginDelayedTransition(
-            @NonNull final ViewGroup sceneRoot,
-            @Nullable Transition transition) {
-        INSTANCE.beginDelayedTransition(sceneRoot, transition);
-    }
-
-    /**
-     * Empty class.
-     */
-    public static class TransitionManagerBase {
-
-        public void beginDelayedTransition(
-                @NonNull final ViewGroup sceneRoot,
-                @Nullable Transition transition) {
-        }
-
-    }
-
-    /**
-     * Calls {@link android.transition.Transition}'s methods.
-     */
-    @TargetApi(Build.VERSION_CODES.KITKAT)
-    public static class TransitionManagerKitKat extends TransitionManagerBase {
-
-        /**
-         * {@inheritDoc}
-         */
-        @Override
-        public void beginDelayedTransition(
-                @NonNull final ViewGroup sceneRoot,
-                @Nullable Transition transition) {
-            android.transition.TransitionManager.beginDelayedTransition(sceneRoot);
-        }
-
-    }
-
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/fragments/AboutDialog.java b/project/app/src/main/java/com/achep/acdisplay/fragments/AboutDialog.java
deleted file mode 100644
index 71789eba..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/fragments/AboutDialog.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.acdisplay.fragments;
-
-import android.app.AlertDialog;
-import android.app.Dialog;
-import android.app.DialogFragment;
-import android.content.Context;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.content.res.Resources;
-import android.os.Bundle;
-import android.text.Html;
-import android.view.View;
-import android.widget.Toast;
-
-import com.achep.acdisplay.App;
-import com.achep.acdisplay.Build;
-import com.achep.acdisplay.DialogHelper;
-import com.achep.acdisplay.R;
-import com.achep.acdisplay.utils.ToastUtils;
-
-/**
- * Dialog fragment that shows some info about this application.
- *
- * @author Artem Chepurnoy
- */
-public class AboutDialog extends DialogFragment implements View.OnClickListener {
-
-    private static final String VERSION_UNAVAILABLE = "N/A";
-    private static final int EASTER_EGGS_CLICK_NUMBER = 5;
-
-    private int mTitleClickNumber;
-    private Toast mTimeStampToast;
-
-    /**
-     * Merges app name and version name into one.
-     */
-    public static CharSequence getVersionName(Context context) {
-        PackageManager pm = context.getPackageManager();
-        String packageName = context.getPackageName();
-        String versionName;
-        try {
-            PackageInfo info = pm.getPackageInfo(packageName, 0);
-            versionName = info.versionName;
-
-            // Make the info part of version name a bit smaller.
-            if (versionName.indexOf('-') >= 0) {
-                versionName = versionName.replaceFirst("\\-", "<small>-") + "</small>";
-            }
-        } catch (PackageManager.NameNotFoundException e) {
-            versionName = VERSION_UNAVAILABLE;
-        }
-
-        Resources res = context.getResources();
-        return Html.fromHtml(
-                res.getString(R.string.about_title,
-                        res.getString(R.string.app_name), versionName)
-        );
-    }
-
-    @Override
-    public Dialog onCreateDialog(Bundle savedInstanceState) {
-        Context context = getActivity();
-        assert context != null;
-
-        CharSequence message = Html.fromHtml(getString(
-                R.string.about_message, getString(R.string.about_thanks)));
-
-        View view = new DialogHelper.Builder(context)
-                .setIcon(R.mipmap.ic_launcher)
-                .setTitle(getVersionName(context))
-                .setMessage(message)
-                .createCommonView();
-        View title = view.findViewById(R.id.title);
-        title.setOnClickListener(this);
-
-        return new AlertDialog.Builder(context)
-                .setView(view)
-                .setNeutralButton(R.string.close, null)
-                .create();
-    }
-
-    @Override
-    public void onClick(View v) {
-        if (mTimeStampToast != null) {
-            // Cancel previous toast to avoid of
-            // continuous spam after.
-            mTimeStampToast.cancel();
-        }
-
-        Context context = getActivity();
-
-        if (++mTitleClickNumber == EASTER_EGGS_CLICK_NUMBER) {
-            App.startEasterEggs(context);
-            mTitleClickNumber = 0;
-        } else {
-            mTimeStampToast = ToastUtils.showLong(context, Build.TIME_STAMP);
-        }
-    }
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/fragments/HelpDialog.java b/project/app/src/main/java/com/achep/acdisplay/fragments/HelpDialog.java
deleted file mode 100644
index 772d2cfa..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/fragments/HelpDialog.java
+++ /dev/null
@@ -1,225 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.acdisplay.fragments;
-
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.app.Dialog;
-import android.app.DialogFragment;
-import android.os.Bundle;
-import android.os.SystemClock;
-import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
-import android.text.Html;
-import android.text.TextUtils;
-import android.text.method.LinkMovementMethod;
-import android.view.View;
-import android.widget.ProgressBar;
-import android.widget.TextView;
-
-import com.achep.acdisplay.AsyncTask;
-import com.achep.acdisplay.Config;
-import com.achep.acdisplay.DialogHelper;
-import com.achep.acdisplay.R;
-import com.achep.acdisplay.RepositoryUrlBuilder;
-import com.achep.acdisplay.utils.FileUtils;
-import com.achep.acdisplay.utils.NetworkUtils;
-import com.achep.acdisplay.utils.RawReader;
-
-import java.io.File;
-import java.util.Locale;
-
-/**
- * Dialog fragment that shows FAQ.
- *
- * @author Artem Chepurnoy
- */
-public class HelpDialog extends DialogFragment implements AsyncTask.DownloadText.Callback {
-
-    private static final String FILE_NAME = "faq-%1$s.html";
-    private static final String FILE_URL = new RepositoryUrlBuilder()
-            .changeDirectory(RepositoryUrlBuilder.PROJECT_NAME)
-            .changeDirectory(RepositoryUrlBuilder.MODULE_NAME)
-            .changeDirectory("src")
-            .changeDirectory("releaseFlavor")
-            .changeDirectory("res")
-            .changeDirectory("raw-%1$s")
-            .setFile("faq.html")
-            .setRawAccess(true)
-            .build();
-
-    private ProgressBar mProgressBar;
-    private TextView mTextView;
-
-    private CharSequence mFaqLocaleSuffix;
-    private CharSequence mFaqMessage;
-    private AsyncTask.DownloadText mDownloaderTask;
-
-    private long mResumedAtTime;
-
-    @Override
-    public void onAttach(Activity activity) {
-        super.onAttach(activity);
-
-        Locale locale = Locale.getDefault();
-        mFaqLocaleSuffix = locale.getLanguage();
-
-        if (!NetworkUtils.isOnline(activity)) {
-            setFaq(null);
-            return;
-        }
-
-        // Download latest FAQ from the GitHub
-        // and store to file if available.
-
-        String localeSuffixRegional = mFaqLocaleSuffix.toString();
-
-        // Try with regional locales if available.
-        String localeCountry = locale.getCountry();
-        if (!TextUtils.isEmpty(localeCountry)) {
-            localeSuffixRegional += "-r" + localeCountry;
-        }
-
-        mDownloaderTask = new AsyncTask.DownloadText(this);
-        mDownloaderTask.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR,
-                String.format(FILE_URL, localeSuffixRegional),
-                String.format(FILE_URL, mFaqLocaleSuffix));
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        mResumedAtTime = SystemClock.elapsedRealtime();
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-
-        // Make sure that user really read the Help dialog.
-        long elapsedTime = SystemClock.elapsedRealtime() - mResumedAtTime;
-        if (elapsedTime > getResources().getInteger(R.integer.config_maxHelpUserReadFuckyou)) {
-            Config.Triggers triggers = Config.getInstance().getTriggers();
-            triggers.setHelpRead(getActivity(), true, null);
-        }
-    }
-
-    @Override
-    public void onDetach() {
-        super.onDetach();
-        AsyncTask.stop(mDownloaderTask);
-        mDownloaderTask = null;
-    }
-
-    @Override
-    public Dialog onCreateDialog(Bundle savedInstanceState) {
-        View view = new DialogHelper.Builder(getActivity())
-                .setIcon(R.drawable.ic_dialog_help)
-                .setTitle(R.string.help)
-                .setView(R.layout.fragment_help)
-                .createCommonView();
-        mTextView = (TextView) view.findViewById(R.id.message);
-        mTextView.setVisibility(View.GONE);
-        mTextView.setMovementMethod(new LinkMovementMethod());
-        mProgressBar = (ProgressBar) view.findViewById(R.id.progress_bar);
-        mProgressBar.setVisibility(View.VISIBLE);
-
-        if (mFaqMessage != null) {
-            populateFaq();
-        }
-
-        return new AlertDialog.Builder(getActivity())
-                .setNegativeButton(R.string.close, null)
-                .setView(view)
-                .create();
-    }
-
-    @Override
-    public void onDownloaded(@NonNull String[] texts) {
-        final String faqHtml = texts[0] != null ? texts[0] : texts[1];
-        if (faqHtml != null) {
-
-            // Save text to file on internal storage
-            // to keep latest FAQ offline.
-            writeToFile(faqHtml);
-        }
-
-        setFaq(faqHtml);
-    }
-
-    /**
-     * @param text latest FAQ to update from, or {@code null} to keep old.
-     */
-    private void setFaq(@Nullable String text) {
-        if (text == null) text = readFromFile();
-        if (text == null) text = readFromRaw();
-        mFaqMessage = Html.fromHtml(text);
-        populateFaq(); // update views
-    }
-
-    /**
-     * Applies current {@link #mFaqMessage FAQ message} to views, or does nothing
-     * if {@link #mTextView views} are not created yet.
-     */
-    private void populateFaq() {
-        if (mTextView != null) {
-            mTextView.setText(mFaqMessage);
-            mTextView.setVisibility(View.VISIBLE);
-            mProgressBar.setVisibility(View.GONE);
-        }
-    }
-
-    /**
-     * @return Built-in FAQ
-     * @see #readFromFile()
-     */
-    @Nullable
-    private String readFromRaw() {
-        return RawReader.readTextFileFromRawResource(getActivity(), R.raw.faq);
-    }
-
-    /**
-     * @return Previously saved FAQ, that may be not up-to-date.
-     * @see #readFromRaw()
-     * @see #writeToFile(String)
-     * @see #mFaqLocaleSuffix
-     */
-    @Nullable
-    private String readFromFile() {
-        return FileUtils.readTextFile(getFile(mFaqLocaleSuffix));
-    }
-
-    /**
-     * Saves FAQ to the {@link #getFile(CharSequence) file} on internal storage.
-     *
-     * @param faqHtml text to save.
-     * @see #readFromFile()
-     * @see #mFaqLocaleSuffix
-     */
-    private void writeToFile(@NonNull String faqHtml) {
-        FileUtils.writeToFile(getFile(mFaqLocaleSuffix), faqHtml);
-    }
-
-    @NonNull
-    private File getFile(@NonNull CharSequence suffix) {
-        String filename = String.format(FILE_NAME, suffix);
-        return new File(getActivity().getFilesDir(), filename);
-    }
-
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/fragments/SetupPermissionsDialog.java b/project/app/src/main/java/com/achep/acdisplay/fragments/SetupPermissionsDialog.java
deleted file mode 100644
index 9cf46646..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/fragments/SetupPermissionsDialog.java
+++ /dev/null
@@ -1,249 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.acdisplay.fragments;
-
-import android.app.AlertDialog;
-import android.app.Dialog;
-import android.app.DialogFragment;
-import android.app.admin.DevicePolicyManager;
-import android.content.ActivityNotFoundException;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.graphics.drawable.Drawable;
-import android.os.Bundle;
-import android.support.annotation.DrawableRes;
-import android.support.annotation.NonNull;
-import android.util.Log;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.AdapterView;
-import android.widget.ArrayAdapter;
-import android.widget.ImageView;
-import android.widget.ListView;
-import android.widget.TextView;
-
-import com.achep.acdisplay.Config;
-import com.achep.acdisplay.Device;
-import com.achep.acdisplay.DialogHelper;
-import com.achep.acdisplay.R;
-import com.achep.acdisplay.admin.AdminReceiver;
-import com.achep.acdisplay.utils.AccessUtils;
-import com.achep.acdisplay.utils.ToastUtils;
-
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-import java.util.HashMap;
-
-/**
- * Dialog fragment that shows some info about this application.
- *
- * @author Artem Chepurnoy
- */
-public class SetupPermissionsDialog extends DialogFragment {
-
-    private static final String TAG = "AccessDialog";
-
-    private ListView mListView;
-
-    private static class Item {
-        public int icon;
-        public String title;
-        public String summary;
-        public Runnable runnable;
-
-        public Item(@DrawableRes int icon,
-                    String title, String summary,
-                    @NonNull Runnable runnable) {
-            this.icon = icon;
-            this.title = title;
-            this.summary = summary;
-            this.runnable = runnable;
-        }
-    }
-
-    private Item[] buildItems() {
-        Context context = getActivity();
-        ArrayList<Item> items = new ArrayList<>();
-
-        if (!AccessUtils.isDeviceAdminAccessGranted(context)) {
-            items.add(new Item(R.drawable.stat_lock,
-                    getString(R.string.access_device_admin),
-                    getString(R.string.access_device_admin_description), new Runnable() {
-                @Override
-                public void run() {
-                    Context context = getActivity();
-                    ComponentName admin = new ComponentName(context, AdminReceiver.class);
-                    Intent intent = new Intent()
-                            .setAction(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN)
-                            .putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, admin);
-
-                    try {
-                        startActivity(intent);
-                    } catch (ActivityNotFoundException e) {
-                        ToastUtils.showLong(context, R.string.access_device_admin_grant_manually);
-                        Log.e(TAG, "Device admins activity not found.");
-                    }
-                }
-            }));
-        }
-
-        if (!AccessUtils.isNotificationAccessGranted(context)) {
-            items.add(new Item(R.drawable.stat_notify,
-                    getString(R.string.access_notifications),
-                    getString(R.string.access_notifications_description), new Runnable() {
-                @Override
-                public void run() {
-                    if (Device.hasJellyBeanMR2Api()) {
-                        launchNotificationSettings();
-                    } else {
-                        launchAccessibilitySettings();
-                    }
-                }
-
-                private void launchNotificationSettings() {
-                    Intent intent = new Intent("android.settings.ACTION_NOTIFICATION_LISTENER_SETTINGS");
-                    try {
-                        startActivity(intent);
-                    } catch (ActivityNotFoundException e) {
-                        ToastUtils.showLong(getActivity(), R.string.access_notifications_grant_manually);
-                        Log.e(TAG, "Notification listeners activity not found.");
-                    }
-                }
-
-                private void launchAccessibilitySettings() {
-                    Intent intent = new Intent(android.provider.Settings.ACTION_ACCESSIBILITY_SETTINGS);
-                    try {
-                        startActivity(intent);
-                    } catch (ActivityNotFoundException e) {
-                        Log.wtf(TAG, "Accessibility settings not found!");
-                    }
-                }
-            }));
-        }
-
-        return items.toArray(new Item[items.size()]);
-    }
-
-    @Override
-    public Dialog onCreateDialog(Bundle savedInstanceState) {
-        Context context = getActivity();
-        assert context != null;
-
-        View view = new DialogHelper.Builder(context)
-                .setTitle(R.string.access_title)
-                .setView(R.layout.fragment_access)
-                .createSkeletonView();
-
-        // Make title more red
-        TextView title = (TextView) view.findViewById(R.id.title);
-        title.setTextColor(title.getCurrentTextColor() & 0xFFFF2020 | 0xFF << 16);
-
-        mListView = (ListView) view.findViewById(R.id.list);
-        mListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-            @Override
-            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-                Adapter adapter = (Adapter) parent.getAdapter();
-                Item item = adapter.getItem(position);
-                item.runnable.run();
-            }
-        });
-
-        return new AlertDialog.Builder(context)
-                .setView(view)
-                .setNeutralButton(R.string.later, null)
-                .create();
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-
-        Item[] items = buildItems();
-        if (items.length == 0) {
-            Config.getInstance().setEnabled(getActivity(), true, null);
-            dismiss();
-        } else {
-            Adapter adapter = new Adapter(getActivity(), items);
-            mListView.setAdapter(adapter);
-        }
-    }
-
-    public static class Adapter extends ArrayAdapter<Item> {
-
-        private final Context mContext;
-        private final LayoutInflater mInflater;
-        private final HashMap<Integer, WeakReference<Drawable>> mCache;
-
-        public Adapter(Context context, Item[] items) {
-            super(context, 0, items);
-            mContext = context;
-            mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-            mCache = new HashMap<>();
-        }
-
-        private static class Holder {
-            ImageView icon;
-            TextView title;
-            TextView summary;
-        }
-
-        @Override
-        public View getView(int position, View convertView, ViewGroup parent) {
-            final Item item = getItem(position);
-            final Holder holder;
-            final View view;
-
-            if (convertView == null) {
-                holder = new Holder();
-                view = mInflater.inflate(R.layout.preference_header_item, parent, false);
-                assert view != null;
-
-                int padding = mContext.getResources().getDimensionPixelSize(R.dimen.activity_horizontal_margin);
-                view.setPadding(padding, view.getPaddingTop(), padding, view.getPaddingBottom());
-
-                holder.icon = (ImageView) view.findViewById(R.id.icon);
-                holder.title = (TextView) view.findViewById(android.R.id.title);
-                holder.summary = (TextView) view.findViewById(android.R.id.summary);
-
-                view.setTag(holder);
-            } else {
-                view = convertView;
-                holder = (Holder) view.getTag();
-            }
-
-            holder.title.setText(item.title);
-            holder.summary.setText(item.summary);
-
-            // Cache drawables for smoother scrolling.
-            Drawable drawable;
-            WeakReference<Drawable> drawableLink = mCache.get(item.icon);
-            if (drawableLink == null || (drawable = drawableLink.get()) == null) {
-                holder.icon.setImageResource(item.icon);
-                mCache.put(item.icon, new WeakReference<>(holder.icon.getDrawable()));
-            } else {
-                holder.icon.setImageDrawable(drawable);
-            }
-
-            return view;
-        }
-    }
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/graphics/BackgroundFactory.java b/project/app/src/main/java/com/achep/acdisplay/graphics/BackgroundFactory.java
new file mode 100644
index 00000000..48ced108
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/graphics/BackgroundFactory.java
@@ -0,0 +1,80 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.graphics;
+
+import android.graphics.Bitmap;
+import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.v4.os.AsyncTaskCompat;
+import android.util.Log;
+
+import com.achep.acdisplay.utils.BitmapUtils;
+import com.achep.base.async.AsyncTask;
+
+import static com.achep.base.Build.DEBUG;
+
+/**
+ * The factory for generating the background images.
+ *
+ * @author Artem Chepurnoy
+ */
+public class BackgroundFactory {
+
+    private static final String TAG = "BackgroundFactory";
+
+    public interface BackgroundAsyncListener {
+        void onGenerated(@NonNull Bitmap bitmap);
+    }
+
+    @NonNull
+    public static AsyncTask<Void, Void, Bitmap> generateAsync(final @NonNull Bitmap bitmap,
+                                                              final @NonNull BackgroundAsyncListener listener) {
+        return (AsyncTask<Void, Void, Bitmap>) AsyncTaskCompat.executeParallel(
+                new AsyncTask<Void, Void, Bitmap>() {
+
+                    @Override
+                    protected Bitmap doInBackground(Void... params) {
+                        final long start = SystemClock.elapsedRealtime();
+
+                        Bitmap output = generate(bitmap);
+
+                        if (DEBUG) {
+                            long delta = SystemClock.elapsedRealtime() - start;
+                            Log.d(TAG, "Dynamic background created in " + delta + " millis:"
+                                    + " width=" + output.getWidth()
+                                    + " height=" + output.getHeight());
+                        }
+
+                        return output;
+                    }
+
+                    @Override
+                    protected void onPostExecute(Bitmap bitmap) {
+                        super.onPostExecute(bitmap);
+                        listener.onGenerated(bitmap);
+                    }
+
+                });
+    }
+
+    public static Bitmap generate(@NonNull Bitmap bitmap) {
+        return BitmapUtils.doBlur(bitmap, 3, false);
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/graphics/IconFactory.java b/project/app/src/main/java/com/achep/acdisplay/graphics/IconFactory.java
new file mode 100644
index 00000000..8c0cb80c
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/graphics/IconFactory.java
@@ -0,0 +1,127 @@
+/*
+ * Copyright (C) 2015 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.graphics;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.drawable.Drawable;
+import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.v4.os.AsyncTaskCompat;
+import android.util.Log;
+
+import com.achep.acdisplay.R;
+import com.achep.acdisplay.notifications.NotificationUtils;
+import com.achep.acdisplay.notifications.OpenNotification;
+import com.achep.base.async.AsyncTask;
+
+import static com.achep.base.Build.DEBUG;
+
+/**
+ * The factory for generating the notification icons.
+ *
+ * @author Artem Chepurnoy
+ */
+public class IconFactory {
+
+    private static final String TAG = "IconFactory";
+
+    public interface IconAsyncListener {
+        void onGenerated(@NonNull Bitmap bitmap);
+    }
+
+    @NonNull
+    public static AsyncTask<Void, Void, Bitmap> generateAsync(final @NonNull Context context,
+                                                              final @NonNull OpenNotification notification,
+                                                              final @NonNull IconAsyncListener listener) {
+        return (AsyncTask<Void, Void, Bitmap>) AsyncTaskCompat.executeParallel(
+                new AsyncTask<Void, Void, Bitmap>() {
+
+                    @Override
+                    protected Bitmap doInBackground(Void... params) {
+                        final long start = SystemClock.elapsedRealtime();
+
+                        Bitmap output = generate(context, notification);
+
+                        if (DEBUG) {
+                            long delta = SystemClock.elapsedRealtime() - start;
+                            Log.d(TAG, "Notification icon created in " + delta + " millis:"
+                                    + " width=" + output.getWidth()
+                                    + " height=" + output.getHeight());
+                        }
+
+                        return output;
+                    }
+
+                    @Override
+                    protected void onPostExecute(Bitmap bitmap) {
+                        super.onPostExecute(bitmap);
+                        listener.onGenerated(bitmap);
+                    }
+
+                });
+    }
+
+    public static Bitmap generate(final @NonNull Context context,
+                                  final @NonNull OpenNotification notification) {
+        Resources res = context.getResources();
+
+        int iconRes = notification.getNotification().icon;
+        Drawable drawable = NotificationUtils.getDrawable(context, notification, iconRes);
+
+        final int size = res.getDimensionPixelSize(R.dimen.notification_icon_size);
+        return drawable == null ? createEmptyIcon(res, size) : createIcon(drawable, size);
+    }
+
+    // TODO: Automatically scale the icon.
+    @NonNull
+    private static Bitmap createIcon(@NonNull Drawable drawable, int size) {
+        Bitmap icon = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_4444);
+        Canvas canvas = new Canvas(icon);
+
+        drawable = drawable.mutate();
+        drawable.setBounds(0, 0, size, size);
+        drawable.draw(canvas);
+
+        return icon;
+    }
+
+    @NonNull
+    private static Bitmap createEmptyIcon(@NonNull Resources res, int size) {
+        Paint paint = new Paint();
+        paint.setAntiAlias(true);
+        paint.setColor(0xDDCCCCCC); // white gray
+
+        final float radius = size / 2f;
+
+        Bitmap icon = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_4444);
+        Canvas canvas = new Canvas(icon);
+        canvas.drawCircle(radius, radius, radius, paint);
+
+        Drawable drawable = res.getDrawable(R.drawable.ic_action_warning_white);
+        drawable.setBounds(0, 0, size, size);
+        drawable.draw(canvas);
+
+        return icon;
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/iab/Donation.java b/project/app/src/main/java/com/achep/acdisplay/iab/Donation.java
deleted file mode 100644
index 5485fdb4..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/iab/Donation.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-package com.achep.acdisplay.iab;
-
-import org.apache.commons.lang.builder.EqualsBuilder;
-import org.apache.commons.lang.builder.HashCodeBuilder;
-
-/**
- * The helper class of donation item.
- *
- * @author Artem Chepurnoy
- */
-public class Donation {
-
-    public final int amount;
-    public final String sku;
-    public final String text;
-
-    public Donation(int amount, String text) {
-        this.amount = amount;
-        this.text = text;
-
-        // Notice that all of them are defined in
-        // my Play Store's account!
-        this.sku = "donation_" + amount;
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public int hashCode() {
-        return new HashCodeBuilder(9, 51)
-                .append(amount)
-                .append(text)
-                .append(sku)
-                .toHashCode();
-    }
-
-    /**
-     * {@inheritDoc}
-     */
-    @Override
-    public boolean equals(Object o) {
-        if (o == null)
-            return false;
-        if (o == this)
-            return true;
-        if (!(o instanceof Donation))
-            return false;
-
-        Donation donation = (Donation) o;
-        return new EqualsBuilder()
-                .append(amount, donation.amount)
-                .append(text, donation.text)
-                .append(sku, donation.sku)
-                .isEquals();
-    }
-
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/iab/DonationAdapter.java b/project/app/src/main/java/com/achep/acdisplay/iab/DonationAdapter.java
deleted file mode 100644
index 3d17b45d..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/iab/DonationAdapter.java
+++ /dev/null
@@ -1,98 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-package com.achep.acdisplay.iab;
-
-import android.content.Context;
-import android.content.res.Resources;
-import android.graphics.Paint;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.ArrayAdapter;
-import android.widget.TextView;
-
-import com.achep.acdisplay.R;
-
-import java.util.HashSet;
-
-/**
- * Created by achep on 06.05.14 for AcDisplay.
- *
- * @author Artem Chepurnoy
- */
-public class DonationAdapter extends ArrayAdapter<Donation> {
-
-    private final HashSet<String> mInventorySet;
-    private final LayoutInflater mInflater;
-    private final String mDonationAmountLabel;
-
-    private final int mColorNormal;
-    private final int mColorPurchased;
-
-    public DonationAdapter(Context context, Donation[] items, HashSet<String> inventory) {
-        super(context, 0, items);
-
-        mInventorySet = inventory;
-        mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-
-        Resources res = context.getResources();
-        mDonationAmountLabel = res.getString(R.string.donation_item_label);
-        mColorNormal = res.getColor(R.color.donation_normal);
-        mColorPurchased = res.getColor(R.color.donation_purchased);
-    }
-
-    private static class Holder {
-        TextView title;
-        TextView summary;
-    }
-
-    @Override
-    public View getView(int position, View convertView, ViewGroup parent) {
-        final Donation donation = getItem(position);
-        final Holder holder;
-        final View view;
-
-        if (convertView == null) {
-            holder = new Holder();
-            view = mInflater.inflate(R.layout.donation_iab_item, parent, false);
-            assert view != null;
-
-            holder.title = (TextView) view.findViewById(android.R.id.title);
-            holder.summary = (TextView) view.findViewById(android.R.id.summary);
-
-            view.setTag(holder);
-        } else {
-            view = convertView;
-            holder = (Holder) view.getTag();
-        }
-
-        boolean bought = mInventorySet.contains(donation.sku);
-
-        String amount = Integer.toString(donation.amount);
-        holder.title.setText(String.format(mDonationAmountLabel, amount));
-        holder.title.setTextColor(bought ? mColorNormal : mColorPurchased);
-        holder.summary.setText(donation.text);
-        holder.summary.setPaintFlags(bought
-                ? holder.summary.getPaintFlags() | Paint.STRIKE_THRU_TEXT_FLAG
-                : holder.summary.getPaintFlags() & (~Paint.STRIKE_THRU_TEXT_FLAG));
-
-        return view;
-    }
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/iab/DonationFragment.java b/project/app/src/main/java/com/achep/acdisplay/iab/DonationFragment.java
deleted file mode 100644
index 51e1e9a1..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/iab/DonationFragment.java
+++ /dev/null
@@ -1,389 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-package com.achep.acdisplay.iab;
-
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.app.Dialog;
-import android.app.DialogFragment;
-import android.content.ActivityNotFoundException;
-import android.content.DialogInterface;
-import android.content.Intent;
-import android.net.Uri;
-import android.os.Bundle;
-import android.text.Html;
-import android.text.Spannable;
-import android.text.SpannableString;
-import android.text.method.LinkMovementMethod;
-import android.text.style.ImageSpan;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.AdapterView;
-import android.widget.Button;
-import android.widget.GridView;
-import android.widget.LinearLayout;
-import android.widget.ProgressBar;
-import android.widget.TextView;
-
-import com.achep.acdisplay.Build;
-import com.achep.acdisplay.DialogHelper;
-import com.achep.acdisplay.R;
-import com.achep.acdisplay.iab.cryptocoin.Bitcoin;
-import com.achep.acdisplay.iab.cryptocoin.Coin;
-import com.achep.acdisplay.iab.utils.IabHelper;
-import com.achep.acdisplay.iab.utils.IabResult;
-import com.achep.acdisplay.iab.utils.Inventory;
-import com.achep.acdisplay.iab.utils.Purchase;
-import com.achep.acdisplay.utils.IntentUtils;
-import com.achep.acdisplay.utils.ToastUtils;
-import com.achep.acdisplay.utils.ViewUtils;
-
-import java.util.HashSet;
-
-/**
- * Fragment that represents an ability to donate to me. Be sure to redirect
- * {@link android.app.Activity#onActivityResult(int, int, android.content.Intent)}
- * to this fragment!
- *
- * @author Artem Chepurnoy
- */
-public class DonationFragment extends DialogFragment {
-
-    private static final String TAG = "DonationFragment";
-
-    public static final int RC_REQUEST = 10001;
-
-    private GridView mGridView;
-    private ProgressBar mProgressBar;
-    private TextView mError;
-
-    private IabHelper mHelper;
-    private Donation[] mDonationList;
-    private final HashSet<String> mInventorySet = new HashSet<>();
-
-    @Override
-    public void onAttach(Activity activity) {
-        super.onAttach(activity);
-        mDonationList = DonationItems.get(getResources());
-    }
-
-    @Override
-    public Dialog onCreateDialog(Bundle savedInstanceState) {
-        Activity activity = getActivity();
-        assert activity != null;
-
-        View view = new DialogHelper.Builder(activity)
-                .setIcon(R.drawable.ic_dialog_donation)
-                .setTitle(R.string.donation_title)
-                .setView(R.layout.donation_dialog)
-                .createSkeletonView();
-        AlertDialog.Builder builder = new AlertDialog.Builder(activity)
-                .setView(view)
-                .setNegativeButton(R.string.close, null);
-
-        TextView info = (TextView) view.findViewById(R.id.info);
-        info.setText(Html.fromHtml(getString(R.string.donation_info)));
-        info.setMovementMethod(new LinkMovementMethod());
-        
-        mError = (TextView) view.findViewById(R.id.error);
-        mProgressBar = (ProgressBar) view.findViewById(android.R.id.progress);
-        mGridView = (GridView) view.findViewById(R.id.grid);
-        mGridView.setAdapter(new DonationAdapter(getActivity(), mDonationList, mInventorySet));
-        mGridView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
-            @Override
-            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
-                DonationAdapter adapter = (DonationAdapter) parent.getAdapter();
-                Donation donation = adapter.getItem(position);
-
-                if (!mInventorySet.contains(donation.sku)) {
-                    /**
-                     * See {@link DonationFragment#verifyDeveloperPayload(Purchase)}.
-                     */
-                    String payload = "";
-                    try {
-                        mHelper.launchPurchaseFlow(
-                                getActivity(), donation.sku, RC_REQUEST,
-                                mPurchaseFinishedListener, payload);
-                    } catch (Exception e) {
-                        ToastUtils.showShort(getActivity(), "Failed to launch a purchase flow.");
-                    }
-                } else {
-                    ToastUtils.showShort(getActivity(), getString(R.string.donation_item_bought));
-                }
-            }
-        });
-
-        final AlertDialog alertDialog;
-        if (getResources().getBoolean(R.bool.config_alternative_payments)) {
-
-            // Show Bitcoin button if user have Bitcoin client installed. 
-            final Bitcoin bitcoin = new Bitcoin();
-            final Intent bitcoinIntent = Coin.getPaymentIntent(bitcoin);
-            if (IntentUtils.hasActivityForThat(activity, bitcoinIntent)) {
-                builder.setPositiveButton(bitcoin.getNameResource(), null);
-            }
-
-            // Show PayPal button.
-            final Intent paypalIntent = new Intent(Intent.ACTION_VIEW, Uri.parse(Build.Links.DONATE));
-            builder.setNeutralButton(R.string.paypal, null);
-
-            alertDialog = builder.create();
-            alertDialog.setOnShowListener(new DialogInterface.OnShowListener() {
-
-                final class Data {
-    
-                    private final Button button;
-                    private final Intent intent;
-                    private final int iconResource;
-    
-                    private Data(Button button, Intent intent, int iconResource) {
-                        this.button = button;
-                        this.intent = intent;
-                        this.iconResource = iconResource;
-                    }
-                }
-    
-                @Override
-                public void onShow(DialogInterface dialog) {
-                    Data[] datas = new Data[] {
-                            new Data(
-                                    alertDialog.getButton(DialogInterface.BUTTON_NEUTRAL),
-                                    paypalIntent, R.drawable.ic_action_paypal),
-                            new Data(
-                                    alertDialog.getButton(DialogInterface.BUTTON_POSITIVE),
-                                    bitcoinIntent, R.drawable.ic_action_bitcoin),
-                    };
-    
-                    ImageSpan span;
-                    SpannableString text;
-                    for (final Data data : datas) {
-                        final Button btn = data.button;
-                        if (btn != null) {
-                            span = new ImageSpan(getActivity(), data.iconResource);
-    
-                            // Replace text with an icon. 
-                            // This is a workaround to fix compound button's aligment.
-                            text = new SpannableString(" ");
-                            text.setSpan(span, 0, 1, Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
-                            btn.setText(text);
-    
-                            // Eat default weight.
-                            btn.setLayoutParams(new LinearLayout.LayoutParams(
-                                    ViewGroup.LayoutParams.WRAP_CONTENT,
-                                    ViewGroup.LayoutParams.WRAP_CONTENT));
-    
-                            btn.setOnClickListener(new View.OnClickListener() {
-                                @Override
-                                public void onClick(View v) {
-                                    startPaymentIntentWithWarningAlertDialog(data.intent);
-                                }
-                            });
-                        }
-                    }
-                }
-            });
-        } else {
-            alertDialog = builder.create();
-        }
-
-        initBilling();
-
-        return alertDialog;
-    }
-
-    /**
-     * Shows a warning alert dialog to note, that those methods 
-     * may suck hard and nobody will care about it.<br/>
-     * Starts an intent if user is agree with it.
-     */
-    private void startPaymentIntentWithWarningAlertDialog(final Intent intent) {
-        CharSequence messageText = getString(R.string.donation_no_responsibility);
-        new DialogHelper.Builder(getActivity())
-                .setMessage(messageText)
-                .wrap()
-                .setNegativeButton(android.R.string.cancel, null)
-                .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        try {
-                            startActivity(intent);
-                            dismiss(); // Dismiss main fragment
-                        } catch (ActivityNotFoundException e) { /* hell no */ }
-                    }
-                })
-                .create()
-                .show();
-    }
-
-    private void setWaitScreen(boolean loading) {
-        ViewUtils.setVisible(mProgressBar, loading);
-        ViewUtils.setVisible(mGridView, !loading);
-        ViewUtils.setVisible(mError, false);
-    }
-
-    private void setErrorScreen(String errorMessage, final Runnable runnable) {
-        mProgressBar.setVisibility(View.GONE);
-        mGridView.setVisibility(View.GONE);
-        mError.setVisibility(View.VISIBLE);
-        mError.setText(errorMessage);
-        mError.setOnClickListener(runnable != null ? new View.OnClickListener() {
-            @Override
-            public void onClick(View v) {
-                runnable.run();
-            }
-        } : null);
-    }
-
-    /**
-     * Updates GUI to display changes.
-     */
-    private void updateUi() {
-        DonationAdapter adapter = (DonationAdapter) mGridView.getAdapter();
-        adapter.notifyDataSetChanged();
-    }
-
-    @Override
-    public void onDestroy() {
-        super.onDestroy();
-        disposeBilling();
-    }
-
-    @Override
-    public void onActivityResult(int requestCode, int resultCode, Intent data) {
-        if (mHelper.handleActivityResult(requestCode, resultCode, data)) {
-            return;
-        }
-
-        super.onActivityResult(requestCode, resultCode, data);
-    }
-
-    private final IabHelper.OnIabPurchaseFinishedListener mPurchaseFinishedListener =
-            new IabHelper.OnIabPurchaseFinishedListener() {
-                public void onIabPurchaseFinished(IabResult result, Purchase purchase) {
-                    if (mHelper == null) return;
-                    if (result.isFailure()) {
-                        complain("Error purchasing: " + result);
-                        setWaitScreen(false);
-                        return;
-                    }
-
-                    if (!verifyDeveloperPayload(purchase)) {
-                        complain("Error purchasing. Authenticity verification failed.");
-                        setWaitScreen(false);
-                        return;
-                    }
-
-                    String sku = purchase.getSku();
-                    mInventorySet.add(sku);
-                }
-            };
-
-    private final IabHelper.QueryInventoryFinishedListener mGotInventoryListener =
-            new IabHelper.QueryInventoryFinishedListener() {
-                public void onQueryInventoryFinished(IabResult result, Inventory inventory) {
-                    if (mHelper == null) return;
-                    if (result.isFailure()) {
-                        complain("Failed to query inventory: " + result);
-                        return;
-                    }
-
-                    mInventorySet.clear();
-                    for (Donation donation : mDonationList) {
-                        Purchase purchase = inventory.getPurchase(donation.sku);
-                        boolean isBought = (purchase != null && verifyDeveloperPayload(purchase));
-
-                        if (isBought) {
-                            mInventorySet.add(donation.sku);
-                        }
-                    }
-
-                    /*
-                    // Fake items to debug user interface.
-                    mInventorySet.add(mDonationList[0].sku);
-                    mInventorySet.add(mDonationList[1].sku);
-                    mInventorySet.add(mDonationList[2].sku);
-                    */
-
-                    updateUi();
-                    setWaitScreen(false);
-                }
-            };
-
-    /**
-     * Releases billing service.
-     *
-     * @see #initBilling()
-     */
-    private void disposeBilling() {
-        if (mHelper != null) {
-            mHelper.dispose();
-            mHelper = null;
-        }
-    }
-
-    /**
-     * <b>Make sure you call {@link #disposeBilling()}!</b>
-     *
-     * @see #disposeBilling()
-     */
-    private void initBilling() {
-        setWaitScreen(true);
-        disposeBilling();
-
-        String base64EncodedPublicKey = Build.GOOGLE_PLAY_PUBLIC_KEY;
-        mHelper = new IabHelper(getActivity(), base64EncodedPublicKey);
-        mHelper.enableDebugLogging(Build.DEBUG);
-        mHelper.startSetup(new IabHelper.OnIabSetupFinishedListener() {
-            public void onIabSetupFinished(IabResult result) {
-                if (mHelper == null) return;
-                if (!result.isSuccess()) {
-                    setErrorScreen(getString(R.string.donation_error_iab_setup), new Runnable() {
-                        @Override
-                        public void run() {
-                            // Try to initialize billings again.
-                            initBilling();
-                        }
-                    });
-                    return;
-                }
-
-                setWaitScreen(false);
-                mHelper.queryInventoryAsync(mGotInventoryListener);
-            }
-        });
-    }
-
-    private boolean verifyDeveloperPayload(Purchase purchase) {
-        // TODO: This method itself is a big question.
-        // Personally, I think that this whole ‘best practices’ part
-        // is confusing and is trying to make you do work that the API
-        // should really be doing. Since the purchase is tied to a Google account,
-        // and the Play Store obviously saves this information, they should
-        // just give you this in the purchase details. Getting a proper user ID
-        // requires additional permissions that you shouldn’t need to add just
-        // to cover for the deficiencies of the IAB API.
-        return true;
-    }
-
-    private void complain(String message) {
-        ToastUtils.showShort(getActivity(), message);
-    }
-
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/iab/utils/Base64.java b/project/app/src/main/java/com/achep/acdisplay/iab/utils/Base64.java
deleted file mode 100644
index 6ee44b9c..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/iab/utils/Base64.java
+++ /dev/null
@@ -1,582 +0,0 @@
-// Portions copyright 2002, Google, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package com.achep.acdisplay.iab.utils;
-
-// This code was converted from code at http://iharder.sourceforge.net/base64/
-// Lots of extraneous features were removed.
-/* The original code said:
- * <p>
- * I am placing this code in the Public Domain. Do with it as you will.
- * This software comes with no guarantees or warranties but with
- * plenty of well-wishing instead!
- * Please visit
- * <a href="http://iharder.net/xmlizable">http://iharder.net/xmlizable</a>
- * periodically to check for updates or to contribute improvements.
- * </p>
- *
- * @author Robert Harder
- * @author rharder@usa.net
- * @version 1.3
- */
-
-/**
- * Base64 converter class. This code is not a complete MIME encoder;
- * it simply converts binary data to base64 data and back.
- * <p/>
- * <p>Note {@link CharBase64} is a GWT-compatible implementation of this
- * class.
- */
-public class Base64 {
-    /**
-     * Specify encoding (value is {@code true}).
-     */
-    public final static boolean ENCODE = true;
-
-    /**
-     * Specify decoding (value is {@code false}).
-     */
-    public final static boolean DECODE = false;
-
-    /**
-     * The equals sign (=) as a byte.
-     */
-    private final static byte EQUALS_SIGN = (byte) '=';
-
-    /**
-     * The new line character (\n) as a byte.
-     */
-    private final static byte NEW_LINE = (byte) '\n';
-
-    /**
-     * The 64 valid Base64 values.
-     */
-    private final static byte[] ALPHABET =
-            {(byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F',
-                    (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K',
-                    (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P',
-                    (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U',
-                    (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z',
-                    (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
-                    (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j',
-                    (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
-                    (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't',
-                    (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y',
-                    (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3',
-                    (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
-                    (byte) '9', (byte) '+', (byte) '/'};
-
-    /**
-     * The 64 valid web safe Base64 values.
-     */
-    private final static byte[] WEBSAFE_ALPHABET =
-            {(byte) 'A', (byte) 'B', (byte) 'C', (byte) 'D', (byte) 'E', (byte) 'F',
-                    (byte) 'G', (byte) 'H', (byte) 'I', (byte) 'J', (byte) 'K',
-                    (byte) 'L', (byte) 'M', (byte) 'N', (byte) 'O', (byte) 'P',
-                    (byte) 'Q', (byte) 'R', (byte) 'S', (byte) 'T', (byte) 'U',
-                    (byte) 'V', (byte) 'W', (byte) 'X', (byte) 'Y', (byte) 'Z',
-                    (byte) 'a', (byte) 'b', (byte) 'c', (byte) 'd', (byte) 'e',
-                    (byte) 'f', (byte) 'g', (byte) 'h', (byte) 'i', (byte) 'j',
-                    (byte) 'k', (byte) 'l', (byte) 'm', (byte) 'n', (byte) 'o',
-                    (byte) 'p', (byte) 'q', (byte) 'r', (byte) 's', (byte) 't',
-                    (byte) 'u', (byte) 'v', (byte) 'w', (byte) 'x', (byte) 'y',
-                    (byte) 'z', (byte) '0', (byte) '1', (byte) '2', (byte) '3',
-                    (byte) '4', (byte) '5', (byte) '6', (byte) '7', (byte) '8',
-                    (byte) '9', (byte) '-', (byte) '_'};
-
-    /**
-     * Translates a Base64 value to either its 6-bit reconstruction value
-     * or a negative number indicating some other meaning.
-     */
-    private final static byte[] DECODABET = {-9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal  0 -  8
-            -5, -5, // Whitespace: Tab and Linefeed
-            -9, -9, // Decimal 11 - 12
-            -5, // Whitespace: Carriage Return
-            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26
-            -9, -9, -9, -9, -9, // Decimal 27 - 31
-            -5, // Whitespace: Space
-            -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 42
-            62, // Plus sign at decimal 43
-            -9, -9, -9, // Decimal 44 - 46
-            63, // Slash at decimal 47
-            52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
-            -9, -9, -9, // Decimal 58 - 60
-            -1, // Equals sign at decimal 61
-            -9, -9, -9, // Decimal 62 - 64
-            0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'
-            14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'
-            -9, -9, -9, -9, -9, -9, // Decimal 91 - 96
-            26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'
-            39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'
-            -9, -9, -9, -9, -9 // Decimal 123 - 127
-        /*  ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
-    };
-
-    /**
-     * The web safe decodabet
-     */
-    private final static byte[] WEBSAFE_DECODABET =
-            {-9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal  0 -  8
-                    -5, -5, // Whitespace: Tab and Linefeed
-                    -9, -9, // Decimal 11 - 12
-                    -5, // Whitespace: Carriage Return
-                    -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 14 - 26
-                    -9, -9, -9, -9, -9, // Decimal 27 - 31
-                    -5, // Whitespace: Space
-                    -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, -9, // Decimal 33 - 44
-                    62, // Dash '-' sign at decimal 45
-                    -9, -9, // Decimal 46-47
-                    52, 53, 54, 55, 56, 57, 58, 59, 60, 61, // Numbers zero through nine
-                    -9, -9, -9, // Decimal 58 - 60
-                    -1, // Equals sign at decimal 61
-                    -9, -9, -9, // Decimal 62 - 64
-                    0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, // Letters 'A' through 'N'
-                    14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, // Letters 'O' through 'Z'
-                    -9, -9, -9, -9, // Decimal 91-94
-                    63, // Underscore '_' at decimal 95
-                    -9, // Decimal 96
-                    26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, // Letters 'a' through 'm'
-                    39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, // Letters 'n' through 'z'
-                    -9, -9, -9, -9, -9 // Decimal 123 - 127
-        /*  ,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 128 - 139
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 140 - 152
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 153 - 165
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 166 - 178
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 179 - 191
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 192 - 204
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 205 - 217
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 218 - 230
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,     // Decimal 231 - 243
-        -9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9,-9         // Decimal 244 - 255 */
-            };
-
-    // Indicates white space in encoding
-    private final static byte WHITE_SPACE_ENC = -5;
-    // Indicates equals sign in encoding
-    private final static byte EQUALS_SIGN_ENC = -1;
-
-    /**
-     * Defeats instantiation.
-     */
-    private Base64() {
-    }
-
-    /* ********  E N C O D I N G   M E T H O D S  ******** */
-
-    /**
-     * Encodes up to three bytes of the array <var>source</var>
-     * and writes the resulting four Base64 bytes to <var>destination</var>.
-     * The source and destination arrays can be manipulated
-     * anywhere along their length by specifying
-     * <var>srcOffset</var> and <var>destOffset</var>.
-     * This method does not check to make sure your arrays
-     * are large enough to accommodate <var>srcOffset</var> + 3 for
-     * the <var>source</var> array or <var>destOffset</var> + 4 for
-     * the <var>destination</var> array.
-     * The actual number of significant bytes in your array is
-     * given by <var>numSigBytes</var>.
-     *
-     * @param source      the array to convert
-     * @param srcOffset   the index where conversion begins
-     * @param numSigBytes the number of significant bytes in your array
-     * @param destination the array to hold the conversion
-     * @param destOffset  the index where output will be put
-     * @param alphabet    is the encoding alphabet
-     * @return the <var>destination</var> array
-     * @since 1.3
-     */
-    private static byte[] encode3to4(byte[] source, int srcOffset,
-                                     int numSigBytes, byte[] destination, int destOffset, byte[] alphabet) {
-        //           1         2         3
-        // 01234567890123456789012345678901 Bit position
-        // --------000000001111111122222222 Array position from threeBytes
-        // --------|    ||    ||    ||    | Six bit groups to index alphabet
-        //          >>18  >>12  >> 6  >> 0  Right shift necessary
-        //                0x3f  0x3f  0x3f  Additional AND
-
-        // Create buffer with zero-padding if there are only one or two
-        // significant bytes passed in the array.
-        // We have to shift left 24 in order to flush out the 1's that appear
-        // when Java treats a value as negative that is cast from a byte to an int.
-        int inBuff =
-                (numSigBytes > 0 ? ((source[srcOffset] << 24) >>> 8) : 0)
-                        | (numSigBytes > 1 ? ((source[srcOffset + 1] << 24) >>> 16) : 0)
-                        | (numSigBytes > 2 ? ((source[srcOffset + 2] << 24) >>> 24) : 0);
-
-        switch (numSigBytes) {
-            case 3:
-                destination[destOffset] = alphabet[(inBuff >>> 18)];
-                destination[destOffset + 1] = alphabet[(inBuff >>> 12) & 0x3f];
-                destination[destOffset + 2] = alphabet[(inBuff >>> 6) & 0x3f];
-                destination[destOffset + 3] = alphabet[(inBuff) & 0x3f];
-                return destination;
-            case 2:
-                destination[destOffset] = alphabet[(inBuff >>> 18)];
-                destination[destOffset + 1] = alphabet[(inBuff >>> 12) & 0x3f];
-                destination[destOffset + 2] = alphabet[(inBuff >>> 6) & 0x3f];
-                destination[destOffset + 3] = EQUALS_SIGN;
-                return destination;
-            case 1:
-                destination[destOffset] = alphabet[(inBuff >>> 18)];
-                destination[destOffset + 1] = alphabet[(inBuff >>> 12) & 0x3f];
-                destination[destOffset + 2] = EQUALS_SIGN;
-                destination[destOffset + 3] = EQUALS_SIGN;
-                return destination;
-            default:
-                return destination;
-        } // end switch
-    } // end encode3to4
-
-    /**
-     * Encodes a byte array into Base64 notation.
-     * Equivalent to calling
-     * {@code encodeBytes(source, 0, source.length)}
-     *
-     * @param source The data to convert
-     * @since 1.4
-     */
-    public static String encode(byte[] source) {
-        return encode(source, 0, source.length, ALPHABET, true);
-    }
-
-    /**
-     * Encodes a byte array into web safe Base64 notation.
-     *
-     * @param source    The data to convert
-     * @param doPadding is {@code true} to pad result with '=' chars
-     *                  if it does not fall on 3 byte boundaries
-     */
-    public static String encodeWebSafe(byte[] source, boolean doPadding) {
-        return encode(source, 0, source.length, WEBSAFE_ALPHABET, doPadding);
-    }
-
-    /**
-     * Encodes a byte array into Base64 notation.
-     *
-     * @param source    the data to convert
-     * @param off       offset in array where conversion should begin
-     * @param len       length of data to convert
-     * @param alphabet  the encoding alphabet
-     * @param doPadding is {@code true} to pad result with '=' chars
-     *                  if it does not fall on 3 byte boundaries
-     * @since 1.4
-     */
-    public static String encode(byte[] source, int off, int len, byte[] alphabet,
-                                boolean doPadding) {
-        byte[] outBuff = encode(source, off, len, alphabet, Integer.MAX_VALUE);
-        int outLen = outBuff.length;
-
-        // If doPadding is false, set length to truncate '='
-        // padding characters
-        while (doPadding == false && outLen > 0) {
-            if (outBuff[outLen - 1] != '=') {
-                break;
-            }
-            outLen -= 1;
-        }
-
-        return new String(outBuff, 0, outLen);
-    }
-
-    /**
-     * Encodes a byte array into Base64 notation.
-     *
-     * @param source        the data to convert
-     * @param off           offset in array where conversion should begin
-     * @param len           length of data to convert
-     * @param alphabet      is the encoding alphabet
-     * @param maxLineLength maximum length of one line.
-     * @return the BASE64-encoded byte array
-     */
-    public static byte[] encode(byte[] source, int off, int len, byte[] alphabet,
-                                int maxLineLength) {
-        int lenDiv3 = (len + 2) / 3; // ceil(len / 3)
-        int len43 = lenDiv3 * 4;
-        byte[] outBuff = new byte[len43 // Main 4:3
-                + (len43 / maxLineLength)]; // New lines
-
-        int d = 0;
-        int e = 0;
-        int len2 = len - 2;
-        int lineLength = 0;
-        for (; d < len2; d += 3, e += 4) {
-
-            // The following block of code is the same as
-            // encode3to4( source, d + off, 3, outBuff, e, alphabet );
-            // but inlined for faster encoding (~20% improvement)
-            int inBuff =
-                    ((source[d + off] << 24) >>> 8)
-                            | ((source[d + 1 + off] << 24) >>> 16)
-                            | ((source[d + 2 + off] << 24) >>> 24);
-            outBuff[e] = alphabet[(inBuff >>> 18)];
-            outBuff[e + 1] = alphabet[(inBuff >>> 12) & 0x3f];
-            outBuff[e + 2] = alphabet[(inBuff >>> 6) & 0x3f];
-            outBuff[e + 3] = alphabet[(inBuff) & 0x3f];
-
-            lineLength += 4;
-            if (lineLength == maxLineLength) {
-                outBuff[e + 4] = NEW_LINE;
-                e++;
-                lineLength = 0;
-            } // end if: end of line
-        } // end for: each piece of array
-
-        if (d < len) {
-            encode3to4(source, d + off, len - d, outBuff, e, alphabet);
-
-            lineLength += 4;
-            if (lineLength == maxLineLength) {
-                // Add a last newline
-                outBuff[e + 4] = NEW_LINE;
-                e++;
-            }
-            e += 4;
-        }
-
-        assert (e == outBuff.length);
-        return outBuff;
-    }
-
-
-    /* ********  D E C O D I N G   M E T H O D S  ******** */
-
-
-    /**
-     * Decodes four bytes from array <var>source</var>
-     * and writes the resulting bytes (up to three of them)
-     * to <var>destination</var>.
-     * The source and destination arrays can be manipulated
-     * anywhere along their length by specifying
-     * <var>srcOffset</var> and <var>destOffset</var>.
-     * This method does not check to make sure your arrays
-     * are large enough to accommodate <var>srcOffset</var> + 4 for
-     * the <var>source</var> array or <var>destOffset</var> + 3 for
-     * the <var>destination</var> array.
-     * This method returns the actual number of bytes that
-     * were converted from the Base64 encoding.
-     *
-     * @param source      the array to convert
-     * @param srcOffset   the index where conversion begins
-     * @param destination the array to hold the conversion
-     * @param destOffset  the index where output will be put
-     * @param decodabet   the decodabet for decoding Base64 content
-     * @return the number of decoded bytes converted
-     * @since 1.3
-     */
-    private static int decode4to3(byte[] source, int srcOffset,
-                                  byte[] destination, int destOffset, byte[] decodabet) {
-        // Example: Dk==
-        if (source[srcOffset + 2] == EQUALS_SIGN) {
-            int outBuff =
-                    ((decodabet[source[srcOffset]] << 24) >>> 6)
-                            | ((decodabet[source[srcOffset + 1]] << 24) >>> 12);
-
-            destination[destOffset] = (byte) (outBuff >>> 16);
-            return 1;
-        } else if (source[srcOffset + 3] == EQUALS_SIGN) {
-            // Example: DkL=
-            int outBuff =
-                    ((decodabet[source[srcOffset]] << 24) >>> 6)
-                            | ((decodabet[source[srcOffset + 1]] << 24) >>> 12)
-                            | ((decodabet[source[srcOffset + 2]] << 24) >>> 18);
-
-            destination[destOffset] = (byte) (outBuff >>> 16);
-            destination[destOffset + 1] = (byte) (outBuff >>> 8);
-            return 2;
-        } else {
-            // Example: DkLE
-            int outBuff =
-                    ((decodabet[source[srcOffset]] << 24) >>> 6)
-                            | ((decodabet[source[srcOffset + 1]] << 24) >>> 12)
-                            | ((decodabet[source[srcOffset + 2]] << 24) >>> 18)
-                            | ((decodabet[source[srcOffset + 3]] << 24) >>> 24);
-
-            destination[destOffset] = (byte) (outBuff >> 16);
-            destination[destOffset + 1] = (byte) (outBuff >> 8);
-            destination[destOffset + 2] = (byte) (outBuff);
-            return 3;
-        }
-    } // end decodeToBytes
-
-
-    /**
-     * Decodes data from Base64 notation.
-     *
-     * @param s the string to decode (decoded in default encoding)
-     * @return the decoded data
-     * @since 1.4
-     */
-    public static byte[] decode(String s) throws Base64DecoderException {
-        byte[] bytes = s.getBytes();
-        return decode(bytes, 0, bytes.length);
-    }
-
-    /**
-     * Decodes data from web safe Base64 notation.
-     * Web safe encoding uses '-' instead of '+', '_' instead of '/'
-     *
-     * @param s the string to decode (decoded in default encoding)
-     * @return the decoded data
-     */
-    public static byte[] decodeWebSafe(String s) throws Base64DecoderException {
-        byte[] bytes = s.getBytes();
-        return decodeWebSafe(bytes, 0, bytes.length);
-    }
-
-    /**
-     * Decodes Base64 content in byte array format and returns
-     * the decoded byte array.
-     *
-     * @param source The Base64 encoded data
-     * @return decoded data
-     * @throws Base64DecoderException
-     * @since 1.3
-     */
-    public static byte[] decode(byte[] source) throws Base64DecoderException {
-        return decode(source, 0, source.length);
-    }
-
-    /**
-     * Decodes web safe Base64 content in byte array format and returns
-     * the decoded data.
-     * Web safe encoding uses '-' instead of '+', '_' instead of '/'
-     *
-     * @param source the string to decode (decoded in default encoding)
-     * @return the decoded data
-     */
-    public static byte[] decodeWebSafe(byte[] source)
-            throws Base64DecoderException {
-        return decodeWebSafe(source, 0, source.length);
-    }
-
-    /**
-     * Decodes Base64 content in byte array format and returns
-     * the decoded byte array.
-     *
-     * @param source the Base64 encoded data
-     * @param off    the offset of where to begin decoding
-     * @param len    the length of characters to decode
-     * @return decoded data
-     * @throws Base64DecoderException
-     * @since 1.3
-     */
-    public static byte[] decode(byte[] source, int off, int len)
-            throws Base64DecoderException {
-        return decode(source, off, len, DECODABET);
-    }
-
-    /**
-     * Decodes web safe Base64 content in byte array format and returns
-     * the decoded byte array.
-     * Web safe encoding uses '-' instead of '+', '_' instead of '/'
-     *
-     * @param source the Base64 encoded data
-     * @param off    the offset of where to begin decoding
-     * @param len    the length of characters to decode
-     * @return decoded data
-     */
-    public static byte[] decodeWebSafe(byte[] source, int off, int len)
-            throws Base64DecoderException {
-        return decode(source, off, len, WEBSAFE_DECODABET);
-    }
-
-    /**
-     * Decodes Base64 content using the supplied decodabet and returns
-     * the decoded byte array.
-     *
-     * @param source    the Base64 encoded data
-     * @param off       the offset of where to begin decoding
-     * @param len       the length of characters to decode
-     * @param decodabet the decodabet for decoding Base64 content
-     * @return decoded data
-     */
-    public static byte[] decode(byte[] source, int off, int len, byte[] decodabet)
-            throws Base64DecoderException {
-        int len34 = len * 3 / 4;
-        byte[] outBuff = new byte[2 + len34]; // Upper limit on size of output
-        int outBuffPosn = 0;
-
-        byte[] b4 = new byte[4];
-        int b4Posn = 0;
-        int i = 0;
-        byte sbiCrop = 0;
-        byte sbiDecode = 0;
-        for (i = 0; i < len; i++) {
-            sbiCrop = (byte) (source[i + off] & 0x7f); // Only the low seven bits
-            sbiDecode = decodabet[sbiCrop];
-
-            if (sbiDecode >= WHITE_SPACE_ENC) { // White space Equals sign or better
-                if (sbiDecode >= EQUALS_SIGN_ENC) {
-                    // An equals sign (for padding) must not occur at position 0 or 1
-                    // and must be the last byte[s] in the encoded value
-                    if (sbiCrop == EQUALS_SIGN) {
-                        int bytesLeft = len - i;
-                        byte lastByte = (byte) (source[len - 1 + off] & 0x7f);
-                        if (b4Posn == 0 || b4Posn == 1) {
-                            throw new Base64DecoderException(
-                                    "invalid padding byte '=' at byte offset " + i);
-                        } else if ((b4Posn == 3 && bytesLeft > 2)
-                                || (b4Posn == 4 && bytesLeft > 1)) {
-                            throw new Base64DecoderException(
-                                    "padding byte '=' falsely signals end of encoded value "
-                                            + "at offset " + i
-                            );
-                        } else if (lastByte != EQUALS_SIGN && lastByte != NEW_LINE) {
-                            throw new Base64DecoderException(
-                                    "encoded value has invalid trailing byte");
-                        }
-                        break;
-                    }
-
-                    b4[b4Posn++] = sbiCrop;
-                    if (b4Posn == 4) {
-                        outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);
-                        b4Posn = 0;
-                    }
-                }
-            } else {
-                throw new Base64DecoderException("Bad Base64 input character at " + i
-                        + ": " + source[i + off] + "(decimal)");
-            }
-        }
-
-        // Because web safe encoding allows non padding base64 encodes, we
-        // need to pad the rest of the b4 buffer with equal signs when
-        // b4Posn != 0.  There can be at most 2 equal signs at the end of
-        // four characters, so the b4 buffer must have two or three
-        // characters.  This also catches the case where the input is
-        // padded with EQUALS_SIGN
-        if (b4Posn != 0) {
-            if (b4Posn == 1) {
-                throw new Base64DecoderException("single trailing character at offset "
-                        + (len - 1));
-            }
-            b4[b4Posn++] = EQUALS_SIGN;
-            outBuffPosn += decode4to3(b4, 0, outBuff, outBuffPosn, decodabet);
-        }
-
-        byte[] out = new byte[outBuffPosn];
-        System.arraycopy(outBuff, 0, out, 0, outBuffPosn);
-        return out;
-    }
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/iab/utils/Base64DecoderException.java b/project/app/src/main/java/com/achep/acdisplay/iab/utils/Base64DecoderException.java
deleted file mode 100644
index 2310746e..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/iab/utils/Base64DecoderException.java
+++ /dev/null
@@ -1,32 +0,0 @@
-// Copyright 2002, Google, Inc.
-//
-// Licensed under the Apache License, Version 2.0 (the "License");
-// you may not use this file except in compliance with the License.
-// You may obtain a copy of the License at
-//
-//     http://www.apache.org/licenses/LICENSE-2.0
-//
-// Unless required by applicable law or agreed to in writing, software
-// distributed under the License is distributed on an "AS IS" BASIS,
-// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
-// See the License for the specific language governing permissions and
-// limitations under the License.
-
-package com.achep.acdisplay.iab.utils;
-
-/**
- * Exception thrown when encountering an invalid Base64 input character.
- *
- * @author nelson
- */
-public class Base64DecoderException extends Exception {
-    public Base64DecoderException() {
-        super();
-    }
-
-    public Base64DecoderException(String s) {
-        super(s);
-    }
-
-    private static final long serialVersionUID = 1L;
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/iab/utils/IabException.java b/project/app/src/main/java/com/achep/acdisplay/iab/utils/IabException.java
deleted file mode 100644
index 81969d85..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/iab/utils/IabException.java
+++ /dev/null
@@ -1,50 +0,0 @@
-/* Copyright (c) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.achep.acdisplay.iab.utils;
-
-/**
- * Exception thrown when something went wrong with in-app billing.
- * An IabException has an associated IabResult (an error).
- * To get the IAB result that caused this exception to be thrown,
- * call {@link #getResult()}.
- */
-public class IabException extends Exception {
-    IabResult mResult;
-
-    public IabException(IabResult r) {
-        this(r, null);
-    }
-
-    public IabException(int response, String message) {
-        this(new IabResult(response, message));
-    }
-
-    public IabException(IabResult r, Exception cause) {
-        super(r.getMessage(), cause);
-        mResult = r;
-    }
-
-    public IabException(int response, String message, Exception cause) {
-        this(new IabResult(response, message), cause);
-    }
-
-    /**
-     * Returns the IAB result (error) that this exception signals.
-     */
-    public IabResult getResult() {
-        return mResult;
-    }
-}
\ No newline at end of file
diff --git a/project/app/src/main/java/com/achep/acdisplay/iab/utils/IabHelper.java b/project/app/src/main/java/com/achep/acdisplay/iab/utils/IabHelper.java
deleted file mode 100644
index f9cc8b2e..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/iab/utils/IabHelper.java
+++ /dev/null
@@ -1,984 +0,0 @@
-/* Copyright (c) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.achep.acdisplay.iab.utils;
-
-import android.app.Activity;
-import android.app.PendingIntent;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.IntentSender.SendIntentException;
-import android.content.ServiceConnection;
-import android.content.pm.ResolveInfo;
-import android.os.Bundle;
-import android.os.Handler;
-import android.os.IBinder;
-import android.os.RemoteException;
-import android.text.TextUtils;
-import android.util.Log;
-
-import com.android.vending.billing.IInAppBillingService;
-
-import org.json.JSONException;
-
-import java.util.ArrayList;
-import java.util.List;
-
-
-/**
- * Provides convenience methods for in-app billing. You can create one instance of this
- * class for your application and use it to process in-app billing operations.
- * It provides synchronous (blocking) and asynchronous (non-blocking) methods for
- * many common in-app billing operations, as well as automatic signature
- * verification.
- * <p/>
- * After instantiating, you must perform setup in order to start using the object.
- * To perform setup, call the {@link #startSetup} method and provide a listener;
- * that listener will be notified when setup is complete, after which (and not before)
- * you may call other methods.
- * <p/>
- * After setup is complete, you will typically want to request an inventory of owned
- * items and subscriptions. See {@link #queryInventory}, {@link #queryInventoryAsync}
- * and related methods.
- * <p/>
- * When you are done with this object, don't forget to call {@link #dispose}
- * to ensure proper cleanup. This object holds a binding to the in-app billing
- * service, which will leak unless you dispose of it correctly. If you created
- * the object on an Activity's onCreate method, then the recommended
- * place to dispose of it is the Activity's onDestroy method.
- * <p/>
- * A note about threading: When using this object from a background thread, you may
- * call the blocking versions of methods; when using from a UI thread, call
- * only the asynchronous versions and handle the results via callbacks.
- * Also, notice that you can only call one asynchronous operation at a time;
- * attempting to start a second asynchronous operation while the first one
- * has not yet completed will result in an exception being thrown.
- *
- * @author Bruno Oliveira (Google)
- */
-public class IabHelper {
-    // Is debug logging enabled?
-    boolean mDebugLog = false;
-    String mDebugTag = "IabHelper";
-
-    // Is setup done?
-    boolean mSetupDone = false;
-
-    // Has this object been disposed of? (If so, we should ignore callbacks, etc)
-    boolean mDisposed = false;
-
-    boolean mIsBound = false;
-
-    // Are subscriptions supported?
-    boolean mSubscriptionsSupported = false;
-
-    // Is an asynchronous operation in progress?
-    // (only one at a time can be in progress)
-    boolean mAsyncInProgress = false;
-
-    // (for logging/debugging)
-    // if mAsyncInProgress == true, what asynchronous operation is in progress?
-    String mAsyncOperation = "";
-
-    // Context we were passed during initialization
-    Context mContext;
-
-    // Connection to the service
-    IInAppBillingService mService;
-    ServiceConnection mServiceConn;
-
-    // The request code used to launch purchase flow
-    int mRequestCode;
-
-    // The item type of the current purchase flow
-    String mPurchasingItemType;
-
-    // Public key for verifying signature, in base64 encoding
-    String mSignatureBase64 = null;
-
-    // Billing response codes
-    public static final int BILLING_RESPONSE_RESULT_OK = 0;
-    public static final int BILLING_RESPONSE_RESULT_USER_CANCELED = 1;
-    public static final int BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE = 3;
-    public static final int BILLING_RESPONSE_RESULT_ITEM_UNAVAILABLE = 4;
-    public static final int BILLING_RESPONSE_RESULT_DEVELOPER_ERROR = 5;
-    public static final int BILLING_RESPONSE_RESULT_ERROR = 6;
-    public static final int BILLING_RESPONSE_RESULT_ITEM_ALREADY_OWNED = 7;
-    public static final int BILLING_RESPONSE_RESULT_ITEM_NOT_OWNED = 8;
-
-    // IAB Helper error codes
-    public static final int IABHELPER_ERROR_BASE = -1000;
-    public static final int IABHELPER_REMOTE_EXCEPTION = -1001;
-    public static final int IABHELPER_BAD_RESPONSE = -1002;
-    public static final int IABHELPER_VERIFICATION_FAILED = -1003;
-    public static final int IABHELPER_SEND_INTENT_FAILED = -1004;
-    public static final int IABHELPER_USER_CANCELLED = -1005;
-    public static final int IABHELPER_UNKNOWN_PURCHASE_RESPONSE = -1006;
-    public static final int IABHELPER_MISSING_TOKEN = -1007;
-    public static final int IABHELPER_UNKNOWN_ERROR = -1008;
-    public static final int IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE = -1009;
-    public static final int IABHELPER_INVALID_CONSUMPTION = -1010;
-
-    // Keys for the responses from InAppBillingService
-    public static final String RESPONSE_CODE = "RESPONSE_CODE";
-    public static final String RESPONSE_GET_SKU_DETAILS_LIST = "DETAILS_LIST";
-    public static final String RESPONSE_BUY_INTENT = "BUY_INTENT";
-    public static final String RESPONSE_INAPP_PURCHASE_DATA = "INAPP_PURCHASE_DATA";
-    public static final String RESPONSE_INAPP_SIGNATURE = "INAPP_DATA_SIGNATURE";
-    public static final String RESPONSE_INAPP_ITEM_LIST = "INAPP_PURCHASE_ITEM_LIST";
-    public static final String RESPONSE_INAPP_PURCHASE_DATA_LIST = "INAPP_PURCHASE_DATA_LIST";
-    public static final String RESPONSE_INAPP_SIGNATURE_LIST = "INAPP_DATA_SIGNATURE_LIST";
-    public static final String INAPP_CONTINUATION_TOKEN = "INAPP_CONTINUATION_TOKEN";
-
-    // Item types
-    public static final String ITEM_TYPE_INAPP = "inapp";
-    public static final String ITEM_TYPE_SUBS = "subs";
-
-    // some fields on the getSkuDetails response bundle
-    public static final String GET_SKU_DETAILS_ITEM_LIST = "ITEM_ID_LIST";
-    public static final String GET_SKU_DETAILS_ITEM_TYPE_LIST = "ITEM_TYPE_LIST";
-
-    /**
-     * Creates an instance. After creation, it will not yet be ready to use. You must perform
-     * setup by calling {@link #startSetup} and wait for setup to complete. This constructor does not
-     * block and is safe to call from a UI thread.
-     *
-     * @param ctx             Your application or Activity context. Needed to bind to the in-app billing service.
-     * @param base64PublicKey Your application's public key, encoded in base64.
-     *                        This is used for verification of purchase signatures. You can find your app's base64-encoded
-     *                        public key in your application's page on Google Play Developer Console. Note that this
-     *                        is NOT your "developer public key".
-     */
-    public IabHelper(Context ctx, String base64PublicKey) {
-        mContext = ctx.getApplicationContext();
-        mSignatureBase64 = base64PublicKey;
-        logDebug("IAB helper created.");
-    }
-
-    /**
-     * Enables or disable debug logging through LogCat.
-     */
-    public void enableDebugLogging(boolean enable, String tag) {
-        checkNotDisposed();
-        mDebugLog = enable;
-        mDebugTag = tag;
-    }
-
-    public void enableDebugLogging(boolean enable) {
-        checkNotDisposed();
-        mDebugLog = enable;
-    }
-
-    /**
-     * Callback for setup process. This listener's {@link #onIabSetupFinished} method is called
-     * when the setup process is complete.
-     */
-    public interface OnIabSetupFinishedListener {
-        /**
-         * Called to notify that setup is complete.
-         *
-         * @param result The result of the setup process.
-         */
-        public void onIabSetupFinished(IabResult result);
-    }
-
-    /**
-     * Starts the setup process. This will start up the setup process asynchronously.
-     * You will be notified through the listener when the setup process is complete.
-     * This method is safe to call from a UI thread.
-     *
-     * @param listener The listener to notify when the setup process is complete.
-     */
-    public void startSetup(final OnIabSetupFinishedListener listener) {
-        // If already set up, can't do it again.
-        checkNotDisposed();
-        if (mSetupDone) throw new IllegalStateException("IAB helper is already set up.");
-
-        // Connection to IAB service
-        logDebug("Starting in-app billing setup.");
-        mServiceConn = new ServiceConnection() {
-            @Override
-            public void onServiceDisconnected(ComponentName name) {
-                logDebug("Billing service disconnected.");
-                mService = null;
-            }
-
-            @Override
-            public void onServiceConnected(ComponentName name, IBinder service) {
-                if (mDisposed) return;
-                logDebug("Billing service connected.");
-                mService = IInAppBillingService.Stub.asInterface(service);
-                String packageName = mContext.getPackageName();
-                try {
-                    logDebug("Checking for in-app billing 3 support.");
-
-                    // check for in-app billing v3 support
-                    int response = mService.isBillingSupported(3, packageName, ITEM_TYPE_INAPP);
-                    if (response != BILLING_RESPONSE_RESULT_OK) {
-                        if (listener != null) listener.onIabSetupFinished(new IabResult(response,
-                                "Error checking for billing v3 support."));
-
-                        // if in-app purchases aren't supported, neither are subscriptions.
-                        mSubscriptionsSupported = false;
-                        return;
-                    }
-                    logDebug("In-app billing version 3 supported for " + packageName);
-
-                    // check for v3 subscriptions support
-                    response = mService.isBillingSupported(3, packageName, ITEM_TYPE_SUBS);
-                    if (response == BILLING_RESPONSE_RESULT_OK) {
-                        logDebug("Subscriptions AVAILABLE.");
-                        mSubscriptionsSupported = true;
-                    } else {
-                        logDebug("Subscriptions NOT AVAILABLE. Response: " + response);
-                    }
-
-                    mSetupDone = true;
-                } catch (RemoteException e) {
-                    if (listener != null) {
-                        listener.onIabSetupFinished(new IabResult(IABHELPER_REMOTE_EXCEPTION,
-                                "RemoteException while setting up in-app billing."));
-                    }
-                    e.printStackTrace();
-                    return;
-                }
-
-                if (listener != null) {
-                    listener.onIabSetupFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Setup successful."));
-                }
-            }
-        };
-
-        Intent serviceIntent = new Intent("com.android.vending.billing.InAppBillingService.BIND");
-        serviceIntent.setPackage("com.android.vending");
-        List<ResolveInfo> ri = mContext.getPackageManager().queryIntentServices(serviceIntent, 0);
-        if (ri != null && !ri.isEmpty()) {
-            // service available to handle that Intent
-            mIsBound = mContext.bindService(serviceIntent, mServiceConn, Context.BIND_AUTO_CREATE);
-        } else {
-            // no service available to handle that Intent
-            if (listener != null) {
-                listener.onIabSetupFinished(
-                        new IabResult(BILLING_RESPONSE_RESULT_BILLING_UNAVAILABLE,
-                                "Billing service unavailable on device.")
-                );
-            }
-        }
-    }
-
-    /**
-     * Dispose of object, releasing resources. It's very important to call this
-     * method when you are done with this object. It will release any resources
-     * used by it such as service connections. Naturally, once the object is
-     * disposed of, it can't be used again.
-     */
-    public void dispose() {
-        logDebug("Disposing.");
-        mSetupDone = false;
-        if (mServiceConn != null) {
-            logDebug("Unbinding from service.");
-            if (mContext != null && mIsBound) {
-                mContext.unbindService(mServiceConn);
-            }
-        }
-        mDisposed = true;
-        mContext = null;
-        mServiceConn = null;
-        mService = null;
-        mPurchaseListener = null;
-    }
-
-    private void checkNotDisposed() {
-        if (mDisposed)
-            throw new IllegalStateException("IabHelper was disposed of, so it cannot be used.");
-    }
-
-    /**
-     * Returns whether subscriptions are supported.
-     */
-    public boolean subscriptionsSupported() {
-        checkNotDisposed();
-        return mSubscriptionsSupported;
-    }
-
-
-    /**
-     * Callback that notifies when a purchase is finished.
-     */
-    public interface OnIabPurchaseFinishedListener {
-        /**
-         * Called to notify that an in-app purchase finished. If the purchase was successful,
-         * then the sku parameter specifies which item was purchased. If the purchase failed,
-         * the sku and extraData parameters may or may not be null, depending on how far the purchase
-         * process went.
-         *
-         * @param result The result of the purchase.
-         * @param info   The purchase information (null if purchase failed)
-         */
-        public void onIabPurchaseFinished(IabResult result, Purchase info);
-    }
-
-    // The listener registered on launchPurchaseFlow, which we have to call back when
-    // the purchase finishes
-    OnIabPurchaseFinishedListener mPurchaseListener;
-
-    public void launchPurchaseFlow(Activity act, String sku, int requestCode, OnIabPurchaseFinishedListener listener) {
-        launchPurchaseFlow(act, sku, requestCode, listener, "");
-    }
-
-    public void launchPurchaseFlow(Activity act, String sku, int requestCode,
-                                   OnIabPurchaseFinishedListener listener, String extraData) {
-        launchPurchaseFlow(act, sku, ITEM_TYPE_INAPP, requestCode, listener, extraData);
-    }
-
-    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
-                                               OnIabPurchaseFinishedListener listener) {
-        launchSubscriptionPurchaseFlow(act, sku, requestCode, listener, "");
-    }
-
-    public void launchSubscriptionPurchaseFlow(Activity act, String sku, int requestCode,
-                                               OnIabPurchaseFinishedListener listener, String extraData) {
-        launchPurchaseFlow(act, sku, ITEM_TYPE_SUBS, requestCode, listener, extraData);
-    }
-
-    /**
-     * Initiate the UI flow for an in-app purchase. Call this method to initiate an in-app purchase,
-     * which will involve bringing up the Google Play screen. The calling activity will be paused while
-     * the user interacts with Google Play, and the result will be delivered via the activity's
-     * {@link android.app.Activity#onActivityResult} method, at which point you must call
-     * this object's {@link #handleActivityResult} method to continue the purchase flow. This method
-     * MUST be called from the UI thread of the Activity.
-     *
-     * @param act         The calling activity.
-     * @param sku         The sku of the item to purchase.
-     * @param itemType    indicates if it's a product or a subscription (ITEM_TYPE_INAPP or ITEM_TYPE_SUBS)
-     * @param requestCode A request code (to differentiate from other responses --
-     *                    as in {@link android.app.Activity#startActivityForResult}).
-     * @param listener    The listener to notify when the purchase process finishes
-     * @param extraData   Extra data (developer payload), which will be returned with the purchase data
-     *                    when the purchase completes. This extra data will be permanently bound to that purchase
-     *                    and will always be returned when the purchase is queried.
-     */
-    public void launchPurchaseFlow(Activity act, String sku, String itemType, int requestCode,
-                                   OnIabPurchaseFinishedListener listener, String extraData) {
-        checkNotDisposed();
-        checkSetupDone("launchPurchaseFlow");
-        flagStartAsync("launchPurchaseFlow");
-        IabResult result;
-
-        if (itemType.equals(ITEM_TYPE_SUBS) && !mSubscriptionsSupported) {
-            IabResult r = new IabResult(IABHELPER_SUBSCRIPTIONS_NOT_AVAILABLE,
-                    "Subscriptions are not available.");
-            flagEndAsync();
-            if (listener != null) listener.onIabPurchaseFinished(r, null);
-            return;
-        }
-
-        try {
-            logDebug("Constructing buy intent for " + sku + ", item type: " + itemType);
-            Bundle buyIntentBundle = mService.getBuyIntent(3, mContext.getPackageName(), sku, itemType, extraData);
-            int response = getResponseCodeFromBundle(buyIntentBundle);
-            if (response != BILLING_RESPONSE_RESULT_OK) {
-                logError("Unable to buy item, Error response: " + getResponseDesc(response));
-                flagEndAsync();
-                result = new IabResult(response, "Unable to buy item");
-                if (listener != null) listener.onIabPurchaseFinished(result, null);
-                return;
-            }
-
-            PendingIntent pendingIntent = buyIntentBundle.getParcelable(RESPONSE_BUY_INTENT);
-            logDebug("Launching buy intent for " + sku + ". Request code: " + requestCode);
-            mRequestCode = requestCode;
-            mPurchaseListener = listener;
-            mPurchasingItemType = itemType;
-            act.startIntentSenderForResult(pendingIntent.getIntentSender(),
-                    requestCode, new Intent(),
-                    0, 0,
-                    0);
-        } catch (SendIntentException e) {
-            logError("SendIntentException while launching purchase flow for sku " + sku);
-            e.printStackTrace();
-            flagEndAsync();
-
-            result = new IabResult(IABHELPER_SEND_INTENT_FAILED, "Failed to send intent.");
-            if (listener != null) listener.onIabPurchaseFinished(result, null);
-        } catch (RemoteException e) {
-            logError("RemoteException while launching purchase flow for sku " + sku);
-            e.printStackTrace();
-            flagEndAsync();
-
-            result = new IabResult(IABHELPER_REMOTE_EXCEPTION, "Remote exception while starting purchase flow");
-            if (listener != null) listener.onIabPurchaseFinished(result, null);
-        }
-    }
-
-    /**
-     * Handles an activity result that's part of the purchase flow in in-app billing. If you
-     * are calling {@link #launchPurchaseFlow}, then you must call this method from your
-     * Activity's {@link android.app.Activity@onActivityResult} method. This method
-     * MUST be called from the UI thread of the Activity.
-     *
-     * @param requestCode The requestCode as you received it.
-     * @param resultCode  The resultCode as you received it.
-     * @param data        The data (Intent) as you received it.
-     * @return Returns true if the result was related to a purchase flow and was handled;
-     * false if the result was not related to a purchase, in which case you should
-     * handle it normally.
-     */
-    public boolean handleActivityResult(int requestCode, int resultCode, Intent data) {
-        IabResult result;
-        if (requestCode != mRequestCode) return false;
-
-        checkNotDisposed();
-        checkSetupDone("handleActivityResult");
-
-        // end of async purchase operation that started on launchPurchaseFlow
-        flagEndAsync();
-
-        if (data == null) {
-            logError("Null data in IAB activity result.");
-            result = new IabResult(IABHELPER_BAD_RESPONSE, "Null data in IAB result");
-            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
-            return true;
-        }
-
-        int responseCode = getResponseCodeFromIntent(data);
-        String purchaseData = data.getStringExtra(RESPONSE_INAPP_PURCHASE_DATA);
-        String dataSignature = data.getStringExtra(RESPONSE_INAPP_SIGNATURE);
-
-        if (resultCode == Activity.RESULT_OK && responseCode == BILLING_RESPONSE_RESULT_OK) {
-            logDebug("Successful resultcode from purchase activity.");
-            logDebug("Purchase data: " + purchaseData);
-            logDebug("Data signature: " + dataSignature);
-            logDebug("Extras: " + data.getExtras());
-            logDebug("Expected item type: " + mPurchasingItemType);
-
-            if (purchaseData == null || dataSignature == null) {
-                logError("BUG: either purchaseData or dataSignature is null.");
-                logDebug("Extras: " + data.getExtras().toString());
-                result = new IabResult(IABHELPER_UNKNOWN_ERROR, "IAB returned null purchaseData or dataSignature");
-                if (mPurchaseListener != null)
-                    mPurchaseListener.onIabPurchaseFinished(result, null);
-                return true;
-            }
-
-            @SuppressWarnings("UnusedAssignment") Purchase purchase = null;
-            try {
-                purchase = new Purchase(mPurchasingItemType, purchaseData, dataSignature);
-                String sku = purchase.getSku();
-
-                // Verify signature
-                if (!Security.verifyPurchase(mSignatureBase64, purchaseData, dataSignature)) {
-                    logError("Purchase signature verification FAILED for sku " + sku);
-                    result = new IabResult(IABHELPER_VERIFICATION_FAILED, "Signature verification failed for sku " + sku);
-                    if (mPurchaseListener != null)
-                        mPurchaseListener.onIabPurchaseFinished(result, purchase);
-                    return true;
-                }
-                logDebug("Purchase signature successfully verified.");
-            } catch (JSONException e) {
-                logError("Failed to parse purchase data.");
-                e.printStackTrace();
-                result = new IabResult(IABHELPER_BAD_RESPONSE, "Failed to parse purchase data.");
-                if (mPurchaseListener != null)
-                    mPurchaseListener.onIabPurchaseFinished(result, null);
-                return true;
-            }
-
-            if (mPurchaseListener != null) {
-                mPurchaseListener.onIabPurchaseFinished(new IabResult(BILLING_RESPONSE_RESULT_OK, "Success"), purchase);
-            }
-        } else if (resultCode == Activity.RESULT_OK) {
-            // result code was OK, but in-app billing response was not OK.
-            logDebug("Result code was OK but in-app billing response was not OK: " + getResponseDesc(responseCode));
-            if (mPurchaseListener != null) {
-                result = new IabResult(responseCode, "Problem purchashing item.");
-                mPurchaseListener.onIabPurchaseFinished(result, null);
-            }
-        } else if (resultCode == Activity.RESULT_CANCELED) {
-            logDebug("Purchase canceled - Response: " + getResponseDesc(responseCode));
-            result = new IabResult(IABHELPER_USER_CANCELLED, "User canceled.");
-            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
-        } else {
-            logError("Purchase failed. Result code: " + Integer.toString(resultCode)
-                    + ". Response: " + getResponseDesc(responseCode));
-            result = new IabResult(IABHELPER_UNKNOWN_PURCHASE_RESPONSE, "Unknown purchase response.");
-            if (mPurchaseListener != null) mPurchaseListener.onIabPurchaseFinished(result, null);
-        }
-        return true;
-    }
-
-    public Inventory queryInventory(boolean querySkuDetails, List<String> moreSkus) throws IabException {
-        return queryInventory(querySkuDetails, moreSkus, null);
-    }
-
-    /**
-     * Queries the inventory. This will query all owned items from the server, as well as
-     * information on additional skus, if specified. This method may block or take long to execute.
-     * Do not call from a UI thread. For that, use the non-blocking version {@link #refreshInventoryAsync}.
-     *
-     * @param querySkuDetails if true, SKU details (price, description, etc) will be queried as well
-     *                        as purchase information.
-     * @param moreItemSkus    additional PRODUCT skus to query information on, regardless of ownership.
-     *                        Ignored if null or if querySkuDetails is false.
-     * @param moreSubsSkus    additional SUBSCRIPTIONS skus to query information on, regardless of ownership.
-     *                        Ignored if null or if querySkuDetails is false.
-     * @throws IabException if a problem occurs while refreshing the inventory.
-     */
-    public Inventory queryInventory(boolean querySkuDetails, List<String> moreItemSkus,
-                                    List<String> moreSubsSkus) throws IabException {
-        checkNotDisposed();
-        checkSetupDone("queryInventory");
-        try {
-            Inventory inv = new Inventory();
-            int r = queryPurchases(inv, ITEM_TYPE_INAPP);
-            if (r != BILLING_RESPONSE_RESULT_OK) {
-                throw new IabException(r, "Error refreshing inventory (querying owned items).");
-            }
-
-            if (querySkuDetails) {
-                r = querySkuDetails(ITEM_TYPE_INAPP, inv, moreItemSkus);
-                if (r != BILLING_RESPONSE_RESULT_OK) {
-                    throw new IabException(r, "Error refreshing inventory (querying prices of items).");
-                }
-            }
-
-            // if subscriptions are supported, then also query for subscriptions
-            if (mSubscriptionsSupported) {
-                r = queryPurchases(inv, ITEM_TYPE_SUBS);
-                if (r != BILLING_RESPONSE_RESULT_OK) {
-                    throw new IabException(r, "Error refreshing inventory (querying owned subscriptions).");
-                }
-
-                if (querySkuDetails) {
-                    r = querySkuDetails(ITEM_TYPE_SUBS, inv, moreItemSkus);
-                    if (r != BILLING_RESPONSE_RESULT_OK) {
-                        throw new IabException(r, "Error refreshing inventory (querying prices of subscriptions).");
-                    }
-                }
-            }
-
-            return inv;
-        } catch (RemoteException e) {
-            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while refreshing inventory.", e);
-        } catch (JSONException e) {
-            throw new IabException(IABHELPER_BAD_RESPONSE, "Error parsing JSON response while refreshing inventory.", e);
-        }
-    }
-
-    /**
-     * Listener that notifies when an inventory query operation completes.
-     */
-    public interface QueryInventoryFinishedListener {
-        /**
-         * Called to notify that an inventory query operation completed.
-         *
-         * @param result The result of the operation.
-         * @param inv    The inventory.
-         */
-        public void onQueryInventoryFinished(IabResult result, Inventory inv);
-    }
-
-
-    /**
-     * Asynchronous wrapper for inventory query. This will perform an inventory
-     * query as described in {@link #queryInventory}, but will do so asynchronously
-     * and call back the specified listener upon completion. This method is safe to
-     * call from a UI thread.
-     *
-     * @param querySkuDetails as in {@link #queryInventory}
-     * @param moreSkus        as in {@link #queryInventory}
-     * @param listener        The listener to notify when the refresh operation completes.
-     */
-    public void queryInventoryAsync(final boolean querySkuDetails,
-                                    final List<String> moreSkus,
-                                    final QueryInventoryFinishedListener listener) {
-        final Handler handler = new Handler();
-        checkNotDisposed();
-        checkSetupDone("queryInventory");
-        flagStartAsync("refresh inventory");
-        (new Thread(new Runnable() {
-            public void run() {
-                IabResult result = new IabResult(BILLING_RESPONSE_RESULT_OK, "Inventory refresh successful.");
-                Inventory inv = null;
-                try {
-                    inv = queryInventory(querySkuDetails, moreSkus);
-                } catch (IabException ex) {
-                    result = ex.getResult();
-                }
-
-                flagEndAsync();
-
-                final IabResult result_f = result;
-                final Inventory inv_f = inv;
-                if (!mDisposed && listener != null) {
-                    handler.post(new Runnable() {
-                        public void run() {
-                            listener.onQueryInventoryFinished(result_f, inv_f);
-                        }
-                    });
-                }
-            }
-        })).start();
-    }
-
-    public void queryInventoryAsync(QueryInventoryFinishedListener listener) {
-        queryInventoryAsync(true, null, listener);
-    }
-
-    public void queryInventoryAsync(boolean querySkuDetails, QueryInventoryFinishedListener listener) {
-        queryInventoryAsync(querySkuDetails, null, listener);
-    }
-
-
-    /**
-     * Consumes a given in-app product. Consuming can only be done on an item
-     * that's owned, and as a result of consumption, the user will no longer own it.
-     * This method may block or take long to return. Do not call from the UI thread.
-     * For that, see {@link #consumeAsync}.
-     *
-     * @param itemInfo The PurchaseInfo that represents the item to consume.
-     * @throws IabException if there is a problem during consumption.
-     */
-    void consume(Purchase itemInfo) throws IabException {
-        checkNotDisposed();
-        checkSetupDone("consume");
-
-        if (!itemInfo.mItemType.equals(ITEM_TYPE_INAPP)) {
-            throw new IabException(IABHELPER_INVALID_CONSUMPTION,
-                    "Items of type '" + itemInfo.mItemType + "' can't be consumed.");
-        }
-
-        try {
-            String token = itemInfo.getToken();
-            String sku = itemInfo.getSku();
-            if (token == null || token.equals("")) {
-                logError("Can't consume " + sku + ". No token.");
-                throw new IabException(IABHELPER_MISSING_TOKEN, "PurchaseInfo is missing token for sku: "
-                        + sku + " " + itemInfo);
-            }
-
-            logDebug("Consuming sku: " + sku + ", token: " + token);
-            int response = mService.consumePurchase(3, mContext.getPackageName(), token);
-            if (response == BILLING_RESPONSE_RESULT_OK) {
-                logDebug("Successfully consumed sku: " + sku);
-            } else {
-                logDebug("Error consuming consuming sku " + sku + ". " + getResponseDesc(response));
-                throw new IabException(response, "Error consuming sku " + sku);
-            }
-        } catch (RemoteException e) {
-            throw new IabException(IABHELPER_REMOTE_EXCEPTION, "Remote exception while consuming. PurchaseInfo: " + itemInfo, e);
-        }
-    }
-
-    /**
-     * Callback that notifies when a consumption operation finishes.
-     */
-    public interface OnConsumeFinishedListener {
-        /**
-         * Called to notify that a consumption has finished.
-         *
-         * @param purchase The purchase that was (or was to be) consumed.
-         * @param result   The result of the consumption operation.
-         */
-        public void onConsumeFinished(Purchase purchase, IabResult result);
-    }
-
-    /**
-     * Callback that notifies when a multi-item consumption operation finishes.
-     */
-    public interface OnConsumeMultiFinishedListener {
-        /**
-         * Called to notify that a consumption of multiple items has finished.
-         *
-         * @param purchases The purchases that were (or were to be) consumed.
-         * @param results   The results of each consumption operation, corresponding to each
-         *                  sku.
-         */
-        public void onConsumeMultiFinished(List<Purchase> purchases, List<IabResult> results);
-    }
-
-    /**
-     * Asynchronous wrapper to item consumption. Works like {@link #consume}, but
-     * performs the consumption in the background and notifies completion through
-     * the provided listener. This method is safe to call from a UI thread.
-     *
-     * @param purchase The purchase to be consumed.
-     * @param listener The listener to notify when the consumption operation finishes.
-     */
-    public void consumeAsync(Purchase purchase, OnConsumeFinishedListener listener) {
-        checkNotDisposed();
-        checkSetupDone("consume");
-        List<Purchase> purchases = new ArrayList<>();
-        purchases.add(purchase);
-        consumeAsyncInternal(purchases, listener, null);
-    }
-
-    /**
-     * Same as {@link consumeAsync}, but for multiple items at once.
-     *
-     * @param purchases The list of PurchaseInfo objects representing the purchases to consume.
-     * @param listener  The listener to notify when the consumption operation finishes.
-     */
-    public void consumeAsync(List<Purchase> purchases, OnConsumeMultiFinishedListener listener) {
-        checkNotDisposed();
-        checkSetupDone("consume");
-        consumeAsyncInternal(purchases, null, listener);
-    }
-
-    /**
-     * Returns a human-readable description for the given response code.
-     *
-     * @param code The response code
-     * @return A human-readable string explaining the result code.
-     * It also includes the result code numerically.
-     */
-    public static String getResponseDesc(int code) {
-        String[] iab_msgs = ("0:OK/1:User Canceled/2:Unknown/" +
-                "3:Billing Unavailable/4:Item unavailable/" +
-                "5:Developer Error/6:Error/7:Item Already Owned/" +
-                "8:Item not owned").split("/");
-        String[] iabhelper_msgs = ("0:OK/-1001:Remote exception during initialization/" +
-                "-1002:Bad response received/" +
-                "-1003:Purchase signature verification failed/" +
-                "-1004:Send intent failed/" +
-                "-1005:User cancelled/" +
-                "-1006:Unknown purchase response/" +
-                "-1007:Missing token/" +
-                "-1008:Unknown error/" +
-                "-1009:Subscriptions not available/" +
-                "-1010:Invalid consumption attempt").split("/");
-
-        if (code <= IABHELPER_ERROR_BASE) {
-            int index = IABHELPER_ERROR_BASE - code;
-            if (index >= 0 && index < iabhelper_msgs.length) return iabhelper_msgs[index];
-            else return String.valueOf(code) + ":Unknown IAB Helper Error";
-        } else if (code < 0 || code >= iab_msgs.length)
-            return String.valueOf(code) + ":Unknown";
-        else
-            return iab_msgs[code];
-    }
-
-
-    // Checks that setup was done; if not, throws an exception.
-    void checkSetupDone(String operation) {
-        if (!mSetupDone) {
-            logError("Illegal state for operation (" + operation + "): IAB helper is not set up.");
-            throw new IllegalStateException("IAB helper is not set up. Can't perform operation: " + operation);
-        }
-    }
-
-    // Workaround to bug where sometimes response codes come as Long instead of Integer
-    int getResponseCodeFromBundle(Bundle b) {
-        Object o = b.get(RESPONSE_CODE);
-        if (o == null) {
-            logDebug("Bundle with null response code, assuming OK (known issue)");
-            return BILLING_RESPONSE_RESULT_OK;
-        } else if (o instanceof Integer) return (Integer) o;
-        else if (o instanceof Long) return (int) ((Long) o).longValue();
-        else {
-            logError("Unexpected type for bundle response code.");
-            logError(o.getClass().getName());
-            throw new RuntimeException("Unexpected type for bundle response code: " + o.getClass().getName());
-        }
-    }
-
-    // Workaround to bug where sometimes response codes come as Long instead of Integer
-    int getResponseCodeFromIntent(Intent i) {
-        Object o = i.getExtras().get(RESPONSE_CODE);
-        if (o == null) {
-            logError("Intent with no response code, assuming OK (known issue)");
-            return BILLING_RESPONSE_RESULT_OK;
-        } else if (o instanceof Integer) return (Integer) o;
-        else if (o instanceof Long) return (int) ((Long) o).longValue();
-        else {
-            logError("Unexpected type for intent response code.");
-            logError(o.getClass().getName());
-            throw new RuntimeException("Unexpected type for intent response code: " + o.getClass().getName());
-        }
-    }
-
-    void flagStartAsync(String operation) {
-        if (mAsyncInProgress) throw new IllegalStateException("Can't start async operation (" +
-                operation + ") because another async operation(" + mAsyncOperation + ") is in progress.");
-        mAsyncOperation = operation;
-        mAsyncInProgress = true;
-        logDebug("Starting async operation: " + operation);
-    }
-
-    void flagEndAsync() {
-        logDebug("Ending async operation: " + mAsyncOperation);
-        mAsyncOperation = "";
-        mAsyncInProgress = false;
-    }
-
-
-    int queryPurchases(Inventory inv, String itemType) throws JSONException, RemoteException {
-        // Query purchases
-        logDebug("Querying owned items, item type: " + itemType);
-        logDebug("Package name: " + mContext.getPackageName());
-        boolean verificationFailed = false;
-        String continueToken = null;
-
-        do {
-            logDebug("Calling getPurchases with continuation token: " + continueToken);
-            Bundle ownedItems = mService.getPurchases(3, mContext.getPackageName(),
-                    itemType, continueToken);
-
-            int response = getResponseCodeFromBundle(ownedItems);
-            logDebug("Owned items response: " + String.valueOf(response));
-            if (response != BILLING_RESPONSE_RESULT_OK) {
-                logDebug("getPurchases() failed: " + getResponseDesc(response));
-                return response;
-            }
-            if (!ownedItems.containsKey(RESPONSE_INAPP_ITEM_LIST)
-                    || !ownedItems.containsKey(RESPONSE_INAPP_PURCHASE_DATA_LIST)
-                    || !ownedItems.containsKey(RESPONSE_INAPP_SIGNATURE_LIST)) {
-                logError("Bundle returned from getPurchases() doesn't contain required fields.");
-                return IABHELPER_BAD_RESPONSE;
-            }
-
-            ArrayList<String> ownedSkus = ownedItems.getStringArrayList(
-                    RESPONSE_INAPP_ITEM_LIST);
-            ArrayList<String> purchaseDataList = ownedItems.getStringArrayList(
-                    RESPONSE_INAPP_PURCHASE_DATA_LIST);
-            ArrayList<String> signatureList = ownedItems.getStringArrayList(
-                    RESPONSE_INAPP_SIGNATURE_LIST);
-
-            for (int i = 0; i < purchaseDataList.size(); ++i) {
-                String purchaseData = purchaseDataList.get(i);
-                String signature = signatureList.get(i);
-                String sku = ownedSkus.get(i);
-                if (Security.verifyPurchase(mSignatureBase64, purchaseData, signature)) {
-                    logDebug("Sku is owned: " + sku);
-                    Purchase purchase = new Purchase(itemType, purchaseData, signature);
-
-                    if (TextUtils.isEmpty(purchase.getToken())) {
-                        logWarn("BUG: empty/null token!");
-                        logDebug("Purchase data: " + purchaseData);
-                    }
-
-                    // Record ownership and token
-                    inv.addPurchase(purchase);
-                } else {
-                    logWarn("Purchase signature verification **FAILED**. Not adding item.");
-                    logDebug("   Purchase data: " + purchaseData);
-                    logDebug("   Signature: " + signature);
-                    verificationFailed = true;
-                }
-            }
-
-            continueToken = ownedItems.getString(INAPP_CONTINUATION_TOKEN);
-            logDebug("Continuation token: " + continueToken);
-        } while (!TextUtils.isEmpty(continueToken));
-
-        return verificationFailed ? IABHELPER_VERIFICATION_FAILED : BILLING_RESPONSE_RESULT_OK;
-    }
-
-    int querySkuDetails(String itemType, Inventory inv, List<String> moreSkus)
-            throws RemoteException, JSONException {
-        logDebug("Querying SKU details.");
-        ArrayList<String> skuList = new ArrayList<>();
-        skuList.addAll(inv.getAllOwnedSkus(itemType));
-        if (moreSkus != null) {
-            for (String sku : moreSkus) {
-                if (!skuList.contains(sku)) {
-                    skuList.add(sku);
-                }
-            }
-        }
-
-        if (skuList.size() == 0) {
-            logDebug("queryPrices: nothing to do because there are no SKUs.");
-            return BILLING_RESPONSE_RESULT_OK;
-        }
-
-        Bundle querySkus = new Bundle();
-        querySkus.putStringArrayList(GET_SKU_DETAILS_ITEM_LIST, skuList);
-        Bundle skuDetails = mService.getSkuDetails(3, mContext.getPackageName(),
-                itemType, querySkus);
-
-        if (!skuDetails.containsKey(RESPONSE_GET_SKU_DETAILS_LIST)) {
-            int response = getResponseCodeFromBundle(skuDetails);
-            if (response != BILLING_RESPONSE_RESULT_OK) {
-                logDebug("getSkuDetails() failed: " + getResponseDesc(response));
-                return response;
-            } else {
-                logError("getSkuDetails() returned a bundle with neither an error nor a detail list.");
-                return IABHELPER_BAD_RESPONSE;
-            }
-        }
-
-        ArrayList<String> responseList = skuDetails.getStringArrayList(
-                RESPONSE_GET_SKU_DETAILS_LIST);
-
-        for (String thisResponse : responseList) {
-            SkuDetails d = new SkuDetails(itemType, thisResponse);
-            logDebug("Got sku details: " + d);
-            inv.addSkuDetails(d);
-        }
-        return BILLING_RESPONSE_RESULT_OK;
-    }
-
-
-    void consumeAsyncInternal(final List<Purchase> purchases,
-                              final OnConsumeFinishedListener singleListener,
-                              final OnConsumeMultiFinishedListener multiListener) {
-        final Handler handler = new Handler();
-        flagStartAsync("consume");
-        (new Thread(new Runnable() {
-            public void run() {
-                final List<IabResult> results = new ArrayList<>();
-                for (Purchase purchase : purchases) {
-                    try {
-                        consume(purchase);
-                        results.add(new IabResult(BILLING_RESPONSE_RESULT_OK, "Successful consume of sku " + purchase.getSku()));
-                    } catch (IabException ex) {
-                        results.add(ex.getResult());
-                    }
-                }
-
-                flagEndAsync();
-                if (!mDisposed && singleListener != null) {
-                    handler.post(new Runnable() {
-                        public void run() {
-                            singleListener.onConsumeFinished(purchases.get(0), results.get(0));
-                        }
-                    });
-                }
-                if (!mDisposed && multiListener != null) {
-                    handler.post(new Runnable() {
-                        public void run() {
-                            multiListener.onConsumeMultiFinished(purchases, results);
-                        }
-                    });
-                }
-            }
-        })).start();
-    }
-
-    void logDebug(String msg) {
-        if (mDebugLog) Log.d(mDebugTag, msg);
-    }
-
-    void logError(String msg) {
-        Log.e(mDebugTag, "In-app billing error: " + msg);
-    }
-
-    void logWarn(String msg) {
-        Log.w(mDebugTag, "In-app billing warning: " + msg);
-    }
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/iab/utils/IabResult.java b/project/app/src/main/java/com/achep/acdisplay/iab/utils/IabResult.java
deleted file mode 100644
index f5ef0128..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/iab/utils/IabResult.java
+++ /dev/null
@@ -1,59 +0,0 @@
-/* Copyright (c) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.achep.acdisplay.iab.utils;
-
-/**
- * Represents the result of an in-app billing operation.
- * A result is composed of a response code (an integer) and possibly a
- * message (String). You can get those by calling
- * {@link #getResponse} and {@link #getMessage()}, respectively. You
- * can also inquire whether a result is a success or a failure by
- * calling {@link #isSuccess()} and {@link #isFailure()}.
- */
-public class IabResult {
-    int mResponse;
-    String mMessage;
-
-    public IabResult(int response, String message) {
-        mResponse = response;
-        if (message == null || message.trim().length() == 0) {
-            mMessage = IabHelper.getResponseDesc(response);
-        } else {
-            mMessage = message + " (response: " + IabHelper.getResponseDesc(response) + ")";
-        }
-    }
-
-    public int getResponse() {
-        return mResponse;
-    }
-
-    public String getMessage() {
-        return mMessage;
-    }
-
-    public boolean isSuccess() {
-        return mResponse == IabHelper.BILLING_RESPONSE_RESULT_OK;
-    }
-
-    public boolean isFailure() {
-        return !isSuccess();
-    }
-
-    public String toString() {
-        return "IabResult: " + getMessage();
-    }
-}
-
diff --git a/project/app/src/main/java/com/achep/acdisplay/iab/utils/Inventory.java b/project/app/src/main/java/com/achep/acdisplay/iab/utils/Inventory.java
deleted file mode 100644
index d0e915d7..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/iab/utils/Inventory.java
+++ /dev/null
@@ -1,106 +0,0 @@
-/* Copyright (c) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.achep.acdisplay.iab.utils;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-/**
- * Represents a block of information about in-app items.
- * An Inventory is returned by such methods as {@link IabHelper#queryInventory}.
- */
-public class Inventory {
-    Map<String, SkuDetails> mSkuMap = new HashMap<>();
-    Map<String, Purchase> mPurchaseMap = new HashMap<>();
-
-    Inventory() {
-    }
-
-    /**
-     * Returns the listing details for an in-app product.
-     */
-    public SkuDetails getSkuDetails(String sku) {
-        return mSkuMap.get(sku);
-    }
-
-    /**
-     * Returns purchase information for a given product, or null if there is no purchase.
-     */
-    public Purchase getPurchase(String sku) {
-        return mPurchaseMap.get(sku);
-    }
-
-    /**
-     * Returns whether or not there exists a purchase of the given product.
-     */
-    public boolean hasPurchase(String sku) {
-        return mPurchaseMap.containsKey(sku);
-    }
-
-    /**
-     * Return whether or not details about the given product are available.
-     */
-    public boolean hasDetails(String sku) {
-        return mSkuMap.containsKey(sku);
-    }
-
-    /**
-     * Erase a purchase (locally) from the inventory, given its product ID. This just
-     * modifies the Inventory object locally and has no effect on the server! This is
-     * useful when you have an existing Inventory object which you know to be up to date,
-     * and you have just consumed an item successfully, which means that erasing its
-     * purchase data from the Inventory you already have is quicker than querying for
-     * a new Inventory.
-     */
-    public void erasePurchase(String sku) {
-        if (mPurchaseMap.containsKey(sku)) mPurchaseMap.remove(sku);
-    }
-
-    /**
-     * Returns a list of all owned product IDs.
-     */
-    List<String> getAllOwnedSkus() {
-        return new ArrayList<>(mPurchaseMap.keySet());
-    }
-
-    /**
-     * Returns a list of all owned product IDs of a given type
-     */
-    List<String> getAllOwnedSkus(String itemType) {
-        List<String> result = new ArrayList<>();
-        for (Purchase p : mPurchaseMap.values()) {
-            if (p.getItemType().equals(itemType)) result.add(p.getSku());
-        }
-        return result;
-    }
-
-    /**
-     * Returns a list of all purchases.
-     */
-    List<Purchase> getAllPurchases() {
-        return new ArrayList<>(mPurchaseMap.values());
-    }
-
-    void addSkuDetails(SkuDetails d) {
-        mSkuMap.put(d.getSku(), d);
-    }
-
-    void addPurchase(Purchase p) {
-        mPurchaseMap.put(p.getSku(), p);
-    }
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/iab/utils/Purchase.java b/project/app/src/main/java/com/achep/acdisplay/iab/utils/Purchase.java
deleted file mode 100644
index 6192db3c..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/iab/utils/Purchase.java
+++ /dev/null
@@ -1,94 +0,0 @@
-/* Copyright (c) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.achep.acdisplay.iab.utils;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
-/**
- * Represents an in-app billing purchase.
- */
-public class Purchase {
-    String mItemType;  // ITEM_TYPE_INAPP or ITEM_TYPE_SUBS
-    String mOrderId;
-    String mPackageName;
-    String mSku;
-    long mPurchaseTime;
-    int mPurchaseState;
-    String mDeveloperPayload;
-    String mToken;
-    String mOriginalJson;
-    String mSignature;
-
-    public Purchase(String itemType, String jsonPurchaseInfo, String signature) throws JSONException {
-        mItemType = itemType;
-        mOriginalJson = jsonPurchaseInfo;
-        JSONObject o = new JSONObject(mOriginalJson);
-        mOrderId = o.optString("orderId");
-        mPackageName = o.optString("packageName");
-        mSku = o.optString("productId");
-        mPurchaseTime = o.optLong("purchaseTime");
-        mPurchaseState = o.optInt("purchaseState");
-        mDeveloperPayload = o.optString("developerPayload");
-        mToken = o.optString("token", o.optString("purchaseToken"));
-        mSignature = signature;
-    }
-
-    public String getItemType() {
-        return mItemType;
-    }
-
-    public String getOrderId() {
-        return mOrderId;
-    }
-
-    public String getPackageName() {
-        return mPackageName;
-    }
-
-    public String getSku() {
-        return mSku;
-    }
-
-    public long getPurchaseTime() {
-        return mPurchaseTime;
-    }
-
-    public int getPurchaseState() {
-        return mPurchaseState;
-    }
-
-    public String getDeveloperPayload() {
-        return mDeveloperPayload;
-    }
-
-    public String getToken() {
-        return mToken;
-    }
-
-    public String getOriginalJson() {
-        return mOriginalJson;
-    }
-
-    public String getSignature() {
-        return mSignature;
-    }
-
-    @Override
-    public String toString() {
-        return "PurchaseInfo(type:" + mItemType + "):" + mOriginalJson;
-    }
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/iab/utils/Security.java b/project/app/src/main/java/com/achep/acdisplay/iab/utils/Security.java
deleted file mode 100644
index a6fe1346..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/iab/utils/Security.java
+++ /dev/null
@@ -1,120 +0,0 @@
-/* Copyright (c) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.achep.acdisplay.iab.utils;
-
-import android.text.TextUtils;
-import android.util.Log;
-
-import java.security.InvalidKeyException;
-import java.security.KeyFactory;
-import java.security.NoSuchAlgorithmException;
-import java.security.PublicKey;
-import java.security.Signature;
-import java.security.SignatureException;
-import java.security.spec.InvalidKeySpecException;
-import java.security.spec.X509EncodedKeySpec;
-
-/**
- * Security-related methods. For a secure implementation, all of this code
- * should be implemented on a server that communicates with the
- * application on the device. For the sake of simplicity and clarity of this
- * example, this code is included here and is executed on the device. If you
- * must verify the purchases on the phone, you should obfuscate this code to
- * make it harder for an attacker to replace the code with stubs that treat all
- * purchases as verified.
- */
-public class Security {
-    private static final String TAG = "IABUtil/Security";
-
-    private static final String KEY_FACTORY_ALGORITHM = "RSA";
-    private static final String SIGNATURE_ALGORITHM = "SHA1withRSA";
-
-    /**
-     * Verifies that the data was signed with the given signature, and returns
-     * the verified purchase. The data is in JSON format and signed
-     * with a private key. The data also contains the {@link PurchaseState}
-     * and product ID of the purchase.
-     *
-     * @param base64PublicKey the base64-encoded public key to use for verifying.
-     * @param signedData      the signed JSON string (signed, not encrypted)
-     * @param signature       the signature for the data, signed with the private key
-     */
-    public static boolean verifyPurchase(String base64PublicKey, String signedData, String signature) {
-        if (TextUtils.isEmpty(signedData) || TextUtils.isEmpty(base64PublicKey) ||
-                TextUtils.isEmpty(signature)) {
-            Log.e(TAG, "Purchase verification failed: missing data.");
-            return false;
-        }
-
-        PublicKey key = Security.generatePublicKey(base64PublicKey);
-        return Security.verify(key, signedData, signature);
-    }
-
-    /**
-     * Generates a PublicKey instance from a string containing the
-     * Base64-encoded public key.
-     *
-     * @param encodedPublicKey Base64-encoded public key
-     * @throws IllegalArgumentException if encodedPublicKey is invalid
-     */
-    public static PublicKey generatePublicKey(String encodedPublicKey) {
-        try {
-            byte[] decodedKey = Base64.decode(encodedPublicKey);
-            KeyFactory keyFactory = KeyFactory.getInstance(KEY_FACTORY_ALGORITHM);
-            return keyFactory.generatePublic(new X509EncodedKeySpec(decodedKey));
-        } catch (NoSuchAlgorithmException e) {
-            throw new RuntimeException(e);
-        } catch (InvalidKeySpecException e) {
-            Log.e(TAG, "Invalid key specification.");
-            throw new IllegalArgumentException(e);
-        } catch (Base64DecoderException e) {
-            Log.e(TAG, "Base64 decoding failed.");
-            throw new IllegalArgumentException(e);
-        }
-    }
-
-    /**
-     * Verifies that the signature from the server matches the computed
-     * signature on the data.  Returns true if the data is correctly signed.
-     *
-     * @param publicKey  public key associated with the developer account
-     * @param signedData signed data from server
-     * @param signature  server signature
-     * @return true if the data and signature match
-     */
-    public static boolean verify(PublicKey publicKey, String signedData, String signature) {
-        Signature sig;
-        try {
-            sig = Signature.getInstance(SIGNATURE_ALGORITHM);
-            sig.initVerify(publicKey);
-            sig.update(signedData.getBytes());
-            if (!sig.verify(Base64.decode(signature))) {
-                Log.e(TAG, "Signature verification failed.");
-                return false;
-            }
-            return true;
-        } catch (NoSuchAlgorithmException e) {
-            Log.e(TAG, "NoSuchAlgorithmException.");
-        } catch (InvalidKeyException e) {
-            Log.e(TAG, "Invalid key specification.");
-        } catch (SignatureException e) {
-            Log.e(TAG, "Signature exception.");
-        } catch (Base64DecoderException e) {
-            Log.e(TAG, "Base64 decoding failed.");
-        }
-        return false;
-    }
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/iab/utils/SkuDetails.java b/project/app/src/main/java/com/achep/acdisplay/iab/utils/SkuDetails.java
deleted file mode 100644
index 0286af4a..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/iab/utils/SkuDetails.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/* Copyright (c) 2012 Google Inc.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *     http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package com.achep.acdisplay.iab.utils;
-
-import org.json.JSONException;
-import org.json.JSONObject;
-
-/**
- * Represents an in-app product's listing details.
- */
-public class SkuDetails {
-    String mItemType;
-    String mSku;
-    String mType;
-    String mPrice;
-    String mTitle;
-    String mDescription;
-    String mJson;
-
-    public SkuDetails(String jsonSkuDetails) throws JSONException {
-        this(IabHelper.ITEM_TYPE_INAPP, jsonSkuDetails);
-    }
-
-    public SkuDetails(String itemType, String jsonSkuDetails) throws JSONException {
-        mItemType = itemType;
-        mJson = jsonSkuDetails;
-        JSONObject o = new JSONObject(mJson);
-        mSku = o.optString("productId");
-        mType = o.optString("type");
-        mPrice = o.optString("price");
-        mTitle = o.optString("title");
-        mDescription = o.optString("description");
-    }
-
-    public String getSku() {
-        return mSku;
-    }
-
-    public String getType() {
-        return mType;
-    }
-
-    public String getPrice() {
-        return mPrice;
-    }
-
-    public String getTitle() {
-        return mTitle;
-    }
-
-    public String getDescription() {
-        return mDescription;
-    }
-
-    @Override
-    public String toString() {
-        return "SkuDetails:" + mJson;
-    }
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/widgets/NotificationView.java b/project/app/src/main/java/com/achep/acdisplay/interfaces/INotificatiable.java
similarity index 81%
rename from project/app/src/main/java/com/achep/acdisplay/widgets/NotificationView.java
rename to project/app/src/main/java/com/achep/acdisplay/interfaces/INotificatiable.java
index 29c1b6ae..385054a3 100644
--- a/project/app/src/main/java/com/achep/acdisplay/widgets/NotificationView.java
+++ b/project/app/src/main/java/com/achep/acdisplay/interfaces/INotificatiable.java
@@ -16,17 +16,20 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.widgets;
+package com.achep.acdisplay.interfaces;
+
+import android.support.annotation.Nullable;
 
 import com.achep.acdisplay.notifications.OpenNotification;
 
 /**
  * Created by Artem on 02.02.14.
  */
-public interface NotificationView {
+public interface INotificatiable {
 
-    public void setNotification(OpenNotification notification);
+    public void setNotification(@Nullable OpenNotification notification);
 
+    @Nullable
     public OpenNotification getNotification();
 
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/interfaces/IOnLowMemory.java b/project/app/src/main/java/com/achep/acdisplay/interfaces/IOnLowMemory.java
deleted file mode 100644
index f3cb1324..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/interfaces/IOnLowMemory.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package com.achep.acdisplay.interfaces;
-
-/**
- * Created by Artem Chepurnoy on 27.08.2014.
- */
-public interface IOnLowMemory {
-
-    public void onLowMemory();
-
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/notifications/Action.java b/project/app/src/main/java/com/achep/acdisplay/notifications/Action.java
index 470f6267..3c128b87 100644
--- a/project/app/src/main/java/com/achep/acdisplay/notifications/Action.java
+++ b/project/app/src/main/java/com/achep/acdisplay/notifications/Action.java
@@ -1,20 +1,43 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
 package com.achep.acdisplay.notifications;
 
 import android.annotation.TargetApi;
 import android.app.Notification;
 import android.app.PendingIntent;
 import android.os.Build;
+import android.support.annotation.DrawableRes;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Log;
 
-import com.achep.acdisplay.Device;
+import com.achep.base.Device;
 
 import java.lang.ref.SoftReference;
 import java.lang.reflect.Field;
 
 /**
- * Wrapper around {@link android.app.Notification.Action} class that supports both
+ * Structure to encapsulate a named action that can be shown as part of this notification.
+ * It must include an icon, a label, and a {@link PendingIntent} to be fired when the action is
+ * selected by the user.
+ * <p/>
+ * This is actually a wrapper around {@link android.app.Notification.Action} class that supports both
  * Jelly Bean (via reflections) and KitKat Android versions.
  */
 public class Action {
@@ -24,9 +47,24 @@ public class Action {
     @NonNull
     private static SoftReference<Factory> sFactoryRef = new SoftReference<>(null);
 
+    @NonNull
+    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
+    static Factory getFactory() {
+        Factory factory = sFactoryRef.get();
+        if (factory == null) {
+            factory = Device.hasKitKatApi()
+                    ? new FactoryNative()
+                    : new FactoryReflective();
+            sFactoryRef = new SoftReference<>(factory);
+            return factory;
+        }
+        return factory;
+    }
+
     /**
      * Small icon representing the action.
      */
+    @DrawableRes
     public final int icon;
 
     /**
@@ -39,32 +77,15 @@ public class Action {
      * Intent to send when the user invokes this action. May be null, in which case the action
      * may be rendered in a disabled presentation by the system UI.
      */
-    @NonNull
+    @Nullable
     public final PendingIntent intent;
 
-    Action(int icon, @NonNull CharSequence title, @NonNull PendingIntent intent) {
+    Action(@DrawableRes int icon, @NonNull CharSequence title, @Nullable PendingIntent intent) {
         this.icon = icon;
         this.title = title;
         this.intent = intent;
     }
 
-    /**
-     * @return Instance of action factory.
-     */
-    @NonNull
-    @TargetApi(Build.VERSION_CODES.JELLY_BEAN)
-    public static Factory getFactory() {
-        Factory factory = sFactoryRef.get();
-        if (factory == null) {
-            factory = Device.hasKitKatApi()
-                    ? new FactoryNative()
-                    : new FactoryReflective();
-            sFactoryRef = new SoftReference<>(factory);
-            return factory;
-        }
-        return factory;
-    }
-
     /**
      * Base definition of {@link com.achep.acdisplay.notifications.Action} creator.
      *
diff --git a/project/app/src/main/java/com/achep/acdisplay/notifications/parser/Extractor.java b/project/app/src/main/java/com/achep/acdisplay/notifications/Extractor.java
similarity index 58%
rename from project/app/src/main/java/com/achep/acdisplay/notifications/parser/Extractor.java
rename to project/app/src/main/java/com/achep/acdisplay/notifications/Extractor.java
index ae0026bb..c11e259d 100644
--- a/project/app/src/main/java/com/achep/acdisplay/notifications/parser/Extractor.java
+++ b/project/app/src/main/java/com/achep/acdisplay/notifications/Extractor.java
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.notifications.parser;
+package com.achep.acdisplay.notifications;
 
 import android.annotation.SuppressLint;
 import android.app.Notification;
@@ -32,12 +32,8 @@ import android.view.ViewGroup;
 import android.widget.RemoteViews;
 import android.widget.TextView;
 
-import com.achep.acdisplay.Device;
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.notifications.Action;
-import com.achep.acdisplay.notifications.NotificationData;
-import com.achep.acdisplay.notifications.NotificationUtils;
-import com.achep.acdisplay.notifications.OpenNotification;
+import com.achep.base.Device;
 
 import java.lang.reflect.Field;
 import java.util.ArrayList;
@@ -45,16 +41,43 @@ import java.util.ArrayList;
 /**
  * Created by Artem on 04.03.14.
  */
-public final class Extractor {
+final class Extractor {
 
     private static final String TAG = "Extractor";
 
+    /**
+     * Removes all kinds of multiple spaces from given string.
+     */
+    @Nullable
+    private static String removeSpaces(@Nullable CharSequence cs) {
+        if (cs == null) return null;
+        String string = cs instanceof String
+                ? (String) cs : cs.toString();
+        return string
+                .replaceAll("(\\s+$|^\\s+)", "")
+                .replaceAll("\n+", "\n");
+    }
+
+    @SuppressLint("InlinedApi")
+    public void loadTexts(@NonNull Context context, @NonNull OpenNotification n) {
+        final Notification notification = n.getNotification();
+        final Bundle extras = getExtras(notification);
+
+        if (extras != null) loadFromExtras(n, extras);
+        if (TextUtils.isEmpty(n.titleText)
+                && TextUtils.isEmpty(n.titleBigText)
+                && TextUtils.isEmpty(n.messageText)
+                && n.messageTextLines == null) {
+            loadFromView(context, n);
+        }
+    }
+
     /**
      * Gets a bundle with additional data from notification.
      */
     @Nullable
     @SuppressLint("NewApi")
-    private Bundle getExtras(Notification notification) {
+    private Bundle getExtras(@NonNull Notification notification) {
         if (Device.hasKitKatApi()) {
             return notification.extras;
         }
@@ -70,45 +93,13 @@ public final class Extractor {
         }
     }
 
-    @SuppressLint("InlinedApi")
-    public NotificationData loadTexts(Context context,
-                                      OpenNotification openNotification,
-                                      NotificationData data) {
-        final Notification n = openNotification.getNotification();
-        final Bundle extras = getExtras(n);
-
-        if (extras != null) loadFromExtras(data, extras);
-        if (TextUtils.isEmpty(data.titleText)
-                && TextUtils.isEmpty(data.titleBigText)
-                && TextUtils.isEmpty(data.messageText)
-                && data.messageTextLines == null) {
-            loadFromView(data, context, openNotification);
-        }
-        return data;
-    }
-
-    //-- LOADING FROM EXTRAS --------------------------------------------------
-
-    /**
-     * Loads all possible texts from given {@link Notification#extras extras} to
-     * {@link com.achep.acdisplay.notifications.NotificationData}.
-     *
-     * @param extras extras to load from
-     */
-    private void loadFromExtras(@NonNull NotificationData data, @NonNull Bundle extras) {
-        data.titleBigText = extras.getCharSequence(Notification.EXTRA_TITLE_BIG);
-        data.titleText = extras.getCharSequence(Notification.EXTRA_TITLE);
-        data.infoText = extras.getCharSequence(Notification.EXTRA_INFO_TEXT);
-        data.subText = extras.getCharSequence(Notification.EXTRA_SUB_TEXT);
-        data.summaryText = extras.getCharSequence(Notification.EXTRA_SUMMARY_TEXT);
-        data.messageText = extras.getCharSequence(Notification.EXTRA_TEXT);
-
-        CharSequence[] lines = extras.getCharSequenceArray(Notification.EXTRA_TEXT_LINES);
+    @Nullable
+    private CharSequence[] doIt(@Nullable CharSequence[] lines) {
         if (lines != null) {
-            // Ignore empty lines.
+            // Filter empty lines.
             ArrayList<CharSequence> list = new ArrayList<>();
             for (CharSequence msg : lines) {
-                msg = Utils.removeSpaces(msg);
+                msg = removeSpaces(msg);
                 if (!TextUtils.isEmpty(msg)) {
                     list.add(msg);
                 }
@@ -116,70 +107,82 @@ public final class Extractor {
 
             // Create new array.
             if (list.size() > 0) {
-                lines = list.toArray(new CharSequence[list.size()]);
-                data.messageTextLines = lines;
+                return list.toArray(new CharSequence[list.size()]);
             }
         }
+        return null;
+    }
+
+    //-- LOADING FROM EXTRAS --------------------------------------------------
+
+    /**
+     * Loads all possible texts from given {@link Notification#extras extras}.
+     *
+     * @param extras extras to load from
+     */
+    @SuppressLint("InlinedApi")
+    private void loadFromExtras(@NonNull OpenNotification n, @NonNull Bundle extras) {
+        n.titleBigText = extras.getCharSequence(Notification.EXTRA_TITLE_BIG);
+        n.titleText = extras.getCharSequence(Notification.EXTRA_TITLE);
+        n.infoText = extras.getCharSequence(Notification.EXTRA_INFO_TEXT);
+        n.subText = extras.getCharSequence(Notification.EXTRA_SUB_TEXT);
+        n.summaryText = extras.getCharSequence(Notification.EXTRA_SUMMARY_TEXT);
+        n.messageBigText = extras.getCharSequence(Notification.EXTRA_BIG_TEXT);
+        n.messageText = extras.getCharSequence(Notification.EXTRA_TEXT);
+
+        CharSequence[] lines = extras.getCharSequenceArray(Notification.EXTRA_TEXT_LINES);
+        n.messageTextLines = doIt(lines);
     }
 
-    //-- LOADING FROM VIES ----------------------------------------------------
+    //-- LOADING FROM VIEWS ---------------------------------------------------
 
-    private void loadFromView(@NonNull NotificationData data,
-                              @NonNull Context context,
-                              @NonNull OpenNotification openNotification) {
+    private void loadFromView(@NonNull Context context, @NonNull OpenNotification n) {
         ViewGroup view;
-        try {
-            final Notification n = openNotification.getNotification();
-            final RemoteViews rvs = n.bigContentView == null ? n.contentView : n.bigContentView;
+        {
+            final Context contextNotify = NotificationUtils.createContext(context, n);
+            if (contextNotify == null) return;
+
+            final Notification notification = n.getNotification();
+            final RemoteViews rvs = notification.bigContentView == null
+                    ? notification.contentView
+                    : notification.bigContentView;
 
-            // Try to load view from remote views.
-            Context contextNotify = NotificationUtils.createContext(context, openNotification);
+            // Try to load the view from remote views.
             LayoutInflater inflater = (LayoutInflater) contextNotify.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-            view = (ViewGroup) inflater.inflate(rvs.getLayoutId(), null);
-            rvs.reapply(contextNotify, view);
-        } catch (Exception e) {
-            return;
+            try {
+                view = (ViewGroup) inflater.inflate(rvs.getLayoutId(), null);
+                rvs.reapply(contextNotify, view);
+            } catch (Exception e) {
+                return;
+            }
         }
 
         ArrayList<TextView> textViews = new RecursiveFinder<>(TextView.class).expand(view);
         removeClickableViews(textViews);
         removeSubtextViews(context, textViews);
-        removeActionViews(data.actions, textViews);
+        removeActionViews(n.getActions(), textViews);
 
-        // There're no views present.
+        // No views
         if (textViews.size() == 0)
             return;
 
         TextView title = findTitleTextView(textViews);
         textViews.remove(title); // no need of title view anymore
-        data.titleText = title.getText();
+        n.titleText = title.getText();
 
-        // There're no views present.
+        // No views
         if (textViews.size() == 0)
             return;
 
+        // Pull all other texts and merge them.
         int length = textViews.size();
         CharSequence[] messages = new CharSequence[length];
-        for (int i = 0; i < length; i++) {
-            messages[i] = textViews.get(i).getText();
-        }
-
-        data.messageText = Utils.mergeLargeMessage(messages);
-    }
-
-    private TextView findTitleTextView(ArrayList<TextView> textViews) {
-        // The idea is that title text is biggest from all
-        // views here.
-        TextView biggest = null;
-        for (TextView textView : textViews) {
-            if (biggest == null || textView.getTextSize() > biggest.getTextSize()) {
-                biggest = textView;
-            }
-        }
-        return biggest;
+        for (int i = 0; i < length; i++) messages[i] = textViews.get(i).getText();
+        n.messageTextLines = doIt(messages);
     }
 
-    private void removeActionViews(Action[] actions, ArrayList<TextView> textViews) {
+    private void removeActionViews(@Nullable Action[] actions,
+                                   @NonNull ArrayList<TextView> textViews) {
         if (actions == null) {
             return;
         }
@@ -195,7 +198,7 @@ public final class Extractor {
         }
     }
 
-    private void removeClickableViews(ArrayList<TextView> textViews) {
+    private void removeClickableViews(@NonNull ArrayList<TextView> textViews) {
         for (int i = textViews.size() - 1; i >= 0; i--) {
             TextView child = textViews.get(i);
             if (child.isClickable() || child.getVisibility() != View.VISIBLE) {
@@ -205,7 +208,8 @@ public final class Extractor {
         }
     }
 
-    private void removeSubtextViews(Context context, ArrayList<TextView> textViews) {
+    private void removeSubtextViews(@NonNull Context context,
+                                    @NonNull ArrayList<TextView> textViews) {
         float subtextSize = context.getResources().getDimension(R.dimen.notification_subtext_size);
         for (int i = textViews.size() - 1; i >= 0; i--) {
             final TextView child = textViews.get(i);
@@ -220,17 +224,31 @@ public final class Extractor {
         }
     }
 
+    @NonNull
+    private TextView findTitleTextView(@NonNull ArrayList<TextView> textViews) {
+        // The idea is that title text is the
+        // largest one.
+        TextView largest = null;
+        for (TextView textView : textViews) {
+            if (largest == null || textView.getTextSize() > largest.getTextSize()) {
+                largest = textView;
+            }
+        }
+        assert largest != null; // cause the count of views is always >= 1
+        return largest;
+    }
+
     private static class RecursiveFinder<T extends View> {
 
         private final ArrayList<T> list;
         private final Class<T> clazz;
 
-        public RecursiveFinder(Class<T> clazz) {
+        public RecursiveFinder(@NonNull Class<T> clazz) {
             this.list = new ArrayList<>();
             this.clazz = clazz;
         }
 
-        public ArrayList<T> expand(ViewGroup viewGroup) {
+        public ArrayList<T> expand(@NonNull ViewGroup viewGroup) {
             int offset = 0;
             int childCount = viewGroup.getChildCount();
             for (int i = 0; i < childCount; i++) {
diff --git a/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationData.java b/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationData.java
deleted file mode 100644
index b09c52c1..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationData.java
+++ /dev/null
@@ -1,348 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.acdisplay.notifications;
-
-import android.app.Notification;
-import android.content.Context;
-import android.content.pm.PackageManager;
-import android.content.res.Resources;
-import android.graphics.Bitmap;
-import android.graphics.Canvas;
-import android.graphics.Paint;
-import android.graphics.drawable.Drawable;
-import android.os.SystemClock;
-import android.service.notification.StatusBarNotification;
-import android.support.annotation.Nullable;
-import android.text.SpannableStringBuilder;
-import android.text.Spanned;
-import android.text.TextUtils;
-import android.text.style.ForegroundColorSpan;
-import android.text.style.UnderlineSpan;
-import android.util.Log;
-
-import com.achep.acdisplay.AsyncTask;
-import com.achep.acdisplay.Build;
-import com.achep.acdisplay.R;
-import com.achep.acdisplay.acdisplay.BackgroundFactoryThread;
-import com.achep.acdisplay.notifications.parser.Extractor;
-import com.achep.acdisplay.utils.BitmapUtils;
-import com.achep.acdisplay.utils.StringUtils;
-
-import java.lang.ref.WeakReference;
-import java.util.ArrayList;
-
-/**
- * Created by Artem on 13.01.14.
- */
-public class NotificationData {
-
-    private static final String TAG = "NotificationData";
-
-    public static final int ICON = 1;
-    public static final int READ = 2;
-    public static final int BACKGROUND = 3;
-
-    public CharSequence titleBigText;
-    public CharSequence titleText;
-    public CharSequence messageText;
-    public CharSequence[] messageTextLines;
-    public CharSequence infoText;
-    public CharSequence subText;
-    public CharSequence summaryText;
-
-    public Action[] actions;
-
-    private Bitmap icon;
-    private Bitmap circleIcon;
-    private Bitmap background;
-
-    public int dominantColor;
-
-    /**
-     * The number of events that this notification represents. For example, in a new mail
-     * notification, this could be the number of unread messages.
-     * <p/>
-     * The system may or may not use this field to modify the appearance of the notification. For
-     * example, before {@link android.os.Build.VERSION_CODES#HONEYCOMB}, this number was
-     * superimposed over the icon in the status bar. Starting with
-     * {@link android.os.Build.VERSION_CODES#HONEYCOMB}, the template used by
-     * {@link android.app.Notification.Builder} has displayed the number in the expanded notification view.
-     * <p/>
-     * If the number is 0 or negative, it is never shown.
-     */
-    public int number;
-    public boolean isRead;
-
-    /**
-     * @return small notification icon with corrected size and color.
-     * This may return null if icon is still loading.
-     */
-    public Bitmap getIcon() {
-        return icon;
-    }
-
-    public Bitmap getCircleIcon() {
-        return circleIcon;
-    }
-
-    public Bitmap getBackground() {
-        return background;
-    }
-
-    public void recycle() {
-        AsyncTask.stop(mBackgroundLoader);
-        AsyncTask.stop(mIconLoader);
-
-        // All those bitmaps can be displayed at this moment.
-        // BitmapUtils.safelyRecycle(background);
-        // BitmapUtils.safelyRecycle(circleIcon);
-        // BitmapUtils.safelyRecycle(icon);
-    }
-
-    // //////////////////////////////////////////
-    // /////////// -- LISTENERS -- //////////////
-    // //////////////////////////////////////////
-
-    private final ArrayList<OnNotificationDataChangedListener> mListeners = new ArrayList<>(3);
-
-    public interface OnNotificationDataChangedListener {
-
-        public void onNotificationDataChanged(NotificationData data, int changeId);
-    }
-
-    public void registerListener(OnNotificationDataChangedListener listener) {
-        mListeners.add(listener);
-    }
-
-    public void unregisterListener(OnNotificationDataChangedListener listener) {
-        mListeners.remove(listener);
-    }
-
-    private void notifyListeners(int changeId) {
-        for (OnNotificationDataChangedListener listener : mListeners) {
-            listener.onNotificationDataChanged(this, changeId);
-        }
-    }
-
-    // //////////////////////////////////////////
-    // ///////////// -- MAIN -- /////////////////
-    // //////////////////////////////////////////
-
-    private static final Extractor sExtractor = new Extractor();
-    private IconLoaderThread mIconLoader;
-    private BackgroundFactoryThread mBackgroundLoader;
-    private BackgroundFactoryThread.Callback mBackgroundLoaderCallback =
-            new BackgroundFactoryThread.Callback() {
-                @Override
-                public void onBackgroundCreated(Bitmap bitmap) {
-                    setBackground(bitmap);
-                }
-            };
-
-    public void markAsRead(boolean value) {
-        if (isRead == (isRead = value)) return;
-        notifyListeners(READ);
-    }
-
-    private void setIcon(Bitmap bitmap) {
-        if (icon == (icon = bitmap)) return;
-        notifyListeners(ICON);
-    }
-
-    public void setBackground(Bitmap bitmap) {
-        if (background == (background = bitmap)) return;
-        notifyListeners(BACKGROUND);
-    }
-
-    /**
-     * Asynchronously loads the background of notification.
-     *
-     * @param n Notification to load from.
-     * @see #clearBackground()
-     */
-    public void loadBackground(Context context, OpenNotification n) {
-        // Stop previous thread if it is still
-        // running.
-        AsyncTask.stop(mBackgroundLoader);
-
-        Bitmap bitmapIcon = n.getNotification().largeIcon;
-        if (bitmapIcon != null && !BitmapUtils.hasTransparentCorners(bitmapIcon)) {
-            mBackgroundLoader = new BackgroundFactoryThread(
-                    context, bitmapIcon, mBackgroundLoaderCallback);
-            mBackgroundLoader.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
-        }
-    }
-
-    /**
-     * Frees the background of this notification.
-     *
-     * @see #loadBackground(Context, OpenNotification)
-     */
-    public void clearBackground() {
-        if (background != null) {
-            background.recycle();
-            setBackground(null);
-        }
-    }
-
-    /**
-     * Loads the circle icon of this notification.
-     *
-     * @see #clearCircleIcon()
-     */
-    public void loadCircleIcon(OpenNotification n) {
-        Bitmap bitmapIcon = n.getNotification().largeIcon;
-        if (bitmapIcon != null && !BitmapUtils.hasTransparentCorners(bitmapIcon)) {
-            circleIcon = BitmapUtils.createCircleBitmap(bitmapIcon);
-        }
-    }
-
-    /**
-     * Frees the circle icon of this notification.
-     *
-     * @see #loadBackground(Context, com.achep.acdisplay.notifications.OpenNotification)
-     */
-    public void clearCircleIcon() {
-        if (circleIcon != null) {
-            circleIcon.recycle();
-            circleIcon = null;
-        }
-    }
-
-    public void loadNotification(Context context, OpenNotification sbn, boolean isRead) {
-        Notification notification = sbn.getNotification();
-        actions = Action.getFactory().create(notification);
-        number = notification.number;
-        markAsRead(isRead);
-
-        try {
-            String packageName = sbn.getPackageName();
-            Drawable appIcon = context.getPackageManager().getApplicationIcon(packageName);
-
-            Bitmap bitmap = Bitmap.createBitmap(
-                    appIcon.getMinimumWidth(),
-                    appIcon.getMinimumHeight(),
-                    Bitmap.Config.ARGB_4444);
-            appIcon.draw(new Canvas(bitmap));
-            dominantColor = BitmapUtils.getDominantColor(bitmap);
-            bitmap.recycle();
-        } catch (PackageManager.NameNotFoundException e) { /* do nothing */ }
-
-        sExtractor.loadTexts(context, sbn, this);
-
-        AsyncTask.stop(mIconLoader);
-        mIconLoader = new IconLoaderThread(context, sbn);
-        mIconLoader.executeOnExecutor(AsyncTask.THREAD_POOL_EXECUTOR);
-    }
-
-    /**
-     * Task to load an icon from {@link StatusBarNotification notification}.
-     *
-     * @author Artem Chepurnoy
-     */
-    private static class IconLoaderThread extends AsyncTask<Void, Void, Bitmap> {
-
-        private final WeakReference<OpenNotification> mOpenNotification;
-        private final WeakReference<Context> mContext;
-
-        private volatile long startTime;
-
-        private IconLoaderThread(Context context, OpenNotification sbn) {
-            mOpenNotification = new WeakReference<>(sbn);
-            mContext = new WeakReference<>(context);
-        }
-
-        @Override
-        protected void onPreExecute() {
-            super.onPreExecute();
-            startTime = elapsedRealtime(); // to get elapsed time
-        }
-
-        @Override
-        protected Bitmap doInBackground(Void... params) {
-            OpenNotification openNotification = mOpenNotification.get();
-            Context context = mContext.get();
-
-            if (context == null || openNotification == null || isCancelled()) {
-                return null;
-            }
-
-            Resources res = context.getResources();
-            Drawable drawable = NotificationUtils
-                    .getDrawable(context, openNotification, openNotification.getNotification().icon);
-
-            if (isCancelled()) {
-                return null;
-            }
-
-            final int size = res.getDimensionPixelSize(R.dimen.notification_icon_size);
-            return drawable == null ? createEmptyIcon(res, size) : createIcon(drawable, size);
-        }
-
-        // TODO: Automatically scale the icon.
-        private Bitmap createIcon(Drawable drawable, int size) {
-            Bitmap icon = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_4444);
-            Canvas canvas = new Canvas(icon);
-
-            drawable = drawable.mutate();
-            drawable.setBounds(0, 0, size, size);
-            drawable.draw(canvas);
-
-            return icon;
-        }
-
-        private Bitmap createEmptyIcon(Resources res, int size) {
-            Paint paint = new Paint();
-            paint.setAntiAlias(true);
-            paint.setColor(0xDDCCCCCC); // white gray
-
-            final float radius = size / 2f;
-
-            Bitmap icon = Bitmap.createBitmap(size, size, Bitmap.Config.ARGB_4444);
-            Canvas canvas = new Canvas(icon);
-            canvas.drawCircle(radius, radius, radius, paint);
-
-            Drawable drawable = res.getDrawable(R.drawable.ic_dialog_bug);
-            drawable.setBounds(0, 0, size, size);
-            drawable.draw(canvas);
-
-            return icon;
-        }
-
-        @Override
-        protected void onPostExecute(Bitmap bitmap) {
-            super.onPostExecute(bitmap);
-            if (Build.DEBUG) {
-                long delta = elapsedRealtime() - startTime;
-                Log.d(TAG, "Notification icon loaded in " + delta + " millis:" + " bitmap=" + bitmap);
-            }
-
-            OpenNotification data = mOpenNotification.get();
-            if (bitmap != null && data != null) {
-                data.getNotificationData().setIcon(bitmap);
-            }
-        }
-
-        private long elapsedRealtime() {
-            return SystemClock.elapsedRealtime();
-        }
-
-    }
-
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationList.java b/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationList.java
index 5efc0927..c4a9a941 100644
--- a/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationList.java
+++ b/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationList.java
@@ -16,7 +16,6 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
 package com.achep.acdisplay.notifications;
 
 import android.support.annotation.NonNull;
@@ -44,7 +43,7 @@ final class NotificationList {
     private static final int EVENT_REMOVED = 2;
 
     @NonNull
-    private ArrayList<OpenNotification> mList;
+    private final ArrayList<OpenNotification> mList;
 
     @Nullable
     private OnNotificationListChangedListener mListener;
diff --git a/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationListChange.java b/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationListChange.java
new file mode 100644
index 00000000..18ddb757
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationListChange.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.notifications;
+
+/**
+ * Created by Artem Chepurnoy on 08.11.2014.
+ */
+public class NotificationListChange {
+
+    public final int event;
+    public final OpenNotification notification;
+
+    public NotificationListChange(int event, OpenNotification notification) {
+        this.event = event;
+        this.notification = notification;
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationPresenter.java b/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationPresenter.java
index 18615e77..2d48514d 100644
--- a/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationPresenter.java
+++ b/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationPresenter.java
@@ -16,7 +16,6 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
 package com.achep.acdisplay.notifications;
 
 import android.annotation.SuppressLint;
@@ -25,6 +24,7 @@ import android.app.NotificationManager;
 import android.content.Context;
 import android.content.res.Resources;
 import android.os.Handler;
+import android.os.Looper;
 import android.service.notification.StatusBarNotification;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
@@ -33,20 +33,21 @@ import android.util.Log;
 
 import com.achep.acdisplay.App;
 import com.achep.acdisplay.Config;
-import com.achep.acdisplay.Device;
-import com.achep.acdisplay.InactiveTimeHelper;
-import com.achep.acdisplay.Operator;
 import com.achep.acdisplay.Presenter;
 import com.achep.acdisplay.R;
 import com.achep.acdisplay.blacklist.AppConfig;
 import com.achep.acdisplay.blacklist.Blacklist;
 import com.achep.acdisplay.services.MediaService;
-import com.achep.acdisplay.services.activemode.sensors.ProximitySensor;
-import com.achep.acdisplay.utils.PackageUtils;
-import com.achep.acdisplay.utils.PowerUtils;
+import com.achep.base.Device;
+import com.achep.base.content.ConfigBase;
+import com.achep.base.utils.Operator;
+import com.achep.base.utils.PackageUtils;
 
+import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 
+import static com.achep.base.Build.DEBUG;
+
 /**
  * Created by Artem on 27.12.13.
  */
@@ -54,12 +55,41 @@ public class NotificationPresenter implements NotificationList.OnNotificationLis
 
     private static final String TAG = "NotificationPresenter";
 
+    /**
+     * {@code true} to use an additional {@link com.achep.acdisplay.notifications.NotificationList list}
+     * to store all current notifications, not depending on the preferences, {@code false} to
+     * use local list only. Using global list allows to change local list in-time after
+     * any of preferences change, which is useful for <b>AcDisplay</b>, but useless for <b>HeadsUp</b>.
+     */
+    private static final boolean KEEP_GLOBAL_LIST = true;
+
+    /**
+     * {@code true} to filter the noisy flow of same notifications,
+     * {@code false} to handle all notifications' updates normally.
+     */
+    private static final boolean FILTER_NOISY_NOTIFICATIONS = true;
+
     public static final int EVENT_BATH = 0;
     public static final int EVENT_POSTED = 1;
     public static final int EVENT_CHANGED = 2;
     public static final int EVENT_CHANGED_SPAM = 3;
     public static final int EVENT_REMOVED = 4;
 
+    private static final String[] EVENT_NAMES;
+
+    static {
+        EVENT_NAMES = new String[5];
+        EVENT_NAMES[EVENT_BATH] = "EVENT_BATH";
+        EVENT_NAMES[EVENT_POSTED] = "EVENT_POSTED";
+        EVENT_NAMES[EVENT_CHANGED] = "EVENT_CHANGED";
+        EVENT_NAMES[EVENT_CHANGED_SPAM] = "EVENT_CHANGED_SPAM";
+        EVENT_NAMES[EVENT_REMOVED] = "EVENT_REMOVED";
+    }
+
+    public static String getEventName(int event) {
+        return EVENT_NAMES[event];
+    }
+
     private static final int RESULT_SUCCESS = 1;
     private static final int RESULT_SPAM = -1;
 
@@ -77,57 +107,84 @@ public class NotificationPresenter implements NotificationList.OnNotificationLis
     private final NotificationList mGList;
     private final NotificationList mLList;
 
-    private final ArrayList<OnNotificationListChangedListener> mListeners;
+    private final ArrayList<WeakReference<OnNotificationListChangedListener>> mListenersRefs;
     private final Config mConfig;
     private final Blacklist mBlacklist;
 
+    // Threading
+    private final Object mMonitor = new Object(); // This is not really needed to be synced... :D
+    private final Handler mHandler;
+
+    //-- HANDLING CONFIG & BLACKLIST CHANGES ----------------------------------
+
+    private final ConfigListener mConfigListener;
+    private final BlacklistListener mBlacklistListener;
+
     /**
      * Listens to config to update notification list when needed.
      */
-    private class ConfigListener implements Config.OnConfigChangedListener {
+    private class ConfigListener implements ConfigBase.OnConfigChangedListener {
+
+        private int mMinPriority;
+        private int mMaxPriority;
+
+        public ConfigListener(@NonNull Config config) {
+            mMinPriority = config.getNotifyMinPriority();
+            mMaxPriority = config.getNotifyMaxPriority();
+        }
 
         @Override
-        public void onConfigChanged(Config config, String key, Object value) {
+        public void onConfigChanged(@NonNull ConfigBase configBase,
+                                    @NonNull String key,
+                                    @NonNull Object value) {
             boolean enabled;
+            int v;
             switch (key) {
-                case Config.KEY_NOTIFY_LOW_PRIORITY:
-                    handleLowPriorityNotificationsPreferenceChanged();
+                case Config.KEY_NOTIFY_MIN_PRIORITY:
+                    v = (int) value;
+                    handleNotifyPriorityChanged(v, mMinPriority);
+                    mMinPriority = v;
+                    break;
+                case Config.KEY_NOTIFY_MAX_PRIORITY:
+                    v = (int) value;
+                    handleNotifyPriorityChanged(v, mMaxPriority);
+                    mMaxPriority = v;
                     break;
                 case Config.KEY_UI_DYNAMIC_BACKGROUND_MODE:
                     enabled = Operator.bitAnd((int) value, Config.DYNAMIC_BG_NOTIFICATION_MASK);
-                    for (OpenNotification n : mGList.list()) {
-                        NotificationData data = n.getNotificationData();
-
-                        if (enabled) {
-                            data.loadBackground(config.getContext(), n);
-                        } else {
-                            data.clearBackground();
-                        }
-                    }
-                    break;
-                case Config.KEY_UI_NOTIFY_CIRCLED_ICON:
-                    enabled = (boolean) value;
-                    for (OpenNotification n : mGList.list()) {
-                        NotificationData data = n.getNotificationData();
-
+                    for (OpenNotification notification : getLargeList().list()) {
                         if (enabled) {
-                            data.loadCircleIcon(n);
+                            notification.loadBackgroundAsync();
                         } else {
-                            data.clearCircleIcon();
+                            notification.clearBackground();
                         }
                     }
                     break;
             }
         }
 
-        private void handleLowPriorityNotificationsPreferenceChanged() {
+        private void handleNotifyPriorityChanged(int a, int b) {
+            if (a > b) {
+                // This is here to remind me the great times
+                // of programming in the school. Sorry for that :p
+                a -= b *= -1;
+                a -= b += a;
+                // FIXME: Those two codes must do the same thing (proved by gcc).
+                // But definitely Java compiler is broken. I'm scared
+                // now... How can I not trust the compiler?
+                // a -= b += a -= b *= -1;
+            }
+
+            final int lower = a, higher = b;
             rebuildLocalList(new Comparator() {
                 @Override
-                public boolean needsRebuild(OpenNotification osbn) {
-                    return osbn.getNotification().priority <= Notification.PRIORITY_LOW;
+                public boolean needsRebuild(@NonNull OpenNotification osbn) {
+                    int priority = osbn.getNotification().priority;
+                    return priority >= lower && priority <= higher;
                 }
             });
         }
+
     }
 
     private class BlacklistListener extends Blacklist.OnBlacklistChangedListener {
@@ -147,10 +204,10 @@ public class NotificationPresenter implements NotificationList.OnNotificationLis
             }
         }
 
-        private void handlePackageVisibilityChanged(final String packageName) {
+        private void handlePackageVisibilityChanged(@NonNull final String packageName) {
             rebuildLocalList(new Comparator() {
                 @Override
-                public boolean needsRebuild(OpenNotification osbn) {
+                public boolean needsRebuild(@NonNull OpenNotification osbn) {
                     return osbn.getPackageName().equals(packageName);
                 }
             });
@@ -158,11 +215,11 @@ public class NotificationPresenter implements NotificationList.OnNotificationLis
     }
 
     private interface Comparator {
-        public boolean needsRebuild(OpenNotification osbn);
+        public boolean needsRebuild(@NonNull OpenNotification osbn);
     }
 
-    private void rebuildLocalList(Comparator comparator) {
-        for (OpenNotification n : mGList.list()) {
+    private void rebuildLocalList(@NonNull Comparator comparator) {
+        for (OpenNotification n : getLargeList().list()) {
             if (comparator.needsRebuild(n)) {
                 rebuildLocalList();
                 break;
@@ -170,9 +227,12 @@ public class NotificationPresenter implements NotificationList.OnNotificationLis
         }
     }
 
-    // //////////////////////////////////////////
-    // ////////////// -- MAIN -- ////////////////
-    // //////////////////////////////////////////
+    @NonNull
+    private NotificationList getLargeList() {
+        return KEEP_GLOBAL_LIST ? mGList : mLList;
+    }
+
+    //-- LISTENERS ------------------------------------------------------------
 
     public interface OnNotificationListChangedListener {
 
@@ -181,83 +241,132 @@ public class NotificationPresenter implements NotificationList.OnNotificationLis
          *
          * @param osbn  an instance of notification.
          * @param event event type:
-         *              {@link #EVENT_BATH}, {@link #EVENT_POSTED},
+         *              {@link #EVENT_POSTED}, {@link #EVENT_REMOVED},
          *              {@link #EVENT_CHANGED}, {@link #EVENT_CHANGED_SPAM},
-         *              {@link #EVENT_REMOVED}
+         *              {@link #EVENT_BATH}
+         * @param f     {@code true} if this is last of bath changes, {@code false} otherwise.
          */
         public void onNotificationListChanged(@NonNull NotificationPresenter np,
-                                              @Nullable OpenNotification osbn, int event);
+                                              OpenNotification osbn, int event,
+                                              boolean f);
 
     }
 
-    public void registerListener(OnNotificationListChangedListener listener) {
-        mListeners.add(listener);
+    public void registerListener(@NonNull OnNotificationListChangedListener listener) {
+        // Make sure to register listener only once.
+        for (WeakReference<OnNotificationListChangedListener> ref : mListenersRefs) {
+            if (ref.get() == listener) {
+                Log.w(TAG, "Tried to register already registered listener!");
+                return;
+            }
+        }
+
+        mListenersRefs.add(new WeakReference<>(listener));
     }
 
-    public void unregisterListener(OnNotificationListChangedListener listener) {
-        mListeners.remove(listener);
+    public void unregisterListener(@NonNull OnNotificationListChangedListener listener) {
+        for (WeakReference<OnNotificationListChangedListener> ref : mListenersRefs) {
+            if (ref.get() == listener) {
+                mListenersRefs.remove(ref);
+                return;
+            }
+        }
+
+        Log.w(TAG, "Tried to unregister non-existent listener!");
     }
 
+    //-- MAIN -----------------------------------------------------------------
+
     private NotificationPresenter() {
-        mListeners = new ArrayList<>();
+        mListenersRefs = new ArrayList<>();
         mGList = new NotificationList(null);
         mLList = new NotificationList(this);
+        mHandler = new Handler(Looper.getMainLooper());
 
-        if (!Device.hasJellyBeanMR2Api()) {
-            mGList.setMaximumSize(7);
-            mLList.setMaximumSize(7);
+        if (!Device.hasJellyBeanMR2Api()) { // pre 4.3 version
+            mGList.setMaximumSize(5);
+            mLList.setMaximumSize(5);
         }
 
         mConfig = Config.getInstance();
-        mConfig.registerListener(new ConfigListener());
+        mConfigListener = new ConfigListener(mConfig); // because of weak listeners
+        mConfig.registerListener(mConfigListener);
 
+        mBlacklistListener = new BlacklistListener();
         mBlacklist = Blacklist.getInstance();
-        mBlacklist.registerListener(new BlacklistListener());
+        mBlacklist.registerListener(mBlacklistListener);
     }
 
+    @NonNull
     public synchronized static NotificationPresenter getInstance() {
         if (sNotificationPresenter == null) {
             sNotificationPresenter = new NotificationPresenter();
+            // This is here to fool proguard and prevent
+            // listeners from converting to the local
+            // variables.
+            assert sNotificationPresenter.mConfigListener != null;
+            assert sNotificationPresenter.mBlacklistListener != null;
         }
         return sNotificationPresenter;
     }
 
+    public void postNotificationFromMain(
+            @NonNull final Context context,
+            @NonNull final OpenNotification n, final int flags) {
+        if (DEBUG) Log.d(TAG, "Initially posting " + n + " from \'"
+                + Thread.currentThread().getName() + "\' thread.");
+
+        mHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                //noinspection deprecation
+                postNotification(context, n, flags);
+            }
+        });
+    }
+
     /**
      * Posts notification to global list, notifies every follower
      * about this change, and tries to launch
-     * {@link com.achep.acdisplay.acdisplay.AcDisplayActivity}.
+     * {@link com.achep.acdisplay.ui.activities.AcDisplayActivity}.
      * <p><i>
-     *     To create {@link OpenNotification}, use
-     *     {@link OpenNotification#newInstance(StatusBarNotification)} or
-     *     {@link OpenNotification#newInstance(android.app.Notification)}
-     *     method.
+     * To create {@link OpenNotification}, use
+     * {@link OpenNotification#newInstance(StatusBarNotification)} or
+     * {@link OpenNotification#newInstance(android.app.Notification)}
+     * method.
      * </i></p>
      *
      * @see #FLAG_DONT_NOTIFY_FOLLOWERS
      * @see #FLAG_DONT_WAKE_UP
      */
+    @Deprecated
     public void postNotification(
             @NonNull Context context,
             @NonNull OpenNotification n, int flags) {
+        if (DEBUG) Log.d(TAG, "Posting new " + n + " from \'"
+                + Thread.currentThread().getName() + "\' thread.");
+
+        // Check for the test notification.
+        if (isInitNotification(context, n)) {
+            NotificationUtils.dismissNotification(n);
+            return;
+        }
+
         boolean globalValid = isValidForGlobal(n);
         boolean localValid = false;
 
         // If notification will not be added to the
         // list there's no point of loading its data.
         if (globalValid) {
-            n.loadData(context);
+            n.load(context);
 
-            NotificationData data = n.getNotificationData();
             Config config = Config.getInstance();
-
             // Selective load exactly what we need and nothing more.
             // This will reduce RAM consumption for a bit (1% or so.)
             if (Operator.bitAnd(
                     config.getDynamicBackgroundMode(),
                     Config.DYNAMIC_BG_NOTIFICATION_MASK))
-                data.loadBackground(context, n);
-            if (config.isCircledLargeIconEnabled())
-                data.loadCircleIcon(n);
+                n.loadBackgroundAsync();
 
             localValid = isValidForLocal(n);
         }
@@ -268,21 +377,41 @@ public class NotificationPresenter implements NotificationList.OnNotificationLis
         boolean flagWakeUp = !Operator.bitAnd(
                 flags, FLAG_DONT_WAKE_UP);
 
-        mGList.pushOrRemove(n, globalValid, flagIgnoreFollowers);
+        if (KEEP_GLOBAL_LIST) mGList.pushOrRemove(n, globalValid, flagIgnoreFollowers);
         int result = mLList.pushOrRemove(n, localValid, flagIgnoreFollowers);
 
         if (flagWakeUp && result == RESULT_SUCCESS) {
-            tryStartGui(context, n);
+            // Try start gui
+            Presenter.getInstance().tryStartGuiCauseNotification(context, n);
         }
     }
 
+    public void removeNotificationFromMain(final @NonNull OpenNotification n) {
+        if (DEBUG) Log.d(TAG, "Initially removing " + n + " from \'"
+                + Thread.currentThread().getName() + "\' thread.");
+
+        mHandler.post(new Runnable() {
+            @Override
+            public void run() {
+                //noinspection deprecation
+                removeNotification(n);
+            }
+        });
+    }
+
     /**
      * Removes notification from the presenter and sends
      * this event to followers. Calling his method will not
      * remove notification from system!
+     *
+     * @deprecated use {@link #removeNotificationFromMain(OpenNotification)} instead!
      */
+    @Deprecated
     public void removeNotification(@NonNull OpenNotification n) {
-        mGList.remove(n);
+        if (DEBUG) Log.d(TAG, "Removing " + n + " from \'"
+                + Thread.currentThread().getName() + "\' thread.");
+
+        if (KEEP_GLOBAL_LIST) mGList.remove(n);
         mLList.remove(n);
     }
 
@@ -294,7 +423,7 @@ public class NotificationPresenter implements NotificationList.OnNotificationLis
      * @see #isValidForGlobal(OpenNotification)
      */
     private void rebuildLocalList() {
-        boolean changed = false;
+        ArrayList<NotificationListChange> changes = new ArrayList<>();
 
         // Remove not valid notifications
         // from local list.
@@ -302,56 +431,64 @@ public class NotificationPresenter implements NotificationList.OnNotificationLis
         for (int i = 0; i < list.size(); i++) {
             OpenNotification n = list.get(i);
             if (!isValidForLocal(n)) {
-                changed = true;
                 list.remove(i--);
+                changes.add(new NotificationListChange(EVENT_REMOVED, n));
             }
         }
 
         // Add newly valid notifications to local list.
         for (OpenNotification n : mGList.list()) {
             if (isValidForLocal(n) && mLList.indexOf(n) == -1) {
-                changed = true;
                 list.add(n);
+                changes.add(new NotificationListChange(EVENT_POSTED, n));
             }
         }
 
-        if (changed) {
+        int size = changes.size();
+        if (size > 4) {
             notifyListeners(null, EVENT_BATH);
+        } else if (size > 0) {
+            notifyListeners(changes);
         }
     }
 
+    @NonNull
     public ArrayList<OpenNotification> getList() {
         return mLList.list();
     }
 
-    // //////////////////////////////////////////
-    // ///////////// -- EVENTS -- ///////////////
-    // //////////////////////////////////////////
+    public int size() {
+        return getList().size();
+    }
+
+    //-- LOCAL LIST'S EVENTS --------------------------------------------------
 
     @Override
+    // Not an enter point, should not be synchronized.
     public int onNotificationAdded(@NonNull OpenNotification n) {
         notifyListeners(n, EVENT_POSTED);
         return RESULT_SUCCESS;
     }
 
     @Override
+    // Not an enter point, should not be synchronized.
     public int onNotificationChanged(@NonNull OpenNotification n, @NonNull OpenNotification old) {
+        if (!FILTER_NOISY_NOTIFICATIONS) return RESULT_SUCCESS;
+
         // Prevent god damn notification spam by
         // checking texts' equality.
 
-        // An example of notification spammer is well-known
+        // An example of notification spammer is a well-known
         // DownloadProvider (seriously, Google?)
-        NotificationData dataOld = old.getNotificationData();
-        NotificationData dataNew = n.getNotificationData();
-
-        if (dataNew.number == dataOld.number
-                && TextUtils.equals(dataNew.titleText, dataOld.titleText)
-                && TextUtils.equals(dataNew.titleBigText, dataOld.titleBigText)
-                && TextUtils.equals(dataNew.messageText, dataOld.messageText)
-                && TextUtils.equals(dataNew.infoText, dataOld.infoText)) {
+
+        if (n.getNumber() == old.getNumber()
+                && TextUtils.equals(n.titleText, old.titleText)
+                && TextUtils.equals(n.titleBigText, old.titleBigText)
+                && TextUtils.equals(n.messageText, old.messageText)
+                && TextUtils.equals(n.infoText, old.infoText)) {
             // Technically notification was changed, but it was a fault
             // of dumb developer. Mark notification as read, if old one was.
-            n.getNotificationData().markAsRead(old.getNotificationData().isRead);
+            n.setRead(old.isRead());
 
             if (!n.isMine()) {
                 notifyListeners(n, EVENT_CHANGED_SPAM);
@@ -364,171 +501,166 @@ public class NotificationPresenter implements NotificationList.OnNotificationLis
     }
 
     @Override
+    // Not an enter point, should not be synchronized.
     public int onNotificationRemoved(@NonNull OpenNotification n) {
         notifyListeners(n, EVENT_REMOVED);
         n.recycle(); // Free all resources
         return RESULT_SUCCESS;
     }
 
-    // //////////////////////////////////////////
-    // //////// -- NOTIFICATION UTILS -- ////////
-    // //////////////////////////////////////////
+    //-- NOTIFICATION UTILS ---------------------------------------------------
+
+    @SuppressLint("NewApi")
+    public boolean isTestNotification(@NonNull Context context, @NonNull OpenNotification n) {
+        StatusBarNotification sbn = n.getStatusBarNotification();
+        return sbn != null
+                && sbn.getId() == App.ID_NOTIFY_TEST
+                && n.getPackageName().equals(PackageUtils.getName(context));
+    }
+
+    @SuppressLint("NewApi")
+    public boolean isInitNotification(@NonNull Context context, @NonNull OpenNotification n) {
+        StatusBarNotification sbn = n.getStatusBarNotification();
+        return sbn != null
+                && sbn.getId() == App.ID_NOTIFY_INIT
+                && n.getPackageName().equals(PackageUtils.getName(context));
+    }
+
+    private void notifyListeners(OpenNotification n, int event) {
+        notifyListeners(n, event, true);
+    }
+
+    private void notifyListeners(OpenNotification n, int event, boolean f) {
+        for (int i = mListenersRefs.size() - 1; i >= 0; i--) {
+            WeakReference<OnNotificationListChangedListener> ref = mListenersRefs.get(i);
+            OnNotificationListChangedListener l = ref.get();
+
+            if (l == null) {
+                // There were no links to this listener except
+                // our class.
+                Log.w(TAG, "Deleting an unused listener!");
+                mListenersRefs.remove(i);
+            } else {
+                l.onNotificationListChanged(this, n, event, f);
+            }
+        }
+    }
 
-    private void notifyListeners(@Nullable OpenNotification n, int event) {
-        for (OnNotificationListChangedListener listener : mListeners) {
-            listener.onNotificationListChanged(this, n, event);
+    private void notifyListeners(@NonNull ArrayList<NotificationListChange> changes) {
+        int size = changes.size();
+        for (int i = 0; i < size; i++) {
+            NotificationListChange change = changes.get(i);
+            notifyListeners(change.notification, change.event, i + 1 == size);
         }
     }
 
     /**
-     * Returns {@code false} if the notification doesn't fit
-     * the requirements (such as not ongoing and clearable).
+     * @return {@code true} if notification may be shown to user,
+     * {@code false} otherwise.
      */
-    private boolean isValidForLocal(@NonNull OpenNotification o) {
-        AppConfig config = mBlacklist.getAppConfig(o.getPackageName());
+    private boolean isValidForLocal(@NonNull OpenNotification notification) {
+        AppConfig config = mBlacklist.getAppConfig(notification.getPackageName());
 
         if (config.isHidden()) {
             // Do not display any notifications from this app.
             return false;
         }
 
-        if (!o.isClearable() && !config.isNonClearableEnabled()) {
+        if (!notification.isClearable() && !config.isNonClearableEnabled()) {
             // Do not display non-clearable notification.
             return false;
         }
 
-        if (o.getNotification().priority <= Notification.PRIORITY_LOW
-                && !mConfig.isLowPriorityNotificationsAllowed()) {
-            // Do not display low-priority notification.
+        if (notification.getNotification().priority < mConfig.getNotifyMinPriority()) {
+            // Do not display too low-priority notification.
             return false;
         }
 
-        // Do not allow notifications without any content.
-        NotificationData data = o.getNotificationData();
-        return !(TextUtils.isEmpty(data.titleText)
-                && TextUtils.isEmpty(data.titleBigText)
-                && TextUtils.isEmpty(data.messageText)
-                && TextUtils.isEmpty(data.infoText)
-                && data.messageTextLines == null);
-    }
-
-    private boolean isValidForGlobal(@NonNull OpenNotification n) {
-        return true;
-    }
-
-    // //////////////////////////////////////////
-    // ///////// -- USER INTERFACE -- ///////////
-    // //////////////////////////////////////////
+        if (notification.getNotification().priority > mConfig.getNotifyMaxPriority()) {
+            // Do not display too high-priority notification.
+            return false;
+        }
 
-    @SuppressLint("NewApi")
-    private boolean isTestNotification(Context context, OpenNotification n) {
-        StatusBarNotification sbn = n.getStatusBarNotification();
-        return sbn != null
-                && sbn.getId() == App.ID_NOTIFY_INIT
-                && n.getPackageName().equals(PackageUtils.getName(context));
+        // Do not allow notifications with no content.
+        return !(TextUtils.isEmpty(notification.titleText)
+                && TextUtils.isEmpty(notification.titleBigText)
+                && TextUtils.isEmpty(notification.messageText)
+                && TextUtils.isEmpty(notification.messageBigText)
+                && notification.messageTextLines == null);
     }
 
-    /**
-     * Starts {@link com.achep.acdisplay.acdisplay.AcDisplayActivity activity} if active display
-     * is enabled and screen is turned off and...
-     */
-    private boolean tryStartGui(Context context, OpenNotification n) {
-        if (!isTestNotification(context, n)) { // force test notification to be shown
-            if (!mConfig.isEnabled() || !mConfig.isNotifyWakingUp()
-                    // Inactive time
-                    || mConfig.isInactiveTimeEnabled()
-                    && InactiveTimeHelper.isInactiveTime(mConfig)
-                    // Only while charging
-                    || mConfig.isEnabledOnlyWhileCharging()
-                    && !PowerUtils.isPlugged(context)) {
-                // Don't turn screen on due to user settings.
-                return false;
-            }
-
-            if (ProximitySensor.isNear()) {
-                // Don't display while device is face down.
-                return false;
-            }
-
-            String packageName = n.getPackageName();
-            AppConfig config = mBlacklist.getAppConfig(packageName);
-            if (config.isRestricted()) {
-                // Don't display due to app settings.
-                return false;
-            }
-        }
-
-        Presenter.getInstance().start(context);
+    private boolean isValidForGlobal(@NonNull OpenNotification notification) {
+        // Here we filter completely wrong
+        // notifications.
         return true;
     }
 
-    // //////////////////////////////////////////
-    // ////////// -- INITIALIZING -- ////////////
-    // //////////////////////////////////////////
+    //-- INITIALIZING ---------------------------------------------------------
 
     /**
      * Should be called when notification listener service is ready to receive new notifications.
      */
     // Running on wrong thread
     public void tryStartInitProcess() {
-        if (mInitProcess != INITIALIZING_PROCESS_NONE) {
-            return;
-        }
+        synchronized (mMonitor) {
 
-        mInitProcess = INITIALIZING_PROCESS_STARTED;
+            if (mInitProcess != INITIALIZING_PROCESS_NONE) {
+                return;
+            }
 
-        // Well I know that handler doesn't work properly on deep sleep.
-        // This is okay. It'll send this init notification after waking up.
-        new Handler().postDelayed(new Runnable() {
-            @Override
-            public void run() {
-                MediaService service = MediaService.sService;
+            mInitProcess = INITIALIZING_PROCESS_STARTED;
+
+            // Well I know that handler doesn't work properly on deep sleep.
+            // This is okay. It'll send this init notification after waking up.
+            new Handler().postDelayed(new Runnable() {
+                @Override
+                public void run() {
+                    MediaService service = MediaService.sService;
+
+                    if (service == null) {
+                        Log.w(TAG, "Tried to send an init-notification but notification service is offline.");
+                        return;
+                    }
 
-                if (service == null) {
-                    Log.w(TAG, "Tried to send an init-notification but notification service is offline.");
-                    return;
+                    Resources res = service.getResources();
+                    Notification.Builder builder = new Notification.Builder(service)
+                            .setContentTitle(res.getString(R.string.app_name))
+                            .setContentText(res.getString(R.string.notification_init_text))
+                            .setSmallIcon(R.drawable.stat_notify)
+                            .setPriority(Notification.PRIORITY_MIN)
+                            .setAutoCancel(true);
+
+                    NotificationManager nm = (NotificationManager)
+                            service.getSystemService(Context.NOTIFICATION_SERVICE);
+                    nm.notify(App.ID_NOTIFY_INIT, builder.build());
                 }
+            }, 2500);
+        }
+    }
 
-                Resources res = service.getResources();
-                Notification.Builder builder = new Notification.Builder(service)
-                        .setContentTitle(res.getString(R.string.app_name))
-                        .setContentText(res.getString(R.string.init_notification_text))
-                        .setSmallIcon(R.drawable.stat_notify)
-                        .setPriority(Notification.PRIORITY_MIN)
-                        .setAutoCancel(true);
-
-                NotificationManager nm = (NotificationManager)
-                        service.getSystemService(Context.NOTIFICATION_SERVICE);
-                nm.notify(App.ID_NOTIFY_INIT, builder.build());
+    // Running on wrong thread
+    public void tryInit(final @NonNull Context context,
+                        final @Nullable StatusBarNotification[] activeNotifications) {
+        synchronized (mMonitor) {
+            if (mInitProcess != INITIALIZING_PROCESS_STARTED
+                    || activeNotifications == null) {
+                return;
             }
-        }, 2500);
-    }
 
-    @SuppressWarnings("PointlessBooleanExpression")
-    public void tryInit(MediaService service, final StatusBarNotification n, StatusBarNotification[] activeNotifications) {
-        if (mInitProcess != INITIALIZING_PROCESS_STARTED
-                // Is posted notification equals to init notification?
-                || n.getId() != App.ID_NOTIFY_INIT
-                || n.getPackageName().equals(PackageUtils.getName(service)) == false) {
-            return;
-        } else {
             mInitProcess = INITIALIZING_PROCESS_DONE;
-        }
+            mHandler.post(new Runnable() {
+                @SuppressLint("NewApi")
+                @Override
+                public void run() {
+                    for (StatusBarNotification notification : activeNotifications) {
+                        OpenNotification n = OpenNotification.newInstance(notification);
+                        postNotification(context, n, FLAG_DONT_NOTIFY_FOLLOWERS | FLAG_DONT_WAKE_UP);
+                    }
 
-        if (activeNotifications != null) {
-            for (StatusBarNotification notification : activeNotifications) {
-                OpenNotification n1 = OpenNotification.newInstance(notification);
-                postNotification(service, n1, FLAG_DONT_NOTIFY_FOLLOWERS | FLAG_DONT_WAKE_UP);
-            }
-            notifyListeners(null, EVENT_BATH);
+                    notifyListeners(null, EVENT_BATH);
+                }
+            });
         }
-
-        new Handler().postDelayed(new Runnable() {
-            @Override
-            public void run() {
-                NotificationUtils.dismissNotification(OpenNotification.newInstance(n));
-            }
-        }, 500);
     }
 
     public boolean isInitialized() {
diff --git a/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationUtils.java b/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationUtils.java
index 1484cb16..58faa91b 100644
--- a/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationUtils.java
+++ b/project/app/src/main/java/com/achep/acdisplay/notifications/NotificationUtils.java
@@ -26,16 +26,15 @@ import android.content.pm.PackageManager;
 import android.content.res.Resources;
 import android.graphics.drawable.Drawable;
 import android.service.notification.StatusBarNotification;
+import android.support.annotation.DrawableRes;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 
-import com.achep.acdisplay.Device;
-import com.achep.acdisplay.Operator;
 import com.achep.acdisplay.services.MediaService;
 import com.achep.acdisplay.utils.PendingIntentUtils;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
+import com.achep.base.Device;
+import com.achep.base.utils.Operator;
 
 /**
  * Created by Artem on 30.12.13.
@@ -68,7 +67,6 @@ public class NotificationUtils {
     @SuppressLint("NewApi")
     public static void dismissNotification(@NonNull OpenNotification n) {
         NotificationPresenter.getInstance().removeNotification(n);
-
         StatusBarNotification sbn = n.getStatusBarNotification();
         if (sbn != null && Device.hasJellyBeanMR2Api()) {
             MediaService service = MediaService.sService;
@@ -87,7 +85,10 @@ public class NotificationUtils {
         }
     }
 
-    public static Drawable getDrawable(Context context, OpenNotification n, int iconRes) {
+    @Nullable
+    public static Drawable getDrawable(@NonNull Context context,
+                                       @NonNull OpenNotification n,
+                                       @DrawableRes int iconRes) {
         Context pkgContext = createContext(context, n);
         if (pkgContext != null)
             try {
@@ -96,7 +97,8 @@ public class NotificationUtils {
         return null;
     }
 
-    public static Context createContext(Context context, OpenNotification n) {
+    @Nullable
+    public static Context createContext(@NonNull Context context, @NonNull OpenNotification n) {
         try {
             return context.createPackageContext(n.getPackageName(), Context.CONTEXT_RESTRICTED);
         } catch (PackageManager.NameNotFoundException e) {
@@ -108,7 +110,9 @@ public class NotificationUtils {
     /**
      * @see com.achep.acdisplay.notifications.OpenNotification#hasIdenticalIds(OpenNotification)
      */
-    public static boolean hasIdenticalIds(OpenNotification n, OpenNotification n2) {
+    public static boolean hasIdenticalIds(@Nullable OpenNotification n,
+                                          @Nullable OpenNotification n2) {
         return n == n2 || n != null && n.hasIdenticalIds(n2);
     }
+
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/notifications/OpenNotification.java b/project/app/src/main/java/com/achep/acdisplay/notifications/OpenNotification.java
index 8cd1db69..c9b05436 100644
--- a/project/app/src/main/java/com/achep/acdisplay/notifications/OpenNotification.java
+++ b/project/app/src/main/java/com/achep/acdisplay/notifications/OpenNotification.java
@@ -22,31 +22,36 @@ import android.annotation.SuppressLint;
 import android.annotation.TargetApi;
 import android.app.Notification;
 import android.content.Context;
+import android.content.pm.PackageManager;
+import android.graphics.Bitmap;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.drawable.Drawable;
 import android.os.Build;
 import android.service.notification.StatusBarNotification;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.v7.graphics.Palette;
 import android.text.TextUtils;
 
-import com.achep.acdisplay.Device;
-import com.achep.acdisplay.utils.PackageUtils;
+import com.achep.acdisplay.graphics.BackgroundFactory;
+import com.achep.acdisplay.graphics.IconFactory;
+import com.achep.acdisplay.utils.BitmapUtils;
+import com.achep.base.Device;
+import com.achep.base.async.AsyncTask;
+import com.achep.base.interfaces.ISubscriptable;
+import com.achep.base.utils.PackageUtils;
 
 import org.apache.commons.lang.builder.EqualsBuilder;
 
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
+import java.util.ArrayList;
 
 /**
  * Created by Artem on 23.01.14.
  */
-public class OpenNotification {
+public class OpenNotification implements
+        ISubscriptable<OpenNotification.OnNotificationDataChangedListener> {
 
-    private StatusBarNotification mStatusBarNotification;
-
-    private Notification mNotification;
-    private NotificationData mNotificationData;
-
-    private boolean mMine;
 
     /**
      * Creates empty notification instance.
@@ -59,7 +64,7 @@ public class OpenNotification {
     /**
      * Creates empty notification instance.
      *
-     * @deprecated Use {@link #newInstance(android.service.notification.StatusBarNotification)}
+     * @deprecated use {@link #newInstance(android.service.notification.StatusBarNotification)}
      * instead.
      */
     @Deprecated
@@ -67,16 +72,118 @@ public class OpenNotification {
         return new OpenNotificationCompat(n);
     }
 
-    protected OpenNotification(StatusBarNotification sbn, @NonNull Notification n) {
+    //-- BEGIN ----------------------------------------------------------------
+
+    public static final int EVENT_ICON = 1;
+    public static final int EVENT_READ = 2;
+    public static final int EVENT_BACKGROUND = 3;
+    public static final int EVENT_BRAND_COLOR = 4;
+
+    @Nullable
+    private final StatusBarNotification mStatusBarNotification;
+    @NonNull
+    private final Notification mNotification;
+    @Nullable
+    private Action[] mActions;
+    private boolean mMine;
+    private boolean mRead;
+    private int mNumber;
+
+    // Extracted
+    @Nullable
+    public CharSequence titleBigText;
+    @Nullable
+    public CharSequence titleText;
+    @Nullable
+    public CharSequence messageBigText;
+    @Nullable
+    public CharSequence messageText;
+    @Nullable
+    public CharSequence[] messageTextLines;
+    @Nullable
+    public CharSequence infoText;
+    @Nullable
+    public CharSequence subText;
+    @Nullable
+    public CharSequence summaryText;
+
+    // Notification icon.
+    @Nullable
+    private Bitmap mIconBitmap;
+    @Nullable
+    private AsyncTask<Void, Void, Bitmap> mIconWorker;
+    @NonNull
+    private final IconFactory.IconAsyncListener mIconCallback =
+            new IconFactory.IconAsyncListener() {
+                @Override
+                public void onGenerated(@NonNull Bitmap bitmap) {
+                    mIconWorker = null;
+                    setIcon(bitmap);
+                }
+            };
+
+    // Dynamic background.
+    @Nullable
+    private Bitmap mBackgroundBitmap;
+    @Nullable
+    private AsyncTask<Void, Void, Bitmap> mBackgroundWorker;
+    @NonNull
+    private final BackgroundFactory.BackgroundAsyncListener mBackgroundCallback =
+            new BackgroundFactory.BackgroundAsyncListener() {
+                @Override
+                public void onGenerated(@NonNull Bitmap bitmap) {
+                    mBackgroundWorker = null;
+                    setBackground(bitmap);
+                }
+            };
+
+    // Brand color.
+    private int mBrandColor = Color.WHITE;
+    @Nullable
+    private android.os.AsyncTask<Bitmap, Void, Palette> mPaletteWorker;
+
+    // Listeners
+    @NonNull
+    private final ArrayList<OnNotificationDataChangedListener> mListeners = new ArrayList<>(3);
+
+    protected OpenNotification(@Nullable StatusBarNotification sbn, @NonNull Notification n) {
         mStatusBarNotification = sbn;
         mNotification = n;
-
-        mNotificationData = new NotificationData();
     }
 
-    public void loadData(Context context) {
-        mNotificationData.loadNotification(context, this, false);
+    public void load(@NonNull Context context) {
         mMine = TextUtils.equals(getPackageName(), PackageUtils.getName(context));
+        mActions = Action.getFactory().create(mNotification);
+        mNumber = mNotification.number;
+
+        // Load the brand color.
+        try {
+            String packageName = getPackageName();
+            Drawable appIcon = context.getPackageManager().getApplicationIcon(packageName);
+
+            final Bitmap bitmap = Bitmap.createBitmap(
+                    appIcon.getMinimumWidth(),
+                    appIcon.getMinimumHeight(),
+                    Bitmap.Config.ARGB_4444);
+            appIcon.draw(new Canvas(bitmap));
+            AsyncTask.stop(mPaletteWorker);
+            mPaletteWorker = Palette.generateAsync(bitmap, new Palette.PaletteAsyncListener() {
+                @Override
+                public void onGenerated(Palette palette) {
+                    mBrandColor = palette.getVibrantColor(Color.WHITE);
+                    notifyListeners(EVENT_BRAND_COLOR);
+                    bitmap.recycle();
+                }
+            });
+        } catch (PackageManager.NameNotFoundException e) { /* do nothing */ }
+
+        // Load notification icon.
+        AsyncTask.stop(mIconWorker);
+        mIconWorker = IconFactory.generateAsync(context, this, mIconCallback);
+
+        // Load all other things, such as title text, message text
+        // and more and more.
+        new Extractor().loadTexts(context, this);
     }
 
     /**
@@ -97,9 +204,52 @@ public class OpenNotification {
         return mNotification;
     }
 
-    @NonNull
-    public NotificationData getNotificationData() {
-        return mNotificationData;
+    /**
+     * Array of all {@link Action} structures attached to this notification.
+     */
+    @Nullable
+    public Action[] getActions() {
+        return mActions;
+    }
+
+    @Nullable
+    public Bitmap getBackground() {
+        return mBackgroundBitmap;
+    }
+
+    @Nullable
+    public Bitmap getIcon() {
+        return mIconBitmap;
+    }
+
+    /**
+     * The number of events that this notification represents. For example, in a new mail
+     * notification, this could be the number of unread messages.
+     * <p/>
+     * The system may or may not use this field to modify the appearance of the notification. For
+     * example, before {@link android.os.Build.VERSION_CODES#HONEYCOMB}, this number was
+     * superimposed over the icon in the status bar. Starting with
+     * {@link android.os.Build.VERSION_CODES#HONEYCOMB}, the template used by
+     * {@link Notification.Builder} has displayed the number in the expanded notification view.
+     * <p/>
+     * If the number is 0 or negative, it is never shown.
+     */
+    public int getNumber() {
+        return mNumber;
+    }
+
+    public int getBrandColor() {
+        return mBrandColor;
+    }
+
+    /**
+     * @return {@code true} if user has seen the notification,
+     * {@code false} otherwise.
+     * @see #markAsRead()
+     * @see #setRead(boolean)
+     */
+    public boolean isRead() {
+        return mRead;
     }
 
     //-- COMPARING INSTANCES --------------------------------------------------
@@ -109,6 +259,7 @@ public class OpenNotification {
      */
     @Override
     public int hashCode() {
+        assert mStatusBarNotification != null;
         return mStatusBarNotification.hashCode();
     }
 
@@ -118,11 +269,12 @@ public class OpenNotification {
     @SuppressWarnings("EqualsWhichDoesntCheckParameterClass")
     @Override
     public boolean equals(Object o) {
+        assert mStatusBarNotification != null;
         return mStatusBarNotification.equals(o);
     }
 
     /**
-     * Note, that method is not equals with {@link #equals(Object)} method.
+     * Note, that method does not equals with {@link #equals(Object)} method.
      *
      * @param n notification to compare with.
      * @return {@code true} if notifications are from the same source and will
@@ -135,20 +287,9 @@ public class OpenNotification {
         StatusBarNotification sbn = getStatusBarNotification();
         StatusBarNotification sbn2 = n.getStatusBarNotification();
         if (Device.hasLollipopApi()) {
-            // FIXME: Android L reflections.
-            // service.cancelNotification(notification.getKey());
-            try {
-                Method method = sbn.getClass().getMethod("getKey");
-                method.setAccessible(true);
-                String key = (String) method.invoke(sbn);
-                String key2 = (String) method.invoke(sbn2);
-
-                return new EqualsBuilder()
-                        .append(key, key2)
-                        .isEquals();
-            } catch (NoSuchMethodException
-                    | InvocationTargetException
-                    | IllegalAccessException e) { /* sad, but true */ }
+            return new EqualsBuilder()
+                    .append(sbn2.getKey(), sbn.getKey())
+                    .isEquals();
         }
         return new EqualsBuilder()
                 .append(sbn.getId(), sbn2.getId())
@@ -157,8 +298,120 @@ public class OpenNotification {
                 .isEquals();
     }
 
+    //-- NOTIFICATION DATA ----------------------------------------------------
+
+    /**
+     * Interface definition for a callback to be invoked
+     * when date of notification is changed.
+     */
+    public interface OnNotificationDataChangedListener {
+
+        /**
+         * @see #EVENT_BACKGROUND
+         * @see #EVENT_ICON
+         * @see #EVENT_READ
+         */
+        public void onNotificationDataChanged(@NonNull OpenNotification notification, int event);
+
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void registerListener(@NonNull OnNotificationDataChangedListener listener) {
+        mListeners.add(listener);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void unregisterListener(@NonNull OnNotificationDataChangedListener listener) {
+        mListeners.remove(listener);
+    }
+
+    /**
+     * Notifies all listeners about this event.
+     *
+     * @see com.achep.acdisplay.notifications.OpenNotification.OnNotificationDataChangedListener
+     * @see #registerListener(com.achep.acdisplay.notifications.OpenNotification.OnNotificationDataChangedListener)
+     */
+    private void notifyListeners(int event) {
+        for (OnNotificationDataChangedListener listener : mListeners) {
+            listener.onNotificationDataChanged(this, event);
+        }
+    }
+
+    private void setIcon(@Nullable Bitmap bitmap) {
+        if (mIconBitmap == (mIconBitmap = bitmap)) return;
+        notifyListeners(EVENT_ICON);
+    }
+
+    //-- BACKGROUND -----------------------------------------------------------
+
+    private void setBackground(@Nullable Bitmap bitmap) {
+        if (mBackgroundBitmap == (mBackgroundBitmap = bitmap)) return;
+        notifyListeners(EVENT_BACKGROUND);
+    }
+
+    /**
+     * Asynchronously generates the background of notification. The background is
+     * used by {@link com.achep.acdisplay.ui.fragments.AcDisplayFragment}.
+     *
+     * @see #clearBackground()
+     */
+    public void loadBackgroundAsync() {
+        // Clear old background.
+        clearBackground();
+
+        // Generate new background.
+        Bitmap bitmap = mNotification.largeIcon;
+        if (isBackgroundFine(bitmap)) {
+            assert bitmap != null;
+            mBackgroundWorker = BackgroundFactory.generateAsync(bitmap, mBackgroundCallback);
+        }
+    }
+
+    /**
+     * Stops the {@link #mBackgroundWorker background loader} and sets the background
+     * to {@code null}.
+     *
+     * @see #loadBackgroundAsync()
+     */
+    public void clearBackground() {
+        AsyncTask.stop(mBackgroundWorker);
+        mBackgroundWorker = null;
+        setBackground(null);
+    }
+
+    private boolean isBackgroundFine(@Nullable Bitmap bitmap) {
+        return bitmap != null && !BitmapUtils.hasTransparentCorners(bitmap);
+    }
+
     //-- BASICS ---------------------------------------------------------------
 
+    /**
+     * Marks the notification as read.
+     *
+     * @see #setRead(boolean)
+     */
+    public void markAsRead() {
+        setRead(true);
+    }
+
+    /**
+     * Sets the state of the notification.
+     *
+     * @param isRead {@code true} if user has seen the notification,
+     *               {@code false} otherwise.
+     * @see #markAsRead()
+     */
+    public void setRead(boolean isRead) {
+        if (mRead == (mRead = isRead)) return;
+        notifyListeners(EVENT_READ);
+    }
+
     /**
      * Dismisses this notification from system.
      *
@@ -180,10 +433,12 @@ public class OpenNotification {
     }
 
     /**
-     * Clears all notification's resources.
+     * Clears some notification's resources.
      */
     public void recycle() {
-        mNotificationData.recycle();
+        clearBackground();
+        AsyncTask.stop(mPaletteWorker);
+        AsyncTask.stop(mIconWorker);
     }
 
     /**
@@ -212,11 +467,13 @@ public class OpenNotification {
     }
 
     /**
-     * @return the package name of notification's parent.
+     * @return the package name of notification, or a random string
+     * if not possible to get the package name.
      */
     @SuppressLint("NewApi")
     @NonNull
     public String getPackageName() {
+        assert mStatusBarNotification != null;
         return mStatusBarNotification.getPackageName();
     }
 
diff --git a/project/app/src/main/java/com/achep/acdisplay/notifications/OpenNotificationCompat.java b/project/app/src/main/java/com/achep/acdisplay/notifications/OpenNotificationCompat.java
index e4847792..ccad368e 100644
--- a/project/app/src/main/java/com/achep/acdisplay/notifications/OpenNotificationCompat.java
+++ b/project/app/src/main/java/com/achep/acdisplay/notifications/OpenNotificationCompat.java
@@ -1,18 +1,34 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
 package com.achep.acdisplay.notifications;
 
 import android.app.Notification;
-import android.app.PendingIntent;
 import android.content.Context;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.text.TextUtils;
 import android.widget.RemoteViews;
 
 import org.apache.commons.lang.builder.EqualsBuilder;
 
 /**
-* Created by Artem Chepurnoy on 05.09.2014.
-*/
+ * Created by Artem Chepurnoy on 05.09.2014.
+ */
 // TODO: Find the way to get notification's ID and TAG.
 public class OpenNotificationCompat extends OpenNotification {
 
@@ -23,13 +39,14 @@ public class OpenNotificationCompat extends OpenNotification {
     }
 
     @Override
-    public void loadData(Context context) {
+    public void load(@NonNull Context context) {
         RemoteViews rvs = getNotification().contentView;
         if (rvs == null) rvs = getNotification().bigContentView;
-        if (rvs == null) rvs = getNotification().tickerView;
+        if (rvs == null) //noinspection deprecation
+            rvs = getNotification().tickerView;
         mPackageName = rvs != null ? rvs.getPackage() : "!2#$%^&*()";
 
-        super.loadData(context);
+        super.load(context);
     }
 
     //-- COMPARING INSTANCES --------------------------------------------------
@@ -71,7 +88,7 @@ public class OpenNotificationCompat extends OpenNotification {
         return builder
                 .append(getNotification().ledARGB, n.getNotification().ledARGB)
                 .append(getPackageName(), n.getPackageName())
-                .append(getNotificationData().titleText, n.getNotificationData().titleText)
+                .append(titleText, n.titleText)
                 .isEquals();
 
     }
@@ -86,4 +103,5 @@ public class OpenNotificationCompat extends OpenNotification {
     public String getPackageName() {
         return mPackageName;
     }
+
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/notifications/parser/Utils.java b/project/app/src/main/java/com/achep/acdisplay/notifications/parser/Utils.java
deleted file mode 100644
index 74d494c3..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/notifications/parser/Utils.java
+++ /dev/null
@@ -1,85 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-package com.achep.acdisplay.notifications.parser;
-
-import android.text.SpannableStringBuilder;
-import android.text.Spanned;
-import android.text.TextUtils;
-import android.text.style.ForegroundColorSpan;
-import android.text.style.UnderlineSpan;
-import android.util.Log;
-
-import com.achep.acdisplay.Build;
-
-/**
- * Created by Artem on 29.03.2014.
- */
-final class Utils {
-
-    private static final String TAG = "NotificationParser.Utils";
-
-    /**
-     * Removes all kinds of multiple spaces from given string.
-     */
-    static String removeSpaces(CharSequence cs) {
-        if (cs == null) return null;
-        String string = cs instanceof String
-                ? (String) cs : cs.toString();
-        return string
-                .replaceAll("(\\s+$|^\\s+)", "")
-                .replaceAll("\n+", "\n");
-    }
-
-    static CharSequence mergeLargeMessage(CharSequence[] messages) {
-        if (messages == null) return null;
-        int length = messages.length;
-
-        boolean isFirstMessage = true;
-        boolean highlight = length > 1; // highlight first letters of messages or no?
-
-        SpannableStringBuilder sb = new SpannableStringBuilder();
-        for (CharSequence message : messages) {
-            CharSequence line = Utils.removeSpaces(message);
-            if (TextUtils.isEmpty(line)) {
-                if (Build.DEBUG) Log.w(TAG, "One of text lines was null!");
-                continue;
-            }
-            
-            // Start every new message from new line
-            if (!isFirstMessage & !(isFirstMessage = false)) {
-                sb.append('\n');
-            }
-
-            int start = sb.length();
-            sb.append(line);
-
-            if (highlight) {
-                sb.setSpan(new ForegroundColorSpan(0xaaFFFFFF),
-                        start, start + 1,
-                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-                sb.setSpan(new UnderlineSpan(),
-                        start, start + 1,
-                        Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-            }
-        }
-
-        return sb;
-    }
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/powertoggles/ToggleReceiver.java b/project/app/src/main/java/com/achep/acdisplay/plugins/powertoggles/ToggleReceiver.java
similarity index 96%
rename from project/app/src/main/java/com/achep/acdisplay/powertoggles/ToggleReceiver.java
rename to project/app/src/main/java/com/achep/acdisplay/plugins/powertoggles/ToggleReceiver.java
index eec3ba03..e6d9d503 100644
--- a/project/app/src/main/java/com/achep/acdisplay/powertoggles/ToggleReceiver.java
+++ b/project/app/src/main/java/com/achep/acdisplay/plugins/powertoggles/ToggleReceiver.java
@@ -16,8 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.powertoggles;
+package com.achep.acdisplay.plugins.powertoggles;
 
 import android.content.Context;
 
diff --git a/project/app/src/main/java/com/achep/acdisplay/xposed/ImmersiveModeDontPanic.java b/project/app/src/main/java/com/achep/acdisplay/plugins/xposed/ImmersiveModeDontPanic.java
similarity index 98%
rename from project/app/src/main/java/com/achep/acdisplay/xposed/ImmersiveModeDontPanic.java
rename to project/app/src/main/java/com/achep/acdisplay/plugins/xposed/ImmersiveModeDontPanic.java
index 85e1a9c8..275689a7 100644
--- a/project/app/src/main/java/com/achep/acdisplay/xposed/ImmersiveModeDontPanic.java
+++ b/project/app/src/main/java/com/achep/acdisplay/plugins/xposed/ImmersiveModeDontPanic.java
@@ -16,8 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.xposed;
+package com.achep.acdisplay.plugins.xposed;
 
 import android.util.Log;
 
diff --git a/project/app/src/main/java/com/achep/acdisplay/xposed/OverrideHomeButton.java b/project/app/src/main/java/com/achep/acdisplay/plugins/xposed/OverrideHomeButton.java
similarity index 98%
rename from project/app/src/main/java/com/achep/acdisplay/xposed/OverrideHomeButton.java
rename to project/app/src/main/java/com/achep/acdisplay/plugins/xposed/OverrideHomeButton.java
index 7470e293..0884e8bf 100644
--- a/project/app/src/main/java/com/achep/acdisplay/xposed/OverrideHomeButton.java
+++ b/project/app/src/main/java/com/achep/acdisplay/plugins/xposed/OverrideHomeButton.java
@@ -16,8 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.xposed;
+package com.achep.acdisplay.plugins.xposed;
 
 import android.content.BroadcastReceiver;
 import android.content.Context;
diff --git a/project/app/src/main/java/com/achep/acdisplay/providers/LogAttachmentProvider.java b/project/app/src/main/java/com/achep/acdisplay/providers/LogAttachmentProvider.java
index 9a8d856c..243a5353 100644
--- a/project/app/src/main/java/com/achep/acdisplay/providers/LogAttachmentProvider.java
+++ b/project/app/src/main/java/com/achep/acdisplay/providers/LogAttachmentProvider.java
@@ -16,106 +16,15 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
 package com.achep.acdisplay.providers;
 
-import android.content.ContentProvider;
-import android.content.ContentValues;
-import android.database.Cursor;
-import android.database.MatrixCursor;
-import android.net.Uri;
-import android.os.ParcelFileDescriptor;
-import android.provider.OpenableColumns;
-import android.util.Log;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.util.List;
+import com.achep.base.providers.LogsProviderBase;
 
 /**
  * Created by achep on 16.06.14.
  */
-public class LogAttachmentProvider extends ContentProvider {
-
-    private static final String TAG = "LogAttachmentProvider";
+public class LogAttachmentProvider extends LogsProviderBase {
 
     public static final String AUTHORITY = "com.achep.acdisplay.logs";
-    public static final String DIRECTORY = "logs";
-
-    private static final String COLUMN_DATA = "_data";
-
-    @Override
-    public boolean onCreate() {
-        return true;
-    }
-
-    @Override
-    public Cursor query(Uri uri, String[] projection, String selection,
-                        String[] selectionArgs, String orderBy) {
-        List<String> pathSegments = uri.getPathSegments();
-        String fileName = pathSegments.get(0);
-        File logFile = getContext().getCacheDir();
-        if (logFile == null) {
-            Log.e(TAG, "No cache dir.");
-            return null;
-        }
-
-        logFile = new File(new File(logFile, DIRECTORY), fileName);
-        if (!logFile.exists()) {
-            Log.e(TAG, "Requested log file doesn't exist.");
-            return null;
-        }
-
-        if (projection == null) {
-            projection = new String[]{
-                    COLUMN_DATA,
-                    OpenableColumns.DISPLAY_NAME,
-                    OpenableColumns.SIZE,
-            };
-        }
-
-        MatrixCursor matrixCursor = new MatrixCursor(projection, 1);
-        Object[] row = new Object[projection.length];
-        for (int col = 0; col < projection.length; col++) {
-            switch (projection[col]) {
-                case COLUMN_DATA:
-                    row[col] = logFile.getAbsolutePath();
-                    break;
-                case OpenableColumns.DISPLAY_NAME:
-                    row[col] = fileName;
-                    break;
-                case OpenableColumns.SIZE:
-                    row[col] = logFile.length();
-                    break;
-            }
-        }
-        matrixCursor.addRow(row);
-        return matrixCursor;
-    }
-
-    @Override
-    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
-        return openFileHelper(uri, "r");
-    }
-
-    @Override
-    public String getType(Uri uri) {
-        return "text/plain";
-    }
-
-    @Override
-    public Uri insert(Uri uri, ContentValues values) {
-        throw new UnsupportedOperationException("insert not supported");
-    }
-
-    @Override
-    public int delete(Uri uri, String selection, String[] selectionArgs) {
-        throw new UnsupportedOperationException("delete not supported");
-    }
 
-    @Override
-    public int update(Uri uri, ContentValues contentValues, String selection,
-                      String[] selectionArgs) {
-        throw new UnsupportedOperationException("update not supported");
-    }
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/providers/ToggleWidgetProvider.java b/project/app/src/main/java/com/achep/acdisplay/providers/ToggleWidgetProvider.java
index 8417a126..3c53c2d0 100644
--- a/project/app/src/main/java/com/achep/acdisplay/providers/ToggleWidgetProvider.java
+++ b/project/app/src/main/java/com/achep/acdisplay/providers/ToggleWidgetProvider.java
@@ -16,7 +16,6 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
 package com.achep.acdisplay.providers;
 
 import android.app.PendingIntent;
@@ -26,13 +25,15 @@ import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.content.res.Resources;
+import android.support.annotation.NonNull;
 import android.util.Log;
 import android.widget.RemoteViews;
 
 import com.achep.acdisplay.App;
-import com.achep.acdisplay.Build;
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.R;
+import com.achep.base.Build;
+import com.achep.base.content.ConfigBase;
 
 /**
  * Toggle widget provider.
@@ -40,7 +41,7 @@ import com.achep.acdisplay.R;
  * @author Artem Chepurnoy
  */
 public class ToggleWidgetProvider extends AppWidgetProvider
-        implements Config.OnConfigChangedListener {
+        implements ConfigBase.OnConfigChangedListener {
 
     private static final String TAG = "AppWidgetProvider";
 
@@ -65,7 +66,9 @@ public class ToggleWidgetProvider extends AppWidgetProvider
     }
 
     @Override
-    public void onConfigChanged(Config config, String key, Object value) {
+    public void onConfigChanged(@NonNull ConfigBase config,
+                                @NonNull String key,
+                                @NonNull Object value) {
         switch (key) {
             case Config.KEY_ENABLED:
                 updateWidgets(config.getContext());
@@ -113,7 +116,7 @@ public class ToggleWidgetProvider extends AppWidgetProvider
             RemoteViews rv = new RemoteViews(context.getPackageName(), R.layout.appwidget_toggle_layout);
             rv.setOnClickPendingIntent(R.id.container, pendingIntent);
             rv.setTextViewText(R.id.title, res.getString(
-                    mConfig.isEnabled() ? R.string.widget_toggle_enabled : R.string.widget_toggle_disabled));
+                    mConfig.isEnabled() ? R.string.enabled : R.string.disabled));
 
             // Tell the AppWidgetManager to perform an update on the current app widget
             appWidgetManager.updateAppWidget(appWidgetId, rv);
diff --git a/project/app/src/main/java/com/achep/acdisplay/admin/AdminReceiver.java b/project/app/src/main/java/com/achep/acdisplay/receiver/AdminReceiver.java
similarity index 85%
rename from project/app/src/main/java/com/achep/acdisplay/admin/AdminReceiver.java
rename to project/app/src/main/java/com/achep/acdisplay/receiver/AdminReceiver.java
index ccff2c44..18330158 100644
--- a/project/app/src/main/java/com/achep/acdisplay/admin/AdminReceiver.java
+++ b/project/app/src/main/java/com/achep/acdisplay/receiver/AdminReceiver.java
@@ -16,8 +16,9 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.admin;
+package com.achep.acdisplay.receiver;
 
+import android.content.ComponentName;
 import android.content.Context;
 import android.content.Intent;
 import android.support.v4.content.LocalBroadcastManager;
@@ -42,7 +43,7 @@ public class AdminReceiver extends android.app.admin.DeviceAdminReceiver {
         Config config = Config.getInstance();
         if (config.isEnabled()) {
 
-            Toast.makeText(context, R.string.app_auto_disabled, Toast.LENGTH_LONG).show();
+            Toast.makeText(context, R.string.permissions_auto_disabled, Toast.LENGTH_LONG).show();
             config.setEnabled(context, false, null); // auto disabling :/
         }
     }
@@ -52,4 +53,9 @@ public class AdminReceiver extends android.app.admin.DeviceAdminReceiver {
         super.onEnabled(context, intent);
         LocalBroadcastManager.getInstance(context).sendBroadcast(new Intent(ACTION_ENABLED));
     }
+
+    public static ComponentName newComponentName(Context context) {
+        return new ComponentName(context, AdminReceiver.class);
+    }
+
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/receiver/LocalReceiverActivity.java b/project/app/src/main/java/com/achep/acdisplay/receiver/LocalReceiverActivity.java
index c1080cf2..93f13026 100644
--- a/project/app/src/main/java/com/achep/acdisplay/receiver/LocalReceiverActivity.java
+++ b/project/app/src/main/java/com/achep/acdisplay/receiver/LocalReceiverActivity.java
@@ -27,13 +27,12 @@ import android.content.Intent;
 import android.net.Uri;
 import android.os.Bundle;
 import android.provider.Settings;
-import android.support.v4.content.LocalBroadcastManager;
+import android.support.annotation.Nullable;
 import android.util.Log;
 
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.admin.AdminReceiver;
-import com.achep.acdisplay.utils.PackageUtils;
-import com.achep.acdisplay.utils.ToastUtils;
+import com.achep.base.utils.PackageUtils;
+import com.achep.base.utils.ToastUtils;
 
 /**
  * Created by Artem on 12.03.14.
@@ -50,43 +49,25 @@ public class LocalReceiverActivity extends Activity {
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 
-        Intent intent = getIntent();
-        if (intent != null) {
-            handleIntent(intent);
-        } else {
-            Log.wtf(TAG, "Got an empty launch intent.");
-        }
-
+        handleIntent(getIntent());
         finish();
     }
 
-    static String extractHost(Intent intent) {
-        Uri data = intent.getData();
-        return data != null ? data.getHost() : null;
-    }
+    private void handleIntent(@Nullable Intent intent) {
+        Uri data;
+        String host;
 
-    private void handleIntent(Intent intent) {
-        String host = extractHost(intent);
-        if (host == null) {
-            Log.wtf(TAG, "Got an empty launch intent.");
-            return;
-        }
+        if (intent == null
+                || (data = intent.getData()) == null
+                || (host = data.getHost()) == null) return;
 
         switch (host) {
             case HOST_REMOVE_ADMIN_ACCESS:
-                ComponentName admin = new ComponentName(this, AdminReceiver.class);
-                DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
-
-                try {
-                    dpm.removeActiveAdmin(admin);
-                    ToastUtils.showShort(this, R.string.access_device_admin_removed_successful);
-                } catch (SecurityException e) {
-                    Log.i(TAG, "Failed to remove AcDisplay from active device admins.");
-                }
-                Log.i(TAG, "asdasdasd");
+                removeDeviceAdminRights();
                 break;
             case HOST_UNINSTALL:
                 try {
+                    removeDeviceAdminRights();
                     startActivity(new Intent(
                             Intent.ACTION_UNINSTALL_PACKAGE,
                             Uri.fromParts("package", PackageUtils.getName(this), null)));
@@ -103,14 +84,21 @@ public class LocalReceiverActivity extends Activity {
                     Log.wtf(TAG, "Failed to start ApplicationDetails activity.");
                 }
                 break;
-            default:
-                Log.wtf(TAG, "Got an unknown intent: " + host);
-                return;
         }
+    }
 
-        Intent broadcastIntent = new Intent();
-        broadcastIntent.setAction(host);
-        LocalBroadcastManager.getInstance(this).sendBroadcast(broadcastIntent);
+    private void removeDeviceAdminRights() {
+        ComponentName component = AdminReceiver.newComponentName(this);
+        DevicePolicyManager dpm = (DevicePolicyManager)
+                getSystemService(Context.DEVICE_POLICY_SERVICE);
+
+        if (dpm.isAdminActive(component)) {
+            try {
+                dpm.removeActiveAdmin(component);
+                ToastUtils.showShort(this, R.string.permissions_device_admin_removed);
+            } catch (SecurityException ignored) {
+            }
+        }
     }
 
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/receiver/Receiver.java b/project/app/src/main/java/com/achep/acdisplay/receiver/ReceiverPublic.java
similarity index 55%
rename from project/app/src/main/java/com/achep/acdisplay/receiver/Receiver.java
rename to project/app/src/main/java/com/achep/acdisplay/receiver/ReceiverPublic.java
index ae5ee72b..24105bc1 100644
--- a/project/app/src/main/java/com/achep/acdisplay/receiver/Receiver.java
+++ b/project/app/src/main/java/com/achep/acdisplay/receiver/ReceiverPublic.java
@@ -26,53 +26,37 @@ import android.util.Log;
 import com.achep.acdisplay.App;
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.services.KeyguardService;
-import com.achep.acdisplay.services.SensorsDumpService;
-import com.achep.acdisplay.services.activemode.ActiveModeService;
-import com.achep.acdisplay.utils.ToastUtils;
+import com.achep.base.utils.ToastUtils;
 
 /**
  * Created by Artem on 11.03.14.
  */
-public class Receiver extends BroadcastReceiver {
+public class ReceiverPublic extends BroadcastReceiver {
 
-    private static final String TAG = "Receiver";
+    private static final String TAG = "PublicReceiver";
 
     @Override
     public void onReceive(Context context, Intent intent) {
+        Config config = Config.getInstance();
         String action = intent.getAction();
         switch (action) {
-            case Intent.ACTION_BOOT_COMPLETED:
-            case Intent.ACTION_POWER_CONNECTED:
-            case Intent.ACTION_POWER_DISCONNECTED:
-                ActiveModeService.handleState(context);
-                KeyguardService.handleState(context);
-                SensorsDumpService.handleState(context);
-                break;
             case App.ACTION_ENABLE:
+                Log.i(TAG, "Enabling AcDisplay by intent. " + intent);
+                setAcDisplayEnabled(context, config, true);
+                break;
             case App.ACTION_DISABLE:
+                Log.i(TAG, "Disabling AcDisplay by intent. " + intent);
+                setAcDisplayEnabled(context, config, false);
+                break;
             case App.ACTION_TOGGLE:
-                Config config = Config.getInstance();
-                switch (action) {
-                    case App.ACTION_ENABLE:
-                        Log.i(TAG, "Enabling AcDisplay from broadcast receiver.");
-                        setAcDisplayEnabled(context, config, true);
-                        break;
-                    case App.ACTION_DISABLE:
-                        Log.i(TAG, "Disabling AcDisplay from broadcast receiver.");
-                        setAcDisplayEnabled(context, config, false);
-                        break;
-                    default:
-                        Log.i(TAG, "Toggling from broadcast receiver.");
-                        setAcDisplayEnabled(context, config, !config.isEnabled());
-                        break;
-                }
+                Log.i(TAG, "Toggling AcDisplay by intent. " + intent);
+                setAcDisplayEnabled(context, config, !config.isEnabled());
                 break;
         }
     }
 
     /**
-     * Tries to {@link Config#setEnabled(Context, boolean, Config.OnConfigChangedListener) enable / disable }
+     * Tries to {@link com.achep.acdisplay.Config#setEnabled(android.content.Context, boolean, com.achep.acdisplay.Config.OnConfigChangedListener) enable / disable }
      * AcDisplay and shows toast message about the result.
      *
      * @param enable {@code true} to enable AcDisplay, {@code false} to disable.
@@ -83,4 +67,5 @@ public class Receiver extends BroadcastReceiver {
                 ? R.string.remote_enable_acdisplay
                 : R.string.remote_disable_acdisplay);
     }
+
 }
\ No newline at end of file
diff --git a/project/app/src/main/java/com/achep/acdisplay/receiver/ReceiverSystem.java b/project/app/src/main/java/com/achep/acdisplay/receiver/ReceiverSystem.java
new file mode 100644
index 00000000..74c5f4db
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/receiver/ReceiverSystem.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.receiver;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+
+import com.achep.acdisplay.services.KeyguardService;
+import com.achep.acdisplay.services.SensorsDumpService;
+import com.achep.acdisplay.services.activemode.ActiveModeService;
+
+/**
+ * Created by Artem on 11.03.14.
+ */
+public class ReceiverSystem extends BroadcastReceiver {
+
+    private static final String TAG = "Receiver";
+
+    @Override
+    public void onReceive(Context context, Intent intent) {
+        String action = intent.getAction();
+        switch (action) {
+            case Intent.ACTION_BOOT_COMPLETED:
+            case Intent.ACTION_POWER_CONNECTED:
+            case Intent.ACTION_POWER_DISCONNECTED:
+                ActiveModeService.handleState(context);
+                KeyguardService.handleState(context);
+                SensorsDumpService.handleState(context);
+                break;
+        }
+    }
+
+}
\ No newline at end of file
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/AccessibilityService.java b/project/app/src/main/java/com/achep/acdisplay/services/AccessibilityService.java
index 55e96950..0f87f6e8 100644
--- a/project/app/src/main/java/com/achep/acdisplay/services/AccessibilityService.java
+++ b/project/app/src/main/java/com/achep/acdisplay/services/AccessibilityService.java
@@ -1,3 +1,21 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
 package com.achep.acdisplay.services;
 
 import android.accessibilityservice.AccessibilityServiceInfo;
@@ -5,15 +23,16 @@ import android.app.Notification;
 import android.os.Parcelable;
 import android.view.accessibility.AccessibilityEvent;
 
-import com.achep.acdisplay.Device;
 import com.achep.acdisplay.notifications.NotificationPresenter;
 import com.achep.acdisplay.notifications.OpenNotification;
+import com.achep.base.Device;
 
 /**
  * Created by Artem Chepurnoy on 06.09.2014.
  */
 public class AccessibilityService extends android.accessibilityservice.AccessibilityService {
 
+    private static final String TAG = "AccessibilityService";
     public static boolean isRunning;
 
     @Override
@@ -41,7 +60,7 @@ public class AccessibilityService extends android.accessibilityservice.Accessibi
 
                     Notification notification = (Notification) parcelable;
                     OpenNotification openNotification = OpenNotification.newInstance(notification);
-                    NotificationPresenter.getInstance().postNotification(this, openNotification, 0);
+                    NotificationPresenter.getInstance().postNotificationFromMain(this, openNotification, 0);
                 }
                 break;
         }
@@ -51,4 +70,5 @@ public class AccessibilityService extends android.accessibilityservice.Accessibi
     public void onInterrupt() {
         isRunning = false;
     }
+
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/BathService.java b/project/app/src/main/java/com/achep/acdisplay/services/BathService.java
index 8eac8dfa..c764ef39 100644
--- a/project/app/src/main/java/com/achep/acdisplay/services/BathService.java
+++ b/project/app/src/main/java/com/achep/acdisplay/services/BathService.java
@@ -16,7 +16,6 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
 package com.achep.acdisplay.services;
 
 import android.app.Notification;
@@ -33,10 +32,10 @@ import android.text.TextUtils;
 import android.util.Log;
 
 import com.achep.acdisplay.App;
-import com.achep.acdisplay.Build;
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.activities.MainActivity;
-import com.achep.acdisplay.interfaces.IOnLowMemory;
+import com.achep.acdisplay.ui.activities.MainActivity;
+import com.achep.base.Build;
+import com.achep.base.interfaces.IOnLowMemory;
 
 import java.util.HashMap;
 import java.util.Map;
@@ -200,7 +199,7 @@ public class BathService extends Service {
      * <p>NOT SYNCHRONIZED!</p>
      * Builds fresh notification with all {@link ChildService children services}'s
      * {@link com.achep.acdisplay.services.BathService.ChildService#getLabel() labels} in.
-     * Content intent starts {@link com.achep.acdisplay.activities.MainActivity}.
+     * Content intent starts {@link com.achep.acdisplay.ui.activities.MainActivity}.
      */
     private Notification buildNotification() {
         boolean empty = true;
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/KeyguardService.java b/project/app/src/main/java/com/achep/acdisplay/services/KeyguardService.java
index c7a4e0fe..3573f93b 100644
--- a/project/app/src/main/java/com/achep/acdisplay/services/KeyguardService.java
+++ b/project/app/src/main/java/com/achep/acdisplay/services/KeyguardService.java
@@ -24,31 +24,41 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.os.SystemClock;
+import android.support.annotation.NonNull;
 import android.telephony.TelephonyManager;
 import android.util.Log;
 
-import com.achep.acdisplay.Build;
+import com.achep.acdisplay.Atomic;
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.Presenter;
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.acdisplay.AcDisplayActivity;
-import com.achep.acdisplay.utils.PackageUtils;
-import com.achep.acdisplay.utils.PowerUtils;
+import com.achep.acdisplay.notifications.NotificationPresenter;
+import com.achep.acdisplay.notifications.OpenNotification;
+import com.achep.base.content.ConfigBase;
+import com.achep.base.utils.PackageUtils;
+import com.achep.base.utils.power.PowerUtils;
 
 import java.util.List;
 
+import static com.achep.base.Build.DEBUG;
+
 /**
  * Created by Artem on 16.02.14.
  *
  * @author Artem Chepurnoy
  */
-public class KeyguardService extends BathService.ChildService {
+public class KeyguardService extends BathService.ChildService implements
+        ConfigBase.OnConfigChangedListener,
+        NotificationPresenter.OnNotificationListChangedListener {
 
     private static final String TAG = "KeyguardService";
 
     private static final int ACTIVITY_LAUNCH_MAX_TIME = 1000;
 
     private ActivityMonitorThread mActivityMonitorThread;
+    private String mPackageName;
+
+    public static boolean isActive = false;
 
     /**
      * Starts or stops this service as required by settings and device's state.
@@ -68,6 +78,61 @@ public class KeyguardService extends BathService.ChildService {
         }
     }
 
+    private final Atomic mAtomicOption = new Atomic(new Atomic.Callback() {
+
+        private final NotificationPresenter mNp = NotificationPresenter.getInstance();
+
+        @Override
+        public void onStart(Object... objects) {
+            mNp.registerListener(KeyguardService.this);
+            updateState();
+        }
+
+        @Override
+        public void onStop(Object... objects) {
+            mNp.unregisterListener(KeyguardService.this);
+            mAtomicMain.start();
+        }
+
+    });
+
+    private final Atomic mAtomicMain = new Atomic(new Atomic.Callback() {
+
+        @Override
+        public void onStart(Object... objects) {
+            final Context context = getContext();
+
+            IntentFilter intentFilter = new IntentFilter();
+            intentFilter.addAction(Intent.ACTION_SCREEN_ON);
+            intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
+            intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY - 1); // highest priority
+            context.registerReceiver(mReceiver, intentFilter);
+
+            if (!PowerUtils.isScreenOn(context)) {
+                Intent intent = new Intent();
+                intent.setAction(Intent.ACTION_SCREEN_OFF);
+                mReceiver.onReceive(context, intent);
+            }
+
+            isActive = true;
+        }
+
+        @Override
+        public void onStop(Object... objects) {
+            final Context context = getContext();
+
+            getContext().unregisterReceiver(mReceiver);
+            stopMonitoringActivities();
+
+            if (!PowerUtils.isScreenOn(context)) {
+                Presenter.getInstance().kill();
+            }
+
+            isActive = false;
+        }
+
+    });
+
     private final BroadcastReceiver mReceiver = new BroadcastReceiver() {
 
         @Override
@@ -90,8 +155,11 @@ public class KeyguardService extends BathService.ChildService {
                     long now = SystemClock.elapsedRealtime();
                     boolean becauseOfActivityLaunch =
                             now - activityChangeTime < ACTIVITY_LAUNCH_MAX_TIME
-                                    && activityName != null && !activityName.startsWith(
-                                    PackageUtils.getName(getContext()));
+                                    && activityName != null
+                                    && !activityName.startsWith(mPackageName);
+
+                    if (DEBUG) Log.d(TAG, "Screen is on: is_call=" + isCall +
+                            " activity_flag=" + becauseOfActivityLaunch);
 
                     if (isCall) {
                         return;
@@ -102,14 +170,10 @@ public class KeyguardService extends BathService.ChildService {
                         // Finish AcDisplay activity so it won't shown
                         // after exiting from newly launched one.
                         Presenter.getInstance().kill();
-                    } else startGui();
-
-                    if (Build.DEBUG)
-                        Log.d(TAG, "Screen is on: is_call=" + isCall +
-                                " activity_flag=" + becauseOfActivityLaunch);
+                    } else startGui(); // Normal launch
                     break;
                 case Intent.ACTION_SCREEN_OFF:
-                    if (!isCall) startGui();
+                    if (!isCall) startGuiGhost(); // Ghost launch
 
                     startMonitoringActivities();
                     break;
@@ -118,16 +182,17 @@ public class KeyguardService extends BathService.ChildService {
 
     };
 
+    private void startGuiGhost() {
+        startGui();
+    }
+
     private void startGui() {
-        Context context = getContext();
-        context.startActivity(new Intent(context, AcDisplayActivity.class)
-                .setFlags(Intent.FLAG_ACTIVITY_NEW_TASK
-                        | Intent.FLAG_ACTIVITY_NO_ANIMATION));
+        Presenter.getInstance().tryStartGuiCauseKeyguard(getContext());
     }
 
     private void startMonitoringActivities() {
         stopMonitoringActivities();
-        if (Build.DEBUG) Log.d(TAG, "Starting to monitor activities.");
+        if (DEBUG) Log.d(TAG, "Starting to monitor activities.");
 
         ActivityManager am = (ActivityManager) getContext()
                 .getSystemService(Context.ACTIVITY_SERVICE);
@@ -137,7 +202,7 @@ public class KeyguardService extends BathService.ChildService {
 
     private void stopMonitoringActivities() {
         if (mActivityMonitorThread != null) {
-            if (Build.DEBUG) Log.d(TAG, "Stopping to monitor activities.");
+            if (DEBUG) Log.d(TAG, "Stopping to monitor activities.");
 
             mActivityMonitorThread.running = false;
             mActivityMonitorThread.interrupt();
@@ -147,17 +212,19 @@ public class KeyguardService extends BathService.ChildService {
 
     @Override
     public void onCreate() {
-        IntentFilter intentFilter = new IntentFilter();
-        intentFilter.addAction(Intent.ACTION_SCREEN_ON);
-        intentFilter.addAction(Intent.ACTION_SCREEN_OFF);
-        intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY - 1); // highest priority
-        getContext().registerReceiver(mReceiver, intentFilter);
+        mPackageName = PackageUtils.getName(getContext());
+
+        Config config = Config.getInstance();
+        config.registerListener(this);
+        (config.isKeyguardWithoutNotifiesEnabled() ? mAtomicMain : mAtomicOption).start();
     }
 
     @Override
     public void onDestroy() {
-        getContext().unregisterReceiver(mReceiver);
-        stopMonitoringActivities();
+        Config config = Config.getInstance();
+        config.unregisterListener(this);
+        mAtomicOption.stop();
+        mAtomicMain.stop();
     }
 
     @Override
@@ -165,6 +232,42 @@ public class KeyguardService extends BathService.ChildService {
         return getContext().getString(R.string.service_bath_keyguard);
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onConfigChanged(@NonNull ConfigBase config,
+                                @NonNull String key,
+                                @NonNull Object value) {
+        switch (key) {
+            case Config.KEY_KEYGUARD_WITHOUT_NOTIFICATIONS:
+                boolean start = !(boolean) value;
+                mAtomicOption.react(start);
+                break;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onNotificationListChanged(@NonNull NotificationPresenter np,
+                                          OpenNotification osbn,
+                                          int event, boolean f) {
+        switch (event) {
+            case NotificationPresenter.EVENT_POSTED:
+            case NotificationPresenter.EVENT_REMOVED:
+            case NotificationPresenter.EVENT_BATH:
+                updateState();
+                break;
+        }
+    }
+
+    private void updateState() {
+        boolean start = NotificationPresenter.getInstance().size() >= 1;
+        mAtomicMain.react(start);
+    }
+
     /**
      * Thread that monitors current top activity.
      * This is needed to prevent launching AcDisplay above any other
@@ -188,14 +291,12 @@ public class KeyguardService extends BathService.ChildService {
         @Override
         public void run() {
             super.run();
-
-            while (running) {
-                monitor();
-
-                try {
+            try {
+                while (running) {
+                    monitor();
                     Thread.sleep(MONITORING_PERIOD);
-                } catch (InterruptedException e) { /* unused */ }
-            }
+                }
+            } catch (InterruptedException e) { /* unused */ }
         }
 
         /**
@@ -217,7 +318,7 @@ public class KeyguardService extends BathService.ChildService {
 
                 topActivityName = topActivity;
 
-                if (Build.DEBUG) Log.d(TAG, "Current latest activity is " + topActivityName);
+                if (DEBUG) Log.d(TAG, "Current top activity is " + topActivityName);
             }
         }
     }
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/MediaService.java b/project/app/src/main/java/com/achep/acdisplay/services/MediaService.java
index 779c785c..625304ea 100644
--- a/project/app/src/main/java/com/achep/acdisplay/services/MediaService.java
+++ b/project/app/src/main/java/com/achep/acdisplay/services/MediaService.java
@@ -16,7 +16,6 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
 package com.achep.acdisplay.services;
 
 import android.annotation.SuppressLint;
@@ -25,25 +24,26 @@ import android.content.Intent;
 import android.media.AudioManager;
 import android.media.RemoteController;
 import android.os.Binder;
-import android.os.Handler;
 import android.os.IBinder;
-import android.os.Looper;
 import android.service.notification.NotificationListenerService;
 import android.service.notification.StatusBarNotification;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.Log;
 
 import com.achep.acdisplay.App;
-import com.achep.acdisplay.Device;
 import com.achep.acdisplay.R;
 import com.achep.acdisplay.notifications.NotificationPresenter;
 import com.achep.acdisplay.notifications.OpenNotification;
+import com.achep.base.Device;
 
 /**
  * Created by achep on 07.06.14.
  *
  * @author Artem Chepurnoy
  */
-@SuppressLint("NewApi")
+@SuppressWarnings("deprecation") // RemoteController is completely outdated.
+@SuppressLint("NewApi") // RemoteController is a new thing.
 public class MediaService extends NotificationListenerService implements
         RemoteController.OnClientUpdateListener {
 
@@ -58,8 +58,6 @@ public class MediaService extends NotificationListenerService implements
     private RemoteController mRemoteController;
     private RemoteController.OnClientUpdateListener mExternalListener;
 
-    private final Handler mHandler = new Handler(Looper.getMainLooper());
-
     public class B extends Binder {
 
         public MediaService getService() {
@@ -68,12 +66,17 @@ public class MediaService extends NotificationListenerService implements
 
     }
 
+    private static boolean isRemoteControllerSupported() {
+        return Device.hasKitKatApi() && !Device.hasLollipopApi();
+    }
+
     @Override
-    public IBinder onBind(Intent intent) {
+    public IBinder onBind(@NonNull Intent intent) {
         switch (intent.getAction()) {
             case App.ACTION_BIND_MEDIA_CONTROL_SERVICE:
-                if (!Device.hasKitKatApi() && !Device.hasLollipopApi()) {
-                    throw new RuntimeException("Required Android API version 19!");
+                if (!isRemoteControllerSupported()) {
+                    // Should never happen normally.
+                    throw new RuntimeException("Not supported Android version!");
                 }
                 return mBinder;
             default:
@@ -92,7 +95,7 @@ public class MediaService extends NotificationListenerService implements
     }
 
     @Override
-    public boolean onUnbind(Intent intent) {
+    public boolean onUnbind(@NonNull Intent intent) {
         switch (intent.getAction()) {
             case App.ACTION_BIND_MEDIA_CONTROL_SERVICE:
                 break;
@@ -103,42 +106,40 @@ public class MediaService extends NotificationListenerService implements
         return super.onUnbind(intent);
     }
 
+    //-- HANDLING NOTIFICATIONS -----------------------------------------------
+
     @Override
-    public void onNotificationPosted(StatusBarNotification notification) {
-        rockNotification(notification, true);
+    public void onNotificationPosted(@NonNull StatusBarNotification notification) {
+        NotificationPresenter np = NotificationPresenter.getInstance();
+        if (np.isInitialized()) {
+            OpenNotification n = OpenNotification.newInstance(notification);
+            np.postNotificationFromMain(this, n, 0);
+        } else {
+            rockNotification(np);
+        }
     }
 
     @Override
-    public void onNotificationRemoved(final StatusBarNotification notification) {
-        rockNotification(notification, false);
-    }
-
-    private void rockNotification(final StatusBarNotification sbn, final boolean post) {
-        final StatusBarNotification[] activeNotifies = getActiveNotifications();
-        runOnMainLooper(new Runnable() {
-            @Override
-            public void run() {
-                OpenNotification n = OpenNotification.newInstance(sbn);
-                NotificationPresenter np = NotificationPresenter.getInstance();
-
-                if (post) {
-                    np.postNotification(MediaService.this, n, 0);
-                } else {
-                    np.removeNotification(n);
-                }
-
-                np.tryInit(MediaService.this, sbn, activeNotifies);
-            }
-        });
+    public void onNotificationRemoved(@NonNull StatusBarNotification notification) {
+        NotificationPresenter np = NotificationPresenter.getInstance();
+        if (np.isInitialized()) {
+            OpenNotification n = OpenNotification.newInstance(notification);
+            np.removeNotificationFromMain(n);
+        } else {
+            rockNotification(np);
+        }
     }
 
-    private void runOnMainLooper(Runnable runnable) {
-        mHandler.post(runnable);
+    private void rockNotification(@NonNull NotificationPresenter np) {
+        StatusBarNotification[] activeNotifies = getActiveNotifications();
+        np.tryInit(MediaService.this, activeNotifies);
     }
 
+    //-- REMOTE CONTROLLER ----------------------------------------------------
+
     @Override
     public void onCreate() {
-        if (Device.hasKitKatApi() && !Device.hasLollipopApi()) {
+        if (isRemoteControllerSupported()) {
             mRemoteController = new RemoteController(this, this);
             mAudioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);
         }
@@ -146,7 +147,7 @@ public class MediaService extends NotificationListenerService implements
 
     @Override
     public void onDestroy() {
-        if (Device.hasKitKatApi() && !Device.hasLollipopApi()) {
+        if (isRemoteControllerSupported()) {
             setRemoteControllerDisabled();
         }
     }
@@ -159,7 +160,7 @@ public class MediaService extends NotificationListenerService implements
         mRegistered = mAudioManager.registerRemoteController(mRemoteController);
 
         if (mRegistered) {
-            final int size = getResources().getDimensionPixelSize(R.dimen.artwork_size);
+            final int size = getResources().getDimensionPixelSize(R.dimen.media_artwork_size);
             mRemoteController.setArtworkConfiguration(size, size);
             //setSynchronizationMode(mRemoteController, RemoteController.POSITION_SYNCHRONIZATION_CHECK);
         } else {
@@ -183,7 +184,7 @@ public class MediaService extends NotificationListenerService implements
     /**
      * Sets up external callback for client update events.
      */
-    public void setClientUpdateListener(RemoteController.OnClientUpdateListener listener) {
+    public void setClientUpdateListener(@Nullable RemoteController.OnClientUpdateListener listener) {
         mExternalListener = listener;
     }
 
@@ -221,4 +222,5 @@ public class MediaService extends NotificationListenerService implements
             mExternalListener.onClientMetadataUpdate(metadataEditor);
         }
     }
+
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/SensorsDumpService.java b/project/app/src/main/java/com/achep/acdisplay/services/SensorsDumpService.java
index 4f0d614d..91605cd1 100644
--- a/project/app/src/main/java/com/achep/acdisplay/services/SensorsDumpService.java
+++ b/project/app/src/main/java/com/achep/acdisplay/services/SensorsDumpService.java
@@ -16,7 +16,6 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
 package com.achep.acdisplay.services;
 
 import android.content.BroadcastReceiver;
@@ -32,11 +31,11 @@ import android.os.SystemClock;
 import android.support.annotation.NonNull;
 import android.util.Log;
 
-import com.achep.acdisplay.Build;
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.utils.FileUtils;
-import com.achep.acdisplay.utils.PowerUtils;
+import com.achep.base.Build;
+import com.achep.base.utils.FileUtils;
+import com.achep.base.utils.power.PowerUtils;
 
 import java.io.File;
 import java.util.LinkedList;
@@ -55,11 +54,12 @@ public class SensorsDumpService extends BathService.ChildService implements
     private static final int MAX_SIZE = 2500;
 
     private SensorManager mSensorManager;
-    private final int[] mSensorTypes = new int[] {
-        Sensor.TYPE_GYROSCOPE, Sensor.TYPE_ACCELEROMETER,
+    private final int[] mSensorTypes = new int[]{
+            Sensor.TYPE_GYROSCOPE, Sensor.TYPE_ACCELEROMETER,
     };
 
     private final LinkedList<Event> mEventList = new LinkedList<>();
+
     private static class Event {
         long timestamp;
         float[] values;
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeHandler.java b/project/app/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeHandler.java
index 73670d92..2a28a1c2 100644
--- a/project/app/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeHandler.java
+++ b/project/app/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeHandler.java
@@ -16,7 +16,6 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
 package com.achep.acdisplay.services.activemode;
 
 import android.content.Context;
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeSensor.java b/project/app/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeSensor.java
index c92fed1e..df7db951 100644
--- a/project/app/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeSensor.java
+++ b/project/app/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeSensor.java
@@ -16,7 +16,6 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
 package com.achep.acdisplay.services.activemode;
 
 import android.content.Context;
@@ -32,7 +31,7 @@ import com.achep.acdisplay.services.activemode.sensors.ProximitySensor;
 import java.util.ArrayList;
 
 /**
- * Provides a callback when {@link com.achep.acdisplay.acdisplay.AcDisplayActivity}
+ * Provides a callback when {@link com.achep.acdisplay.ui.activities.AcDisplayActivity}
  * should be started and stopped.
  *
  * @author Artem Chepurnoy
@@ -96,7 +95,7 @@ public abstract class ActiveModeSensor {
      *
      * @return {@code true} if the sensor is supported by device, {@code false} otherwise.
      */
-    protected boolean isSupported(@NonNull SensorManager sensorManager) {
+    public boolean isSupported(@NonNull SensorManager sensorManager) {
         return sensorManager.getSensorList(getType()).size() > 0;
     }
 
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeService.java b/project/app/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeService.java
index 9708e3ff..b9378c95 100644
--- a/project/app/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeService.java
+++ b/project/app/src/main/java/com/achep/acdisplay/services/activemode/ActiveModeService.java
@@ -22,6 +22,7 @@ import android.content.BroadcastReceiver;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
+import android.hardware.Sensor;
 import android.hardware.SensorManager;
 import android.os.PowerManager;
 import android.os.SystemClock;
@@ -31,7 +32,6 @@ import android.util.Log;
 
 import com.achep.acdisplay.App;
 import com.achep.acdisplay.Atomic;
-import com.achep.acdisplay.Build;
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.Presenter;
 import com.achep.acdisplay.R;
@@ -44,7 +44,8 @@ import com.achep.acdisplay.services.activemode.handlers.WithoutNotifiesHandler;
 import com.achep.acdisplay.services.activemode.sensors.AccelerometerSensor;
 import com.achep.acdisplay.services.activemode.sensors.GyroscopeSensor;
 import com.achep.acdisplay.services.activemode.sensors.ProximitySensor;
-import com.achep.acdisplay.utils.PowerUtils;
+import com.achep.base.Build;
+import com.achep.base.utils.power.PowerUtils;
 
 /**
  * Service that turns on AcDisplay exactly when it's needed.
@@ -56,7 +57,7 @@ import com.achep.acdisplay.utils.PowerUtils;
 public class ActiveModeService extends BathService.ChildService implements
         ActiveModeSensor.Callback, ActiveModeHandler.Callback,
         NotificationPresenter.OnNotificationListChangedListener,
-Atomic.Callback {
+        Atomic.Callback {
 
     private static final String TAG = "ActiveModeService";
     private static final String WAKE_LOCK_TAG = "Consuming sensors";
@@ -98,6 +99,11 @@ Atomic.Callback {
         }
     }
 
+    public static boolean isSupported(@NonNull Context context) {
+        SensorManager sensorManager = (SensorManager) context.getSystemService(Context.SENSOR_SERVICE);
+        return sensorManager.getSensorList(Sensor.TYPE_PROXIMITY).size() > 0;
+    }
+
     /**
      * Builds the array of supported {@link ActiveModeSensor sensors}.
      *
@@ -177,8 +183,9 @@ Atomic.Callback {
     }
 
     @Override
-    public void onNotificationListChanged(NotificationPresenter np,
-                                          OpenNotification osbn, int event) {
+    public void onNotificationListChanged(@NonNull NotificationPresenter np,
+                                          OpenNotification osbn,
+                                          int event, boolean f) {
         if (Config.getInstance().isNotifyWakingUp()) {
             // Notification will wake up device without
             // any sensors' callback.
@@ -315,7 +322,7 @@ Atomic.Callback {
 
     @Override
     public void onWakeRequested(@NonNull ActiveModeSensor sensor) {
-        Presenter.getInstance().start(getContext());
+        Presenter.getInstance().tryStartGuiCauseSensor(getContext());
     }
 
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/activemode/handlers/InactiveTimeHandler.java b/project/app/src/main/java/com/achep/acdisplay/services/activemode/handlers/InactiveTimeHandler.java
index 8d6a346a..df466ddb 100644
--- a/project/app/src/main/java/com/achep/acdisplay/services/activemode/handlers/InactiveTimeHandler.java
+++ b/project/app/src/main/java/com/achep/acdisplay/services/activemode/handlers/InactiveTimeHandler.java
@@ -16,7 +16,6 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
 package com.achep.acdisplay.services.activemode.handlers;
 
 import android.content.Context;
@@ -24,10 +23,11 @@ import android.os.SystemClock;
 import android.support.annotation.NonNull;
 import android.util.Log;
 
-import com.achep.acdisplay.Build;
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.InactiveTimeHelper;
 import com.achep.acdisplay.services.activemode.ActiveModeHandler;
+import com.achep.base.Build;
+import com.achep.base.content.ConfigBase;
 
 import java.util.Timer;
 import java.util.TimerTask;
@@ -37,11 +37,11 @@ import java.util.TimerTask;
  * sensors on inactive time (if corresponding option is enabled.)
  *
  * @author Artem Chepurnoy
- * @see com.achep.acdisplay.settings.MoreSettings
+ * @see com.achep.acdisplay.ui.fragments.settings.MoreSettings
  */
 // TODO: Implement event based inactive time handling.
 public final class InactiveTimeHandler extends ActiveModeHandler implements
-        Config.OnConfigChangedListener {
+        ConfigBase.OnConfigChangedListener {
 
     private static final int INACTIVE_HOURS_CHECK_PERIOD = 1000 * 60 * 5; // ms.
 
@@ -120,7 +120,10 @@ public final class InactiveTimeHandler extends ActiveModeHandler implements
     }
 
     @Override
-    public void onConfigChanged(Config config, String key, Object value) {
+    public void onConfigChanged(@NonNull ConfigBase configBase,
+                                @NonNull String key,
+                                @NonNull Object value) {
+        Config config = (Config) configBase;
         boolean enabled = config.isInactiveTimeEnabled();
         switch (key) {
             case Config.KEY_INACTIVE_TIME_FROM:
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/activemode/handlers/ScreenHandler.java b/project/app/src/main/java/com/achep/acdisplay/services/activemode/handlers/ScreenHandler.java
index 40b12005..c6c2ad04 100644
--- a/project/app/src/main/java/com/achep/acdisplay/services/activemode/handlers/ScreenHandler.java
+++ b/project/app/src/main/java/com/achep/acdisplay/services/activemode/handlers/ScreenHandler.java
@@ -16,7 +16,6 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
 package com.achep.acdisplay.services.activemode.handlers;
 
 import android.content.BroadcastReceiver;
@@ -26,7 +25,7 @@ import android.content.IntentFilter;
 import android.support.annotation.NonNull;
 
 import com.achep.acdisplay.services.activemode.ActiveModeHandler;
-import com.achep.acdisplay.utils.PowerUtils;
+import com.achep.base.utils.power.PowerUtils;
 
 /**
  * Prevents {@link com.achep.acdisplay.services.activemode.ActiveModeService} from listening to
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/activemode/handlers/WithoutNotifiesHandler.java b/project/app/src/main/java/com/achep/acdisplay/services/activemode/handlers/WithoutNotifiesHandler.java
index 9d643811..1de26f3c 100644
--- a/project/app/src/main/java/com/achep/acdisplay/services/activemode/handlers/WithoutNotifiesHandler.java
+++ b/project/app/src/main/java/com/achep/acdisplay/services/activemode/handlers/WithoutNotifiesHandler.java
@@ -16,7 +16,6 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
 package com.achep.acdisplay.services.activemode.handlers;
 
 import android.content.Context;
@@ -26,17 +25,18 @@ import com.achep.acdisplay.Config;
 import com.achep.acdisplay.notifications.NotificationPresenter;
 import com.achep.acdisplay.notifications.OpenNotification;
 import com.achep.acdisplay.services.activemode.ActiveModeHandler;
+import com.achep.base.content.ConfigBase;
 
 /**
  * Prevents {@link com.achep.acdisplay.services.activemode.ActiveModeService} from listening to
  * sensors while notification list is empty (if corresponding option is enabled.)
  *
  * @author Artem Chepurnoy
- * @see com.achep.acdisplay.settings.ActiveModeSettings
+ * @see com.achep.acdisplay.ui.fragments.settings.ActiveModeSettings
  */
 public final class WithoutNotifiesHandler extends ActiveModeHandler implements
         NotificationPresenter.OnNotificationListChangedListener,
-        Config.OnConfigChangedListener {
+        ConfigBase.OnConfigChangedListener {
 
     private Config mConfig;
     private NotificationPresenter mNotificationPresenter;
@@ -63,11 +63,13 @@ public final class WithoutNotifiesHandler extends ActiveModeHandler implements
     @Override
     public boolean isActive() {
         boolean enabled = mConfig.isActiveModeWithoutNotifiesEnabled();
-        return enabled || mNotificationPresenter.getList().size() > 0;
+        return enabled || mNotificationPresenter.size() > 0;
     }
 
     @Override
-    public void onConfigChanged(Config config, String key, Object value) {
+    public void onConfigChanged(@NonNull ConfigBase configBase,
+                                @NonNull String key,
+                                @NonNull Object value) {
         switch (key) {
             case Config.KEY_ACTIVE_MODE_WITHOUT_NOTIFICATIONS:
                 if ((boolean) value) {
@@ -83,9 +85,9 @@ public final class WithoutNotifiesHandler extends ActiveModeHandler implements
     }
 
     @Override
-    public void onNotificationListChanged(NotificationPresenter np,
+    public void onNotificationListChanged(@NonNull NotificationPresenter np,
                                           OpenNotification osbn,
-                                          int event) {
+                                          int event, boolean f) {
         switch (event) {
             case NotificationPresenter.EVENT_BATH:
             case NotificationPresenter.EVENT_POSTED:
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/activemode/sensors/AccelerometerSensor.java b/project/app/src/main/java/com/achep/acdisplay/services/activemode/sensors/AccelerometerSensor.java
index 23962e71..cec0025c 100644
--- a/project/app/src/main/java/com/achep/acdisplay/services/activemode/sensors/AccelerometerSensor.java
+++ b/project/app/src/main/java/com/achep/acdisplay/services/activemode/sensors/AccelerometerSensor.java
@@ -23,19 +23,19 @@ import android.hardware.SensorManager;
 import android.support.annotation.NonNull;
 import android.util.Log;
 
-import com.achep.acdisplay.Build;
 import com.achep.acdisplay.services.activemode.ActiveModeSensor;
+import com.achep.base.Build;
 import com.squareup.seismic.ShakeDetector;
 
 import java.lang.ref.WeakReference;
 
 /**
  * Basing on results of accelerometer sensor it notifies when
- * {@link com.achep.acdisplay.acdisplay.AcDisplayActivity AcDisplay}
+ * {@link com.achep.acdisplay.ui.activities.AcDisplayActivity AcDisplay}
  * should be shown.
  * <p>
- *     Uses nice library <a href="https://github.com/square/seismic">seismic</a>
- *     to detect shake.
+ * Uses nice library <a href="https://github.com/square/seismic">seismic</a>
+ * to detect shake.
  * </p>
  *
  * @author Artem Chepurnoy
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/activemode/sensors/GyroscopeSensor.java b/project/app/src/main/java/com/achep/acdisplay/services/activemode/sensors/GyroscopeSensor.java
index 9c928da5..dc3d31b7 100644
--- a/project/app/src/main/java/com/achep/acdisplay/services/activemode/sensors/GyroscopeSensor.java
+++ b/project/app/src/main/java/com/achep/acdisplay/services/activemode/sensors/GyroscopeSensor.java
@@ -16,7 +16,6 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
 package com.achep.acdisplay.services.activemode.sensors;
 
 import android.hardware.Sensor;
@@ -26,14 +25,14 @@ import android.hardware.SensorManager;
 import android.support.annotation.NonNull;
 import android.util.Log;
 
-import com.achep.acdisplay.Build;
 import com.achep.acdisplay.services.activemode.ActiveModeSensor;
+import com.achep.base.Build;
 
 import java.lang.ref.WeakReference;
 
 /**
  * Basing on results of gyroscope sensor it notifies when
- * {@link com.achep.acdisplay.acdisplay.AcDisplayActivity AcDisplay}
+ * {@link com.achep.acdisplay.ui.activities.AcDisplayActivity AcDisplay}
  * should be shown.
  *
  * @author Artem Chepurnoy
@@ -66,7 +65,7 @@ public final class GyroscopeSensor extends ActiveModeSensor.Consuming implements
     }
 
     @Override
-    protected boolean isSupported(@NonNull SensorManager sensorManager) {
+    public boolean isSupported(@NonNull SensorManager sensorManager) {
         return false;
     }
 
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/activemode/sensors/ProximitySensor.java b/project/app/src/main/java/com/achep/acdisplay/services/activemode/sensors/ProximitySensor.java
index 047cecea..b3fb7081 100644
--- a/project/app/src/main/java/com/achep/acdisplay/services/activemode/sensors/ProximitySensor.java
+++ b/project/app/src/main/java/com/achep/acdisplay/services/activemode/sensors/ProximitySensor.java
@@ -26,15 +26,15 @@ import android.os.Handler;
 import android.support.annotation.NonNull;
 import android.util.Log;
 
-import com.achep.acdisplay.Build;
 import com.achep.acdisplay.services.activemode.ActiveModeSensor;
+import com.achep.base.Build;
 
 import java.lang.ref.WeakReference;
 import java.util.ArrayList;
 
 /**
  * Basing on results of proximity sensor it notifies when
- * {@link com.achep.acdisplay.acdisplay.AcDisplayActivity AcDisplay}
+ * {@link com.achep.acdisplay.ui.activities.AcDisplayActivity AcDisplay}
  * should be shown.
  *
  * @author Artem Chepurnoy
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/media/MediaController.java b/project/app/src/main/java/com/achep/acdisplay/services/media/MediaController.java
deleted file mode 100644
index 7e8cbb21..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/services/media/MediaController.java
+++ /dev/null
@@ -1,372 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-package com.achep.acdisplay.services.media;
-
-import android.annotation.TargetApi;
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.ServiceConnection;
-import android.media.MediaMetadataEditor;
-import android.media.MediaMetadataRetriever;
-import android.media.RemoteControlClient;
-import android.media.RemoteController;
-import android.os.Handler;
-import android.os.IBinder;
-import android.os.Message;
-import android.text.TextUtils;
-import android.util.Log;
-import android.view.KeyEvent;
-
-import com.achep.acdisplay.App;
-import com.achep.acdisplay.Build;
-import com.achep.acdisplay.Device;
-import com.achep.acdisplay.services.MediaService;
-
-import java.util.ArrayList;
-
-/**
- * Class-wrapper of {@link android.media.RemoteController}.
- *
- * @author Artem Chepurnoy
- */
-@TargetApi(android.os.Build.VERSION_CODES.KITKAT)
-public class MediaController {
-
-    private static final String TAG = "MediaController";
-
-    @SuppressWarnings("PointlessBooleanExpression")
-    private static final boolean DEBUG = false && Build.DEBUG;
-
-    public static final int EVENT_METADATA_CHANGED = 1;
-    public static final int EVENT_PLAYSTATE_CHANGED = 2;
-    public static final int EVENT_UISTATE_CHANGED = 4;
-
-    public static final int UISTATE_NORMAL = 0;
-    public static final int UISTATE_MUSIC = 1;
-
-    private static final int MSG_MEDIA_HIDE = 0;
-
-    private final Handler mHandler = new Handler() {
-        @Override
-        public void handleMessage(Message msg) {
-            super.handleMessage(msg);
-            switch (msg.what) {
-                case MSG_MEDIA_HIDE:
-                    mUiState = UISTATE_NORMAL;
-                    notifyListeners(EVENT_UISTATE_CHANGED);
-                    break;
-            }
-        }
-    };
-
-    private Context mContext;
-    private MediaService mService;
-    private boolean mBound = false;
-
-    private final ArrayList<MediaListener> mListeners = new ArrayList<>();
-    private boolean mStarted;
-
-    private int mCurrentPlayState = RemoteControlClient.PLAYSTATE_STOPPED;
-    private int mUiState = UISTATE_NORMAL;
-
-    private final Metadata mMetadata = new Metadata();
-    private RemoteController.MetadataEditor mPopulateMetadataWhenStarted;
-    private final RemoteController.OnClientUpdateListener mRCClientUpdateListener =
-            new RemoteController.OnClientUpdateListener() {
-                @Override
-                public void onClientChange(boolean clearing) {
-                    if (clearing) {
-                        clearMetadata();
-                    }
-                }
-
-                @Override
-                public void onClientPlaybackStateUpdate(int state) {
-                    updatePlayPauseState(state);
-                }
-
-                @Override
-                public void onClientPlaybackStateUpdate(int state, long stateChangeTimeMs,
-                                                        long currentPosMs, float speed) {
-                    updatePlayPauseState(state);
-                    // TODO: Bring more music control.
-                }
-
-                @Override
-                public void onClientTransportControlUpdate(int transportControlFlags) {
-                    // TODO: Bring more music control.
-                }
-
-                @Override
-                public void onClientMetadataUpdate(RemoteController.MetadataEditor metadataEditor) {
-                    updateMetadata(metadataEditor);
-                }
-            };
-
-    private final ServiceConnection mConnection = new ServiceConnection() {
-
-        @Override
-        public void onServiceConnected(ComponentName className, IBinder service) {
-            MediaService.B binder = (MediaService.B) service;
-            mService = binder.getService();
-            mService.setRemoteControllerEnabled();
-            mService.setClientUpdateListener(mRCClientUpdateListener);
-
-            mBound = true;
-        }
-
-        @Override
-        public void onServiceDisconnected(ComponentName name) {
-            mBound = false;
-        }
-    };
-
-
-    /**
-     * Interface definition for a callback to be invoked
-     * when media state changed.
-     *
-     * @see #registerListener(MediaController.MediaListener)
-     * @see #unregisterListener(MediaController.MediaListener)
-     */
-    public interface MediaListener {
-
-        /**
-         * Called when something is changed.
-         *
-         * @param event one of following:
-         *              {@link #EVENT_PLAYSTATE_CHANGED},
-         *              {@link #EVENT_METADATA_CHANGED},
-         *              {@link #EVENT_UISTATE_CHANGED}
-         */
-        void onMediaChanged(MediaController controller, int event);
-    }
-
-    public void registerListener(MediaListener listener) {
-        mListeners.add(listener);
-    }
-
-    public void unregisterListener(MediaListener listener) {
-        mListeners.remove(listener);
-    }
-
-    /**
-     * Notifies all listeners with given {@code event} as a parameter.
-     *
-     * @param event parameter of {@link MediaListener#onMediaChanged(MediaController, int)}.
-     */
-    private void notifyListeners(int event) {
-        for (MediaListener listener : mListeners) {
-            listener.onMediaChanged(this, event);
-        }
-    }
-
-    /**
-     * @see #onStart()
-     * @see #onDestroy()
-     */
-    public void onCreate(Context context) {
-        mContext = context;
-    }
-
-    /**
-     * Called when media controller may register all listeners
-     * and setup all bindings. You must call {@link #onStop()} later!
-     *
-     * @see #onStop()
-     */
-    public void onStart() {
-        mStarted = true;
-
-        if (mPopulateMetadataWhenStarted != null) {
-            updateMetadata(mPopulateMetadataWhenStarted);
-            mPopulateMetadataWhenStarted = null;
-        }
-
-        mMetadata.clear();
-
-        if (Device.hasLollipopApi()) {
-            // TODO: Bring media controls to Android L
-        } else if (Device.hasKitKatApi()) {
-            Intent intent = new Intent(App.ACTION_BIND_MEDIA_CONTROL_SERVICE);
-            mContext.bindService(intent, mConnection, Context.BIND_AUTO_CREATE);
-        }
-    }
-
-    /**
-     * Called when media controller should unregister all listeners
-     * and close all bindings.
-     *
-     * @see #onStart()
-     * @see #onDestroy()
-     */
-    public void onStop() {
-        mStarted = false;
-        mMetadata.clear();
-        mHandler.removeCallbacksAndMessages(null);
-
-        if (Device.hasLollipopApi()) {
-            // TODO: Bring media controls to Android L
-        } else if (Device.hasKitKatApi()) {
-            if (mBound) {
-                mService.setClientUpdateListener(null);
-                mService.setRemoteControllerDisabled();
-            }
-
-            mContext.unbindService(mConnection);
-        }
-    }
-
-    /**
-     *
-     */
-    public void onDestroy() {
-        mContext = null;
-    }
-
-    private void updatePlayPauseState(int state) {
-        if (DEBUG) Log.d(TAG, "state: old=" + mCurrentPlayState + ", state=" + state);
-        if (state == mCurrentPlayState) {
-            return;
-        }
-
-        // boolean clientSupportsSeek = mMetadata != null && mMetadata.duration > 0;
-        // setSeekBarsEnabled(clientSupportsSeek);
-
-        switch (state) {
-            case RemoteControlClient.PLAYSTATE_PLAYING:
-                mHandler.removeMessages(MSG_MEDIA_HIDE);
-                mUiState = UISTATE_MUSIC;
-                notifyListeners(EVENT_UISTATE_CHANGED);
-                break;
-            default:
-
-                // Hide media widget delayed to give user some
-                // time to start playing music.
-                int msg = MSG_MEDIA_HIDE;
-                if (!mHandler.hasMessages(msg)) {
-                    mHandler.sendEmptyMessageDelayed(msg, 6000);
-                }
-                break;
-        }
-
-        mCurrentPlayState = state;
-        notifyListeners(EVENT_PLAYSTATE_CHANGED);
-    }
-
-    public int getPlayState() {
-        return mCurrentPlayState;
-    }
-
-    /**
-     * If {@link #getPlayState() play state} equals to
-     * {@link android.media.RemoteControlClient#PLAYSTATE_PLAYING}, then
-     * ui state is {@link #UISTATE_MUSIC}, otherwise it switches (with a little delay)
-     * to {@link #UISTATE_NORMAL}.
-     *
-     * @return the state of media user interface
-     */
-    public int getUiState() {
-        return mUiState;
-    }
-
-    /**
-     * Clears {@link #mMetadata metadata}. Same as calling
-     * {@link #updateMetadata(android.media.RemoteController.MetadataEditor)}
-     * with {@code null} parameter.
-     *
-     * @see #updateMetadata(android.media.RemoteController.MetadataEditor)
-     */
-    private void clearMetadata() {
-        updateMetadata(null);
-    }
-
-    /**
-     * Updates {@link #mMetadata metadata} from given remote metadata class.
-     * This also updates play state.
-     *
-     * @param data Object of metadata to update from, or {@code null} to clear local metadata.
-     * @see #clearMetadata()
-     */
-    private void updateMetadata(RemoteController.MetadataEditor data) {
-        if (data == null) {
-            mMetadata.clear();
-        } else {
-            if (mStarted) {
-                mMetadata.artist = trim(data.getString(MediaMetadataRetriever.METADATA_KEY_ALBUMARTIST, mMetadata.artist));
-                mMetadata.trackTitle = trim(data.getString(MediaMetadataRetriever.METADATA_KEY_TITLE, mMetadata.trackTitle));
-                mMetadata.albumTitle = trim(data.getString(MediaMetadataRetriever.METADATA_KEY_ALBUM, mMetadata.albumTitle));
-                mMetadata.duration = data.getLong(MediaMetadataRetriever.METADATA_KEY_DURATION, -1);
-                mMetadata.bitmap = data.getBitmap(MediaMetadataEditor.BITMAP_KEY_ARTWORK, mMetadata.bitmap);
-            } else {
-                mPopulateMetadataWhenStarted = data;
-                return;
-            }
-        }
-
-        updatePlayPauseState(mCurrentPlayState);
-        notifyListeners(EVENT_METADATA_CHANGED);
-    }
-
-    /**
-     * @return {@code string == null ? null : TextUtils.isEmpty(string) ? null : string.trim()}
-     */
-    private String trim(String string) {
-        return string == null ? null : TextUtils.isEmpty(string = string.trim()) ? null : string;
-    }
-
-    /**
-     * @return {@link com.achep.acdisplay.services.media.Metadata} of playing track,
-     * or {@code null} if music is not playing.
-     */
-    public Metadata getMetadata() {
-        return mMetadata;
-    }
-
-    /**
-     * Sends media button's click with given key code.
-     *
-     * @param keyCode May be one of media key events.
-     * @see android.view.KeyEvent#KEYCODE_MEDIA_NEXT
-     * @see android.view.KeyEvent#KEYCODE_MEDIA_PLAY_PAUSE
-     * @see android.view.KeyEvent#KEYCODE_MEDIA_PREVIOUS
-     */
-    public void sendMediaButtonClick(int keyCode) {
-        if (Device.hasLollipopApi()) {
-            // TODO: Bring media controls to Android L
-        } else if (Device.hasKitKatApi()) {
-            // TODO We should think about sending these up/down events accurately with touch up/down
-            // on the buttons, but in the near term this will interfere with the long press behavior.
-            // Note from Artem Chepurnoy: This is from Android sources, so check them if this fixed.
-            RemoteController rc = mService.getRemoteController();
-            rc.sendMediaKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, keyCode));
-            rc.sendMediaKeyEvent(new KeyEvent(KeyEvent.ACTION_UP, keyCode));
-        } else {
-            Intent intent = new Intent(Intent.ACTION_MEDIA_BUTTON);
-            KeyEvent keyDown = new KeyEvent(KeyEvent.ACTION_DOWN, keyCode);
-            KeyEvent keyUp = new KeyEvent(KeyEvent.ACTION_UP, keyCode);
-
-            mContext.sendOrderedBroadcast(intent.putExtra(Intent.EXTRA_KEY_EVENT, keyDown), null);
-            mContext.sendOrderedBroadcast(intent.putExtra(Intent.EXTRA_KEY_EVENT, keyUp), null);
-        }
-    }
-
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/media/MediaController2.java b/project/app/src/main/java/com/achep/acdisplay/services/media/MediaController2.java
new file mode 100644
index 00000000..cbef36fc
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/services/media/MediaController2.java
@@ -0,0 +1,188 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.services.media;
+
+import android.app.Activity;
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.support.v4.media.session.PlaybackStateCompat;
+import android.util.Log;
+
+import com.achep.base.Build;
+import com.achep.base.Device;
+
+import java.util.ArrayList;
+
+/**
+ * Allows an app to interact with an ongoing media session. Media buttons and
+ * other commands can be sent to the session. A callback may be registered to
+ * receive updates from the session, such as metadata and play state changes.
+ *
+ * @author Artem Chepurnoy
+ */
+public abstract class MediaController2 {
+
+    protected static final String TAG = "MediaController";
+
+    public static final int ACTION_SKIP_TO_NEXT = 2;
+    public static final int ACTION_SKIP_TO_PREVIOUS = 3;
+    public static final int ACTION_PLAY_PAUSE = 0;
+    public static final int ACTION_STOP = 1;
+
+    /**
+     * Creates new instance, created for working on this device's
+     * Android version.
+     *
+     * @return new instance.
+     */
+    @NonNull
+    public static MediaController2 newInstance(@NonNull Activity activity) {
+        if (Device.hasLollipopApi()) {
+            return new MediaController2Lollipop(activity);
+        } else if (Device.hasKitKatApi()) {
+            return new MediaController2KitKat(activity);
+        } else if (Device.hasJellyBeanMR2Api()) {
+            return new MediaController2JellyBean(activity);
+        }
+
+        return new MediaController2Empty(activity);
+    }
+
+    /**
+     * Callback for receiving updates on from the session. A Callback can be
+     * registered using {@link #registerListener(MediaListener)}
+     */
+    public interface MediaListener {
+
+        /**
+         * Override to handle changes to the current metadata.
+         *
+         * @param metadata The current metadata for the session.
+         * @see com.achep.acdisplay.services.media.Metadata
+         * @see #getMetadata()
+         */
+        void onMetadataChanged(@NonNull Metadata metadata);
+
+        /**
+         * Override to handle changes in playback state.
+         *
+         * @param state The new playback state of the session
+         * @see #getPlaybackState()
+         */
+        void onPlaybackStateChanged(int state);
+
+    }
+
+    protected final Context mContext;
+    protected final ArrayList<MediaListener> mListeners;
+    protected final Metadata mMetadata;
+    protected int mPlaybackState;
+
+    protected MediaController2(@NonNull Context context) {
+        mContext = context;
+
+        mListeners = new ArrayList<>();
+        mMetadata = new Metadata();
+    }
+
+    public void onStart() {
+        if (Build.DEBUG) Log.d(TAG, "Starting media controller: [" + toString() + "]");
+    }
+
+    public void onStop() {
+        if (Build.DEBUG) Log.d(TAG, "Stopping media controller: [" + toString() + "]");
+
+        mPlaybackState = PlaybackStateCompat.STATE_NONE;
+    }
+
+    /**
+     * Registers the specified callback.
+     */
+    public final void registerListener(@NonNull MediaListener listener) {
+        synchronized (this) {
+            mListeners.add(listener);
+        }
+    }
+
+    /**
+     * Unregisters the specified callback.
+     */
+    public final void unregisterListener(@NonNull MediaListener listener) {
+        synchronized (this) {
+            mListeners.remove(listener);
+        }
+    }
+
+    /**
+     * Sends media action. One of the following:
+     * <ul>
+     * <li> {@link #ACTION_PLAY_PAUSE}</li>
+     * <li> {@link #ACTION_STOP}</li>
+     * <li> {@link #ACTION_SKIP_TO_NEXT}</li>
+     * <li> {@link #ACTION_SKIP_TO_PREVIOUS}</li>
+     * </ul>
+     */
+    public abstract void sendMediaAction(int action);
+
+    protected void notifyOnMetadataChanged() {
+        synchronized (this) {
+            for (MediaListener listener : mListeners) {
+                listener.onMetadataChanged(mMetadata);
+            }
+        }
+    }
+
+    protected void notifyOnPlaybackStateChanged() {
+        synchronized (this) {
+            for (MediaListener listener : mListeners) {
+                listener.onPlaybackStateChanged(mPlaybackState);
+            }
+        }
+    }
+
+    /**
+     * Get the current metadata for this session.
+     *
+     * @return {@link Metadata the metadata} of playing track.
+     */
+    @NonNull
+    public final Metadata getMetadata() {
+        return mMetadata;
+    }
+
+    /**
+     * Get the current state of playback. One of the following:
+     * <ul>
+     * <li> {@link android.media.session.PlaybackState#STATE_NONE}</li>
+     * <li> {@link android.media.session.PlaybackState#STATE_STOPPED}</li>
+     * <li> {@link android.media.session.PlaybackState#STATE_PLAYING}</li>
+     * <li> {@link android.media.session.PlaybackState#STATE_PAUSED}</li>
+     * <li> {@link android.media.session.PlaybackState#STATE_FAST_FORWARDING}</li>
+     * <li> {@link android.media.session.PlaybackState#STATE_REWINDING}</li>
+     * <li> {@link android.media.session.PlaybackState#STATE_BUFFERING}</li>
+     * <li> {@link android.media.session.PlaybackState#STATE_ERROR}</li>
+     * </ul>
+     * You also may use {@link android.support.v4.media.session.PlaybackStateCompat} to
+     * access those values.
+     */
+    public final int getPlaybackState() {
+        return mPlaybackState;
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/media/MediaController2Empty.java b/project/app/src/main/java/com/achep/acdisplay/services/media/MediaController2Empty.java
new file mode 100644
index 00000000..9b5a4680
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/services/media/MediaController2Empty.java
@@ -0,0 +1,41 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.services.media;
+
+import android.app.Activity;
+import android.support.annotation.NonNull;
+
+/**
+ * {@inheritDoc}
+ */
+class MediaController2Empty extends MediaController2 {
+
+    /**
+     * {@inheritDoc}
+     */
+    protected MediaController2Empty(@NonNull Activity activity) {
+        super(activity);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void sendMediaAction(int action) { /* do nothing */ }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/media/MediaController2JellyBean.java b/project/app/src/main/java/com/achep/acdisplay/services/media/MediaController2JellyBean.java
new file mode 100644
index 00000000..1f41852e
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/services/media/MediaController2JellyBean.java
@@ -0,0 +1,84 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.services.media;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.support.annotation.NonNull;
+import android.util.Log;
+import android.view.KeyEvent;
+
+import com.achep.base.Device;
+
+/**
+ * {@inheritDoc}
+ */
+class MediaController2JellyBean extends MediaController2KitKat {
+
+    /**
+     * {@inheritDoc}
+     */
+    protected MediaController2JellyBean(@NonNull Activity activity) {
+        super(activity);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void sendMediaAction(int action) {
+        broadcastMediaAction(mContext, action);
+    }
+
+    /**
+     * Emulates hardware buttons' click via broadcast system.
+     *
+     * @see android.view.KeyEvent
+     */
+    public static void broadcastMediaAction(Context context, int action) {
+        int keyCode;
+        switch (action) {
+            case ACTION_PLAY_PAUSE:
+                keyCode = KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE;
+                break;
+            case ACTION_STOP:
+                keyCode = KeyEvent.KEYCODE_MEDIA_STOP;
+                break;
+            case ACTION_SKIP_TO_NEXT:
+                keyCode = KeyEvent.KEYCODE_MEDIA_NEXT;
+                break;
+            case ACTION_SKIP_TO_PREVIOUS:
+                keyCode = KeyEvent.KEYCODE_MEDIA_PREVIOUS;
+                break;
+            default:
+                Log.d(TAG, "Received unknown media action(" + action + ").");
+                return;
+        }
+
+        Intent intent = new Intent(Intent.ACTION_MEDIA_BUTTON);
+        KeyEvent keyDown = new KeyEvent(KeyEvent.ACTION_DOWN, keyCode);
+        KeyEvent keyUp = new KeyEvent(KeyEvent.ACTION_UP, keyCode);
+
+        if (Device.hasKitKatApi()) Log.i(TAG, "Broadcasting this (" + action + ") media action.");
+        context.sendOrderedBroadcast(intent.putExtra(Intent.EXTRA_KEY_EVENT, keyDown), null);
+        context.sendOrderedBroadcast(intent.putExtra(Intent.EXTRA_KEY_EVENT, keyUp), null);
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/media/MediaController2KitKat.java b/project/app/src/main/java/com/achep/acdisplay/services/media/MediaController2KitKat.java
new file mode 100644
index 00000000..484d313d
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/services/media/MediaController2KitKat.java
@@ -0,0 +1,242 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.services.media;
+
+import android.annotation.TargetApi;
+import android.app.Activity;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.ServiceConnection;
+import android.media.MediaMetadataEditor;
+import android.media.MediaMetadataRetriever;
+import android.media.RemoteControlClient;
+import android.media.RemoteController;
+import android.os.Build;
+import android.os.IBinder;
+import android.support.annotation.NonNull;
+import android.support.v4.media.session.PlaybackStateCompat;
+import android.text.TextUtils;
+import android.util.Log;
+import android.util.SparseIntArray;
+import android.view.KeyEvent;
+
+import com.achep.acdisplay.App;
+import com.achep.acdisplay.services.MediaService;
+
+/**
+ * Created by Artem Chepurnoy on 26.10.2014.
+ */
+@SuppressWarnings("deprecation")
+@TargetApi(Build.VERSION_CODES.LOLLIPOP)
+class MediaController2KitKat extends MediaController2 {
+
+    private MediaService mService;
+    private boolean mBound = false;
+
+    private boolean mStarted;
+
+    private RemoteController.MetadataEditor mPopulateMetadataWhenStarted;
+    private final RemoteController.OnClientUpdateListener mRCClientUpdateListener =
+            new RemoteController.OnClientUpdateListener() {
+
+                @Override
+                public void onClientChange(boolean clearing) {
+                    if (clearing) {
+                        clearMetadata();
+                    }
+                }
+
+                @Override
+                public void onClientPlaybackStateUpdate(int state) {
+                    if (mPlaybackState != state) {
+                        updatePlaybackState(state);
+                    }
+                }
+
+                @Override
+                public void onClientPlaybackStateUpdate(int state, long stateChangeTimeMs,
+                                                        long currentPosMs, float speed) {
+                    onClientPlaybackStateUpdate(state);
+                }
+
+                @Override
+                public void onClientTransportControlUpdate(int transportControlFlags) {
+                    // TODO: Bring more music control.
+                }
+
+                @Override
+                public void onClientMetadataUpdate(RemoteController.MetadataEditor metadataEditor) {
+                    updateMetadata(metadataEditor);
+                }
+
+            };
+
+    private final ServiceConnection mConnection = new ServiceConnection() {
+
+        @Override
+        public void onServiceConnected(ComponentName className, IBinder service) {
+            MediaService.B binder = (MediaService.B) service;
+            mService = binder.getService();
+            mService.setRemoteControllerEnabled();
+            mService.setClientUpdateListener(mRCClientUpdateListener);
+
+            mBound = true;
+        }
+
+        @Override
+        public void onServiceDisconnected(ComponentName name) {
+            mBound = false;
+        }
+
+    };
+
+    private final SparseIntArray mStateSparse;
+
+    /**
+     * {@inheritDoc}
+     */
+    protected MediaController2KitKat(@NonNull Activity activity) {
+        super(activity);
+
+        mStateSparse = new SparseIntArray();
+        mStateSparse.put(RemoteControlClient.PLAYSTATE_BUFFERING, PlaybackStateCompat.STATE_BUFFERING);
+        mStateSparse.put(RemoteControlClient.PLAYSTATE_PLAYING, PlaybackStateCompat.STATE_PLAYING);
+        mStateSparse.put(RemoteControlClient.PLAYSTATE_PAUSED, PlaybackStateCompat.STATE_PAUSED);
+        mStateSparse.put(RemoteControlClient.PLAYSTATE_ERROR, PlaybackStateCompat.STATE_ERROR);
+        mStateSparse.put(RemoteControlClient.PLAYSTATE_REWINDING, PlaybackStateCompat.STATE_REWINDING);
+        mStateSparse.put(RemoteControlClient.PLAYSTATE_FAST_FORWARDING, PlaybackStateCompat.STATE_FAST_FORWARDING);
+        mStateSparse.put(RemoteControlClient.PLAYSTATE_SKIPPING_FORWARDS, PlaybackStateCompat.STATE_SKIPPING_TO_NEXT);
+        mStateSparse.put(RemoteControlClient.PLAYSTATE_SKIPPING_BACKWARDS, PlaybackStateCompat.STATE_SKIPPING_TO_PREVIOUS);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void onStart() {
+        super.onStart();
+
+        mStarted = true;
+
+        if (mPopulateMetadataWhenStarted != null) {
+            updateMetadata(mPopulateMetadataWhenStarted);
+            mPopulateMetadataWhenStarted = null;
+        }
+
+        Intent intent = new Intent(App.ACTION_BIND_MEDIA_CONTROL_SERVICE);
+        mContext.bindService(intent, mConnection, Context.BIND_AUTO_CREATE);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void onStop() {
+        mStarted = false;
+        mMetadata.clear();
+
+        if (mBound) {
+            mService.setClientUpdateListener(null);
+            mService.setRemoteControllerDisabled();
+        }
+
+        mContext.unbindService(mConnection);
+        super.onStop();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void sendMediaAction(int action) {
+        int keyCode;
+        switch (action) {
+            case ACTION_PLAY_PAUSE:
+                keyCode = KeyEvent.KEYCODE_MEDIA_PLAY_PAUSE;
+                break;
+            case ACTION_STOP:
+                keyCode = KeyEvent.KEYCODE_MEDIA_STOP;
+                break;
+            case ACTION_SKIP_TO_NEXT:
+                keyCode = KeyEvent.KEYCODE_MEDIA_NEXT;
+                break;
+            case ACTION_SKIP_TO_PREVIOUS:
+                keyCode = KeyEvent.KEYCODE_MEDIA_PREVIOUS;
+                break;
+            default:
+                Log.wtf(TAG, "Received unknown media action.");
+                return;
+        }
+
+        // TODO We should think about sending these up/down events accurately with touch up/down
+        // on the buttons, but in the near term this will interfere with the long press behavior.
+        RemoteController rc = mService.getRemoteController();
+        rc.sendMediaKeyEvent(new KeyEvent(KeyEvent.ACTION_DOWN, keyCode));
+        rc.sendMediaKeyEvent(new KeyEvent(KeyEvent.ACTION_UP, keyCode));
+    }
+
+    private void updatePlaybackState(int state) {
+        mPlaybackState = mStateSparse.get(state);
+        notifyOnPlaybackStateChanged();
+    }
+
+    /**
+     * Clears {@link #mMetadata metadata}. Same as calling
+     * {@link #updateMetadata(android.media.RemoteController.MetadataEditor)}
+     * with {@code null} parameter.
+     *
+     * @see #updateMetadata(android.media.RemoteController.MetadataEditor)
+     */
+    private void clearMetadata() {
+        updateMetadata(null);
+    }
+
+    /**
+     * Updates {@link #mMetadata metadata} from given remote metadata class.
+     * This also updates play state.
+     *
+     * @param data Object of metadata to update from, or {@code null} to clear local metadata.
+     * @see #clearMetadata()
+     */
+    private void updateMetadata(RemoteController.MetadataEditor data) {
+        if (data == null) {
+            mMetadata.clear();
+        } else {
+            if (mStarted) {
+                mMetadata.title = data.getString(MediaMetadataRetriever.METADATA_KEY_TITLE, null);
+                mMetadata.artist = data.getString(MediaMetadataRetriever.METADATA_KEY_ARTIST, null);
+                mMetadata.album = data.getString(MediaMetadataRetriever.METADATA_KEY_ALBUM, null);
+                mMetadata.duration = data.getLong(MediaMetadataRetriever.METADATA_KEY_DURATION, -1);
+                mMetadata.bitmap = data.getBitmap(MediaMetadataEditor.BITMAP_KEY_ARTWORK, mMetadata.bitmap);
+                mMetadata.updateSubtitle();
+            } else {
+                mPopulateMetadataWhenStarted = data;
+                return;
+            }
+        }
+
+        notifyOnMetadataChanged();
+    }
+
+    /**
+     * @return {@code string == null ? null : TextUtils.isEmpty(string = string.trim()) ? null : string}
+     */
+    private String trim(String string) {
+        return string == null ? null : TextUtils.isEmpty(string = string.trim()) ? null : string;
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/media/MediaController2Lollipop.java b/project/app/src/main/java/com/achep/acdisplay/services/media/MediaController2Lollipop.java
new file mode 100644
index 00000000..7f079544
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/services/media/MediaController2Lollipop.java
@@ -0,0 +1,216 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.services.media;
+
+import android.annotation.TargetApi;
+import android.content.ComponentName;
+import android.content.Context;
+import android.graphics.Bitmap;
+import android.media.MediaDescription;
+import android.media.MediaMetadata;
+import android.media.session.MediaController;
+import android.media.session.MediaSessionManager;
+import android.media.session.PlaybackState;
+import android.os.Build;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+import com.achep.acdisplay.R;
+import com.achep.acdisplay.services.MediaService;
+
+import java.util.List;
+
+/**
+ * {@inheritDoc}
+ */
+@TargetApi(Build.VERSION_CODES.LOLLIPOP)
+class MediaController2Lollipop extends MediaController2 {
+
+    private MediaController mMediaController;
+
+    private boolean mSessionListening;
+
+    private final ComponentName mComponent;
+    private final MediaSessionManager mMediaSessionManager;
+    private final MediaController.Callback mCallback =
+            new MediaController.Callback() {
+
+                @Override
+                public void onMetadataChanged(MediaMetadata metadata) {
+                    super.onMetadataChanged(metadata);
+                    updateMetadata(metadata);
+                }
+
+                @Override
+                public void onPlaybackStateChanged(PlaybackState state) {
+                    super.onPlaybackStateChanged(state);
+                    updatePlaybackState(state.getState());
+                }
+            };
+
+    private final MediaSessionManager.OnActiveSessionsChangedListener mSessionListener =
+            new MediaSessionManager.OnActiveSessionsChangedListener() {
+
+                @Override
+                public void onActiveSessionsChanged(List<MediaController> controllers) {
+                    int size = controllers.size();
+                    if (size == 0) {
+                        updateMetadata(null);
+                        updatePlaybackState(PlaybackState.STATE_NONE);
+                    } else {
+                        if (mMediaController != null) {
+                            for (MediaController controller : controllers) {
+                                if (mMediaController == controller) {
+                                    // Current media controller is still alive.
+                                    return;
+                                }
+                            }
+                        }
+
+                        // TODO: Maybe check which one is better instead of selecting first one?
+                        switchMediaController(controllers.get(0));
+                    }
+                }
+
+            };
+
+    /**
+     * {@inheritDoc}
+     */
+    protected MediaController2Lollipop(@NonNull Context context) {
+        super(context);
+
+        //noinspection ResourceType
+        mMediaSessionManager = (MediaSessionManager) mContext
+                .getSystemService(Context.MEDIA_SESSION_SERVICE);
+        mComponent = new ComponentName(context, MediaService.class);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void onStart() {
+        super.onStart();
+
+        try {
+            mMediaSessionManager.addOnActiveSessionsChangedListener(mSessionListener, mComponent);
+            List<MediaController> sessions = mMediaSessionManager.getActiveSessions(mComponent);
+            mSessionListener.onActiveSessionsChanged(sessions);
+            mSessionListening = true;
+        } catch (SecurityException exception) {
+            Log.i(TAG, "Caught SecurityException on start: " + exception.getMessage());
+            mSessionListening = false;
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void onStop() {
+        if (mSessionListening) {
+            mMediaSessionManager.removeOnActiveSessionsChangedListener(mSessionListener);
+            clearMediaController();
+        }
+        super.onStop();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public void sendMediaAction(int action) {
+        if (mMediaController == null) {
+            // Maybe somebody is waiting to start his player by
+            // this lovely event.
+            // TODO: Check if it works as expected.
+            MediaController2JellyBean.broadcastMediaAction(mContext, action);
+            return;
+        }
+
+        MediaController.TransportControls controls = mMediaController.getTransportControls();
+        switch (action) {
+            case ACTION_PLAY_PAUSE:
+                if (mPlaybackState == PlaybackState.STATE_PLAYING) {
+                    controls.pause();
+                } else {
+                    controls.play();
+                }
+                break;
+            case ACTION_STOP:
+                controls.stop();
+                break;
+            case ACTION_SKIP_TO_NEXT:
+                controls.skipToNext();
+                break;
+            case ACTION_SKIP_TO_PREVIOUS:
+                controls.skipToPrevious();
+                break;
+        }
+    }
+
+    private void updateMetadata(MediaMetadata metadata) {
+        if (metadata == null) {
+            mMetadata.clear();
+        } else {
+            MediaDescription description = metadata.getDescription();
+            mMetadata.title = description.getTitle();
+            mMetadata.artist = metadata.getText(MediaMetadata.METADATA_KEY_ARTIST);
+            mMetadata.album = metadata.getText(MediaMetadata.METADATA_KEY_ALBUM);
+            mMetadata.bitmap = metadata.getBitmap(MediaMetadata.METADATA_KEY_ART);
+            mMetadata.duration = metadata.getLong(MediaMetadata.METADATA_KEY_DURATION);
+            mMetadata.updateSubtitle();
+
+            if (mMetadata.bitmap != null) {
+                final int size = mContext.getResources().getDimensionPixelSize(R.dimen.media_artwork_size);
+                mMetadata.bitmap = Bitmap.createScaledBitmap(mMetadata.bitmap, size, size, true);
+            }
+        }
+
+        notifyOnMetadataChanged();
+    }
+
+    private void updatePlaybackState(@Nullable PlaybackState state) {
+        updatePlaybackState(state == null ? PlaybackState.STATE_NONE : state.getState());
+    }
+
+    private void updatePlaybackState(int state) {
+        mPlaybackState = state;
+        notifyOnPlaybackStateChanged();
+    }
+
+    private void switchMediaController(MediaController controller) {
+        clearMediaController();
+
+        mMediaController = controller;
+        mMediaController.registerCallback(mCallback);
+        updateMetadata(mMediaController.getMetadata());
+        updatePlaybackState(mMediaController.getPlaybackState());
+
+        Log.i(TAG, "Switching to " + mMediaController.getPackageName() + " controller.");
+    }
+
+    private void clearMediaController() {
+        if (mMediaController != null) {
+            mMediaController.unregisterCallback(mCallback);
+            mMediaController = null;
+            mMetadata.clear();
+        }
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/services/media/Metadata.java b/project/app/src/main/java/com/achep/acdisplay/services/media/Metadata.java
index 8b75d926..8e306873 100644
--- a/project/app/src/main/java/com/achep/acdisplay/services/media/Metadata.java
+++ b/project/app/src/main/java/com/achep/acdisplay/services/media/Metadata.java
@@ -16,34 +16,85 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
 package com.achep.acdisplay.services.media;
 
 import android.graphics.Bitmap;
+import android.text.TextUtils;
+
+import org.apache.commons.lang.builder.EqualsBuilder;
+import org.apache.commons.lang.builder.HashCodeBuilder;
 
 /**
  * Created by achep on 08.06.14.
  */
 public class Metadata {
-    public String artist;
-    public String trackTitle;
-    public String albumTitle;
+
+    public CharSequence title;
+    public CharSequence artist;
+    public CharSequence album;
+    public CharSequence subtitle;
     public Bitmap bitmap;
     public long duration;
 
     public void clear() {
-        artist = null;
-        trackTitle = null;
-        albumTitle = null;
+        title = null;
+        subtitle = null;
         bitmap = null;
         duration = -1;
     }
 
+    public void updateSubtitle() {
+        // General subtitle's format is
+        // ARTIST - ALBUM
+        StringBuilder sb = new StringBuilder();
+        if (!TextUtils.isEmpty(artist)) {
+            sb.append(artist);
+
+            if (TextUtils.isEmpty(album)) {
+                sb.append(" - ");
+                sb.append(album);
+            }
+        } else if (!TextUtils.isEmpty(album)) {
+            sb.append(album);
+        } else {
+            sb = null;
+        }
+
+        subtitle = sb;
+    }
+
     @Override
     public String toString() {
-        return "Metadata[artist=" + artist
-                + " trackTitle=" + trackTitle
-                + " albumTitle=" + albumTitle
-                + " duration=" + duration + "]";
+        return "Metadata[title=" + title
+                + " subtitle=" + subtitle
+                + " duration=" + duration
+                + " bitmap=" + bitmap + "]";
     }
+
+    @Override
+    public int hashCode() {
+        return new HashCodeBuilder(13, 2041)
+                .append(title)
+                .append(subtitle)
+                .append(duration)
+                .append(bitmap)
+                .toHashCode();
+    }
+
+    @Override
+    public boolean equals(Object o) {
+        if (o == this)
+            return true;
+        if (!(o instanceof Metadata))
+            return false;
+
+        Metadata metadata = (Metadata) o;
+        return new EqualsBuilder()
+                .append(duration, metadata.duration)
+                .append(title, metadata.title)
+                .append(subtitle, metadata.title)
+                .append(bitmap, metadata.bitmap)
+                .isEquals();
+    }
+
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/settings/Enabler.java b/project/app/src/main/java/com/achep/acdisplay/settings/Enabler.java
deleted file mode 100644
index 021ec0c5..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/settings/Enabler.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.acdisplay.settings;
-
-import android.content.Context;
-import android.widget.CompoundButton;
-import android.widget.Switch;
-
-import com.achep.acdisplay.Config;
-
-/**
- * Created by Artem on 21.02.14.
- */
-public class Enabler implements
-        Config.OnConfigChangedListener,
-        CompoundButton.OnCheckedChangeListener {
-
-    private final Context mContext;
-
-    private final String mKey;
-    private final Config mConfig;
-    private final Config.Option mOption;
-
-    private Switch mSwitch;
-
-    private boolean mBroadcasting;
-
-    public Enabler(Context context, Switch switch_, String key) {
-        mContext = context;
-
-        mKey = key;
-        mConfig = Config.getInstance();
-        mOption = mConfig.getHashMap().get(mKey);
-
-        mSwitch = switch_;
-    }
-
-    private void updateState() {
-        mBroadcasting = true;
-        mSwitch.setChecked((Boolean) mOption.read(mConfig));
-        mBroadcasting = false;
-    }
-
-    public void resume() {
-        mConfig.registerListener(this);
-        mSwitch.setOnCheckedChangeListener(this);
-        updateState();
-    }
-
-    public void pause() {
-        mConfig.unregisterListener(this);
-        mSwitch.setOnCheckedChangeListener(null);
-    }
-
-    public void setSwitch(Switch switch_) {
-        if (mSwitch == switch_) {
-            return;
-        }
-
-        mSwitch = switch_;
-        mSwitch.setOnCheckedChangeListener(this);
-        updateState();
-    }
-
-    @Override
-    public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
-        if (mBroadcasting) {
-            return;
-        }
-
-        mOption.write(mConfig, mContext, isChecked, this);
-    }
-
-    @Override
-    public void onConfigChanged(Config config, String key, Object value) {
-        if (mKey.equals(key)) {
-            updateState();
-        }
-    }
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/settings/InterfaceSettings.java b/project/app/src/main/java/com/achep/acdisplay/settings/InterfaceSettings.java
deleted file mode 100644
index 222037e4..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/settings/InterfaceSettings.java
+++ /dev/null
@@ -1,176 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.acdisplay.settings;
-
-import android.content.Context;
-import android.os.Bundle;
-import android.preference.MultiSelectListPreference;
-import android.preference.Preference;
-
-import com.achep.acdisplay.Config;
-import com.achep.acdisplay.Operator;
-import com.achep.acdisplay.R;
-
-import java.util.Collections;
-import java.util.HashSet;
-import java.util.Set;
-
-/**
- * Interface settings fragment.
- *
- * @author Artem Chepurnoy
- */
-public class InterfaceSettings extends PreferenceFragment implements
-        Preference.OnPreferenceChangeListener,
-        Config.OnConfigChangedListener {
-
-    private MultiSelectListPreference mDynamicBackground;
-    private Preference mIconSizePreference;
-
-    private boolean mBroadcasting;
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        addPreferencesFromResource(R.xml.interface_settings);
-        syncPreference(Config.KEY_UI_WALLPAPER_SHOWN);
-        syncPreference(Config.KEY_UI_SHADOW_TOGGLE);
-        syncPreference(Config.KEY_UI_MIRRORED_TIMEOUT_BAR);
-        syncPreference(Config.KEY_UI_NOTIFY_CIRCLED_ICON);
-        syncPreference(Config.KEY_UI_STATUS_BATTERY_STICKY);
-        syncPreference(Config.KEY_UI_FULLSCREEN);
-        syncPreference(Config.KEY_UI_UNLOCK_ANIMATION);
-
-        mDynamicBackground = (MultiSelectListPreference) findPreference(
-                Config.KEY_UI_DYNAMIC_BACKGROUND_MODE);
-        mIconSizePreference = findPreference("icon_size");
-
-        mDynamicBackground.setOnPreferenceChangeListener(this);
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        Config config = getConfig();
-        config.registerListener(this);
-
-        updateDynamicBackgroundPreference(config);
-        updateIconSizeSummary(config);
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        Config config = getConfig();
-        config.unregisterListener(this);
-    }
-
-    @Override
-    public boolean onPreferenceChange(Preference preference, Object newValue) {
-        if (mBroadcasting) {
-            return true;
-        }
-
-        Context context = getActivity();
-        Config config = Config.getInstance();
-        if (preference == mDynamicBackground) {
-            int mode = 0;
-
-            Set<String> values = (Set<String>) newValue;
-            for (String v : values) {
-                mode |= Integer.parseInt(v);
-            }
-
-            config.setDynamicBackgroundMode(context, mode, this);
-            updateDynamicBackgroundPreferenceSummary(config);
-        } else
-            return false;
-        return true;
-    }
-
-    @Override
-    public void onConfigChanged(Config config, String key, Object value) {
-        switch (key) {
-            case Config.KEY_UI_DYNAMIC_BACKGROUND_MODE:
-                updateDynamicBackgroundPreference(config);
-                break;
-            case Config.KEY_UI_ICON_SIZE:
-                updateIconSizeSummary(config);
-                break;
-        }
-    }
-
-    private void updateIconSizeSummary(Config config) {
-        mIconSizePreference.setSummary(getString(R.string.settings_icon_size_summary,
-                Integer.toString(config.getIconSize(Config.ICON_SIZE_DP))));
-    }
-
-    private void updateDynamicBackgroundPreference(Config config) {
-        mBroadcasting = true;
-
-        int mode = config.getDynamicBackgroundMode();
-        String[] values = new String[Integer.bitCount(mode)];
-        for (int i = 1, j = 0; j < values.length; i <<= 1) {
-            if (Operator.bitAnd(mode, i)) {
-                values[j++] = Integer.toString(i);
-            }
-        }
-
-        Set<String> valuesSet = new HashSet<>();
-        Collections.addAll(valuesSet, values);
-        mDynamicBackground.setValues(valuesSet);
-
-        mBroadcasting = false;
-        updateDynamicBackgroundPreferenceSummary(config);
-    }
-
-    private void updateDynamicBackgroundPreferenceSummary(Config config) {
-        CharSequence summary;
-        if (config.getDynamicBackgroundMode() != 0) {
-            CharSequence[] entries = mDynamicBackground.getEntries();
-            CharSequence[] values = mDynamicBackground.getEntryValues();
-            int mode = config.getDynamicBackgroundMode();
-
-            String divider = getString(R.string.settings_multi_list_divider);
-            StringBuilder sb = new StringBuilder();
-            boolean empty = true;
-
-            assert entries != null;
-            assert values != null;
-
-            // Append selected items.
-            for (int i = 0; i < values.length; i++) {
-                int a = Integer.parseInt(values[i].toString());
-                if (Operator.bitAnd(mode, a)) {
-                    if (!empty) {
-                        sb.append(divider);
-                    }
-                    sb.append(entries[i]);
-                    empty = false;
-                }
-            }
-
-            String itemsText = sb.toString().toLowerCase();
-            summary = getString(R.string.settings_dynamic_background_summary, itemsText);
-        } else {
-            summary = getString(R.string.settings_dynamic_background_disabled);
-        }
-        mDynamicBackground.setSummary(summary);
-    }
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/settings/KeyguardSettings.java b/project/app/src/main/java/com/achep/acdisplay/settings/KeyguardSettings.java
deleted file mode 100644
index 5fd62b33..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/settings/KeyguardSettings.java
+++ /dev/null
@@ -1,63 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-package com.achep.acdisplay.settings;
-
-import android.app.ActionBar;
-import android.app.Activity;
-import android.os.Bundle;
-import android.preference.PreferenceFragment;
-import android.widget.Switch;
-
-import com.achep.acdisplay.Config;
-import com.achep.acdisplay.R;
-
-/**
- * Created by Artem on 09.02.14.
- */
-public class KeyguardSettings extends PreferenceFragment {
-
-    private Enabler mKeyguardEnabler;
-
-    @Override
-    public void onCreate(Bundle savedInstanceState) {
-        super.onCreate(savedInstanceState);
-        addPreferencesFromResource(R.xml.lockscreen_settings);
-
-        Activity activity = getActivity();
-        ActionBar actionBar = activity.getActionBar();
-        assert actionBar != null;
-
-        actionBar.setDisplayShowCustomEnabled(true);
-        actionBar.setCustomView(R.layout.layout_ab_switch);
-        Switch switch_ = (Switch) actionBar.getCustomView().findViewById(R.id.switch_);
-        mKeyguardEnabler = new Enabler(activity, switch_, Config.KEY_KEYGUARD);
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        mKeyguardEnabler.resume();
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        mKeyguardEnabler.pause();
-    }
-}
\ No newline at end of file
diff --git a/project/app/src/main/java/com/achep/acdisplay/settings/PreferenceFragment.java b/project/app/src/main/java/com/achep/acdisplay/settings/PreferenceFragment.java
deleted file mode 100644
index 7d0dd605..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/settings/PreferenceFragment.java
+++ /dev/null
@@ -1,72 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-package com.achep.acdisplay.settings;
-
-import android.app.Activity;
-import android.preference.Preference;
-import android.preference.PreferenceScreen;
-import android.util.Log;
-
-import com.achep.acdisplay.Build;
-import com.achep.acdisplay.Config;
-
-/**
- * Created by achep on 04.06.14.
- */
-public class PreferenceFragment extends android.preference.PreferenceFragment {
-
-    private static final String TAG = "PreferenceFragment";
-
-    private Config.Syncer mSyncer;
-    private Config mConfig;
-
-    @Override
-    public void onAttach(Activity activity) {
-        super.onAttach(activity);
-        mConfig = Config.getInstance();
-        mSyncer = new Config.Syncer(activity, mConfig);
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        mSyncer.start();
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        mSyncer.stop();
-    }
-
-    protected Config getConfig() {
-        return mConfig;
-    }
-
-    protected void syncPreference(String key) {
-        Preference preference = findPreference(key);
-        PreferenceScreen preferenceScreen = getPreferenceScreen();
-        if (preference != null) {
-            mSyncer.addPreference(preferenceScreen, preference);
-        } else if (Build.DEBUG) {
-            Log.d(TAG, "Tried to sync non-existent preference with config.");
-        }
-    }
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/settings/Settings.java b/project/app/src/main/java/com/achep/acdisplay/settings/Settings.java
deleted file mode 100644
index a644a4ca..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/settings/Settings.java
+++ /dev/null
@@ -1,567 +0,0 @@
-/*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
- *
- * This program is free software; you can redistribute it and/or
- * modify it under the terms of the GNU General Public License
- * as published by the Free Software Foundation; either version 2
- * of the License, or (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
- * MA  02110-1301, USA.
- */
-
-package com.achep.acdisplay.settings;
-
-import android.content.ComponentName;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.ActivityInfo;
-import android.content.pm.PackageManager;
-import android.content.pm.PackageManager.NameNotFoundException;
-import android.os.Bundle;
-import android.preference.Preference;
-import android.preference.PreferenceActivity;
-import android.preference.PreferenceFragment;
-import android.text.TextUtils;
-import android.util.Log;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.View.OnClickListener;
-import android.view.ViewGroup;
-import android.widget.ArrayAdapter;
-import android.widget.ImageView;
-import android.widget.ListAdapter;
-import android.widget.Switch;
-import android.widget.TextView;
-
-import com.achep.acdisplay.Build;
-import com.achep.acdisplay.Config;
-import com.achep.acdisplay.R;
-
-import java.lang.reflect.InvocationTargetException;
-import java.lang.reflect.Method;
-import java.util.HashMap;
-import java.util.List;
-
-/**
- * Top-level settings activity to handle single pane and double pane UI layout.
- */
-public class Settings extends PreferenceActivity {
-
-    // Fuck you Android Devs for the hidden #getHeaders()!
-    private static final String HEADERS_TAG = ":android:headers";
-
-    private static final String LOG_TAG = "Settings";
-
-    private static final String META_DATA_KEY_HEADER_ID =
-            "com.achep.acdisplay.TOP_LEVEL_HEADER_ID";
-    private static final String META_DATA_KEY_FRAGMENT_CLASS =
-            "com.achep.acdisplay.FRAGMENT_CLASS";
-    private static final String META_DATA_KEY_PARENT_TITLE =
-            "com.achep.acdisplay.PARENT_FRAGMENT_TITLE";
-    private static final String META_DATA_KEY_PARENT_FRAGMENT_CLASS =
-            "com.achep.acdisplay.PARENT_FRAGMENT_CLASS";
-
-    private static final String EXTRA_UI_OPTIONS = "settings:ui_options";
-    private static final String EXTRA_CLEAR_UI_OPTIONS = "settings:remove_ui_options";
-
-    private static final String SAVE_KEY_CURRENT_HEADER = "com.achep.acdisplay.CURRENT_HEADER";
-    private static final String SAVE_KEY_PARENT_HEADER = "com.achep.acdisplay.PARENT_HEADER";
-
-    private String mFragmentClass;
-    private int mTopLevelHeaderId;
-    private Header mFirstHeader;
-    private Header mCurrentHeader;
-    private Header mParentHeader;
-    private boolean mInLocalHeaderSwitch;
-
-    protected HashMap<Integer, Integer> mHeaderIndexMap = new HashMap<>();
-
-    @Override
-    protected void onCreate(Bundle savedInstanceState) {
-        if (getIntent().hasExtra(EXTRA_UI_OPTIONS)) {
-            getWindow().setUiOptions(getIntent().getIntExtra(EXTRA_UI_OPTIONS, 0));
-        }
-
-        getMetaData();
-        mInLocalHeaderSwitch = true;
-        super.onCreate(savedInstanceState);
-        mInLocalHeaderSwitch = false;
-
-        if (!onIsHidingHeaders() && onIsMultiPane()) {
-            highlightHeader(mTopLevelHeaderId);
-            // Force the title so that it doesn't get overridden by a direct launch of
-            // a specific settings screen.
-            setTitle(R.string.settings);
-        }
-
-        // Retrieve any saved state
-        if (savedInstanceState != null) {
-            mCurrentHeader = savedInstanceState.getParcelable(SAVE_KEY_CURRENT_HEADER);
-            mParentHeader = savedInstanceState.getParcelable(SAVE_KEY_PARENT_HEADER);
-        }
-
-        // If the current header was saved, switch to it
-        if (savedInstanceState != null && mCurrentHeader != null) {
-            //switchToHeaderLocal(mCurrentHeader);
-            showBreadCrumbs(mCurrentHeader.title, null);
-        }
-
-        if (mParentHeader != null) {
-            setParentTitle(mParentHeader.title, null, new OnClickListener() {
-                @Override
-                public void onClick(View v) {
-                    switchToParent(mParentHeader.fragment);
-                }
-            });
-        }
-
-        // Override up navigation for multi-pane, since we handle it in the fragment breadcrumbs
-        if (onIsMultiPane()) {
-            getActionBar().setDisplayHomeAsUpEnabled(false);
-            getActionBar().setHomeButtonEnabled(false);
-        }
-    }
-
-    @Override
-    protected void onSaveInstanceState(Bundle outState) {
-        super.onSaveInstanceState(outState);
-
-        // Save the current fragment, if it is the same as originally launched
-        if (mCurrentHeader != null) {
-            outState.putParcelable(SAVE_KEY_CURRENT_HEADER, mCurrentHeader);
-        }
-        if (mParentHeader != null) {
-            outState.putParcelable(SAVE_KEY_PARENT_HEADER, mParentHeader);
-        }
-    }
-
-    @Override
-    public void onResume() {
-        super.onResume();
-        ListAdapter listAdapter = getListAdapter();
-        if (listAdapter instanceof HeaderAdapter) {
-            ((HeaderAdapter) listAdapter).resume();
-        }
-        invalidateHeaders();
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        ListAdapter listAdapter = getListAdapter();
-        if (listAdapter instanceof HeaderAdapter) {
-            ((HeaderAdapter) listAdapter).pause();
-        }
-    }
-
-    private static final String[] ENTRY_FRAGMENTS = {
-            KeyguardSettings.class.getName(),
-            ActiveModeSettings.class.getName(),
-            NotificationSettings.class.getName(),
-            InterfaceSettings.class.getName(),
-            MoreSettings.class.getName()
-    };
-
-    @Override
-    protected boolean isValidFragment(String fragmentName) {
-        // Almost all fragments are wrapped in this,
-        // except for a few that have their own activities.
-        for (String str : ENTRY_FRAGMENTS) {
-            if (str.equals(fragmentName)) return true;
-        }
-        return false;
-    }
-
-    private void switchToHeaderLocal(Header header) {
-        mInLocalHeaderSwitch = true;
-        switchToHeader(header);
-        mInLocalHeaderSwitch = false;
-    }
-
-    @Override
-    public void switchToHeader(Header header) {
-        if (!mInLocalHeaderSwitch) {
-            mCurrentHeader = null;
-            mParentHeader = null;
-        }
-        super.switchToHeader(header);
-    }
-
-    /**
-     * Switch to parent fragment and store the grand parent's info
-     *
-     * @param className name of the activity wrapper for the parent fragment.
-     */
-    private void switchToParent(String className) {
-        final ComponentName cn = new ComponentName(this, className);
-        try {
-            final PackageManager pm = getPackageManager();
-            final ActivityInfo parentInfo = pm.getActivityInfo(cn, PackageManager.GET_META_DATA);
-
-            if (parentInfo != null && parentInfo.metaData != null) {
-                String fragmentClass = parentInfo.metaData.getString(META_DATA_KEY_FRAGMENT_CLASS);
-                CharSequence fragmentTitle = parentInfo.loadLabel(pm);
-                Header parentHeader = new Header();
-                parentHeader.fragment = fragmentClass;
-                parentHeader.title = fragmentTitle;
-                mCurrentHeader = parentHeader;
-
-                switchToHeaderLocal(parentHeader);
-                highlightHeader(mTopLevelHeaderId);
-
-                mParentHeader = new Header();
-                mParentHeader.fragment
-                        = parentInfo.metaData.getString(META_DATA_KEY_PARENT_FRAGMENT_CLASS);
-                mParentHeader.title = parentInfo.metaData.getString(META_DATA_KEY_PARENT_TITLE);
-            }
-        } catch (NameNotFoundException nnfe) {
-            Log.w(LOG_TAG, "Could not find parent activity : " + className);
-        }
-    }
-
-    @Override
-    public void onNewIntent(Intent intent) {
-        super.onNewIntent(intent);
-
-        // If it is not launched from history, then reset to top-level
-        if ((intent.getFlags() & Intent.FLAG_ACTIVITY_LAUNCHED_FROM_HISTORY) == 0) {
-            if (mFirstHeader != null && !onIsHidingHeaders() && onIsMultiPane()) {
-                switchToHeaderLocal(mFirstHeader);
-            }
-            getListView().setSelectionFromTop(0, 0);
-        }
-    }
-
-    private void highlightHeader(int id) {
-        if (id != 0) {
-            Integer index = mHeaderIndexMap.get(id);
-            if (index != null) {
-                getListView().setItemChecked(index, true);
-                if (isMultiPane()) {
-                    getListView().smoothScrollToPosition(index);
-                }
-            }
-        }
-    }
-
-    @Override
-    public Intent getIntent() {
-        Intent superIntent = super.getIntent();
-        String startingFragment = getStartingFragmentClass(superIntent);
-        // This is called from super.onCreate, isMultiPane() is not yet reliable
-        // Do not use onIsHidingHeaders either, which relies itself on this method
-        if (startingFragment != null && !onIsMultiPane()) {
-            Intent modIntent = new Intent(superIntent);
-            modIntent.putExtra(EXTRA_SHOW_FRAGMENT, startingFragment);
-            Bundle args = superIntent.getExtras();
-            if (args != null) {
-                args = new Bundle(args);
-            } else {
-                args = new Bundle();
-            }
-            args.putParcelable("intent", superIntent);
-            modIntent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, superIntent.getExtras());
-            return modIntent;
-        }
-        return superIntent;
-    }
-
-    /**
-     * Checks if the component name in the intent is different from the Settings class and
-     * returns the class name to load as a fragment.
-     */
-    protected String getStartingFragmentClass(Intent intent) {
-        if (mFragmentClass != null) return mFragmentClass;
-        String intentClass = intent.getComponent().getClassName();
-        if (intentClass.equals(getClass().getName())) return null;
-
-        return intentClass;
-    }
-
-    /**
-     * Override initial header when an activity-alias is causing Settings to be launched
-     * for a specific fragment encoded in the android:name parameter.
-     */
-    @Override
-    public Header onGetInitialHeader() {
-        String fragmentClass = getStartingFragmentClass(super.getIntent());
-        if (fragmentClass != null) {
-            Header header = new Header();
-            header.fragment = fragmentClass;
-            header.title = getTitle();
-            header.fragmentArguments = getIntent().getExtras();
-            mCurrentHeader = header;
-            return header;
-        }
-
-        return mFirstHeader;
-    }
-
-    @Override
-    public Intent onBuildStartFragmentIntent(String fragmentName, Bundle args,
-                                             int titleRes, int shortTitleRes) {
-        Intent intent = super.onBuildStartFragmentIntent(fragmentName, args,
-                titleRes, shortTitleRes);
-        onBuildStartFragmentIntentHelper(fragmentName, intent);
-        return intent;
-    }
-
-    private void onBuildStartFragmentIntentHelper(String fragmentName, Intent intent) {
-        intent.setClass(this, SubSettings.class);
-    }
-
-    /**
-     * Populate the activity with the top-level headers.
-     */
-    @Override
-    public void onBuildHeaders(List<Header> headers) {
-        if (!onIsHidingHeaders()) {
-            loadHeadersFromResource(R.xml.settings_headers, headers);
-            updateHeaderList(headers);
-        }
-    }
-
-    private void updateHeaderList(List<Header> target) {
-        int i = 0;
-        mHeaderIndexMap.clear();
-        while (i < target.size()) {
-            Header header = target.get(i);
-            // Ids are integers, so downcasting
-            int id = (int) header.id;
-
-            if (id == R.id.dev_settings) {
-                if (!Build.DEBUG) {
-                    target.remove(i);
-                }
-            }
-
-            // Increment if the current one wasn't removed by the Utils code.
-            if (target.get(i) == header) {
-                // Hold on to the first header, when we need to reset to the top-level
-                int headerType = HeaderAdapter.getHeaderType(header);
-                if (mFirstHeader == null &&
-                        headerType == HeaderAdapter.HEADER_TYPE_NORMAL) {
-                    mFirstHeader = header;
-                }
-                mHeaderIndexMap.put(id, i);
-                i++;
-            }
-        }
-    }
-
-    private void getMetaData() {
-        try {
-            ActivityInfo ai = getPackageManager().getActivityInfo(getComponentName(),
-                    PackageManager.GET_META_DATA);
-            if (ai == null || ai.metaData == null) return;
-            mTopLevelHeaderId = ai.metaData.getInt(META_DATA_KEY_HEADER_ID);
-            mFragmentClass = ai.metaData.getString(META_DATA_KEY_FRAGMENT_CLASS);
-
-            // Check if it has a parent specified and create a Header object
-            final int parentHeaderTitleRes = ai.metaData.getInt(META_DATA_KEY_PARENT_TITLE);
-            String parentFragmentClass = ai.metaData.getString(META_DATA_KEY_PARENT_FRAGMENT_CLASS);
-            if (parentFragmentClass != null) {
-                mParentHeader = new Header();
-                mParentHeader.fragment = parentFragmentClass;
-                if (parentHeaderTitleRes != 0) {
-                    mParentHeader.title = getResources().getString(parentHeaderTitleRes);
-                }
-            }
-        } catch (NameNotFoundException nnfe) {
-            // No recovery
-        }
-    }
-
-    private static class HeaderAdapter extends ArrayAdapter<Header> {
-        static final int HEADER_TYPE_CATEGORY = 0;
-        static final int HEADER_TYPE_NORMAL = 1;
-        static final int HEADER_TYPE_SWITCH = 2;
-
-        private static final int HEADER_TYPE_COUNT = 3;
-
-        private final Enabler mLockscreenEnabler;
-        private final Enabler mActiveEnabler;
-
-        private static class HeaderViewHolder {
-            ImageView icon;
-            TextView title;
-            TextView summary;
-            Switch switch_;
-        }
-
-        private LayoutInflater mInflater;
-
-        static int getHeaderType(Header header) {
-            if (header.fragment == null && header.intent == null) {
-                return HEADER_TYPE_CATEGORY;
-            } else if (header.id == R.id.keyguard_settings
-                    || header.id == R.id.active_settings) {
-                return HEADER_TYPE_SWITCH;
-            } else {
-                return HEADER_TYPE_NORMAL;
-            }
-        }
-
-        @Override
-        public int getItemViewType(int position) {
-            Header header = getItem(position);
-            return getHeaderType(header);
-        }
-
-        @Override
-        public boolean areAllItemsEnabled() {
-            return false; // because of categories
-        }
-
-        @Override
-        public boolean isEnabled(int position) {
-            return getItemViewType(position) != HEADER_TYPE_CATEGORY;
-        }
-
-        @Override
-        public int getViewTypeCount() {
-            return HEADER_TYPE_COUNT;
-        }
-
-        @Override
-        public boolean hasStableIds() {
-            return true;
-        }
-
-        public HeaderAdapter(Context context, List<Header> objects) {
-            super(context, 0, objects);
-
-            mInflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-
-            // Temp Switches provided as placeholder until the adapter replaces these with actual
-            // Switches inflated from their layouts. Must be done before adapter is set in super
-            mLockscreenEnabler = new Enabler(context, new Switch(context), Config.KEY_KEYGUARD);
-            mActiveEnabler = new Enabler(context, new Switch(context), Config.KEY_ACTIVE_MODE);
-        }
-
-        @Override
-        public View getView(int position, View convertView, ViewGroup parent) {
-            final HeaderViewHolder holder;
-            final Header header = getItem(position);
-            final int headerType = getHeaderType(header);
-            View view = null;
-
-            if (convertView == null) {
-                holder = new HeaderViewHolder();
-                switch (headerType) {
-                    case HEADER_TYPE_CATEGORY:
-                        view = new TextView(getContext(), null,
-                                android.R.attr.listSeparatorTextViewStyle);
-                        holder.title = (TextView) view;
-                        break;
-
-                    case HEADER_TYPE_SWITCH:
-                        view = mInflater.inflate(
-                                R.layout.preference_header_switch_item, parent,
-                                false);
-                        holder.icon = (ImageView) view.findViewById(R.id.icon);
-                        holder.title = (TextView) view.findViewById(android.R.id.title);
-                        holder.summary = (TextView) view.findViewById(android.R.id.summary);
-                        holder.switch_ = (Switch) view.findViewById(R.id.switch_);
-                        break;
-
-                    case HEADER_TYPE_NORMAL:
-                        view = mInflater.inflate(
-                                R.layout.preference_header_item, parent,
-                                false);
-                        holder.icon = (ImageView) view.findViewById(R.id.icon);
-                        holder.title = (TextView) view.findViewById(android.R.id.title);
-                        holder.summary = (TextView) view.findViewById(android.R.id.summary);
-                        break;
-                }
-                view.setTag(holder);
-            } else {
-                view = convertView;
-                holder = (HeaderViewHolder) view.getTag();
-            }
-
-            // All view fields must be updated every time, because the view may be recycled
-            switch (headerType) {
-                case HEADER_TYPE_CATEGORY:
-                    holder.title.setText(header.getTitle(getContext().getResources()));
-                    break;
-
-                case HEADER_TYPE_SWITCH:
-                    if (header.id == R.id.keyguard_settings) {
-                        mLockscreenEnabler.setSwitch(holder.switch_);
-                    } else if (header.id == R.id.active_settings) {
-                        mActiveEnabler.setSwitch(holder.switch_);
-                    }
-                case HEADER_TYPE_NORMAL:
-                    holder.icon.setImageResource(header.iconRes);
-                    holder.title.setText(header.getTitle(getContext().getResources()));
-
-                    CharSequence summary = header.getSummary(getContext().getResources());
-                    if (!TextUtils.isEmpty(summary)) {
-                        holder.summary.setVisibility(View.VISIBLE);
-                        holder.summary.setText(summary);
-                    } else {
-                        holder.summary.setVisibility(View.GONE);
-                    }
-                    break;
-            }
-
-            return view;
-        }
-
-        public void resume() {
-            mLockscreenEnabler.resume();
-            mActiveEnabler.resume();
-        }
-
-        public void pause() {
-            mLockscreenEnabler.pause();
-            mActiveEnabler.pause();
-        }
-    }
-
-    @Override
-    public boolean onPreferenceStartFragment(PreferenceFragment caller, Preference pref) {
-        int titleRes = pref.getTitleRes();
-        startPreferencePanel(pref.getFragment(), pref.getExtras(),
-                titleRes, pref.getTitle(), null, 0);
-        return true;
-    }
-
-    @Override
-    public boolean shouldUpRecreateTask(Intent targetIntent) {
-        return super.shouldUpRecreateTask(new Intent(this, Settings.class));
-    }
-
-    @Override
-    public void setListAdapter(ListAdapter adapter) {
-        if (adapter == null) {
-            super.setListAdapter(null);
-        } else {
-            List<Header> headers = null;
-            try {
-                Method method = PreferenceActivity.class.getDeclaredMethod("getHeaders");
-                method.setAccessible(true);
-                headers = (List<Header>) method.invoke(this);
-            } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
-                e.printStackTrace();
-            }
-
-            super.setListAdapter(new HeaderAdapter(this, headers));
-        }
-    }
-
-    public static class ActiveModeSettingsActivity extends Settings { /* empty */
-    }
-
-    public static class LockscreenSettingsActivity extends Settings { /* empty */
-    }
-}
diff --git a/project/app/src/main/java/com/achep/acdisplay/ui/DynamicBackground.java b/project/app/src/main/java/com/achep/acdisplay/ui/DynamicBackground.java
new file mode 100644
index 00000000..9f4faa92
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/DynamicBackground.java
@@ -0,0 +1,258 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.ui;
+
+import android.animation.Animator;
+import android.animation.AnimatorInflater;
+import android.animation.AnimatorListenerAdapter;
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.drawable.BitmapDrawable;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.TransitionDrawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.transitions.everywhere.TransitionManager;
+import android.transitions.everywhere.hidden.Crossfade;
+import android.util.Log;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageView;
+
+import com.achep.acdisplay.Config;
+import com.achep.acdisplay.R;
+import com.achep.acdisplay.ui.fragments.AcDisplayFragment;
+import com.achep.base.utils.Operator;
+
+import static com.achep.base.Build.DEBUG;
+
+/**
+ * Created by Artem Chepurnoy on 22.11.2014.
+ */
+public abstract class DynamicBackground {
+
+    protected static final String TAG = "DynamicBackground";
+
+    private static final boolean TRANSITION_IS_NOT_BUGGY = false;
+
+    public static DynamicBackground newInstance(@NonNull AcDisplayFragment fragment,
+                                                @Nullable ImageView imageView) {
+        return TRANSITION_IS_NOT_BUGGY
+                ? new DynamicBackgroundTransition(fragment, imageView)
+                : new DynamicBackgroundCompat(fragment, imageView);
+    }
+
+    protected final AcDisplayFragment mFragment;
+    protected final ImageView mImageView;
+
+    protected DynamicBackground(@NonNull AcDisplayFragment fragment,
+                                @Nullable ImageView imageView) {
+        mFragment = fragment;
+        mImageView = imageView;
+
+        if (mImageView == null) {
+            return;
+        }
+
+        initBackground();
+    }
+
+    protected abstract void initBackground();
+
+    protected abstract void dispatchSetBackgroundInternal(@Nullable Bitmap bitmap);
+
+    /**
+     * Clears background.
+     *
+     * @see #dispatchSetBackground(android.graphics.Bitmap, int)
+     */
+    public void dispatchClearBackground() {
+        dispatchSetBackground(null);
+    }
+
+    /**
+     * Smoothly sets the background. This feature is known as "Dynamic background".
+     *
+     * @param bitmap the bitmap to display, or {@code null} to hide previous background.
+     * @param mask   one of the following:
+     *               {@link Config#DYNAMIC_BG_ARTWORK_MASK},
+     *               {@link Config#DYNAMIC_BG_NOTIFICATION_MASK} or
+     *               {@code 0} to bypass mask checking.
+     * @see #dispatchClearBackground()
+     */
+    public void dispatchSetBackground(@Nullable Bitmap bitmap, int mask) {
+        Config config = mFragment.getConfig();
+        if (mask == 0 || Operator.bitAnd(config.getDynamicBackgroundMode(), mask)) {
+            dispatchSetBackground(bitmap);
+        }
+    }
+
+    /**
+     * Smoothly sets the background.
+     */
+    private void dispatchSetBackground(@Nullable Bitmap bitmap) {
+        if (mImageView == null) return;
+        if (false) {
+            if (DEBUG) Log.d(TAG, "Skipped background change: using default one.");
+            return;
+        }
+
+        if (mFragment.isPowerSaveMode()) { // No animations and no background.
+            mImageView.setImageBitmap(null);
+        } else {
+            dispatchSetBackgroundInternal(bitmap);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    private static class DynamicBackgroundTransition extends DynamicBackground {
+
+        private Crossfade mTransition;
+
+        /**
+         * {@inheritDoc}
+         */
+        DynamicBackgroundTransition(
+                @NonNull AcDisplayFragment fragment,
+                @Nullable ImageView imageView) {
+            super(fragment, imageView);
+        }
+
+        @Override
+        protected void initBackground() {
+            assert mImageView != null;
+
+            mTransition = new Crossfade();
+            mTransition.addTarget(mImageView);
+        }
+
+        @Override
+        protected void dispatchSetBackgroundInternal(@Nullable Bitmap bitmap) {
+            assert mImageView != null;
+
+            if (mImageView.getWidth() > 0 && mImageView.getHeight() > 0) {
+                // Avoid of bug in Crossfade.java that causes 0-sized Bitmap to be
+                // created.
+                // https://github.com/andkulikov/transitions-everywhere/blob/master/library/src/main/java/android/transitions/everywhere/hidden/Crossfade.java
+                TransitionManager.beginDelayedTransition((ViewGroup) mFragment.getView(), mTransition);
+            }
+
+            mImageView.setImageBitmap(bitmap);
+        }
+
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    private static class DynamicBackgroundCompat extends DynamicBackground {
+
+        private Animator mEnterAnimation;
+        private Animator mExitAnimation;
+
+        /**
+         * {@inheritDoc}
+         */
+        DynamicBackgroundCompat(
+                @NonNull AcDisplayFragment fragment,
+                @Nullable ImageView imageView) {
+            super(fragment, imageView);
+        }
+
+        @Override
+        protected void initBackground() {
+            assert mImageView != null;
+            Context context = mFragment.getActivity();
+
+            // Setup enter animation.
+            mEnterAnimation = AnimatorInflater.loadAnimator(context, R.animator.background_enter);
+            mEnterAnimation.setTarget(mImageView);
+            mEnterAnimation.addListener(new AnimatorListenerAdapter() {
+
+                @Override
+                public void onAnimationStart(Animator animation) {
+                    mImageView.setVisibility(View.VISIBLE);
+                }
+
+            });
+
+            // Setup exit animation.
+            mExitAnimation = AnimatorInflater.loadAnimator(context, R.animator.background_exit);
+            mExitAnimation.setTarget(mImageView);
+            mExitAnimation.addListener(new AnimatorListenerAdapter() {
+
+                @Override
+                public void onAnimationEnd(Animator animation) {
+                    mImageView.setVisibility(View.GONE);
+                    mImageView.setImageDrawable(null);
+                }
+
+            });
+        }
+
+        @Override
+        protected void dispatchSetBackgroundInternal(@Nullable Bitmap bitmap) {
+            assert mImageView != null;
+
+            if (bitmap == null) { // Clear background.
+                if (mImageView.getDrawable() != null) {
+                    mEnterAnimation.cancel();
+                    mExitAnimation.start();
+                }
+            } else { // Set background.
+                BitmapDrawable drawable = new BitmapDrawable(getResources(), bitmap);
+                Drawable drawablePrev = mImageView.getDrawable();
+
+                if (mExitAnimation.isRunning()) {
+                    mExitAnimation.cancel();
+                    mEnterAnimation.setupEndValues();
+                }
+
+                if (drawablePrev == null) {
+                    mImageView.setImageDrawable(drawable);
+                    mEnterAnimation.start();
+                } else {
+                    if (drawablePrev instanceof TransitionDrawable) {
+                        TransitionDrawable d = (TransitionDrawable) drawablePrev;
+                        drawablePrev = d.getDrawable(1);
+                        d.resetTransition();
+                    }
+
+                    Drawable[] arrayDrawable = new Drawable[]{drawablePrev, drawable};
+                    TransitionDrawable transitionDrawable = new TransitionDrawable(arrayDrawable);
+                    transitionDrawable.setCrossFadeEnabled(true);
+                    mImageView.setImageDrawable(transitionDrawable);
+
+                    // Start cross-fade animation.
+                    int duration = getResources().getInteger(android.R.integer.config_shortAnimTime);
+                    transitionDrawable.startTransition(duration);
+                }
+            }
+        }
+
+        private Resources getResources() {
+            return mFragment.getResources();
+        }
+
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/ui/activities/AcDisplayActivity.java b/project/app/src/main/java/com/achep/acdisplay/ui/activities/AcDisplayActivity.java
new file mode 100644
index 00000000..403745be
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/activities/AcDisplayActivity.java
@@ -0,0 +1,181 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.ui.activities;
+
+import android.annotation.SuppressLint;
+import android.app.FragmentManager;
+import android.app.FragmentTransaction;
+import android.content.Intent;
+import android.os.Bundle;
+import android.view.View;
+
+import com.achep.acdisplay.Config;
+import com.achep.acdisplay.Presenter;
+import com.achep.acdisplay.R;
+import com.achep.acdisplay.Timeout;
+import com.achep.acdisplay.ui.fragments.PocketFragment;
+import com.achep.base.Device;
+
+/**
+ * Created by Artem on 25.01.14.
+ */
+public class AcDisplayActivity extends KeyguardActivity implements
+        Timeout.OnTimeoutEventListener,
+        PocketFragment.OnSleepRequestListener {
+
+    private static final String TAG = "AcDisplayActivity";
+
+    private Config mConfig = Config.getInstance();
+    private PocketFragment mPocketFragment;
+
+    @Override
+    public void onWindowFocusChanged(boolean hasFocus) {
+        super.onWindowFocusChanged(hasFocus);
+        populateFlags(hasFocus);
+    }
+
+    @SuppressLint("NewApi")
+    private void populateFlags(boolean windowHasFocus) {
+        final View decorView = getWindow().getDecorView();
+
+        if (windowHasFocus) {
+            int visibilityUi = View.SYSTEM_UI_FLAG_LAYOUT_STABLE
+                    | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
+                    | View.SYSTEM_UI_FLAG_LOW_PROFILE;
+
+            if (mConfig.isFullScreen()) {
+                // Hide status bar if fullscreen mode is enabled.
+                visibilityUi = visibilityUi
+                        | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
+                        | View.SYSTEM_UI_FLAG_FULLSCREEN;
+
+                if (Device.hasKitKatApi()) {
+                    // Hide navigation bar and flag sticky.
+                    visibilityUi = visibilityUi
+                            | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
+                            | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
+                }
+            }
+
+            decorView.setSystemUiVisibility(visibilityUi);
+        }
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        if (mConfig.isWallpaperShown()) setTheme(R.style.MaterialTheme_AcDisplay_Wallpaper);
+        super.onCreate(savedInstanceState);
+
+        setContentView(R.layout.acdisplay);
+
+        // Initialize non-UI fragments.
+        if (savedInstanceState == null) {
+            initInternalFragments();
+        } else {
+
+            // Find fragments.
+            FragmentManager fm = getFragmentManager();
+            mPocketFragment = (PocketFragment) fm.findFragmentByTag(PocketFragment.TAG);
+            // TODO: Maybe remove PocketFragment if active mode is disabled?
+        }
+
+        // Setup fragments.
+        if (mPocketFragment != null) {
+            mPocketFragment.setListener(this);
+        }
+
+        //   mPulsingThread = new PulsingThread(getContentResolver());
+        //   mPulsingThread.start();
+        Presenter.getInstance().attachActivity(this);
+    }
+
+    /**
+     * Initializes non-UI fragments such as {@link com.achep.acdisplay.ui.fragments.PocketFragment}.
+     */
+    private void initInternalFragments() {
+        FragmentTransaction ft = getFragmentManager().beginTransaction();
+
+        // Turns screen off inside of your pocket.
+        if (mConfig.isActiveModeEnabled()) {
+            mPocketFragment = PocketFragment.newInstance();
+            ft.add(mPocketFragment, PocketFragment.TAG);
+        }
+
+        ft.commit();
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        mConfig.getTriggers().incrementLaunchCount(this, null);
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        hideHeadsUpApp(true);
+        populateFlags(true);
+    }
+
+    @Override
+    protected void onPause() {
+        hideHeadsUpApp(false);
+        populateFlags(false);
+        super.onPause();
+    }
+
+    /**
+     * Asks HeadsUp (https://play.google.com/store/apps/details?id=com.achep.headsup) to
+     * pause or continue showing its floating notifications.
+     *
+     * @param hideHeadsUp {@code true} to disallow showing floating notifications,
+     *                    {@code false} to allow.
+     */
+    private void hideHeadsUpApp(boolean hideHeadsUp) {
+        Intent intent = new Intent(hideHeadsUp
+                ? "com.achep.headsup.ACTION_DISALLOW_HEADSUP"
+                : "com.achep.headsup.ACTION_ALLOW_HEADSUP");
+        sendBroadcast(intent);
+    }
+
+    @Override
+    protected void onDestroy() {
+        Presenter.getInstance().detachActivity();
+        super.onDestroy();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean onSleepRequest() {
+        // Probably it's not the best solution, but not worst too.
+        // Check if user does not interact with app before locking.
+        if (!getTimeout().isPaused()) {
+
+            return lock();
+        }
+        return false;
+    }
+
+    public Config getConfig() {
+        return mConfig;
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/blacklist/activities/BlacklistActivity.java b/project/app/src/main/java/com/achep/acdisplay/ui/activities/BlacklistActivity.java
similarity index 99%
rename from project/app/src/main/java/com/achep/acdisplay/blacklist/activities/BlacklistActivity.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/activities/BlacklistActivity.java
index 7706e3b0..c84d4b9c 100644
--- a/project/app/src/main/java/com/achep/acdisplay/blacklist/activities/BlacklistActivity.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/activities/BlacklistActivity.java
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.blacklist.activities;
+package com.achep.acdisplay.ui.activities;
 
 import android.app.Activity;
 import android.content.ComponentName;
@@ -51,8 +51,8 @@ import android.widget.TextView;
 import com.achep.acdisplay.R;
 import com.achep.acdisplay.blacklist.AppConfig;
 import com.achep.acdisplay.blacklist.Blacklist;
-import com.achep.acdisplay.blacklist.fragments.BlacklistAppFragment;
-import com.achep.acdisplay.utils.MathUtils;
+import com.achep.acdisplay.ui.fragments.BlacklistAppFragment;
+import com.achep.base.utils.MathUtils;
 
 import java.lang.reflect.InvocationTargetException;
 import java.lang.reflect.Method;
diff --git a/project/app/src/main/java/com/achep/acdisplay/ui/activities/KeyguardActivity.java b/project/app/src/main/java/com/achep/acdisplay/ui/activities/KeyguardActivity.java
new file mode 100644
index 00000000..08b69c30
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/activities/KeyguardActivity.java
@@ -0,0 +1,368 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.ui.activities;
+
+import android.app.KeyguardManager;
+import android.app.admin.DevicePolicyManager;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.PowerManager;
+import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+import android.view.WindowManager;
+
+import com.achep.acdisplay.App;
+import com.achep.acdisplay.Config;
+import com.achep.acdisplay.R;
+import com.achep.acdisplay.Timeout;
+import com.achep.acdisplay.services.KeyguardService;
+import com.achep.base.Device;
+import com.achep.base.ui.activities.ActivityBase;
+import com.achep.base.utils.LogUtils;
+
+import static com.achep.base.Build.DEBUG;
+
+
+/**
+ * Activity that contains some methods to emulate system keyguard.
+ */
+public abstract class KeyguardActivity extends ActivityBase implements
+        Timeout.OnTimeoutEventListener {
+
+    private static final String TAG = "KeyguardActivity";
+    public static final String EXTRA_TURN_SCREEN_ON = "turn_screen_on";
+
+    private static final int UNLOCKING_MAX_TIME = 150; // ms.
+    private static final int PF_MAX_TIME = 2000; // ms.
+
+    private BroadcastReceiver mScreenOffReceiver;
+    private KeyguardManager mKeyguardManager;
+    private long mUnlockingTime;
+    private boolean mResumed;
+
+    private final Timeout mTimeout = new Timeout();
+    private final Handler mHandler = new Handler();
+
+    @Override
+    public void onWindowFocusChanged(boolean windowHasFocus) {
+        super.onWindowFocusChanged(windowHasFocus);
+        if (DEBUG) Log.d(TAG, "On window focus changed " + windowHasFocus);
+
+        if (isUnlocking()) {
+            if (windowHasFocus) {
+                mUnlockingTime = 0;
+            } else {
+                finish();
+                return;
+            }
+        }
+        if (mResumed) {
+            populateFlags(windowHasFocus);
+        }
+    }
+
+    private void populateFlags(boolean manualControl) {
+        int windowFlags = WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON;
+        int timeoutDelay = Config.getInstance().getTimeoutNormal();
+
+        if (manualControl) {
+            getWindow().addFlags(windowFlags);
+
+            mTimeout.resume();
+            mTimeout.setTimeoutDelayed(timeoutDelay, true);
+        } else {
+            getWindow().clearFlags(windowFlags);
+
+            mTimeout.setTimeoutDelayed(timeoutDelay, true);
+            mTimeout.pause();
+        }
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        if (DEBUG) Log.d(TAG, "Creating keyguard activity...");
+
+        mTimeout.registerListener(this);
+        mKeyguardManager = (KeyguardManager) getSystemService(Context.KEYGUARD_SERVICE);
+        registerScreenOffReceiver();
+
+        int flags = 0;
+
+        // Handle intents
+        Intent intent = getIntent();
+        if (intent != null) {
+            // Turns screen on.
+            if (intent.getBooleanExtra(EXTRA_TURN_SCREEN_ON, false))
+                flags |= WindowManager.LayoutParams.FLAG_TURN_SCREEN_ON;
+        }
+
+        // FIXME: Android dev team broke the DISMISS_KEYGUARD flag.
+        // https://code.google.com/p/android-developer-preview/issues/detail?id=1902
+        if (Device.hasLollipopApi() /* bugs monster */ && !mKeyguardManager.isKeyguardSecure()) {
+            getWindow().addFlags(flags | WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
+        } else {
+            getWindow().addFlags(flags |
+                    // Show activity above the system keyguard.
+                    WindowManager.LayoutParams.FLAG_SHOW_WHEN_LOCKED);
+        }
+    }
+
+    @Override
+    protected void onDestroy() {
+        if (DEBUG) Log.d(TAG, "Destroying keyguard activity...");
+
+        unregisterScreenOffReceiver();
+
+        mTimeout.unregisterListener(this);
+        mTimeout.clear();
+
+        super.onDestroy();
+    }
+
+    /**
+     * Registers a receiver to finish activity when screen goes off.
+     * You will need to {@link #unregisterScreenOffReceiver() unregister} it
+     * later.
+     *
+     * @see #unregisterScreenOffReceiver()
+     */
+    private void registerScreenOffReceiver() {
+        mScreenOffReceiver = new BroadcastReceiver() {
+
+            @Override
+            public void onReceive(Context context, Intent intent) {
+                if (!KeyguardService.isActive) {
+                    PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
+                    pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "Finalize the keyguard.").acquire(200);
+                    KeyguardActivity.this.finish();
+                }
+            }
+
+        };
+
+        IntentFilter intentFilter = new IntentFilter(Intent.ACTION_SCREEN_OFF);
+        intentFilter.setPriority(IntentFilter.SYSTEM_HIGH_PRIORITY - 1); // max allowed priority
+        registerReceiver(mScreenOffReceiver, intentFilter);
+    }
+
+    /**
+     * Unregisters the screen off receiver if it was registered previously.
+     *
+     * @see #registerScreenOffReceiver()
+     */
+    private void unregisterScreenOffReceiver() {
+        if (mScreenOffReceiver != null) {
+            unregisterReceiver(mScreenOffReceiver);
+            mScreenOffReceiver = null;
+        }
+    }
+
+    @Override
+    protected void onResume() {
+        if (DEBUG) Log.d(TAG, "Resuming keyguard activity...");
+        super.onResume();
+
+        mResumed = true;
+        mUnlockingTime = 0;
+        populateFlags(true);
+        overrideHomePress(true);
+
+        /*
+        // Read the system's screen off timeout setting.
+        try {
+            mSystemScreenOffTimeout = Settings.System.getInt(
+                    getContentResolver(),
+                    Settings.System.SCREEN_OFF_TIMEOUT);
+        } catch (Settings.SettingNotFoundException e) {
+            mSystemScreenOffTimeout = -1;
+        }
+        */
+    }
+
+    @Override
+    protected void onPause() {
+        if (DEBUG) Log.d(TAG, "Pausing keyguard activity...");
+        mResumed = false;
+        populateFlags(false);
+        overrideHomePress(false);
+
+        mHandler.removeCallbacksAndMessages(null);
+
+        super.onPause();
+    }
+
+    /**
+     * Notifies Xposed {@link com.achep.acdisplay.plugins.xposed.OverrideHomeButton module}
+     * to start ignoring home button press. Please, notice that it will ignore home button
+     * click everywhere until you call {@code overrideHomePress(false)}
+     *
+     * @param override {@code true} to start ignoring, {@code false} to stop.
+     * @see com.achep.acdisplay.plugins.xposed.OverrideHomeButton
+     * @see #sendBroadcast(android.content.Intent)
+     */
+    private void overrideHomePress(boolean override) {
+        Intent intent = new Intent(override
+                ? App.ACTION_EAT_HOME_PRESS_START
+                : App.ACTION_EAT_HOME_PRESS_STOP);
+        sendBroadcast(intent);
+    }
+
+    @Override
+    protected void onUserLeaveHint() {
+        super.onUserLeaveHint();
+        if (DEBUG) Log.d(TAG, "User is leaving...");
+        /*
+        // The user has tried to fool the keyguard.
+        // Blame him ("You shall not pass!")
+        // and turn the screen off.
+        if (PowerUtils.isScreenOn(this)) {
+            if (!mUnlocking) {
+                Log.i(TAG, "You shall not pass!");
+                lock();
+            } else if (!mLocking) {
+                finish();
+            }
+        }
+        */
+    }
+
+    @Override
+    public void onTimeoutEvent(@NonNull Timeout timeout, int event) {
+        if (DEBUG) LogUtils.v(TAG, "TIMEOUT: " + event, 5);
+        switch (event) {
+            case Timeout.EVENT_TIMEOUT:
+                lock();
+                break;
+        }
+    }
+
+    /**
+     * Locks the device (and turns screen off).
+     *
+     * @return {@code true} if successful, {@code false} otherwise.
+     * @see DevicePolicyManager#lockNow()
+     */
+    public boolean lock() {
+        DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
+        try {
+            // TODO: Respect secure lock timeout settings.
+            mUnlockingTime = 0;
+            dpm.lockNow();
+            return true;
+        } catch (SecurityException e) {
+            return false; // Screw you owner!
+        }
+    }
+
+    /**
+     * Unlocks keyguard and runs {@link Runnable runnable} when unlocked.
+     */
+    public void unlock(@Nullable Runnable runnable) {
+        unlock(runnable, true);
+    }
+
+    /**
+     * Unlocks keyguard and runs {@link Runnable runnable} when unlocked.
+     *
+     * @param finish {@code true} to finish activity, {@code false} to keep it
+     * @see #unlock(Runnable)
+     */
+    public void unlock(final @Nullable Runnable runnable, final boolean finish) {
+        if (DEBUG) Log.d(TAG, "Unlocking with params: finish=" + finish);
+
+        // If keyguard is disabled no need to make
+        // a delay between calling this method and
+        // unlocking.
+        // Otherwise we need this delay to get new
+        // flags applied.
+        final long now = SystemClock.elapsedRealtime();
+
+        mUnlockingTime = now;
+        getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
+
+        mHandler.post(new Runnable() {
+
+            @Override
+            public void run() {
+                // Loop until flag gets applied.
+                // TODO: Use somewhat trigger for detecting unlocking.
+                int delta = (int) (SystemClock.elapsedRealtime() - now);
+                if (isLocked() && !isSecure() && delta < UNLOCKING_MAX_TIME) {
+                    mHandler.postDelayed(this, 30);
+                    return;
+                }
+
+                if (runnable != null) runnable.run();
+                if (finish) {
+                    finish();
+
+                    Config config = Config.getInstance();
+                    overridePendingTransition(0, config.isUnlockAnimationEnabled()
+                            ? R.anim.activity_unlock
+                            : 0);
+                }
+            }
+        });
+    }
+
+    /**
+     * Return whether the keyguard requires a password to unlock.
+     *
+     * @return {@code true} is keyguard is secure, {@code false} otherwise.
+     */
+    public boolean isSecure() {
+        return mKeyguardManager.isKeyguardSecure();
+    }
+
+    /**
+     * Return whether the keyguard presents.
+     *
+     * @return {@code true} if device is locked, {@code false} otherwise.
+     */
+    public boolean isLocked() {
+        return mKeyguardManager.isKeyguardLocked();
+    }
+
+    /**
+     * Return whether the keyguard is unlocking.
+     *
+     * @return {@code true} if the keyguard is unlocking atm, {@code false} otherwise.
+     * @see #unlock(Runnable)
+     * @see #PF_MAX_TIME
+     */
+    public boolean isUnlocking() {
+        return SystemClock.elapsedRealtime() - mUnlockingTime <= PF_MAX_TIME;
+    }
+
+    @NonNull
+    public Timeout getTimeout() {
+        return mTimeout;
+    }
+
+    @Override
+    public void onBackPressed() { /* override back button */ }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/ui/activities/MainActivity.java b/project/app/src/main/java/com/achep/acdisplay/ui/activities/MainActivity.java
new file mode 100644
index 00000000..1fa28d21
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/activities/MainActivity.java
@@ -0,0 +1,328 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.ui.activities;
+
+import android.app.Notification;
+import android.app.NotificationManager;
+import android.app.PendingIntent;
+import android.app.admin.DevicePolicyManager;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.res.Resources;
+import android.graphics.BitmapFactory;
+import android.graphics.Typeface;
+import android.media.RingtoneManager;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.PowerManager;
+import android.support.annotation.NonNull;
+import android.support.v7.app.ActionBarActivity;
+import android.text.SpannableStringBuilder;
+import android.text.style.StyleSpan;
+import android.util.Log;
+import android.view.Menu;
+import android.view.MenuItem;
+import android.widget.CompoundButton;
+import android.widget.ImageView;
+
+import com.achep.acdisplay.App;
+import com.achep.acdisplay.Config;
+import com.achep.acdisplay.DialogHelper;
+import com.achep.acdisplay.R;
+import com.achep.acdisplay.utils.AccessUtils;
+import com.achep.base.Device;
+import com.achep.base.content.ConfigBase;
+import com.achep.base.ui.activities.ActivityBase;
+import com.achep.base.ui.widgets.SwitchBar;
+import com.achep.base.utils.PackageUtils;
+import com.achep.base.utils.ToastUtils;
+import com.achep.base.utils.ViewUtils;
+
+import static com.achep.base.Build.DEBUG;
+
+/**
+ * Created by Artem on 21.01.14.
+ */
+public class MainActivity extends ActivityBase implements ConfigBase.OnConfigChangedListener {
+
+    private static final String TAG = "MainActivity";
+
+    private static void sendTestNotification(@NonNull Context context) {
+        final int id = App.ID_NOTIFY_TEST;
+        final Resources res = context.getResources();
+
+        PendingIntent pendingIntent = PendingIntent.getActivity(context,
+                id, new Intent(context, MainActivity.class),
+                PendingIntent.FLAG_UPDATE_CURRENT);
+        Notification.BigTextStyle bts = new Notification.BigTextStyle()
+                .bigText(res.getString(R.string.notification_test_message_large));
+        Notification.Builder builder = new Notification.Builder(context)
+                .setContentTitle(res.getString(R.string.app_name))
+                .setContentText(res.getString(R.string.notification_test_message))
+                .setContentIntent(pendingIntent)
+                .setLargeIcon(BitmapFactory.decodeResource(res, R.mipmap.ic_launcher))
+                .setSmallIcon(R.drawable.stat_acdisplay)
+                .setAutoCancel(true)
+                .setStyle(bts)
+                .setSound(RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION));
+
+        NotificationManager nm = (NotificationManager) context.getSystemService(Context.NOTIFICATION_SERVICE);
+        nm.notify(id, builder.build());
+    }
+
+    private SwitchBar mSwitchBar;
+    private ImageView mSwitchAlertView;
+    private MenuItem mSendTestNotificationMenuItem;
+    private Config mConfig;
+
+    private boolean mBroadcasting;
+
+    private void showCompatibilityIssuesAlert() {
+        boolean force = DEBUG;
+        int[] pairs = {
+                R.string.compat_alert_notifications,
+                android.os.Build.VERSION_CODES.JELLY_BEAN_MR2,
+                R.string.compat_alert_immersive_mode,
+                android.os.Build.VERSION_CODES.KITKAT,
+                R.string.compat_alert_music_widget,
+                android.os.Build.VERSION_CODES.KITKAT,
+        };
+
+        // Check over all pairs.
+        if (!force) {
+            boolean empty = true;
+            for (int i = 1; i < pairs.length; i += 2) {
+                final int api = pairs[i];
+                if (!Device.hasTargetApi(api)) {
+                    empty = false;
+                    break;
+                }
+            }
+            if (empty) return;
+        }
+
+        String formatter = getString(R.string.compat_alert_formatter);
+        SpannableStringBuilder builder = new SpannableStringBuilder();
+        builder.append(getString(R.string.compat_alert_title));
+        builder.setSpan(new StyleSpan(Typeface.BOLD), 0, builder.length(), 0);
+        builder.append('\n');
+
+        for (int i = 0; i < pairs.length; i += 2) {
+            final int api = pairs[i + 1];
+            if (!Device.hasTargetApi(api) || force) {
+                String str = getString(pairs[i]);
+                str = String.format(formatter, str);
+                builder.append(str);
+            }
+        }
+
+        final int length = builder.length();
+        builder.delete(length - 1, length);
+        ToastUtils.showLong(this, builder);
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        requestCheckout();
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.main);
+
+        mConfig = Config.getInstance();
+        mConfig.registerListener(this);
+
+        mSwitchBar = (SwitchBar) findViewById(R.id.switch_bar);
+        mSwitchAlertView = (ImageView) mSwitchBar.findViewById(R.id.icon);
+        mSwitchAlertView.setImageResource(R.drawable.ic_action_warning_amber);
+        mSwitchBar.setChecked(mConfig.isEnabled());
+        mSwitchBar.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
+
+            @Override
+            public void onCheckedChanged(CompoundButton compoundButton, boolean checked) {
+                updateSendTestNotificationMenuItem();
+                if (mBroadcasting) {
+                    return;
+                }
+
+                ActionBarActivity context = MainActivity.this;
+                if (checked && !AccessUtils.hasAllRights(context)) {
+                    // Reset compound button and update
+                    // testing menu item.
+                    compoundButton.setChecked(false);
+                    updateSendTestNotificationMenuItem();
+
+                    // Show permission dialog.
+                    DialogHelper.showSetupPermissionsDialog(context);
+                } else if (mConfig.setEnabled(context, checked, MainActivity.this)) {
+                    if (checked) {
+                        showCompatibilityIssuesAlert();
+                    }
+                } else {
+
+                    // Setting option failed, so we need to
+                    // sync switch with config.
+                    compoundButton.setChecked(mConfig.isEnabled());
+                    updateSendTestNotificationMenuItem();
+                }
+            }
+        });
+
+        Config.Triggers triggers = mConfig.getTriggers();
+        if (!triggers.isDonationAsked() && triggers.getLaunchCount() >= 15) {
+            triggers.setDonationAsked(this, true, this);
+            DialogHelper.showCryDialog(this);
+        }
+
+        handleAppUpgrade();
+    }
+
+    private void handleAppUpgrade() {
+        PackageInfo pi;
+        try {
+            pi = getPackageManager().getPackageInfo(PackageUtils.getName(this), 0);
+        } catch (PackageManager.NameNotFoundException e) {
+            Log.wtf(TAG, "Failed to find my PackageInfo.");
+            return;
+        }
+
+        Config.Triggers triggers = mConfig.getTriggers();
+
+        final int versionCode = pi.versionCode;
+        final int versionCodeOld = triggers.getPreviousVersion();
+
+        if (versionCodeOld < versionCode) {
+            triggers.setPreviousVersion(this, pi.versionCode, null);
+        }
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+
+        boolean hasAllRights = AccessUtils.hasAllRights(this);
+        mSwitchBar.setChecked(mSwitchBar.isChecked() && hasAllRights);
+        ViewUtils.setVisible(mSwitchAlertView, !hasAllRights);
+    }
+
+    private void updateSendTestNotificationMenuItem() {
+        if (mSendTestNotificationMenuItem != null) {
+            mSendTestNotificationMenuItem.setVisible(mSwitchBar.isChecked());
+        }
+    }
+
+    @Override
+    protected void onDestroy() {
+        super.onDestroy();
+        mConfig.unregisterListener(this);
+    }
+
+    @Override
+    public void onConfigChanged(@NonNull ConfigBase config,
+                                @NonNull String key,
+                                @NonNull Object value) {
+        switch (key) {
+            case Config.KEY_ENABLED:
+                mBroadcasting = true;
+                mSwitchBar.setChecked((Boolean) value);
+                mBroadcasting = false;
+                break;
+        }
+    }
+
+    @Override
+    public boolean onCreateOptionsMenu(Menu menu) {
+        getMenuInflater().inflate(R.menu.main, menu);
+
+        mSendTestNotificationMenuItem = menu.findItem(R.id.test_action);
+        updateSendTestNotificationMenuItem();
+        return true;
+    }
+
+    @Override
+    public boolean onOptionsItemSelected(MenuItem item) {
+        switch (item.getItemId()) {
+            case R.id.settings_action:
+                startActivity(new Intent(this, Settings2.class));
+                break;
+            case R.id.test_action:
+                startAcDisplayTest(true);
+                break;
+
+            //-- DIALOGS ------------------------------------------------------
+
+            case R.id.donate_action:
+                DialogHelper.showDonateDialog(this);
+                break;
+            case R.id.feedback_action:
+                DialogHelper.showFeedbackDialog(this);
+                break;
+            case R.id.about_action:
+                DialogHelper.showAboutDialog(this);
+                break;
+            case R.id.help_action:
+                DialogHelper.showHelpDialog(this);
+                break;
+            default:
+                return super.onOptionsItemSelected(item);
+        }
+        return true;
+    }
+
+    /**
+     * Turns screen off and sends a test notification.
+     *
+     * @param cheat {@code true} if it simply starts {@link AcDisplayActivity},
+     *              {@code false} if it turns device off and then uses notification
+     *              to wake it up.
+     */
+    private void startAcDisplayTest(boolean cheat) {
+        if (cheat) {
+            startActivity(new Intent(this, AcDisplayActivity.class));
+            sendTestNotification(this);
+            return;
+        }
+
+        int delay = getResources().getInteger(R.integer.config_test_notification_delay);
+
+        PowerManager pm = (PowerManager) getSystemService(Context.POWER_SERVICE);
+        PowerManager.WakeLock wakeLock = pm.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, "Test notification.");
+        wakeLock.acquire(delay);
+
+        try {
+            // Go sleep
+            DevicePolicyManager dpm = (DevicePolicyManager) getSystemService(Context.DEVICE_POLICY_SERVICE);
+            dpm.lockNow();
+
+            new Handler().postDelayed(new Runnable() {
+
+                private final Context context = getApplicationContext();
+
+                @Override
+                public void run() {
+                    sendTestNotification(context);
+                }
+            }, delay);
+        } catch (SecurityException e) {
+            Log.wtf(TAG, "Failed to turn screen off!");
+            wakeLock.release();
+        }
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/ui/activities/Settings2.java b/project/app/src/main/java/com/achep/acdisplay/ui/activities/Settings2.java
new file mode 100644
index 00000000..577f011d
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/activities/Settings2.java
@@ -0,0 +1,75 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.ui.activities;
+
+import android.support.annotation.NonNull;
+import android.support.annotation.XmlRes;
+
+import com.achep.acdisplay.R;
+import com.achep.acdisplay.services.activemode.ActiveModeService;
+import com.achep.acdisplay.ui.fragments.settings.ActiveModeSettings;
+import com.achep.acdisplay.ui.fragments.settings.InterfaceSettings;
+import com.achep.acdisplay.ui.fragments.settings.KeyguardSettings;
+import com.achep.acdisplay.ui.fragments.settings.MoreSettings;
+import com.achep.acdisplay.ui.fragments.settings.NotificationSettings;
+import com.achep.base.dashboard.DashboardTile;
+import com.achep.base.ui.activities.SettingsActivity;
+
+import static com.achep.base.Build.DEBUG;
+
+/**
+ * Created by Artem Chepurnoy on 02.01.2015.
+ */
+public class Settings2 extends SettingsActivity {
+
+    private static final String[] ENTRY_FRAGMENTS = {
+            KeyguardSettings.class.getName(),
+            ActiveModeSettings.class.getName(),
+            NotificationSettings.class.getName(),
+            InterfaceSettings.class.getName(),
+            MoreSettings.class.getName()
+    };
+
+    @Override
+    protected boolean isValidFragment(@NonNull String fragmentName) {
+        // Almost all fragments are wrapped in this,
+        // except for a few that have their own activities.
+        for (String fragment : ENTRY_FRAGMENTS)
+            if (fragment.equals(fragmentName))
+                return true;
+        return false;
+    }
+
+    @XmlRes
+    @Override
+    public int getDashboardResource() {
+        return R.xml.settings_dashboard;
+    }
+
+    @Override
+    protected boolean isTileSupported(@NonNull DashboardTile tile) {
+        switch ((int) tile.id) {
+            case R.id.dev_settings:
+                return DEBUG;
+            case R.id.active_settings:
+                return ActiveModeService.isSupported(this);
+        }
+        return true;
+    }
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/blacklist/activities/SubBlacklistActivity.java b/project/app/src/main/java/com/achep/acdisplay/ui/activities/SubBlacklistActivity.java
similarity index 97%
rename from project/app/src/main/java/com/achep/acdisplay/blacklist/activities/SubBlacklistActivity.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/activities/SubBlacklistActivity.java
index a61411f2..7dd6ca6a 100644
--- a/project/app/src/main/java/com/achep/acdisplay/blacklist/activities/SubBlacklistActivity.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/activities/SubBlacklistActivity.java
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.blacklist.activities;
+package com.achep.acdisplay.ui.activities;
 
 import android.app.FragmentManager;
 import android.util.Log;
diff --git a/project/app/src/main/java/com/achep/acdisplay/animations/CircleDarkeningAnimation.java b/project/app/src/main/java/com/achep/acdisplay/ui/animations/CircleDarkeningAnimation.java
similarity index 94%
rename from project/app/src/main/java/com/achep/acdisplay/animations/CircleDarkeningAnimation.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/animations/CircleDarkeningAnimation.java
index 5a52b7a0..4ce3068f 100644
--- a/project/app/src/main/java/com/achep/acdisplay/animations/CircleDarkeningAnimation.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/animations/CircleDarkeningAnimation.java
@@ -16,13 +16,12 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.animations;
+package com.achep.acdisplay.ui.animations;
 
 import android.view.animation.Animation;
 import android.view.animation.Transformation;
 
-import com.achep.acdisplay.widgets.CircleView;
+import com.achep.acdisplay.ui.widgets.CircleView;
 
 /**
  * Created by achep on 19.04.14.
diff --git a/project/app/src/main/java/com/achep/acdisplay/animations/CircleRadiusAnimation.java b/project/app/src/main/java/com/achep/acdisplay/ui/animations/CircleRadiusAnimation.java
similarity index 54%
rename from project/app/src/main/java/com/achep/acdisplay/animations/CircleRadiusAnimation.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/animations/CircleRadiusAnimation.java
index a741f8d4..def907b8 100644
--- a/project/app/src/main/java/com/achep/acdisplay/animations/CircleRadiusAnimation.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/animations/CircleRadiusAnimation.java
@@ -1,9 +1,27 @@
-package com.achep.acdisplay.animations;
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.ui.animations;
 
 import android.view.animation.Animation;
 import android.view.animation.Transformation;
 
-import com.achep.acdisplay.widgets.CircleView;
+import com.achep.acdisplay.ui.widgets.CircleView;
 
 /**
  * Created by achep on 19.04.14.
diff --git a/project/app/src/main/java/com/achep/acdisplay/animations/ProgressBarAnimation.java b/project/app/src/main/java/com/achep/acdisplay/ui/animations/ProgressBarAnimation.java
similarity index 97%
rename from project/app/src/main/java/com/achep/acdisplay/animations/ProgressBarAnimation.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/animations/ProgressBarAnimation.java
index 91c24abd..e533c243 100644
--- a/project/app/src/main/java/com/achep/acdisplay/animations/ProgressBarAnimation.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/animations/ProgressBarAnimation.java
@@ -16,8 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.animations;
+package com.achep.acdisplay.ui.animations;
 
 import android.view.animation.Animation;
 import android.view.animation.Transformation;
diff --git a/project/app/src/main/java/com/achep/acdisplay/ui/components/ClockWidget.java b/project/app/src/main/java/com/achep/acdisplay/ui/components/ClockWidget.java
new file mode 100644
index 00000000..17ccc86f
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/components/ClockWidget.java
@@ -0,0 +1,88 @@
+/*
+ * Copyright (C) 2015 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.ui.components;
+
+import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.view.LayoutInflater;
+import android.view.ViewGroup;
+
+import com.achep.acdisplay.R;
+import com.achep.acdisplay.ui.fragments.AcDisplayFragment;
+
+/**
+ * Very simple clock widget for {@link com.achep.acdisplay.ui.fragments.AcDisplayFragment}.
+ *
+ * @author Artem Chepurnoy
+ */
+public class ClockWidget extends Widget {
+
+    private static final String TAG = "ClockWidget";
+
+    public ClockWidget(@NonNull Callback callback, @NonNull AcDisplayFragment fragment) {
+        super(callback, fragment);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isHomeWidget() {
+        return true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean hasClock() {
+        return true;
+    }
+
+    @Override
+    protected ViewGroup onCreateView(
+            @NonNull LayoutInflater inflater,
+            @NonNull ViewGroup container,
+            @Nullable ViewGroup sceneView) {
+        boolean initialize = sceneView == null;
+        if (initialize) {
+            sceneView = (ViewGroup) inflater.inflate(R.layout.acdisplay_scene_clock, container, false);
+            assert sceneView != null;
+        }
+
+        if (!initialize) {
+            return sceneView;
+        }
+
+        return sceneView;
+    }
+
+    @Nullable
+    @Override
+    public Bitmap getBackground() {
+        return null;
+    }
+
+    @Override
+    public int getBackgroundMask() {
+        return 0;
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/ui/components/MediaWidget.java b/project/app/src/main/java/com/achep/acdisplay/ui/components/MediaWidget.java
new file mode 100644
index 00000000..e8144f6c
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/components/MediaWidget.java
@@ -0,0 +1,334 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.ui.components;
+
+import android.annotation.SuppressLint;
+import android.content.res.ColorStateList;
+import android.content.res.Resources;
+import android.graphics.Bitmap;
+import android.graphics.Color;
+import android.graphics.PorterDuff;
+import android.graphics.drawable.Drawable;
+import android.os.AsyncTask;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v4.media.session.PlaybackStateCompat;
+import android.support.v7.graphics.Palette;
+import android.transitions.everywhere.TransitionManager;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ImageButton;
+import android.widget.ImageView;
+import android.widget.TextView;
+
+import com.achep.acdisplay.Config;
+import com.achep.acdisplay.R;
+import com.achep.acdisplay.graphics.BackgroundFactory;
+import com.achep.acdisplay.services.media.MediaController2;
+import com.achep.acdisplay.services.media.Metadata;
+import com.achep.acdisplay.ui.fragments.AcDisplayFragment;
+import com.achep.base.Device;
+import com.achep.base.ui.drawables.PlayPauseDrawable;
+import com.achep.base.ui.drawables.RippleDrawable2;
+import com.achep.base.utils.Operator;
+import com.achep.base.utils.RippleUtils;
+import com.achep.base.utils.ViewUtils;
+
+import static com.achep.base.Build.DEBUG;
+
+/**
+ * Media widget for {@link com.achep.acdisplay.ui.fragments.AcDisplayFragment} that provides
+ * basic media controls and has a nice skin.
+ *
+ * @author Artem Chepurnoy
+ */
+public class MediaWidget extends Widget implements
+        MediaController2.MediaListener,
+        View.OnClickListener,
+        View.OnLongClickListener {
+
+    private static final String TAG = "MediaWidget";
+
+    private final MediaController2 mMediaController;
+    private final PlayPauseDrawable mPlayPauseDrawable;
+    private final Drawable mWarningDrawable;
+
+    private ImageView mArtworkView;
+    private TextView mTitleView;
+    private TextView mSubtitleView;
+    private ImageButton mButtonPrevious;
+    private ImageButton mButtonPlayPause;
+    private ImageButton mButtonNext;
+
+    private Bitmap mArtwork;
+    private Bitmap mArtworkBackground;
+    private AsyncTask<Bitmap, Void, Palette> mPaletteWorker;
+    private AsyncTask<Void, Void, Bitmap> mBackgroundWorker;
+
+    private final Palette.PaletteAsyncListener mPaletteCallback =
+            new Palette.PaletteAsyncListener() {
+                @Override
+                public void onGenerated(@NonNull Palette palette) {
+                    updatePlayPauseButtonColor(palette.getVibrantColor(Color.WHITE));
+                }
+            };
+
+    private final BackgroundFactory.BackgroundAsyncListener mBackgroundCallback =
+            new BackgroundFactory.BackgroundAsyncListener() {
+                @Override
+                public void onGenerated(@NonNull Bitmap bitmap) {
+                    mArtworkBackground = bitmap;
+                    populateBackground();
+                }
+            };
+
+    public MediaWidget(@NonNull Callback callback, @NonNull AcDisplayFragment fragment) {
+        super(callback, fragment);
+        mMediaController = fragment.getMediaController2();
+
+        Resources res = fragment.getResources();
+        mPlayPauseDrawable = new PlayPauseDrawable();
+        mPlayPauseDrawable.setSize(res.getDimensionPixelSize(R.dimen.media_btn_actual_size));
+        mWarningDrawable = res.getDrawable(R.drawable.ic_action_warning_white);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isHomeWidget() {
+        return true;
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        mMediaController.registerListener(this);
+    }
+
+    @Override
+    public void onStop() {
+        mMediaController.unregisterListener(this);
+        super.onStop();
+    }
+
+    @Override
+    public void onMetadataChanged(@NonNull Metadata metadata) {
+        populateMetadata();
+        final Bitmap bitmap = metadata.bitmap;
+
+        // Check if artwork are equals. If so, then we don't need to
+        // generate everything from the beginning.
+        if (mArtwork == bitmap || mArtwork != null && mArtwork.sameAs(bitmap)) {
+            return;
+        }
+
+        mArtwork = bitmap;
+        mArtworkBackground = null;
+
+        com.achep.base.async.AsyncTask.stop(mPaletteWorker);
+        com.achep.base.async.AsyncTask.stop(mBackgroundWorker);
+
+        if (metadata.bitmap != null) {
+            // TODO: Load the vibrant color only.
+            mPaletteWorker = Palette.generateAsync(bitmap, mPaletteCallback);
+
+            int dynamicBgMode = getConfig().getDynamicBackgroundMode();
+            if (Operator.bitAnd(dynamicBgMode, getBackgroundMask())) {
+                mBackgroundWorker = BackgroundFactory.generateAsync(bitmap, mBackgroundCallback);
+                return; // Do not reset the background.
+            }
+        } else {
+            mPaletteWorker = null;
+        }
+
+        mBackgroundWorker = null;
+        populateBackground();
+    }
+
+    @Override
+    public void onPlaybackStateChanged(int state) {
+        // Making transformation rule for the warning icon is too
+        // much overkill for me.
+        if (state == PlaybackStateCompat.STATE_ERROR) {
+            mButtonPlayPause.setImageDrawable(mWarningDrawable);
+        } else {
+            mButtonPlayPause.setImageDrawable(mPlayPauseDrawable);
+        }
+
+        if (DEBUG) Log.d(TAG, "Playback state is " + state);
+
+        final int imageDescId;
+        switch (state) {
+            case PlaybackStateCompat.STATE_ERROR:
+                imageDescId = R.string.media_play_description;
+                break;
+            case PlaybackStateCompat.STATE_PLAYING:
+                mPlayPauseDrawable.transformToPause();
+                imageDescId = R.string.media_pause_description;
+                break;
+            case PlaybackStateCompat.STATE_BUFFERING:
+            case PlaybackStateCompat.STATE_STOPPED:
+                mPlayPauseDrawable.transformToStop();
+                imageDescId = R.string.media_stop_description;
+                break;
+            case PlaybackStateCompat.STATE_PAUSED:
+            default:
+                mPlayPauseDrawable.transformToPlay();
+                imageDescId = R.string.media_play_description;
+                break;
+        }
+
+        mButtonPlayPause.setContentDescription(getHostFragment().getString(imageDescId));
+    }
+
+    /**
+     * Updates the content of the view to latest metadata
+     * provided by {@link com.achep.acdisplay.services.media.MediaController2#getMetadata()}.
+     */
+    private void populateMetadata() {
+        TransitionManager.beginDelayedTransition(getView());
+
+        Metadata metadata = mMediaController.getMetadata();
+        ViewUtils.safelySetText(mTitleView, metadata.title);
+        ViewUtils.safelySetText(mSubtitleView, metadata.subtitle);
+        updatePlayPauseButtonColor(Color.WHITE); // Reset color
+
+        if (mArtworkView != null) {
+            mArtworkView.setImageBitmap(metadata.bitmap);
+        }
+    }
+
+    /**
+     * Requests host to update dynamic background.
+     *
+     * @see #getBackground()
+     * @see #getBackgroundMask()
+     */
+    private void populateBackground() {
+        mCallback.requestBackgroundUpdate(this);
+    }
+
+    @SuppressLint("NewApi")
+    private void updatePlayPauseButtonColor(int color) {
+        if (Device.hasLollipopApi()) {
+            RippleDrawable2 rippleDrawable = (RippleDrawable2) mButtonPlayPause.getBackground();
+            rippleDrawable.setColorFilter(color, PorterDuff.Mode.MULTIPLY);
+        } else {
+            RippleUtils.makeFor(ColorStateList.valueOf(color), false, mButtonPlayPause);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Nullable
+    @Override
+    public Bitmap getBackground() {
+        return mArtworkBackground == null
+                ? mArtwork
+                : mArtworkBackground;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getBackgroundMask() {
+        return Config.DYNAMIC_BG_ARTWORK_MASK;
+    }
+
+    @Override
+    protected ViewGroup onCreateView(
+            @NonNull LayoutInflater inflater,
+            @NonNull ViewGroup container,
+            @Nullable ViewGroup sceneView) {
+        boolean initialize = sceneView == null;
+        if (initialize) {
+            sceneView = (ViewGroup) inflater.inflate(R.layout.acdisplay_scene_music, container, false);
+            assert sceneView != null;
+        }
+
+        mArtworkView = (ImageView) sceneView.findViewById(R.id.artwork);
+        mTitleView = (TextView) sceneView.findViewById(R.id.media_title);
+        mSubtitleView = (TextView) sceneView.findViewById(R.id.media_subtitle);
+        mButtonPrevious = (ImageButton) sceneView.findViewById(R.id.previous);
+        mButtonPlayPause = (ImageButton) sceneView.findViewById(R.id.play);
+        mButtonNext = (ImageButton) sceneView.findViewById(R.id.next);
+
+        if (!initialize) {
+            return sceneView;
+        }
+
+        mButtonPrevious.setOnClickListener(this);
+        mButtonPlayPause.setImageDrawable(mPlayPauseDrawable);
+        mButtonPlayPause.setOnClickListener(this);
+        mButtonPlayPause.setOnLongClickListener(this);
+        mButtonNext.setOnClickListener(this);
+
+        if (Device.hasLollipopApi()) {
+            // FIXME: Ripple doesn't work if the background is set (masked ripple works fine, but ugly).
+            // Apply our own ripple drawable with slightly extended abilities, such
+            // as setting color filter.
+            ColorStateList csl = container.getResources().getColorStateList(R.color.ripple_dark);
+            mButtonPlayPause.setBackground(new RippleDrawable2(csl, null, null));
+        } else {
+            RippleUtils.makeFor(false, true,
+                    mButtonNext,
+                    mButtonPlayPause,
+                    mButtonPrevious);
+        }
+
+        return sceneView;
+    }
+
+    @Override
+    public void onClick(@NonNull View v) {
+        int action;
+        if (v == mButtonPrevious) {
+            action = MediaController2.ACTION_SKIP_TO_PREVIOUS;
+        } else if (v == mButtonPlayPause) {
+            action = MediaController2.ACTION_PLAY_PAUSE;
+        } else if (v == mButtonNext) {
+            action = MediaController2.ACTION_SKIP_TO_NEXT;
+        } else {
+            Log.wtf(TAG, "Received click event from an unknown view.");
+            return;
+        }
+
+        mMediaController.sendMediaAction(action);
+        mCallback.requestTimeoutRestart(this);
+    }
+
+    @Override
+    public boolean onLongClick(@NonNull View v) {
+        if (v == mButtonPlayPause) {
+            mMediaController.sendMediaAction(MediaController2.ACTION_STOP);
+        } else {
+            Log.wtf(TAG, "Received long-click event from an unknown view.");
+            return false;
+        }
+
+        mCallback.requestTimeoutRestart(this);
+        return true;
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/acdisplay/components/NotifyWidget.java b/project/app/src/main/java/com/achep/acdisplay/ui/components/NotifyWidget.java
similarity index 79%
rename from project/app/src/main/java/com/achep/acdisplay/acdisplay/components/NotifyWidget.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/components/NotifyWidget.java
index bfe15a76..07475921 100644
--- a/project/app/src/main/java/com/achep/acdisplay/acdisplay/components/NotifyWidget.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/components/NotifyWidget.java
@@ -16,8 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.acdisplay.components;
+package com.achep.acdisplay.ui.components;
 
 import android.app.PendingIntent;
 import android.graphics.Bitmap;
@@ -29,13 +28,13 @@ import android.view.ViewGroup;
 
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.acdisplay.AcDisplayFragment;
+import com.achep.acdisplay.interfaces.INotificatiable;
+import com.achep.acdisplay.notifications.NotificationUtils;
 import com.achep.acdisplay.notifications.OpenNotification;
-import com.achep.acdisplay.utils.BitmapUtils;
+import com.achep.acdisplay.ui.fragments.AcDisplayFragment;
+import com.achep.acdisplay.ui.widgets.notification.NotificationIconWidget;
+import com.achep.acdisplay.ui.widgets.notification.NotificationWidget;
 import com.achep.acdisplay.utils.PendingIntentUtils;
-import com.achep.acdisplay.widgets.NotificationIconWidget;
-import com.achep.acdisplay.widgets.NotificationView;
-import com.achep.acdisplay.widgets.NotificationWidget;
 
 import org.apache.commons.lang.builder.EqualsBuilder;
 import org.apache.commons.lang.builder.HashCodeBuilder;
@@ -43,7 +42,9 @@ import org.apache.commons.lang.builder.HashCodeBuilder;
 /**
  * Created by Artem on 02.04.2014.
  */
-public class NotifyWidget extends Widget implements NotificationView {
+public class NotifyWidget extends Widget implements
+        OpenNotification.OnNotificationDataChangedListener,
+        INotificatiable {
 
     private NotificationIconWidget mIconView;
     private OpenNotification mNotification;
@@ -94,6 +95,7 @@ public class NotifyWidget extends Widget implements NotificationView {
 
     @Override
     public void onDismiss() {
+        assert mNotifyWidget.getNotification() != null;
         mNotifyWidget.getNotification().dismiss();
     }
 
@@ -102,23 +104,11 @@ public class NotifyWidget extends Widget implements NotificationView {
         return false;
     }
 
-    @Nullable
-    @Override
-    public Bitmap getBackground() {
-        Bitmap bitmap = mNotification.getNotificationData().getBackground();
-        return bitmap != null && !BitmapUtils.hasTransparentCorners(bitmap) ? bitmap : null;
-    }
-
-    @Override
-    public int getBackgroundMask() {
-        return Config.DYNAMIC_BG_NOTIFICATION_MASK;
-    }
-
     @Override
     protected View onCreateIconView(
             @NonNull LayoutInflater inflater,
             @NonNull ViewGroup container) {
-        View view = inflater.inflate(R.layout.widget_notification_icon, container, false);
+        View view = inflater.inflate(R.layout.notification_icon, container, false);
         assert view != null;
 
         mIconView = (NotificationIconWidget) view;
@@ -143,7 +133,6 @@ public class NotifyWidget extends Widget implements NotificationView {
             return sceneView;
         }
 
-        // mNotifyWidget.setActionButtonsAlignment(RelativeLayout.ALIGN_BOTTOM);
         mNotifyWidget.setOnClickListener(new NotificationWidget.OnClickListener() {
 
             @Override
@@ -174,12 +163,39 @@ public class NotifyWidget extends Widget implements NotificationView {
         return sceneView;
     }
 
+    @NonNull
+    @Override
+    public OpenNotification getNotification() {
+        return mNotification;
+    }
+
+    public boolean hasIdenticalIds(OpenNotification notification) {
+        return NotificationUtils.hasIdenticalIds(mNotification, notification);
+    }
+
     @Override
     public void onViewAttached() {
-        mNotification.getNotificationData().markAsRead(true);
+        super.onViewAttached();
+        mNotification.markAsRead();
+        mNotification.registerListener(this);
         mNotifyWidget.setNotification(mNotification);
     }
 
+    @Override
+    public void onViewDetached() {
+        mNotification.unregisterListener(this);
+        super.onViewDetached();
+    }
+
+    @Override
+    public void onNotificationDataChanged(@NonNull OpenNotification notification, int event) {
+        switch (event) {
+            case OpenNotification.EVENT_BACKGROUND:
+                mCallback.requestBackgroundUpdate(this);
+                break;
+        }
+    }
+
     @Override
     public void setNotification(OpenNotification notification) {
         mNotification = notification;
@@ -192,8 +208,21 @@ public class NotifyWidget extends Widget implements NotificationView {
         }
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @Nullable
     @Override
-    public OpenNotification getNotification() {
-        return mNotification;
+    public Bitmap getBackground() {
+        return mNotification.getBackground();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getBackgroundMask() {
+        return Config.DYNAMIC_BG_NOTIFICATION_MASK;
     }
+
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/acdisplay/components/Widget.java b/project/app/src/main/java/com/achep/acdisplay/ui/components/Widget.java
similarity index 90%
rename from project/app/src/main/java/com/achep/acdisplay/acdisplay/components/Widget.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/components/Widget.java
index e6d8caeb..f93721be 100644
--- a/project/app/src/main/java/com/achep/acdisplay/acdisplay/components/Widget.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/components/Widget.java
@@ -16,8 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.acdisplay.components;
+package com.achep.acdisplay.ui.components;
 
 import android.graphics.Bitmap;
 import android.support.annotation.NonNull;
@@ -27,7 +26,7 @@ import android.view.View;
 import android.view.ViewGroup;
 
 import com.achep.acdisplay.Config;
-import com.achep.acdisplay.acdisplay.AcDisplayFragment;
+import com.achep.acdisplay.ui.fragments.AcDisplayFragment;
 
 import org.apache.commons.lang.builder.EqualsBuilder;
 import org.apache.commons.lang.builder.HashCodeBuilder;
@@ -51,12 +50,12 @@ public abstract class Widget {
     private boolean mShown;
 
     /**
-     * Interface definition for a callback to host fragment.
+     * Interface definition for a callback to the host fragment.
      */
     public interface Callback {
 
         /**
-         * Requests fragment to update widget's dynamic background.
+         * Requests the fragment to update widget's dynamic background.
          *
          * @see #getBackground()
          * @see #getBackgroundMask()
@@ -64,9 +63,10 @@ public abstract class Widget {
         public void requestBackgroundUpdate(@NonNull Widget widget);
 
         /**
-         * Requests fragment to restarts timeout.
+         * Requests the fragment to restart the timeout.
          */
         public void requestTimeoutRestart(@NonNull Widget widget);
+
     }
 
     public Widget(@NonNull Callback callback, @NonNull AcDisplayFragment fragment) {
@@ -106,11 +106,28 @@ public abstract class Widget {
                 .isEquals();
     }
 
+    /**
+     * @return the host fragment
+     */
     @NonNull
     public AcDisplayFragment getHostFragment() {
         return mHostFragment;
     }
 
+    public Config getConfig() {
+        return mHostFragment.getConfig();
+    }
+
+    //-- HOME WIDGET ----------------------------------------------------------
+
+    public boolean isHomeWidget() {
+        return false;
+    }
+
+    public boolean hasClock() {
+        return false;
+    }
+
     //-- DISMISSING WIDGET ----------------------------------------------------
 
     /**
@@ -172,7 +189,7 @@ public abstract class Widget {
 
     //-- LIFE CYCLE -----------------------------------------------------------
 
-    public void onCreate() { /* empty */ }
+    public void onStart() { /* empty */ }
 
     /**
      * This is called when the {@link #getView() view} is attached to host fragment.
@@ -199,7 +216,7 @@ public abstract class Widget {
         return mShown;
     }
 
-    public void onDestroy() { /* empty */ }
+    public void onStop() { /* empty */ }
 
     //-- VIEWS ----------------------------------------------------------------
 
diff --git a/project/app/src/main/java/com/achep/acdisplay/ui/fragments/AcDisplayFragment.java b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/AcDisplayFragment.java
new file mode 100644
index 00000000..05f20c75
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/AcDisplayFragment.java
@@ -0,0 +1,1390 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.ui.fragments;
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.annotation.SuppressLint;
+import android.app.Activity;
+import android.app.Fragment;
+import android.content.Context;
+import android.content.res.Resources;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.os.SystemClock;
+import android.support.annotation.NonNull;
+import android.support.v4.media.session.PlaybackStateCompat;
+import android.transitions.everywhere.ChangeBounds;
+import android.transitions.everywhere.Fade;
+import android.transitions.everywhere.Scene;
+import android.transitions.everywhere.Transition;
+import android.transitions.everywhere.TransitionManager;
+import android.transitions.everywhere.TransitionSet;
+import android.util.Log;
+import android.view.GestureDetector;
+import android.view.HapticFeedbackConstants;
+import android.view.LayoutInflater;
+import android.view.MotionEvent;
+import android.view.VelocityTracker;
+import android.view.View;
+import android.view.ViewConfiguration;
+import android.view.ViewGroup;
+import android.view.WindowManager;
+import android.view.animation.AccelerateInterpolator;
+import android.view.animation.Animation;
+import android.view.animation.Transformation;
+import android.widget.GridLayout;
+import android.widget.ImageView;
+import android.widget.ProgressBar;
+
+import com.achep.acdisplay.Config;
+import com.achep.acdisplay.R;
+import com.achep.acdisplay.Timeout;
+import com.achep.acdisplay.compat.SceneCompat;
+import com.achep.acdisplay.notifications.NotificationPresenter;
+import com.achep.acdisplay.notifications.NotificationUtils;
+import com.achep.acdisplay.notifications.OpenNotification;
+import com.achep.acdisplay.services.media.MediaController2;
+import com.achep.acdisplay.services.media.Metadata;
+import com.achep.acdisplay.ui.DynamicBackground;
+import com.achep.acdisplay.ui.activities.AcDisplayActivity;
+import com.achep.acdisplay.ui.components.ClockWidget;
+import com.achep.acdisplay.ui.components.MediaWidget;
+import com.achep.acdisplay.ui.components.NotifyWidget;
+import com.achep.acdisplay.ui.components.Widget;
+import com.achep.acdisplay.ui.view.ForwardingLayout;
+import com.achep.acdisplay.ui.view.ForwardingListener;
+import com.achep.acdisplay.ui.widgets.CircleView;
+import com.achep.base.Device;
+import com.achep.base.content.ConfigBase;
+import com.achep.base.ui.activities.ActivityBase;
+import com.achep.base.ui.animations.AnimationListenerAdapter;
+import com.achep.base.ui.widgets.TextView;
+import com.achep.base.utils.LogUtils;
+import com.achep.base.utils.MathUtils;
+import com.achep.base.utils.ViewUtils;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.HashMap;
+
+import static com.achep.base.Build.DEBUG;
+
+/**
+ * This is main fragment of ActiveDisplay app.
+ */
+// TODO: Put main scene inside of widget.
+public class AcDisplayFragment extends Fragment implements
+        NotificationPresenter.OnNotificationListChangedListener,
+        ForwardingLayout.OnForwardedEventListener,
+        View.OnTouchListener,
+        Widget.Callback,
+        ConfigBase.OnConfigChangedListener,
+        MediaController2.MediaListener,
+        CircleView.Callback {
+
+    private static final String TAG = "AcDisplayFragment";
+
+    private static final int MSG_SHOW_HOME_WIDGET = 0;
+    private static final int MSG_HIDE_MEDIA_WIDGET = 1;
+
+    // Views
+    private CircleView mCircleView;
+    private TextView mStatusClockTextView;
+    private ProgressBar mProgressBar;
+    private ViewGroup mDividerView;
+    private ForwardingLayout mSceneContainer;
+    private ForwardingLayout mIconsForwarder;
+    private GridLayout mIconsContainer;
+
+    // Main
+    private ActivityBase mActivity;
+    private AcDisplayActivity mActivityAcd;
+
+    private final HashMap<View, Widget> mWidgetsMap = new HashMap<>();
+    private final HashMap<String, SceneCompat> mScenesMap = new HashMap<>();
+    private SceneCompat mCurrentScene;
+    private Widget mSelectedWidget;
+    private View mPressedIconView;
+    private boolean mHasPinnedWidget;
+
+    private ForwardingListener mSceneForwardingListener;
+    private ForwardingListener mIconsForwardingListener;
+    private final Handler mTouchHandler = new Handler();
+
+    private int mConfigWidgetPinDuration;
+    private int mConfigWidgetSelectDelay;
+
+    // Animations and transitions
+    private TransitionSet mTransitionJit;
+    private Transition mTransitionSwitchScene;
+    private DismissAnimation mSceneContainerDismissAnim;
+
+    // Clock widget
+    private SceneCompat mSceneMainClock;
+    private ClockWidget mClockWidget;
+
+    // Media widget
+    private SceneCompat mSceneMainMedia;
+    private MediaController2 mMediaController;
+    private MediaWidget mMediaWidget;
+    private boolean mShowMediaWidget;
+
+    // Timeout
+    private Timeout.Gui mTimeoutGui;
+    private Timeout mTimeout;
+    private int mTimeoutNormal;
+    private int mTimeoutShort;
+
+    // Swipe to dismiss
+    private VelocityTracker mVelocityTracker;
+    private int mMaxFlingVelocity;
+    private int mMinFlingVelocity;
+
+    // Dynamic background
+    private DynamicBackground mBackground;
+
+    /**
+     * Handler to control delayed events.
+     *
+     * @see #MSG_HIDE_MEDIA_WIDGET
+     * @see #MSG_SHOW_HOME_WIDGET
+     */
+    private final Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            super.handleMessage(msg);
+            switch (msg.what) {
+                case MSG_HIDE_MEDIA_WIDGET:
+                    disableMediaWidget();
+                    break;
+                case MSG_SHOW_HOME_WIDGET:
+                    showHomeWidget();
+                    break;
+            }
+        }
+    };
+
+    /**
+     * Controller of dismiss animation.
+     */
+    private class DismissAnimation extends Animation {
+
+        private float start;
+        private Widget widget;
+
+        public DismissAnimation() {
+            super();
+            setAnimationListener(new AnimationListenerAdapter() {
+                @Override
+                public void onAnimationEnd(@NonNull Animation animation) {
+                    Widget widget = DismissAnimation.this.widget;
+
+                    onWidgetDismiss(widget);
+                    if (mSelectedWidget == widget) {
+                        showHomeWidget();
+                    }
+                }
+            });
+        }
+
+        @Override
+        protected void applyTransformation(float interpolatedTime, Transformation t) {
+            super.applyTransformation(interpolatedTime, t);
+            float value = (start + (1f - start) * interpolatedTime);
+            populateSceneContainerDismissAnimation(value);
+        }
+
+        public void setup(int duration, float start, Widget widget) {
+            if (!hasEnded()) Log.wtf(TAG, "Setting up running animation!!!");
+            setDuration(duration);
+            this.start = start;
+            this.widget = widget;
+        }
+
+    }
+
+    private boolean isPinnable() {
+        return getConfig().isWidgetPinnable();
+    }
+
+    private boolean isReadable() {
+        return getConfig().isWidgetReadable();
+    }
+
+    private boolean isViewLaidOut(@NonNull View view) {
+        if (Device.hasKitKatApi()) {
+            return view.isLaidOut();
+        }
+        return !view.isLayoutRequested() && view.getWidth() != 0;
+    }
+
+    /**
+     * Unlocks the keyguard and runs {@link Runnable runnable} when unlocked.
+     *
+     * @param finish {@code true} to finish activity, {@code false} to keep it
+     * @see com.achep.acdisplay.ui.activities.KeyguardActivity
+     */
+    public void unlock(Runnable runnable, boolean finish) {
+        if (!isNotDemo()) {
+            if (runnable != null) runnable.run();
+            return;
+        }
+
+        mActivityAcd.unlock(runnable, finish);
+    }
+
+    public Config getConfig() {
+        return Config.getInstance();
+    }
+
+    @Override
+    public void onAttach(Activity activity) {
+        super.onAttach(activity);
+        if (DEBUG) Log.d(TAG, "Attaching fragment...");
+        mActivity = (ActivityBase) activity;
+        mActivityAcd = isNotDemo() ? (AcDisplayActivity) activity : null;
+
+        Resources res = getResources();
+        mConfigWidgetPinDuration = res.getInteger(R.integer.config_maxPinTime);
+        mConfigWidgetSelectDelay = res.getInteger(R.integer.config_iconSelectDelayMillis);
+        ViewConfiguration vc = ViewConfiguration.get(activity);
+        mMaxFlingVelocity = vc.getScaledMaximumFlingVelocity();
+        mMinFlingVelocity = vc.getScaledMinimumFlingVelocity();
+
+        // Clock widget
+        mClockWidget = new ClockWidget(this, this);
+
+        // Media widget
+        mMediaController = MediaController2.newInstance(activity);
+        mMediaWidget = new MediaWidget(this, this);
+
+        // Transitions
+        mSceneContainerDismissAnim = new DismissAnimation();
+        mTransitionJit = new TransitionSet()
+                .setOrdering(TransitionSet.ORDERING_TOGETHER)
+                .addTransition(new Fade())
+                .addTransition(new ChangeBounds());
+        mTransitionSwitchScene = new TransitionSet()
+                .setOrdering(TransitionSet.ORDERING_TOGETHER)
+                .addTransition(new Fade(Fade.OUT).setDuration(200))
+                .addTransition(new Fade(Fade.IN).setStartDelay(80))
+                .addTransition(new ChangeBounds().setStartDelay(80));
+
+        // Timeout
+        mTimeout = isNotDemo()
+                ? mActivityAcd.getTimeout()
+                : new Timeout();
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
+        if (DEBUG) Log.d(TAG, "Creating view...");
+
+        View root = inflater.inflate(isNotDemo()
+                ? R.layout.acdisplay_fragment_full
+                : R.layout.acdisplay_fragment, container, false);
+        assert root != null;
+
+        // Initialize secondary views
+        mStatusClockTextView = (TextView) root.findViewById(R.id.clock_small);
+        mCircleView = (CircleView) root.findViewById(R.id.circle);
+        mBackground = DynamicBackground.newInstance(this,
+                (ImageView) root.findViewById(R.id.background));
+
+        // Initialize main views
+        View c = root.findViewById(R.id.container);
+        mDividerView = (ViewGroup) c.findViewById(R.id.divider);
+        mProgressBar = (ProgressBar) mDividerView.findViewById(R.id.progress);
+        mSceneContainer = (ForwardingLayout) c.findViewById(R.id.scene);
+        mIconsForwarder = (ForwardingLayout) c.findViewById(R.id.forwarding);
+        mIconsContainer = (GridLayout) c.findViewById(R.id.grid);
+        mIconsForwarder.setOnForwardedEventListener(this);
+        mIconsForwarder.setAllViewsForwardable(true, 1 /* the touch depth */);
+        mIconsForwarder.setOnTouchListener(this);
+
+        mSceneForwardingListener = new ForwardingListener(mIconsForwarder, false, mSceneContainer);
+        mIconsForwardingListener = new ForwardingListener(mIconsForwarder, true, mIconsForwarder);
+
+        // Initialize home widgets.
+        mSceneMainClock = new SceneCompat(mSceneContainer, mClockWidget
+                .createView(inflater, mSceneContainer, null));
+        mSceneMainMedia = new SceneCompat(mSceneContainer, mMediaWidget
+                .createView(inflater, mSceneContainer, null));
+
+        return root;
+    }
+
+    @Override
+    public void onViewCreated(View view, Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+        if (DEBUG) Log.d(TAG, "Creating view (created)...");
+        if (isNotDemo()) {
+            // Init the timeout
+            mTimeoutGui = new Timeout.Gui(mProgressBar);
+            mTimeout.registerListener(mTimeoutGui);
+
+            // Init the touch forwarding.
+            View.OnTouchListener listener = new TouchForwarder(getActivity(), mCircleView, mActivityAcd);
+            view.setOnTouchListener(listener);
+            mCircleView.setCallback(this);
+        }
+
+        // Needs to be started before it may be attached
+        mClockWidget.onStart();
+        mMediaWidget.onStart();
+
+        showHomeWidget(false); // Enter home widget.
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        if (DEBUG) Log.d(TAG, "Starting fragment...");
+
+        // Start all available widgets.
+        for (Widget widget : mWidgetsMap.values()) widget.onStart();
+
+        // Start listening to the media controller.
+        mMediaController.onStart();
+        mMediaController.registerListener(this);
+        onPlaybackStateChanged(mMediaController.getPlaybackState());
+
+        // Apply all possible background changes of
+        // the config or the list of notifications.
+        NotificationPresenter.getInstance().registerListener(this);
+        rebuildNotifications();
+        getConfig().registerListener(this);
+        updateIconsSize();
+        updateTimeouts();
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        mHandler.removeCallbacksAndMessages(null);
+        mTouchHandler.removeCallbacksAndMessages(null);
+
+        // Back to the home widget.
+        showHomeWidget();
+    }
+
+    @Override
+    public void onStop() {
+        if (DEBUG) Log.d(TAG, "Stopping fragment...");
+
+        // Stop all widgets.
+        for (Widget widget : mWidgetsMap.values()) widget.onStop();
+
+        // Unregister everything.
+        mMediaController.onStop();
+        mMediaController.unregisterListener(this);
+        NotificationPresenter.getInstance().unregisterListener(this);
+        getConfig().unregisterListener(this);
+
+        super.onStop();
+    }
+
+    @Override
+    public void onDestroyView() {
+        if (DEBUG) Log.d(TAG, "Destroying view...");
+        if (isNotDemo()) {
+            mTimeout.unregisterListener(mTimeoutGui);
+        }
+
+        mClockWidget.onStop();
+        mMediaWidget.onStop();
+        super.onDestroyView();
+    }
+
+    //-- CONFIG ---------------------------------------------------------------
+
+    @Override
+    public void onConfigChanged(@NonNull ConfigBase config,
+                                @NonNull String key,
+                                @NonNull Object value) {
+        switch (key) {
+            case Config.KEY_UI_ICON_SIZE:
+                updateIconsSize();
+                break;
+            case Config.KEY_TIMEOUT_NORMAL:
+                mTimeoutNormal = (int) value;
+                break;
+            case Config.KEY_TIMEOUT_SHORT:
+                mTimeoutShort = (int) value;
+                break;
+        }
+    }
+
+    private void updateTimeouts() {
+        mTimeoutNormal = getConfig().getTimeoutNormal();
+        mTimeoutShort = getConfig().getTimeoutShort();
+    }
+
+    /**
+     * Updates the size of all widget's icons as
+     * {@link com.achep.acdisplay.Config#getIconSizePx() set} in config.
+     */
+    private void updateIconsSize() {
+        final int sizePx = getConfig().getIconSizePx();
+        final int childCount = mIconsContainer.getChildCount();
+        for (int i = 0; i < childCount; i++) {
+            View child = mIconsContainer.getChildAt(i);
+            ViewUtils.setSize(child, sizePx);
+        }
+    }
+
+    //-- TIMEOUT --------------------------------------------------------------
+
+    @Override
+    public void requestTimeoutRestart(@NonNull Widget widget) {
+        if (isCurrentWidget(widget)) {
+            int timeoutDelay = getConfig().getTimeoutNormal();
+            mTimeout.setTimeoutDelayed(timeoutDelay, true);
+        }
+    }
+
+    //-- TOUCH HANDLING -------------------------------------------------------
+
+    @Override
+    public void onCircleEvent(float radius, float ratio, int event) {
+        switch (event) {
+            case CircleView.ACTION_START:
+                if (hasPinnedWidget()) {
+                    showHomeWidget();
+                }
+
+                mTimeout.setTimeoutDelayed(mTimeoutShort);
+                mTimeout.pause();
+                break;
+            case CircleView.ACTION_UNLOCK_START:
+                mActivityAcd.getWindow().addFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
+                break;
+            case CircleView.ACTION_UNLOCK_CANCEL:
+                mActivityAcd.getWindow().clearFlags(WindowManager.LayoutParams.FLAG_DISMISS_KEYGUARD);
+                break;
+            case CircleView.ACTION_UNLOCK:
+                mActivityAcd.unlock(null);
+            case CircleView.ACTION_CANCELED:
+                mTimeout.resume();
+
+                int delta = (int) (2200 - mTimeout.getRemainingTime());
+                if (delta > 0) {
+                    mTimeout.delay(delta);
+                }
+                break;
+        }
+    }
+
+    @Override
+    public void onPressedView(MotionEvent event, int activePointerId, View view) {
+        mTouchHandler.removeCallbacksAndMessages(null);
+        mPressedIconView = view;
+
+        if (view == null) {
+            return;
+        }
+
+        final Widget widget = findWidgetByIcon(view);
+        if (!isCurrentWidget(widget)) {
+            int delay = event.getActionMasked() != MotionEvent.ACTION_DOWN
+                    ? mConfigWidgetSelectDelay : 0;
+            mTouchHandler.postDelayed(new Runnable() {
+                @Override
+                public void run() {
+                    showWidget(widget);
+                }
+            }, delay);
+        } else {
+            mHandler.removeMessages(MSG_SHOW_HOME_WIDGET);
+        }
+    }
+
+    @Override
+    public boolean onTouch(View v, MotionEvent event) {
+        if (v == mIconsForwarder) {
+            mSceneForwardingListener.onTouch(v, event);
+            mIconsForwardingListener.onTouch(v, event);
+            return true;
+        }
+        return false;
+    }
+
+    @Override
+    public void onForwardedEvent(MotionEvent event, int activePointerId) {
+        boolean dismiss = false;
+
+        int action = event.getActionMasked();
+        switch (action) {
+            case MotionEvent.ACTION_DOWN:
+                // Track the velocity of movement, so we
+                // can do swipe-to-dismiss.
+                mVelocityTracker = VelocityTracker.obtain();
+            case MotionEvent.ACTION_MOVE:
+            case MotionEvent.ACTION_UP:
+                populateSwipeToDismiss(event);
+
+                if (action != MotionEvent.ACTION_UP) {
+                    return; // Don't fall down.
+                }
+
+                //noinspection LoopStatementThatDoesntLoop
+                while (isDismissible(mSelectedWidget)) {
+                    mVelocityTracker.computeCurrentVelocity(1000);
+
+                    float velocityX = mVelocityTracker.getXVelocity();
+                    float velocityY = mVelocityTracker.getYVelocity();
+                    float absVelocityX = Math.abs(velocityX);
+                    float absVelocityY = Math.abs(velocityY);
+
+                    float deltaY = mSceneContainer.getTranslationY();
+                    float absDeltaY = Math.abs(deltaY);
+
+                    int height = getSceneView().getHeight();
+                    if (height == 0) {
+                        // Scene view is not measured yet.
+                        break; // Exits from loop not from the switch!
+                    } else if (absDeltaY < height / 2) {
+                        if (mMinFlingVelocity <= absVelocityY
+                                && absVelocityY <= mMaxFlingVelocity
+                                && absVelocityY > absVelocityX * 2
+                                && absDeltaY > height / 5) {
+                            // Dismiss only if flinging in the same direction as dragging
+                            dismiss = (velocityY < 0) == (deltaY < 0);
+                        }
+
+                        if (!dismiss) {
+                            break; // Exits from loop not from the switch!
+                        }
+                    }
+
+                    dismiss = true;
+
+                    if (height > absDeltaY) {
+                        int duration;
+                        duration = Math.round(1000f /* ms. */ * (height - absDeltaY) / absVelocityX);
+                        duration = Math.min(duration, 300);
+
+                        mSceneContainerDismissAnim.setup(duration,
+                                MathUtils.range(deltaY / height, 0f, 1f),
+                                mSelectedWidget);
+                        mSceneContainer.startAnimation(mSceneContainerDismissAnim);
+                        break; // Exits from loop not from the switch!
+                    }
+
+                    // Instant dismissing.
+                    onWidgetDismiss(mSelectedWidget);
+                    showHomeWidget();
+                    break;
+                }
+
+                // Don't not reset scene while dismissing, or if
+                // pinnable.
+                if (!dismiss) {
+                    if (mPressedIconView == null || !isPinnable()) {
+                        showHomeWidget();
+                    } else {
+                        onWidgetPinned(mSelectedWidget);
+                    }
+                }
+            case MotionEvent.ACTION_CANCEL:
+                mTouchHandler.removeCallbacksAndMessages(null);
+                mVelocityTracker.recycle();
+                mVelocityTracker = null;
+
+                if (action == MotionEvent.ACTION_CANCEL) {
+                    showHomeWidget();
+                }
+                break;
+        }
+    }
+
+    protected boolean hasPinnedWidget() {
+        return mHasPinnedWidget;
+    }
+
+    protected void onWidgetPinned(Widget widget) {
+        mHandler.sendEmptyMessageDelayed(MSG_SHOW_HOME_WIDGET, mConfigWidgetPinDuration);
+        mHasPinnedWidget = true;
+    }
+
+    protected void onWidgetReadAloud(Widget widget) {
+        // TODO: Read widget aloud
+    }
+
+    /**
+     * Resets {@link #mSceneContainer scene container}'s params, such
+     * as: animation, alpha level, translation, rotation etc.
+     */
+    private void resetSceneContainerParams() {
+        mSceneContainer.clearAnimation();
+        mSceneContainer.setAlpha(1f);
+        mSceneContainer.setTranslationY(0);
+        mSceneContainer.setRotationX(0);
+    }
+
+    private void populateSceneContainerDismissAnimation(float progress) {
+        float height = getSceneView().getHeight();
+        float y = height * progress;
+        double degrees = Math.toDegrees(Math.acos((height - y) / height));
+
+        mSceneContainer.setAlpha(1f - progress);
+        mSceneContainer.setTranslationY(y);
+        mSceneContainer.setRotationX((float) (-degrees / 2f));
+    }
+
+    private void populateSwipeToDismiss(MotionEvent srcEvent) {
+        float y = srcEvent.getY() - mIconsContainer.getHeight();
+
+        MotionEvent dstEvent = MotionEvent.obtainNoHistory(srcEvent);
+        mVelocityTracker.addMovement(MotionEvent.obtainNoHistory(srcEvent));
+        dstEvent.recycle();
+
+        if (!isDismissible(mSelectedWidget)) {
+            return;
+        }
+
+        if (y < 0) {
+            if (mSceneContainer.getTranslationY() != 0) {
+                resetSceneContainerParams();
+            }
+            return;
+        }
+
+        float height = getSceneView().getHeight();
+        float progress = MathUtils.range(y / height, 0f, 1f);
+        populateSceneContainerDismissAnimation(progress);
+
+        if (DEBUG) Log.d(TAG, "dismiss_progress=" + progress + " height=" + height);
+    }
+
+    public void showHomeWidget() {
+        showHomeWidget(true);
+    }
+
+    public void showHomeWidget(boolean animate) {
+        Widget widget = isMediaWidgetHome()
+                ? mMediaWidget
+                : mClockWidget;
+        showWidget(widget, animate);
+    }
+
+
+    /**
+     * @see #showWidget(com.achep.acdisplay.ui.components.Widget, boolean)
+     * @see #getCurrentWidget()
+     */
+    protected void showWidget(@NonNull Widget widget) {
+        showWidget(widget, true);
+    }
+
+    /**
+     * @see #showWidget(com.achep.acdisplay.ui.components.Widget)
+     * @see #getCurrentWidget()
+     */
+    protected void showWidget(@NonNull Widget widget, boolean animate) {
+        LogUtils.v(TAG, "widget=" + widget, 3);
+
+        mHandler.removeMessages(MSG_SHOW_HOME_WIDGET);
+        mHasPinnedWidget = false;
+
+        View iconView;
+
+        if (mSelectedWidget != null) {
+            iconView = mSelectedWidget.getIconView();
+            if (iconView != null) {
+                iconView.setSelected(false);
+            }
+
+            mSelectedWidget.onViewDetached();
+        }
+
+        mSelectedWidget = widget;
+        resetSceneContainerParams();
+        animate &= !isPowerSaveMode();
+
+        SceneCompat scene = findSceneByWidget(mSelectedWidget);
+        if (scene == null) {
+            goScene(mSceneMainClock, animate);
+        } else if (mCurrentScene != scene) {
+            goScene(scene, animate);
+        } else if (animate) {
+            ViewGroup viewGroup = mSelectedWidget.getView();
+            if (viewGroup != null && isViewLaidOut(viewGroup)) {
+                // Automatically animate the content change.
+                TransitionManager.beginDelayedTransition(viewGroup, mTransitionJit);
+            }
+        }
+
+        mSelectedWidget.onViewAttached();
+        mBackground.dispatchSetBackground(
+                mSelectedWidget.getBackground(),
+                mSelectedWidget.getBackgroundMask());
+        updateStatusClockVisibility(!mSelectedWidget.hasClock() && getConfig().isFullScreen());
+
+        iconView = mSelectedWidget.getIconView();
+        if (iconView != null) {
+            iconView.setSelected(true);
+            iconView.performHapticFeedback(HapticFeedbackConstants.VIRTUAL_KEY);
+        }
+
+        if (!isResumed()) {
+            return;
+        }
+
+        // Start timeout on main or media widgets, and
+        // pause it otherwise.
+        if (widget.isHomeWidget()) {
+            mTimeout.resume();
+        } else {
+            mTimeout.setTimeoutDelayed(mTimeoutNormal, true);
+            mTimeout.pause();
+        }
+    }
+
+    /**
+     * @return Currently displayed widget, or {@code null} if main widget is displayed.
+     * @see #showWidget(com.achep.acdisplay.ui.components.Widget)
+     */
+    protected final Widget getCurrentWidget() {
+        return mSelectedWidget;
+    }
+
+    /**
+     * @return {@code true} if current widget equals to given one, {@code false} otherwise.
+     * @see #getCurrentWidget()
+     */
+    protected final boolean isCurrentWidget(Widget widget) {
+        return widget == mSelectedWidget;
+    }
+
+    /**
+     * @return {@code true} if widget is not {@code null} and
+     * {@link Widget#isDismissible() dismissible}, {@code false} otherwise.
+     */
+    public final boolean isDismissible(Widget widget) {
+        return widget != null && widget.isDismissible();
+    }
+
+    /**
+     * @return The view of the {@link #mCurrentScene current scene}.
+     */
+    private View getSceneView() {
+        return mCurrentScene.getView();
+    }
+
+    protected SceneCompat findSceneByWidget(Widget widget) {
+        if (widget == mMediaWidget) {
+            return mSceneMainMedia;
+        } else if (widget == mClockWidget) {
+            return mSceneMainClock;
+        } else if (widget.getView() != null) {
+            String className = widget.getClass().getName();
+            return mScenesMap.get(className);
+        }
+        return null;
+    }
+
+    private Widget findWidgetByIcon(View view) {
+        return mWidgetsMap.get(view);
+    }
+
+    /**
+     * Updates the visibility of status clock (appears above on top of the screen).
+     */
+    private void updateStatusClockVisibility(boolean visibleNow) {
+        if (mStatusClockTextView == null) {
+            return;
+        }
+
+        View view = mStatusClockTextView;
+        boolean visible = view.getVisibility() == View.VISIBLE;
+
+        if (visible == visibleNow) return;
+        if (!isPowerSaveMode()) {
+            final float[] values;
+            if (visibleNow) {
+                values = new float[]{
+                        0.0f, 1.0f,
+                        0.8f, 1.0f,
+                        0.8f, 1.0f,
+                };
+                view.setVisibility(View.VISIBLE);
+                view.animate().setListener(null);
+            } else {
+                values = new float[]{
+                        1.0f, 0.0f,
+                        1.0f, 0.8f,
+                        1.0f, 0.8f,
+                };
+                view.animate().setListener(new AnimatorListenerAdapter() {
+                    @Override
+                    public void onAnimationEnd(Animator animation) {
+                        super.onAnimationEnd(animation);
+                        mStatusClockTextView.setVisibility(View.GONE);
+                    }
+                });
+            }
+
+            view.setAlpha(values[0]);
+            view.setScaleX(values[2]);
+            view.setScaleY(values[4]);
+            view.animate()
+                    .alpha(values[1])
+                    .scaleX(values[3])
+                    .scaleY(values[5]);
+        } else {
+            ViewUtils.setVisible(view, visibleNow);
+        }
+    }
+
+    //-- WIDGETS MANAGEMENT ---------------------------------------------------
+
+    /**
+     * Called when widget is going to be dismissed.
+     */
+    protected void onWidgetDismiss(@NonNull Widget widget) {
+        boolean preLock = false;
+
+        if (isNotDemo()
+                && getConfig().isScreenOffAfterLastNotify()
+                && widget instanceof NotifyWidget) {
+            preLock = NotificationPresenter.getInstance().size() == 1;
+        }
+
+        widget.onDismiss();
+
+        if (preLock) {
+            // Check is the latest notification is gone.
+            boolean lock = NotificationPresenter.getInstance().size() == 0;
+            if (lock) {
+                mActivityAcd.lock();
+            }
+        }
+    }
+
+    //-- SCENES MANAGEMENT ----------------------------------------------------
+
+    /**
+     * Changes current scene to given one.
+     *
+     * @see #showWidget(com.achep.acdisplay.ui.components.Widget)
+     */
+    @SuppressLint("NewApi")
+    protected final void goScene(@NonNull SceneCompat sceneCompat, boolean animate) {
+        if (mCurrentScene == sceneCompat) {
+            return;
+        }
+
+        mCurrentScene = sceneCompat;
+        final Scene scene = sceneCompat.getScene();
+        if (animate && !isPowerSaveMode() && isViewLaidOut(mSceneContainer)) {
+            try {
+                // This must be a synchronization problem with Android's Scene or TransitionManager,
+                // but those were declared as final classes, so I have no idea how to fix it.
+                TransitionManager.go(scene, mTransitionSwitchScene);
+            } catch (IllegalStateException e) {
+                Log.w(TAG, "TransitionManager has failed switching scenes!");
+
+                ViewGroup viewGroup = (ViewGroup) getSceneView().getParent();
+                viewGroup.removeView(getSceneView());
+
+                try {
+                    // Reset internal scene's tag to make it work again.
+                    int id = Resources.getSystem().getIdentifier("current_scene", "id", "android");
+                    Method method = View.class.getMethod("setTagInternal", int.class, Object.class);
+                    method.setAccessible(true);
+                    method.invoke(viewGroup, id, null);
+                } catch (NoSuchMethodException
+                        | IllegalAccessException
+                        | InvocationTargetException e2) {
+                    throw new RuntimeException("An attempt to fix the TransitionManager has failed.");
+                }
+
+                TransitionManager.go(scene, mTransitionSwitchScene);
+            }
+        } else scene.enter();
+    }
+
+    //-- DYNAMIC BACKGROUND ---------------------------------------------------
+
+    /**
+     * Updates current background if given {@link com.achep.acdisplay.ui.components.Widget}
+     * is currently selected.
+     *
+     * @param widget client, may not be {@code null}.
+     */
+    @Override
+    public void requestBackgroundUpdate(@NonNull Widget widget) {
+        if (isCurrentWidget(widget)) {
+            final int mask = widget.getBackgroundMask();
+            mBackground.dispatchSetBackground(widget.getBackground(), mask);
+        }
+    }
+
+    //-- MEDIA ----------------------------------------------------------------
+
+    /**
+     * Gets the controller which should be receiving media events
+     * while this fragment is in the foreground. The controller supports
+     * all platforms starting from Android 4.3 and does nothing on older
+     * versions.
+     *
+     * @return The controller which should receive events.
+     */
+    @NonNull
+    public MediaController2 getMediaController2() {
+        return mMediaController;
+    }
+
+    @Override
+    public void onMetadataChanged(@NonNull Metadata metadata) {
+        // This event is handled by
+        // the media widget.
+    }
+
+    @Override
+    public void onPlaybackStateChanged(int state) {
+        switch (state) {
+            case PlaybackStateCompat.STATE_NONE:
+                mHandler.removeMessages(MSG_HIDE_MEDIA_WIDGET);
+                disableMediaWidget();
+                break;
+            case PlaybackStateCompat.STATE_PLAYING:
+                mHandler.removeMessages(MSG_HIDE_MEDIA_WIDGET);
+                enableMediaWidget();
+                break;
+            default:
+                mHandler.sendEmptyMessageDelayed(MSG_HIDE_MEDIA_WIDGET, 6000);
+                break;
+        }
+    }
+
+    private void enableMediaWidget() {
+        mShowMediaWidget = true;
+
+        // Update home widget.
+        if (mSelectedWidget.isHomeWidget()) {
+            showHomeWidget();
+        }
+    }
+
+    private void disableMediaWidget() {
+        mShowMediaWidget = false;
+
+        // Reset home widget.
+        if (isCurrentWidget(mMediaWidget)) {
+            showHomeWidget();
+        }
+    }
+
+    /**
+     * Defines if media widget replaces home widget
+     * or no.
+     *
+     * @return {@code true} if media widget replaces the home widget,
+     * {@code false} otherwise.
+     */
+    private boolean isMediaWidgetHome() {
+        return mShowMediaWidget;
+    }
+
+    //-- LOLLIPOP -------------------------------------------------------------
+
+    /**
+     * Returns {@code true} if the device is currently in power save mode.
+     * When in this mode, applications should reduce their functionality
+     * in order to conserve battery as much as possible.
+     *
+     * @return {@code true} if the device is currently in power save mode, {@code false} otherwise.
+     * @see com.achep.base.utils.power.PowerSaveDetector
+     */
+    public boolean isPowerSaveMode() {
+        return mActivity.isPowerSaveMode();
+    }
+
+    /**
+     * @return {@code true} if this fragment is attached to {@link com.achep.acdisplay.ui.activities.AcDisplayActivity} and
+     * matches parent layout, {@code false} if this is only preview.
+     */
+    public boolean isNotDemo() {
+        return getActivity() instanceof AcDisplayActivity;
+    }
+
+    //-- NOTIFICATION HANDLING ------------------------------------------------
+
+    @Override
+    public void onNotificationListChanged(@NonNull NotificationPresenter np,
+                                          OpenNotification osbn,
+                                          int event, boolean last) {
+        if (DEBUG) Log.d(TAG, "Handling notification list changed event: "
+                + NotificationPresenter.getEventName(event));
+        NotifyWidget widgetPrev = null;
+
+        if (event == NotificationPresenter.EVENT_REMOVED
+                || event == NotificationPresenter.EVENT_CHANGED) {
+
+            // Find the widget of this or previous notification,
+            // so we can manage it.
+            for (Widget item : mWidgetsMap.values()) {
+                if (item instanceof NotifyWidget) {
+                    // Check if notification has the same key.
+                    NotifyWidget nw = (NotifyWidget) item;
+                    if (nw.hasIdenticalIds(osbn)) {
+                        widgetPrev = nw;
+                        break;
+                    }
+                }
+            }
+        }
+
+        switch (event) { // don't update on spam-change.
+            case NotificationPresenter.EVENT_CHANGED:
+                if (widgetPrev != null) {
+                    if (DEBUG) Log.d(TAG, "[Event] Updating notification widget...");
+                    ViewGroup viewGroup = widgetPrev.getView();
+                    if (!isPowerSaveMode() && isViewLaidOut(viewGroup)) {
+                        TransitionManager.beginDelayedTransition(viewGroup, mTransitionJit);
+                    }
+                    widgetPrev.setNotification(osbn);
+                    break;
+                }
+            case NotificationPresenter.EVENT_POSTED:
+                if (DEBUG) Log.d(TAG, "[Event] Adding new notification widget...");
+                event = NotificationPresenter.EVENT_POSTED;
+
+                // Create new widget and inflate its
+                // icon view.
+                LayoutInflater inflater = getActivity().getLayoutInflater();
+                NotifyWidget nw = new NotifyWidget(this, this);
+                View iconView = nw.createIconView(inflater, mIconsContainer);
+                nw.onStart();
+
+                // Check if widget's scene is available.
+                String name = nw.getClass().getName();
+                SceneCompat scene = mScenesMap.get(name);
+
+                // Setup widget & view.
+                ViewUtils.setSize(iconView, getConfig().getIconSizePx());
+                nw.setNotification(osbn);
+                if (scene != null) {
+                    // Initialize widget with previously created
+                    // scene. This is possible by design.
+                    nw.createView(null, null, scene.getView());
+                } else {
+                    // Create scene view and put to map of scenes.
+                    ViewGroup sceneView = nw.createView(inflater, mSceneContainer, null);
+                    if (sceneView != null) {
+                        scene = new SceneCompat(mSceneContainer, sceneView);
+                        mScenesMap.put(name, scene);
+                    }
+                }
+
+                mWidgetsMap.put(iconView, nw);
+                mIconsContainer.addView(iconView);
+                break;
+            case NotificationPresenter.EVENT_REMOVED:
+                if (widgetPrev != null) {
+                    if (DEBUG) Log.d(TAG, "[Event] Removing notification widget...");
+
+                    iconView = widgetPrev.getIconView();
+                    clearWidget(iconView);
+                    mWidgetsMap.remove(iconView);
+                    mIconsContainer.removeView(iconView);
+
+                    // Remove widget's scene if it's not needed anymore.
+                    boolean removeScene = true;
+                    name = widgetPrev.getClass().getName();
+                    for (Widget item : mWidgetsMap.values()) {
+                        if (name.equals(item.getClass().getName())) {
+                            removeScene = false;
+                            break;
+                        }
+                    }
+                    if (removeScene) {
+                        mScenesMap.remove(name);
+                    }
+
+                    // Don't let removed widget to be shown.
+                    if (mSelectedWidget == widgetPrev) {
+                        showHomeWidget(); // Un-pin
+                        // TODO: Maybe simulate touch to update selected widget?
+                    }
+                }
+                break;
+            case NotificationPresenter.EVENT_BATH:
+                if (DEBUG) Log.d(TAG, "[Event] Rebuilding notifications...");
+                rebuildNotifications();
+                break;
+        }
+
+        if (event == NotificationPresenter.EVENT_POSTED
+                || event == NotificationPresenter.EVENT_REMOVED) {
+            if (last) updateDividerVisibility();
+            // #EVENT_BATH causes #rebuildNotifications() to be run,
+            // which calls #updateDividerVisibility() by itself.
+        }
+    }
+
+    private void rebuildNotifications() {
+        final long now = SystemClock.elapsedRealtime();
+
+        ViewGroup container = mIconsContainer;
+        if (!isPowerSaveMode() && isViewLaidOut(container)) {
+            TransitionManager.beginDelayedTransition(container, mTransitionJit);
+        }
+
+        final int childCount = container.getChildCount();
+
+        // Count the number of non-notification fragments
+        // such as unlock or music controls fragments.
+        int start = 0;
+        for (int i = 0; i < childCount; i++) {
+            View child = container.getChildAt(i);
+            Widget fragment = findWidgetByIcon(child);
+            if (fragment instanceof NotifyWidget) {
+                // Those fragments are placed at the begin of layout
+                // so no reason to continue searching.
+                break;
+            } else {
+                start++;
+            }
+        }
+
+        final ArrayList<OpenNotification> list = NotificationPresenter.getInstance().getList();
+        final int notifyCount = list.size();
+
+        final boolean[] notifyUsed = new boolean[notifyCount];
+        final boolean[] childUsed = new boolean[childCount];
+
+        for (int i = start; i < childCount; i++) {
+            View child = container.getChildAt(i);
+            NotifyWidget widget = (NotifyWidget) findWidgetByIcon(child);
+            OpenNotification target = widget.getNotification();
+
+            for (int j = 0; j < notifyCount; j++) {
+                OpenNotification n = list.get(j);
+                if (NotificationUtils.hasIdenticalIds(target, n)) {
+
+                    notifyUsed[j] = true;
+                    childUsed[i] = true;
+
+                    if (target != n) {
+                        widget.setNotification(n);
+                    }
+                    break;
+                }
+            }
+        }
+
+        // Re-use free views and remove redundant views.
+        boolean removeAllAfter = false;
+        for (int a = start, j = 0, offset = 0; a < childCount; a++) {
+            if (childUsed[a]) continue;
+            final int i = a + offset;
+
+            View child = container.getChildAt(i);
+            removing_all_next_views:
+            {
+                if (!removeAllAfter) {
+                    for (; j < notifyCount; j++) {
+                        if (notifyUsed[j]) continue;
+
+                        assert child != null;
+                        notifyUsed[j] = true;
+
+                        NotifyWidget nw = (NotifyWidget) findWidgetByIcon(child);
+                        nw.setNotification(list.get(j));
+                        break removing_all_next_views;
+                    }
+                }
+                removeAllAfter = true;
+                clearWidget(child);
+
+                // Remove widget's icon.
+                container.removeViewAt(i);
+                offset--;
+            }
+        }
+
+        assert getActivity() != null;
+        LayoutInflater inflater = getActivity().getLayoutInflater();
+
+        final int iconSize = getConfig().getIconSizePx();
+        for (int i = 0; i < notifyCount; i++) {
+            if (notifyUsed[i]) continue;
+
+            NotifyWidget nw = new NotifyWidget(this, this);
+
+            View iconView = nw.createIconView(inflater, container);
+            ViewUtils.setSize(iconView, iconSize);
+            container.addView(iconView);
+
+            nw.onStart();
+            nw.setNotification(list.get(i));
+            mWidgetsMap.put(iconView, nw);
+        }
+
+        // /////////////////////
+        // ~~ UPDATE HASH MAP ~~
+        // /////////////////////
+
+        HashMap<String, SceneCompat> map = (HashMap<String, SceneCompat>) mScenesMap.clone();
+
+        mScenesMap.clear();
+        for (Widget fragment : mWidgetsMap.values()) {
+            String type = fragment.getClass().getName();
+            SceneCompat scene = map.get(type);
+            if (scene != null) {
+                fragment.createView(null, null, scene.getView());
+            } else {
+                ViewGroup sceneView = fragment.createView(inflater, mSceneContainer, null);
+                if (sceneView != null) {
+                    scene = new SceneCompat(mSceneContainer, sceneView);
+                    map.put(type, scene);
+                }
+            }
+            if (scene != null) {
+                mScenesMap.put(type, scene);
+            }
+        }
+
+        if (DEBUG) {
+            long delta = SystemClock.elapsedRealtime() - now;
+            Log.d(TAG, "Fragment list updated in " + delta + "ms.");
+        }
+
+        updateDividerVisibility();
+    }
+
+    private void clearWidget(@NonNull View iconView) {
+        NotifyWidget nw = (NotifyWidget) findWidgetByIcon(iconView);
+        nw.onStop();
+        mWidgetsMap.remove(iconView);
+    }
+
+    /**
+     * Updates the visibility of divider between
+     * the scene and icons.
+     */
+    @SuppressLint("NewApi")
+    private void updateDividerVisibility() {
+        final View view = mDividerView;
+
+        final boolean visible = view.getVisibility() == View.VISIBLE;
+        final boolean visibleNow = mIconsContainer.getChildCount() > 0;
+
+        if (!isPowerSaveMode() && isResumed()) {
+            int visibleInt = MathUtils.bool(visible);
+            int visibleNowInt = MathUtils.bool(visibleNow);
+            float[] values = {1.0f, 0.1f, 1.0f, 0.5f};
+
+            ViewUtils.setVisible(view, true);
+            view.setScaleX(values[1 - visibleInt]);
+            view.setAlpha(values[3 - visibleInt]);
+            view.animate()
+                    .scaleX(values[1 - visibleNowInt])
+                    .alpha(values[3 - visibleNowInt])
+                    .setInterpolator(new AccelerateInterpolator())
+                    .setListener(new AnimatorListenerAdapter() {
+                        @Override
+                        public void onAnimationEnd(Animator animation) {
+                            super.onAnimationEnd(animation);
+                            ViewUtils.setVisible(view, visibleNow, View.INVISIBLE);
+                            view.setAlpha(1);
+                            view.setScaleX(1);
+                        }
+                    });
+        } else {
+            ViewUtils.setVisible(view, visibleNow, View.INVISIBLE);
+        }
+    }
+
+    //-- OTHER CLASSES --------------------------------------------------------
+
+    /**
+     * Transfers the touch between views, and implements double-tap-to-lock.
+     *
+     * @author Artem Chepurnoy
+     */
+    private static class TouchForwarder implements View.OnTouchListener {
+
+        private final PocketFragment.OnSleepRequestListener mListener;
+        private final CircleView mCircleView;
+        private final GestureDetector mGestureDetector;
+
+        /**
+         * {@code true} if redirecting all touches to the {@link #mCircleView},
+         * {@code false} otherwise.
+         */
+        private boolean mCircling;
+
+        public TouchForwarder(@NonNull Context context,
+                              @NonNull CircleView circleView,
+                              @NonNull PocketFragment.OnSleepRequestListener listener) {
+            mListener = listener;
+            mCircleView = circleView;
+            mGestureDetector = new GestureDetector(context, new GestureListener());
+        }
+
+        @Override
+        public boolean onTouch(View v, MotionEvent event) {
+            mGestureDetector.onTouchEvent(event);
+
+            switch (event.getAction()) {
+                case MotionEvent.ACTION_DOWN:
+                    float x = event.getX();
+                    float y = event.getY();
+                    mCircling = ViewUtils.pointInView(v, x, y, -20);
+                default:
+                    if (mCircling) mCircleView.onTouchEvent2(event);
+            }
+
+            return mCircling;
+        }
+
+        /**
+         * Implements double-tap gesture.
+         *
+         * @author Artem Chepurnoy
+         */
+        class GestureListener extends GestureDetector.SimpleOnGestureListener {
+
+            @Override
+            public boolean onSingleTapUp(MotionEvent e) {
+                return false;
+            }
+
+            @Override
+            public boolean onDoubleTap(MotionEvent e) {
+                return mListener.onSleepRequest();
+            }
+
+        }
+
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/blacklist/fragments/BlacklistAppFragment.java b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/BlacklistAppFragment.java
similarity index 98%
rename from project/app/src/main/java/com/achep/acdisplay/blacklist/fragments/BlacklistAppFragment.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/fragments/BlacklistAppFragment.java
index ada5cfdd..9407bae2 100644
--- a/project/app/src/main/java/com/achep/acdisplay/blacklist/fragments/BlacklistAppFragment.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/BlacklistAppFragment.java
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.blacklist.fragments;
+package com.achep.acdisplay.ui.fragments;
 
 import android.app.Activity;
 import android.app.Fragment;
@@ -34,11 +34,11 @@ import android.widget.TextView;
 
 import com.achep.acdisplay.R;
 import com.achep.acdisplay.blacklist.Blacklist;
-import com.achep.acdisplay.blacklist.options.NonClearableOption;
 import com.achep.acdisplay.blacklist.options.HideOption;
+import com.achep.acdisplay.blacklist.options.NonClearableOption;
 import com.achep.acdisplay.blacklist.options.Option;
 import com.achep.acdisplay.blacklist.options.RestrictOption;
-import com.achep.acdisplay.utils.ViewUtils;
+import com.achep.base.utils.ViewUtils;
 
 /**
  * Created by Artem on 09.02.14.
@@ -83,7 +83,7 @@ public class BlacklistAppFragment extends Fragment {
         Activity activity = getActivity();
         Blacklist blacklist = Blacklist.getInstance();
         mPackageName = extractPackageName(getArguments(), savedInstanceState);
-        mOptions = new Option[] {
+        mOptions = new Option[]{
                 new HideOption(activity, new CheckBox(activity), blacklist, mPackageName),
                 new RestrictOption(activity, new CheckBox(activity), blacklist, mPackageName),
                 new NonClearableOption(activity, new CheckBox(activity), blacklist, mPackageName)
diff --git a/project/app/src/main/java/com/achep/acdisplay/fragments/PocketFragment.java b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/PocketFragment.java
similarity index 98%
rename from project/app/src/main/java/com/achep/acdisplay/fragments/PocketFragment.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/fragments/PocketFragment.java
index 6b5d5ef1..aa01de1e 100644
--- a/project/app/src/main/java/com/achep/acdisplay/fragments/PocketFragment.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/PocketFragment.java
@@ -16,8 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.fragments;
+package com.achep.acdisplay.ui.fragments;
 
 import android.app.Activity;
 import android.app.Fragment;
@@ -83,7 +82,7 @@ public class PocketFragment extends Fragment implements SensorEventListener {
          * Called when parent activity may go to sleep because we're
          * in pocket at this moment.
          */
-        void onSleepRequest();
+        boolean onSleepRequest();
 
     }
 
diff --git a/project/app/src/main/java/com/achep/acdisplay/ui/fragments/dialogs/SetupPermissionsDialog.java b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/dialogs/SetupPermissionsDialog.java
new file mode 100644
index 00000000..f9a16eb9
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/dialogs/SetupPermissionsDialog.java
@@ -0,0 +1,336 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.ui.fragments.dialogs;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.app.admin.DevicePolicyManager;
+import android.content.ActivityNotFoundException;
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.graphics.drawable.Drawable;
+import android.os.Bundle;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.v4.app.DialogFragment;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.ArrayAdapter;
+import android.widget.ImageView;
+import android.widget.ListView;
+import android.widget.TextView;
+
+import com.achep.acdisplay.Config;
+import com.achep.acdisplay.R;
+import com.achep.acdisplay.receiver.AdminReceiver;
+import com.achep.acdisplay.utils.AccessUtils;
+import com.achep.base.Device;
+import com.achep.base.ui.DialogBuilder;
+import com.achep.base.utils.ToastUtils;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.List;
+
+/**
+ * Dialog fragment that shows some info about this application.
+ *
+ * @author Artem Chepurnoy
+ */
+public class SetupPermissionsDialog extends DialogFragment {
+
+    private static final String TAG = "AccessDialog";
+
+    private ListView mListView;
+    private Adapter mAdapter;
+    private Item[] mItems;
+
+    private abstract static class Item {
+
+        public int icon;
+        public String title;
+        public String summary;
+        public Runnable runnable;
+
+        public Item(@DrawableRes int icon,
+                    String title, String summary,
+                    @NonNull Runnable runnable) {
+            this.icon = icon;
+            this.title = title;
+            this.summary = summary;
+            this.runnable = runnable;
+        }
+
+        public abstract boolean isAllowed();
+
+    }
+
+    private static class DeviceAdminItem extends Item {
+
+        private Context mContext;
+
+        public DeviceAdminItem(@DrawableRes int icon,
+                               String title, String summary,
+                               @NonNull Runnable runnable,
+                               Context context) {
+            super(icon, title, summary, runnable);
+            mContext = context;
+        }
+
+        @Override
+        public boolean isAllowed() {
+            return AccessUtils.isDeviceAdminAccessGranted(mContext);
+        }
+
+    }
+
+    private static class NotificationListenerItem extends Item {
+
+        private Context mContext;
+
+        public NotificationListenerItem(@DrawableRes int icon,
+                                        String title, String summary,
+                                        @NonNull Runnable runnable,
+                                        Context context) {
+            super(icon, title, summary, runnable);
+            mContext = context;
+        }
+
+        @Override
+        public boolean isAllowed() {
+            return AccessUtils.isNotificationAccessGranted(mContext);
+        }
+
+    }
+
+    private Item[] buildItems() {
+        Context context = getActivity();
+        ArrayList<Item> items = new ArrayList<>();
+        items.add(new DeviceAdminItem(R.drawable.stat_lock,
+                getString(R.string.permissions_device_admin),
+                getString(R.string.permissions_device_admin_description),
+                new Runnable() {
+
+                    @Override
+                    public void run() {
+                        Context context = getActivity();
+                        ComponentName admin = new ComponentName(context, AdminReceiver.class);
+                        Intent intent = new Intent()
+                                .setAction(DevicePolicyManager.ACTION_ADD_DEVICE_ADMIN)
+                                .putExtra(DevicePolicyManager.EXTRA_DEVICE_ADMIN, admin);
+
+                        try {
+                            startActivity(intent);
+
+                            // TODO: Fix 'Device admin request intent acts strange on Lollipop'
+                            if (Device.hasLollipopApi()) {
+                                // Yes, they broke the intent somehow.
+                                String message = getString(
+                                        R.string.permissions_device_admin_troubleshooting,
+                                        getString(R.string.permissions_device_admin_grant_manually));
+                                ToastUtils.showLong(context, message);
+                            }
+                        } catch (ActivityNotFoundException e) {
+                            ToastUtils.showLong(context, R.string.permissions_device_admin_grant_manually);
+                            Log.e(TAG, "Device admins activity not found.");
+                        }
+                    }
+
+                }, context));
+        items.add(new NotificationListenerItem(R.drawable.stat_notify,
+                getString(R.string.permissions_notifications),
+                getString(R.string.permissions_notifications_description),
+                new Runnable() {
+
+                    @Override
+                    public void run() {
+                        if (Device.hasJellyBeanMR2Api()) {
+                            launchNotificationSettings();
+                        } else {
+                            launchAccessibilitySettings();
+                        }
+                    }
+
+                    private void launchNotificationSettings() {
+                        Intent intent = new Intent("android.settings.ACTION_NOTIFICATION_LISTENER_SETTINGS");
+                        try {
+                            startActivity(intent);
+                        } catch (ActivityNotFoundException e) {
+                            ToastUtils.showLong(getActivity(), R.string.permissions_notifications_grant_manually);
+                            Log.e(TAG, "Notification listeners activity not found.");
+                        }
+                    }
+
+                    private void launchAccessibilitySettings() {
+                        Intent intent = new Intent(android.provider.Settings.ACTION_ACCESSIBILITY_SETTINGS);
+                        try {
+                            startActivity(intent);
+                        } catch (ActivityNotFoundException e) {
+                            String message = "Accessibility settings not found!";
+                            ToastUtils.showLong(getActivity(), message);
+                            Log.wtf(TAG, message);
+                        }
+                    }
+
+                }, context));
+
+        return items.toArray(new Item[items.size()]);
+    }
+
+    @NonNull
+    @Override
+    public Dialog onCreateDialog(Bundle savedInstanceState) {
+        Context context = getActivity();
+        assert context != null;
+
+        View view = new DialogBuilder(context)
+                .setTitle(R.string.permissions_dialog_title)
+                .setView(R.layout.fragment_access)
+                .createSkeletonView();
+
+        // Make title more red
+        TextView title = (TextView) view.findViewById(R.id.title);
+        title.setTextColor(title.getCurrentTextColor() & 0xFFFF2020 | 0xFF << 16);
+
+        mListView = (ListView) view.findViewById(R.id.list);
+        mAdapter = new Adapter(context, new ArrayList<Item>());
+        mListView.setAdapter(mAdapter);
+        mListView.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+            @Override
+            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
+                Adapter adapter = (Adapter) parent.getAdapter();
+                Item item = adapter.getItem(position);
+                item.runnable.run();
+            }
+        });
+
+        return new AlertDialog.Builder(context)
+                .setView(view)
+                .setNeutralButton(R.string.later, null)
+                .create();
+    }
+
+    @Override
+    public void onAttach(Activity activity) {
+        super.onAttach(activity);
+        mItems = buildItems();
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+
+        List<Item> data = mAdapter.mDataset;
+        data.clear();
+        for (Item item : mItems) {
+            if (!item.isAllowed()) {
+                data.add(item);
+            }
+        }
+        if (data.size() == 0) {
+            Config.getInstance().setEnabled(getActivity(), true, null);
+            dismiss();
+        }
+        mAdapter.notifyDataSetChanged();
+    }
+
+    public static class Adapter extends ArrayAdapter<Item> {
+
+        private final Context mContext;
+        private final List<Item> mDataset;
+        private final LayoutInflater mInflater;
+        private final HashMap<Integer, WeakReference<Drawable>> mDrawableCache;
+
+        static class ViewHolder {
+
+            ImageView icon;
+            TextView title;
+            TextView summary;
+
+            public ViewHolder(View itemView) {
+                this.icon = (ImageView) itemView.findViewById(R.id.icon);
+                this.title = (TextView) itemView.findViewById(R.id.title);
+                this.summary = (TextView) itemView.findViewById(R.id.summary);
+            }
+
+        }
+
+        public Adapter(Context context, List<Item> items) {
+            super(context, 0);
+            mContext = context;
+            mDataset = items;
+            mInflater = LayoutInflater.from(getContext());
+            mDrawableCache = new HashMap<>(Math.min(getCount(), 10));
+        }
+
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+            final Item item = getItem(position);
+            final ViewHolder holder;
+            final View view;
+
+            if (convertView == null) {
+                view = mInflater.inflate(R.layout.item_blah, parent, false);
+                assert view != null;
+                holder = new ViewHolder(view);
+
+                int padding = mContext.getResources().getDimensionPixelSize(R.dimen.activity_horizontal_margin);
+                view.setPadding(padding, view.getPaddingTop(), padding, view.getPaddingBottom());
+
+                view.setTag(holder);
+            } else {
+                view = convertView;
+                holder = (ViewHolder) view.getTag();
+            }
+
+            holder.title.setText(item.title);
+            holder.summary.setText(item.summary);
+
+            // Cache drawables for smoother scrolling.
+            Drawable drawable;
+            WeakReference<Drawable> drawableLink = mDrawableCache.get(item.icon);
+            if (drawableLink == null || (drawable = drawableLink.get()) == null) {
+                holder.icon.setImageResource(item.icon);
+                mDrawableCache.put(item.icon, new WeakReference<>(holder.icon.getDrawable()));
+            } else {
+                holder.icon.setImageDrawable(drawable);
+            }
+
+            return view;
+        }
+
+        @Override
+        public int getCount() {
+            return mDataset.size();
+        }
+
+        @Override
+        public Item getItem(int position) {
+            return mDataset.get(position);
+        }
+
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/ui/fragments/dialogs/WelcomeDialog.java b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/dialogs/WelcomeDialog.java
new file mode 100644
index 00000000..6debbcaf
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/dialogs/WelcomeDialog.java
@@ -0,0 +1,58 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.ui.fragments.dialogs;
+
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.Context;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.text.Html;
+import android.view.View;
+
+import com.achep.acdisplay.R;
+import com.achep.base.ui.DialogBuilder;
+import com.achep.base.ui.fragments.dialogs.DialogFragment;
+
+/**
+ * Created by Artem Chepurnoy on 22.10.2014.
+ */
+public class WelcomeDialog extends DialogFragment {
+
+    @NonNull
+    @Override
+    public Dialog onCreateDialog(Bundle savedInstanceState) {
+        Context context = getActivity();
+        assert context != null;
+
+        CharSequence message = Html.fromHtml(getString(R.string.cry_dialog_message));
+
+        View view = new DialogBuilder(context)
+                .setIcon(R.drawable.ic_action_about_white)
+                .setTitle(R.string.cry_dialog_title)
+                .setMessage(message)
+                .createView();
+
+        return new AlertDialog.Builder(context)
+                .setView(view)
+                .setNegativeButton(R.string.close, null)
+                .create();
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/settings/ActiveModeSettings.java b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/settings/ActiveModeSettings.java
similarity index 58%
rename from project/app/src/main/java/com/achep/acdisplay/settings/ActiveModeSettings.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/fragments/settings/ActiveModeSettings.java
index 16d35ced..b8d303cb 100644
--- a/project/app/src/main/java/com/achep/acdisplay/settings/ActiveModeSettings.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/settings/ActiveModeSettings.java
@@ -16,48 +16,30 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.settings;
+package com.achep.acdisplay.ui.fragments.settings;
 
-import android.app.ActionBar;
-import android.app.Activity;
 import android.os.Bundle;
-import android.widget.Switch;
 
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.R;
+import com.achep.base.ui.fragments.PreferenceFragment;
 
 /**
  * Created by Artem on 09.02.14.
  */
 public class ActiveModeSettings extends PreferenceFragment {
 
-    private Enabler mActiveModeEnabler;
+    @Override
+    public Config getConfig() {
+        return Config.getInstance();
+    }
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        addPreferencesFromResource(R.xml.active_settings);
+        requestMasterSwitch(Config.KEY_ACTIVE_MODE);
+        addPreferencesFromResource(R.xml.settings_active_fragment);
         syncPreference(Config.KEY_ACTIVE_MODE_WITHOUT_NOTIFICATIONS);
-
-        Activity activity = getActivity();
-        ActionBar actionBar = activity.getActionBar();
-        assert actionBar != null;
-
-        actionBar.setDisplayShowCustomEnabled(true);
-        actionBar.setCustomView(R.layout.layout_ab_switch);
-        Switch switch_ = (Switch) actionBar.getCustomView().findViewById(R.id.switch_);
-        mActiveModeEnabler = new Enabler(activity, switch_, Config.KEY_ACTIVE_MODE);
     }
 
-    @Override
-    public void onResume() {
-        super.onResume();
-        mActiveModeEnabler.resume();
-    }
-
-    @Override
-    public void onPause() {
-        super.onPause();
-        mActiveModeEnabler.pause();
-    }
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/settings/DevSettings.java b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/settings/DevSettings.java
similarity index 84%
rename from project/app/src/main/java/com/achep/acdisplay/settings/DevSettings.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/fragments/settings/DevSettings.java
index 3fc5c058..188e0c64 100644
--- a/project/app/src/main/java/com/achep/acdisplay/settings/DevSettings.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/settings/DevSettings.java
@@ -16,14 +16,15 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.settings;
+package com.achep.acdisplay.ui.fragments.settings;
 
 import android.os.Bundle;
 import android.preference.Preference;
 
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.R;
+import com.achep.base.content.ConfigBase;
+import com.achep.base.ui.fragments.PreferenceFragment;
 
 /**
  * Development settings fragment.
@@ -35,10 +36,15 @@ public class DevSettings extends PreferenceFragment implements
 
     private Preference mSensorsDumpSendPreference;
 
+    @Override
+    public ConfigBase getConfig() {
+        return Config.getInstance();
+    }
+
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        addPreferencesFromResource(R.xml.dev_settings);
+        addPreferencesFromResource(R.xml.settings_dev_fragment);
         syncPreference(Config.KEY_DEV_SENSORS_DUMP);
 
         mSensorsDumpSendPreference = findPreference("dev_sensors_dump_send");
@@ -53,4 +59,5 @@ public class DevSettings extends PreferenceFragment implements
             return false;
         return true;
     }
+
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/ui/fragments/settings/InterfaceSettings.java b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/settings/InterfaceSettings.java
new file mode 100644
index 00000000..75a035dc
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/settings/InterfaceSettings.java
@@ -0,0 +1,173 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.ui.fragments.settings;
+
+import android.os.Bundle;
+import android.preference.MultiSelectListPreference;
+import android.preference.Preference;
+import android.support.annotation.NonNull;
+
+import com.achep.acdisplay.Config;
+import com.achep.acdisplay.R;
+import com.achep.base.content.ConfigBase;
+import com.achep.base.ui.fragments.PreferenceFragment;
+import com.achep.base.utils.Operator;
+
+import java.util.Collections;
+import java.util.HashSet;
+import java.util.Set;
+
+/**
+ * Interface settings fragment.
+ *
+ * @author Artem Chepurnoy
+ */
+public class InterfaceSettings extends PreferenceFragment implements
+        ConfigBase.OnConfigChangedListener {
+
+    private final ListPreferenceSetter mListPreferenceDynamicBackgroundSetter =
+            new ListPreferenceSetter() {
+
+                @Override
+                public void updateSummary(@NonNull Preference preference,
+                                          @NonNull Config.Option option,
+                                          @NonNull Object value) {
+                    MultiSelectListPreference mslp = (MultiSelectListPreference) preference;
+                    int mode = (int) value;
+
+                    CharSequence summary;
+                    if (mode != 0) {
+                        CharSequence[] entries = mslp.getEntries();
+                        CharSequence[] values = mslp.getEntryValues();
+
+                        String divider = getString(R.string.settings_multi_list_divider);
+                        StringBuilder sb = new StringBuilder();
+                        boolean empty = true;
+
+                        assert entries != null;
+                        assert values != null;
+
+                        // Append selected items.
+                        for (int i = 0; i < values.length; i++) {
+                            int a = Integer.parseInt(values[i].toString());
+                            if (Operator.bitAnd(mode, a)) {
+                                if (!empty) {
+                                    sb.append(divider);
+                                }
+                                sb.append(entries[i]);
+                                empty = false;
+                            }
+                        }
+
+                        String itemsText = sb.toString().toLowerCase();
+                        summary = getString(R.string.settings_dynamic_background_summary, itemsText);
+                    } else {
+                        summary = getString(R.string.settings_dynamic_background_disabled);
+                    }
+
+                    mslp.setSummary(summary);
+                }
+
+                @Override
+                public void setValue(@NonNull Preference preference,
+                                     @NonNull Config.Option option,
+                                     @NonNull Object value) {
+                    int mode = (int) value;
+                    String[] values = new String[Integer.bitCount(mode)];
+                    for (int i = 1, j = 0; j < values.length; i <<= 1) {
+                        if (Operator.bitAnd(mode, i)) {
+                            values[j++] = Integer.toString(i);
+                        }
+                    }
+
+                    Set<String> valuesSet = new HashSet<>();
+                    Collections.addAll(valuesSet, values);
+
+                    MultiSelectListPreference mslp = (MultiSelectListPreference) preference;
+                    mslp.setValues(valuesSet);
+                }
+
+                @NonNull
+                @Override
+                public Object getValue(@NonNull Object value) {
+                    int mode = 0;
+
+                    Set<String> values = (Set<String>) value;
+                    for (String v : values) {
+                        mode |= Integer.parseInt(v);
+                    }
+
+                    return mode;
+                }
+
+            };
+
+    private Preference mIconSizePreference;
+
+    @Override
+    public Config getConfig() {
+        return Config.getInstance();
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        addPreferencesFromResource(R.xml.settings_interface_fragment);
+        syncPreference(Config.KEY_UI_DYNAMIC_BACKGROUND_MODE, mListPreferenceDynamicBackgroundSetter);
+        syncPreference(Config.KEY_UI_WALLPAPER_SHOWN);
+        syncPreference(Config.KEY_UI_STATUS_BATTERY_STICKY);
+        syncPreference(Config.KEY_UI_FULLSCREEN);
+        syncPreference(Config.KEY_UI_UNLOCK_ANIMATION);
+
+        mIconSizePreference = findPreference("icon_size");
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        Config config = getConfig();
+        config.registerListener(this);
+
+        updateIconSizeSummary(config);
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        Config config = getConfig();
+        config.unregisterListener(this);
+    }
+
+    @Override
+    public void onConfigChanged(@NonNull ConfigBase configBase,
+                                @NonNull String key,
+                                @NonNull Object value) {
+        Config config = (Config) configBase;
+        switch (key) {
+            case Config.KEY_UI_ICON_SIZE:
+                updateIconSizeSummary(config);
+                break;
+        }
+    }
+
+    private void updateIconSizeSummary(Config config) {
+        mIconSizePreference.setSummary(getString(R.string.settings_icon_size_summary,
+                Integer.toString(config.getIconSize(Config.ICON_SIZE_DP))));
+    }
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/settings/NotificationSettings.java b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/settings/KeyguardSettings.java
similarity index 70%
rename from project/app/src/main/java/com/achep/acdisplay/settings/NotificationSettings.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/fragments/settings/KeyguardSettings.java
index 28bfe485..a6e33364 100644
--- a/project/app/src/main/java/com/achep/acdisplay/settings/NotificationSettings.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/settings/KeyguardSettings.java
@@ -16,24 +16,30 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.settings;
+package com.achep.acdisplay.ui.fragments.settings;
 
 import android.os.Bundle;
 
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.R;
+import com.achep.base.ui.fragments.PreferenceFragment;
 
 /**
  * Created by Artem on 09.02.14.
  */
-public class NotificationSettings extends PreferenceFragment {
+public class KeyguardSettings extends PreferenceFragment {
+
+    @Override
+    public Config getConfig() {
+        return Config.getInstance();
+    }
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        addPreferencesFromResource(R.xml.notification_settings);
-        syncPreference(Config.KEY_NOTIFY_LOW_PRIORITY);
-        syncPreference(Config.KEY_NOTIFY_WAKE_UP_ON);
+        requestMasterSwitch(Config.KEY_KEYGUARD);
+        addPreferencesFromResource(R.xml.settings_keyguard_fragment);
+        syncPreference(Config.KEY_KEYGUARD_WITHOUT_NOTIFICATIONS);
     }
 
-}
+}
\ No newline at end of file
diff --git a/project/app/src/main/java/com/achep/acdisplay/settings/MoreSettings.java b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/settings/MoreSettings.java
similarity index 78%
rename from project/app/src/main/java/com/achep/acdisplay/settings/MoreSettings.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/fragments/settings/MoreSettings.java
index 9ca14a2f..57a0acb0 100644
--- a/project/app/src/main/java/com/achep/acdisplay/settings/MoreSettings.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/settings/MoreSettings.java
@@ -16,29 +16,35 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.settings;
+package com.achep.acdisplay.ui.fragments.settings;
 
 import android.os.Bundle;
 import android.preference.Preference;
+import android.support.annotation.NonNull;
 
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.utils.DateUtils;
-import com.achep.acdisplay.utils.MathUtils;
+import com.achep.base.content.ConfigBase;
+import com.achep.base.ui.fragments.PreferenceFragment;
+import com.achep.base.utils.DateUtils;
 
 /**
  * Created by Artem on 09.02.14.
  */
-public class MoreSettings extends PreferenceFragment implements
-        Config.OnConfigChangedListener {
+public class MoreSettings extends PreferenceFragment implements ConfigBase.OnConfigChangedListener {
 
     private Preference mInactiveHoursPreference;
     private Preference mTimeoutPreference;
 
+    @Override
+    public Config getConfig() {
+        return Config.getInstance();
+    }
+
     @Override
     public void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
-        addPreferencesFromResource(R.xml.more_settings);
+        addPreferencesFromResource(R.xml.settings_more_fragment);
         syncPreference(Config.KEY_ONLY_WHILE_CHARGING);
         syncPreference(Config.KEY_FEEL_SCREEN_OFF_AFTER_LAST_NOTIFY);
         syncPreference(Config.KEY_FEEL_WIDGET_PINNABLE);
@@ -66,7 +72,10 @@ public class MoreSettings extends PreferenceFragment implements
     }
 
     @Override
-    public void onConfigChanged(Config config, String key, Object value) {
+    public void onConfigChanged(@NonNull ConfigBase configBase,
+                                @NonNull String key,
+                                @NonNull Object value) {
+        Config config = (Config) configBase;
         switch (key) {
             case Config.KEY_INACTIVE_TIME_ENABLED:
             case Config.KEY_INACTIVE_TIME_FROM:
@@ -85,8 +94,8 @@ public class MoreSettings extends PreferenceFragment implements
             int from = config.getInactiveTimeFrom();
             int to = config.getInactiveTimeTo();
             mInactiveHoursPreference.setSummary(getString(R.string.settings_inactive_hours_enabled,
-                    DateUtils.formatTime(getActivity(), MathUtils.div(from, 60), from % 60),
-                    DateUtils.formatTime(getActivity(), MathUtils.div(to, 60), to % 60)));
+                    DateUtils.formatTime(getActivity(), from / 60, from % 60),
+                    DateUtils.formatTime(getActivity(), to / 60, to % 60)));
         } else {
             mInactiveHoursPreference.setSummary(getString(R.string.settings_inactive_hours_disabled));
         }
diff --git a/project/app/src/main/java/com/achep/acdisplay/ui/fragments/settings/NotificationSettings.java b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/settings/NotificationSettings.java
new file mode 100644
index 00000000..5b9413b3
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/fragments/settings/NotificationSettings.java
@@ -0,0 +1,63 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.ui.fragments.settings;
+
+import android.os.Bundle;
+import android.preference.ListPreference;
+import android.preference.Preference;
+import android.support.annotation.NonNull;
+
+import com.achep.acdisplay.Config;
+import com.achep.acdisplay.R;
+import com.achep.base.ui.fragments.PreferenceFragment;
+
+/**
+ * Created by Artem on 09.02.14.
+ */
+public class NotificationSettings extends PreferenceFragment {
+
+    private final ListPreferenceSetter mListPreferenceNotifyPrioritySetter =
+            new ListPreferenceSetter() {
+
+                @Override
+                public void updateSummary(@NonNull Preference preference,
+                                          @NonNull Config.Option option,
+                                          @NonNull Object value) {
+                    int pos = -(int) value + 2;
+                    ListPreference cbp = (ListPreference) preference;
+                    cbp.setSummary(cbp.getEntries()[pos]);
+                }
+
+            };
+
+    @Override
+    public Config getConfig() {
+        return Config.getInstance();
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        addPreferencesFromResource(R.xml.settings_notification_fragment);
+        syncPreference(Config.KEY_NOTIFY_MIN_PRIORITY, mListPreferenceNotifyPrioritySetter);
+        syncPreference(Config.KEY_NOTIFY_MAX_PRIORITY, mListPreferenceNotifyPrioritySetter);
+        syncPreference(Config.KEY_NOTIFY_WAKE_UP_ON);
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/ui/preferences/ColorPickerPreference.java b/project/app/src/main/java/com/achep/acdisplay/ui/preferences/ColorPickerPreference.java
new file mode 100644
index 00000000..2ba4e7ab
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/preferences/ColorPickerPreference.java
@@ -0,0 +1,92 @@
+/*
+ * Copyright (C) 2015 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.ui.preferences;
+
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.preference.DialogPreference;
+import android.util.AttributeSet;
+import android.view.View;
+
+import com.achep.acdisplay.Config;
+import com.achep.acdisplay.R;
+import com.achep.base.content.ConfigBase;
+import com.achep.base.ui.DialogBuilder;
+import com.larswerkman.holocolorpicker.ColorPicker;
+import com.larswerkman.holocolorpicker.SaturationBar;
+import com.larswerkman.holocolorpicker.ValueBar;
+
+/**
+ * Preference to configure the size of collapsed views.
+ *
+ * @author Artem Chepurnoy
+ */
+public class ColorPickerPreference extends DialogPreference {
+
+    private static final String TAG = "ColorPickerPreference";
+
+    private final Drawable mIcon;
+    private final CharSequence mTitle;
+    private final ConfigBase.Option mOption;
+    private final Config mConfig;
+
+    private ColorPicker mColorPicker;
+
+    public ColorPickerPreference(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        mConfig = Config.getInstance();
+        mOption = mConfig.getHashMap().get(getKey());
+
+        // Get data from default dialog and hide it.
+        mIcon = getDialogIcon();
+        mTitle = getDialogTitle();
+        setDialogTitle(null);
+    }
+
+    @Override
+    protected View onCreateDialogView() {
+        final View root = new DialogBuilder(getContext())
+                .setIcon(mIcon)
+                .setTitle(mTitle)
+                .setContentView(R.layout.dialog_preference_colorpicker)
+                .createView();
+
+        int color = (int) mOption.read(mConfig);
+        mColorPicker = (ColorPicker) root.findViewById(R.id.picker);
+        mColorPicker.addSaturationBar((SaturationBar) root.findViewById(R.id.saturationbar));
+        mColorPicker.addValueBar((ValueBar) root.findViewById(R.id.valuebar));
+        mColorPicker.setColor(color);
+        mColorPicker.setOldCenterColor(color);
+
+        return root;
+    }
+
+    @Override
+    protected void onDialogClosed(boolean positiveResult) {
+        super.onDialogClosed(positiveResult);
+
+        if (!positiveResult) {
+            return;
+        }
+
+        // Save changes to config.
+        mOption.write(mConfig, getContext(), mColorPicker.getColor(), null);
+    }
+
+}
\ No newline at end of file
diff --git a/project/app/src/main/java/com/achep/acdisplay/settings/preferences/IconSizePreference.java b/project/app/src/main/java/com/achep/acdisplay/ui/preferences/IconSizePreference.java
similarity index 91%
rename from project/app/src/main/java/com/achep/acdisplay/settings/preferences/IconSizePreference.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/preferences/IconSizePreference.java
index 8b9fb9f9..b826044f 100644
--- a/project/app/src/main/java/com/achep/acdisplay/settings/preferences/IconSizePreference.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/preferences/IconSizePreference.java
@@ -16,8 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.settings.preferences;
+package com.achep.acdisplay.ui.preferences;
 
 import android.content.Context;
 import android.content.res.Resources;
@@ -33,8 +32,8 @@ import android.widget.SeekBar;
 import android.widget.TextView;
 
 import com.achep.acdisplay.Config;
-import com.achep.acdisplay.DialogHelper;
 import com.achep.acdisplay.R;
+import com.achep.base.ui.DialogBuilder;
 
 import java.lang.ref.SoftReference;
 
@@ -75,10 +74,14 @@ public class IconSizePreference extends DialogPreference implements
     protected View onCreateDialogView() {
         Resources res = getContext().getResources();
 
-        LayoutInflater inflater = (LayoutInflater) getContext()
+        final LayoutInflater inflater = (LayoutInflater) getContext()
                 .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-        View root = inflater.inflate(R.layout.preference_dialog_size, null);
-        assert root != null;
+        final View root = new DialogBuilder(getContext())
+                .setIcon(mIcon)
+                .setTitle(mTitle)
+                .setMessage(R.string.preference_icon_size_message)
+                .setContentView(R.layout.preference_dialog_size)
+                .createView();
 
         final int max = res.getInteger(R.integer.config_icon_size_max_dp);
         mMin = res.getInteger(R.integer.config_icon_size_min_dp);
@@ -95,7 +98,7 @@ public class IconSizePreference extends DialogPreference implements
 
         // Init preview
         for (int i = 0; i < 3; i++) {
-            View view = inflater.inflate(R.layout.widget_notification_icon, mContainer, false);
+            View view = inflater.inflate(R.layout.notification_icon, mContainer, false);
             view.setBackgroundColor(res.getColor(R.color.selector_pressed_dark));
             ImageView icon = (ImageView) view.findViewById(R.id.icon);
             icon.setImageResource(R.drawable.stat_notify);
@@ -106,12 +109,7 @@ public class IconSizePreference extends DialogPreference implements
 
         onStopTrackingTouch(mSeekBar);
 
-        // Build custom dialog.
-        return new DialogHelper.Builder(getContext())
-                .setIcon(mIcon)
-                .setTitle(mTitle)
-                .setView(root)
-                .createCommonView();
+        return root;
     }
 
     @Override
diff --git a/project/app/src/main/java/com/achep/acdisplay/settings/preferences/InactiveTimePreference.java b/project/app/src/main/java/com/achep/acdisplay/ui/preferences/InactiveTimePreference.java
similarity index 85%
rename from project/app/src/main/java/com/achep/acdisplay/settings/preferences/InactiveTimePreference.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/preferences/InactiveTimePreference.java
index ed72add5..afab2731 100644
--- a/project/app/src/main/java/com/achep/acdisplay/settings/preferences/InactiveTimePreference.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/preferences/InactiveTimePreference.java
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.settings.preferences;
+package com.achep.acdisplay.ui.preferences;
 
 import android.app.TimePickerDialog;
 import android.content.Context;
@@ -24,18 +24,15 @@ import android.graphics.drawable.Drawable;
 import android.preference.DialogPreference;
 import android.text.Html;
 import android.util.AttributeSet;
-import android.view.LayoutInflater;
 import android.view.View;
-import android.view.ViewGroup;
 import android.widget.CheckBox;
 import android.widget.TextView;
 import android.widget.TimePicker;
 
 import com.achep.acdisplay.Config;
-import com.achep.acdisplay.DialogHelper;
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.utils.DateUtils;
-import com.achep.acdisplay.utils.MathUtils;
+import com.achep.base.ui.DialogBuilder;
+import com.achep.base.utils.DateUtils;
 
 /**
  * Preference to configure timeouts.
@@ -61,7 +58,7 @@ public class InactiveTimePreference extends DialogPreference implements View.OnC
         public TextView labelTextView;
 
         public void setTime(Context context, int timeInMinutes) {
-            setTime(context, MathUtils.div(timeInMinutes, 60), timeInMinutes % 60);
+            setTime(context, timeInMinutes / 60, timeInMinutes % 60);
         }
 
         public void setTime(Context context, int hours, int minutes) {
@@ -84,10 +81,12 @@ public class InactiveTimePreference extends DialogPreference implements View.OnC
 
     @Override
     protected View onCreateDialogView() {
-        Context context = getContext();
-        LayoutInflater inflater = (LayoutInflater) context.getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-        ViewGroup root = (ViewGroup) inflater.inflate(R.layout.preference_dialog_inactive_hours, null);
-        assert root != null;
+        final Context context = getContext();
+        final View root = new DialogBuilder(context)
+                .setIcon(mIcon)
+                .setTitle(mTitle)
+                .setContentView(R.layout.preference_dialog_inactive_hours)
+                .createView();
 
         TextView fromTextView = (TextView) root.findViewById(R.id.from);
         TextView toTextView = (TextView) root.findViewById(R.id.to);
@@ -106,12 +105,7 @@ public class InactiveTimePreference extends DialogPreference implements View.OnC
         mTo.setTime(context, config.getInactiveTimeTo());
         mEnabled.setChecked(config.isInactiveTimeEnabled());
 
-        // Build custom dialog.
-        return new DialogHelper.Builder(getContext())
-                .setIcon(mIcon)
-                .setTitle(mTitle)
-                .setView(root)
-                .createCommonView();
+        return root;
     }
 
     @Override
diff --git a/project/app/src/main/java/com/achep/acdisplay/settings/preferences/TimeoutPreference.java b/project/app/src/main/java/com/achep/acdisplay/ui/preferences/TimeoutPreference.java
similarity index 93%
rename from project/app/src/main/java/com/achep/acdisplay/settings/preferences/TimeoutPreference.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/preferences/TimeoutPreference.java
index eca394c6..e2e55ddc 100644
--- a/project/app/src/main/java/com/achep/acdisplay/settings/preferences/TimeoutPreference.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/preferences/TimeoutPreference.java
@@ -16,21 +16,20 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.settings.preferences;
+package com.achep.acdisplay.ui.preferences;
 
 import android.content.Context;
 import android.content.res.Resources;
 import android.graphics.drawable.Drawable;
 import android.preference.DialogPreference;
 import android.util.AttributeSet;
-import android.view.LayoutInflater;
 import android.view.View;
 import android.widget.SeekBar;
 import android.widget.TextView;
 
 import com.achep.acdisplay.Config;
-import com.achep.acdisplay.DialogHelper;
 import com.achep.acdisplay.R;
+import com.achep.base.ui.DialogBuilder;
 
 import java.lang.ref.SoftReference;
 import java.lang.reflect.InvocationTargetException;
@@ -73,11 +72,12 @@ public class TimeoutPreference extends DialogPreference implements
     @Override
     protected View onCreateDialogView() {
         Resources res = getContext().getResources();
-
-        LayoutInflater inflater = (LayoutInflater) getContext()
-                .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
-        View root = inflater.inflate(R.layout.preference_dialog_timeout, null);
-        assert root != null;
+        final Context context = getContext();
+        final View root = new DialogBuilder(context)
+                .setIcon(mIcon)
+                .setTitle(mTitle)
+                .setContentView(R.layout.preference_dialog_timeout)
+                .createView();
 
         mProgresses = new int[2];
         mGroups = new Group[mProgresses.length];
@@ -111,12 +111,7 @@ public class TimeoutPreference extends DialogPreference implements
             group.seekBar.setProgress(progress / MULTIPLIER);
         }
 
-        // Build custom dialog.
-        return new DialogHelper.Builder(getContext())
-                .setIcon(mIcon)
-                .setTitle(mTitle)
-                .setView(root)
-                .createCommonView();
+        return root;
     }
 
     @Override
diff --git a/project/app/src/main/java/com/achep/acdisplay/view/ForwardingLayout.java b/project/app/src/main/java/com/achep/acdisplay/ui/view/ForwardingLayout.java
similarity index 98%
rename from project/app/src/main/java/com/achep/acdisplay/view/ForwardingLayout.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/view/ForwardingLayout.java
index d58bb308..3442f49f 100644
--- a/project/app/src/main/java/com/achep/acdisplay/view/ForwardingLayout.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/view/ForwardingLayout.java
@@ -16,8 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.view;
+package com.achep.acdisplay.ui.view;
 
 import android.content.Context;
 import android.util.AttributeSet;
@@ -27,7 +26,7 @@ import android.view.View;
 import android.view.ViewGroup;
 import android.widget.LinearLayout;
 
-import com.achep.acdisplay.utils.ViewUtils;
+import com.achep.base.utils.ViewUtils;
 
 /**
  * Created by achep on 26.04.14.
diff --git a/project/app/src/main/java/com/achep/acdisplay/view/ForwardingListener.java b/project/app/src/main/java/com/achep/acdisplay/ui/view/ForwardingListener.java
similarity index 98%
rename from project/app/src/main/java/com/achep/acdisplay/view/ForwardingListener.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/view/ForwardingListener.java
index 1b1ac0b5..a95dbf24 100644
--- a/project/app/src/main/java/com/achep/acdisplay/view/ForwardingListener.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/view/ForwardingListener.java
@@ -16,15 +16,14 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.view;
+package com.achep.acdisplay.ui.view;
 
 import android.view.MotionEvent;
 import android.view.View;
 import android.view.ViewConfiguration;
 import android.view.ViewParent;
 
-import com.achep.acdisplay.utils.ViewUtils;
+import com.achep.base.utils.ViewUtils;
 
 /**
  * Abstract class that forwards touch events to a {@link ForwardingLayout}.
diff --git a/project/app/src/main/java/com/achep/acdisplay/ui/view/HeaderGridView.java b/project/app/src/main/java/com/achep/acdisplay/ui/view/HeaderGridView.java
new file mode 100644
index 00000000..64379379
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/view/HeaderGridView.java
@@ -0,0 +1,445 @@
+/*
+ * Copyright (C) 2013 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+/* Modified by Artem Chepurnoy at 2014 */
+package com.achep.acdisplay.ui.view;
+
+import android.content.Context;
+import android.database.DataSetObservable;
+import android.database.DataSetObserver;
+import android.util.AttributeSet;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.Filter;
+import android.widget.Filterable;
+import android.widget.FrameLayout;
+import android.widget.GridView;
+import android.widget.ListAdapter;
+import android.widget.WrapperListAdapter;
+
+import java.util.ArrayList;
+
+/**
+ * A {@link GridView} that supports adding header rows in a
+ * very similar way to {@link android.widget.ListView}.
+ * See {@link HeaderGridView#addHeaderView(View, Object, boolean)}
+ */
+public class HeaderGridView extends GridView {
+    private static final String TAG = "HeaderGridView";
+
+    /**
+     * A class that represents a fixed view in a list, for example a header at the top
+     * or a footer at the bottom.
+     */
+    private static class FixedViewInfo {
+        /**
+         * The view to add to the grid
+         */
+        public View view;
+        public ViewGroup viewContainer;
+        /**
+         * The data backing the view. This is returned from {@link ListAdapter#getItem(int)}.
+         */
+        public Object data;
+        /**
+         * <code>true</code> if the fixed view should be selectable in the grid
+         */
+        public boolean isSelectable;
+    }
+
+    private final ArrayList<FixedViewInfo> mHeaderViewInfos = new ArrayList<>();
+
+    private void initHeaderGridView() {
+        super.setClipChildren(false);
+    }
+
+    public HeaderGridView(Context context) {
+        super(context);
+        initHeaderGridView();
+    }
+
+    public HeaderGridView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+        initHeaderGridView();
+    }
+
+    public HeaderGridView(Context context, AttributeSet attrs, int defStyle) {
+        super(context, attrs, defStyle);
+        initHeaderGridView();
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+        ListAdapter adapter = getAdapter();
+        if (adapter != null && adapter instanceof HeaderViewGridAdapter) {
+            ((HeaderViewGridAdapter) adapter).setNumColumns(getNumColumns());
+        }
+    }
+
+    @Override
+    public void setClipChildren(boolean clipChildren) {
+        // Ignore, since the header rows depend on not being clipped
+    }
+
+    /**
+     * Add a fixed view to appear at the top of the grid. If addHeaderView is
+     * called more than once, the views will appear in the order they were
+     * added. Views added using this call can take focus if they want.
+     * <p/>
+     * NOTE: Call this before calling setAdapter. This is so HeaderGridView can wrap
+     * the supplied cursor with one that will also account for header views.
+     *
+     * @param v            The view to add.
+     * @param data         Data to associate with this view
+     * @param isSelectable whether the item is selectable
+     */
+    public void addHeaderView(View v, Object data, boolean isSelectable) {
+        ListAdapter adapter = getAdapter();
+        if (adapter != null && !(adapter instanceof HeaderViewGridAdapter)) {
+            throw new IllegalStateException(
+                    "Cannot add header view to grid -- setAdapter has already been called.");
+        }
+        FixedViewInfo info = new FixedViewInfo();
+        FrameLayout fl = new FullWidthFixedViewLayout(getContext());
+        fl.addView(v);
+        info.view = v;
+        info.viewContainer = fl;
+        info.data = data;
+        info.isSelectable = isSelectable;
+        mHeaderViewInfos.add(info);
+        // in the case of re-adding a header view, or adding one later on,
+        // we need to notify the observer
+        if (adapter != null) {
+            ((HeaderViewGridAdapter) adapter).notifyDataSetChanged();
+        }
+    }
+
+    /**
+     * Add a fixed view to appear at the top of the grid. If addHeaderView is
+     * called more than once, the views will appear in the order they were
+     * added. Views added using this call can take focus if they want.
+     * <p/>
+     * NOTE: Call this before calling setAdapter. This is so HeaderGridView can wrap
+     * the supplied cursor with one that will also account for header views.
+     *
+     * @param v The view to add.
+     */
+    public void addHeaderView(View v) {
+        addHeaderView(v, null, true);
+    }
+
+    public int getHeaderViewCount() {
+        return mHeaderViewInfos.size();
+    }
+
+    /**
+     * Removes a previously-added header view.
+     *
+     * @param v The view to remove
+     * @return true if the view was removed, false if the view was not a header
+     * view
+     */
+    public boolean removeHeaderView(View v) {
+        if (mHeaderViewInfos.size() > 0) {
+            boolean result = false;
+            ListAdapter adapter = getAdapter();
+            if (adapter != null && ((HeaderViewGridAdapter) adapter).removeHeader(v)) {
+                result = true;
+            }
+            removeFixedViewInfo(v, mHeaderViewInfos);
+            return result;
+        }
+        return false;
+    }
+
+    private void removeFixedViewInfo(View v, ArrayList<FixedViewInfo> where) {
+        int len = where.size();
+        for (int i = 0; i < len; ++i) {
+            FixedViewInfo info = where.get(i);
+            if (info.view == v) {
+                where.remove(i);
+                break;
+            }
+        }
+    }
+
+    @Override
+    public void setAdapter(ListAdapter adapter) {
+        if (mHeaderViewInfos.size() > 0) {
+            HeaderViewGridAdapter hadapter = new HeaderViewGridAdapter(mHeaderViewInfos, adapter);
+            int numColumns = getNumColumns();
+            if (numColumns > 1) {
+                hadapter.setNumColumns(numColumns);
+            }
+            super.setAdapter(hadapter);
+        } else {
+            super.setAdapter(adapter);
+        }
+    }
+
+    private class FullWidthFixedViewLayout extends FrameLayout {
+        public FullWidthFixedViewLayout(Context context) {
+            super(context);
+        }
+
+        @Override
+        protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+            int targetWidth = HeaderGridView.this.getMeasuredWidth()
+                    - HeaderGridView.this.getPaddingLeft()
+                    - HeaderGridView.this.getPaddingRight();
+            widthMeasureSpec = MeasureSpec.makeMeasureSpec(targetWidth,
+                    MeasureSpec.getMode(widthMeasureSpec));
+            super.onMeasure(widthMeasureSpec, heightMeasureSpec);
+        }
+    }
+
+    /**
+     * ListAdapter used when a HeaderGridView has header views. This ListAdapter
+     * wraps another one and also keeps track of the header views and their
+     * associated data objects.
+     * <p>This is intended as a base class; you will probably not need to
+     * use this class directly in your own code.
+     */
+    private static class HeaderViewGridAdapter implements WrapperListAdapter, Filterable {
+        // This is used to notify the container of updates relating to number of columns
+        // or headers changing, which changes the number of placeholders needed
+        private final DataSetObservable mDataSetObservable = new DataSetObservable();
+        private final ListAdapter mAdapter;
+        private int mNumColumns = 1;
+        // This ArrayList is assumed to NOT be null.
+        ArrayList<FixedViewInfo> mHeaderViewInfos;
+        boolean mAreAllFixedViewsSelectable;
+        private final boolean mIsFilterable;
+
+        public HeaderViewGridAdapter(ArrayList<FixedViewInfo> headerViewInfos, ListAdapter adapter) {
+            mAdapter = adapter;
+            mIsFilterable = adapter instanceof Filterable;
+            if (headerViewInfos == null) {
+                throw new IllegalArgumentException("headerViewInfos cannot be null");
+            }
+            mHeaderViewInfos = headerViewInfos;
+            mAreAllFixedViewsSelectable = areAllListInfosSelectable(mHeaderViewInfos);
+        }
+
+        public int getHeadersCount() {
+            return mHeaderViewInfos.size();
+        }
+
+        @Override
+        public boolean isEmpty() {
+            return (mAdapter == null || mAdapter.isEmpty()) && getHeadersCount() == 0;
+        }
+
+        public void setNumColumns(int numColumns) {
+            if (numColumns < 1) {
+                throw new IllegalArgumentException("Number of columns must be 1 or more");
+            }
+            if (mNumColumns != numColumns) {
+                mNumColumns = numColumns;
+                notifyDataSetChanged();
+            }
+        }
+
+        private boolean areAllListInfosSelectable(ArrayList<FixedViewInfo> infos) {
+            if (infos != null) {
+                for (FixedViewInfo info : infos) {
+                    if (!info.isSelectable) {
+                        return false;
+                    }
+                }
+            }
+            return true;
+        }
+
+        public boolean removeHeader(View v) {
+            for (int i = 0; i < mHeaderViewInfos.size(); i++) {
+                FixedViewInfo info = mHeaderViewInfos.get(i);
+                if (info.view == v) {
+                    mHeaderViewInfos.remove(i);
+                    mAreAllFixedViewsSelectable = areAllListInfosSelectable(mHeaderViewInfos);
+                    mDataSetObservable.notifyChanged();
+                    return true;
+                }
+            }
+            return false;
+        }
+
+        @Override
+        public int getCount() {
+            if (mAdapter != null) {
+                return getHeadersCount() * mNumColumns + mAdapter.getCount();
+            } else {
+                return getHeadersCount() * mNumColumns;
+            }
+        }
+
+        @Override
+        public boolean areAllItemsEnabled() {
+            return mAdapter == null || mAreAllFixedViewsSelectable && mAdapter.areAllItemsEnabled();
+        }
+
+        @Override
+        public boolean isEnabled(int position) {
+            // Header (negative positions will throw an ArrayIndexOutOfBoundsException)
+            int numHeadersAndPlaceholders = getHeadersCount() * mNumColumns;
+            if (position < numHeadersAndPlaceholders) {
+                return (position % mNumColumns == 0)
+                        && mHeaderViewInfos.get(position / mNumColumns).isSelectable;
+            }
+            // Adapter
+            final int adjPosition = position - numHeadersAndPlaceholders;
+            int adapterCount;
+            if (mAdapter != null) {
+                adapterCount = mAdapter.getCount();
+                if (adjPosition < adapterCount) {
+                    return mAdapter.isEnabled(adjPosition);
+                }
+            }
+            throw new ArrayIndexOutOfBoundsException(position);
+        }
+
+        @Override
+        public Object getItem(int position) {
+            // Header (negative positions will throw an ArrayIndexOutOfBoundsException)
+            int numHeadersAndPlaceholders = getHeadersCount() * mNumColumns;
+            if (position < numHeadersAndPlaceholders) {
+                if (position % mNumColumns == 0) {
+                    return mHeaderViewInfos.get(position / mNumColumns).data;
+                }
+                return null;
+            }
+            // Adapter
+            final int adjPosition = position - numHeadersAndPlaceholders;
+            int adapterCount;
+            if (mAdapter != null) {
+                adapterCount = mAdapter.getCount();
+                if (adjPosition < adapterCount) {
+                    return mAdapter.getItem(adjPosition);
+                }
+            }
+            throw new ArrayIndexOutOfBoundsException(position);
+        }
+
+        @Override
+        public long getItemId(int position) {
+            int numHeadersAndPlaceholders = getHeadersCount() * mNumColumns;
+            if (mAdapter != null && position >= numHeadersAndPlaceholders) {
+                int adjPosition = position - numHeadersAndPlaceholders;
+                int adapterCount = mAdapter.getCount();
+                if (adjPosition < adapterCount) {
+                    return mAdapter.getItemId(adjPosition);
+                }
+            }
+            return -1;
+        }
+
+        @Override
+        public boolean hasStableIds() {
+            return mAdapter != null && mAdapter.hasStableIds();
+        }
+
+        @Override
+        public View getView(int position, View convertView, ViewGroup parent) {
+            // Header (negative positions will throw an ArrayIndexOutOfBoundsException)
+            int numHeadersAndPlaceholders = getHeadersCount() * mNumColumns;
+            if (position < numHeadersAndPlaceholders) {
+                View headerViewContainer = mHeaderViewInfos
+                        .get(position / mNumColumns).viewContainer;
+                if (position % mNumColumns == 0) {
+                    return headerViewContainer;
+                } else {
+                    if (convertView == null) {
+                        convertView = new View(parent.getContext());
+                    }
+                    // We need to do this because GridView uses the height of the last item
+                    // in a row to determine the height for the entire row.
+                    convertView.setVisibility(View.INVISIBLE);
+                    convertView.setMinimumHeight(headerViewContainer.getHeight());
+                    return convertView;
+                }
+            }
+            // Adapter
+            final int adjPosition = position - numHeadersAndPlaceholders;
+            int adapterCount;
+            if (mAdapter != null) {
+                adapterCount = mAdapter.getCount();
+                if (adjPosition < adapterCount) {
+                    return mAdapter.getView(adjPosition, convertView, parent);
+                }
+            }
+            throw new ArrayIndexOutOfBoundsException(position);
+        }
+
+        @Override
+        public int getItemViewType(int position) {
+            int numHeadersAndPlaceholders = getHeadersCount() * mNumColumns;
+            if (position < numHeadersAndPlaceholders && (position % mNumColumns != 0)) {
+                // Placeholders get the last view type number
+                return mAdapter != null ? mAdapter.getViewTypeCount() : 1;
+            }
+            if (mAdapter != null && position >= numHeadersAndPlaceholders) {
+                int adjPosition = position - numHeadersAndPlaceholders;
+                int adapterCount = mAdapter.getCount();
+                if (adjPosition < adapterCount) {
+                    return mAdapter.getItemViewType(adjPosition);
+                }
+            }
+            return AdapterView.ITEM_VIEW_TYPE_HEADER_OR_FOOTER;
+        }
+
+        @Override
+        public int getViewTypeCount() {
+            if (mAdapter != null) {
+                return mAdapter.getViewTypeCount() + 1;
+            }
+            return 2;
+        }
+
+        @Override
+        public void registerDataSetObserver(DataSetObserver observer) {
+            mDataSetObservable.registerObserver(observer);
+            if (mAdapter != null) {
+                mAdapter.registerDataSetObserver(observer);
+            }
+        }
+
+        @Override
+        public void unregisterDataSetObserver(DataSetObserver observer) {
+            mDataSetObservable.unregisterObserver(observer);
+            if (mAdapter != null) {
+                mAdapter.unregisterDataSetObserver(observer);
+            }
+        }
+
+        @Override
+        public Filter getFilter() {
+            if (mIsFilterable) {
+                return ((Filterable) mAdapter).getFilter();
+            }
+            return null;
+        }
+
+        @Override
+        public ListAdapter getWrappedAdapter() {
+            return mAdapter;
+        }
+
+        public void notifyDataSetChanged() {
+            mDataSetObservable.notifyChanged();
+        }
+    }
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/view/NotifyingLayout.java b/project/app/src/main/java/com/achep/acdisplay/ui/view/NotifyingLayout.java
similarity index 98%
rename from project/app/src/main/java/com/achep/acdisplay/view/NotifyingLayout.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/view/NotifyingLayout.java
index 58151a3a..40eb6010 100644
--- a/project/app/src/main/java/com/achep/acdisplay/view/NotifyingLayout.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/view/NotifyingLayout.java
@@ -16,8 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.view;
+package com.achep.acdisplay.ui.view;
 
 import android.content.Context;
 import android.util.AttributeSet;
diff --git a/project/app/src/main/java/com/achep/acdisplay/widgets/CircleView.java b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/CircleView.java
similarity index 89%
rename from project/app/src/main/java/com/achep/acdisplay/widgets/CircleView.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/widgets/CircleView.java
index 2178cf83..0c2ccb15 100644
--- a/project/app/src/main/java/com/achep/acdisplay/widgets/CircleView.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/CircleView.java
@@ -16,12 +16,13 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.widgets;
+package com.achep.acdisplay.ui.widgets;
 
 import android.content.Context;
 import android.content.res.Resources;
 import android.graphics.Canvas;
 import android.graphics.Color;
+import android.graphics.ColorMatrixColorFilter;
 import android.graphics.Paint;
 import android.graphics.drawable.Drawable;
 import android.os.Handler;
@@ -34,8 +35,8 @@ import android.view.animation.AccelerateDecelerateInterpolator;
 
 import com.achep.acdisplay.Config;
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.animations.CircleRadiusAnimation;
-import com.achep.acdisplay.utils.MathUtils;
+import com.achep.acdisplay.ui.animations.CircleRadiusAnimation;
+import com.achep.base.utils.MathUtils;
 
 /**
  * Created by achep on 19.04.14.
@@ -106,6 +107,9 @@ public class CircleView extends View {
         }
     };
 
+    private int mInnerColor;
+    private int mOuterColor;
+
     public interface Callback {
 
         public void onCircleEvent(float radius, float ratio, int event);
@@ -138,15 +142,32 @@ public class CircleView extends View {
 
         mPaint = new Paint();
         mPaint.setAntiAlias(true);
-        mPaint.setColor(Color.WHITE);
 
         mRadiusTarget = res.getDimension(R.dimen.circle_radius_target);
         mRadiusDecreaseThreshold = res.getDimension(R.dimen.circle_radius_decrease_threshold);
 
-        mDrawable = res.getDrawable(R.drawable.ic_unlock);
+
+        Config config = Config.getInstance();
+        mInnerColor = config.getCircleInnerColor();
+        mOuterColor = config.getCircleOuterColor();
+        float[] innerHsv = new float[3];
+        Color.colorToHSV(mInnerColor, innerHsv);
+        float innerHsvValue = innerHsv[2];
+
+        mDrawable = res.getDrawable(R.drawable.ic_settings_keyguard_white);
         mDrawable.setBounds(0, 0,
                 mDrawable.getIntrinsicWidth(),
                 mDrawable.getIntrinsicHeight());
+        if (innerHsvValue > 0.5f) { // inverse the drawable
+            final float[] matrix = {
+                    -1, 0, 0, 0, 0,
+                    0, -1, 0, 0, 0,
+                    0, 0, -1, 0, 0,
+                    0, 0, -0, 1, 0,
+            };
+            mDrawable = mDrawable.mutate(); // don't affect the original drawable
+            mDrawable.setColorFilter(new ColorMatrixColorFilter(matrix));
+        }
 
         setRadius(0);
     }
@@ -164,9 +185,13 @@ public class CircleView extends View {
         // Darkening background
         int alpha = (int) (mDarkening * 255);
         alpha += (int) ((255 - alpha) * ratio * 0.7f); // Change alpha dynamically
-        canvas.drawColor(Color.argb(alpha, 0, 0, 0));
+        canvas.drawColor(Color.argb(alpha,
+                Color.red(mOuterColor),
+                Color.green(mOuterColor),
+                Color.blue(mOuterColor)));
 
         // Draw unlock circle
+        mPaint.setColor(mInnerColor);
         mPaint.setAlpha((int) (255 * Math.pow(ratio, 1f / 3f)));
         canvas.drawCircle(mPoint[0], mPoint[1], mRadiusDrawn, mPaint);
 
diff --git a/project/app/src/main/java/com/achep/acdisplay/widgets/DateView.java b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/DateView.java
similarity index 94%
rename from project/app/src/main/java/com/achep/acdisplay/widgets/DateView.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/widgets/DateView.java
index e290bd69..09c298a5 100644
--- a/project/app/src/main/java/com/achep/acdisplay/widgets/DateView.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/DateView.java
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.widgets;
+package com.achep.acdisplay.ui.widgets;
 
 import android.annotation.SuppressLint;
 import android.content.BroadcastReceiver;
@@ -24,16 +24,12 @@ import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
 import android.text.format.DateFormat;
-import android.text.format.Time;
 import android.util.AttributeSet;
 import android.widget.TextView;
 
-import com.achep.acdisplay.Device;
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.utils.DateUtils;
-import java.text.SimpleDateFormat;
-import java.util.Date;
-import java.util.Locale;
+import com.achep.base.Device;
+
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
diff --git a/project/app/src/main/java/com/achep/acdisplay/widgets/ProgressBar.java b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/ProgressBar.java
similarity index 79%
rename from project/app/src/main/java/com/achep/acdisplay/widgets/ProgressBar.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/widgets/ProgressBar.java
index f780cfcd..7d4f69d1 100644
--- a/project/app/src/main/java/com/achep/acdisplay/widgets/ProgressBar.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/ProgressBar.java
@@ -16,17 +16,18 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.widgets;
+package com.achep.acdisplay.ui.widgets;
 
 import android.annotation.SuppressLint;
 import android.content.Context;
 import android.content.res.TypedArray;
 import android.graphics.Canvas;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.AttributeSet;
 
-import com.achep.acdisplay.Device;
 import com.achep.acdisplay.R;
+import com.achep.base.Device;
 
 /**
  * {@inheritDoc}
@@ -46,7 +47,7 @@ public class ProgressBar extends android.widget.ProgressBar {
          * Notification that the progress level has changed.
          *
          * @param progressBar The ProgressBar whose progress has changed
-         * @param progress    The current progress level. This will be in the range 0..{@link com.achep.acdisplay.widgets.ProgressBar#getMax()}}
+         * @param progress    The current progress level. This will be in the range [0..{@link ProgressBar#getMax()}]
          */
         public void onProgressChanged(ProgressBar progressBar, int progress);
 
@@ -63,22 +64,16 @@ public class ProgressBar extends android.widget.ProgressBar {
 
     public ProgressBar(Context context, AttributeSet attrs, int defStyle) {
         super(context, attrs, defStyle);
-        init(attrs, defStyle);
+        init(context, attrs, defStyle);
     }
 
-    private void init(AttributeSet attrs, int defStyle) {
+    private void init(@NonNull Context context, @Nullable AttributeSet attrs, int defStyle) {
         if (attrs == null) {
             return;
         }
 
-        Context context = getContext();
-        assert context != null;
-
         TypedArray arr = context.obtainStyledAttributes(attrs, R.styleable.ProgressBar, defStyle, 0);
-        assert arr != null;
-
         setMirrored(arr.getBoolean(R.styleable.ProgressBar_mirrored, mMirrored));
-
         arr.recycle();
     }
 
@@ -102,15 +97,21 @@ public class ProgressBar extends android.widget.ProgressBar {
 
     @SuppressLint("NewApi")
     @Override
-    protected synchronized void onDraw(Canvas canvas) {
+    protected synchronized void onDraw(@NonNull Canvas canvas) {
         if (mMirrored) {
+            canvas.save();
+            canvas.translate(getWidth() / 2, 0);
+            canvas.scale(0.5f, 1.0f);
+            super.onDraw(canvas);
+            canvas.restore();
+
             int paddingEnd = Device.hasJellyBeanMR1Api()
                     ? getPaddingEnd()
                     : getPaddingRight();
 
             canvas.save();
-            canvas.translate(getWidth() - paddingEnd, getPaddingTop());
-            canvas.scale(-1.0f, 1.0f);
+            canvas.translate(getWidth() / 2 - paddingEnd, 0);
+            canvas.scale(-0.5f, 1.0f);
             super.onDraw(canvas);
             canvas.restore();
         } else {
@@ -118,8 +119,13 @@ public class ProgressBar extends android.widget.ProgressBar {
         }
     }
 
+    /**
+     * Sets if the{@link ProgressBar progress bar} should be
+     * mirrored (decreasing from both sides to center) or no.
+     */
     public void setMirrored(boolean mirrored) {
         mMirrored = mirrored;
+        postInvalidate();
     }
 
     /**
diff --git a/project/app/src/main/java/com/achep/acdisplay/widgets/TimeView.java b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/TimeView.java
similarity index 95%
rename from project/app/src/main/java/com/achep/acdisplay/widgets/TimeView.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/widgets/TimeView.java
index a3d68c73..d026f531 100644
--- a/project/app/src/main/java/com/achep/acdisplay/widgets/TimeView.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/TimeView.java
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.widgets;
+package com.achep.acdisplay.ui.widgets;
 
 import android.content.BroadcastReceiver;
 import android.content.Context;
@@ -25,7 +25,8 @@ import android.content.IntentFilter;
 import android.text.format.Time;
 import android.util.AttributeSet;
 
-import com.achep.acdisplay.utils.DateUtils;
+import com.achep.base.ui.widgets.TextView;
+import com.achep.base.utils.DateUtils;
 
 /**
  * Created by Artem on 29.01.14.
diff --git a/project/app/src/main/java/com/achep/acdisplay/widgets/NotificationIcon.java b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/notification/NotificationIcon.java
similarity index 52%
rename from project/app/src/main/java/com/achep/acdisplay/widgets/NotificationIcon.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/widgets/notification/NotificationIcon.java
index c1d7d4f5..46a4b100 100644
--- a/project/app/src/main/java/com/achep/acdisplay/widgets/NotificationIcon.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/notification/NotificationIcon.java
@@ -16,116 +16,97 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.widgets;
+package com.achep.acdisplay.ui.widgets.notification;
 
 import android.content.Context;
 import android.graphics.Bitmap;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 import android.util.AttributeSet;
 import android.widget.ImageView;
 
-import com.achep.acdisplay.notifications.NotificationData;
+import com.achep.acdisplay.interfaces.INotificatiable;
 import com.achep.acdisplay.notifications.OpenNotification;
 
 /**
  * Created by Artem on 25.03.2014.
  */
 public class NotificationIcon extends ImageView implements
-        NotificationView,
-        NotificationData.OnNotificationDataChangedListener {
+        OpenNotification.OnNotificationDataChangedListener,
+        INotificatiable {
 
-    private boolean mAttached;
+    /* Compat for Jelly Bean */
+    private boolean mAttachedToWindow;
 
+    @Nullable
     private OpenNotification mNotification;
-    private int mIconAlpha;
 
-    private boolean mAdjustAlphaEnabled = true;
+    private int mIconAlpha;
+    private boolean mIndicateReadState = true;
 
     public NotificationIcon(Context context) {
         super(context);
-        init();
     }
 
     public NotificationIcon(Context context, AttributeSet attrs) {
         super(context, attrs);
-        init();
     }
 
     public NotificationIcon(Context context, AttributeSet attrs, int defStyle) {
         super(context, attrs, defStyle);
-        init();
-    }
-
-    @SuppressWarnings("EmptyMethod")
-    private void init() {
-        /*
-        float c[] = new float[]{
-                1f, 0f, 0f, // red
-                0f, 1f, 0f, // green
-                0.2f, 0.2f, 1f, // blue
-                1f, 0.2f, 1f, // pink
-                0.5f, 1f, 1f, // :)
-                1f, 1f, 0f, // orange
-        };
-        int i = (int) (Math.random() * (c.length / 3 - 1));
-
-        float[] colorMatrix = {
-                c[i], 0, 0, 0, 0,
-                0, c[i + 1], 0, 0, 0,
-                0, 0, c[i + 2], 0, 0,
-                0, 0, 0, 1, 0
-        };
-
-        ColorFilter colorFilter = new ColorMatrixColorFilter(colorMatrix);
-        setColorFilter(colorFilter);
-        */
     }
 
-    private void registerListenerAndUpdateIcon() {
-        if (mNotification == null) return;
+    private void registerListenerAndUpdateAll() {
+        if (mNotification == null) {
+            // TODO: What to do if the notification is null?
+            return;
+        }
 
-        NotificationData data = mNotification.getNotificationData();
-        handleIconChanged(data.getIcon());
-        handleReadStateChanged(data.isRead);
-        data.registerListener(this);
+        handleIconChanged();
+        handleReadStateChanged();
+        mNotification.registerListener(this);
     }
 
     private void unregisterListener() {
         if (mNotification == null) return;
 
-        NotificationData data = mNotification.getNotificationData();
-        data.unregisterListener(this);
+        mNotification.unregisterListener(this);
     }
 
     @Override
     protected void onAttachedToWindow() {
         super.onAttachedToWindow();
-        mAttached = true;
-        registerListenerAndUpdateIcon();
+        mAttachedToWindow = true;
+        registerListenerAndUpdateAll();
     }
 
     @Override
     protected void onDetachedFromWindow() {
-        mAttached = false;
-        super.onDetachedFromWindow();
+        mAttachedToWindow = false;
         unregisterListener();
+        super.onDetachedFromWindow();
     }
 
     public void setNotificationIndicateReadStateEnabled(boolean enabled) {
-        mAdjustAlphaEnabled = enabled;
-        handleReadStateChanged(false);
+        mIndicateReadState = enabled;
+        if (mNotification != null) handleReadStateChanged();
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
-    public void setNotification(OpenNotification notification) {
-        if (mAttached) {
+    public void setNotification(@Nullable OpenNotification notification) {
+        if (mAttachedToWindow) {
             unregisterListener();
             mNotification = notification;
-            registerListenerAndUpdateIcon();
+            registerListenerAndUpdateAll();
         } else mNotification = notification;
     }
 
-    private void handleIconChanged(Bitmap icon) {
+    private void handleIconChanged() {
+        assert mNotification != null;
+        Bitmap icon = mNotification.getIcon();
         setImageBitmap(icon);
         setImageAlpha(mIconAlpha);
     }
@@ -133,25 +114,35 @@ public class NotificationIcon extends ImageView implements
     /**
      * Updates icon's alpha level to indicate is notification read or not.
      */
-    private void handleReadStateChanged(boolean isRead) {
-        mIconAlpha = isRead && mAdjustAlphaEnabled ? 120 : 255;
+    private void handleReadStateChanged() {
+        assert mNotification != null;
+        // TODO: Move the alpha levels up to resources.
+        mIconAlpha = mNotification.isRead() && mIndicateReadState ? 120 : 255;
         setImageAlpha(mIconAlpha);
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
-    public void onNotificationDataChanged(NotificationData data, int changeId) {
-        switch (changeId) {
-            case NotificationData.ICON:
-                handleIconChanged(data.getIcon());
+    public void onNotificationDataChanged(@NonNull OpenNotification notification, int event) {
+        switch (event) {
+            case OpenNotification.EVENT_ICON:
+                handleIconChanged();
                 break;
-            case NotificationData.READ:
-                handleReadStateChanged(data.isRead);
+            case OpenNotification.EVENT_READ:
+                handleReadStateChanged();
                 break;
         }
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @Nullable
     @Override
     public OpenNotification getNotification() {
         return mNotification;
     }
+
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/widgets/NotificationIconWidget.java b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/notification/NotificationIconWidget.java
similarity index 54%
rename from project/app/src/main/java/com/achep/acdisplay/widgets/NotificationIconWidget.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/widgets/notification/NotificationIconWidget.java
index 570bf5ef..8fbc0960 100644
--- a/project/app/src/main/java/com/achep/acdisplay/widgets/NotificationIconWidget.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/notification/NotificationIconWidget.java
@@ -16,26 +16,28 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.widgets;
+package com.achep.acdisplay.ui.widgets.notification;
 
 import android.content.Context;
+import android.support.annotation.Nullable;
 import android.util.AttributeSet;
 import android.widget.FrameLayout;
 import android.widget.TextView;
 
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.notifications.NotificationData;
+import com.achep.acdisplay.interfaces.INotificatiable;
 import com.achep.acdisplay.notifications.OpenNotification;
-import com.achep.acdisplay.utils.ViewUtils;
 
 /**
  * Created by Artem on 12.01.14.
  */
-public class NotificationIconWidget extends FrameLayout implements NotificationView {
+public class NotificationIconWidget extends FrameLayout implements INotificatiable {
 
+    @Nullable
     private OpenNotification mNotification;
 
-    private NotificationIcon mIcon;
+    // Views
+    private NotificationIcon mNotificationIcon;
     private TextView mNumberTextView;
 
     public NotificationIconWidget(Context context, AttributeSet attrs) {
@@ -45,25 +47,44 @@ public class NotificationIconWidget extends FrameLayout implements NotificationV
     @Override
     protected void onFinishInflate() {
         super.onFinishInflate();
-
-        mIcon = (NotificationIcon) findViewById(R.id.icon);
+        mNotificationIcon = (NotificationIcon) findViewById(R.id.icon);
         mNumberTextView = (TextView) findViewById(R.id.number);
+        if (mNotification != null) setNotification(mNotification);
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
-    public void setNotification(OpenNotification notification) {
-        if (mNotification == notification) return;
-        mNotification = notification;
+    public void setNotification(@Nullable OpenNotification notification) {
+        if (mNotificationIcon == null) {
+            // This means that #onFinishInflate() hadn't happen yet.
+            // Lets wait for it and re-set notification.
+            mNotification = notification;
+            return;
+        }
 
-        mIcon.setNotification(mNotification);
+        mNotification = null;
+        mNotificationIcon.setNotification(notification);
 
-        NotificationData data = mNotification.getNotificationData();
-        String tileText = data.number > 0 ? Integer.toString(data.number) : null;
-        ViewUtils.safelySetText(mNumberTextView, tileText);
+        int number = notification == null ? 0 : notification.getNumber();
+        if (number > 0) {
+            mNumberTextView.setText(Integer.toString(number));
+            mNumberTextView.setVisibility(VISIBLE);
+        } else {
+            mNumberTextView.setVisibility(GONE);
+        }
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @Nullable
     @Override
     public OpenNotification getNotification() {
-        return mNotification;
+        return mNotificationIcon != null
+                ? mNotificationIcon.getNotification()
+                : mNotification;
     }
+
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/widgets/NotificationWidget.java b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/notification/NotificationWidget.java
similarity index 81%
rename from project/app/src/main/java/com/achep/acdisplay/widgets/NotificationWidget.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/widgets/notification/NotificationWidget.java
index e5dd779f..3402dd6c 100644
--- a/project/app/src/main/java/com/achep/acdisplay/widgets/NotificationWidget.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/notification/NotificationWidget.java
@@ -16,8 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.widgets;
+package com.achep.acdisplay.ui.widgets.notification;
 
 import android.annotation.SuppressLint;
 import android.app.Notification;
@@ -29,6 +28,7 @@ import android.graphics.Color;
 import android.graphics.ColorFilter;
 import android.graphics.ColorMatrixColorFilter;
 import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.text.SpannableString;
 import android.text.Spanned;
@@ -41,14 +41,15 @@ import android.view.ViewGroup;
 import android.widget.LinearLayout;
 import android.widget.TextView;
 
-import com.achep.acdisplay.Device;
 import com.achep.acdisplay.R;
+import com.achep.acdisplay.interfaces.INotificatiable;
 import com.achep.acdisplay.notifications.Action;
-import com.achep.acdisplay.notifications.NotificationData;
 import com.achep.acdisplay.notifications.NotificationUtils;
 import com.achep.acdisplay.notifications.OpenNotification;
 import com.achep.acdisplay.utils.BitmapUtils;
-import com.achep.acdisplay.utils.ViewUtils;
+import com.achep.base.Device;
+import com.achep.base.utils.NullUtils;
+import com.achep.base.utils.ViewUtils;
 
 import java.util.Arrays;
 
@@ -58,7 +59,7 @@ import java.util.Arrays;
  *
  * @author Artem Chepurnoy
  */
-public class NotificationWidget extends LinearLayout implements NotificationView {
+public class NotificationWidget extends LinearLayout implements INotificatiable {
 
     private final int mMessageLayoutRes;
     private final int mMessageMaxLines;
@@ -78,9 +79,7 @@ public class NotificationWidget extends LinearLayout implements NotificationView
     private OpenNotification mNotification;
     private ViewGroup mContent;
 
-    private boolean mActionContainerAtTop = false;
-
-    private ColorFilter mColorFilterDark;
+    private final ColorFilter mColorFilterDark;
 
     /**
      * Interface definition for a callback to be invoked
@@ -115,19 +114,19 @@ public class NotificationWidget extends LinearLayout implements NotificationView
         TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.NotificationWidget);
         mActionLayoutRes = a.getResourceId(
                 R.styleable.NotificationWidget_actionItemLayout,
-                R.layout.widget_notification_action);
+                R.layout.notification_action);
         mMessageMaxLines = a.getInt(R.styleable.NotificationWidget_messageMaxLines, 4);
         mMessageLayoutRes = a.getResourceId(
                 R.styleable.NotificationWidget_messageItemLayout,
-                R.layout.heads_up_notification_message);
+                R.layout.notification_message);
         mActionAddIcon = a.getBoolean(R.styleable.NotificationWidget_actionItemShowIcon, true);
         a.recycle();
 
+        float v = -0.8f;
         float[] colorMatrix = {
-                // Change everychannel's color (except alpha).
-                -0.8f, 0, 0, 0, 0,
-                0, -0.8f, 0, 0, 0,
-                0, 0, -0.8f, 0, 0,
+                v, 0, 0, 0, 0,
+                0, v, 0, 0, 0,
+                0, 0, v, 0, 0,
                 0, 0, 0, 1, 0
         };
         mColorFilterDark = new ColorMatrixColorFilter(colorMatrix);
@@ -154,25 +153,6 @@ public class NotificationWidget extends LinearLayout implements NotificationView
         mContent.setOnClickListener(listener);
     }
 
-    /**
-     * Sets an alignment of action buttons.
-     *
-     * @param alignment may be {@link #ALIGN_TOP} or {@link #ALIGN_BOTTOM}
-     */
-    public void setActionButtonsAlignTop(boolean alignTop) {
-        mActionContainerAtTop = alignTop;
-
-        if (mContent != null && mActionsContainer != null) {
-            updateActionButtonsAlignment();
-        }
-    }
-
-    private void updateActionButtonsAlignment() {
-        removeView(mActionsContainer);
-        int pos = ViewUtils.indexOf(this, mContent) - 1;
-        addView(mActionsContainer, mActionContainerAtTop ? pos + 1 : pos);
-    }
-
     @Override
     protected void onFinishInflate() {
         super.onFinishInflate();
@@ -188,7 +168,6 @@ public class NotificationWidget extends LinearLayout implements NotificationView
 
         if (mSmallIcon != null) mSmallIcon.setNotificationIndicateReadStateEnabled(false);
         mIcon.setNotificationIndicateReadStateEnabled(false);
-        updateActionButtonsAlignment();
     }
 
     private int getAverageRgb(int color) {
@@ -213,15 +192,11 @@ public class NotificationWidget extends LinearLayout implements NotificationView
      * or higher Android version.
      */
     @SuppressLint("NewApi")
-    private void setActions(OpenNotification osbn) {
-        Action[] actions = osbn.getNotificationData().actions;
+    private void setActions(@NonNull OpenNotification notification) {
+        Action[] actions = notification.getActions();
         if (actions == null) {
-            // Hide actions container. Do not delete all views
-            // because we may re-use them later.
-            mActionsContainer.setVisibility(GONE);
+            mActionsContainer.removeAllViews();
             return;
-        } else {
-            mActionsContainer.setVisibility(VISIBLE);
         }
 
         int count = actions.length;
@@ -259,19 +234,24 @@ public class NotificationWidget extends LinearLayout implements NotificationView
                 // We need to keep all IDs unique to make
                 // TransitionManager.beginDelayedTransition(viewGroup, null)
                 // work correctly!
-                root.setId(mActionsContainer.getChildCount());
+                root.setId(mActionsContainer.getChildCount() + 1);
                 mActionsContainer.addView(root);
             }
 
-            root.setOnClickListener(new View.OnClickListener() {
-                @Override
-                public void onClick(View v) {
-                    if (mOnClickListener != null) {
-                        NotificationWidget widget = NotificationWidget.this;
-                        mOnClickListener.onActionButtonClick(widget, v, action.intent);
+            if (action.intent != null) {
+                root.setEnabled(true);
+                root.setOnClickListener(new View.OnClickListener() {
+                    @Override
+                    public void onClick(View v) {
+                        if (mOnClickListener != null) {
+                            NotificationWidget widget = NotificationWidget.this;
+                            mOnClickListener.onActionButtonClick(widget, v, action.intent);
+                        }
                     }
-                }
-            });
+                });
+            } else {
+                root.setEnabled(false);
+            }
 
             // Get message view and apply the content.
             TextView textView = root instanceof TextView
@@ -280,11 +260,12 @@ public class NotificationWidget extends LinearLayout implements NotificationView
             textView.setText(action.title);
 
             if (mActionAddIcon) {
-                Drawable icon = NotificationUtils.getDrawable(getContext(), osbn, action.icon);
+                Drawable icon = NotificationUtils.getDrawable(getContext(), notification, action.icon);
 
                 if (icon != null) {
                     final int size = getResources().getDimensionPixelSize(R.dimen.notification_action_icon_size);
                     icon.setBounds(0, 0, size, size);
+                    icon.setAlpha(255 * 0x89 / 0xFF); // TODO: Move that magic constant away
 
                     if (hasDarkTextColor(textView)) {
                         icon.setColorFilter(mColorFilterDark);
@@ -318,10 +299,8 @@ public class NotificationWidget extends LinearLayout implements NotificationView
         if (lines == null) {
             // Hide message container. Do not delete all messages
             // because we may re-use them later.
-            mMessageContainer.setVisibility(GONE);
+            mMessageContainer.removeAllViews();
             return;
-        } else {
-            mMessageContainer.setVisibility(VISIBLE);
         }
 
         int[] maxlines;
@@ -399,7 +378,7 @@ public class NotificationWidget extends LinearLayout implements NotificationView
                 // We need to keep all IDs unique to make
                 // TransitionManager.beginDelayedTransition(viewGroup, null)
                 // work correctly!
-                root.setId(mMessageContainer.getChildCount());
+                root.setId(mMessageContainer.getChildCount() + 1);
                 mMessageContainer.addView(root);
             }
 
@@ -455,22 +434,18 @@ public class NotificationWidget extends LinearLayout implements NotificationView
         }
 
         Notification n = osbn.getNotification();
-        NotificationData data = osbn.getNotificationData();
-
-        Bitmap bitmap = data.getCircleIcon();
-        if (bitmap == null) bitmap = n.largeIcon;
+        Bitmap bitmap = n.largeIcon;
         if (bitmap != null) {
-            if (bitmap == n.largeIcon
-                    // Not a profile icon.
-                    && BitmapUtils.hasTransparentCorners(bitmap)
-                    // Icon has white color.
-                    && Color.red(data.dominantColor) > 127
-                    && Color.blue(data.dominantColor) > 127
-                    && Color.green(data.dominantColor) > 127
+            int averageColor;
+            if (BitmapUtils.hasTransparentCorners(bitmap) // Not a profile icon.
                     // Title text is dark.
-                    && hasDarkTextColor(mTitleTextView)) {
+                    && hasDarkTextColor(mTitleTextView)
+                    // Icon has white color.
+                    && Color.red(averageColor = BitmapUtils.getAverageColor(bitmap)) > 127
+                    && Color.blue(averageColor) > 127
+                    && Color.green(averageColor) > 127) {
                 // The icon is PROBABLY not a profile icon,
-                // NOT a dark one and we must dark it to
+                // NOT a dark one and we must reverse its color to
                 // make it visible on white backgrounds.
                 mIcon.setColorFilter(mColorFilterDark);
             } else {
@@ -491,20 +466,24 @@ public class NotificationWidget extends LinearLayout implements NotificationView
             setSmallIcon(null);
         }
 
-        mTitleTextView.setText(data.titleBigText == null
-                ? data.titleText
-                : data.titleBigText);
-        mSubtextTextView.setText(data.infoText == null
-                ? data.subText
-                : data.infoText);
-        mWhenTextView.setText(DateUtils.formatDateTime(
-                getContext(), n.when, DateUtils.FORMAT_SHOW_TIME));
+        mTitleTextView.setText(NullUtils.whileNotNull(osbn.titleBigText, osbn.titleText));
+        mSubtextTextView.setText(NullUtils.whileNotNull(osbn.infoText, osbn.subText));
+        mWhenTextView.setText(getTimestamp(n));
 
         setActions(osbn);
-        setMessageLines(data.messageTextLines == null
-                ? data.messageText == null
-                ? null : new CharSequence[]{data.messageText}
-                : data.messageTextLines);
+        setMessageLines((CharSequence[]) NullUtils.whileNotNull(
+                osbn.messageTextLines,
+                wrap(osbn.messageBigText),
+                wrap(osbn.messageText)));
+    }
+
+    private CharSequence[] wrap(CharSequence charSequence) {
+        return charSequence == null ? null : new CharSequence[]{charSequence};
+    }
+
+    private String getTimestamp(@NonNull Notification notification) {
+        final long when = notification.when;
+        return DateUtils.formatDateTime(getContext(), when, DateUtils.FORMAT_SHOW_TIME);
     }
 
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/widgets/status/BatteryMeterView.java b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/status/BatteryMeterView.java
similarity index 99%
rename from project/app/src/main/java/com/achep/acdisplay/widgets/status/BatteryMeterView.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/widgets/status/BatteryMeterView.java
index 3e30bf61..38451c1f 100644
--- a/project/app/src/main/java/com/achep/acdisplay/widgets/status/BatteryMeterView.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/status/BatteryMeterView.java
@@ -14,8 +14,7 @@
  * limitations under the License.
  */
 // Modified 2014 AChep@xda <artemchep@gmail.com>
-
-package com.achep.acdisplay.widgets.status;
+package com.achep.acdisplay.ui.widgets.status;
 
 import android.content.BroadcastReceiver;
 import android.content.Context;
@@ -196,7 +195,7 @@ public class BatteryMeterView extends TextView {
             levels.recycle();
             colors.recycle();
         } else {
-            mColors = new int[] {
+            mColors = new int[]{
                     4, res.getColor(R.color.batterymeter_critical),
                     15, res.getColor(R.color.batterymeter_low),
                     100, res.getColor(R.color.batterymeter_full),
@@ -477,7 +476,7 @@ public class BatteryMeterView extends TextView {
                 }
                 return ptsF;
             } else {
-                return new float[] {0, 0, 1, 1};
+                return new float[]{0, 0, 1, 1};
             }
         }
 
diff --git a/project/app/src/main/java/com/achep/acdisplay/widgets/status/NextAlarmView.java b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/status/NextAlarmView.java
similarity index 98%
rename from project/app/src/main/java/com/achep/acdisplay/widgets/status/NextAlarmView.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/widgets/status/NextAlarmView.java
index 1af238f4..2890e2b4 100644
--- a/project/app/src/main/java/com/achep/acdisplay/widgets/status/NextAlarmView.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/status/NextAlarmView.java
@@ -16,8 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.widgets.status;
+package com.achep.acdisplay.ui.widgets.status;
 
 import android.content.ContentResolver;
 import android.content.Context;
diff --git a/project/app/src/main/java/com/achep/acdisplay/widgets/status/StatusWidget.java b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/status/StatusWidget.java
similarity index 87%
rename from project/app/src/main/java/com/achep/acdisplay/widgets/status/StatusWidget.java
rename to project/app/src/main/java/com/achep/acdisplay/ui/widgets/status/StatusWidget.java
index eb05ff86..77f55a46 100644
--- a/project/app/src/main/java/com/achep/acdisplay/widgets/status/StatusWidget.java
+++ b/project/app/src/main/java/com/achep/acdisplay/ui/widgets/status/StatusWidget.java
@@ -16,23 +16,24 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.widgets.status;
+package com.achep.acdisplay.ui.widgets.status;
 
 import android.content.Context;
+import android.support.annotation.NonNull;
 import android.util.AttributeSet;
 import android.widget.LinearLayout;
 
 import com.achep.acdisplay.Config;
-import com.achep.acdisplay.Operator;
 import com.achep.acdisplay.R;
-import com.achep.acdisplay.utils.ViewUtils;
+import com.achep.base.content.ConfigBase;
+import com.achep.base.utils.Operator;
+import com.achep.base.utils.ViewUtils;
 
 /**
  * Created by achep on 17.06.14.
  */
 public class StatusWidget extends LinearLayout implements
-        Config.OnConfigChangedListener,
+        ConfigBase.OnConfigChangedListener,
         BatteryMeterView.OnBatteryChangedListener {
 
     private BatteryMeterView mBatteryMeterView;
@@ -87,7 +88,9 @@ public class StatusWidget extends LinearLayout implements
     }
 
     @Override
-    public void onConfigChanged(Config config, String key, Object value) {
+    public void onConfigChanged(@NonNull ConfigBase config,
+                                @NonNull String key,
+                                @NonNull Object value) {
         switch (key) {
             case Config.KEY_UI_STATUS_BATTERY_STICKY:
                 updateBatteryVisibility();
diff --git a/project/app/src/main/java/com/achep/acdisplay/utils/AccessUtils.java b/project/app/src/main/java/com/achep/acdisplay/utils/AccessUtils.java
index 218663bc..8ab20297 100644
--- a/project/app/src/main/java/com/achep/acdisplay/utils/AccessUtils.java
+++ b/project/app/src/main/java/com/achep/acdisplay/utils/AccessUtils.java
@@ -23,10 +23,10 @@ import android.content.ComponentName;
 import android.content.Context;
 import android.support.annotation.NonNull;
 
-import com.achep.acdisplay.Device;
-import com.achep.acdisplay.admin.AdminReceiver;
+import com.achep.acdisplay.receiver.AdminReceiver;
 import com.achep.acdisplay.services.AccessibilityService;
 import com.achep.acdisplay.services.MediaService;
+import com.achep.base.Device;
 
 /**
  * Created by Artem on 23.01.14.
diff --git a/project/app/src/main/java/com/achep/acdisplay/utils/BitmapUtils.java b/project/app/src/main/java/com/achep/acdisplay/utils/BitmapUtils.java
index d951b56b..8dcdc641 100644
--- a/project/app/src/main/java/com/achep/acdisplay/utils/BitmapUtils.java
+++ b/project/app/src/main/java/com/achep/acdisplay/utils/BitmapUtils.java
@@ -16,33 +16,20 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
 package com.achep.acdisplay.utils;
 
 import android.graphics.Bitmap;
-import android.graphics.BitmapShader;
-import android.graphics.Canvas;
 import android.graphics.Color;
-import android.graphics.Paint;
-import android.graphics.Shader;
 import android.support.annotation.NonNull;
-import android.support.annotation.Nullable;
 
 /**
  * Created by Artem on 24.03.2014.
  */
 public class BitmapUtils {
 
-    /**
-     * Recycles given bitmap, if it's not {@code null}.
-     */
-    public static void safelyRecycle(@Nullable Bitmap bitmap) {
-        if (bitmap != null) bitmap.recycle();
-    }
-
-    public static int getDominantColor(@NonNull Bitmap bitmap) {
+    public static int getAverageColor(@NonNull Bitmap bitmap) {
         Bitmap onePixelBitmap = Bitmap.createScaledBitmap(bitmap, 1, 1, true);
-        int color = onePixelBitmap.getPixel(0,0);
+        int color = onePixelBitmap.getPixel(0, 0);
         onePixelBitmap.recycle();
         return color;
     }
@@ -56,32 +43,6 @@ public class BitmapUtils {
                 || bitmap.getPixel(right, bottom) == Color.TRANSPARENT;
     }
 
-    /**
-     * Create a bitmap which is wrapped to circle
-     * (similar to what you can see in G+ profile pic.)
-     *
-     * @param bitmap Original Bitmap
-     * @return Circled bitmap
-     */
-    @NonNull
-    public static Bitmap createCircleBitmap(@NonNull Bitmap bitmap) {
-        final int width = bitmap.getWidth();
-        final int height = bitmap.getHeight();
-
-        BitmapShader bitmapShader = new BitmapShader(bitmap,
-                Shader.TileMode.CLAMP,
-                Shader.TileMode.CLAMP);
-        Paint bitmapPaint = new Paint();
-        bitmapPaint.setAntiAlias(true);
-        bitmapPaint.setShader(bitmapShader);
-
-        Bitmap output = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888);
-        Canvas canvas = new Canvas(output);
-        canvas.drawCircle(width / 2, height / 2, Math.min(width, height) / 2, bitmapPaint);
-
-        return output;
-    }
-
     @NonNull
     public static Bitmap doBlur(@NonNull Bitmap sentBitmap, int radius, boolean canReuseInBitmap) {
 
diff --git a/project/app/src/main/java/com/achep/acdisplay/utils/MaterialAnimationUtils.java b/project/app/src/main/java/com/achep/acdisplay/utils/MaterialAnimationUtils.java
new file mode 100644
index 00000000..09812a31
--- /dev/null
+++ b/project/app/src/main/java/com/achep/acdisplay/utils/MaterialAnimationUtils.java
@@ -0,0 +1,67 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.acdisplay.utils;
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.annotation.TargetApi;
+import android.os.Build;
+import android.view.View;
+import android.view.ViewAnimationUtils;
+
+/**
+ * Created by Artem Chepurnoy on 07.11.2014.
+ */
+public class MaterialAnimationUtils {
+
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    public static Animator createCircularReveal(final View view, boolean show) {
+        int x = view.getMeasuredWidth() / 2;
+        int y = view.getMeasuredHeight() / 2;
+        return createCircularReveal(view, x, y, show);
+    }
+
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    public static Animator createCircularReveal(final View view, int x, int y, boolean show) {
+        Animator anim;
+
+        int distance = (int) Math.floor(Math.hypot(
+                view.getMeasuredWidth(),
+                view.getMeasuredHeight()) / 2);
+        if (show) {
+            anim = ViewAnimationUtils.createCircularReveal(view, x, y, 0, distance);
+            anim.addListener(new AnimatorListenerAdapter() {
+                @Override
+                public void onAnimationStart(Animator animation) {
+                    view.setVisibility(View.VISIBLE);
+                }
+            });
+        } else {
+            anim = ViewAnimationUtils.createCircularReveal(view, x, y, distance, 0);
+            anim.addListener(new AnimatorListenerAdapter() {
+                @Override
+                public void onAnimationEnd(Animator animation) {
+                    view.setVisibility(View.INVISIBLE);
+                }
+            });
+        }
+        return anim;
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/utils/StringUtils.java b/project/app/src/main/java/com/achep/acdisplay/utils/StringUtils.java
deleted file mode 100644
index efcb0fd4..00000000
--- a/project/app/src/main/java/com/achep/acdisplay/utils/StringUtils.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package com.achep.acdisplay.utils;
-
-/**
- * Created by Artem Chepurnoy on 15.09.2014.
- */
-public class StringUtils {
-
-    /**
-     * Removes all kinds of multiple spaces from given string.
-     */
-    public static String removeSpaces(CharSequence cs) {
-        if (cs == null) return null;
-        String string = cs instanceof String
-                ? (String) cs : cs.toString();
-        return string
-                .replaceAll("(\\s+$|^\\s+)", "")
-                .replaceAll("\n+", "\n");
-    }
-
-}
diff --git a/project/app/src/main/java/com/achep/base/Build.java b/project/app/src/main/java/com/achep/base/Build.java
new file mode 100644
index 00000000..17000c37
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/Build.java
@@ -0,0 +1,65 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base;
+
+import android.support.annotation.NonNull;
+
+import com.achep.acdisplay.BuildConfig;
+
+/**
+ * Created by Artem on 30.12.13.
+ */
+/* The first class of the AcDisplay, dated by 30.12.2013 */
+public final class Build {
+
+    /**
+     * Is the current build <b>debug</b> or not.
+     */
+    public static final boolean DEBUG =
+            BuildConfig.MY_DEBUG;
+
+    /**
+     * The timestamp of build in {@code EEE MMMM dd HH:mm:ss zzz yyyy} format.
+     */
+    @NonNull
+    public static final String TIME_STAMP =
+            BuildConfig.MY_TIME_STAMP;
+
+    /**
+     *
+     */
+    @NonNull
+    public static final String GOOGLE_PLAY_PUBLIC_KEY_ENCRYPTED =
+            BuildConfig.MY_GOOGLE_PLAY_PUBLIC_KEY;
+
+    /**
+     *
+     */
+    @NonNull
+    public static final String GOOGLE_PLAY_PUBLIC_KEY_SALT =
+            BuildConfig.MY_GOOGLE_PLAY_PUBLIC_KEY_SALT;
+
+    /**
+     *
+     */
+    @NonNull
+    public static final String SUPPORT_EMAIL =
+            "support@artemchep.com";
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/Device.java b/project/app/src/main/java/com/achep/base/Device.java
similarity index 50%
rename from project/app/src/main/java/com/achep/acdisplay/Device.java
rename to project/app/src/main/java/com/achep/base/Device.java
index 8a901d81..a1255fe9 100644
--- a/project/app/src/main/java/com/achep/acdisplay/Device.java
+++ b/project/app/src/main/java/com/achep/base/Device.java
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay;
+package com.achep.base;
 
 import android.os.Build;
 
@@ -28,20 +28,65 @@ import android.os.Build;
  */
 public class Device {
 
+    /**
+     * The user-visible SDK version of the framework;
+     * its possible values are defined in Build.VERSION_CODES.
+     */
+    public static final int API_VERSION = Build.VERSION.SDK_INT;
+
+    /**
+     * The name of the Android version represented by two or three
+     * letters. Example: KK -> KitKat, KKW -> KitKat Watches etc.
+     */
+    public static final String API_VERSION_NAME_SHORT;
+
+    static {
+        switch (API_VERSION) {
+            case Build.VERSION_CODES.JELLY_BEAN:
+                API_VERSION_NAME_SHORT = "JB";
+                break;
+            case Build.VERSION_CODES.JELLY_BEAN_MR1:
+                API_VERSION_NAME_SHORT = "JB1";
+                break;
+            case Build.VERSION_CODES.JELLY_BEAN_MR2:
+                API_VERSION_NAME_SHORT = "JB2";
+                break;
+            case Build.VERSION_CODES.KITKAT:
+                API_VERSION_NAME_SHORT = "KK";
+                break;
+            case Build.VERSION_CODES.KITKAT_WATCH:
+                API_VERSION_NAME_SHORT = "KKW";
+                break;
+            case Build.VERSION_CODES.LOLLIPOP:
+                API_VERSION_NAME_SHORT = "LP";
+                break;
+            default:
+                API_VERSION_NAME_SHORT = "WTF";
+        }
+    }
+
     /**
      * @return {@code true} if device is device supports given API version,
      * {@code false} otherwise.
      */
     public static boolean hasTargetApi(int api) {
-        return Build.VERSION.SDK_INT >= api;
+        return API_VERSION >= api;
     }
 
     /**
      * @return {@code true} if device is running
-     * {@link Build.VERSION_CODES#L Lollipop} or higher, {@code false} otherwise.
+     * {@link Build.VERSION_CODES#LOLLIPOP Lollipop} or higher, {@code false} otherwise.
      */
     public static boolean hasLollipopApi() {
-        return Build.VERSION.SDK_INT >= 20; // Build.VERSION_CODES.L;
+        return hasTargetApi(Build.VERSION_CODES.LOLLIPOP);
+    }
+
+    /**
+     * @return {@code true} if device is running
+     * {@link Build.VERSION_CODES#KITKAT_WATCH KitKat watch} or higher, {@code false} otherwise.
+     */
+    public static boolean hasKitKatWatchApi() {
+        return hasTargetApi(Build.VERSION_CODES.KITKAT_WATCH);
     }
 
     /**
@@ -49,7 +94,7 @@ public class Device {
      * {@link Build.VERSION_CODES#KITKAT KitKat} or higher, {@code false} otherwise.
      */
     public static boolean hasKitKatApi() {
-        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
+        return hasTargetApi(Build.VERSION_CODES.KITKAT);
     }
 
     /**
@@ -57,7 +102,7 @@ public class Device {
      * {@link Build.VERSION_CODES#JELLY_BEAN_MR2 Jelly Bean 4.3} or higher, {@code false} otherwise.
      */
     public static boolean hasJellyBeanMR2Api() {
-        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2;
+        return hasTargetApi(Build.VERSION_CODES.JELLY_BEAN_MR2);
     }
 
     /**
@@ -65,7 +110,7 @@ public class Device {
      * {@link Build.VERSION_CODES#JELLY_BEAN_MR1 Jelly Bean 4.2} or higher, {@code false} otherwise.
      */
     public static boolean hasJellyBeanMR1Api() {
-        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR1;
+        return hasTargetApi(Build.VERSION_CODES.JELLY_BEAN_MR1);
     }
 
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/AsyncTask.java b/project/app/src/main/java/com/achep/base/async/AsyncTask.java
similarity index 79%
rename from project/app/src/main/java/com/achep/acdisplay/AsyncTask.java
rename to project/app/src/main/java/com/achep/base/async/AsyncTask.java
index 5c1c61ea..341a129e 100644
--- a/project/app/src/main/java/com/achep/acdisplay/AsyncTask.java
+++ b/project/app/src/main/java/com/achep/base/async/AsyncTask.java
@@ -16,14 +16,17 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay;
+package com.achep.base.async;
 
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.text.TextUtils;
 import android.util.Log;
 
-import com.achep.acdisplay.utils.FileUtils;
+import com.achep.acdisplay.App;
+import com.achep.base.interfaces.IOnLowMemory;
+import com.achep.base.utils.FileUtils;
+import com.achep.base.utils.NetworkUtils;
 
 import java.io.BufferedReader;
 import java.io.IOException;
@@ -32,11 +35,13 @@ import java.io.InputStreamReader;
 import java.lang.ref.WeakReference;
 import java.net.URL;
 import java.util.ArrayList;
-import java.util.HashMap;
 import java.util.List;
+import java.util.concurrent.ConcurrentHashMap;
+
+import static com.achep.base.Build.DEBUG;
 
 /**
- * A better {@link com.achep.acdisplay.AsyncTask}.
+ * A better {@link AsyncTask}.
  *
  * @author Artem Chepurnoy
  */
@@ -48,6 +53,12 @@ public abstract class AsyncTask<A, B, C> extends android.os.AsyncTask<A, B, C> {
         }
     }
 
+    public static void stop(@Nullable android.os.AsyncTask asyncTask) {
+        if (asyncTask != null && !asyncTask.getStatus().equals(Status.FINISHED)) {
+            asyncTask.cancel(false);
+        }
+    }
+
     /**
      * Equals to calling: {@code AsyncTask.getStatus().equals(AsyncTask.Status.FINISHED)}
      */
@@ -68,16 +79,27 @@ public abstract class AsyncTask<A, B, C> extends android.os.AsyncTask<A, B, C> {
      *
      * @author Artem Chepurnoy
      */
-    public static class DownloadText extends AsyncTask<String, Void, String[]> {
+    public static class DownloadText extends AsyncTask<String, Void, String[]> implements IOnLowMemory {
 
         private static final String TAG = "DownloadText";
 
         private static final int MAX_THREAD_NUM = 5;
 
         private final WeakReference<Callback> mCallback;
-        private final HashMap<String, String> mMap;
+        private final ConcurrentHashMap<String, String> mMap;
         private final List<LoaderThread> mThreadList;
 
+        private boolean mReduceThreads = false;
+
+        /**
+         * Reduces the number of running download tasks to one.
+         * This is not possible to revert.
+         */
+        @Override
+        public void onLowMemory() {
+            mReduceThreads = true;
+        }
+
         /**
          * Interface definition for a callback to be invoked
          * when downloading finished or failed.
@@ -92,19 +114,19 @@ public abstract class AsyncTask<A, B, C> extends android.os.AsyncTask<A, B, C> {
 
         private static class LoaderThread extends Thread {
 
-            private final HashMap<String, String> mMap;
+            private final ConcurrentHashMap<String, String> mMap;
             private final String mUrl;
 
-            public LoaderThread(HashMap<String, String> map, String url) {
+            public LoaderThread(ConcurrentHashMap<String, String> map, String url) {
                 mMap = map;
                 mUrl = url;
             }
 
             @Override
             // TODO: Calculate how much downloading will take
-            // TODO: to be able to kick threads effectively.
+            // to be able to kick threads effectively.
             public void run() {
-                if (Build.DEBUG) Log.d(TAG, "Fetching from " + mUrl);
+                if (DEBUG) Log.d(TAG, "Fetching from " + mUrl);
 
                 InputStream is = null;
                 InputStreamReader isr = null;
@@ -114,12 +136,11 @@ public abstract class AsyncTask<A, B, C> extends android.os.AsyncTask<A, B, C> {
                     isr = new InputStreamReader(is);
                     br = new BufferedReader(isr);
                     String result = FileUtils.readTextFromBufferedReader(br);
-                    if (result != null) {
-                        mMap.put(mUrl, result);
-                        if (Build.DEBUG) Log.d(TAG, "Done fetching from " + mUrl);
-                    }
+
+                    mMap.put(mUrl, result);
+                    if (DEBUG) Log.d(TAG, "Done fetching from " + mUrl);
                 } catch (IOException e) {
-                    if (Build.DEBUG) Log.w(TAG, "Failed fetching from " + mUrl);
+                    if (DEBUG) Log.w(TAG, "Failed fetching from " + mUrl);
                 } finally {
                     try {
                         if (br != null) {
@@ -140,17 +161,20 @@ public abstract class AsyncTask<A, B, C> extends android.os.AsyncTask<A, B, C> {
             mCallback = new WeakReference<>(callback);
 
             int initialCapacity = Math.min(MAX_THREAD_NUM, 5);
-            mMap = new HashMap<>(initialCapacity);
+            mMap = new ConcurrentHashMap<>(initialCapacity);
             mThreadList = new ArrayList<>(initialCapacity);
         }
 
         @Override
         protected String[] doInBackground(String... urls) {
             String[] result = new String[urls.length];
+            if (!NetworkUtils.isOnline(App.get())) return result;
             for (String url : urls) {
+                if (TextUtils.isEmpty(url)) continue;
+
                 // Control the amount of running threads.
                 final int threadSize = mThreadList.size();
-                if (threadSize >= MAX_THREAD_NUM) {
+                if (mReduceThreads ? threadSize > 1 : threadSize > MAX_THREAD_NUM) {
 
                     // Search for the best candidate to be
                     // finished.
@@ -227,9 +251,7 @@ public abstract class AsyncTask<A, B, C> extends android.os.AsyncTask<A, B, C> {
             Callback callback = mCallback.get();
             if (callback != null) {
                 callback.onDownloaded(s);
-            } else {
-                if (Build.DEBUG) Log.w(TAG, "Finished loading text, but callback is null!");
-            }
+            } else if (DEBUG) Log.w(TAG, "Finished loading text, but callback is null!");
         }
     }
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/iab/cryptocoin/Bitcoin.java b/project/app/src/main/java/com/achep/base/billing/Bitcoin.java
similarity index 70%
rename from project/app/src/main/java/com/achep/acdisplay/iab/cryptocoin/Bitcoin.java
rename to project/app/src/main/java/com/achep/base/billing/Bitcoin.java
index 3e8ce530..1a3f319c 100644
--- a/project/app/src/main/java/com/achep/acdisplay/iab/cryptocoin/Bitcoin.java
+++ b/project/app/src/main/java/com/achep/base/billing/Bitcoin.java
@@ -16,14 +16,18 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.iab.cryptocoin;
+package com.achep.base.billing;
 
 import android.net.Uri;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.StringRes;
 
 import com.achep.acdisplay.R;
+import com.achep.base.interfaces.ICoin;
 
 /**
- * An implementation of Bitcoin.
+ * Bitcoin's very basics.
  * <p></p>
  * Bitcoin is a peer-to-peer payment system introduced as open source
  * software in 2009 by developer Satoshi Nakamoto. The digital currency
@@ -31,58 +35,84 @@ import com.achep.acdisplay.R;
  * alternatively referred to as a virtual currency, electronic money,
  * or cryptocurrency. The bitcoin system is not controlled by a single entity,
  * like a central bank, which has led the US Treasury to call bitcoin a
- * decentralized currency. Economists generally agree that it does not
- * meet the definition of money.
+ * decentralized currency.
  *
  * @author Artem Chepurnoy
  */
-public class Bitcoin extends Coin {
+public class Bitcoin implements ICoin {
 
-    private static final String DONATION_KEY = "1GYj49ZnMByKj2f6p7r4f92GQi5pR6BSMz";
-    private static final double DONATION_AMOUNT = 0.005;
-
-    @Override
-    public int getId() {
-        return 0;
-    }
+    private static final String KEY = "1GYj49ZnMByKj2f6p7r4f92GQi5pR6BSMz";
+    private static final double AMOUNT = 0.01; // BTC
 
+    /**
+     * {@inheritDoc}
+     */
+    @DrawableRes
     @Override
     public int getIconResource() {
         return 0;
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @StringRes
     @Override
     public int getNameResource() {
         return R.string.bitcoin;
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @NonNull
     @Override
     public String getPaymentKey() {
-        return DONATION_KEY;
+        return KEY;
     }
 
+    /**
+     * {@inheritDoc}
+     */
     @Override
     public double getPaymentAmount() {
-        return DONATION_AMOUNT;
+        return AMOUNT;
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @NonNull
     @Override
     public Uri getPaymentUri(double amount) {
         return Uri.parse("bitcoin:" + getPaymentKey() + "?amount=" + Double.toString(amount));
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @NonNull
     @Override
     public Uri getUriBrowseWallet() {
         return Uri.parse("https://www.biteasy.com/blockchain/addresses/" + getPaymentKey());
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @NonNull
     @Override
-    public Uri getUriWiki() {
+    public Uri getUriWhatIsIt() {
         return Uri.parse("http://www.youtube.com/watch?v=Um63OQz3bjo");
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @NonNull
     @Override
     public Uri getUriTutorial() {
         return Uri.parse("https://www.trybtc.com/");
     }
+
 }
diff --git a/project/app/src/main/java/com/achep/base/billing/PayPal.java b/project/app/src/main/java/com/achep/base/billing/PayPal.java
new file mode 100644
index 00000000..10cf2d28
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/billing/PayPal.java
@@ -0,0 +1,124 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.billing;
+
+import android.net.Uri;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.StringRes;
+
+import com.achep.acdisplay.R;
+import com.achep.base.interfaces.ICoin;
+
+/**
+ * PayPal's very basics.
+ * <p></p>
+ * PayPal is an American, international digital wallet based e-commerce
+ * business allowing payments and money transfers to be made through the Internet.
+ * Online money transfers serve as electronic alternatives to paying with
+ * traditional paper methods, such as checks and money orders.<br/>
+ * PayPal is one of the world's largest internet payment companies.
+ * The company operates as an acquirer, performing payment processing for
+ * online vendors, auction sites and other commercial users, for which it charges a fee.
+ *
+ * @author Artem Chepurnoy
+ */
+public class PayPal implements ICoin {
+
+    private static final String KEY = "donations.achep@gmail.com";
+    private static final double AMOUNT = 0; // Let user choose the amount
+
+    /**
+     * {@inheritDoc}
+     */
+    @DrawableRes
+    @Override
+    public int getIconResource() {
+        return 0;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @StringRes
+    @Override
+    public int getNameResource() {
+        return R.string.paypal;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @NonNull
+    @Override
+    public String getPaymentKey() {
+        return KEY;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public double getPaymentAmount() {
+        return AMOUNT;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @NonNull
+    @Override
+    public Uri getPaymentUri(double amount) {
+        StringBuilder builder = new StringBuilder();
+        builder.append("https://www.paypal.com/cgi-bin/webscr?cmd=_donations");
+        builder.append("&lc=US&item_name=Artem%20Chepurnoy");
+        builder.append("&business=").append(getPaymentKey());
+        if (amount > 0) builder.append("&amount=").append(amount);
+        return Uri.parse(builder.toString());
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Nullable
+    @Override
+    public Uri getUriBrowseWallet() {
+        return null;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @NonNull
+    @Override
+    public Uri getUriWhatIsIt() {
+        return Uri.parse("https://www.youtube.com/watch?v=c_A6OOzndt8");
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @NonNull
+    @Override
+    public Uri getUriTutorial() {
+        return Uri.parse("http://www.wikihow.com/Use-PayPal");
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/base/content/ConfigBase.java b/project/app/src/main/java/com/achep/base/content/ConfigBase.java
new file mode 100644
index 00000000..c89502ea
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/content/ConfigBase.java
@@ -0,0 +1,518 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.content;
+
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.preference.Preference;
+import android.preference.PreferenceScreen;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+import com.achep.base.Device;
+import com.achep.base.interfaces.IOnLowMemory;
+import com.achep.base.interfaces.ISubscriptable;
+
+import org.apache.commons.lang.builder.EqualsBuilder;
+import org.apache.commons.lang.builder.HashCodeBuilder;
+
+import java.lang.ref.SoftReference;
+import java.lang.ref.WeakReference;
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+import java.util.ArrayList;
+import java.util.HashMap;
+
+import static com.achep.base.Build.DEBUG;
+
+/**
+ * Saves all the configurations for the app.
+ *
+ * @author Artem Chepurnoy
+ * @since 21.01.14
+ */
+@SuppressWarnings("ConstantConditions")
+public abstract class ConfigBase implements
+        ISubscriptable<ConfigBase.OnConfigChangedListener>,
+        IOnLowMemory {
+
+    private static final String TAG = "Config";
+
+    protected static final String PREFERENCES_FILE_NAME = "config";
+
+    private SoftReference<HashMap<String, Option>> mHashMapRef = new SoftReference<>(null);
+    private final ArrayList<WeakReference<OnConfigChangedListener>> mListenersRefs = new ArrayList<>(6);
+    private Context mContext;
+
+    /**
+     * Interface definition for a callback to be invoked
+     * when a config is changed.
+     */
+    public interface OnConfigChangedListener {
+
+        /**
+         * Callback that the config has changed.
+         *
+         * @param config an instance of config
+         * @param value  a new value of changed option
+         */
+        public void onConfigChanged(
+                @NonNull ConfigBase config,
+                @NonNull String key,
+                @NonNull Object value);
+
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onLowMemory() {
+        mHashMapRef.clear(); // it will be recreated in #getHashMap().
+    }
+
+    /**
+     * Adds new {@link java.lang.ref.WeakReference weak} listener to the config. Make sure you call
+     * {@link #unregisterListener(ConfigBase.OnConfigChangedListener)} later!
+     *
+     * @param listener a listener to register to config changes.
+     * @see #unregisterListener(ConfigBase.OnConfigChangedListener)
+     */
+    @Override
+    public final void registerListener(@NonNull OnConfigChangedListener listener) {
+        // Make sure to register listener only once.
+        for (WeakReference<OnConfigChangedListener> ref : mListenersRefs) {
+            if (ref.get() == listener) {
+                Log.w(TAG, "Tried to register already registered listener!");
+                return;
+            }
+        }
+
+        mListenersRefs.add(new WeakReference<>(listener));
+    }
+
+    /**
+     * Un-registers listener is there's one.
+     *
+     * @param listener a listener to unregister from config changes.
+     * @see #registerListener(ConfigBase.OnConfigChangedListener)
+     */
+    @Override
+    public final void unregisterListener(@NonNull OnConfigChangedListener listener) {
+        for (WeakReference<OnConfigChangedListener> ref : mListenersRefs) {
+            if (ref.get() == listener) {
+                mListenersRefs.remove(ref);
+                return;
+            }
+        }
+
+        Log.w(TAG, "Tried to unregister non-existent listener!");
+    }
+
+    /**
+     * @return the {@link java.util.HashMap HashMap} with option's keys as the keys, and
+     * its {@link Option data} as the values.
+     * @see #onCreateHashMap(java.util.HashMap)
+     */
+    @NonNull
+    public final HashMap<String, Option> getHashMap() {
+        HashMap<String, Option> hashMap = mHashMapRef.get();
+        if (hashMap == null) {
+            hashMap = new HashMap<>();
+            onCreateHashMap(hashMap);
+            mHashMapRef = new SoftReference<>(hashMap);
+        }
+        return hashMap;
+    }
+
+    /**
+     * You may get a context from here only on
+     * {@link ConfigBase.OnConfigChangedListener#onConfigChanged(ConfigBase, String, Object) config change}.
+     */
+    public Context getContext() {
+        return mContext;
+    }
+
+    //-- INTERNAL METHODS -----------------------------------------------------
+
+    protected void reset(@NonNull Context context) {
+        SharedPreferences prefs = getSharedPreferences(context);
+        prefs.edit().clear().apply();
+        // TODO: Notify about those changes.
+    }
+
+    /**
+     * Gets an instance of the shared preferences of {@link #PREFERENCES_FILE_NAME}. By
+     * default, the name is {@link #PREFERENCES_FILE_NAME}.
+     */
+    @NonNull
+    protected SharedPreferences getSharedPreferences(@NonNull Context context) {
+        return context.getSharedPreferences(PREFERENCES_FILE_NAME, Context.MODE_PRIVATE);
+    }
+
+    /**
+     * Fills the {@link java.util.HashMap hash map} with config's options.
+     *
+     * @see #getHashMap()
+     */
+    protected abstract void onCreateHashMap(@NonNull HashMap<String, Option> hashMap);
+
+    protected void saveOption(@NonNull Context context,
+                              @NonNull String key, @NonNull Object value,
+                              @Nullable OnConfigChangedListener listenerToBeIgnored,
+                              boolean changed) {
+        if (!changed) {
+            // The change is a lie!
+            return;
+        }
+
+        if (DEBUG) Log.d(TAG, "Writing \"" + key + "=" + value + "\" to config.");
+
+        SharedPreferences.Editor editor = getSharedPreferences(context).edit();
+        if (value instanceof Boolean) {
+            editor.putBoolean(key, (Boolean) value);
+        } else if (value instanceof Integer) {
+            editor.putInt(key, (Integer) value);
+        } else if (value instanceof Float) {
+            editor.putFloat(key, (Float) value);
+        } else if (value instanceof String) {
+            editor.putString(key, (String) value);
+        } else throw new IllegalArgumentException("Unknown option\'s type.");
+        editor.apply();
+
+        mContext = context;
+        notifyConfigChanged(key, value, listenerToBeIgnored);
+        mContext = null;
+    }
+
+    /**
+     * @param key   the key of the option
+     * @param value the new value
+     * @see ConfigBase.OnConfigChangedListener#onConfigChanged(ConfigBase, String, Object)
+     */
+    private void notifyConfigChanged(@NonNull String key, @NonNull Object value,
+                                     @Nullable OnConfigChangedListener listenerToBeIgnored) {
+        for (int i = mListenersRefs.size() - 1; i >= 0; i--) {
+            WeakReference<OnConfigChangedListener> ref = mListenersRefs.get(i);
+            OnConfigChangedListener l = ref.get();
+
+            if (l == null) {
+                // There were no links to this listener except
+                // our class.
+                Log.w(TAG, "Deleting an addled listener..!");
+                mListenersRefs.remove(i);
+            } else if (l != listenerToBeIgnored) {
+                l.onConfigChanged(this, key, value);
+            }
+        }
+    }
+
+    //-- SYNCER ---------------------------------------------------------------
+
+    /**
+     * A class that syncs {@link android.preference.Preference} with its
+     * value in config.
+     *
+     * @author Artem Chepurnoy
+     */
+    public static class Syncer {
+
+        private final ArrayList<Group> mGroups;
+        private final Context mContext;
+        private final ConfigBase mConfig;
+
+        private boolean mBroadcasting;
+        private boolean mStarted;
+
+        private final Preference.OnPreferenceChangeListener mPreferenceListener =
+                new Preference.OnPreferenceChangeListener() {
+
+                    @Override
+                    public boolean onPreferenceChange(Preference preference, Object newValue) {
+                        if (mBroadcasting) {
+                            return true;
+                        }
+
+                        Group group = null;
+                        for (Group c : mGroups) {
+                            if (preference == c.preference) {
+                                group = c;
+                                break;
+                            }
+                        }
+
+                        assert group != null;
+
+                        newValue = group.setter.getValue(newValue);
+                        group.option.write(mConfig, mContext, newValue, mConfigListener);
+                        group.setter.updateSummary(group.preference, group.option, newValue);
+                        return true;
+                    }
+
+                };
+
+        private final OnConfigChangedListener mConfigListener =
+                new OnConfigChangedListener() {
+
+                    @Override
+                    public void onConfigChanged(@NonNull ConfigBase config, @NonNull String key,
+                                                @NonNull Object value) {
+                        Group group = null;
+                        for (Group c : mGroups) {
+                            if (key.equals(c.preference.getKey())) {
+                                group = c;
+                                break;
+                            }
+                        }
+
+                        if (group == null) {
+                            return;
+                        }
+
+                        setPreferenceValue(group, value);
+                    }
+
+                };
+
+        private void setPreferenceValue(@NonNull Group group, @NonNull Object value) {
+            mBroadcasting = true;
+            group.setter.setValue(group.preference, group.option, value);
+            group.setter.updateSummary(group.preference, group.option, value);
+            mBroadcasting = false;
+        }
+
+        public interface Setter {
+
+            void updateSummary(@NonNull Preference preference,
+                               @NonNull Option option,
+                               @NonNull Object value);
+
+            /**
+             * Sets new value to the preference.
+             *
+             * @param preference preference to set to
+             * @param option     the changed option
+             * @param value      new value to set
+             */
+            void setValue(@NonNull Preference preference,
+                          @NonNull Option option,
+                          @NonNull Object value);
+
+            @NonNull
+            Object getValue(@NonNull Object value);
+
+        }
+
+        /**
+         * A class-merge of {@link android.preference.Preference}
+         * and its {@link ConfigBase.Option}.
+         *
+         * @author Artem Chepurnoy
+         */
+        private final static class Group {
+            final Preference preference;
+            final Setter setter;
+            final Option option;
+
+            public Group(@NonNull ConfigBase config,
+                         @NonNull Preference preference,
+                         @NonNull Setter setter) {
+                this.preference = preference;
+                this.setter = setter;
+                this.option = config.getHashMap().get(preference.getKey());
+            }
+        }
+
+        public Syncer(@NonNull Context context, @NonNull ConfigBase config) {
+            mGroups = new ArrayList<>(10);
+            mContext = context;
+            mConfig = config;
+        }
+
+        @NonNull
+        public Syncer addPreference(@Nullable PreferenceScreen preferenceScreen,
+                                    @NonNull Preference preference,
+                                    @NonNull Setter setter) {
+            Group group = new Group(mConfig, preference, setter);
+            addPreference(preferenceScreen, preference, group);
+            return this;
+        }
+
+        private void addPreference(@Nullable PreferenceScreen preferenceScreen,
+                                   @NonNull Preference preference,
+                                   Group group) {
+
+            // Remove preference from preference screen
+            // if needed.
+            if (preferenceScreen != null) {
+                if (Device.hasTargetApi(group.option.maxSdkVersion + 1)
+                        || !Device.hasTargetApi(group.option.minSdkVersion)) {
+                    preferenceScreen.removePreference(preference);
+                    return;
+                }
+            }
+
+            mGroups.add(group);
+
+            if (mStarted) {
+                startListeningGroup(group);
+            }
+
+        }
+
+        /**
+         * Updates all preferences and starts to listen to the changes.
+         */
+        public void start() {
+            mStarted = true;
+            mConfig.registerListener(mConfigListener);
+            for (Group group : mGroups) {
+                startListeningGroup(group);
+            }
+        }
+
+        private void startListeningGroup(@NonNull Group group) {
+            group.preference.setOnPreferenceChangeListener(mPreferenceListener);
+            setPreferenceValue(group, group.option.read(mConfig));
+        }
+
+        /**
+         * Stops to listen to the changes.
+         */
+        public void stop() {
+            mStarted = false;
+            mConfig.unregisterListener(mConfigListener);
+            for (Group group : mGroups) {
+                group.preference.setOnPreferenceChangeListener(null);
+            }
+        }
+    }
+
+    /**
+     * @author Artem Chepurnoy
+     */
+    public static class Option {
+
+        private final String setterName;
+        private final String getterName;
+        private final Class clazz;
+        private final int minSdkVersion;
+        private final int maxSdkVersion;
+
+        public Option(@NonNull String setterName,
+                      @NonNull String getterName,
+                      @NonNull Class clazz) {
+            this(setterName, getterName, clazz, 0, Integer.MAX_VALUE - 1);
+        }
+
+        public Option(@NonNull String setterName,
+                      @NonNull String getterName,
+                      @NonNull Class clazz, int minSdkVersion, int maxSdkVersion) {
+            this.setterName = setterName;
+            this.getterName = getterName;
+            this.clazz = clazz;
+            this.minSdkVersion = minSdkVersion;
+            this.maxSdkVersion = maxSdkVersion;
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public int hashCode() {
+            return new HashCodeBuilder(11, 31)
+                    .append(setterName)
+                    .append(getterName)
+                    .append(clazz)
+                    .toHashCode();
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public boolean equals(Object o) {
+            if (o == null)
+                return false;
+            if (o == this)
+                return true;
+            if (!(o instanceof Option))
+                return false;
+
+            Option option = (Option) o;
+            return new EqualsBuilder()
+                    .append(setterName, option.setterName)
+                    .append(getterName, option.getterName)
+                    .append(clazz, option.clazz)
+                    .isEquals();
+        }
+
+        /**
+         * Reads an option from given config instance.</br>
+         * Reading is done using reflections!
+         *
+         * @param config a config to read from.
+         * @throws RuntimeException if failed to read given config.
+         */
+        @NonNull
+        public final Object read(@NonNull ConfigBase config) {
+            Object configInstance = getConfigInstance(config);
+            Class configClass = configInstance.getClass();
+            try {
+                Method method = configClass.getDeclaredMethod(getterName);
+                method.setAccessible(true);
+                return method.invoke(configInstance);
+            } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
+                throw new RuntimeException("Failed to access " + clazz.getName() + "." + getterName + " method.");
+            }
+        }
+
+        /**
+         * Writes new value to the option to given config instance.</br>
+         * Writing is done using reflections!
+         *
+         * @param config a config to write to.
+         * @throws RuntimeException if failed to read given config.
+         */
+        public final void write(@NonNull ConfigBase config, @NonNull Context context,
+                                @NonNull Object newValue, @Nullable OnConfigChangedListener listener) {
+            Object configInstance = getConfigInstance(config);
+            Class configClass = configInstance.getClass();
+            try {
+                Method method = configClass.getDeclaredMethod(setterName,
+                        Context.class, clazz,
+                        ConfigBase.OnConfigChangedListener.class);
+                method.setAccessible(true);
+                method.invoke(configInstance, context, newValue, listener);
+            } catch (NoSuchMethodException | InvocationTargetException | IllegalAccessException e) {
+                throw new RuntimeException("Failed to access " + clazz.getName() + "#" + setterName + "(***) method.");
+            }
+        }
+
+        @NonNull
+        protected Object getConfigInstance(@NonNull ConfigBase config) {
+            // This method is needed to be able to create options from
+            // other classes, not only Config.
+            return config;
+        }
+
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/SharedList.java b/project/app/src/main/java/com/achep/base/content/SharedList.java
similarity index 90%
rename from project/app/src/main/java/com/achep/acdisplay/SharedList.java
rename to project/app/src/main/java/com/achep/base/content/SharedList.java
index 25fef81f..64552364 100644
--- a/project/app/src/main/java/com/achep/acdisplay/SharedList.java
+++ b/project/app/src/main/java/com/achep/base/content/SharedList.java
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay;
+package com.achep.base.content;
 
 import android.content.Context;
 import android.content.SharedPreferences;
@@ -24,10 +24,13 @@ import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Log;
 
-import com.achep.acdisplay.interfaces.IOnLowMemory;
+import com.achep.base.Build;
+import com.achep.base.interfaces.IOnLowMemory;
+import com.achep.base.interfaces.ISubscriptable;
 
 import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.Iterator;
 import java.util.Set;
 
 /**
@@ -36,17 +39,19 @@ import java.util.Set;
  *
  * @author Artem Chepurnoy
  */
-public abstract class SharedList<V, T extends SharedList.Saver<V>> implements IOnLowMemory {
+public abstract class SharedList<V, T extends SharedList.Saver<V>> implements
+        ISubscriptable<SharedList.OnSharedListChangedListener<V>>,
+        IOnLowMemory, Iterable<V> {
 
     private static final String TAG = "SharedList";
 
     /**
      * Key's prefix for SharedList's internal usage.
      */
-    public static final String KEY_PREFIX = "__";
+    private static final String KEY_PREFIX = "__";
 
-    public static final String KEY_NUMBER = KEY_PREFIX + "n";
-    public static final String KEY_USED_ITEM = KEY_PREFIX + "used_";
+    private static final String KEY_NUMBER = KEY_PREFIX + "n";
+    private static final String KEY_USED_ITEM = KEY_PREFIX + "used_";
 
     private HashMap<V, Integer> mList;
     private ArrayList<Integer> mPlaceholder;
@@ -118,6 +123,7 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> implements IO
          * @param position position of given object in list
          * @see #get(android.content.SharedPreferences, int)
          */
+        @NonNull
         public abstract SharedPreferences.Editor put(@NonNull V object,
                                                      @NonNull SharedPreferences.Editor editor,
                                                      int position);
@@ -138,6 +144,7 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> implements IO
      * @see #unregisterListener(SharedList.OnSharedListChangedListener)
      * @see SharedList.OnSharedListChangedListener
      */
+    @Override
     public void registerListener(@NonNull OnSharedListChangedListener<V> listener) {
         mListeners.add(listener);
     }
@@ -148,6 +155,7 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> implements IO
      * @see #registerListener(SharedList.OnSharedListChangedListener)
      * @see SharedList.OnSharedListChangedListener
      */
+    @Override
     public void unregisterListener(@NonNull OnSharedListChangedListener<V> listener) {
         mListeners.remove(listener);
     }
@@ -158,7 +166,7 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> implements IO
         init(context);
     }
 
-    protected void init(Context context) {
+    protected void init(@NonNull Context context) {
         mList = new HashMap<>();
         mPlaceholder = new ArrayList<>(3);
         mListeners = new ArrayList<>(6);
@@ -181,6 +189,7 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> implements IO
         }
     }
 
+    @NonNull
     private SharedPreferences getSharedPreferences(@NonNull Context context) {
         return context.getSharedPreferences(getPreferencesFileName(), Context.MODE_PRIVATE);
     }
@@ -189,12 +198,14 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> implements IO
      * @return the name of the shared list's file.
      * @see #getSharedPreferences(android.content.Context)
      */
+    @NonNull
     protected abstract String getPreferencesFileName();
 
     /**
      * @return Instance of saver which will save your Object to shared preferences.
      * @see Saver
      */
+    @NonNull
     protected abstract T onCreateSaver();
 
     /**
@@ -218,7 +229,7 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> implements IO
         return mComparator;
     }
 
-    protected boolean isOverwriteAllowed(V object) {
+    protected boolean isOverwriteAllowed(@NonNull V object) {
         return false;
     }
 
@@ -229,7 +240,7 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> implements IO
     public void onLowMemory() {
         mRecyclableCreated = false;
         // This probably won't free a lot, but
-        // we are free to do it.
+        // yes, we can do it.
         mComparator = null;
         mSaver = null;
     }
@@ -251,6 +262,7 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> implements IO
         }
 
         V objectRemoved = find(object);
+        assert objectRemoved != null; // Defined by the condition above
         int pos = mList.remove(object);
 
         // Put the position of newly removed object
@@ -335,7 +347,8 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> implements IO
         return old;
     }
 
-    private V find(V object) {
+    @Nullable
+    private V find(@NonNull V object) {
         for (V o : mList.keySet()) {
             if (o.equals(object)) {
                 return o;
@@ -351,7 +364,8 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> implements IO
      * @param objectRemoved removed object from the list
      * @param l             Listener that will be ignored while notifying.
      */
-    protected void notifyOnRemoved(V objectRemoved, OnSharedListChangedListener l) {
+    protected void notifyOnRemoved(@NonNull V objectRemoved,
+                                   @Nullable OnSharedListChangedListener l) {
         for (OnSharedListChangedListener<V> listener : mListeners) {
             if (listener == l) continue;
             listener.onRemoved(objectRemoved);
@@ -366,7 +380,7 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> implements IO
      * @param old    old object from the list
      * @param l      Listener that will be ignored while notifying.
      */
-    protected void notifyOnPut(V object, V old, OnSharedListChangedListener l) {
+    protected void notifyOnPut(V object, V old, @Nullable OnSharedListChangedListener l) {
         createRecyclableFields();
 
         int diff = mComparator != null ? mComparator.compare(object, old) : 0;
@@ -381,13 +395,21 @@ public abstract class SharedList<V, T extends SharedList.Saver<V>> implements IO
      *
      * @return {@code true} if this list contains the specified object, {@code true} otherwise.
      */
-    public boolean contains(V object) {
+    public boolean contains(@Nullable V object) {
         return mList.containsKey(object);
     }
 
     @NonNull
-    public Set<V> valuesSet() {
+    public Set<V> values() {
         return mList.keySet();
     }
 
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public Iterator<V> iterator() {
+        return values().iterator();
+    }
+
 }
diff --git a/project/app/src/main/java/com/achep/base/dashboard/DashboardCategory.java b/project/app/src/main/java/com/achep/base/dashboard/DashboardCategory.java
new file mode 100644
index 00000000..71286759
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/dashboard/DashboardCategory.java
@@ -0,0 +1,383 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.dashboard;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.util.TypedValue;
+
+import com.achep.acdisplay.R;
+
+import org.apache.commons.lang.builder.EqualsBuilder;
+import org.apache.commons.lang.builder.HashCodeBuilder;
+
+import java.util.ArrayList;
+import java.util.Collection;
+import java.util.Iterator;
+import java.util.List;
+import java.util.ListIterator;
+
+public class DashboardCategory implements Parcelable, List<DashboardTile> {
+
+    /**
+     * Default value for {@link com.achep.base.dashboard.DashboardCategory#id DashboardCategory.id}
+     * indicating that no identifier value is set.  All other values (including those below -1)
+     * are valid.
+     */
+    public static final int CAT_ID_UNDEFINED = -1;
+
+    /**
+     * Identifier for this tile, to correlate with a new list when
+     * it is updated.  The default value is
+     * {@link com.achep.base.dashboard.DashboardTile#TILE_ID_UNDEFINED}, meaning no id.
+     */
+    public long id = CAT_ID_UNDEFINED;
+
+    /**
+     * Resource ID of title of the category that is shown to the user.
+     */
+    public int titleRes;
+
+    /**
+     * Title of the category that is shown to the user.
+     */
+    public CharSequence title;
+
+    /**
+     * List of the category's children
+     */
+    public final List<DashboardTile> tiles = new ArrayList<>();
+
+    public DashboardCategory(Context context, AttributeSet attrs) {
+        TypedArray sa = context.obtainStyledAttributes(attrs, R.styleable.DashboardTile);
+
+        id = sa.getResourceId(R.styleable.DashboardTile_dashboard_id, CAT_ID_UNDEFINED);
+
+        TypedValue tv = sa.peekValue(R.styleable.DashboardTile_dashboard_title);
+        if (tv != null && tv.type == TypedValue.TYPE_STRING) {
+            if (tv.resourceId != 0) {
+                titleRes = tv.resourceId;
+            } else {
+                title = tv.string;
+            }
+        }
+
+        sa.recycle();
+    }
+
+    /**
+     * Return the currently set title. If {@link #titleRes} is set,
+     * this resource is loaded from <var>res</var> and stored in {@link #title}.
+     */
+    public CharSequence getTitle(Resources res) {
+        if (titleRes != 0) {
+            title = res.getText(titleRes);
+            titleRes = 0;
+        }
+
+        return title;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean equals(Object o) {
+        if (o == this)
+            return true;
+        if (!(o instanceof DashboardCategory))
+            return false;
+
+        DashboardCategory dc = (DashboardCategory) o;
+        return new EqualsBuilder()
+                .append(id, dc.id)
+                .append(titleRes, dc.titleRes)
+                .append(title, dc.title)
+                .append(tiles, dc.tiles)
+                .isEquals();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int hashCode() {
+        return new HashCodeBuilder(153, 11)
+                .append(id)
+                .append(titleRes)
+                .append(title)
+                .append(tiles)
+                .toHashCode();
+    }
+
+    //-- PARCELABLE IMPLEMENTATION --------------------------------------------
+
+    public static final Creator<DashboardCategory> CREATOR =
+            new Creator<DashboardCategory>() {
+
+                public DashboardCategory createFromParcel(Parcel source) {
+                    return new DashboardCategory(source);
+                }
+
+                public DashboardCategory[] newArray(int size) {
+                    return new DashboardCategory[size];
+                }
+
+            };
+
+    private DashboardCategory(Parcel in) {
+        titleRes = in.readInt();
+        title = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
+
+        final int count = in.readInt();
+
+        for (int n = 0; n < count; n++) {
+            DashboardTile tile = DashboardTile.CREATOR.createFromParcel(in);
+            tiles.add(tile);
+        }
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        if (titleRes != 0) {
+            dest.writeInt(titleRes);
+        } else {
+            TextUtils.writeToParcel(title, dest, flags);
+        }
+
+        final int count = tiles.size();
+        dest.writeInt(count);
+
+        for (int n = 0; n < count; n++) {
+            DashboardTile tile = tiles.get(n);
+            tile.writeToParcel(dest, flags);
+        }
+    }
+
+    //-- LIST IMPLEMENTATION --------------------------------------------------
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void add(int location, DashboardTile object) {
+        tiles.add(location, object);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean add(DashboardTile object) {
+        return tiles.add(object);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean addAll(int location, Collection<? extends DashboardTile> collection) {
+        return tiles.addAll(location, collection);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean addAll(Collection<? extends DashboardTile> collection) {
+        return tiles.addAll(collection);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void clear() {
+        tiles.clear();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean contains(Object object) {
+        return tiles.contains(object);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean containsAll(@NonNull Collection<?> collection) {
+        return tiles.containsAll(collection);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public DashboardTile get(int location) {
+        return tiles.get(location);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int indexOf(Object object) {
+        return tiles.indexOf(object);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isEmpty() {
+        return tiles.isEmpty();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @NonNull
+    @Override
+    public Iterator<DashboardTile> iterator() {
+        return tiles.iterator();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int lastIndexOf(Object object) {
+        return tiles.lastIndexOf(object);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @NonNull
+    @Override
+    public ListIterator<DashboardTile> listIterator() {
+        return tiles.listIterator();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @NonNull
+    @Override
+    public ListIterator<DashboardTile> listIterator(int location) {
+        return tiles.listIterator(location);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public DashboardTile remove(int location) {
+        return tiles.remove(location);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean remove(Object object) {
+        return tiles.remove(object);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean removeAll(@NonNull Collection<?> collection) {
+        return tiles.removeAll(collection);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean retainAll(@NonNull Collection<?> collection) {
+        return tiles.retainAll(collection);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public DashboardTile set(int location, DashboardTile object) {
+        return tiles.set(location, object);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int size() {
+        return tiles.size();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @NonNull
+    @Override
+    public List<DashboardTile> subList(int start, int end) {
+        return tiles.subList(start, end);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @NonNull
+    @Override
+    public Object[] toArray() {
+        return tiles.toArray();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @SuppressWarnings("SuspiciousToArrayCall")
+    @NonNull
+    @Override
+    public <T> T[] toArray(@NonNull T[] array) {
+        return tiles.toArray(array);
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/base/dashboard/DashboardTile.java b/project/app/src/main/java/com/achep/base/dashboard/DashboardTile.java
new file mode 100644
index 00000000..d36f3c89
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/dashboard/DashboardTile.java
@@ -0,0 +1,207 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.dashboard;
+
+import android.content.Context;
+import android.content.Intent;
+import android.content.res.Resources;
+import android.content.res.TypedArray;
+import android.os.Bundle;
+import android.os.Parcel;
+import android.os.Parcelable;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.util.TypedValue;
+
+import com.achep.acdisplay.R;
+
+/**
+ * Description of a single dashboard tile that the user can select.
+ */
+public class DashboardTile implements Parcelable {
+
+    /**
+     * Default value for {@link com.achep.base.dashboard.DashboardTile#id DashboardTile.id}
+     * indicating that no identifier value is set. All other values (including those below -1)
+     * are valid.
+     */
+    public static final int TILE_ID_UNDEFINED = -1;
+
+    /**
+     * Identifier for this tile, to correlate with a new list when
+     * it is updated.  The default value is
+     * {@link #TILE_ID_UNDEFINED}, meaning no id.
+     */
+    public long id = TILE_ID_UNDEFINED;
+
+    /**
+     * Resource ID of title of the tile that is shown to the user.
+     */
+    public int titleRes;
+
+    /**
+     * Title of the tile that is shown to the user.
+     */
+    public CharSequence title;
+
+    /**
+     * Resource ID of optional summary describing what this tile controls.
+     */
+    public int summaryRes;
+
+    /**
+     * Optional summary describing what this tile controls.
+     */
+    public CharSequence summary;
+
+    /**
+     * Optional icon resource to show for this tile.
+     */
+    public final int iconRes;
+
+    /**
+     * Full class name of the fragment to display when this tile is
+     * selected.
+     */
+    public final String fragment;
+
+    /**
+     * Optional arguments to supply to the fragment when it is
+     * instantiated.
+     */
+    public Bundle fragmentArguments;
+
+    /**
+     * Intent to launch when the preference is selected.
+     */
+    public Intent intent;
+
+    /**
+     * Optional additional data for use by subclasses of the activity
+     */
+    public Bundle extras;
+
+    public DashboardTile(Context context, AttributeSet attrs) {
+        TypedArray sa = context.obtainStyledAttributes(attrs, R.styleable.DashboardTile);
+        TypedValue tv;
+
+        id = sa.getResourceId(R.styleable.DashboardTile_dashboard_id, TILE_ID_UNDEFINED);
+        iconRes = sa.getResourceId(R.styleable.DashboardTile_dashboard_icon, 0);
+        fragment = sa.getString(R.styleable.DashboardTile_dashboard_fragment);
+
+        tv = sa.peekValue(R.styleable.DashboardTile_dashboard_title);
+        if (tv != null && tv.type == TypedValue.TYPE_STRING) {
+            if (tv.resourceId != 0) {
+                titleRes = tv.resourceId;
+            } else {
+                title = tv.string;
+            }
+        }
+
+        tv = sa.peekValue(R.styleable.DashboardTile_dashboard_summary);
+        if (tv != null && tv.type == TypedValue.TYPE_STRING) {
+            if (tv.resourceId != 0) {
+                summaryRes = tv.resourceId;
+            } else {
+                summary = tv.string;
+            }
+        }
+
+        sa.recycle();
+    }
+
+    /**
+     * Return the currently set title.  If {@link #titleRes} is set,
+     * this resource is loaded from <var>res</var> and returned.  Otherwise
+     * {@link #title} is returned.
+     */
+    public CharSequence getTitle(Resources res) {
+        return titleRes != 0 ? res.getText(titleRes) : title;
+    }
+
+    /**
+     * Return the currently set summary.  If {@link #summaryRes} is set,
+     * this resource is loaded from <var>res</var> and returned.  Otherwise
+     * {@link #summary} is returned.
+     */
+    public CharSequence getSummary(Resources res) {
+        return summaryRes != 0 ? res.getText(summaryRes) : summary;
+    }
+
+    //-- PARCELABLE IMPLEMENTATION --------------------------------------------
+
+    public static final Creator<DashboardTile> CREATOR =
+            new Creator<DashboardTile>() {
+
+                public DashboardTile createFromParcel(Parcel source) {
+                    return new DashboardTile(source);
+                }
+
+                public DashboardTile[] newArray(int size) {
+                    return new DashboardTile[size];
+                }
+
+            };
+
+    private DashboardTile(Parcel in) {
+        id = in.readLong();
+        titleRes = in.readInt();
+        title = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
+        summaryRes = in.readInt();
+        summary = TextUtils.CHAR_SEQUENCE_CREATOR.createFromParcel(in);
+        iconRes = in.readInt();
+        fragment = in.readString();
+        fragmentArguments = in.readBundle();
+        if (in.readInt() != 0) {
+            intent = Intent.CREATOR.createFromParcel(in);
+        }
+        extras = in.readBundle();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int describeContents() {
+        return 0;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void writeToParcel(Parcel dest, int flags) {
+        dest.writeLong(id);
+        dest.writeInt(titleRes);
+        TextUtils.writeToParcel(title, dest, flags);
+        dest.writeInt(summaryRes);
+        TextUtils.writeToParcel(summary, dest, flags);
+        dest.writeInt(iconRes);
+        dest.writeString(fragment);
+        dest.writeBundle(fragmentArguments);
+        if (intent != null) {
+            dest.writeInt(1);
+            intent.writeToParcel(dest, flags);
+        } else {
+            dest.writeInt(0);
+        }
+        dest.writeBundle(extras);
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/base/interfaces/ICheckable.java b/project/app/src/main/java/com/achep/base/interfaces/ICheckable.java
new file mode 100644
index 00000000..a2a058c4
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/interfaces/ICheckable.java
@@ -0,0 +1,31 @@
+/*
+ * Copyright (C) 2015 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.interfaces;
+
+import android.widget.Checkable;
+import android.widget.CompoundButton;
+
+/**
+ * @author Artem Chepurnoy
+ */
+public interface ICheckable extends Checkable {
+
+    void setOnCheckedChangeListener(CompoundButton.OnCheckedChangeListener listener);
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/iab/cryptocoin/Coin.java b/project/app/src/main/java/com/achep/base/interfaces/ICoin.java
similarity index 70%
rename from project/app/src/main/java/com/achep/acdisplay/iab/cryptocoin/Coin.java
rename to project/app/src/main/java/com/achep/base/interfaces/ICoin.java
index 107c3357..c386bcbc 100644
--- a/project/app/src/main/java/com/achep/acdisplay/iab/cryptocoin/Coin.java
+++ b/project/app/src/main/java/com/achep/base/interfaces/ICoin.java
@@ -1,5 +1,5 @@
 /*
- * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ * Copyright (C) 2015 AChep@xda <artemchep@gmail.com>
  *
  * This program is free software; you can redistribute it and/or
  * modify it under the terms of the GNU General Public License
@@ -16,57 +16,53 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.iab.cryptocoin;
+package com.achep.base.interfaces;
 
-import android.content.Intent;
 import android.net.Uri;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.StringRes;
 
 /**
  * Base class for simple virtual coins.
  *
  * @author Artem Chepurnoy
  */
-public abstract class Coin {
-
-    public static Intent getPaymentIntent(Coin coin) {
-        return getPaymentIntent(coin, coin.getPaymentAmount());
-    }
-
-    public static Intent getPaymentIntent(Coin coin, double amount) {
-        Uri uri = coin.getPaymentUri(amount);
-        return new Intent(Intent.ACTION_VIEW, uri);
-    }
-
-    public abstract int getId();
+public interface ICoin {
 
+    @DrawableRes
     public abstract int getIconResource();
 
+    @StringRes
     public abstract int getNameResource();
 
     /**
      * @return The receiver's key. It may be an email or just "any string".
      */
+    @NonNull
     public abstract String getPaymentKey();
 
     /**
      * @return The default amount of money.
-     * @see #getPaymentIntent(Coin)
-     * @see #getPaymentIntent(Coin, double)
      */
     public abstract double getPaymentAmount();
 
     /**
+     * @param amount the amount to send, or if {@code <= 0} blank field.
      * @return Uri to page through which you can sends me moneys.
-     * @see #getPaymentIntent(Coin)
-     * @see #getPaymentIntent(Coin, double)
+     * @see com.achep.base.utils.CoinUtils#getPaymentIntent(ICoin)
+     * @see com.achep.base.utils.CoinUtils#getPaymentIntent(ICoin, double)
      */
+    @NonNull
     public abstract Uri getPaymentUri(double amount);
 
     /**
      * @return Uri to page that shows my current money.
-     * @see #getUriWiki()
+     * @see #getUriWhatIsIt()
      * @see #getUriTutorial()
      */
+    @Nullable
     public abstract Uri getUriBrowseWallet();
 
     /**
@@ -74,13 +70,15 @@ public abstract class Coin {
      * @see #getUriBrowseWallet()
      * @see #getUriTutorial()
      */
-    public abstract Uri getUriWiki();
+    @NonNull
+    public abstract Uri getUriWhatIsIt();
 
     /**
      * @return Uri to page that explains how to use that coin: send / receive money etc.
-     * @see #getUriWiki()
+     * @see #getUriWhatIsIt()
      * @see #getUriBrowseWallet()
      */
+    @NonNull
     public abstract Uri getUriTutorial();
 
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/iab/DonationItems.java b/project/app/src/main/java/com/achep/base/interfaces/IOnLowMemory.java
similarity index 50%
rename from project/app/src/main/java/com/achep/acdisplay/iab/DonationItems.java
rename to project/app/src/main/java/com/achep/base/interfaces/IOnLowMemory.java
index 8f459876..7564d2b9 100644
--- a/project/app/src/main/java/com/achep/acdisplay/iab/DonationItems.java
+++ b/project/app/src/main/java/com/achep/base/interfaces/IOnLowMemory.java
@@ -16,38 +16,23 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.iab;
-
-import android.content.res.Resources;
-
-import com.achep.acdisplay.R;
+package com.achep.base.interfaces;
 
 /**
- * Created by achep on 07.05.14 for AcDisplay.
- *
  * @author Artem Chepurnoy
  */
-public class DonationItems {
-
-    public static Donation[] get(Resources res) {
-        int[] data = new int[]{
-                1, R.string.donation_1,
-                4, R.string.donation_4,
-                10, R.string.donation_10,
-                20, R.string.donation_20,
-                50, R.string.donation_50,
-                99, R.string.donation_99,
-        };
-
-        Donation[] donation = new Donation[data.length / 2];
-
-        int length = donation.length;
-        for (int i = 0; i < length; i++) {
-            donation[i] = new Donation(data[i * 2],
-                    res.getString(data[i * 2 + 1]));
-        }
-        return donation;
-    }
+public interface IOnLowMemory {
+
+    /**
+     * This is called when the overall system is running low on memory, and actively running
+     * processes should trim their memory usage. While the exact point at which this
+     * will be called is not defined, generally it will happen when all background process
+     * have been killed. That is, before reaching the point of killing processes hosting service
+     * and foreground UI that we would like to avoid killing.
+     * You should implement this method to release any caches or other unnecessary resources you
+     * may be holding on to. The system will perform a garbage collection for you after returning
+     * from this method.
+     */
+    public void onLowMemory();
 
 }
diff --git a/project/app/src/main/java/com/achep/base/interfaces/ISubscriptable.java b/project/app/src/main/java/com/achep/base/interfaces/ISubscriptable.java
new file mode 100644
index 00000000..80bdbcac
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/interfaces/ISubscriptable.java
@@ -0,0 +1,43 @@
+/*
+ * Copyright (C) 2015 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.interfaces;
+
+import android.support.annotation.NonNull;
+
+/**
+ * Created by Artem Chepurnoy on 10.01.2015.
+ *
+ * @author Artem Chepurnoy
+ */
+public interface ISubscriptable<T> {
+
+    /**
+     * Register a listener to something. Don't forget to
+     * {@link #unregisterListener(Object) unregister} it later!
+     *
+     * @see #unregisterListener(Object)
+     */
+    void registerListener(@NonNull T listener);
+
+    /**
+     * @see #registerListener(Object)
+     */
+    void unregisterListener(@NonNull T listener);
+
+}
diff --git a/project/app/src/main/java/com/achep/base/interfaces/ITimeout.java b/project/app/src/main/java/com/achep/base/interfaces/ITimeout.java
new file mode 100644
index 00000000..f849671c
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/interfaces/ITimeout.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2015 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.interfaces;
+
+/**
+ * Created by Artem Chepurnoy on 08.01.2015.
+ */
+public interface ITimeout {
+}
diff --git a/project/app/src/main/java/com/achep/base/providers/LogsProviderBase.java b/project/app/src/main/java/com/achep/base/providers/LogsProviderBase.java
new file mode 100644
index 00000000..b8c6b7b7
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/providers/LogsProviderBase.java
@@ -0,0 +1,137 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.providers;
+
+import android.content.ContentProvider;
+import android.content.ContentValues;
+import android.database.Cursor;
+import android.database.MatrixCursor;
+import android.net.Uri;
+import android.os.ParcelFileDescriptor;
+import android.provider.OpenableColumns;
+import android.util.Log;
+
+import java.io.File;
+import java.io.FileNotFoundException;
+import java.util.List;
+
+/**
+ * Created by achep on 16.06.14.
+ */
+public abstract class LogsProviderBase extends ContentProvider {
+
+    private static final String TAG = "LogsProvider";
+    private static final String COLUMN_DATA = "_data";
+
+    public static final String DIRECTORY = "logs";
+
+    @Override
+    public boolean onCreate() {
+        return true;
+    }
+
+    @Override
+    public Cursor query(Uri uri, String[] projection, String selection,
+                        String[] selectionArgs, String orderBy) {
+        final List<String> pathSegments = uri.getPathSegments();
+        final String fileName = pathSegments.get(0);
+        File logFile;
+
+        logFile = getContext().getCacheDir();
+        if (logFile == null) {
+            Log.e(TAG, "No cache dir.");
+            return null;
+        }
+
+        logFile = new File(new File(logFile, DIRECTORY), fileName);
+        if (!logFile.exists()) {
+            Log.e(TAG, "Requested log file doesn't exist.");
+            return null;
+        }
+
+        if (projection == null) {
+            projection = new String[]{
+                    COLUMN_DATA,
+                    OpenableColumns.DISPLAY_NAME,
+                    OpenableColumns.SIZE,
+            };
+        }
+
+        MatrixCursor matrixCursor = new MatrixCursor(projection, 1);
+        Object[] row = new Object[projection.length];
+        for (int col = 0; col < projection.length; col++) {
+            switch (projection[col]) {
+                case COLUMN_DATA:
+                    row[col] = logFile.getAbsolutePath();
+                    break;
+                case OpenableColumns.DISPLAY_NAME:
+                    row[col] = fileName;
+                    break;
+                case OpenableColumns.SIZE:
+                    row[col] = logFile.length();
+                    break;
+            }
+        }
+        matrixCursor.addRow(row);
+        return matrixCursor;
+    }
+
+    @Override
+    public ParcelFileDescriptor openFile(Uri uri, String mode)
+            throws FileNotFoundException {
+        return openFileHelper(uri, "r");
+    }
+
+    @Override
+    public String getType(Uri uri) {
+        return "text/plain";
+    }
+
+    /**
+     * Not supported!
+     *
+     * @throws UnsupportedOperationException
+     */
+    @Override
+    public Uri insert(Uri uri, ContentValues values) {
+        throw new UnsupportedOperationException("Insert is not supported!");
+    }
+
+    /**
+     * Not supported!
+     *
+     * @throws UnsupportedOperationException
+     */
+    @Override
+    public int delete(Uri uri, String selection, String[] selectionArgs) {
+        throw new UnsupportedOperationException("Delete is not supported!");
+    }
+
+    /**
+     * Not supported!
+     *
+     * @throws UnsupportedOperationException
+     */
+    @Override
+    public int update(Uri uri, ContentValues contentValues, String selection,
+                      String[] selectionArgs) {
+        throw new UnsupportedOperationException("Update is not supported!");
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/base/ui/DialogBuilder.java b/project/app/src/main/java/com/achep/base/ui/DialogBuilder.java
new file mode 100644
index 00000000..7347ae83
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/ui/DialogBuilder.java
@@ -0,0 +1,315 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.ui;
+
+import android.app.AlertDialog;
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.LayoutRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.StringRes;
+import android.text.TextUtils;
+import android.text.method.LinkMovementMethod;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.view.ViewStub;
+import android.widget.FrameLayout;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import com.achep.acdisplay.R;
+import com.achep.base.Device;
+
+import org.apache.commons.lang.builder.EqualsBuilder;
+import org.apache.commons.lang.builder.HashCodeBuilder;
+
+/**
+ * Helper class to implement custom dialog's design.
+ */
+public class DialogBuilder {
+
+    /**
+     * Layout where content's layout exists in a {@link android.widget.ScrollView}.
+     * This is nice to display simple layout without scrollable elements such as
+     * {@link android.widget.ListView} or any similar. Use {@link #LAYOUT_SKELETON}
+     * for them.
+     *
+     * @see #LAYOUT_SKELETON
+     * @see #createView()
+     * @see #createAlertDialogBuilder(int)
+     */
+    public static final int LAYOUT_COMMON = 0;
+
+    /**
+     * The skeleton of dialog's layout. The only thing that is here is the custom
+     * view you set and the title / icon. Use it to display scrollable elements such as
+     * {@link android.widget.ListView}.
+     *
+     * @see #LAYOUT_COMMON
+     * @see #createSkeletonView()
+     * @see #createAlertDialogBuilder(int)
+     */
+    public static final int LAYOUT_SKELETON = 1;
+
+    protected final Context mContext;
+
+    private Drawable mIcon;
+    private CharSequence mTitleText;
+    private CharSequence mMessageText;
+    private View mView;
+    private int mViewRes;
+    private int mContentViewRes;
+
+    public DialogBuilder(@NonNull Context context) {
+        mContext = context;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int hashCode() {
+        return new HashCodeBuilder(201, 17)
+                .append(mContext)
+                .append(mIcon)
+                .append(mTitleText)
+                .append(mMessageText)
+                .append(mViewRes)
+                .append(mView)
+                .toHashCode();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean equals(Object o) {
+        if (o == null)
+            return false;
+        if (o == this)
+            return true;
+        if (!(o instanceof DialogBuilder))
+            return false;
+
+        DialogBuilder builder = (DialogBuilder) o;
+        return new EqualsBuilder()
+                .append(mContext, builder.mContext)
+                .append(mIcon, builder.mIcon)
+                .append(mTitleText, builder.mTitleText)
+                .append(mMessageText, builder.mMessageText)
+                .append(mViewRes, builder.mViewRes)
+                .append(mView, builder.mView)
+                .isEquals();
+    }
+
+    /**
+     * Sets the icon of the title.
+     *
+     * @see #setIcon(int)
+     */
+    @NonNull
+    public DialogBuilder setIcon(@Nullable Drawable icon) {
+        mIcon = icon;
+        return this;
+    }
+
+    /**
+     * Sets the icon of the title.
+     *
+     * @see #setIcon(android.graphics.drawable.Drawable)
+     */
+    @NonNull
+    public DialogBuilder setIcon(@DrawableRes int drawableResource) {
+        Resources res = mContext.getResources();
+        return setIcon(drawableResource == 0
+                ? null
+                : res.getDrawable(drawableResource));
+    }
+
+    /**
+     * Sets the title text.
+     *
+     * @see #setTitle(int)
+     * @see #setIcon(int)
+     */
+    @NonNull
+    public DialogBuilder setTitle(@Nullable CharSequence title) {
+        mTitleText = title;
+        return this;
+    }
+
+    /**
+     * Sets the title text.
+     *
+     * @see #setTitle(CharSequence)
+     * @see #setIcon(android.graphics.drawable.Drawable)
+     */
+    @NonNull
+    public DialogBuilder setTitle(@StringRes int titleRes) {
+        return setTitle(titleRes == 0
+                ? null
+                : getString(titleRes));
+    }
+
+    @NonNull
+    public DialogBuilder setMessage(@Nullable CharSequence message) {
+        mMessageText = message;
+        return this;
+    }
+
+    @NonNull
+    public DialogBuilder setMessage(@StringRes int messageRes) {
+        return setMessage(messageRes == 0
+                ? null
+                : getString(messageRes));
+    }
+
+    private String getString(int stringRes) {
+        return mContext.getResources().getString(stringRes);
+    }
+
+    public DialogBuilder setView(View view) {
+        mView = view;
+        mViewRes = 0;
+        return this;
+    }
+
+    public DialogBuilder setView(@LayoutRes int layoutRes) {
+        mView = null;
+        mViewRes = layoutRes;
+        return this;
+    }
+
+    public DialogBuilder setContentView(@LayoutRes int layoutRes) {
+        mContentViewRes = layoutRes;
+        return this;
+    }
+
+    //-- CREATING VIEW --------------------------------------------------------
+
+    public View createView() {
+        return createView(LAYOUT_COMMON);
+    }
+
+    public View createSkeletonView() {
+        return createView(LAYOUT_SKELETON);
+    }
+
+    /**
+     * Builds dialog's view
+     *
+     * @throws IllegalArgumentException when type is not one of defined.
+     * @see #LAYOUT_COMMON
+     * @see #LAYOUT_SKELETON
+     */
+    public View createView(int type) {
+        LayoutInflater inflater = (LayoutInflater) mContext
+                .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+
+        ViewGroup rootLayout = (ViewGroup) createSkeleton();
+        ViewGroup contentLayout = rootLayout;
+
+        switch (type) {
+            case LAYOUT_COMMON:
+                final boolean hasMessageOnly = mView == null && mViewRes == 0;
+                final int layoutResource = mContentViewRes != 0
+                        ? mContentViewRes : hasMessageOnly
+                        ? R.layout.dialog_message
+                        : R.layout.dialog_content;
+
+                ViewStub viewStub = (ViewStub) inflater
+                        .inflate(R.layout.dialog_main_body, rootLayout, true)
+                        .findViewById(R.id.placeholder);
+                viewStub.setLayoutResource(layoutResource);
+
+                contentLayout = (ViewGroup) viewStub.inflate().findViewById(R.id.content);
+                if (contentLayout == null) contentLayout = rootLayout;
+                TextView messageView = (TextView) contentLayout.findViewById(R.id.message);
+
+                if (messageView != null) {
+                    if (!TextUtils.isEmpty(mMessageText)) {
+                        messageView.setMovementMethod(new LinkMovementMethod());
+                        messageView.setText(mMessageText);
+                    } else {
+                        ViewGroup vg = (ViewGroup) messageView.getParent();
+                        vg.removeView(messageView);
+                    }
+                }
+
+                // Fall down.
+            case LAYOUT_SKELETON:
+
+                if (mViewRes != 0) {
+                    inflater.inflate(mViewRes, contentLayout, true);
+                } else if (mView != null) {
+                    contentLayout.addView(mView);
+                }
+
+                return rootLayout;
+            default:
+                throw new IllegalArgumentException();
+        }
+    }
+
+    private View createSkeleton() {
+        LayoutInflater inflater = (LayoutInflater) mContext
+                .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        LinearLayout rootLayout = (LinearLayout) inflater.inflate(
+                R.layout.dialog_main_skeleton, new FrameLayout(mContext), false);
+        TextView titleView = (TextView) rootLayout.findViewById(R.id.title);
+
+        if (Device.hasLollipopApi()) {
+            // The dividers are quite ugly with material design.
+            rootLayout.setShowDividers(LinearLayout.SHOW_DIVIDER_NONE);
+        }
+
+        if (mTitleText == null && mIcon == null) {
+            rootLayout.removeView(titleView);
+        } else {
+            if (mTitleText != null)
+                titleView.setText(mTitleText);
+            if (mIcon != null)
+                titleView.setCompoundDrawablesWithIntrinsicBounds(mIcon, null, null, null);
+        }
+
+        return rootLayout;
+    }
+
+    //-- ALERT DIALOG ---------------------------------------------------------
+
+    public AlertDialog.Builder createAlertDialogBuilder() {
+        return createAlertDialogBuilder(LAYOUT_COMMON);
+    }
+
+    /**
+     * Creates view and {@link android.app.AlertDialog.Builder#setView(android.view.View) sets}
+     * to new {@link android.app.AlertDialog.Builder}.
+     *
+     * @param type type of container layout
+     * @return AlertDialog.Builder with set custom view
+     */
+    public AlertDialog.Builder createAlertDialogBuilder(int type) {
+        return new AlertDialog.Builder(mContext).setView(createView(type));
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/base/ui/activities/ActivityBase.java b/project/app/src/main/java/com/achep/base/ui/activities/ActivityBase.java
new file mode 100644
index 00000000..30b05a25
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/ui/activities/ActivityBase.java
@@ -0,0 +1,115 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.ui.activities;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v7.app.ActionBarActivity;
+
+import com.achep.acdisplay.App;
+import com.achep.base.utils.power.PowerSaveDetector;
+
+import org.solovyev.android.checkout.ActivityCheckout;
+import org.solovyev.android.checkout.Checkout;
+
+/**
+ * Created by Artem Chepurnoy on 28.12.2014.
+ */
+public abstract class ActivityBase extends ActionBarActivity {
+
+    protected ActivityCheckout mCheckout;
+    protected PowerSaveDetector mPowerSaveDetector;
+
+    private boolean mCheckoutRequest;
+
+    public void requestCheckout() {
+        mCheckoutRequest = true;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        if (mCheckoutRequest) mCheckout = Checkout.forActivity(this, App.getCheckout());
+        mPowerSaveDetector = PowerSaveDetector.newInstance(this);
+        super.onCreate(savedInstanceState);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onStart() {
+        super.onStart();
+        if (mCheckout != null) mCheckout.start();
+        mPowerSaveDetector.start();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void onStop() {
+        if (mCheckout != null) mCheckout.stop();
+        mPowerSaveDetector.stop();
+        super.onStop();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
+        if (mCheckout != null) {
+            boolean handled = mCheckout.onActivityResult(requestCode, resultCode, data);
+            if (handled) return;
+        }
+
+        // Pass to parent.
+        super.onActivityResult(requestCode, resultCode, data);
+    }
+
+    @Nullable
+    public ActivityCheckout getCheckout() {
+        return mCheckout;
+    }
+
+    /**
+     * @see #isPowerSaveMode()
+     */
+    @NonNull
+    public PowerSaveDetector getPowerSaveDetector() {
+        return mPowerSaveDetector;
+    }
+
+    /**
+     * Returns {@code true} if the device is currently in power save mode.
+     * When in this mode, applications should reduce their functionality
+     * in order to conserve battery as much as possible.
+     *
+     * @return {@code true} if the device is currently in power save mode, {@code false} otherwise.
+     */
+    public boolean isPowerSaveMode() {
+        return mPowerSaveDetector.isPowerSaveMode();
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/base/ui/activities/SettingsActivity.java b/project/app/src/main/java/com/achep/base/ui/activities/SettingsActivity.java
new file mode 100644
index 00000000..cf7b65cc
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/ui/activities/SettingsActivity.java
@@ -0,0 +1,642 @@
+/*
+ * Copyright (C) 2015 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.ui.activities;
+
+import android.content.ComponentName;
+import android.content.Context;
+import android.content.Intent;
+import android.content.pm.ActivityInfo;
+import android.content.pm.PackageManager;
+import android.content.pm.PackageManager.NameNotFoundException;
+import android.content.res.XmlResourceParser;
+import android.os.Bundle;
+import android.preference.Preference;
+import android.preference.PreferenceFragment;
+import android.support.annotation.NonNull;
+import android.support.annotation.XmlRes;
+import android.support.v4.app.Fragment;
+import android.support.v4.app.FragmentManager;
+import android.support.v4.app.FragmentTransaction;
+import android.support.v7.app.ActionBar;
+import android.transitions.everywhere.TransitionManager;
+import android.util.AttributeSet;
+import android.util.Log;
+import android.util.Xml;
+import android.view.ViewGroup;
+
+import com.achep.acdisplay.R;
+import com.achep.acdisplay.ui.activities.Settings2;
+import com.achep.base.dashboard.DashboardCategory;
+import com.achep.base.dashboard.DashboardTile;
+import com.achep.base.ui.fragments.DashboardFragment;
+import com.achep.base.utils.xml.XmlUtils;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+public abstract class SettingsActivity extends ActivityBase implements
+        PreferenceFragment.OnPreferenceStartFragmentCallback,
+        FragmentManager.OnBackStackChangedListener {
+
+    private static final String LOG_TAG = "Settings";
+
+    // Constants for loading dashboard from xml resource.
+    private static final String RESOURCE_TAG_DASHBOARD = "dashboard";
+    private static final String RESOURCE_TAG_DASHBOARD_CATEGORY = "dashboard-category";
+    private static final String RESOURCE_TAG_DASHBOARD_TILE = "dashboard-tile";
+    private static final String RESOURCE_TAG_DASHBOARD_TILE_EXTRA = "extra";
+    private static final String RESOURCE_TAG_DASHBOARD_TILE_INTENT = "intent";
+
+    // Constants for state save/restore
+    private static final String SAVE_KEY_CATEGORIES = ":settings:categories";
+    private static final String SAVE_KEY_SHOW_HOME_AS_UP = ":settings:show_home_as_up";
+
+    /**
+     * When starting this activity, the invoking Intent can contain this extra
+     * string to specify which fragment should be initially displayed.
+     * <p/>Starting from Key Lime Pie, when this argument is passed in, the activity
+     * will call isValidFragment() to confirm that the fragment class name is valid for this
+     * activity.
+     */
+    public static final String EXTRA_SHOW_FRAGMENT = ":settings:show_fragment";
+
+    /**
+     * When starting this activity and using {@link #EXTRA_SHOW_FRAGMENT},
+     * this extra can also be specified to supply a Bundle of arguments to pass
+     * to that fragment when it is instantiated during the initial creation
+     * of the activity.
+     */
+    public static final String EXTRA_SHOW_FRAGMENT_ARGUMENTS = ":settings:show_fragment_args";
+
+    /**
+     * Fragment "key" argument passed thru {@link #EXTRA_SHOW_FRAGMENT_ARGUMENTS}
+     */
+    public static final String EXTRA_FRAGMENT_ARG_KEY = ":settings:fragment_args_key";
+
+    public static final String BACK_STACK_PREFS = ":settings:prefs";
+
+    /**
+     * When starting this activity and using {@link #EXTRA_SHOW_FRAGMENT},
+     * those extra can also be specify to supply the title or title res id to be shown for
+     * that fragment.
+     */
+    public static final String EXTRA_SHOW_FRAGMENT_TITLE =
+            ":settings:show_fragment_title";
+
+    public static final String EXTRA_SHOW_FRAGMENT_TITLE_RESID =
+            ":settings:show_fragment_title_resid";
+
+    public static final String EXTRA_SHOW_FRAGMENT_AS_SHORTCUT =
+            ":settings:show_fragment_as_shortcut";
+
+    public static final String EXTRA_SHOW_FRAGMENT_AS_SUBSETTING =
+            ":settings:show_fragment_as_subsetting";
+
+    private static final String META_DATA_KEY_FRAGMENT_CLASS =
+            "com.android.settings.FRAGMENT_CLASS";
+
+    private static final String EXTRA_UI_OPTIONS =
+            "settings:ui_options";
+
+    private String mFragmentClass;
+
+    private CharSequence mInitialTitle;
+    private int mInitialTitleResId;
+
+
+    private static final String[] LIKE_SHORTCUT_INTENT_ACTION_ARRAY = {
+            "android.settings.APPLICATION_DETAILS_SETTINGS"
+    };
+
+    private ViewGroup mContent;
+
+    private boolean mDisplayHomeAsUpEnabled;
+    private boolean mIsShowingDashboard;
+    private boolean mIsShortcut;
+
+    private ArrayList<DashboardCategory> mCategories = new ArrayList<>();
+
+    public List<DashboardCategory> getDashboardCategories(boolean forceRefresh) {
+        if (forceRefresh || mCategories.size() == 0) {
+            buildDashboard(mCategories);
+        }
+        return mCategories;
+    }
+
+    @Override
+    public boolean onPreferenceStartFragment(PreferenceFragment caller, Preference p) {
+        startPreferencePanel(p.getFragment(), p.getExtras(), p.getTitleRes(), p.getTitle(), null, 0);
+        return true;
+    }
+
+    private static boolean isShortCutIntent(final Intent intent) {
+        Set<String> categories = intent.getCategories();
+        return (categories != null) && categories.contains("com.android.settings.SHORTCUT");
+    }
+
+    private static boolean isLikeShortCutIntent(final Intent intent) {
+        String action = intent.getAction();
+        if (action == null) return false;
+
+        for (String item : LIKE_SHORTCUT_INTENT_ACTION_ARRAY)
+            if (item.equals(action))
+                return true;
+        return false;
+    }
+
+    @Override
+    protected void onCreate(Bundle savedState) {
+        super.onCreate(savedState);
+
+        // Should happen before any call to getIntent()
+        getMetaData();
+
+        final Intent intent = getIntent();
+        if (intent.hasExtra(EXTRA_UI_OPTIONS)) {
+            getWindow().setUiOptions(intent.getIntExtra(EXTRA_UI_OPTIONS, 0));
+        }
+
+        // Getting Intent properties can only be done after the super.onCreate(...)
+        final String initialFragmentName = intent.getStringExtra(EXTRA_SHOW_FRAGMENT);
+
+        mIsShortcut = isShortCutIntent(intent) || isLikeShortCutIntent(intent) ||
+                intent.getBooleanExtra(EXTRA_SHOW_FRAGMENT_AS_SHORTCUT, false);
+
+        final ComponentName cn = intent.getComponent();
+        final String className = cn.getClassName();
+
+        mIsShowingDashboard = className.equals(Settings2.class.getName());
+
+        // This is a "Sub Settings" when:
+        // - this is a real SubSettings
+        // - or :settings:show_fragment_as_subsetting is passed to the Intent
+        final boolean isSubSettings = className.equals(SubSettings.class.getName()) ||
+                intent.getBooleanExtra(EXTRA_SHOW_FRAGMENT_AS_SUBSETTING, false);
+
+        // If this is a sub settings, then apply the SubSettings Theme for the ActionBar content insets
+        if (isSubSettings) {
+            // Check also that we are not a Theme Dialog as we don't want to override them
+            /*
+            final int themeResId = getTheme(). getThemeResId();
+            if (themeResId != R.style.Theme_DialogWhenLarge &&
+                    themeResId != R.style.Theme_SubSettingsDialogWhenLarge) {
+                setTheme(R.style.Theme_SubSettings);
+            }
+            */
+        }
+
+        setContentView(R.layout.settings_main_dashboard);
+
+        mContent = (ViewGroup) findViewById(R.id.main_content);
+
+        getSupportFragmentManager().addOnBackStackChangedListener(this);
+
+        if (savedState != null) {
+            // We are restarting from a previous saved state; used that to initialize, instead
+            // of starting fresh.
+
+            setTitleFromIntent(intent);
+
+            ArrayList<DashboardCategory> categories =
+                    savedState.getParcelableArrayList(SAVE_KEY_CATEGORIES);
+            if (categories != null) {
+                mCategories.clear();
+                mCategories.addAll(categories);
+                setTitleFromBackStack();
+            }
+
+            mDisplayHomeAsUpEnabled = savedState.getBoolean(SAVE_KEY_SHOW_HOME_AS_UP);
+        } else {
+            if (!mIsShowingDashboard) {
+                mDisplayHomeAsUpEnabled = isSubSettings;
+                setTitleFromIntent(intent);
+
+                Bundle initialArguments = intent.getBundleExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS);
+                switchToFragment(initialFragmentName, initialArguments, true, false,
+                        mInitialTitleResId, mInitialTitle, false);
+            } else {
+                mDisplayHomeAsUpEnabled = false;
+                mInitialTitleResId = R.string.app_name;
+                switchToFragment(DashboardFragment.class.getName(), null, false, false,
+                        mInitialTitleResId, mInitialTitle, false);
+            }
+        }
+
+        ActionBar actionBar = getSupportActionBar();
+        if (actionBar != null) {
+            actionBar.setDisplayHomeAsUpEnabled(mDisplayHomeAsUpEnabled);
+            actionBar.setHomeButtonEnabled(mDisplayHomeAsUpEnabled);
+        }
+    }
+
+    /*
+    @Override
+    public boolean onNavigateUp() {
+        startActivity(new Intent(this, MainActivity.class)
+                .addFlags(Intent.FLAG_ACTIVITY_REORDER_TO_FRONT)
+                .addFlags(Intent.FLAG_ACTIVITY_CLEAR_TOP));
+        return true;
+    }
+    */
+
+    private void setTitleFromIntent(Intent intent) {
+        final int initialTitleResId = intent.getIntExtra(EXTRA_SHOW_FRAGMENT_TITLE_RESID, -1);
+        if (initialTitleResId > 0) {
+            mInitialTitle = null;
+            mInitialTitleResId = initialTitleResId;
+            setTitle(mInitialTitleResId);
+        } else {
+            mInitialTitleResId = -1;
+            final String initialTitle = intent.getStringExtra(EXTRA_SHOW_FRAGMENT_TITLE);
+            mInitialTitle = (initialTitle != null) ? initialTitle : getTitle();
+            setTitle(mInitialTitle);
+        }
+    }
+
+    @Override
+    public void onBackStackChanged() {
+        setTitleFromBackStack();
+    }
+
+    private int setTitleFromBackStack() {
+        final int count = getFragmentManager().getBackStackEntryCount();
+
+        if (count == 0) {
+            if (mInitialTitleResId > 0) {
+                setTitle(mInitialTitleResId);
+            } else {
+                setTitle(mInitialTitle);
+            }
+            return 0;
+        }
+
+        FragmentManager.BackStackEntry bse = getSupportFragmentManager().getBackStackEntryAt(count - 1);
+        setTitleFromBackStackEntry(bse);
+
+        return count;
+    }
+
+    private void setTitleFromBackStackEntry(FragmentManager.BackStackEntry bse) {
+        final CharSequence title;
+        final int titleRes = bse.getBreadCrumbTitleRes();
+        if (titleRes > 0) {
+            title = getText(titleRes);
+        } else {
+            title = bse.getBreadCrumbTitle();
+        }
+        if (title != null) {
+            setTitle(title);
+        }
+    }
+
+    @Override
+    protected void onSaveInstanceState(@NonNull Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        if (mCategories.size() > 0) {
+            outState.putParcelableArrayList(SAVE_KEY_CATEGORIES, mCategories);
+        }
+
+        outState.putBoolean(SAVE_KEY_SHOW_HOME_AS_UP, mDisplayHomeAsUpEnabled);
+    }
+
+    protected boolean isValidFragment(@NonNull String fragmentName) {
+        return false;
+    }
+
+    @XmlRes
+    protected int getDashboardResource() {
+        return 0;
+    }
+
+    protected abstract boolean isTileSupported(@NonNull DashboardTile tile);
+
+    @Override
+    public Intent getIntent() {
+        Intent superIntent = super.getIntent();
+        String startingFragment = getStartingFragmentClass(superIntent);
+        // This is called from super.onCreate, isMultiPane() is not yet reliable
+        // Do not use onIsHidingHeaders either, which relies itself on this method
+        if (startingFragment != null) {
+            Intent modIntent = new Intent(superIntent);
+            modIntent.putExtra(EXTRA_SHOW_FRAGMENT, startingFragment);
+            Bundle args = superIntent.getExtras();
+            if (args != null) {
+                args = new Bundle(args);
+            } else {
+                args = new Bundle();
+            }
+            args.putParcelable("intent", superIntent);
+            modIntent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);
+            return modIntent;
+        }
+        return superIntent;
+    }
+
+    /**
+     * Checks if the component name in the intent is different from the Settings class and
+     * returns the class name to load as a fragment.
+     */
+    private String getStartingFragmentClass(Intent intent) {
+        if (mFragmentClass != null) return mFragmentClass;
+
+        String intentClass = intent.getComponent().getClassName();
+        return intentClass.equals(getClass().getName()) ? null : intentClass;
+    }
+
+    /**
+     * Start a new fragment containing a preference panel.  If the preferences
+     * are being displayed in multi-pane mode, the given fragment class will
+     * be instantiated and placed in the appropriate pane.  If running in
+     * single-pane mode, a new activity will be launched in which to show the
+     * fragment.
+     *
+     * @param fragmentClass     Full name of the class implementing the fragment.
+     * @param args              Any desired arguments to supply to the fragment.
+     * @param titleRes          Optional resource identifier of the title of this
+     *                          fragment.
+     * @param titleText         Optional text of the title of this fragment.
+     * @param resultTo          Optional fragment that result data should be sent to.
+     *                          If non-null, resultTo.onActivityResult() will be called when this
+     *                          preference panel is done.  The launched panel must use
+     *                          {@link #finishPreferencePanel(Fragment, int, Intent)} when done.
+     * @param resultRequestCode If resultTo is non-null, this is the caller's
+     *                          request code to be received with the result.
+     */
+    public void startPreferencePanel(String fragmentClass, Bundle args, int titleRes,
+                                     CharSequence titleText, Fragment resultTo, int resultRequestCode) {
+        String title = null;
+        if (titleRes < 0) {
+            if (titleText != null) {
+                title = titleText.toString();
+            } else {
+                // There not much we can do in that case
+                title = "";
+            }
+        }
+
+        Utils.startWithFragment(this, fragmentClass, args,
+                resultTo, resultRequestCode,
+                titleRes, title, mIsShortcut);
+    }
+
+    /**
+     * Switch to a specific Fragment with taking care of validation, Title and BackStack
+     */
+    private Fragment switchToFragment(String fragmentName, Bundle args, boolean validate,
+                                      boolean addToBackStack, int titleResId, CharSequence title,
+                                      boolean withTransition) {
+        if (validate && !isValidFragment(fragmentName)) {
+            String message = "Invalid fragment for this activity: " + fragmentName;
+            throw new IllegalArgumentException(message);
+        }
+
+        Fragment f = Fragment.instantiate(this, fragmentName, args);
+        FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
+        transaction.replace(R.id.main_content, f);
+
+        if (withTransition) TransitionManager.beginDelayedTransition(mContent);
+        if (addToBackStack) transaction.addToBackStack(SettingsActivity.BACK_STACK_PREFS);
+        if (titleResId > 0) {
+            transaction.setBreadCrumbTitle(titleResId);
+        } else if (title != null) {
+            transaction.setBreadCrumbTitle(title);
+        }
+
+        transaction.commitAllowingStateLoss();
+        getFragmentManager().executePendingTransactions();
+        return f;
+    }
+
+    /**
+     * Called when the activity needs its list of categories/tiles built.
+     *
+     * @param categories The list in which to place the tiles categories.
+     */
+    private void buildDashboard(@NonNull List<DashboardCategory> categories) {
+        categories.clear();
+        loadDashboardFromResource(getDashboardResource(), categories);
+        updateDashboardTilesList(categories);
+    }
+
+    /**
+     * Parse the given XML file as a categories description, adding each
+     * parsed categories and tiles into the target list.
+     *
+     * @param resourceId The XML resource to load and parse.
+     * @param target     The list in which the parsed categories and tiles should be placed.
+     */
+    protected final void loadDashboardFromResource(@XmlRes int resourceId,
+                                                   @NonNull List<DashboardCategory> target) {
+        XmlResourceParser parser = null;
+        try {
+            parser = getResources().getXml(resourceId);
+            AttributeSet attrs = Xml.asAttributeSet(parser);
+
+            int type;
+
+            for (type = parser.next();
+                 type != XmlPullParser.END_DOCUMENT;
+                 type = parser.next()) {
+                if (type == XmlPullParser.START_TAG) break;
+            }
+
+            String nodeName = parser.getName();
+            if (!RESOURCE_TAG_DASHBOARD.equals(nodeName)) throw new RuntimeException(
+                    String.format("XML document must start with <%s> tag; found %s at %s",
+                            RESOURCE_TAG_DASHBOARD, nodeName, parser.getPositionDescription()));
+
+            for (type = parser.next();
+                 type != XmlPullParser.END_DOCUMENT;
+                 type = parser.next()) {
+                if (type == XmlPullParser.END_TAG && parser.getDepth() <= 1 /* root tag */) break;
+                if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
+                    continue;
+                }
+
+                switch (parser.getName()) {
+                    case RESOURCE_TAG_DASHBOARD_CATEGORY:
+                        DashboardCategory category = new DashboardCategory(this, attrs);
+
+                        final int categoryDepth = parser.getDepth();
+                        for (type = parser.next();
+                             type != XmlPullParser.END_DOCUMENT;
+                             type = parser.next()) {
+                            if (type == XmlPullParser.END_TAG && parser.getDepth() <= categoryDepth)
+                                break;
+                            if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
+                                continue;
+                            }
+
+                            switch (parser.getName()) {
+                                case RESOURCE_TAG_DASHBOARD_TILE:
+                                    DashboardTile tile = new DashboardTile(this, attrs);
+                                    Bundle bundle = null;
+
+                                    final int tileDepth = parser.getDepth();
+                                    for (type = parser.next();
+                                         type != XmlPullParser.END_DOCUMENT;
+                                         type = parser.next()) {
+                                        if (type == XmlPullParser.END_TAG && parser.getDepth() <= tileDepth)
+                                            break;
+                                        if (type == XmlPullParser.END_TAG || type == XmlPullParser.TEXT) {
+                                            continue;
+                                        }
+
+                                        switch (parser.getName()) {
+                                            case RESOURCE_TAG_DASHBOARD_TILE_EXTRA:
+                                                if (bundle == null) {
+                                                    bundle = new Bundle();
+                                                }
+
+                                                getResources().parseBundleExtra(RESOURCE_TAG_DASHBOARD_TILE_EXTRA, attrs, bundle);
+                                                XmlUtils.skipCurrentTag(parser);
+                                                break;
+                                            case RESOURCE_TAG_DASHBOARD_TILE_INTENT:
+                                                tile.intent = Intent.parseIntent(getResources(), parser, attrs);
+                                                break;
+                                            default:
+                                                XmlUtils.skipCurrentTag(parser);
+                                        }
+                                    }
+
+                                    tile.fragmentArguments = bundle;
+                                    category.add(tile);
+                                    break;
+                                default:
+                                    XmlUtils.skipCurrentTag(parser);
+                            }
+                        }
+
+                        target.add(category);
+                        break;
+                    default:
+                        XmlUtils.skipCurrentTag(parser);
+                }
+            }
+        } catch (XmlPullParserException | IOException e) {
+            throw new RuntimeException("Error parsing categories", e);
+        } finally {
+            if (parser != null) parser.close();
+        }
+    }
+
+    private void updateDashboardTilesList(List<DashboardCategory> target) {
+        for (int i = target.size() - 1; i >= 0; i--) {
+            final DashboardCategory category = target.get(i);
+
+            for (int j = category.size() - 1; j >= 0; j--) {
+                final DashboardTile tile = category.get(j);
+                final boolean removeTile = !isTileSupported(tile);
+                if (removeTile) {
+                    category.remove(j);
+                }
+            }
+
+            if (category.isEmpty()) {
+                target.remove(i);
+            }
+        }
+    }
+
+    private void getMetaData() {
+        try {
+            ActivityInfo ai = getPackageManager().getActivityInfo(getComponentName(),
+                    PackageManager.GET_META_DATA);
+            if (ai == null || ai.metaData == null) return;
+            mFragmentClass = ai.metaData.getString(META_DATA_KEY_FRAGMENT_CLASS);
+        } catch (NameNotFoundException nnfe) {
+            // No recovery
+            Log.d(LOG_TAG, "Cannot get Metadata for: " + getComponentName().toString());
+        }
+    }
+
+    @Override
+    public boolean shouldUpRecreateTask(@NonNull Intent unused) {
+        return super.shouldUpRecreateTask(new Intent(this, SettingsActivity.class));
+    }
+
+    public static final class Utils {
+
+        /**
+         * Start a new instance of the activity, showing only the given fragment.
+         * When launched in this mode, the given preference fragment will be instantiated and fill the
+         * entire activity.
+         *
+         * @param context           The context.
+         * @param fragmentName      The name of the fragment to display.
+         * @param args              Optional arguments to supply to the fragment.
+         * @param resultTo          Option fragment that should receive the result of the activity launch.
+         * @param resultRequestCode If resultTo is non-null, this is the request code in which
+         *                          to report the result.
+         * @param titleResId        resource id for the String to display for the title of this set
+         *                          of preferences.
+         * @param title             String to display for the title of this set of preferences.
+         */
+        public static void startWithFragment(Context context, String fragmentName, Bundle args,
+                                             Fragment resultTo, int resultRequestCode, int titleResId, CharSequence title) {
+            startWithFragment(context, fragmentName, args, resultTo, resultRequestCode,
+                    titleResId, title, false /* not a shortcut */);
+        }
+
+        public static void startWithFragment(Context context, String fragmentName, Bundle args,
+                                             Fragment resultTo, int resultRequestCode, int titleResId, CharSequence title,
+                                             boolean isShortcut) {
+            Intent intent = onBuildStartFragmentIntent(context, fragmentName, args, titleResId,
+                    title, isShortcut);
+            if (resultTo == null) {
+                context.startActivity(intent);
+            } else {
+                resultTo.startActivityForResult(intent, resultRequestCode);
+            }
+        }
+
+        /**
+         * Build an Intent to launch a new activity showing the selected fragment.
+         * The implementation constructs an Intent that re-launches the current activity with the
+         * appropriate arguments to display the fragment.
+         *
+         * @param context      The Context.
+         * @param fragmentName The name of the fragment to display.
+         * @param args         Optional arguments to supply to the fragment.
+         * @param titleResId   Optional title resource id to show for this item.
+         * @param title        Optional title to show for this item.
+         * @param isShortcut   tell if this is a Launcher Shortcut or not
+         * @return Returns an Intent that can be launched to display the given
+         * fragment.
+         */
+        public static Intent onBuildStartFragmentIntent(Context context, String fragmentName,
+                                                        Bundle args, int titleResId, CharSequence title, boolean isShortcut) {
+            Intent intent = new Intent(Intent.ACTION_MAIN);
+            intent.setClass(context, SubSettings.class);
+            intent.putExtra(EXTRA_SHOW_FRAGMENT, fragmentName);
+            intent.putExtra(EXTRA_SHOW_FRAGMENT_ARGUMENTS, args);
+            intent.putExtra(EXTRA_SHOW_FRAGMENT_TITLE_RESID, titleResId);
+            intent.putExtra(EXTRA_SHOW_FRAGMENT_TITLE, title);
+            intent.putExtra(EXTRA_SHOW_FRAGMENT_AS_SHORTCUT, isShortcut);
+            return intent;
+        }
+
+    }
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/settings/SubSettings.java b/project/app/src/main/java/com/achep/base/ui/activities/SubSettings.java
similarity index 64%
rename from project/app/src/main/java/com/achep/acdisplay/settings/SubSettings.java
rename to project/app/src/main/java/com/achep/base/ui/activities/SubSettings.java
index 63525a84..15f5ac85 100644
--- a/project/app/src/main/java/com/achep/acdisplay/settings/SubSettings.java
+++ b/project/app/src/main/java/com/achep/base/ui/activities/SubSettings.java
@@ -16,41 +16,34 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.settings;
+package com.achep.base.ui.activities;
 
-import android.app.FragmentManager;
+import android.support.annotation.NonNull;
 import android.util.Log;
 
-import com.achep.acdisplay.Build;
+import com.achep.base.dashboard.DashboardTile;
 
 /**
  * Stub class for showing sub-settings; we can't use the main Settings class
  * since for our app it is a special singleTask class.
  */
-public class SubSettings extends Settings {
-
-    private static final String TAG = "SubSettings";
+public class SubSettings extends SettingsActivity {
 
     @Override
     public boolean onNavigateUp() {
-        if (!popFragment()) {
-            finish();
-        }
+        finish();
         return true;
     }
 
     @Override
-    protected boolean isValidFragment(String fragmentName) {
-        if (Build.DEBUG) Log.d(TAG, "Launching fragment " + fragmentName);
+    protected boolean isValidFragment(@NonNull String fragmentName) {
+        Log.d("SubSettings", "Launching fragment " + fragmentName);
         return true;
     }
 
-    private boolean popFragment() {
-        FragmentManager fm = getFragmentManager();
-        if (fm.getBackStackEntryCount() > 0) {
-            fm.popBackStack();
-            return true;
-        }
+    @Override
+    protected boolean isTileSupported(@NonNull DashboardTile tile) {
         return false;
     }
-}
\ No newline at end of file
+
+}
diff --git a/project/app/src/main/java/com/achep/base/ui/adapters/BetterArrayAdapter.java b/project/app/src/main/java/com/achep/base/ui/adapters/BetterArrayAdapter.java
new file mode 100644
index 00000000..bbe3ffdb
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/ui/adapters/BetterArrayAdapter.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.ui.adapters;
+
+import android.content.Context;
+import android.support.annotation.LayoutRes;
+import android.support.annotation.NonNull;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ArrayAdapter;
+
+/**
+ * Created by Artem Chepurnoy on 27.12.2014.
+ */
+public abstract class BetterArrayAdapter<T> extends ArrayAdapter<T> {
+
+    @NonNull
+    protected final LayoutInflater mInflater;
+
+    @NonNull
+    protected final Context mContext;
+
+    @LayoutRes
+    private final int mResource;
+
+    public abstract static class ViewHolder {
+
+        @NonNull
+        public final View view;
+
+        public ViewHolder(@NonNull View view) {
+            this.view = view;
+        }
+
+    }
+
+    protected BetterArrayAdapter(@NonNull Context context, @LayoutRes int resource) {
+        super(context, 0);
+        mInflater = LayoutInflater.from(context);
+        mContext = context;
+        mResource = resource;
+    }
+
+    @Override
+    public View getView(int position, View convertView, ViewGroup parent) {
+        final View view;
+        final ViewHolder vh;
+        if (convertView == null) {
+            view = mInflater.inflate(mResource, parent, false);
+            vh = onCreateViewHolder(view);
+            view.setTag(vh);
+        } else {
+            view = convertView;
+            vh = (ViewHolder) view.getTag();
+        }
+
+        onBindViewHolder(vh, position);
+        return view;
+    }
+
+    @NonNull
+    protected abstract ViewHolder onCreateViewHolder(@NonNull View view);
+
+    protected abstract void onBindViewHolder(@NonNull ViewHolder viewHolder, int i);
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/animations/AnimationListenerAdapter.java b/project/app/src/main/java/com/achep/base/ui/animations/AnimationListenerAdapter.java
similarity index 73%
rename from project/app/src/main/java/com/achep/acdisplay/animations/AnimationListenerAdapter.java
rename to project/app/src/main/java/com/achep/base/ui/animations/AnimationListenerAdapter.java
index ec23c166..d343675e 100644
--- a/project/app/src/main/java/com/achep/acdisplay/animations/AnimationListenerAdapter.java
+++ b/project/app/src/main/java/com/achep/base/ui/animations/AnimationListenerAdapter.java
@@ -16,29 +16,25 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
+package com.achep.base.ui.animations;
 
-package com.achep.acdisplay.animations;
-
+import android.support.annotation.NonNull;
 import android.view.animation.Animation;
 
 /**
  * An empty class that implements {@link Animation.AnimationListener}
+ *
+ * @author Artem Chepurnoy
  */
 public class AnimationListenerAdapter implements Animation.AnimationListener {
 
     @Override
-    public void onAnimationStart(Animation animation) {
-
-    }
+    public void onAnimationStart(@NonNull Animation animation) { /* for children */ }
 
     @Override
-    public void onAnimationEnd(Animation animation) {
-
-    }
+    public void onAnimationEnd(@NonNull Animation animation) { /* for children */ }
 
     @Override
-    public void onAnimationRepeat(Animation animation) {
-
-    }
+    public void onAnimationRepeat(@NonNull Animation animation) { /* for children */ }
 
 }
diff --git a/project/app/src/main/java/com/achep/base/ui/drawables/PlayPauseDrawable.java b/project/app/src/main/java/com/achep/base/ui/drawables/PlayPauseDrawable.java
new file mode 100644
index 00000000..14a031c1
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/ui/drawables/PlayPauseDrawable.java
@@ -0,0 +1,66 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.ui.drawables;
+
+/**
+ * Created by Artem Chepurnoy on 18.10.2014.
+ */
+public class PlayPauseDrawable extends TransformationDrawable {
+
+    /**
+     * Pause icon
+     */
+    private static final float[][] VERTEX_PAUSE = {
+            {0.3f, 0.0f, 0.0f, 0.3f, 0.3f, 0.7f, 0.7f, 1.0f, 1.0f},
+            {0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f}
+    };
+
+    /**
+     * Play icon
+     */
+    private static final float[][] VERTEX_PLAY = {
+            {1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f},
+            {0.5f, 0.5f, 0.0f, 1.0f, 0.5f, 0.5f, 0.0f, 1.0f, 0.5f}
+    };
+
+    /**
+     * Stop icon
+     */
+    private static final float[][] VERTEX_STOP = {
+            {0.5f, 0.0f, 0.0f, 0.5f, 0.5f, 0.5f, 0.5f, 1.0f, 1.0f},
+            {0.0f, 0.0f, 1.0f, 1.0f, 0.0f, 0.0f, 1.0f, 1.0f, 0.0f}
+    };
+
+    public PlayPauseDrawable() {
+        super(VERTEX_PAUSE, VERTEX_PLAY, VERTEX_STOP);
+    }
+
+    public void transformToPause() {
+        transformToShape(0);
+    }
+
+    public void transformToPlay() {
+        transformToShape(1);
+    }
+
+    public void transformToStop() {
+        transformToShape(2);
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/base/ui/drawables/RippleDrawable2.java b/project/app/src/main/java/com/achep/base/ui/drawables/RippleDrawable2.java
new file mode 100644
index 00000000..5510e028
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/ui/drawables/RippleDrawable2.java
@@ -0,0 +1,85 @@
+/*
+ * Copyright (C) 2015 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.ui.drawables;
+
+import android.annotation.TargetApi;
+import android.content.res.ColorStateList;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.PorterDuff;
+import android.graphics.PorterDuffColorFilter;
+import android.graphics.drawable.Drawable;
+import android.graphics.drawable.RippleDrawable;
+import android.os.Build;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/**
+ * Created by Artem Chepurnoy on 09.01.2015.
+ *
+ * @author Artem Chepurnoy
+ */
+@TargetApi(Build.VERSION_CODES.LOLLIPOP)
+public class RippleDrawable2 extends RippleDrawable {
+
+    /**
+     * Creates a new ripple drawable with the specified ripple color and
+     * optional content and mask drawables.
+     *
+     * @param color   The ripple color
+     * @param content The content drawable, may be {@code null}
+     * @param mask    The mask drawable, may be {@code null}
+     */
+    public RippleDrawable2(ColorStateList color, Drawable content, Drawable mask) {
+        super(color, content, mask);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setColorFilter(int color, PorterDuff.Mode mode) {
+        setColorFilter(new PorterDuffColorFilter(color, mode));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setColorFilter(ColorFilter colorFilter) {
+        super.setColorFilter(colorFilter);
+        getRipplePaint().setColorFilter(colorFilter);
+        // FIXME: Ripple backfires with original color.
+    }
+
+    private Paint getRipplePaint() {
+        try {
+            Method method = RippleDrawable.class.getDeclaredMethod("getRipplePaint");
+            method.setAccessible(true);
+            return (Paint) method.invoke(this);
+        } catch (NoSuchMethodException
+                | InvocationTargetException
+                | IllegalAccessException ignored) {
+        }
+        // Normally should never happen.
+        return new Paint();
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/base/ui/drawables/TransformationDrawable.java b/project/app/src/main/java/com/achep/base/ui/drawables/TransformationDrawable.java
new file mode 100644
index 00000000..f4448a90
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/ui/drawables/TransformationDrawable.java
@@ -0,0 +1,188 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.ui.drawables;
+
+import android.animation.Animator;
+import android.animation.ObjectAnimator;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.Path;
+import android.graphics.PixelFormat;
+import android.graphics.Rect;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.util.Property;
+
+import com.achep.base.utils.FloatProperty;
+
+/**
+ * A class for creating simple transformation buttons. It is very simple to
+ * use and perfectly fits simple Material icons' transformation.
+ *
+ * @author Artem Chepurnoy
+ * @see com.achep.base.ui.drawables.PlayPauseDrawable
+ */
+public abstract class TransformationDrawable extends Drawable {
+
+    private final Path mPath;
+    private final Paint mPaint;
+    private final float[][][] mVertex;
+
+    private int mSize = Integer.MAX_VALUE;
+
+    private float mProgress;
+    private int mFromShape;
+    private int mToShape;
+
+    private final Animator mAnimator = ObjectAnimator.ofFloat(this, TRANSFORM, 0f, 1f);
+    private final static Property<TransformationDrawable, Float> TRANSFORM =
+            new FloatProperty<TransformationDrawable>("setTransformation") {
+                @Override
+                public void setValue(TransformationDrawable object, float value) {
+                    object.setTransformation(value);
+                }
+
+                @Override
+                public Float get(TransformationDrawable object) {
+                    return object.getTransformation();
+                }
+            };
+
+    protected TransformationDrawable(@NonNull float[][]... vertex) {
+        mVertex = vertex;
+
+        mPath = new Path();
+        mPath.setFillType(Path.FillType.WINDING);
+
+        mPaint = new Paint();
+        mPaint.setAntiAlias(true);
+        mPaint.setColor(Color.WHITE);
+        mPaint.setStyle(Paint.Style.FILL);
+    }
+
+    public void setColor(int color) {
+        mPaint.setColor(color);
+        invalidateSelf();
+    }
+
+    public void transformToShape(int i) {
+        if (mToShape == i) {
+            // Otherwise this will not be animated.
+            return;
+        }
+
+        setTransformationTarget(i);
+        mAnimator.cancel();
+        mAnimator.start();
+    }
+
+    /**
+     * Sets the size of canvas rectangle.
+     *
+     * @param size size in pixels.
+     */
+    public void setSize(int size) {
+        mSize = size;
+    }
+
+    public void setTransformationTarget(int i) {
+        mFromShape = mToShape;
+        mToShape = i;
+    }
+
+    public void setTransformation(float progress) {
+        mProgress = progress;
+        Rect rect = getBounds();
+
+        final float size = Math.min(Math.min(
+                rect.right - rect.left,
+                rect.bottom - rect.top), mSize);
+        final float left = rect.left + (rect.right - rect.left - size) / 2;
+        final float top = rect.top + (rect.bottom - rect.top - size) / 2;
+
+        mPath.reset();
+        mPath.moveTo(
+                left + calcTransformation(0, 0, progress, size),
+                top + calcTransformation(1, 0, progress, size));
+        for (int i = 1; i < mVertex[0][0].length; i++) {
+            mPath.lineTo(
+                    left + calcTransformation(0, i, progress, size),
+                    top + calcTransformation(1, i, progress, size));
+        }
+
+        mPath.close();
+        invalidateSelf();
+    }
+
+    public float getTransformation() {
+        return mProgress;
+    }
+
+    private float calcTransformation(int type, int i, float progress, float size) {
+        float v0 = mVertex[mFromShape][type][i] * (1f - progress);
+        float v1 = mVertex[mToShape][type][i] * progress;
+        return (v0 + v1) * size;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        super.onBoundsChange(bounds);
+        setTransformation(mProgress);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void draw(Canvas canvas) {
+        canvas.drawPath(mPath, mPaint);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setAlpha(int alpha) {
+        mPaint.setAlpha(alpha);
+        invalidateSelf();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+        mPaint.setColorFilter(cf);
+        invalidateSelf();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public int getOpacity() {
+        return PixelFormat.TRANSLUCENT;
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/base/ui/fragments/DashboardFragment.java b/project/app/src/main/java/com/achep/base/ui/fragments/DashboardFragment.java
new file mode 100644
index 00000000..3ab0057b
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/ui/fragments/DashboardFragment.java
@@ -0,0 +1,126 @@
+/*
+ * Copyright (C) 2015 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.ui.fragments;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.support.v4.app.Fragment;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.TextView;
+
+import com.achep.acdisplay.R;
+import com.achep.base.dashboard.DashboardCategory;
+import com.achep.base.dashboard.DashboardTile;
+import com.achep.base.ui.activities.SettingsActivity;
+import com.achep.base.ui.widgets.DashboardTileView;
+
+import java.util.List;
+
+import static com.achep.base.Build.DEBUG;
+
+public class DashboardFragment extends Fragment {
+
+    private static final String TAG = "DashboardFragment";
+
+    private LayoutInflater mLayoutInflater;
+    private ViewGroup mDashboardContainer;
+
+    private static final int MSG_REBUILD_UI = 1;
+    private final Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+                case MSG_REBUILD_UI: {
+                    final Context context = getActivity();
+                    rebuildUI(context);
+                }
+                break;
+            }
+        }
+    };
+
+    @Override
+    public void onResume() {
+        super.onResume();
+
+        sendRebuildUI();
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container,
+                             Bundle savedInstanceState) {
+        mLayoutInflater = inflater;
+
+        final View rootView = inflater.inflate(R.layout.dashboard, container, false);
+        mDashboardContainer = (ViewGroup) rootView.findViewById(R.id.dashboard_container);
+        return rootView;
+    }
+
+    private void rebuildUI(Context context) {
+        if (!isAdded()) {
+            Log.w(TAG, "Cannot build the DashboardSummary UI yet as the Fragment is not added");
+            return;
+        }
+
+        final long start = System.currentTimeMillis();
+        final Resources res = getResources();
+
+        mDashboardContainer.removeAllViews();
+
+        SettingsActivity activity = (SettingsActivity) context;
+        List<DashboardCategory> categories = activity.getDashboardCategories(true);
+
+        final int count = categories.size();
+        for (int i = 0; i < count; i++) {
+            DashboardCategory category = categories.get(i);
+
+            View view = mLayoutInflater.inflate(R.layout.dashboard_category, mDashboardContainer, false);
+            TextView labelView = (TextView) view.findViewById(R.id.category_title);
+            labelView.setText(category.getTitle(res));
+            mDashboardContainer.addView(view);
+
+            ViewGroup categoryContent = (ViewGroup) view.findViewById(R.id.category_content);
+
+            for (DashboardTile tile : category) {
+                // Create, fill and add new tile to the category.
+                DashboardTileView tileView = (DashboardTileView)
+                        mLayoutInflater.inflate(R.layout.dashboard_tile, categoryContent, false);
+                tileView.setDashboardTile(tile);
+                categoryContent.addView(tileView);
+            }
+        }
+
+        if (DEBUG) {
+            long delta = System.currentTimeMillis() - start;
+            Log.d(TAG, "Rebuilding GUI took " + delta + "ms.");
+        }
+    }
+
+    private void sendRebuildUI() {
+        if (!mHandler.hasMessages(MSG_REBUILD_UI)) {
+            mHandler.sendEmptyMessage(MSG_REBUILD_UI);
+        }
+    }
+}
diff --git a/project/app/src/main/java/com/achep/base/ui/fragments/PreferenceFragment.java b/project/app/src/main/java/com/achep/base/ui/fragments/PreferenceFragment.java
new file mode 100644
index 00000000..54301407
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/ui/fragments/PreferenceFragment.java
@@ -0,0 +1,217 @@
+/*
+ * Copyright (C) 2015 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.ui.fragments;
+
+import android.app.Activity;
+import android.os.Bundle;
+import android.preference.CheckBoxPreference;
+import android.preference.ListPreference;
+import android.preference.Preference;
+import android.preference.PreferenceScreen;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+import android.view.View;
+import android.view.ViewStub;
+
+import com.achep.acdisplay.R;
+import com.achep.base.content.ConfigBase;
+import com.achep.base.ui.preferences.Enabler;
+import com.achep.base.ui.widgets.SwitchBar;
+
+import static com.achep.base.Build.DEBUG;
+
+public abstract class PreferenceFragment extends PreferenceFragmentBase {
+
+    private static final String TAG = "PreferenceFragment";
+
+    private SwitchBar mSwitch;
+    private String mEnablerKey;
+    private Enabler mEnabler;
+    private ConfigBase mConfig;
+    private ConfigBase.Syncer mSyncer;
+
+    private CheckBoxPreferenceSetter mCheckBoxPreferenceSetter;
+
+    public abstract ConfigBase getConfig();
+
+    /**
+     * Requests the fragment to setup master switch from
+     * the corresponding key.
+     *
+     * @param key the key of one of the {@link com.achep.base.content.ConfigBase}'s options
+     * @see com.achep.base.content.ConfigBase
+     * @see com.achep.base.ui.preferences.Enabler
+     */
+    public void requestMasterSwitch(@NonNull String key) {
+        mEnablerKey = key;
+    }
+
+    @Override
+    public void onAttach(Activity activity) {
+        super.onAttach(activity);
+        mConfig = getConfig();
+        mSyncer = new ConfigBase.Syncer(activity, mConfig);
+    }
+
+    @Override
+    public void onViewCreated(View view, @Nullable Bundle savedInstanceState) {
+        super.onViewCreated(view, savedInstanceState);
+
+        if (mEnablerKey != null) {
+            if (DEBUG) Log.d(TAG, "Creating the enabler for #" + mEnablerKey + " key.");
+
+            // Setup enabler to switch bar.
+            SwitchBar switchBar = getSwitchBar();
+            assert switchBar != null;
+            mEnabler = new Enabler(getActivity(), mConfig, mEnablerKey, switchBar);
+        }
+    }
+
+    @Override
+    public void onResume() {
+        super.onResume();
+        if (mEnabler != null) mEnabler.start();
+        mSyncer.start();
+    }
+
+    @Override
+    public void onPause() {
+        super.onPause();
+        if (mEnabler != null) mEnabler.stop();
+        mSyncer.stop();
+    }
+
+    /**
+     * Synchronizes simple checkbox preference with the config.
+     *
+     * @param key the key of preference & config's parameter.
+     * @see com.achep.acdisplay.Config#getHashMap()
+     */
+    protected void syncPreference(@NonNull String key) {
+        if (mCheckBoxPreferenceSetter == null)
+            mCheckBoxPreferenceSetter = new CheckBoxPreferenceSetter();
+        syncPreference(key, mCheckBoxPreferenceSetter);
+    }
+
+    /**
+     * Synchronizes any preference with the config.
+     *
+     * @param key    the key of preference & config's parameter.
+     * @param setter preference's setter
+     * @see com.achep.acdisplay.Config#getHashMap()
+     * @see ListPreferenceSetter
+     * @see CheckBoxPreferenceSetter
+     */
+    protected void syncPreference(@NonNull String key, @NonNull ConfigBase.Syncer.Setter setter) {
+        Preference preference = findPreference(key);
+        PreferenceScreen preferenceScreen = getPreferenceScreen();
+
+        if (preference == null) {
+            if (DEBUG) Log.d(TAG, "Tried to sync non-existent preference with config.");
+            return;
+        }
+
+        mSyncer.addPreference(preferenceScreen, preference, setter);
+    }
+
+    @Nullable
+    public SwitchBar getSwitchBar() {
+        if (mSwitch == null) {
+            if (getView() == null) {
+                return null;
+            }
+
+            ViewStub stub = (ViewStub) getView().findViewById(R.id.switch_bar_stub);
+            mSwitch = (SwitchBar) stub.inflate().findViewById(R.id.switch_bar);
+        }
+        return mSwitch;
+    }
+
+    protected static class CheckBoxPreferenceSetter implements ConfigBase.Syncer.Setter {
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public final void updateSummary(@NonNull Preference preference,
+                                        @NonNull ConfigBase.Option option,
+                                        @NonNull Object value) {
+            // This is non needed, because you should always use
+            //     android:summaryOn=""
+            //     android:summaryOff=""
+            // attributes.
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void setValue(@NonNull Preference preference,
+                             @NonNull ConfigBase.Option option,
+                             @NonNull Object value) {
+            CheckBoxPreference cbp = (CheckBoxPreference) preference;
+            cbp.setChecked((Boolean) value);
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @NonNull
+        @Override
+        public Object getValue(@NonNull Object value) {
+            return value;
+        }
+
+    }
+
+    protected static class ListPreferenceSetter implements ConfigBase.Syncer.Setter {
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void updateSummary(@NonNull Preference preference,
+                                  @NonNull ConfigBase.Option option,
+                                  @NonNull Object value) { /* unused */ }
+
+        /**
+         * {@inheritDoc}
+         */
+        @Override
+        public void setValue(@NonNull Preference preference,
+                             @NonNull ConfigBase.Option option,
+                             @NonNull Object value) {
+            ListPreference cbp = (ListPreference) preference;
+            cbp.setValue(Integer.toString((Integer) value));
+        }
+
+        /**
+         * {@inheritDoc}
+         */
+        @NonNull
+        @Override
+        public Object getValue(@NonNull Object value) {
+            return Integer.parseInt((String) value);
+        }
+
+    }
+
+}
+
diff --git a/project/app/src/main/java/com/achep/base/ui/fragments/PreferenceFragmentBase.java b/project/app/src/main/java/com/achep/base/ui/fragments/PreferenceFragmentBase.java
new file mode 100644
index 00000000..b08ae708
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/ui/fragments/PreferenceFragmentBase.java
@@ -0,0 +1,402 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.achep.base.ui.fragments;
+
+import android.content.Intent;
+import android.os.Bundle;
+import android.os.Handler;
+import android.os.Message;
+import android.preference.Preference;
+import android.preference.PreferenceManager;
+import android.preference.PreferenceScreen;
+import android.support.v4.app.Fragment;
+import android.view.KeyEvent;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.ListView;
+
+import com.achep.acdisplay.R;
+import com.achep.base.utils.PreferenceManagerUtils;
+
+import java.lang.reflect.InvocationTargetException;
+import java.lang.reflect.Method;
+
+/**
+ * Shows a hierarchy of {@link android.preference.Preference} objects as
+ * lists. These preferences will
+ * automatically save to {@link android.content.SharedPreferences} as the user interacts with
+ * them. To retrieve an instance of {@link android.content.SharedPreferences} that the
+ * preference hierarchy in this fragment will use, call
+ * {@link android.preference.PreferenceManager#getDefaultSharedPreferences(android.content.Context)}
+ * with a context in the same package as this fragment.
+ * <p>
+ * Furthermore, the preferences shown will follow the visual style of system
+ * preferences. It is easy to create a hierarchy of preferences (that can be
+ * shown on multiple screens) via XML. For these reasons, it is recommended to
+ * use this fragment (as a superclass) to deal with preferences in applications.
+ * <p>
+ * A {@link android.preference.PreferenceScreen} object should be at the top of the preference
+ * hierarchy. Furthermore, subsequent {@link android.preference.PreferenceScreen} in the hierarchy
+ * denote a screen break--that is the preferences contained within subsequent
+ * {@link android.preference.PreferenceScreen} should be shown on another screen. The preference
+ * framework handles showing these other screens from the preference hierarchy.
+ * <p>
+ * The preference hierarchy can be formed in multiple ways:
+ * <li> From an XML file specifying the hierarchy
+ * <li> From different {@link android.app.Activity Activities} that each specify its own
+ * preferences in an XML file via {@link android.app.Activity} meta-data
+ * <li> From an object hierarchy rooted with {@link android.preference.PreferenceScreen}
+ * <p>
+ * To inflate from XML, use the {@link #addPreferencesFromResource(int)}. The
+ * root element should be a {@link android.preference.PreferenceScreen}. Subsequent elements can point
+ * to actual {@link android.preference.Preference} subclasses. As mentioned above, subsequent
+ * {@link android.preference.PreferenceScreen} in the hierarchy will result in the screen break.
+ * <p>
+ * To specify an {@link android.content.Intent} to query {@link android.app.Activity Activities} that each
+ * have preferences, use {@link #addPreferencesFromIntent}. Each
+ * {@link android.app.Activity} can specify meta-data in the manifest (via the key
+ * {@link android.preference.PreferenceManager#METADATA_KEY_PREFERENCES}) that points to an XML
+ * resource. These XML resources will be inflated into a single preference
+ * hierarchy and shown by this fragment.
+ * <p>
+ * To specify an object hierarchy rooted with {@link android.preference.PreferenceScreen}, use
+ * {@link #setPreferenceScreen(android.preference.PreferenceScreen)}.
+ * <p>
+ * As a convenience, this fragment implements a click listener for any
+ * preference in the current hierarchy, see
+ * {@link #onPreferenceTreeClick(android.preference.PreferenceScreen, android.preference.Preference)}.
+ * <p/>
+ * <div class="special reference">
+ * <h3>Developer Guides</h3>
+ * <p>For information about using {@code PreferenceFragment},
+ * read the <a href="{@docRoot}guide/topics/ui/settings.html">Settings</a>
+ * guide.</p>
+ * </div>
+ * <p/>
+ * <a name="SampleCode"></a>
+ * <h3>Sample Code</h3>
+ * <p/>
+ * <p>The following sample code shows a simple preference fragment that is
+ * populated from a resource.  The resource it loads is:</p>
+ * <p/>
+ * {@sample development/samples/ApiDemos/res/xml/preferences.xml preferences}
+ * <p/>
+ * <p>The fragment implementation itself simply populates the preferences
+ * when created.  Note that the preferences framework takes care of loading
+ * the current values out of the app preferences and writing them when changed:</p>
+ * <p/>
+ * {@sample development/samples/ApiDemos/src/com/example/android/apis/preference/FragmentPreferences.java
+ * fragment}
+ *
+ * @see android.preference.Preference
+ * @see android.preference.PreferenceScreen
+ */
+public abstract class PreferenceFragmentBase extends Fragment implements
+        PreferenceManagerUtils.OnPreferenceTreeClickListener {
+
+    private static final String PREFERENCES_TAG = "android:preferences";
+
+    private PreferenceManager mPreferenceManager;
+    private ListView mList;
+    private boolean mHavePrefs;
+    private boolean mInitDone;
+
+    /**
+     * The starting request code given out to preference framework.
+     */
+    private static final int FIRST_REQUEST_CODE = 100;
+
+    private static final int MSG_BIND_PREFERENCES = 1;
+    private Handler mHandler = new Handler() {
+        @Override
+        public void handleMessage(Message msg) {
+            switch (msg.what) {
+
+                case MSG_BIND_PREFERENCES:
+                    bindPreferences();
+                    break;
+            }
+        }
+    };
+
+    final private Runnable mRequestFocus = new Runnable() {
+        public void run() {
+            mList.focusableViewAvailable(mList);
+        }
+    };
+
+    /**
+     * Interface that PreferenceFragment's containing activity should
+     * implement to be able to process preference items that wish to
+     * switch to a new fragment.
+     */
+    public interface OnPreferenceStartFragmentCallback {
+
+        /**
+         * Called when the user has clicked on a Preference that has
+         * a fragment class name associated with it.  The implementation
+         * to should instantiate and switch to an instance of the given
+         * fragment.
+         */
+        boolean onPreferenceStartFragment(PreferenceFragmentBase caller, Preference pref);
+
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        mPreferenceManager = PreferenceManagerUtils.newInstance(getActivity(), FIRST_REQUEST_CODE);
+        PreferenceManagerUtils.setFragment(mPreferenceManager, this);
+    }
+
+    @Override
+    public View onCreateView(LayoutInflater inflater, ViewGroup container,
+                             Bundle savedInstanceState) {
+        return inflater.inflate(R.layout.preference_list_fragment, container, false);
+    }
+
+    @Override
+    public void onActivityCreated(Bundle savedInstanceState) {
+        super.onActivityCreated(savedInstanceState);
+
+        if (mHavePrefs) {
+            bindPreferences();
+        }
+
+        mInitDone = true;
+
+        if (savedInstanceState != null) {
+            Bundle container = savedInstanceState.getBundle(PREFERENCES_TAG);
+            if (container != null) {
+                final PreferenceScreen preferenceScreen = getPreferenceScreen();
+                if (preferenceScreen != null) {
+                    preferenceScreen.restoreHierarchyState(container);
+                }
+            }
+        }
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        PreferenceManagerUtils.setOnPreferenceTreeClickListener(mPreferenceManager, this);
+    }
+
+    @Override
+    public void onStop() {
+        super.onStop();
+        PreferenceManagerUtils.dispatchActivityStop(mPreferenceManager);
+        PreferenceManagerUtils.setOnPreferenceTreeClickListener(mPreferenceManager, null);
+    }
+
+    @Override
+    public void onDestroyView() {
+        mList = null;
+        mHandler.removeCallbacks(mRequestFocus);
+        mHandler.removeMessages(MSG_BIND_PREFERENCES);
+        super.onDestroyView();
+    }
+
+    @Override
+    public void onDestroy() {
+        super.onDestroy();
+        PreferenceManagerUtils.dispatchActivityDestroy(mPreferenceManager);
+    }
+
+    @Override
+    public void onSaveInstanceState(Bundle outState) {
+        super.onSaveInstanceState(outState);
+
+        final PreferenceScreen preferenceScreen = getPreferenceScreen();
+        if (preferenceScreen != null) {
+            Bundle container = new Bundle();
+            preferenceScreen.saveHierarchyState(container);
+            outState.putBundle(PREFERENCES_TAG, container);
+        }
+    }
+
+    @Override
+    public void onActivityResult(int requestCode, int resultCode, Intent data) {
+        super.onActivityResult(requestCode, resultCode, data);
+
+        PreferenceManagerUtils.dispatchActivityResult(mPreferenceManager, requestCode, resultCode, data);
+    }
+
+    /**
+     * Returns the {@link android.preference.PreferenceManager} used by this fragment.
+     *
+     * @return The {@link android.preference.PreferenceManager}.
+     */
+    public PreferenceManager getPreferenceManager() {
+        return mPreferenceManager;
+    }
+
+    /**
+     * Sets the root of the preference hierarchy that this fragment is showing.
+     *
+     * @param preferenceScreen The root {@link android.preference.PreferenceScreen} of the preference hierarchy.
+     */
+    public void setPreferenceScreen(PreferenceScreen preferenceScreen) {
+        boolean r = PreferenceManagerUtils.setPreferences(mPreferenceManager, preferenceScreen);
+        if (r && preferenceScreen != null) {
+            onUnbindPreferences();
+            mHavePrefs = true;
+            if (mInitDone) {
+                postBindPreferences();
+            }
+        }
+    }
+
+    /**
+     * Gets the root of the preference hierarchy that this fragment is showing.
+     *
+     * @return The {@link android.preference.PreferenceScreen} that is the root of the preference
+     * hierarchy.
+     */
+    public PreferenceScreen getPreferenceScreen() {
+        return PreferenceManagerUtils.getPreferenceScreen(mPreferenceManager);
+    }
+
+    /**
+     * Adds preferences from activities that match the given {@link android.content.Intent}.
+     *
+     * @param intent The {@link android.content.Intent} to query activities.
+     */
+    public void addPreferencesFromIntent(Intent intent) {
+        requirePreferenceManager();
+        setPreferenceScreen(PreferenceManagerUtils.inflateFromIntent(
+                mPreferenceManager, intent, getPreferenceScreen()));
+    }
+
+    /**
+     * Inflates the given XML resource and adds the preference hierarchy to the current
+     * preference hierarchy.
+     *
+     * @param preferencesResId The XML resource ID to inflate.
+     */
+    public void addPreferencesFromResource(int preferencesResId) {
+        requirePreferenceManager();
+        setPreferenceScreen(PreferenceManagerUtils.inflateFromResource(
+                mPreferenceManager, getActivity(), preferencesResId, getPreferenceScreen()));
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    public boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen,
+                                         Preference preference) {
+        return preference.getFragment() != null
+                && getActivity() instanceof PreferenceFragmentBase.OnPreferenceStartFragmentCallback
+                && ((PreferenceFragmentBase.OnPreferenceStartFragmentCallback) getActivity())
+                .onPreferenceStartFragment(this, preference);
+    }
+
+    /**
+     * Finds a {@link android.preference.Preference} based on its key.
+     *
+     * @param key The key of the preference to retrieve.
+     * @return The {@link android.preference.Preference} with the key, or null.
+     * @see android.preference.PreferenceGroup#findPreference(CharSequence)
+     */
+    public Preference findPreference(CharSequence key) {
+        if (mPreferenceManager == null) {
+            return null;
+        }
+        return mPreferenceManager.findPreference(key);
+    }
+
+    private void requirePreferenceManager() {
+        if (mPreferenceManager == null) {
+            throw new RuntimeException("This should be called after super.onCreate.");
+        }
+    }
+
+    private void postBindPreferences() {
+        if (mHandler.hasMessages(MSG_BIND_PREFERENCES)) return;
+        mHandler.obtainMessage(MSG_BIND_PREFERENCES).sendToTarget();
+    }
+
+    private void bindPreferences() {
+        final PreferenceScreen preferenceScreen = getPreferenceScreen();
+        if (preferenceScreen != null) {
+            preferenceScreen.bind(getListView());
+        }
+        onBindPreferences();
+    }
+
+    /**
+     * @hide
+     */
+    protected void onBindPreferences() {
+    }
+
+    /**
+     * @hide
+     */
+    protected void onUnbindPreferences() {
+    }
+
+    /**
+     * @hide
+     */
+    public ListView getListView() {
+        ensureList();
+        return mList;
+    }
+
+    private void ensureList() {
+        if (mList != null) {
+            return;
+        }
+        View root = getView();
+        if (root == null) {
+            throw new IllegalStateException("Content view not yet created");
+        }
+        View rawListView = root.findViewById(android.R.id.list);
+        if (!(rawListView instanceof ListView)) {
+            throw new RuntimeException(
+                    "Content has view with id attribute 'android.R.id.list' "
+                            + "that is not a ListView class");
+        }
+        mList = (ListView) rawListView;
+        mList.setOnKeyListener(mListOnKeyListener);
+        mHandler.post(mRequestFocus);
+    }
+
+    private View.OnKeyListener mListOnKeyListener = new View.OnKeyListener() {
+
+        @Override
+        public boolean onKey(View v, int keyCode, KeyEvent event) {
+            Object selectedItem = mList.getSelectedItem();
+            if (selectedItem instanceof Preference) {
+                View selectedView = mList.getSelectedView();
+                Preference pref = (Preference) selectedItem;
+
+                try {
+                    Method method = pref.getClass().getDeclaredMethod("onKey",
+                            View.class, int.class, KeyEvent.class);
+                    method.setAccessible(true);
+                    return (boolean) method.invoke(pref, selectedView, keyCode, event);
+                } catch (NoSuchMethodException
+                        | InvocationTargetException
+                        | IllegalAccessException ignored) { /* unused*/ }
+            }
+            return false;
+        }
+
+    };
+}
diff --git a/project/app/src/main/java/com/achep/base/ui/fragments/dialogs/AboutDialog.java b/project/app/src/main/java/com/achep/base/ui/fragments/dialogs/AboutDialog.java
new file mode 100644
index 00000000..5164cdfb
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/ui/fragments/dialogs/AboutDialog.java
@@ -0,0 +1,148 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.ui.fragments.dialogs;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.Context;
+import android.content.pm.PackageInfo;
+import android.content.pm.PackageManager;
+import android.content.res.Resources;
+import android.graphics.Color;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.text.Html;
+import android.text.Spanned;
+import android.util.Log;
+import android.view.ContextThemeWrapper;
+import android.view.View;
+import android.widget.Toast;
+
+import com.achep.acdisplay.R;
+import com.achep.base.Build;
+import com.achep.base.ui.DialogBuilder;
+import com.achep.base.utils.ToastUtils;
+
+/**
+ * Dialog fragment that shows some info about this application.
+ *
+ * @author Artem Chepurnoy
+ */
+public class AboutDialog extends DialogFragment {
+
+    private static final String TAG = "AboutDialog";
+
+    private static final int EASTER_EGGS_CLICK_NUMBER = 5;
+
+    private int mTitleClickNumber;
+    private ToastUtils.SingleToast mTimeStampToast;
+
+    /**
+     * Merges app name and version name into one.
+     */
+    @NonNull
+    public static Spanned getVersionName(@NonNull Context context) {
+        PackageManager pm = context.getPackageManager();
+        String packageName = context.getPackageName();
+        String versionName;
+        try {
+            PackageInfo info = pm.getPackageInfo(packageName, 0);
+            versionName = info.versionName;
+
+            // Make the info part of version name a bit smaller.
+            if (versionName.indexOf('-') >= 0) {
+                versionName = versionName.replaceFirst("\\-", "<small>-") + "</small>";
+            }
+        } catch (PackageManager.NameNotFoundException e) {
+            versionName = "N/A";
+        }
+
+        /*
+            int[] attribute = {android.R.attr.textColorHint};
+            TypedArray a = context.obtainStyledAttributes(android.R.attr.textAppearance, attribute);
+            int color = a.getColor(0, 0xFF888888);
+            a.recycle();
+        */
+        // TODO: Get the color from current theme.
+        int color = 0xFF888888;
+
+        Resources res = context.getResources();
+        return Html.fromHtml(
+                res.getString(R.string.about_dialog_title,
+                        res.getString(R.string.app_name),
+                        versionName,
+                        Integer.toHexString(Color.red(color))
+                                + Integer.toHexString(Color.green(color))
+                                + Integer.toHexString(Color.blue(color)))
+        );
+    }
+
+    @Override
+    public void onAttach(Activity activity) {
+        super.onAttach(activity);
+        mTimeStampToast = new ToastUtils.SingleToast(activity);
+    }
+
+    @NonNull
+    @Override
+    public Dialog onCreateDialog(Bundle savedInstanceState) {
+        ContextThemeWrapper context = getActivity();
+        assert context != null;
+
+        String year = Build.TIME_STAMP.substring(Build.TIME_STAMP.lastIndexOf(' ') + 1);
+        if (year.charAt(0) != '2') Log.w(TAG, "The build year is corrupted! Check build script.");
+        CharSequence credits = getString(R.string.about_dialog_credits);
+        CharSequence message = Html.fromHtml(getString(R.string.about_dialog_message, credits, year));
+
+        View view = new DialogBuilder(context)
+                .setIcon(R.drawable.ic_action_about_white)
+                .setTitle(getVersionName(context))
+                .setMessage(message)
+                .createView();
+        View title = view.findViewById(R.id.title);
+        title.setOnClickListener(new View.OnClickListener() {
+
+            @Override
+            public void onClick(View v) {
+                switch (mTitleClickNumber++) {
+                    case EASTER_EGGS_CLICK_NUMBER:
+                        /*
+                        Intent intent = new Intent(getActivity(), MainActivity.class)
+                                .addFlags(Intent.FLAG_ACTIVITY_NO_ANIMATION);
+                        startActivity(intent);
+                        */
+
+                        // Reset click counter.
+                        mTitleClickNumber = 0;
+                        break;
+                    default:
+                        mTimeStampToast.show(Build.TIME_STAMP, Toast.LENGTH_LONG);
+                }
+            }
+
+        });
+
+        return new AlertDialog.Builder(context)
+                .setView(view)
+                .setNegativeButton(R.string.close, null)
+                .create();
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/base/ui/fragments/dialogs/DialogFragment.java b/project/app/src/main/java/com/achep/base/ui/fragments/dialogs/DialogFragment.java
new file mode 100644
index 00000000..cee32994
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/ui/fragments/dialogs/DialogFragment.java
@@ -0,0 +1,25 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.ui.fragments.dialogs;
+
+/**
+ * Created by Artem Chepurnoy on 25.10.2014.
+ */
+public abstract class DialogFragment extends android.support.v4.app.DialogFragment {
+}
\ No newline at end of file
diff --git a/project/app/src/main/java/com/achep/base/ui/fragments/dialogs/DonateDialog.java b/project/app/src/main/java/com/achep/base/ui/fragments/dialogs/DonateDialog.java
new file mode 100644
index 00000000..fb615c35
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/ui/fragments/dialogs/DonateDialog.java
@@ -0,0 +1,529 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.ui.fragments.dialogs;
+
+import android.app.Activity;
+import android.app.AlertDialog;
+import android.app.Dialog;
+import android.content.ActivityNotFoundException;
+import android.content.Context;
+import android.content.DialogInterface;
+import android.content.Intent;
+import android.net.Uri;
+import android.os.Bundle;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.LayoutRes;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.annotation.StringRes;
+import android.text.Spannable;
+import android.text.SpannableString;
+import android.text.style.ImageSpan;
+import android.util.Log;
+import android.view.LayoutInflater;
+import android.view.View;
+import android.view.ViewGroup;
+import android.widget.AdapterView;
+import android.widget.Button;
+import android.widget.FrameLayout;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.ProgressBar;
+
+import com.achep.acdisplay.App;
+import com.achep.acdisplay.R;
+import com.achep.acdisplay.ui.view.HeaderGridView;
+import com.achep.base.billing.Bitcoin;
+import com.achep.base.billing.PayPal;
+import com.achep.base.ui.DialogBuilder;
+import com.achep.base.ui.activities.ActivityBase;
+import com.achep.base.ui.adapters.BetterArrayAdapter;
+import com.achep.base.ui.widgets.TextView;
+import com.achep.base.utils.CoinUtils;
+import com.achep.base.utils.IntentUtils;
+import com.achep.base.utils.RippleUtils;
+import com.achep.base.utils.ToastUtils;
+import com.achep.base.utils.ViewUtils;
+
+import org.solovyev.android.checkout.ActivityCheckout;
+import org.solovyev.android.checkout.BillingRequests;
+import org.solovyev.android.checkout.Checkout;
+import org.solovyev.android.checkout.Inventory;
+import org.solovyev.android.checkout.ProductTypes;
+import org.solovyev.android.checkout.Purchase;
+import org.solovyev.android.checkout.RequestListener;
+import org.solovyev.android.checkout.ResponseCodes;
+import org.solovyev.android.checkout.Sku;
+
+import java.util.Comparator;
+
+import static com.achep.base.Build.DEBUG;
+
+/**
+ * Created by Artem Chepurnoy on 13.12.2014.
+ */
+public class DonateDialog extends DialogFragment {
+
+    private static final String TAG = "DonateFragment";
+
+    private static final int SCREEN_LOADING = 1;
+    private static final int SCREEN_INVENTORY = 2;
+    private static final int SCREEN_EMPTY_VIEW = 4;
+
+    private TextView mEmptyView;
+    private ProgressBar mProgressBar;
+
+    private Inventory mInventory;
+    private ActivityCheckout mCheckout;
+    private final PurchaseListener mPurchaseListener = new PurchaseListener();
+    private final InventoryLoadedListener mInventoryLoadedListener = new InventoryLoadedListener();
+
+    private SkusAdapter mAdapter;
+
+    @Override
+    public void onAttach(Activity activity) {
+        super.onAttach(activity);
+        if (activity instanceof ActivityBase) {
+            ActivityBase ma = (ActivityBase) activity;
+            mCheckout = ma.getCheckout();
+
+            if (mCheckout == null) throw new RuntimeException("You must call #requestCheckout()" +
+                    " on the activity before!");
+        } else throw new RuntimeException("Host activity must be an " +
+                "instance of ActivityBase.class!");
+    }
+
+    @Override
+    public void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        mInventory = mCheckout.loadInventory();
+    }
+
+    @NonNull
+    @Override
+    public Dialog onCreateDialog(Bundle savedInstanceState) {
+        View view = new DialogBuilder(getActivity())
+                .setIcon(R.drawable.ic_action_donate_white)
+                .setTitle(R.string.donate_dialog_title)
+                .setView(R.layout.dialog_donate)
+                .createSkeletonView();
+
+        LayoutInflater inflater = (LayoutInflater) getActivity()
+                .getSystemService(Context.LAYOUT_INFLATER_SERVICE);
+        FrameLayout frameLayout = new FrameLayout(getActivity()); //
+
+        // Init description message.
+        TextView textView = (TextView) inflater.inflate(R.layout.dialog_message, frameLayout, false);
+        textView.setText(R.string.donate_dialog_message);
+        textView.setPadding(0, textView.getPaddingTop(), 0, textView.getPaddingBottom() / 2);
+
+        // Init view with error view and progressbar-s.
+        View phView = inflater.inflate(R.layout.dialog_donate_placeholder, frameLayout, false);
+        mProgressBar = (ProgressBar) phView.findViewById(R.id.progress);
+        mEmptyView = (TextView) phView.findViewById(R.id.empty);
+
+        HeaderGridView gv = (HeaderGridView) view.findViewById(R.id.grid);
+        gv.addHeaderView(textView, null, false);
+        gv.addHeaderView(phView, null, false);
+        gv.setAdapter(mAdapter = new SkusAdapter(getActivity(), R.layout.sku));
+        gv.setOnItemClickListener(new AdapterView.OnItemClickListener() {
+            @Override
+            public void onItemClick(AdapterView<?> parent, View view, int position, long id) {
+                SkuUi skuUi = (SkuUi) parent.getAdapter().getItem(position);
+                purchase(skuUi.sku);
+            }
+        });
+
+        return initDialog(new AlertDialog.Builder(getActivity())
+                .setView(view)
+                .setNeutralButton(R.string.close, null));
+    }
+
+    @NonNull
+    private AlertDialog initDialog(final @NonNull AlertDialog.Builder builder) {
+        if (!getResources().getBoolean(R.bool.config_alternative_payments)) {
+            return builder.create();
+        }
+
+        final Bitcoin btc = new Bitcoin();
+        final PayPal pp = new PayPal();
+        final AlertDialog alertDialog = builder
+                .setPositiveButton(btc.getNameResource(), null)
+                .setNegativeButton(pp.getNameResource(), null)
+                .create();
+        alertDialog.setOnShowListener(new DialogInterface.OnShowListener() {
+
+            final class Data {
+
+                private final Button button;
+                private final Intent intent;
+                private final int titleResource;
+                private final int iconResource;
+
+                private Data(Button button, Intent intent,
+                             @StringRes int titleResource,
+                             @DrawableRes int iconResource) {
+                    this.button = button;
+                    this.intent = intent;
+                    this.titleResource = titleResource;
+                    this.iconResource = iconResource;
+                }
+            }
+
+            @Override
+            public void onShow(DialogInterface dialog) {
+                Intent intentPp = CoinUtils.getPaymentIntent(pp);
+                Intent intentBtc = CoinUtils.getPaymentIntent(btc);
+                if (!IntentUtils.hasActivityForThat(getActivity(), intentBtc)) {
+                    Uri uri = btc.getUriBrowseWallet();
+                    intentBtc = IntentUtils.createViewIntent(uri);
+                }
+
+                Data[] datas = new Data[]{
+                        new Data(
+                                alertDialog.getButton(DialogInterface.BUTTON_NEGATIVE),
+                                intentPp, R.string.paypal, R.drawable.ic_action_paypal),
+                        new Data(
+                                alertDialog.getButton(DialogInterface.BUTTON_POSITIVE),
+                                intentBtc, R.string.bitcoin, R.drawable.ic_action_bitcoin),
+                };
+
+                ImageSpan span;
+                SpannableString text;
+                for (final Data data : datas) {
+                    final Button btn = data.button;
+                    if (btn != null) {
+                        // FIXME: Somehow this doesn't work correctly on lollipop devices
+                        // and some other too.
+                        span = new ImageSpan(getActivity(), data.iconResource);
+
+                        // Replace text with an icon.
+                        // This is a workaround to fix compound button's aligment.
+                        text = new SpannableString(getString(data.titleResource));
+                        text.setSpan(span, 0, text.length(), Spannable.SPAN_EXCLUSIVE_EXCLUSIVE);
+                        btn.setText(text);
+
+                        // Eat default weight.
+                        btn.setLayoutParams(new LinearLayout.LayoutParams(
+                                ViewGroup.LayoutParams.WRAP_CONTENT,
+                                ViewGroup.LayoutParams.WRAP_CONTENT));
+
+                        btn.setOnClickListener(new View.OnClickListener() {
+                            @Override
+                            public void onClick(View v) {
+                                startPaymentIntentWithWarningAlertDialog(data.intent);
+                            }
+                        });
+                    }
+                }
+            }
+        });
+        return alertDialog;
+    }
+
+    @Override
+    public void onStart() {
+        super.onStart();
+        mCheckout.createPurchaseFlow(mPurchaseListener);
+        reloadInventory();
+    }
+
+    @Override
+    public void onStop() {
+        mCheckout.destroyPurchaseFlow();
+        super.onStop();
+    }
+
+    /**
+     * Shows a warning alert dialog to note, that those methods
+     * may suck hard and nobody will care about it.<br/>
+     * Starts an intent if user is agree with it.
+     */
+    private void startPaymentIntentWithWarningAlertDialog(final Intent intent) {
+        CharSequence messageText = getString(R.string.donate_alert_no_responsibility);
+        new DialogBuilder(getActivity())
+                .setMessage(messageText)
+                .createAlertDialogBuilder()
+                .setNegativeButton(android.R.string.cancel, null)
+                .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
+                    @Override
+                    public void onClick(DialogInterface dialog, int which) {
+                        try {
+                            startActivity(intent);
+                            dismiss(); // Dismiss main fragment
+                        } catch (ActivityNotFoundException e) { /* hell no */ }
+                    }
+                })
+                .create()
+                .show();
+    }
+
+    private void showScene(int visibility) {
+        ViewUtils.setVisible(mProgressBar, visibility == SCREEN_LOADING);
+        ViewUtils.setVisible(mEmptyView, visibility == SCREEN_EMPTY_VIEW);
+    }
+
+    private void reloadInventory() {
+        showScene(SCREEN_LOADING);
+        mInventory.load().whenLoaded(mInventoryLoadedListener);
+    }
+
+    private void purchase(@NonNull final Sku sku) {
+        if (DEBUG) Log.d(TAG, "Purchasing " + sku.toString() + "...");
+        mCheckout.whenReady(new Checkout.ListenerAdapter() {
+            @Override
+            public void onReady(@NonNull BillingRequests requests) {
+                requests.purchase(sku, null, mCheckout.getPurchaseFlow());
+            }
+        });
+    }
+
+    private class InventoryLoadedListener implements Inventory.Listener {
+
+        @Override
+        public void onLoaded(@NonNull Inventory.Products products) {
+            final Inventory.Product product = products.get(ProductTypes.IN_APP);
+            mAdapter.setNotifyOnChange(false);
+            mAdapter.clear();
+
+            if (product.supported) {
+                for (Sku sku : product.getSkus()) {
+                    final Purchase purchase = product.getPurchaseInState(sku, Purchase.State.PURCHASED);
+                    final SkuUi skuUi = new SkuUi(sku, purchase != null);
+                    mAdapter.add(skuUi);
+                }
+
+                // Sort items by prices.
+                mAdapter.sort(new Comparator<SkuUi>() {
+                    @Override
+                    public int compare(@NonNull SkuUi l, @NonNull SkuUi r) {
+                        return (int) (l.sku.detailedPrice.amount - r.sku.detailedPrice.amount);
+                    }
+                });
+                showScene(SCREEN_INVENTORY);
+            } else {
+                mEmptyView.setText(R.string.donate_billing_not_supported);
+                showScene(SCREEN_EMPTY_VIEW);
+            }
+
+            mAdapter.notifyDataSetChanged();
+        }
+
+    }
+
+    private abstract class BaseRequestListener<T> implements RequestListener<T> {
+
+        @Override
+        public void onError(int response, @NonNull Exception e) {
+            ToastUtils.showShort(getActivity(), e.getLocalizedMessage());
+        }
+
+    }
+
+    private class PurchaseListener extends BaseRequestListener<Purchase> {
+
+        @Override
+        public void onSuccess(@NonNull Purchase purchase) {
+            purchased();
+        }
+
+        @Override
+        public void onError(int response, @NonNull Exception e) {
+            switch (response) {
+                case ResponseCodes.ITEM_ALREADY_OWNED:
+                    purchased();
+                    break;
+                default:
+                    super.onError(response, e);
+            }
+        }
+
+        private void purchased() {
+            reloadInventory();
+            ToastUtils.showLong(getActivity(), R.string.donate_thanks);
+        }
+
+    }
+
+    /**
+     * Created by Artem Chepurnoy on 23.12.2014.
+     */
+    private static class SkusAdapter extends BetterArrayAdapter<SkuUi> {
+
+        private static final class ViewHolder extends BetterArrayAdapter.ViewHolder {
+
+            @NonNull
+            private final android.widget.TextView description;
+
+            @NonNull
+            private final android.widget.TextView price;
+
+            @NonNull
+            private final android.widget.TextView currency;
+
+            @NonNull
+            private final ImageView done;
+
+            public ViewHolder(@NonNull View view) {
+                super(view);
+                description = (android.widget.TextView) view.findViewById(R.id.description);
+                View layout = view.findViewById(R.id.cost);
+                price = (android.widget.TextView) layout.findViewById(R.id.price);
+                currency = (android.widget.TextView) layout.findViewById(R.id.currency);
+                done = (ImageView) layout.findViewById(R.id.done);
+            }
+
+        }
+
+        public SkusAdapter(@NonNull Context context, @LayoutRes int layoutRes) {
+            super(context, layoutRes);
+        }
+
+        @NonNull
+        @Override
+        public BetterArrayAdapter.ViewHolder onCreateViewHolder(@NonNull View view) {
+            return new ViewHolder(view);
+        }
+
+        @Override
+        public void onBindViewHolder(@NonNull BetterArrayAdapter.ViewHolder viewHolder, int i) {
+            fill(mContext, (ViewHolder) viewHolder, getItem(i));
+        }
+
+        private static void fill(@NonNull Context context,
+                                 @NonNull ViewHolder holder,
+                                 @NonNull SkuUi skuUi) {
+            RippleUtils.makeFor(holder.view, true);
+            holder.description.setText(skuUi.getDescription());
+
+            int visibility;
+            if (skuUi.isPurchased()) {
+                visibility = View.GONE;
+                holder.done.setVisibility(View.VISIBLE);
+            } else {
+                visibility = View.VISIBLE;
+                holder.price.setText(skuUi.getPriceAmount());
+                holder.currency.setText(skuUi.getPriceCurrency());
+                holder.done.setVisibility(View.GONE);
+            }
+
+            holder.price.setVisibility(visibility);
+            holder.currency.setVisibility(visibility);
+        }
+
+    }
+
+    /**
+     * @author Artem Chepurnoy
+     */
+    private static class SkuUi {
+
+        @NonNull
+        private static final String TAG = "SkuUi";
+
+        private static final long MICRO = 1_000_000; // defines how much 'micro' is
+
+        @NonNull
+        public final Sku sku;
+
+        private final boolean isPurchased;
+
+        @Nullable
+        private String description;
+
+        public SkuUi(@NonNull Sku sku, boolean isPurchased) {
+            this.sku = sku;
+            this.isPurchased = isPurchased;
+        }
+
+        @NonNull
+        private static String createDescription(@NonNull Sku sku) {
+            String prefix = "donation_";
+            if (sku.id.startsWith(prefix)) {
+                int[] data = new int[]{
+                        1, R.string.donation_1,
+                        4, R.string.donation_4,
+                        10, R.string.donation_10,
+                        20, R.string.donation_20,
+                        50, R.string.donation_50,
+                        99, R.string.donation_99,
+                };
+
+                int price = Integer.parseInt(sku.id.substring(prefix.length()));
+                for (int i = 0; i < data.length; i += 2) {
+                    if (price == data[i]) {
+                        Context context = App.get();
+                        return context.getString(data[i + 1]);
+                    }
+                }
+            }
+
+            Log.wtf(TAG, "Alien sku found!");
+            return "Alien sku found!";
+        }
+
+        /**
+         * @return the price of the sku in {@link #getPriceCurrency() currency}.
+         * @see #getPriceCurrency()
+         * @see #getDescription()
+         */
+        @NonNull
+        public String getPriceAmount() {
+            long amountMicro = sku.detailedPrice.amount;
+            if (amountMicro % MICRO == 0) {
+                // Format it 'as int' number to
+                // get rid of unused comma.
+                long amount = amountMicro / MICRO;
+                return String.valueOf(amount);
+            }
+
+            double amount = (double) amountMicro / MICRO;
+            return String.valueOf(amount);
+        }
+
+        /**
+         * @return the currency of the price.
+         * @see #getPriceAmount()
+         */
+        @NonNull
+        public String getPriceCurrency() {
+            return sku.detailedPrice.currency;
+        }
+
+        /**
+         * The thing that you may buy for that money.
+         *
+         * @see #getPriceAmount()
+         */
+        @NonNull
+        public String getDescription() {
+            if (description == null)
+                description = createDescription(sku);
+            return description;
+        }
+
+        /**
+         * @return {@code true} if the sku is purchased, {@code false} otherwise.
+         */
+        public boolean isPurchased() {
+            return isPurchased;
+        }
+
+    }
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/fragments/FeedbackDialog.java b/project/app/src/main/java/com/achep/base/ui/fragments/dialogs/FeedbackDialog.java
similarity index 50%
rename from project/app/src/main/java/com/achep/acdisplay/fragments/FeedbackDialog.java
rename to project/app/src/main/java/com/achep/base/ui/fragments/dialogs/FeedbackDialog.java
index 63676729..14909988 100644
--- a/project/app/src/main/java/com/achep/acdisplay/fragments/FeedbackDialog.java
+++ b/project/app/src/main/java/com/achep/base/ui/fragments/dialogs/FeedbackDialog.java
@@ -16,12 +16,11 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.fragments;
+package com.achep.base.ui.fragments.dialogs;
 
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.app.Dialog;
-import android.app.DialogFragment;
 import android.content.Context;
 import android.content.DialogInterface;
 import android.content.Intent;
@@ -29,47 +28,52 @@ import android.content.pm.PackageInfo;
 import android.content.pm.PackageManager;
 import android.net.Uri;
 import android.os.Bundle;
-import android.util.Log;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.support.v4.app.DialogFragment;
+import android.support.v7.app.ActionBarActivity;
 import android.view.View;
 import android.view.ViewGroup;
 import android.view.ViewStub;
 import android.widget.AdapterView;
 import android.widget.Button;
 import android.widget.CheckBox;
-import android.widget.CompoundButton;
 import android.widget.EditText;
 import android.widget.Spinner;
 
-import com.achep.acdisplay.Build;
 import com.achep.acdisplay.Config;
-import com.achep.acdisplay.Device;
 import com.achep.acdisplay.DialogHelper;
 import com.achep.acdisplay.R;
 import com.achep.acdisplay.providers.LogAttachmentProvider;
-import com.achep.acdisplay.utils.FileUtils;
-import com.achep.acdisplay.utils.IntentUtils;
-import com.achep.acdisplay.utils.PackageUtils;
-import com.achep.acdisplay.utils.ToastUtils;
-import com.achep.acdisplay.utils.ViewUtils;
-
-import java.io.BufferedReader;
-import java.io.BufferedWriter;
+import com.achep.base.Build;
+import com.achep.base.Device;
+import com.achep.base.content.ConfigBase;
+import com.achep.base.providers.LogsProviderBase;
+import com.achep.base.ui.DialogBuilder;
+import com.achep.base.utils.FileUtils;
+import com.achep.base.utils.IntentUtils;
+import com.achep.base.utils.PackageUtils;
+import com.achep.base.utils.ToastUtils;
+import com.achep.base.utils.ViewUtils;
+import com.achep.base.utils.logcat.Logcat;
+
+import org.json.JSONException;
+import org.json.JSONObject;
+
 import java.io.File;
-import java.io.FileOutputStream;
-import java.io.IOException;
-import java.io.InputStreamReader;
-import java.io.OutputStreamWriter;
 import java.text.SimpleDateFormat;
 import java.util.Date;
 import java.util.Locale;
 import java.util.TimeZone;
 
+import static com.achep.base.Build.DEBUG;
+
 /**
  * Feedback dialog fragment.
  * <p/>
  * Provides an UI for sending bugs & suggestions on my email.
  */
-public class FeedbackDialog extends DialogFragment implements Config.OnConfigChangedListener {
+public class FeedbackDialog extends DialogFragment implements ConfigBase.OnConfigChangedListener {
 
     private static final String TAG = "FeedbackDialog";
 
@@ -79,12 +83,12 @@ public class FeedbackDialog extends DialogFragment implements Config.OnConfigCha
     private EditText mEditText;
     private CheckBox mAttachLogCheckBox;
 
-    private AdapterView.OnItemSelectedListener mListener =
+    private final AdapterView.OnItemSelectedListener mListener =
             new AdapterView.OnItemSelectedListener() {
                 @Override
                 public void onItemSelected(AdapterView<?> parent, View view, int position, long id) {
                     // Show "Attach log" checkbox only if the type
-                    // of this message is "Bug".
+                    // of this message is "Issue".
                     ViewUtils.setVisible(mAttachLogCheckBox, position == 0);
                 }
 
@@ -99,43 +103,46 @@ public class FeedbackDialog extends DialogFragment implements Config.OnConfigCha
         super.onResume();
 
         Config config = Config.getInstance();
-        Config.Triggers triggers = config.getTriggers();
-
         config.registerListener(this);
-        updateFaqPanel(triggers.isHelpRead());
+
+        updateFaqPanel(config.getTriggers().isHelpRead());
     }
 
     @Override
     public void onPause() {
-        super.onPause();
-
         Config config = Config.getInstance();
         config.unregisterListener(this);
+
+        super.onPause();
     }
 
     @Override
-    public void onConfigChanged(Config config, String key, Object value) {
+    public void onConfigChanged(@NonNull ConfigBase config,
+                                @NonNull String key,
+                                @NonNull Object value) {
         switch (key) {
             case Config.KEY_TRIG_HELP_READ:
-                updateFaqPanel((boolean) value);
+                boolean read = (boolean) value;
+                updateFaqPanel(read);
                 break;
         }
     }
 
+    @NonNull
     @Override
     public Dialog onCreateDialog(Bundle savedInstanceState) {
         Activity activity = getActivity();
         assert activity != null;
 
-        View view = new DialogHelper.Builder(activity)
-                .setIcon(getResources().getDrawable(R.drawable.ic_dialog_mail))
-                .setTitle(getString(R.string.feedback))
-                .setView(R.layout.fragment_dialog_feedback)
+        View view = new DialogBuilder(activity)
+                .setIcon(getResources().getDrawable(R.drawable.ic_action_feedback_white))
+                .setTitle(getString(R.string.feedback_dialog_title))
+                .setView(R.layout.feedback_dialog)
                 .createSkeletonView();
         final AlertDialog alertDialog = new AlertDialog.Builder(activity)
                 .setView(view)
                 .setNegativeButton(android.R.string.cancel, null)
-                .setPositiveButton(R.string.feedback_send, null)
+                .setPositiveButton(R.string.send, null)
                 .create();
         alertDialog.setOnShowListener(new DialogInterface.OnShowListener() {
 
@@ -147,7 +154,23 @@ public class FeedbackDialog extends DialogFragment implements Config.OnConfigCha
 
                     @Override
                     public void onClick(View view) {
-                        send();
+                        Context context = getActivity();
+                        CharSequence message = mEditText.getText();
+
+                        if (isMessageLongEnough(message)) {
+                            boolean attachLog = mAttachLogCheckBox.isChecked()
+                                    && mAttachLogCheckBox.getVisibility() == View.VISIBLE;
+
+                            int type = mSpinner.getSelectedItemPosition();
+                            CharSequence title = createTitle(context, type);
+                            CharSequence body = createBody(context, message);
+                            send(title, body, attachLog);
+                        } else {
+                            String toastText = getString(
+                                    R.string.feedback_error_msg_too_short,
+                                    getMinMessageLength());
+                            ToastUtils.showShort(context, toastText);
+                        }
                     }
                 });
             }
@@ -157,22 +180,6 @@ public class FeedbackDialog extends DialogFragment implements Config.OnConfigCha
         mSpinner.setOnItemSelectedListener(mListener);
         mEditText = (EditText) view.findViewById(R.id.message);
         mAttachLogCheckBox = (CheckBox) view.findViewById(R.id.checkbox);
-        mAttachLogCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {
-            @Override
-            public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
-                if (!isChecked) {
-                    return;
-                }
-
-                CharSequence messageText = getString(R.string.feedback_attach_log_description);
-                new DialogHelper.Builder(getActivity())
-                        .setMessage(messageText)
-                        .wrap()
-                        .setPositiveButton(android.R.string.ok, null)
-                        .create()
-                        .show();
-            }
-        });
 
         // Frequently asked questions panel
         Config.Triggers triggers = Config.getInstance().getTriggers();
@@ -185,12 +192,13 @@ public class FeedbackDialog extends DialogFragment implements Config.OnConfigCha
      * Initialize Frequently asked questions panel. This panel is here to reduce
      * the number of already answered questions.
      */
-    private void initFaqPanel(ViewGroup root) {
+    private void initFaqPanel(@NonNull ViewGroup root) {
         mFaqContainer = ((ViewStub) root.findViewById(R.id.faq)).inflate();
         mFaqContainer.findViewById(R.id.faq).setOnClickListener(new View.OnClickListener() {
             @Override
             public void onClick(View v) {
-                DialogHelper.showHelpDialog(getActivity());
+                ActionBarActivity activity = (ActionBarActivity) getActivity();
+                DialogHelper.showHelpDialog(activity);
             }
         });
     }
@@ -218,26 +226,16 @@ public class FeedbackDialog extends DialogFragment implements Config.OnConfigCha
         }
     }
 
-    private void send() {
+    private void send(@NonNull CharSequence title,
+                      @NonNull CharSequence body, boolean attachLog) {
         Activity context = getActivity();
-        CharSequence message = mEditText.getText();
-
-        // Check for message's length
-        int msgMinLength = getResources().getInteger(R.integer.config_feedback_minMessageLength);
-        if (message == null || (message.length() < msgMinLength && !Build.DEBUG)) {
-            String toastText = getString(R.string.feedback_error_msg_too_short, msgMinLength);
-            ToastUtils.showShort(context, toastText);
-            return;
-        }
-
-        CharSequence title = createTitleMessage(context, mSpinner.getSelectedItemPosition());
-        CharSequence body = createBodyMessage(context, message);
+        String[] recipients = {Build.SUPPORT_EMAIL};
         Intent intent = new Intent()
-                .putExtra(Intent.EXTRA_EMAIL, new String[]{Build.SUPPORT_EMAIL})
+                .putExtra(Intent.EXTRA_EMAIL, recipients)
                 .putExtra(Intent.EXTRA_SUBJECT, title)
                 .putExtra(Intent.EXTRA_TEXT, body);
 
-        if (mAttachLogCheckBox.getVisibility() == View.VISIBLE && mAttachLogCheckBox.isChecked()) {
+        if (attachLog) {
             attachLog(intent);
             intent.setAction(Intent.ACTION_SEND);
             intent.setType("message/rfc822");
@@ -250,81 +248,116 @@ public class FeedbackDialog extends DialogFragment implements Config.OnConfigCha
             startActivity(intent);
             dismiss();
         } else {
-            String toastText = getString(R.string.feedback_error_no_app);
-            ToastUtils.showLong(context, toastText);
+            ToastUtils.showLong(context, R.string.feedback_error_no_app);
         }
     }
 
-    private CharSequence createTitleMessage(Context context, int type) {
-        CharSequence osVersion = Device.hasKitKatApi() ? "KK" : Device.hasJellyBeanMR2Api() ? "JB" : "WTF";
-        CharSequence[] typeNames = new CharSequence[]{"bug", "suggestion", "other"};
-        return AboutDialog.getVersionName(context) + ": " + osVersion + ", " + typeNames[type];
+    /**
+     * Creates the title of the email.
+     *
+     * @param type one of the following types:
+     *             0 - issue
+     *             1 - suggestion
+     *             2 - other
+     * @return the title of the email.
+     */
+    @NonNull
+    private CharSequence createTitle(@NonNull Context context, int type) {
+        CharSequence osVersion = Device.API_VERSION_NAME_SHORT;
+        CharSequence[] types = new CharSequence[]{"issue", "suggestion", "other"};
+        return AboutDialog.getVersionName(context) + ": " + osVersion + ", " + types[type];
     }
 
-    private CharSequence createBodyMessage(Context context, CharSequence msg) {
-        PackageInfo pi;
-        try {
-            pi = context
-                    .getPackageManager()
-                    .getPackageInfo(PackageUtils.getName(context), 0);
-        } catch (PackageManager.NameNotFoundException e) {
-            Log.wtf(TAG, "Failed to find my own PackageInfo.");
-            return msg;
-        }
+    /**
+     * Creates the body of the email. It automatically adds some
+     * info about the device.
+     *
+     * @param msg the message that been typed by user.
+     * @return the body of the email
+     */
+    @NonNull
+    private CharSequence createBody(@NonNull Context context, @NonNull CharSequence msg) {
+        final String extra;
+
+        do {
+            PackageInfo pi;
+            try {
+                pi = context
+                        .getPackageManager()
+                        .getPackageInfo(PackageUtils.getName(context), 0);
+            } catch (PackageManager.NameNotFoundException e) {
+                extra = "There was an exception while getting my own package info.";
+                break;
+            }
+
+            JSONObject obj = new JSONObject();
+            try {
+                // App related stuff
+                obj.put("app_version_code", pi.versionCode);
+                obj.put("app_version_name", pi.versionName);
+                obj.put("app_timestamp", Build.TIME_STAMP);
+                obj.put("app_is_debug", DEBUG);
+
+                // Device related stuff
+                obj.put("language", Locale.getDefault().getLanguage());
+                obj.put("android_version_release", android.os.Build.VERSION.RELEASE);
+                obj.put("android_version_sdk_int", android.os.Build.VERSION.SDK_INT);
+                obj.put("android_build_display", android.os.Build.DISPLAY);
+                obj.put("android_build_brand", android.os.Build.BRAND);
+                obj.put("android_build_model", android.os.Build.MODEL);
+            } catch (JSONException ignored) {
+                extra = "There was an exception while building JSON.";
+                break;
+            }
 
-        return "" + msg +
-                '\n' +
-                '\n' +
-                "- - - - - - - - - - device details - - - - - - - - -" + '\n' +
-                "app_version:" + pi.versionName + '(' + pi.versionCode + ")\n" +
-                "android_version:" + android.os.Build.VERSION.RELEASE + '(' + android.os.Build.VERSION.SDK_INT + ")\n" +
-                "build_display:" + android.os.Build.DISPLAY + '\n' +
-                "build_brand:" + android.os.Build.BRAND + '\n' +
-                "build_model:" + android.os.Build.MODEL + '\n' +
-                "language:" + Locale.getDefault().getLanguage();
+            extra = obj.toString();
+        } while (false);
+
+        return msg + "\n\nExtras (added automatically & do not change):\n" + extra;
+    }
+
+    private boolean isMessageLongEnough(@Nullable CharSequence message) {
+        return message != null && message.length() >= getMinMessageLength();
+    }
+
+    private int getMinMessageLength() {
+        return getResources().getInteger(R.integer.config_feedback_minMessageLength);
     }
 
-    // TODO: If root is available, get normal (system events included) logcat.
-    private void attachLog(Intent intent) {
+    private void attachLog(@NonNull Intent intent) {
         Context context = getActivity();
-        StringBuilder log = new StringBuilder();
 
         try {
-            // Read logs from runtime
-            String[] logcatCmd = new String[]{"logcat", "-v", "threadtime", "-d"};
-            Process process = Runtime.getRuntime().exec(logcatCmd);
-            BufferedReader bufferedReader = new BufferedReader(
-                    new InputStreamReader(process.getInputStream()));
-            String line;
-            while ((line = bufferedReader.readLine()) != null) {
-                log.append(line);
-                log.append('\n');
-            }
+            String log = Logcat.capture();
+            if (log == null)
+                throw new Exception("Failed to capture the logcat.");
 
-            // Write everything to a file
+            // Prepare cache directory.
             File cacheDir = context.getCacheDir();
-            if (cacheDir == null) {
-                throw new IOException("Cache directory inaccessible");
-            }
-            File logsDir = new File(cacheDir, LogAttachmentProvider.DIRECTORY);
-            FileUtils.deleteRecursive(logsDir);
-            logsDir.mkdirs();
-
-            SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd_HHmm");
+            if (cacheDir == null)
+                throw new Exception("Cache directory is inaccessible");
+            File directory = new File(cacheDir, LogsProviderBase.DIRECTORY);
+            FileUtils.deleteRecursive(directory); // Clean-up cache folder
+            if (!directory.mkdirs())
+                throw new Exception("Failed to create cache directory.");
+
+            // Create log file.
+            SimpleDateFormat sdf = new SimpleDateFormat("yyyyMMdd_HHmmss");
             sdf.setTimeZone(TimeZone.getTimeZone("UTC"));
             String fileName = "AcDisplay_log_" + sdf.format(new Date()) + ".txt";
-            File logFile = new File(logsDir, fileName);
+            File file = new File(directory, fileName);
 
-            BufferedWriter writer = new BufferedWriter(new OutputStreamWriter(
-                    new FileOutputStream(logFile)));
-            writer.write(log.toString());
-            writer.close();
+            // Write to the file.
+            if (!FileUtils.writeToFile(file, log))
+                throw new Exception("Failed to write log to the file.");
 
-            // Put extra stream to intent
+            // Put extra stream to the intent.
             Uri uri = Uri.parse("content://" + LogAttachmentProvider.AUTHORITY + "/" + fileName);
             intent.putExtra(Intent.EXTRA_STREAM, uri);
-        } catch (IOException e) {
-            ToastUtils.showShort(context, getString(R.string.feedback_error_accessing_log));
+        } catch (Exception e) {
+            String message = getString(R.string.feedback_error_accessing_log, e.getMessage());
+            ToastUtils.showLong(context, message);
         }
     }
+
 }
diff --git a/project/app/src/main/java/com/achep/base/ui/fragments/dialogs/HelpDialog.java b/project/app/src/main/java/com/achep/base/ui/fragments/dialogs/HelpDialog.java
new file mode 100644
index 00000000..5a343c29
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/ui/fragments/dialogs/HelpDialog.java
@@ -0,0 +1,52 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.ui.fragments.dialogs;
+
+import android.app.Dialog;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.v4.app.DialogFragment;
+import android.text.Html;
+
+import com.achep.acdisplay.R;
+import com.achep.base.ui.DialogBuilder;
+import com.achep.base.utils.RawReader;
+
+/**
+ * Dialog fragment that shows FAQ.
+ *
+ * @author Artem Chepurnoy
+ */
+public class HelpDialog extends DialogFragment {
+
+    @NonNull
+    @Override
+    public Dialog onCreateDialog(Bundle savedInstanceState) {
+        String source = RawReader.readText(getActivity(), R.raw.faq);
+        CharSequence message = Html.fromHtml(source);
+        return new DialogBuilder(getActivity())
+                .setIcon(R.drawable.ic_action_help_white)
+                .setTitle(R.string.help_dialog_title)
+                .setMessage(message)
+                .createAlertDialogBuilder()
+                .setNegativeButton(R.string.close, null)
+                .create();
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/base/ui/preferences/Enabler.java b/project/app/src/main/java/com/achep/base/ui/preferences/Enabler.java
new file mode 100644
index 00000000..5fc74922
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/ui/preferences/Enabler.java
@@ -0,0 +1,114 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.ui.preferences;
+
+import android.content.Context;
+import android.support.annotation.NonNull;
+import android.widget.CompoundButton;
+
+import com.achep.base.content.ConfigBase;
+import com.achep.base.interfaces.ICheckable;
+
+/**
+ * @author Artem Chepurnoy
+ */
+public class Enabler {
+
+    private final String mKey;
+    private final Context mContext;
+    private final ConfigBase mConfig;
+    private final ConfigBase.Option mOption;
+    private final ConfigBase.OnConfigChangedListener mConfigListener =
+            new ConfigBase.OnConfigChangedListener() {
+
+                @Override
+                public void onConfigChanged(@NonNull ConfigBase config,
+                                            @NonNull String key,
+                                            @NonNull Object value) {
+                    if (mKey.equals(key)) updateCheckableState();
+                }
+            };
+
+    private final CompoundButton.OnCheckedChangeListener mCheckableListener
+            = new CompoundButton.OnCheckedChangeListener() {
+
+        @Override
+        public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+            if (mBroadcasting) {
+                return;
+            }
+
+            mOption.write(mConfig, mContext, isChecked, mConfigListener);
+        }
+    };
+
+    private ICheckable mCheckable;
+    private boolean mBroadcasting;
+
+    public Enabler(@NonNull Context context,
+                   @NonNull ConfigBase config,
+                   @NonNull String key,
+                   @NonNull ICheckable checkable) {
+        mKey = key;
+        mConfig = config;
+        mContext = context;
+        mCheckable = checkable;
+
+        mOption = mConfig.getHashMap().get(mKey);
+        if (mOption == null) throw new RuntimeException(
+                "You have forgotten to put #" + mKey + " to the hash map of config.");
+    }
+
+    /**
+     * Starts listening to the config's changes and updates corresponding
+     * {@link com.achep.base.interfaces.ICheckable compound button}.
+     * You must call {@link #stop() stop} method later!
+     */
+    public void start() {
+        mConfig.registerListener(mConfigListener);
+        mCheckable.setOnCheckedChangeListener(mCheckableListener);
+        updateCheckableState();
+    }
+
+    /**
+     * Stops listening to the config's changes.
+     */
+    public void stop() {
+        mConfig.unregisterListener(mConfigListener);
+        mCheckable.setOnCheckedChangeListener(null);
+    }
+
+    public void setCheckable(@NonNull ICheckable checkable) {
+        if (mCheckable == checkable) {
+            return;
+        }
+
+        mCheckable.setOnCheckedChangeListener(null);
+        mCheckable = checkable;
+        mCheckable.setOnCheckedChangeListener(mCheckableListener);
+        updateCheckableState();
+    }
+
+    private void updateCheckableState() {
+        mBroadcasting = true;
+        mCheckable.setChecked((boolean) mOption.read(mConfig));
+        mBroadcasting = false;
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/base/ui/widgets/DashboardLayout.java b/project/app/src/main/java/com/achep/base/ui/widgets/DashboardLayout.java
new file mode 100644
index 00000000..18a67561
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/ui/widgets/DashboardLayout.java
@@ -0,0 +1,158 @@
+/*
+ * Copyright (C) 2015 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.ui.widgets;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.res.Resources;
+import android.util.AttributeSet;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.achep.acdisplay.R;
+import com.achep.base.Device;
+
+public class DashboardLayout extends ViewGroup {
+
+    private final float mCellGapX;
+    private final float mCellGapY;
+
+    private int mNumRows;
+    private final int mNumColumns;
+
+    public DashboardLayout(Context context, AttributeSet attrs) {
+        super(context, attrs);
+
+        final Resources res = context.getResources();
+        mCellGapX = res.getDimension(R.dimen.dashboard_cell_gap_x);
+        mCellGapY = res.getDimension(R.dimen.dashboard_cell_gap_y);
+        mNumColumns = res.getInteger(R.integer.dashboard_num_columns);
+    }
+
+    @Override
+    protected void onMeasure(int widthMeasureSpec, int heightMeasureSpec) {
+        final int childCount = getChildCount();
+        final int width = MeasureSpec.getSize(widthMeasureSpec);
+        final int availableWidth = (int) (width - getPaddingLeft() - getPaddingRight() -
+                (mNumColumns - 1) * mCellGapX);
+        float cellWidth = (float) Math.ceil(((float) availableWidth) / mNumColumns);
+
+        int cellHeight = 0;
+        int cursor = 0;
+
+        for (int i = 0; i < childCount; i++) {
+            DashboardTileView v = (DashboardTileView) getChildAt(i);
+            if (v.getVisibility() == View.GONE) continue;
+
+            LayoutParams lp = v.getLayoutParams();
+            int colSpan = v.getColumnSpan();
+            lp.width = (int) ((colSpan * cellWidth) + (colSpan - 1) * mCellGapX);
+
+            // Measure the child
+            int newWidthSpec = getChildMeasureSpec(widthMeasureSpec, 0, lp.width);
+            int newHeightSpec = getChildMeasureSpec(heightMeasureSpec, 0, lp.height);
+            v.measure(newWidthSpec, newHeightSpec);
+
+            // Save the cell height
+            if (cellHeight <= 0) {
+                cellHeight = v.getMeasuredHeight();
+            }
+
+            lp.height = cellHeight;
+
+            cursor += colSpan;
+        }
+
+        mNumRows = (int) Math.ceil((float) cursor / mNumColumns);
+        final int newHeight = (int) ((mNumRows * cellHeight) + ((mNumRows - 1) * mCellGapY)) +
+                getPaddingTop() + getPaddingBottom();
+
+        setMeasuredDimension(width, newHeight);
+    }
+
+    @Override
+    protected void onLayout(boolean changed, int l, int t, int r, int b) {
+        final int childCount = getChildCount();
+        final boolean isLayoutRtl = isLayoutRtl();
+        final int width = getWidth();
+
+        int x = getPaddingStartLeft();
+        int y = getPaddingTop();
+        int cursor = 0;
+
+        for (int i = 0; i < childCount; i++) {
+            final DashboardTileView v = (DashboardTileView) getChildAt(i);
+            final LayoutParams lp = v.getLayoutParams();
+            if (v.getVisibility() == GONE) continue;
+
+            final int col = cursor % mNumColumns;
+            final int colSpan = v.getColumnSpan();
+
+            final int childWidth = lp.width;
+            final int childHeight = lp.height;
+
+            int row = cursor / mNumColumns;
+            v.setDividerVisibility(row != mNumRows - 1);
+
+            // Push the item to the next row if it can't fit on this one
+            if ((col + colSpan) > mNumColumns) {
+                x = getPaddingStartLeft();
+                y += childHeight + mCellGapY;
+                row++;
+            }
+
+            final int childLeft = (isLayoutRtl) ? width - x - childWidth : x;
+            final int childRight = childLeft + childWidth;
+
+            final int childTop = y;
+            final int childBottom = childTop + childHeight;
+
+            // Layout the container
+            v.layout(childLeft, childTop, childRight, childBottom);
+
+            // Offset the position by the cell gap or reset the position and cursor when we
+            // reach the end of the row
+            cursor += v.getColumnSpan();
+            if (cursor < (((row + 1) * mNumColumns))) {
+                x += childWidth + mCellGapX;
+            } else {
+                x = getPaddingStartLeft();
+                y += childHeight + mCellGapY;
+            }
+        }
+    }
+
+    /**
+     * @return {@code true} if this layout is Right-to-left, otherwise,
+     * or if this device's Android version doesn't support RTL, it
+     * returns {@code false}
+     */
+    @SuppressLint("NewApi")
+    private boolean isLayoutRtl() {
+        return Device.hasJellyBeanMR1Api() && getLayoutDirection() == LAYOUT_DIRECTION_RTL;
+    }
+
+    @SuppressLint("NewApi")
+    private int getPaddingStartLeft() {
+        return Device.hasJellyBeanMR1Api()
+                ? getPaddingStart()
+                : getPaddingLeft();
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/base/ui/widgets/DashboardTileView.java b/project/app/src/main/java/com/achep/base/ui/widgets/DashboardTileView.java
new file mode 100644
index 00000000..e00212bb
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/ui/widgets/DashboardTileView.java
@@ -0,0 +1,113 @@
+/*
+ * Copyright (C) 2015 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.ui.widgets;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.support.annotation.NonNull;
+import android.text.TextUtils;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+import android.widget.TextView;
+
+import com.achep.acdisplay.R;
+import com.achep.base.dashboard.DashboardTile;
+import com.achep.base.ui.activities.SettingsActivity;
+import com.achep.base.utils.RippleUtils;
+
+public class DashboardTileView extends LinearLayout implements View.OnClickListener {
+
+    private static final int DEFAULT_COL_SPAN = 1;
+
+    private ImageView mImageView;
+    private TextView mTitleTextView;
+    private TextView mStatusTextView;
+    private View mDivider;
+
+    private int mColSpan = DEFAULT_COL_SPAN;
+
+    private DashboardTile mTile;
+
+    public DashboardTileView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    @Override
+    protected void onFinishInflate() {
+        super.onFinishInflate();
+
+        mImageView = (ImageView) findViewById(R.id.icon);
+        mTitleTextView = (TextView) findViewById(R.id.title);
+        mStatusTextView = (TextView) findViewById(R.id.status);
+        mDivider = findViewById(R.id.tile_divider);
+
+        setOnClickListener(this);
+        setFocusable(true);
+
+        RippleUtils.makeFor(this, true);
+    }
+
+    public void setDashboardTile(@NonNull DashboardTile tile) {
+        mTile = tile;
+        Resources res = getResources();
+
+        if (tile.iconRes > 0) {
+            mImageView.setImageResource(tile.iconRes);
+        } else {
+            mImageView.setImageDrawable(null);
+            mImageView.setBackground(null);
+        }
+
+        mTitleTextView.setText(tile.getTitle(res));
+
+        CharSequence summary = tile.getSummary(res);
+        if (!TextUtils.isEmpty(summary)) {
+            mStatusTextView.setVisibility(View.VISIBLE);
+            mStatusTextView.setText(summary);
+        } else {
+            mStatusTextView.setVisibility(View.GONE);
+        }
+    }
+
+    public void setDividerVisibility(boolean visible) {
+        mDivider.setVisibility(visible ? View.VISIBLE : View.GONE);
+    }
+
+    void setColumnSpan(int span) {
+        mColSpan = span;
+    }
+
+    int getColumnSpan() {
+        return mColSpan;
+    }
+
+    @Override
+    public void onClick(View v) {
+        if (mTile.fragment != null) {
+            SettingsActivity.Utils.startWithFragment(getContext(),
+                    mTile.fragment, mTile.fragmentArguments, null, 0,
+                    mTile.titleRes, mTile.getTitle(getResources()));
+        } else if (mTile.intent != null) {
+            getContext().startActivity(mTile.intent);
+        }
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/base/ui/widgets/SwitchBar.java b/project/app/src/main/java/com/achep/base/ui/widgets/SwitchBar.java
new file mode 100644
index 00000000..f8187936
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/ui/widgets/SwitchBar.java
@@ -0,0 +1,162 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.ui.widgets;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.DrawableRes;
+import android.support.annotation.Nullable;
+import android.support.v7.widget.SwitchCompat;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.CompoundButton;
+import android.widget.ImageView;
+import android.widget.LinearLayout;
+
+import com.achep.acdisplay.R;
+import com.achep.base.interfaces.ICheckable;
+import com.achep.base.utils.RippleUtils;
+
+/**
+ * Material-designed switch bar.
+ *
+ * @author Artem Chepurnoy
+ */
+public class SwitchBar extends LinearLayout implements ICheckable {
+
+    private TextView mTextView;
+    private ImageView mIconView;
+    private SwitchCompat mSwitch;
+
+    private CompoundButton.OnCheckedChangeListener mPublicListener;
+    private final CompoundButton.OnCheckedChangeListener mListener =
+            new CompoundButton.OnCheckedChangeListener() {
+
+                @Override
+                public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
+                    mSwitch.post(new Runnable() {
+                        @Override
+                        public void run() {
+                            updateText(mSwitch.isChecked());
+                        }
+                    });
+
+                    if (mPublicListener != null) {
+                        mPublicListener.onCheckedChanged(buttonView, isChecked);
+                    }
+                }
+
+            };
+
+    private void updateText(boolean isChecked) {
+        mTextView.setText(isChecked
+                ? R.string.on
+                : R.string.off);
+    }
+
+    public SwitchBar(Context context) {
+        super(context);
+    }
+
+    public SwitchBar(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    public SwitchBar(Context context, AttributeSet attrs, int defStyleAttr) {
+        super(context, attrs, defStyleAttr);
+    }
+
+    @SuppressLint("WrongViewCast")
+    @Override
+    protected void onFinishInflate() {
+        super.onFinishInflate();
+        if (!isInEditMode()) {
+            RippleUtils.makeFor(this, false);
+        }
+
+        mTextView = (TextView) findViewById(R.id.title);
+        mIconView = (ImageView) findViewById(R.id.icon);
+        mSwitch = (SwitchCompat) findViewById(R.id.switch_);
+        mSwitch.setOnCheckedChangeListener(mListener);
+        updateText(mSwitch.isChecked());
+
+        // Toggle switch on click on the panel.
+        setOnClickListener(new OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                toggle();
+            }
+        });
+    }
+
+    @Override
+    protected void onAttachedToWindow() {
+        super.onAttachedToWindow();
+        /*
+        post(new Runnable() {
+            @Override
+            public void run() {
+                // TODO: Somehow update padding left to fit with the title of ActionBar.
+            }
+        });
+        */
+    }
+
+    public void setIconResource(@DrawableRes int resource) {
+        mIconView.setImageResource(resource);
+    }
+
+    public void setIconDrawable(@Nullable Drawable drawable) {
+        mIconView.setImageDrawable(drawable);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setOnCheckedChangeListener(CompoundButton.OnCheckedChangeListener listener) {
+        mPublicListener = listener;
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void setChecked(boolean checked) {
+        mSwitch.setChecked(checked);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public boolean isChecked() {
+        return mSwitch.isChecked();
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void toggle() {
+        mSwitch.toggle();
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/widgets/TextView.java b/project/app/src/main/java/com/achep/base/ui/widgets/TextView.java
similarity index 64%
rename from project/app/src/main/java/com/achep/acdisplay/widgets/TextView.java
rename to project/app/src/main/java/com/achep/base/ui/widgets/TextView.java
index e56174e5..5205ad73 100644
--- a/project/app/src/main/java/com/achep/acdisplay/widgets/TextView.java
+++ b/project/app/src/main/java/com/achep/base/ui/widgets/TextView.java
@@ -16,21 +16,25 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.widgets;
+package com.achep.base.ui.widgets;
 
 import android.content.Context;
 import android.content.res.TypedArray;
 import android.graphics.Typeface;
+import android.os.Build;
 import android.util.AttributeSet;
+import android.util.Log;
 
-import com.achep.acdisplay.Device;
 import com.achep.acdisplay.R;
+import com.achep.base.Device;
 
 /**
  * Created by Artem on 29.01.14.
  */
 public class TextView extends android.widget.TextView {
 
+    private static final String TAG = "TextView";
+
     public TextView(Context context) {
         this(context, null);
     }
@@ -44,15 +48,24 @@ public class TextView extends android.widget.TextView {
         if (isInEditMode()) return;
 
         TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.TextView);
-        String font = a.getString(R.styleable.TextView_font);
 
-        int sdk = a.getInt(R.styleable.TextView_font_sdk, 20);
+        String fontName = a.getString(R.styleable.TextView_font);
+        if (fontName != null) {
+            int maximumSdkVersion = a.getInt(
+                    R.styleable.TextView_font_beforeApi,
+                    Build.VERSION_CODES.LOLLIPOP);
 
-        if (!Device.hasTargetApi(sdk) && font != null) {
-            if (!font.contains(".")) font += ".ttf"; // Add default font's extension.
-            setTypeface(Typeface.createFromAsset(context.getAssets(), font));
+            if (!Device.hasTargetApi(maximumSdkVersion)) {
+                if (fontName.indexOf('.') != -1) fontName += ".ttf";
+                try {
+                    setTypeface(Typeface.createFromAsset(context.getAssets(), "fonts/" + fontName));
+                } catch (Exception ignored) {
+                    Log.w(TAG, "Failed to create the typeface!");
+                }
+            }
         }
-        
+
         a.recycle();
     }
+
 }
diff --git a/project/app/src/main/java/com/achep/base/utils/CoinUtils.java b/project/app/src/main/java/com/achep/base/utils/CoinUtils.java
new file mode 100644
index 00000000..0ffcf29e
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/utils/CoinUtils.java
@@ -0,0 +1,42 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.utils;
+
+import android.content.Intent;
+import android.net.Uri;
+
+import com.achep.base.interfaces.ICoin;
+
+/**
+ * Base class for simple virtual coins.
+ *
+ * @author Artem Chepurnoy
+ */
+public class CoinUtils {
+
+    public static Intent getPaymentIntent(ICoin coin) {
+        return getPaymentIntent(coin, coin.getPaymentAmount());
+    }
+
+    public static Intent getPaymentIntent(ICoin coin, double amount) {
+        Uri uri = coin.getPaymentUri(amount);
+        return IntentUtils.createViewIntent(uri);
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/utils/DateUtils.java b/project/app/src/main/java/com/achep/base/utils/DateUtils.java
similarity index 97%
rename from project/app/src/main/java/com/achep/acdisplay/utils/DateUtils.java
rename to project/app/src/main/java/com/achep/base/utils/DateUtils.java
index 50660b54..7c4a6103 100644
--- a/project/app/src/main/java/com/achep/acdisplay/utils/DateUtils.java
+++ b/project/app/src/main/java/com/achep/base/utils/DateUtils.java
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.utils;
+package com.achep.base.utils;
 
 import android.content.Context;
 import android.support.annotation.NonNull;
diff --git a/project/app/src/main/java/com/achep/acdisplay/utils/FileUtils.java b/project/app/src/main/java/com/achep/base/utils/FileUtils.java
similarity index 89%
rename from project/app/src/main/java/com/achep/acdisplay/utils/FileUtils.java
rename to project/app/src/main/java/com/achep/base/utils/FileUtils.java
index 9a9e6cd4..7e7775b1 100644
--- a/project/app/src/main/java/com/achep/acdisplay/utils/FileUtils.java
+++ b/project/app/src/main/java/com/achep/base/utils/FileUtils.java
@@ -16,14 +16,12 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.utils;
+package com.achep.base.utils;
 
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 import android.util.Log;
 
-import com.achep.acdisplay.Build;
-
 import java.io.BufferedReader;
 import java.io.File;
 import java.io.FileOutputStream;
@@ -31,8 +29,10 @@ import java.io.FileReader;
 import java.io.IOException;
 import java.io.OutputStreamWriter;
 
+import static com.achep.base.Build.DEBUG;
+
 /**
- * Helper class with utils related to file system and files.
+ * Utils related to file system, files and maybe reading buffers.
  *
  * @author Artem Chepurnoy
  */
@@ -40,6 +40,8 @@ public class FileUtils {
 
     private static final String TAG = "FileUtils";
 
+    private static final int FILE_DELETE_TRIES = 5;
+
     /**
      * Deletes all files from given directory recursively.
      *
@@ -54,14 +56,12 @@ public class FileUtils {
                     deleteRecursive(child);
                 }
             } else {
-                int i = 0;
-                for (; i < 5; i++) {
+                for (int i = 1; i <= FILE_DELETE_TRIES; i++) {
                     if (file.delete()) {
-                        i = 0;
-                        break;
+                        if (DEBUG) Log.d(TAG, "Removed file=" + file + " on " + i + " try.");
+                        return true;
                     }
                 }
-                return i == 0;
             }
         }
         return false;
@@ -101,7 +101,7 @@ public class FileUtils {
                 errorMessage += "[Failed to close the stream]";
             }
         }
-        if (Build.DEBUG) Log.e(TAG, errorMessage + " file=" + file);
+        if (DEBUG) Log.e(TAG, errorMessage + " file=" + file);
         return false;
     }
 
@@ -116,7 +116,7 @@ public class FileUtils {
             BufferedReader bufferedReader = new BufferedReader(new FileReader(file));
             return FileUtils.readTextFromBufferedReader(bufferedReader);
         } catch (IOException e) {
-            if (Build.DEBUG) Log.e(TAG, "Failed to read file=" + file);
+            if (DEBUG) Log.e(TAG, "Failed to read file=" + file);
             return null;
         }
     }
@@ -127,6 +127,7 @@ public class FileUtils {
      * @return text from given {@link BufferedReader}.
      * @throws IOException
      */
+    @NonNull
     public static String readTextFromBufferedReader(@NonNull BufferedReader bufferedReader) throws IOException {
 
         // Store all lines to string builder to
diff --git a/project/app/src/main/java/dreamers/graphics/FloatProperty.java b/project/app/src/main/java/com/achep/base/utils/FloatProperty.java
similarity index 54%
rename from project/app/src/main/java/dreamers/graphics/FloatProperty.java
rename to project/app/src/main/java/com/achep/base/utils/FloatProperty.java
index 0eb3bf99..4bb429d8 100644
--- a/project/app/src/main/java/dreamers/graphics/FloatProperty.java
+++ b/project/app/src/main/java/com/achep/base/utils/FloatProperty.java
@@ -1,4 +1,22 @@
-package dreamers.graphics;
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.utils;
 
 import android.util.Property;
 
@@ -10,8 +28,6 @@ import android.util.Property;
  * <code>Float</code> class.
  *
  * @param <T> The class on which the Property is declared.
- *
- * @hide
  */
 public abstract class FloatProperty<T> extends Property<T, Float> {
 
diff --git a/project/app/src/main/java/com/achep/acdisplay/utils/IntentUtils.java b/project/app/src/main/java/com/achep/base/utils/IntentUtils.java
similarity index 77%
rename from project/app/src/main/java/com/achep/acdisplay/utils/IntentUtils.java
rename to project/app/src/main/java/com/achep/base/utils/IntentUtils.java
index c86063ff..7068bd0b 100644
--- a/project/app/src/main/java/com/achep/acdisplay/utils/IntentUtils.java
+++ b/project/app/src/main/java/com/achep/base/utils/IntentUtils.java
@@ -16,21 +16,27 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.utils;
+package com.achep.base.utils;
 
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.PackageManager;
+import android.net.Uri;
 import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
 
 /**
  * Created by Artem on 16.03.14.
  */
 public class IntentUtils {
 
-    public static boolean hasActivityForThat(@NonNull Context context, Intent intent) {
+    public static boolean hasActivityForThat(@NonNull Context context, @Nullable Intent intent) {
         PackageManager pm = context.getPackageManager();
-        return pm != null && intent.resolveActivity(pm) != null;
+        return pm != null && intent != null && intent.resolveActivity(pm) != null;
+    }
+
+    public static Intent createViewIntent(@NonNull Uri uri) {
+        return new Intent(Intent.ACTION_VIEW, uri);
     }
 
 }
diff --git a/project/app/src/main/java/com/achep/base/utils/LogUtils.java b/project/app/src/main/java/com/achep/base/utils/LogUtils.java
new file mode 100644
index 00000000..8161763b
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/utils/LogUtils.java
@@ -0,0 +1,74 @@
+/*
+ * Copyright (C) 2015 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.utils;
+
+import android.text.TextUtils;
+import android.util.Log;
+
+/**
+ * Created by Artem Chepurnoy on 12.01.2015.
+ */
+public class LogUtils {
+
+    public static void v(String tag, String msg, int depth) {
+        Log.v(tag, getLocation(depth) + msg);
+    }
+
+    private static String getLocation(int depth) {
+        final String className = LogUtils.class.getName();
+        final StackTraceElement[] traces = Thread.currentThread().getStackTrace();
+        boolean found = false;
+
+        StringBuilder sb = new StringBuilder();
+        for (StackTraceElement trace : traces) {
+            try {
+                if (found) {
+                    if (trace.getClassName().startsWith(className)) continue;
+                    Class<?> clazz = Class.forName(trace.getClassName());
+                    sb.append("[");
+                    sb.append(getClassName(clazz));
+                    sb.append(":");
+                    sb.append(trace.getMethodName());
+                    sb.append(":");
+                    sb.append(trace.getLineNumber());
+                    sb.append("]");
+                    if (--depth == 0) break;
+                } else if (trace.getClassName().startsWith(className)) {
+                    found = true;
+                }
+            } catch (ClassNotFoundException ignored) {
+            }
+        }
+
+        return sb.toString() + ": ";
+    }
+
+    private static String getClassName(Class<?> clazz) {
+        if (clazz != null) {
+            if (!TextUtils.isEmpty(clazz.getSimpleName())) {
+                return clazz.getSimpleName();
+            }
+
+            return getClassName(clazz.getEnclosingClass());
+        }
+
+        return "";
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/utils/MathUtils.java b/project/app/src/main/java/com/achep/base/utils/MathUtils.java
similarity index 84%
rename from project/app/src/main/java/com/achep/acdisplay/utils/MathUtils.java
rename to project/app/src/main/java/com/achep/base/utils/MathUtils.java
index c07c30f4..9d92dff3 100644
--- a/project/app/src/main/java/com/achep/acdisplay/utils/MathUtils.java
+++ b/project/app/src/main/java/com/achep/base/utils/MathUtils.java
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.utils;
+package com.achep.base.utils;
 
 /**
  * Created by Artem on 03.01.14.
@@ -27,15 +27,8 @@ public class MathUtils {
         return a < min ? min : a > max ? max : a;
     }
 
-    public static int charge(float a) {
-        return a >= 0 ? 1 : -1;
-    }
-
     public static int bool(boolean a) {
         return a ? 1 : 0;
     }
 
-    public static int div(int a, int b) {
-        return (a - a % b) / b;
-    }
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/utils/NetworkUtils.java b/project/app/src/main/java/com/achep/base/utils/NetworkUtils.java
similarity index 71%
rename from project/app/src/main/java/com/achep/acdisplay/utils/NetworkUtils.java
rename to project/app/src/main/java/com/achep/base/utils/NetworkUtils.java
index fd0727ad..56b19342 100644
--- a/project/app/src/main/java/com/achep/acdisplay/utils/NetworkUtils.java
+++ b/project/app/src/main/java/com/achep/base/utils/NetworkUtils.java
@@ -16,25 +16,30 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.utils;
+package com.achep.base.utils;
 
 import android.content.Context;
 import android.net.ConnectivityManager;
 import android.support.annotation.NonNull;
 
 /**
- * Helper class with utils related to internet and networking.
+ * Utils related to the Internet and networking.
  *
  * @author Artem Chepurnoy
  */
 public class NetworkUtils {
 
     /**
-     * @return {@code true} if device is connected to internet, {@code false} otherwise.
+     * @return {@code true} if device is connected to the Internet, {@code false} otherwise.
      */
     public static boolean isOnline(@NonNull Context context) {
-        ConnectivityManager cm = (ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE);
+        return isOnline((ConnectivityManager) context.getSystemService(Context.CONNECTIVITY_SERVICE));
+    }
+
+    /**
+     * @return {@code true} if device is connected to the Internet, {@code false} otherwise.
+     */
+    public static boolean isOnline(@NonNull ConnectivityManager cm) {
         return cm.getActiveNetworkInfo() != null && cm.getActiveNetworkInfo().isConnectedOrConnecting();
     }
 
diff --git a/project/app/src/main/java/com/achep/base/utils/NullUtils.java b/project/app/src/main/java/com/achep/base/utils/NullUtils.java
new file mode 100644
index 00000000..e8b798a2
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/utils/NullUtils.java
@@ -0,0 +1,45 @@
+/*
+ * Copyright (C) 2015 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.utils;
+
+import android.support.annotation.NonNull;
+
+/**
+ * Created by Artem Chepurnoy on 10.01.2015.
+ */
+public class NullUtils {
+
+    /**
+     * @return first non-null {@link CharSequence} from the attrs.
+     */
+    public static CharSequence whileNotNull(@NonNull CharSequence... objects) {
+        return (CharSequence) whileNotNull((Object[]) objects);
+    }
+
+    /**
+     * @return first non-null {@link java.lang.Object object} from the attrs.
+     */
+    public static Object whileNotNull(@NonNull Object... objects) {
+        for (Object object : objects)
+            if (object != null)
+                return object;
+        return null;
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/Operator.java b/project/app/src/main/java/com/achep/base/utils/Operator.java
similarity index 97%
rename from project/app/src/main/java/com/achep/acdisplay/Operator.java
rename to project/app/src/main/java/com/achep/base/utils/Operator.java
index 6a46ca15..835369ad 100644
--- a/project/app/src/main/java/com/achep/acdisplay/Operator.java
+++ b/project/app/src/main/java/com/achep/base/utils/Operator.java
@@ -16,7 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay;
+package com.achep.base.utils;
 
 /**
  * Additional functions which I'd like to see as
diff --git a/project/app/src/main/java/com/achep/acdisplay/utils/PackageUtils.java b/project/app/src/main/java/com/achep/base/utils/PackageUtils.java
similarity index 96%
rename from project/app/src/main/java/com/achep/acdisplay/utils/PackageUtils.java
rename to project/app/src/main/java/com/achep/base/utils/PackageUtils.java
index 56c247ab..d27090e0 100644
--- a/project/app/src/main/java/com/achep/acdisplay/utils/PackageUtils.java
+++ b/project/app/src/main/java/com/achep/base/utils/PackageUtils.java
@@ -16,8 +16,7 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.utils;
+package com.achep.base.utils;
 
 import android.content.Context;
 import android.support.annotation.NonNull;
diff --git a/project/app/src/main/java/com/achep/base/utils/PreferenceManagerUtils.java b/project/app/src/main/java/com/achep/base/utils/PreferenceManagerUtils.java
new file mode 100644
index 00000000..3e71dea6
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/utils/PreferenceManagerUtils.java
@@ -0,0 +1,245 @@
+/*
+ * Copyright (C) 2010 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.achep.base.utils;
+
+import android.app.Activity;
+import android.content.Context;
+import android.content.Intent;
+import android.preference.Preference;
+import android.preference.PreferenceManager;
+import android.preference.PreferenceScreen;
+import android.support.annotation.NonNull;
+
+import com.achep.base.ui.fragments.PreferenceFragmentBase;
+
+import java.lang.reflect.Constructor;
+import java.lang.reflect.Field;
+import java.lang.reflect.InvocationHandler;
+import java.lang.reflect.Method;
+import java.lang.reflect.Proxy;
+
+/**
+ * Created by Artem Chepurnoy on 05.01.2015.
+ */
+public final class PreferenceManagerUtils {
+
+    /**
+     * Interface definition for a callback to be invoked when a
+     * {@link android.preference.Preference} in the hierarchy rooted at this {@link android.preference.PreferenceScreen} is
+     * clicked.
+     */
+    public interface OnPreferenceTreeClickListener {
+
+        /**
+         * Called when a preference in the tree rooted at this
+         * {@link android.preference.PreferenceScreen} has been clicked.
+         *
+         * @param preferenceScreen The {@link android.preference.PreferenceScreen} that the
+         *                         preference is located in.
+         * @param preference       The preference that was clicked.
+         * @return Whether the click was handled.
+         */
+        boolean onPreferenceTreeClick(PreferenceScreen preferenceScreen, Preference preference);
+
+    }
+
+    @NonNull
+    public static PreferenceManager newInstance(@NonNull Activity activity, int firstRequestCode) {
+        try {
+            Constructor<PreferenceManager> c = PreferenceManager.class
+                    .getDeclaredConstructor(Activity.class, int.class);
+            c.setAccessible(true);
+            return c.newInstance(activity, firstRequestCode);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Sets the owning preference fragment
+     */
+    public static void setFragment(@NonNull PreferenceManager manager,
+                                   PreferenceFragmentBase fragment) {
+        // stub
+    }
+
+    /**
+     * Sets the callback to be invoked when a {@link android.preference.Preference} in the
+     * hierarchy rooted at this {@link android.preference.PreferenceManager} is clicked.
+     *
+     * @param listener The callback to be invoked.
+     */
+    public static void setOnPreferenceTreeClickListener(@NonNull PreferenceManager manager,
+                                                        final PreferenceManagerUtils.OnPreferenceTreeClickListener listener) {
+        try {
+            Field onPreferenceTreeClickListener = PreferenceManager.class
+                    .getDeclaredField("mOnPreferenceTreeClickListener");
+            onPreferenceTreeClickListener.setAccessible(true);
+            if (listener != null) {
+                Object proxy = Proxy.newProxyInstance(
+                        onPreferenceTreeClickListener.getType().getClassLoader(),
+                        new Class[]{onPreferenceTreeClickListener.getType()},
+                        new InvocationHandler() {
+                            public Object invoke(Object proxy, Method method, Object[] args) {
+                                if (method.getName().equals("onPreferenceTreeClick")) {
+                                    PreferenceScreen ps = (PreferenceScreen) args[0];
+                                    Preference p = (Preference) args[1];
+                                    return listener.onPreferenceTreeClick(ps, p);
+                                } else {
+                                    return null;
+                                }
+                            }
+                        });
+                onPreferenceTreeClickListener.set(manager, proxy);
+            } else {
+                onPreferenceTreeClickListener.set(manager, null);
+            }
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Inflates a preference hierarchy from the preference hierarchies of
+     * {@link android.app.Activity Activities} that match the given {@link android.content.Intent}. An
+     * {@link android.app.Activity} defines its preference hierarchy with meta-data using
+     * the {@link android.preference.PreferenceManager#METADATA_KEY_PREFERENCES} key.
+     * <p/>
+     * If a preference hierarchy is given, the new preference hierarchies will
+     * be merged in.
+     *
+     * @param queryIntent     The intent to match activities.
+     * @param rootPreferences Optional existing hierarchy to merge the new
+     *                        hierarchies into.
+     * @return The root hierarchy (if one was not provided, the new hierarchy's
+     * root).
+     */
+    public static PreferenceScreen inflateFromIntent(@NonNull PreferenceManager manager,
+                                                     Intent queryIntent,
+                                                     PreferenceScreen rootPreferences) {
+        try {
+            Method m = PreferenceManager.class.getDeclaredMethod("inflateFromIntent",
+                    Intent.class,
+                    PreferenceScreen.class);
+            m.setAccessible(true);
+            return (PreferenceScreen) m.invoke(manager, queryIntent, rootPreferences);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Inflates a preference hierarchy from XML. If a preference hierarchy is
+     * given, the new preference hierarchies will be merged in.
+     *
+     * @param context         The context of the resource.
+     * @param resId           The resource ID of the XML to inflate.
+     * @param rootPreferences Optional existing hierarchy to merge the new
+     *                        hierarchies into.
+     * @return The root hierarchy (if one was not provided, the new hierarchy's
+     * root).
+     */
+    public static PreferenceScreen inflateFromResource(@NonNull PreferenceManager manager,
+                                                       Context context, int resId,
+                                                       PreferenceScreen rootPreferences) {
+        try {
+            Method m = PreferenceManager.class.getDeclaredMethod("inflateFromResource",
+                    Context.class, int.class, PreferenceScreen.class);
+            m.setAccessible(true);
+            return (PreferenceScreen) m.invoke(manager, context, resId, rootPreferences);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Returns the root of the preference hierarchy managed by this class.
+     *
+     * @return The {@link android.preference.PreferenceScreen} object that is at the root of the hierarchy.
+     */
+    public static PreferenceScreen getPreferenceScreen(@NonNull PreferenceManager manager) {
+        try {
+            Method m = PreferenceManager.class.getDeclaredMethod("getPreferenceScreen");
+            m.setAccessible(true);
+            return (PreferenceScreen) m.invoke(manager);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Called by the {@link android.preference.PreferenceManager} to dispatch a subactivity result.
+     */
+    public static void dispatchActivityResult(@NonNull PreferenceManager manager,
+                                              int requestCode, int resultCode,
+                                              Intent data) {
+        try {
+            Method m = PreferenceManager.class.getDeclaredMethod("dispatchActivityResult",
+                    int.class, int.class, Intent.class);
+            m.setAccessible(true);
+            m.invoke(manager, requestCode, resultCode, data);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Called by the {@link android.preference.PreferenceManager} to dispatch the activity stop
+     * event.
+     */
+    public static void dispatchActivityStop(@NonNull PreferenceManager manager) {
+        try {
+            Method m = PreferenceManager.class.getDeclaredMethod("dispatchActivityStop");
+            m.setAccessible(true);
+            m.invoke(manager);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Called by the {@link android.preference.PreferenceManager} to dispatch the activity destroy
+     * event.
+     */
+    public static void dispatchActivityDestroy(@NonNull PreferenceManager manager) {
+        try {
+            Method m = PreferenceManager.class.getDeclaredMethod("dispatchActivityDestroy");
+            m.setAccessible(true);
+            m.invoke(manager);
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+    /**
+     * Sets the root of the preference hierarchy.
+     *
+     * @param preferenceScreen The root {@link android.preference.PreferenceScreen} of the preference hierarchy.
+     * @return Whether the {@link android.preference.PreferenceScreen} given is different than the previous.
+     */
+    public static boolean setPreferences(@NonNull PreferenceManager manager,
+                                         PreferenceScreen preferenceScreen) {
+        try {
+            Method m = PreferenceManager.class
+                    .getDeclaredMethod("setPreferences", PreferenceScreen.class);
+            m.setAccessible(true);
+            return ((Boolean) m.invoke(manager, preferenceScreen));
+        } catch (Exception e) {
+            throw new RuntimeException(e);
+        }
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/utils/RawReader.java b/project/app/src/main/java/com/achep/base/utils/RawReader.java
similarity index 75%
rename from project/app/src/main/java/com/achep/acdisplay/utils/RawReader.java
rename to project/app/src/main/java/com/achep/base/utils/RawReader.java
index d42059eb..65124089 100644
--- a/project/app/src/main/java/com/achep/acdisplay/utils/RawReader.java
+++ b/project/app/src/main/java/com/achep/base/utils/RawReader.java
@@ -16,12 +16,12 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-
-package com.achep.acdisplay.utils;
+package com.achep.base.utils;
 
 import android.content.Context;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.support.annotation.RawRes;
 import android.util.Log;
 
 import java.io.BufferedReader;
@@ -36,16 +36,25 @@ public final class RawReader {
 
     private static final String TAG = "RawReader";
 
+    /**
+     * Reads text from raw resource.
+     *
+     * @param resource id of raw file to read, or {@code 0}.
+     * @return text from raw resource, or {@code null}
+     * if reading has failed or resource is {@code 0}.
+     */
     @Nullable
-    public static String readTextFileFromRawResource(@NonNull Context context, int rawRes) {
-        final InputStream inputStream = context.getResources().openRawResource(rawRes);
+    public static String readText(@NonNull Context context, @RawRes int resource) {
+        if (resource == 0) return null;
+
+        final InputStream inputStream = context.getResources().openRawResource(resource);
         final InputStreamReader inputStreamReader = new InputStreamReader(inputStream);
         final BufferedReader bufferedReader = new BufferedReader(inputStreamReader);
 
         try {
             return FileUtils.readTextFromBufferedReader(bufferedReader);
         } catch (IOException e) {
-            Log.e(TAG, "Failed to read raw resource: " + rawRes);
+            Log.e(TAG, "Failed to read raw resource: " + resource);
             return null;
         }
     }
diff --git a/project/app/src/main/java/com/achep/base/utils/RippleUtils.java b/project/app/src/main/java/com/achep/base/utils/RippleUtils.java
new file mode 100644
index 00000000..7cadd9d2
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/utils/RippleUtils.java
@@ -0,0 +1,77 @@
+/*
+ * Copyright (C) 2015 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.utils;
+
+import android.content.Context;
+import android.content.res.ColorStateList;
+import android.support.annotation.NonNull;
+import android.view.View;
+
+import com.achep.acdisplay.R;
+import com.achep.base.Device;
+import com.achep.base.ui.activities.ActivityBase;
+
+import dreamers.graphics.RippleDrawable;
+
+/**
+ * Created by Artem Chepurnoy on 04.01.2015.
+ */
+public class RippleUtils {
+
+    /**
+     * @return {@code false} if the ripple has been set, {@code true} otherwise
+     */
+    public static boolean makeFor(@NonNull View view, boolean parentIsScrollContainer) {
+        return makeFor(parentIsScrollContainer, true, view);
+    }
+
+    /**
+     * @return {@code false} if the ripple has been set, {@code true} otherwise
+     */
+    public static boolean makeFor(boolean parentIsScrollContainer,
+                                  boolean darkTheme, @NonNull View... views) {
+        ColorStateList csl = views[0].getResources().getColorStateList(
+                darkTheme ? R.color.ripple_dark : R.color.ripple_light);
+        return makeFor(csl, parentIsScrollContainer, views);
+    }
+
+    public static boolean makeFor(@NonNull ColorStateList csl,
+                                  boolean parentIsScrollContainer,
+                                  @NonNull View... views) {
+        if (!Device.hasLollipopApi()) {
+            // Do not create ripple effect if in power save mode, because
+            // this will drain more energy.
+            Context context = views[0].getContext();
+            if (context instanceof ActivityBase) {
+                ActivityBase activityBase = (ActivityBase) context;
+                if (activityBase.isPowerSaveMode()) {
+                    return true;
+                }
+            }
+
+            for (View view : views) {
+                view.setBackground(null);
+                RippleDrawable.makeFor(view, csl, parentIsScrollContainer);
+            }
+            return false;
+        }
+        return true;
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/utils/ToastUtils.java b/project/app/src/main/java/com/achep/base/utils/ToastUtils.java
similarity index 70%
rename from project/app/src/main/java/com/achep/acdisplay/utils/ToastUtils.java
rename to project/app/src/main/java/com/achep/base/utils/ToastUtils.java
index aec693d5..d2061a85 100644
--- a/project/app/src/main/java/com/achep/acdisplay/utils/ToastUtils.java
+++ b/project/app/src/main/java/com/achep/base/utils/ToastUtils.java
@@ -16,14 +16,15 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.utils;
+package com.achep.base.utils;
 
 import android.content.Context;
 import android.support.annotation.NonNull;
+import android.support.annotation.StringRes;
 import android.widget.Toast;
 
 /**
- * Helper class with utils related to toasts (no bacon.)
+ * Helper class with utils related to toasts (without the bacon.)
  *
  * @author Artem Chepurnoy
  */
@@ -41,7 +42,7 @@ public class ToastUtils {
     }
 
     @NonNull
-    public static Toast showShort(@NonNull Context context, int stringRes) {
+    public static Toast showShort(@NonNull Context context, @StringRes int stringRes) {
         return showShort(context, context.getString(stringRes));
     }
 
@@ -57,7 +58,7 @@ public class ToastUtils {
     }
 
     @NonNull
-    public static Toast showLong(@NonNull Context context, int stringRes) {
+    public static Toast showLong(@NonNull Context context, @StringRes int stringRes) {
         return showLong(context, context.getString(stringRes));
     }
 
@@ -68,4 +69,28 @@ public class ToastUtils {
         return toast;
     }
 
+    /**
+     * A class for showing a sequence of toasts.
+     *
+     * @author Artem Chepurnoy
+     */
+    public static class SingleToast {
+
+        private final Context mContext;
+        private Toast mToast;
+
+        public SingleToast(@NonNull Context context) {
+            mContext = context;
+        }
+
+        public void show(CharSequence text, int duration) {
+            if (mToast != null) {
+                mToast.cancel();
+            }
+
+            mToast = ToastUtils.show(mContext, text, duration);
+        }
+
+    }
+
 }
diff --git a/project/app/src/main/java/com/achep/acdisplay/utils/ViewUtils.java b/project/app/src/main/java/com/achep/base/utils/ViewUtils.java
similarity index 81%
rename from project/app/src/main/java/com/achep/acdisplay/utils/ViewUtils.java
rename to project/app/src/main/java/com/achep/base/utils/ViewUtils.java
index 41c4757f..71de4fa4 100644
--- a/project/app/src/main/java/com/achep/acdisplay/utils/ViewUtils.java
+++ b/project/app/src/main/java/com/achep/base/utils/ViewUtils.java
@@ -16,11 +16,12 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.utils;
+package com.achep.base.utils;
 
 import android.graphics.Matrix;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
+import android.text.TextUtils;
 import android.util.Log;
 import android.view.MotionEvent;
 import android.view.View;
@@ -28,7 +29,7 @@ import android.view.ViewGroup;
 import android.view.ViewParent;
 import android.widget.TextView;
 
-import com.achep.acdisplay.Device;
+import com.achep.base.Device;
 
 import java.lang.reflect.Field;
 import java.lang.reflect.InvocationTargetException;
@@ -43,8 +44,8 @@ public class ViewUtils {
 
     @NonNull
     private static final MotionEventHandler MOTION_EVENT_HANDLER = Device.hasKitKatApi()
-                    ? new MotionEventHandlerReflection()
-                    : new MotionEventHandlerCompat();
+            ? new MotionEventHandlerReflective()
+            : new MotionEventHandlerReflectiveCompat();
 
     public static boolean isTouchPointInView(@NonNull View view, float x, float y) {
         final int[] coordinates = new int[3];
@@ -55,39 +56,13 @@ public class ViewUtils {
                 y >= top && y <= top + view.getHeight();
     }
 
-    public static int getLeft(@NonNull View view) {
-        final int[] coordinates = new int[3];
-        view.getLocationInWindow(coordinates);
-        return coordinates[0];
-    }
-
-    public static int getTop(@NonNull View view) {
-        final int[] coordinates = new int[3];
-        view.getLocationInWindow(coordinates);
-        return coordinates[1];
+    public static void setSize(@NonNull View view, int size) {
+        ViewGroup.LayoutParams lp = view.getLayoutParams();
+        lp.height = size;
+        lp.width = size;
+        view.requestLayout();
     }
 
-    public static int getBottom(@NonNull View view) {
-        return getTop(view) + view.getHeight();
-    }
-
-    public static int indexOf(@NonNull ViewGroup container, @NonNull View view) {
-        int length = container.getChildCount();
-        for (int i = 0; i < length; i++) {
-            View child = container.getChildAt(i);
-            assert child != null;
-
-            if (child.equals(view)) {
-                return i;
-            }
-        }
-        return -1;
-    }
-
-    // //////////////////////////////////////////
-    // //////////// -- VISIBILITY -- ////////////
-    // //////////////////////////////////////////
-
     public static void setVisible(@NonNull View view, boolean visible) {
         setVisible(view, visible, View.GONE);
     }
@@ -102,15 +77,14 @@ public class ViewUtils {
     }
 
     public static void safelySetText(@NonNull TextView textView, @Nullable CharSequence text) {
-        final boolean visible = text != null;
+        final boolean visible = !TextUtils.isEmpty(text);
         if (visible) textView.setText(text);
         ViewUtils.setVisible(textView, visible);
     }
 
-    // //////////////////////////////////////////
-    // /////////// -- TOUCH EVENTS -- ///////////
-    // //////////////////////////////////////////
-
+    /**
+     * @return {@code true} if the point is in view ± slop, {@code false} otherwise
+     */
     public static boolean pointInView(@NonNull View view, float localX, float localY, float slop) {
         return localX >= view.getLeft() - slop
                 && localX < view.getRight() + slop
@@ -123,7 +97,7 @@ public class ViewUtils {
      * coordinates.
      *
      * @param ev the view-local motion event
-     * @return false if the transformation could not be applied
+     * @return {@code false} if the transformation could not be applied
      */
     public static boolean toGlobalMotionEvent(@NonNull View view, @NonNull MotionEvent ev) {
         return MOTION_EVENT_HANDLER.toGlobalMotionEvent(view, ev);
@@ -134,7 +108,7 @@ public class ViewUtils {
      * coordinates.
      *
      * @param ev the on-screen motion event
-     * @return false if the transformation could not be applied
+     * @return {@code false} if the transformation could not be applied
      */
     public static boolean toLocalMotionEvent(@NonNull View view, @NonNull MotionEvent ev) {
         return MOTION_EVENT_HANDLER.toLocalMotionEvent(view, ev);
@@ -147,7 +121,7 @@ public class ViewUtils {
          * coordinates.
          *
          * @param ev the view-local motion event
-         * @return false if the transformation could not be applied
+         * @return {@code false} if the transformation could not be applied
          */
         abstract boolean toGlobalMotionEvent(@NonNull View view, @NonNull MotionEvent ev);
 
@@ -156,13 +130,15 @@ public class ViewUtils {
          * coordinates.
          *
          * @param ev the on-screen motion event
-         * @return false if the transformation could not be applied
+         * @return {@code false} if the transformation could not be applied
          */
         abstract boolean toLocalMotionEvent(@NonNull View view, @NonNull MotionEvent ev);
 
     }
 
-    private static final class MotionEventHandlerReflection extends MotionEventHandler {
+    //-- NATIVE MOTION EVENT HANDLER ------------------------------------------
+
+    private static final class MotionEventHandlerReflective extends MotionEventHandler {
 
         @Override
         boolean toGlobalMotionEvent(@NonNull View view, @NonNull MotionEvent ev) {
@@ -183,15 +159,21 @@ public class ViewUtils {
                     | IllegalAccessException
                     | NoSuchMethodException
                     | NoClassDefFoundError e) {
-                Log.wtf(TAG, "Failed to access motion event transforming!!!");
-                e.printStackTrace();
+                Log.wtf(TAG, "Failed to access #" + methodName + "!");
+
             }
             return false;
         }
 
     }
 
-    private static final class MotionEventHandlerCompat extends MotionEventHandler {
+    //-- COMPATIBILITY MOTION EVENT HANDLER -----------------------------------
+
+    /*
+     * This class uses half native View methods and half ported from
+     * newer versions.
+     */
+    private static final class MotionEventHandlerReflectiveCompat extends MotionEventHandler {
 
         @Override
         boolean toGlobalMotionEvent(@NonNull View view, @NonNull MotionEvent ev) {
@@ -264,7 +246,8 @@ public class ViewUtils {
                 final View vp = (View) parent;
                 transformMotionEventToLocal(vp, ev);
                 ev.offsetLocation(vp.getScrollX(), vp.getScrollY());
-            } // TODO: Use reflections to access ViewRootImpl
+            }
+            // TODO: Use reflections to access ViewRootImpl
             // else if (parent instanceof ViewRootImpl) {
             //    final ViewRootImpl vr = (ViewRootImpl) parent;
             //    ev.offsetLocation(0, vr.mCurScrollY);
@@ -296,7 +279,8 @@ public class ViewUtils {
                 final View vp = (View) parent;
                 ev.offsetLocation(-vp.getScrollX(), -vp.getScrollY());
                 transformMotionEventToGlobal(vp, ev);
-            } // TODO: Use reflections to access ViewRootImpl
+            }
+            // TODO: Use reflections to access ViewRootImpl
             // else if (parent instanceof ViewRootImpl) {
             //    final ViewRootImpl vr = (ViewRootImpl) parent;
             //    ev.offsetLocation(0, -vr.mCurScrollY);
diff --git a/project/app/src/main/java/com/achep/base/utils/logcat/Logcat.java b/project/app/src/main/java/com/achep/base/utils/logcat/Logcat.java
new file mode 100644
index 00000000..16009d67
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/utils/logcat/Logcat.java
@@ -0,0 +1,50 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.utils.logcat;
+
+import android.support.annotation.Nullable;
+
+import com.achep.base.utils.FileUtils;
+
+import java.io.BufferedReader;
+import java.io.IOException;
+import java.io.InputStreamReader;
+
+/**
+ * Created by Artem Chepurnoy on 09.12.2014.
+ */
+// TODO: Pull the code of capturing the logcat from the CatLog app.
+// Link: https://github.com/nolanlawson/Catlog
+public class Logcat {
+
+    @Nullable
+    public static String capture() {
+        try {
+            String[] command = new String[]{"logcat", "-v", "threadtime", "-d"};
+            Process process = Runtime.getRuntime().exec(command);
+            return FileUtils.readTextFromBufferedReader(
+                    new BufferedReader(
+                            new InputStreamReader(
+                                    process.getInputStream())));
+        } catch (IOException e) {
+            return null;
+        }
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/base/utils/power/PowerSaveDetector.java b/project/app/src/main/java/com/achep/base/utils/power/PowerSaveDetector.java
new file mode 100644
index 00000000..3f699fce
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/utils/power/PowerSaveDetector.java
@@ -0,0 +1,120 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.base.utils.power;
+
+import android.annotation.TargetApi;
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+import android.content.IntentFilter;
+import android.os.Build;
+import android.os.PowerManager;
+import android.support.annotation.NonNull;
+
+import com.achep.base.Device;
+
+/**
+ * Created by Artem Chepurnoy on 22.11.2014.
+ */
+public abstract class PowerSaveDetector {
+
+    public static PowerSaveDetector newInstance(@NonNull Context context) {
+        return Device.hasLollipopApi()
+                ? new PowerSaveLollipop(context)
+                : new PowerSaveCompat(context);
+    }
+
+    protected final Context mContext;
+    protected boolean mPowerSaveMode;
+
+    private PowerSaveDetector(@NonNull Context context) {
+        mContext = context;
+    }
+
+    public abstract void start();
+
+    public abstract void stop();
+
+    /**
+     * Returns {@code true} if the device is currently in power save mode.
+     * When in this mode, applications should reduce their functionality
+     * in order to conserve battery as much as possible.
+     *
+     * @return {@code true} if the device is currently in power save mode, {@code false} otherwise.
+     */
+    public boolean isPowerSaveMode() {
+        return mPowerSaveMode;
+    }
+
+    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
+    private static class PowerSaveLollipop extends PowerSaveDetector {
+
+        private final PowerManager mPowerManager;
+        private final BroadcastReceiver mReceiver =
+                new BroadcastReceiver() {
+                    @Override
+                    public void onReceive(Context context, Intent intent) {
+                        switch (intent.getAction()) {
+                            case PowerManager.ACTION_POWER_SAVE_MODE_CHANGED:
+                                mPowerSaveMode = mPowerManager.isPowerSaveMode();
+                                break;
+                        }
+                    }
+                };
+
+        public PowerSaveLollipop(@NonNull Context context) {
+            super(context);
+            mPowerManager = (PowerManager) context.getSystemService(Context.POWER_SERVICE);
+        }
+
+        @Override
+        public void start() {
+            IntentFilter intentFilter = new IntentFilter();
+            intentFilter.addAction(PowerManager.ACTION_POWER_SAVE_MODE_CHANGED);
+            mContext.registerReceiver(mReceiver, intentFilter);
+            mPowerSaveMode = mPowerManager.isPowerSaveMode();
+        }
+
+        @Override
+        public void stop() {
+            mContext.unregisterReceiver(mReceiver);
+        }
+
+    }
+
+    // TODO: Support some other vendor's pre-Lollipop software.
+    private static class PowerSaveCompat extends PowerSaveDetector {
+
+        public PowerSaveCompat(@NonNull Context context) {
+            super(context);
+        }
+
+        @Override
+        public void start() {
+
+        }
+
+        @Override
+        public void stop() {
+
+        }
+
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/acdisplay/utils/PowerUtils.java b/project/app/src/main/java/com/achep/base/utils/power/PowerUtils.java
similarity index 89%
rename from project/app/src/main/java/com/achep/acdisplay/utils/PowerUtils.java
rename to project/app/src/main/java/com/achep/base/utils/power/PowerUtils.java
index 26012b4a..b6ebb6bf 100644
--- a/project/app/src/main/java/com/achep/acdisplay/utils/PowerUtils.java
+++ b/project/app/src/main/java/com/achep/base/utils/power/PowerUtils.java
@@ -16,8 +16,9 @@
  * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
  * MA  02110-1301, USA.
  */
-package com.achep.acdisplay.utils;
+package com.achep.base.utils.power;
 
+import android.annotation.SuppressLint;
 import android.content.Context;
 import android.content.Intent;
 import android.content.IntentFilter;
@@ -26,6 +27,8 @@ import android.os.PowerManager;
 import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
 
+import com.achep.base.Device;
+
 /**
  * Helper class with utils related to power.
  *
@@ -46,6 +49,7 @@ public class PowerUtils {
      * @return true is device is plugged at this moment, false otherwise.
      * @see #isPlugged(android.content.Context)
      */
+    @SuppressLint("InlinedApi")
     public static boolean isPlugged(@Nullable Intent intent) {
         if (intent == null) {
             return false;
@@ -67,8 +71,11 @@ public class PowerUtils {
         return isScreenOn(pm);
     }
 
+    @SuppressLint("NewApi")
     public static boolean isScreenOn(@NonNull PowerManager pm) {
-        return pm.isScreenOn();
+        return Device.hasKitKatWatchApi()
+                ? pm.isInteractive()
+                : pm.isScreenOn();
     }
 
 }
diff --git a/project/app/src/main/java/com/achep/base/utils/xml/FastXmlSerializer.java b/project/app/src/main/java/com/achep/base/utils/xml/FastXmlSerializer.java
new file mode 100644
index 00000000..d90ac406
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/utils/xml/FastXmlSerializer.java
@@ -0,0 +1,393 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.achep.base.utils.xml;
+
+import org.xmlpull.v1.XmlSerializer;
+
+import java.io.IOException;
+import java.io.OutputStream;
+import java.io.OutputStreamWriter;
+import java.io.UnsupportedEncodingException;
+import java.io.Writer;
+import java.nio.ByteBuffer;
+import java.nio.CharBuffer;
+import java.nio.charset.Charset;
+import java.nio.charset.CharsetEncoder;
+import java.nio.charset.CoderResult;
+import java.nio.charset.IllegalCharsetNameException;
+import java.nio.charset.UnsupportedCharsetException;
+
+/**
+ * This is a quick and dirty implementation of XmlSerializer that isn't horribly
+ * painfully slow like the normal one.  It only does what is needed for the
+ * specific XML files being written with it.
+ */
+public class FastXmlSerializer implements XmlSerializer {
+    private static final String ESCAPE_TABLE[] = new String[]{
+            null, null, null, null, null, null, null, null,  // 0-7
+            null, null, null, null, null, null, null, null,  // 8-15
+            null, null, null, null, null, null, null, null,  // 16-23
+            null, null, null, null, null, null, null, null,  // 24-31
+            null, null, "&quot;", null, null, null, "&amp;", null,  // 32-39
+            null, null, null, null, null, null, null, null,  // 40-47
+            null, null, null, null, null, null, null, null,  // 48-55
+            null, null, null, null, "&lt;", null, "&gt;", null,  // 56-63
+    };
+
+    private static final int BUFFER_LEN = 8192;
+
+    private final char[] mText = new char[BUFFER_LEN];
+    private int mPos;
+
+    private Writer mWriter;
+
+    private OutputStream mOutputStream;
+    private CharsetEncoder mCharset;
+    private final ByteBuffer mBytes = ByteBuffer.allocate(BUFFER_LEN);
+
+    private boolean mIndent = false;
+    private boolean mInTag;
+
+    private int mNesting = 0;
+    private boolean mLineStart = true;
+
+    private void append(char c) throws IOException {
+        int pos = mPos;
+        if (pos >= (BUFFER_LEN - 1)) {
+            flush();
+            pos = mPos;
+        }
+        mText[pos] = c;
+        mPos = pos + 1;
+    }
+
+    private void append(String str, int i, final int length) throws IOException {
+        if (length > BUFFER_LEN) {
+            final int end = i + length;
+            while (i < end) {
+                int next = i + BUFFER_LEN;
+                append(str, i, next < end ? BUFFER_LEN : (end - i));
+                i = next;
+            }
+            return;
+        }
+        int pos = mPos;
+        if ((pos + length) > BUFFER_LEN) {
+            flush();
+            pos = mPos;
+        }
+        str.getChars(i, i + length, mText, pos);
+        mPos = pos + length;
+    }
+
+    private void append(char[] buf, int i, final int length) throws IOException {
+        if (length > BUFFER_LEN) {
+            final int end = i + length;
+            while (i < end) {
+                int next = i + BUFFER_LEN;
+                append(buf, i, next < end ? BUFFER_LEN : (end - i));
+                i = next;
+            }
+            return;
+        }
+        int pos = mPos;
+        if ((pos + length) > BUFFER_LEN) {
+            flush();
+            pos = mPos;
+        }
+        System.arraycopy(buf, i, mText, pos, length);
+        mPos = pos + length;
+    }
+
+    private void append(String str) throws IOException {
+        append(str, 0, str.length());
+    }
+
+    private void appendIndent(int indent) throws IOException {
+        indent *= 4;
+        String space = "                                                              ";
+        if (indent > space.length()) {
+            indent = space.length();
+        }
+        append(space, 0, indent);
+    }
+
+    private void escapeAndAppendString(final String string) throws IOException {
+        final int N = string.length();
+        final char NE = (char) ESCAPE_TABLE.length;
+        final String[] escapes = ESCAPE_TABLE;
+        int lastPos = 0;
+        int pos;
+        for (pos = 0; pos < N; pos++) {
+            char c = string.charAt(pos);
+            if (c >= NE) continue;
+            String escape = escapes[c];
+            if (escape == null) continue;
+            if (lastPos < pos) append(string, lastPos, pos - lastPos);
+            lastPos = pos + 1;
+            append(escape);
+        }
+        if (lastPos < pos) append(string, lastPos, pos - lastPos);
+    }
+
+    private void escapeAndAppendString(char[] buf, int start, int len) throws IOException {
+        final char NE = (char) ESCAPE_TABLE.length;
+        final String[] escapes = ESCAPE_TABLE;
+        int end = start + len;
+        int lastPos = start;
+        int pos;
+        for (pos = start; pos < end; pos++) {
+            char c = buf[pos];
+            if (c >= NE) continue;
+            String escape = escapes[c];
+            if (escape == null) continue;
+            if (lastPos < pos) append(buf, lastPos, pos - lastPos);
+            lastPos = pos + 1;
+            append(escape);
+        }
+        if (lastPos < pos) append(buf, lastPos, pos - lastPos);
+    }
+
+    public XmlSerializer attribute(String namespace, String name, String value) throws IOException,
+            IllegalArgumentException, IllegalStateException {
+        append(' ');
+        if (namespace != null) {
+            append(namespace);
+            append(':');
+        }
+        append(name);
+        append("=\"");
+
+        escapeAndAppendString(value);
+        append('"');
+        mLineStart = false;
+        return this;
+    }
+
+    public void cdsect(String text) throws IOException, IllegalArgumentException,
+            IllegalStateException {
+        throw new UnsupportedOperationException();
+    }
+
+    public void comment(String text) throws IOException, IllegalArgumentException,
+            IllegalStateException {
+        throw new UnsupportedOperationException();
+    }
+
+    public void docdecl(String text) throws IOException, IllegalArgumentException,
+            IllegalStateException {
+        throw new UnsupportedOperationException();
+    }
+
+    public void endDocument() throws IOException, IllegalArgumentException, IllegalStateException {
+        flush();
+    }
+
+    public XmlSerializer endTag(String namespace, String name) throws IOException,
+            IllegalArgumentException, IllegalStateException {
+        mNesting--;
+        if (mInTag) {
+            append(" />\n");
+        } else {
+            if (mIndent && mLineStart) {
+                appendIndent(mNesting);
+            }
+            append("</");
+            if (namespace != null) {
+                append(namespace);
+                append(':');
+            }
+            append(name);
+            append(">\n");
+        }
+        mLineStart = true;
+        mInTag = false;
+        return this;
+    }
+
+    public void entityRef(String text) throws IOException, IllegalArgumentException,
+            IllegalStateException {
+        throw new UnsupportedOperationException();
+    }
+
+    private void flushBytes() throws IOException {
+        int position;
+        if ((position = mBytes.position()) > 0) {
+            mBytes.flip();
+            mOutputStream.write(mBytes.array(), 0, position);
+            mBytes.clear();
+        }
+    }
+
+    public void flush() throws IOException {
+        //Log.i("PackageManager", "flush mPos=" + mPos);
+        if (mPos > 0) {
+            if (mOutputStream != null) {
+                CharBuffer charBuffer = CharBuffer.wrap(mText, 0, mPos);
+                CoderResult result = mCharset.encode(charBuffer, mBytes, true);
+                while (true) {
+                    if (result.isError()) {
+                        throw new IOException(result.toString());
+                    } else if (result.isOverflow()) {
+                        flushBytes();
+                        result = mCharset.encode(charBuffer, mBytes, true);
+                        continue;
+                    }
+                    break;
+                }
+                flushBytes();
+                mOutputStream.flush();
+            } else {
+                mWriter.write(mText, 0, mPos);
+                mWriter.flush();
+            }
+            mPos = 0;
+        }
+    }
+
+    public int getDepth() {
+        throw new UnsupportedOperationException();
+    }
+
+    public boolean getFeature(String name) {
+        throw new UnsupportedOperationException();
+    }
+
+    public String getName() {
+        throw new UnsupportedOperationException();
+    }
+
+    public String getNamespace() {
+        throw new UnsupportedOperationException();
+    }
+
+    public String getPrefix(String namespace, boolean generatePrefix)
+            throws IllegalArgumentException {
+        throw new UnsupportedOperationException();
+    }
+
+    public Object getProperty(String name) {
+        throw new UnsupportedOperationException();
+    }
+
+    public void ignorableWhitespace(String text) throws IOException, IllegalArgumentException,
+            IllegalStateException {
+        throw new UnsupportedOperationException();
+    }
+
+    public void processingInstruction(String text) throws IOException, IllegalArgumentException,
+            IllegalStateException {
+        throw new UnsupportedOperationException();
+    }
+
+    public void setFeature(String name, boolean state) throws IllegalArgumentException,
+            IllegalStateException {
+        if (name.equals("http://xmlpull.org/v1/doc/features.html#indent-output")) {
+            mIndent = true;
+            return;
+        }
+        throw new UnsupportedOperationException();
+    }
+
+    public void setOutput(OutputStream os, String encoding) throws IOException,
+            IllegalArgumentException, IllegalStateException {
+        if (os == null)
+            throw new IllegalArgumentException();
+        if (true) {
+            try {
+                mCharset = Charset.forName(encoding).newEncoder();
+            } catch (IllegalCharsetNameException | UnsupportedCharsetException e) {
+                throw (UnsupportedEncodingException) (new UnsupportedEncodingException(
+                        encoding).initCause(e));
+            }
+            mOutputStream = os;
+        } else {
+            setOutput(
+                    encoding == null
+                            ? new OutputStreamWriter(os)
+                            : new OutputStreamWriter(os, encoding));
+        }
+    }
+
+    public void setOutput(Writer writer) throws IOException, IllegalArgumentException,
+            IllegalStateException {
+        mWriter = writer;
+    }
+
+    public void setPrefix(String prefix, String namespace) throws IOException,
+            IllegalArgumentException, IllegalStateException {
+        throw new UnsupportedOperationException();
+    }
+
+    public void setProperty(String name, Object value) throws IllegalArgumentException,
+            IllegalStateException {
+        throw new UnsupportedOperationException();
+    }
+
+    public void startDocument(String encoding, Boolean standalone) throws IOException,
+            IllegalArgumentException, IllegalStateException {
+        append("<?xml version='1.0' encoding='utf-8' standalone='"
+                + (standalone ? "yes" : "no") + "' ?>\n");
+        mLineStart = true;
+    }
+
+    public XmlSerializer startTag(String namespace, String name) throws IOException,
+            IllegalArgumentException, IllegalStateException {
+        if (mInTag) {
+            append(">\n");
+        }
+        if (mIndent) {
+            appendIndent(mNesting);
+        }
+        mNesting++;
+        append('<');
+        if (namespace != null) {
+            append(namespace);
+            append(':');
+        }
+        append(name);
+        mInTag = true;
+        mLineStart = false;
+        return this;
+    }
+
+    public XmlSerializer text(char[] buf, int start, int len) throws IOException,
+            IllegalArgumentException, IllegalStateException {
+        if (mInTag) {
+            append('>');
+            mInTag = false;
+        }
+        escapeAndAppendString(buf, start, len);
+        if (mIndent) {
+            mLineStart = buf[start + len - 1] == '\n';
+        }
+        return this;
+    }
+
+    public XmlSerializer text(String text) throws IOException, IllegalArgumentException,
+            IllegalStateException {
+        if (mInTag) {
+            append('>');
+            mInTag = false;
+        }
+        escapeAndAppendString(text);
+        if (mIndent) {
+            mLineStart = text.length() > 0 && (text.charAt(text.length() - 1) == '\n');
+        }
+        return this;
+    }
+
+}
\ No newline at end of file
diff --git a/project/app/src/main/java/com/achep/base/utils/xml/XmlUtils.java b/project/app/src/main/java/com/achep/base/utils/xml/XmlUtils.java
new file mode 100644
index 00000000..5aa6ec29
--- /dev/null
+++ b/project/app/src/main/java/com/achep/base/utils/xml/XmlUtils.java
@@ -0,0 +1,1465 @@
+/*
+ * Copyright (C) 2006 The Android Open Source Project
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *      http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+package com.achep.base.utils.xml;
+
+import android.graphics.Bitmap;
+import android.graphics.Bitmap.CompressFormat;
+import android.graphics.BitmapFactory;
+import android.net.Uri;
+import android.util.Base64;
+import android.util.Xml;
+
+import org.xmlpull.v1.XmlPullParser;
+import org.xmlpull.v1.XmlPullParserException;
+import org.xmlpull.v1.XmlSerializer;
+
+import java.io.ByteArrayOutputStream;
+import java.io.IOException;
+import java.io.InputStream;
+import java.io.OutputStream;
+import java.net.ProtocolException;
+import java.util.ArrayList;
+import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
+import java.util.Map;
+import java.util.Set;
+
+public class XmlUtils {
+
+    public static void skipCurrentTag(XmlPullParser parser)
+            throws XmlPullParserException, IOException {
+        int outerDepth = parser.getDepth();
+        int type;
+        //noinspection StatementWithEmptyBody
+        while ((type = parser.next()) != XmlPullParser.END_DOCUMENT
+                && (type != XmlPullParser.END_TAG
+                || parser.getDepth() > outerDepth)) ;
+    }
+
+    public static int convertValueToList(CharSequence value, String[] options, int defaultValue) {
+        if (value != null)
+            for (int i = 0; i < options.length; i++)
+                if (value.equals(options[i]))
+                    return i;
+        return defaultValue;
+    }
+
+    public static boolean convertValueToBoolean(CharSequence value, boolean defaultValue) {
+        if (value == null)
+            return defaultValue;
+
+        return value.equals("1")
+                || value.equals("true")
+                || value.equals("TRUE");
+    }
+
+    public static int convertValueToInt(CharSequence charSeq, int defaultValue) {
+        if (charSeq == null)
+            return defaultValue;
+
+        String nm = charSeq.toString();
+
+        // XXX This code is copied from Integer.decode() so we don't
+        // have to instantiate an Integer!
+
+        int sign = 1;
+        int index = 0;
+        int len = nm.length();
+        int base = 10;
+
+        if ('-' == nm.charAt(0)) {
+            sign = -1;
+            index++;
+        }
+
+        if ('0' == nm.charAt(index)) {
+            //  Quick check for a zero by itself
+            if (index == (len - 1))
+                return 0;
+
+            char c = nm.charAt(index + 1);
+
+            if ('x' == c || 'X' == c) {
+                index += 2;
+                base = 16;
+            } else {
+                index++;
+                base = 8;
+            }
+        } else if ('#' == nm.charAt(index)) {
+            index++;
+            base = 16;
+        }
+
+        return Integer.parseInt(nm.substring(index), base) * sign;
+    }
+
+    public static int convertValueToUnsignedInt(String value, int defaultValue) {
+        return value == null ? defaultValue : parseUnsignedIntAttribute(value);
+    }
+
+    public static int parseUnsignedIntAttribute(CharSequence charSeq) {
+        String value = charSeq.toString();
+
+        int index = 0;
+        int len = value.length();
+        int base = 10;
+
+        if ('0' == value.charAt(index)) {
+            //  Quick check for zero by itself
+            if (index == (len - 1))
+                return 0;
+
+            char c = value.charAt(index + 1);
+
+            if ('x' == c || 'X' == c) { //  check for hex
+                index += 2;
+                base = 16;
+            } else {                    //  check for octal
+                index++;
+                base = 8;
+            }
+        } else if ('#' == value.charAt(index)) {
+            index++;
+            base = 16;
+        }
+
+        return (int) Long.parseLong(value.substring(index), base);
+    }
+
+    /**
+     * Flatten a Map into an output stream as XML.  The map can later be
+     * read back with readMapXml().
+     *
+     * @param val The map to be flattened.
+     * @param out Where to write the XML data.
+     * @see #writeMapXml(Map, String, XmlSerializer)
+     * @see #writeListXml
+     * @see #writeValueXml
+     * @see #readMapXml
+     */
+    public static void writeMapXml(Map val, OutputStream out)
+            throws XmlPullParserException, java.io.IOException {
+        XmlSerializer serializer = new FastXmlSerializer();
+        serializer.setOutput(out, "utf-8");
+        serializer.startDocument(null, true);
+        serializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
+        writeMapXml(val, null, serializer);
+        serializer.endDocument();
+    }
+
+    /**
+     * Flatten a List into an output stream as XML.  The list can later be
+     * read back with readListXml().
+     *
+     * @param val The list to be flattened.
+     * @param out Where to write the XML data.
+     * @see #writeListXml(List, String, XmlSerializer)
+     * @see #writeMapXml
+     * @see #writeValueXml
+     * @see #readListXml
+     */
+    public static void writeListXml(List val, OutputStream out)
+            throws XmlPullParserException, java.io.IOException {
+        XmlSerializer serializer = Xml.newSerializer();
+        serializer.setOutput(out, "utf-8");
+        serializer.startDocument(null, true);
+        serializer.setFeature("http://xmlpull.org/v1/doc/features.html#indent-output", true);
+        writeListXml(val, null, serializer);
+        serializer.endDocument();
+    }
+
+    /**
+     * Flatten a Map into an XmlSerializer.  The map can later be read back
+     * with readThisMapXml().
+     *
+     * @param val  The map to be flattened.
+     * @param name Name attribute to include with this list's tag, or null for
+     *             none.
+     * @param out  XmlSerializer to write the map into.
+     * @see #writeMapXml(Map, OutputStream)
+     * @see #writeListXml
+     * @see #writeValueXml
+     * @see #readMapXml
+     */
+    public static void writeMapXml(Map val, String name, XmlSerializer out)
+            throws XmlPullParserException, java.io.IOException {
+        writeMapXml(val, name, out, null);
+    }
+
+    /**
+     * Flatten a Map into an XmlSerializer.  The map can later be read back
+     * with readThisMapXml().
+     *
+     * @param val      The map to be flattened.
+     * @param name     Name attribute to include with this list's tag, or null for
+     *                 none.
+     * @param out      XmlSerializer to write the map into.
+     * @param callback Method to call when an Object type is not recognized.
+     * @see #writeMapXml(Map, OutputStream)
+     * @see #writeListXml
+     * @see #writeValueXml
+     * @see #readMapXml
+     */
+    public static void writeMapXml(Map val, String name, XmlSerializer out,
+                                   WriteMapCallback callback)
+            throws XmlPullParserException, java.io.IOException {
+
+        if (val == null) {
+            out.startTag(null, "null");
+            out.endTag(null, "null");
+            return;
+        }
+
+        out.startTag(null, "map");
+        if (name != null) {
+            out.attribute(null, "name", name);
+        }
+
+        writeMapXml(val, out, callback);
+
+        out.endTag(null, "map");
+    }
+
+    /**
+     * Flatten a Map into an XmlSerializer.  The map can later be read back
+     * with readThisMapXml(). This method presumes that the start tag and
+     * name attribute have already been written and does not write an end tag.
+     *
+     * @param val The map to be flattened.
+     * @param out XmlSerializer to write the map into.
+     * @see #writeMapXml(Map, OutputStream)
+     * @see #writeListXml
+     * @see #writeValueXml
+     * @see #readMapXml
+     */
+    public static void writeMapXml(Map val, XmlSerializer out, WriteMapCallback callback)
+            throws XmlPullParserException, java.io.IOException {
+        if (val == null) {
+            return;
+        }
+
+        Set s = val.entrySet();
+
+        for (Object value : s) {
+            Map.Entry e = (Map.Entry) value;
+            writeValueXml(e.getValue(), (String) e.getKey(), out, callback);
+        }
+    }
+
+    /**
+     * Flatten a List into an XmlSerializer.  The list can later be read back
+     * with readThisListXml().
+     *
+     * @param val  The list to be flattened.
+     * @param name Name attribute to include with this list's tag, or null for
+     *             none.
+     * @param out  XmlSerializer to write the list into.
+     * @see #writeListXml(List, OutputStream)
+     * @see #writeMapXml
+     * @see #writeValueXml
+     * @see #readListXml
+     */
+    public static void writeListXml(List val, String name, XmlSerializer out)
+            throws XmlPullParserException, java.io.IOException {
+        if (val == null) {
+            out.startTag(null, "null");
+            out.endTag(null, "null");
+            return;
+        }
+
+        out.startTag(null, "list");
+        if (name != null) {
+            out.attribute(null, "name", name);
+        }
+
+        int N = val.size();
+        int i = 0;
+        while (i < N) {
+            writeValueXml(val.get(i), null, out);
+            i++;
+        }
+
+        out.endTag(null, "list");
+    }
+
+    public static void writeSetXml(Set val, String name, XmlSerializer out)
+            throws XmlPullParserException, java.io.IOException {
+        if (val == null) {
+            out.startTag(null, "null");
+            out.endTag(null, "null");
+            return;
+        }
+
+        out.startTag(null, "set");
+        if (name != null) {
+            out.attribute(null, "name", name);
+        }
+
+        for (Object v : val) {
+            writeValueXml(v, null, out);
+        }
+
+        out.endTag(null, "set");
+    }
+
+    /**
+     * Flatten a byte[] into an XmlSerializer.  The list can later be read back
+     * with readThisByteArrayXml().
+     *
+     * @param val  The byte array to be flattened.
+     * @param name Name attribute to include with this array's tag, or null for
+     *             none.
+     * @param out  XmlSerializer to write the array into.
+     * @see #writeMapXml
+     * @see #writeValueXml
+     */
+    public static void writeByteArrayXml(byte[] val, String name, XmlSerializer out)
+            throws java.io.IOException {
+
+        if (val == null) {
+            out.startTag(null, "null");
+            out.endTag(null, "null");
+            return;
+        }
+
+        out.startTag(null, "byte-array");
+        if (name != null) {
+            out.attribute(null, "name", name);
+        }
+
+        final int N = val.length;
+        out.attribute(null, "num", Integer.toString(N));
+
+        StringBuilder sb = new StringBuilder(val.length * 2);
+        for (byte b : val) {
+            int h = b >> 4;
+            sb.append(h >= 10 ? ('a' + h - 10) : ('0' + h));
+            h = b & 0xff;
+            sb.append(h >= 10 ? ('a' + h - 10) : ('0' + h));
+        }
+
+        out.text(sb.toString());
+
+        out.endTag(null, "byte-array");
+    }
+
+    /**
+     * Flatten an int[] into an XmlSerializer.  The list can later be read back
+     * with readThisIntArrayXml().
+     *
+     * @param val  The int array to be flattened.
+     * @param name Name attribute to include with this array's tag, or null for
+     *             none.
+     * @param out  XmlSerializer to write the array into.
+     * @see #writeMapXml
+     * @see #writeValueXml
+     * @see #readThisIntArrayXml
+     */
+    public static void writeIntArrayXml(int[] val, String name, XmlSerializer out)
+            throws java.io.IOException {
+
+        if (val == null) {
+            out.startTag(null, "null");
+            out.endTag(null, "null");
+            return;
+        }
+
+        out.startTag(null, "int-array");
+        if (name != null) {
+            out.attribute(null, "name", name);
+        }
+
+        final int N = val.length;
+        out.attribute(null, "num", Integer.toString(N));
+
+        for (int aVal : val) {
+            out.startTag(null, "item");
+            out.attribute(null, "value", Integer.toString(aVal));
+            out.endTag(null, "item");
+        }
+
+        out.endTag(null, "int-array");
+    }
+
+    /**
+     * Flatten a long[] into an XmlSerializer.  The list can later be read back
+     * with readThisLongArrayXml().
+     *
+     * @param val  The long array to be flattened.
+     * @param name Name attribute to include with this array's tag, or null for
+     *             none.
+     * @param out  XmlSerializer to write the array into.
+     * @see #writeMapXml
+     * @see #writeValueXml
+     * @see #readThisIntArrayXml
+     */
+    public static void writeLongArrayXml(long[] val, String name, XmlSerializer out)
+            throws java.io.IOException {
+
+        if (val == null) {
+            out.startTag(null, "null");
+            out.endTag(null, "null");
+            return;
+        }
+
+        out.startTag(null, "long-array");
+        if (name != null) {
+            out.attribute(null, "name", name);
+        }
+
+        final int N = val.length;
+        out.attribute(null, "num", Integer.toString(N));
+
+        for (long aVal : val) {
+            out.startTag(null, "item");
+            out.attribute(null, "value", Long.toString(aVal));
+            out.endTag(null, "item");
+        }
+
+        out.endTag(null, "long-array");
+    }
+
+    /**
+     * Flatten a double[] into an XmlSerializer.  The list can later be read back
+     * with readThisDoubleArrayXml().
+     *
+     * @param val  The double array to be flattened.
+     * @param name Name attribute to include with this array's tag, or null for
+     *             none.
+     * @param out  XmlSerializer to write the array into.
+     * @see #writeMapXml
+     * @see #writeValueXml
+     * @see #readThisIntArrayXml
+     */
+    public static void writeDoubleArrayXml(double[] val, String name, XmlSerializer out)
+            throws java.io.IOException {
+
+        if (val == null) {
+            out.startTag(null, "null");
+            out.endTag(null, "null");
+            return;
+        }
+
+        out.startTag(null, "double-array");
+        if (name != null) {
+            out.attribute(null, "name", name);
+        }
+
+        final int N = val.length;
+        out.attribute(null, "num", Integer.toString(N));
+
+        for (double aVal : val) {
+            out.startTag(null, "item");
+            out.attribute(null, "value", Double.toString(aVal));
+            out.endTag(null, "item");
+        }
+
+        out.endTag(null, "double-array");
+    }
+
+    /**
+     * Flatten a String[] into an XmlSerializer.  The list can later be read back
+     * with readThisStringArrayXml().
+     *
+     * @param val  The long array to be flattened.
+     * @param name Name attribute to include with this array's tag, or null for
+     *             none.
+     * @param out  XmlSerializer to write the array into.
+     * @see #writeMapXml
+     * @see #writeValueXml
+     * @see #readThisIntArrayXml
+     */
+    public static void writeStringArrayXml(String[] val, String name, XmlSerializer out)
+            throws java.io.IOException {
+
+        if (val == null) {
+            out.startTag(null, "null");
+            out.endTag(null, "null");
+            return;
+        }
+
+        out.startTag(null, "string-array");
+        if (name != null) {
+            out.attribute(null, "name", name);
+        }
+
+        final int N = val.length;
+        out.attribute(null, "num", Integer.toString(N));
+
+        for (String aVal : val) {
+            out.startTag(null, "item");
+            out.attribute(null, "value", aVal);
+            out.endTag(null, "item");
+        }
+
+        out.endTag(null, "string-array");
+    }
+
+    /**
+     * Flatten an object's value into an XmlSerializer.  The value can later
+     * be read back with readThisValueXml().
+     * <p/>
+     * Currently supported value types are: null, String, Integer, Long,
+     * Float, Double Boolean, Map, List.
+     *
+     * @param v    The object to be flattened.
+     * @param name Name attribute to include with this value's tag, or null
+     *             for none.
+     * @param out  XmlSerializer to write the object into.
+     * @see #writeMapXml
+     * @see #writeListXml
+     * @see #readValueXml
+     */
+    public static void writeValueXml(Object v, String name, XmlSerializer out)
+            throws XmlPullParserException, java.io.IOException {
+        writeValueXml(v, name, out, null);
+    }
+
+    /**
+     * Flatten an object's value into an XmlSerializer.  The value can later
+     * be read back with readThisValueXml().
+     * <p/>
+     * Currently supported value types are: null, String, Integer, Long,
+     * Float, Double Boolean, Map, List.
+     *
+     * @param v        The object to be flattened.
+     * @param name     Name attribute to include with this value's tag, or null
+     *                 for none.
+     * @param out      XmlSerializer to write the object into.
+     * @param callback Handler for Object types not recognized.
+     * @see #writeMapXml
+     * @see #writeListXml
+     * @see #readValueXml
+     */
+    private static void writeValueXml(Object v, String name, XmlSerializer out,
+                                      WriteMapCallback callback)
+            throws XmlPullParserException, java.io.IOException {
+        String typeStr;
+        if (v == null) {
+            out.startTag(null, "null");
+            if (name != null) {
+                out.attribute(null, "name", name);
+            }
+            out.endTag(null, "null");
+            return;
+        } else if (v instanceof String) {
+            out.startTag(null, "string");
+            if (name != null) {
+                out.attribute(null, "name", name);
+            }
+            out.text(v.toString());
+            out.endTag(null, "string");
+            return;
+        } else if (v instanceof Integer) {
+            typeStr = "int";
+        } else if (v instanceof Long) {
+            typeStr = "long";
+        } else if (v instanceof Float) {
+            typeStr = "float";
+        } else if (v instanceof Double) {
+            typeStr = "double";
+        } else if (v instanceof Boolean) {
+            typeStr = "boolean";
+        } else if (v instanceof byte[]) {
+            writeByteArrayXml((byte[]) v, name, out);
+            return;
+        } else if (v instanceof int[]) {
+            writeIntArrayXml((int[]) v, name, out);
+            return;
+        } else if (v instanceof long[]) {
+            writeLongArrayXml((long[]) v, name, out);
+            return;
+        } else if (v instanceof double[]) {
+            writeDoubleArrayXml((double[]) v, name, out);
+            return;
+        } else if (v instanceof String[]) {
+            writeStringArrayXml((String[]) v, name, out);
+            return;
+        } else if (v instanceof Map) {
+            writeMapXml((Map) v, name, out);
+            return;
+        } else if (v instanceof List) {
+            writeListXml((List) v, name, out);
+            return;
+        } else if (v instanceof Set) {
+            writeSetXml((Set) v, name, out);
+            return;
+        } else if (v instanceof CharSequence) {
+            // XXX This is to allow us to at least write something if
+            // we encounter styled text...  but it means we will drop all
+            // of the styling information. :(
+            out.startTag(null, "string");
+            if (name != null) {
+                out.attribute(null, "name", name);
+            }
+            out.text(v.toString());
+            out.endTag(null, "string");
+            return;
+        } else if (callback != null) {
+            callback.writeUnknownObject(v, name, out);
+            return;
+        } else {
+            throw new RuntimeException("writeValueXml: unable to write value " + v);
+        }
+
+        out.startTag(null, typeStr);
+        if (name != null) {
+            out.attribute(null, "name", name);
+        }
+        out.attribute(null, "value", v.toString());
+        out.endTag(null, typeStr);
+    }
+
+    /**
+     * Read a HashMap from an InputStream containing XML.  The stream can
+     * previously have been written by writeMapXml().
+     *
+     * @param in The InputStream from which to read.
+     * @return HashMap The resulting map.
+     * @see #readListXml
+     * @see #readValueXml
+     * @see #readThisMapXml
+     * #see #writeMapXml
+     */
+    @SuppressWarnings("unchecked")
+    public static HashMap<String, ?> readMapXml(InputStream in)
+            throws XmlPullParserException, java.io.IOException {
+        XmlPullParser parser = Xml.newPullParser();
+        parser.setInput(in, null);
+        return (HashMap<String, ?>) readValueXml(parser, new String[1]);
+    }
+
+    /**
+     * Read an ArrayList from an InputStream containing XML.  The stream can
+     * previously have been written by writeListXml().
+     *
+     * @param in The InputStream from which to read.
+     * @return ArrayList The resulting list.
+     * @see #readMapXml
+     * @see #readValueXml
+     * @see #readThisListXml
+     * @see #writeListXml
+     */
+    public static ArrayList readListXml(InputStream in)
+            throws XmlPullParserException, java.io.IOException {
+        XmlPullParser parser = Xml.newPullParser();
+        parser.setInput(in, null);
+        return (ArrayList) readValueXml(parser, new String[1]);
+    }
+
+
+    /**
+     * Read a HashSet from an InputStream containing XML. The stream can
+     * previously have been written by writeSetXml().
+     *
+     * @param in The InputStream from which to read.
+     * @return HashSet The resulting set.
+     * @throws XmlPullParserException
+     * @throws java.io.IOException
+     * @see #readValueXml
+     * @see #readThisSetXml
+     * @see #writeSetXml
+     */
+    public static HashSet readSetXml(InputStream in)
+            throws XmlPullParserException, java.io.IOException {
+        XmlPullParser parser = Xml.newPullParser();
+        parser.setInput(in, null);
+        return (HashSet) readValueXml(parser, new String[1]);
+    }
+
+    /**
+     * Read a HashMap object from an XmlPullParser.  The XML data could
+     * previously have been generated by writeMapXml().  The XmlPullParser
+     * must be positioned <em>after</em> the tag that begins the map.
+     *
+     * @param parser The XmlPullParser from which to read the map data.
+     * @param endTag Name of the tag that will end the map, usually "map".
+     * @param name   An array of one string, used to return the name attribute
+     *               of the map's tag.
+     * @return HashMap The newly generated map.
+     * @see #readMapXml
+     */
+    public static HashMap<String, ?> readThisMapXml(XmlPullParser parser, String endTag,
+                                                    String[] name)
+            throws XmlPullParserException, java.io.IOException {
+        return readThisMapXml(parser, endTag, name, null);
+    }
+
+    /**
+     * Read a HashMap object from an XmlPullParser.  The XML data could
+     * previously have been generated by writeMapXml().  The XmlPullParser
+     * must be positioned <em>after</em> the tag that begins the map.
+     *
+     * @param parser The XmlPullParser from which to read the map data.
+     * @param endTag Name of the tag that will end the map, usually "map".
+     * @param name   An array of one string, used to return the name attribute
+     *               of the map's tag.
+     * @return HashMap The newly generated map.
+     * @see #readMapXml
+     */
+    public static HashMap<String, ?> readThisMapXml(XmlPullParser parser, String endTag,
+                                                    String[] name, ReadMapCallback callback)
+            throws XmlPullParserException, java.io.IOException {
+        HashMap<String, Object> map = new HashMap<>();
+
+        int eventType = parser.getEventType();
+        do {
+            if (eventType == XmlPullParser.START_TAG) {
+                Object val = readThisValueXml(parser, name, callback);
+                map.put(name[0], val);
+            } else if (eventType == XmlPullParser.END_TAG) {
+                if (parser.getName().equals(endTag)) {
+                    return map;
+                }
+                throw new XmlPullParserException(
+                        "Expected " + endTag + " end tag at: " + parser.getName());
+            }
+            eventType = parser.next();
+        } while (eventType != XmlPullParser.END_DOCUMENT);
+
+        throw new XmlPullParserException(
+                "Document ended before " + endTag + " end tag");
+    }
+
+    /**
+     * Read an ArrayList object from an XmlPullParser.  The XML data could
+     * previously have been generated by writeListXml().  The XmlPullParser
+     * must be positioned <em>after</em> the tag that begins the list.
+     *
+     * @param parser The XmlPullParser from which to read the list data.
+     * @param endTag Name of the tag that will end the list, usually "list".
+     * @param name   An array of one string, used to return the name attribute
+     *               of the list's tag.
+     * @return HashMap The newly generated list.
+     * @see #readListXml
+     */
+    public static ArrayList readThisListXml(XmlPullParser parser, String endTag, String[] name)
+            throws XmlPullParserException, java.io.IOException {
+        return readThisListXml(parser, endTag, name, null);
+    }
+
+    /**
+     * Read an ArrayList object from an XmlPullParser.  The XML data could
+     * previously have been generated by writeListXml().  The XmlPullParser
+     * must be positioned <em>after</em> the tag that begins the list.
+     *
+     * @param parser The XmlPullParser from which to read the list data.
+     * @param endTag Name of the tag that will end the list, usually "list".
+     * @param name   An array of one string, used to return the name attribute
+     *               of the list's tag.
+     * @return HashMap The newly generated list.
+     * @see #readListXml
+     */
+    private static ArrayList readThisListXml(XmlPullParser parser, String endTag,
+                                             String[] name, ReadMapCallback callback)
+            throws XmlPullParserException, java.io.IOException {
+        ArrayList list = new ArrayList();
+
+        int eventType = parser.getEventType();
+        do {
+            if (eventType == XmlPullParser.START_TAG) {
+                Object val = readThisValueXml(parser, name, callback);
+                list.add(val);
+                //System.out.println("Adding to list: " + val);
+            } else if (eventType == XmlPullParser.END_TAG) {
+                if (parser.getName().equals(endTag)) {
+                    return list;
+                }
+                throw new XmlPullParserException(
+                        "Expected " + endTag + " end tag at: " + parser.getName());
+            }
+            eventType = parser.next();
+        } while (eventType != XmlPullParser.END_DOCUMENT);
+
+        throw new XmlPullParserException(
+                "Document ended before " + endTag + " end tag");
+    }
+
+    /**
+     * Read a HashSet object from an XmlPullParser. The XML data could previously
+     * have been generated by writeSetXml(). The XmlPullParser must be positioned
+     * <em>after</em> the tag that begins the set.
+     *
+     * @param parser The XmlPullParser from which to read the set data.
+     * @param endTag Name of the tag that will end the set, usually "set".
+     * @param name   An array of one string, used to return the name attribute
+     *               of the set's tag.
+     * @return HashSet The newly generated set.
+     * @throws XmlPullParserException
+     * @throws java.io.IOException
+     * @see #readSetXml
+     */
+    public static HashSet readThisSetXml(XmlPullParser parser, String endTag, String[] name)
+            throws XmlPullParserException, java.io.IOException {
+        return readThisSetXml(parser, endTag, name, null);
+    }
+
+    /**
+     * Read a HashSet object from an XmlPullParser. The XML data could previously
+     * have been generated by writeSetXml(). The XmlPullParser must be positioned
+     * <em>after</em> the tag that begins the set.
+     *
+     * @param parser The XmlPullParser from which to read the set data.
+     * @param endTag Name of the tag that will end the set, usually "set".
+     * @param name   An array of one string, used to return the name attribute
+     *               of the set's tag.
+     * @return HashSet The newly generated set.
+     * @throws XmlPullParserException
+     * @throws java.io.IOException
+     * @see #readSetXml
+     */
+    private static HashSet readThisSetXml(XmlPullParser parser, String endTag, String[] name,
+                                          ReadMapCallback callback)
+            throws XmlPullParserException, java.io.IOException {
+        HashSet set = new HashSet();
+
+        int eventType = parser.getEventType();
+        do {
+            if (eventType == XmlPullParser.START_TAG) {
+                Object val = readThisValueXml(parser, name, callback);
+                set.add(val);
+                //System.out.println("Adding to set: " + val);
+            } else if (eventType == XmlPullParser.END_TAG) {
+                if (parser.getName().equals(endTag)) {
+                    return set;
+                }
+                throw new XmlPullParserException(
+                        "Expected " + endTag + " end tag at: " + parser.getName());
+            }
+            eventType = parser.next();
+        } while (eventType != XmlPullParser.END_DOCUMENT);
+
+        throw new XmlPullParserException(
+                "Document ended before " + endTag + " end tag");
+    }
+
+    /**
+     * Read an int[] object from an XmlPullParser.  The XML data could
+     * previously have been generated by writeIntArrayXml().  The XmlPullParser
+     * must be positioned <em>after</em> the tag that begins the list.
+     *
+     * @param parser The XmlPullParser from which to read the list data.
+     * @param endTag Name of the tag that will end the list, usually "list".
+     * @param name   An array of one string, used to return the name attribute
+     *               of the list's tag.
+     * @return Returns a newly generated int[].
+     * @see #readListXml
+     */
+    public static int[] readThisIntArrayXml(XmlPullParser parser,
+                                            String endTag, String[] name)
+            throws XmlPullParserException, java.io.IOException {
+
+        int num;
+        try {
+            num = Integer.parseInt(parser.getAttributeValue(null, "num"));
+        } catch (NullPointerException e) {
+            throw new XmlPullParserException(
+                    "Need num attribute in byte-array");
+        } catch (NumberFormatException e) {
+            throw new XmlPullParserException(
+                    "Not a number in num attribute in byte-array");
+        }
+        parser.next();
+
+        int[] array = new int[num];
+        int i = 0;
+
+        int eventType = parser.getEventType();
+        do {
+            if (eventType == XmlPullParser.START_TAG) {
+                if (parser.getName().equals("item")) {
+                    try {
+                        array[i] = Integer.parseInt(
+                                parser.getAttributeValue(null, "value"));
+                    } catch (NullPointerException e) {
+                        throw new XmlPullParserException(
+                                "Need value attribute in item");
+                    } catch (NumberFormatException e) {
+                        throw new XmlPullParserException(
+                                "Not a number in value attribute in item");
+                    }
+                } else {
+                    throw new XmlPullParserException(
+                            "Expected item tag at: " + parser.getName());
+                }
+            } else if (eventType == XmlPullParser.END_TAG) {
+                if (parser.getName().equals(endTag)) {
+                    return array;
+                } else if (parser.getName().equals("item")) {
+                    i++;
+                } else {
+                    throw new XmlPullParserException(
+                            "Expected " + endTag + " end tag at: "
+                                    + parser.getName());
+                }
+            }
+            eventType = parser.next();
+        } while (eventType != XmlPullParser.END_DOCUMENT);
+
+        throw new XmlPullParserException(
+                "Document ended before " + endTag + " end tag");
+    }
+
+    /**
+     * Read a long[] object from an XmlPullParser.  The XML data could
+     * previously have been generated by writeLongArrayXml().  The XmlPullParser
+     * must be positioned <em>after</em> the tag that begins the list.
+     *
+     * @param parser The XmlPullParser from which to read the list data.
+     * @param endTag Name of the tag that will end the list, usually "list".
+     * @param name   An array of one string, used to return the name attribute
+     *               of the list's tag.
+     * @return Returns a newly generated long[].
+     * @see #readListXml
+     */
+    public static long[] readThisLongArrayXml(XmlPullParser parser,
+                                              String endTag, String[] name)
+            throws XmlPullParserException, java.io.IOException {
+
+        int num;
+        try {
+            num = Integer.parseInt(parser.getAttributeValue(null, "num"));
+        } catch (NullPointerException e) {
+            throw new XmlPullParserException("Need num attribute in long-array");
+        } catch (NumberFormatException e) {
+            throw new XmlPullParserException("Not a number in num attribute in long-array");
+        }
+        parser.next();
+
+        long[] array = new long[num];
+        int i = 0;
+
+        int eventType = parser.getEventType();
+        do {
+            if (eventType == XmlPullParser.START_TAG) {
+                if (parser.getName().equals("item")) {
+                    try {
+                        array[i] = Long.parseLong(parser.getAttributeValue(null, "value"));
+                    } catch (NullPointerException e) {
+                        throw new XmlPullParserException("Need value attribute in item");
+                    } catch (NumberFormatException e) {
+                        throw new XmlPullParserException("Not a number in value attribute in item");
+                    }
+                } else {
+                    throw new XmlPullParserException("Expected item tag at: " + parser.getName());
+                }
+            } else if (eventType == XmlPullParser.END_TAG) {
+                if (parser.getName().equals(endTag)) {
+                    return array;
+                } else if (parser.getName().equals("item")) {
+                    i++;
+                } else {
+                    throw new XmlPullParserException("Expected " + endTag + " end tag at: " +
+                            parser.getName());
+                }
+            }
+            eventType = parser.next();
+        } while (eventType != XmlPullParser.END_DOCUMENT);
+
+        throw new XmlPullParserException("Document ended before " + endTag + " end tag");
+    }
+
+    /**
+     * Read a double[] object from an XmlPullParser.  The XML data could
+     * previously have been generated by writeDoubleArrayXml().  The XmlPullParser
+     * must be positioned <em>after</em> the tag that begins the list.
+     *
+     * @param parser The XmlPullParser from which to read the list data.
+     * @param endTag Name of the tag that will end the list, usually "double-array".
+     * @param name   An array of one string, used to return the name attribute
+     *               of the list's tag.
+     * @return Returns a newly generated double[].
+     * @see #readListXml
+     */
+    public static double[] readThisDoubleArrayXml(XmlPullParser parser, String endTag, String[] name)
+            throws XmlPullParserException, java.io.IOException {
+
+        int num;
+        try {
+            num = Integer.parseInt(parser.getAttributeValue(null, "num"));
+        } catch (NullPointerException e) {
+            throw new XmlPullParserException("Need num attribute in double-array");
+        } catch (NumberFormatException e) {
+            throw new XmlPullParserException("Not a number in num attribute in double-array");
+        }
+        parser.next();
+
+        double[] array = new double[num];
+        int i = 0;
+
+        int eventType = parser.getEventType();
+        do {
+            if (eventType == XmlPullParser.START_TAG) {
+                if (parser.getName().equals("item")) {
+                    try {
+                        array[i] = Double.parseDouble(parser.getAttributeValue(null, "value"));
+                    } catch (NullPointerException e) {
+                        throw new XmlPullParserException("Need value attribute in item");
+                    } catch (NumberFormatException e) {
+                        throw new XmlPullParserException("Not a number in value attribute in item");
+                    }
+                } else {
+                    throw new XmlPullParserException("Expected item tag at: " + parser.getName());
+                }
+            } else if (eventType == XmlPullParser.END_TAG) {
+                if (parser.getName().equals(endTag)) {
+                    return array;
+                } else if (parser.getName().equals("item")) {
+                    i++;
+                } else {
+                    throw new XmlPullParserException("Expected " + endTag + " end tag at: " +
+                            parser.getName());
+                }
+            }
+            eventType = parser.next();
+        } while (eventType != XmlPullParser.END_DOCUMENT);
+
+        throw new XmlPullParserException("Document ended before " + endTag + " end tag");
+    }
+
+    /**
+     * Read a String[] object from an XmlPullParser.  The XML data could
+     * previously have been generated by writeStringArrayXml().  The XmlPullParser
+     * must be positioned <em>after</em> the tag that begins the list.
+     *
+     * @param parser The XmlPullParser from which to read the list data.
+     * @param endTag Name of the tag that will end the list, usually "string-array".
+     * @param name   An array of one string, used to return the name attribute
+     *               of the list's tag.
+     * @return Returns a newly generated String[].
+     * @see #readListXml
+     */
+    public static String[] readThisStringArrayXml(XmlPullParser parser, String endTag, String[] name)
+            throws XmlPullParserException, java.io.IOException {
+
+        int num;
+        try {
+            num = Integer.parseInt(parser.getAttributeValue(null, "num"));
+        } catch (NullPointerException e) {
+            throw new XmlPullParserException("Need num attribute in string-array");
+        } catch (NumberFormatException e) {
+            throw new XmlPullParserException("Not a number in num attribute in string-array");
+        }
+        parser.next();
+
+        String[] array = new String[num];
+        int i = 0;
+
+        int eventType = parser.getEventType();
+        do {
+            if (eventType == XmlPullParser.START_TAG) {
+                if (parser.getName().equals("item")) {
+                    try {
+                        array[i] = parser.getAttributeValue(null, "value");
+                    } catch (NullPointerException e) {
+                        throw new XmlPullParserException("Need value attribute in item");
+                    } catch (NumberFormatException e) {
+                        throw new XmlPullParserException("Not a number in value attribute in item");
+                    }
+                } else {
+                    throw new XmlPullParserException("Expected item tag at: " + parser.getName());
+                }
+            } else if (eventType == XmlPullParser.END_TAG) {
+                if (parser.getName().equals(endTag)) {
+                    return array;
+                } else if (parser.getName().equals("item")) {
+                    i++;
+                } else {
+                    throw new XmlPullParserException("Expected " + endTag + " end tag at: " +
+                            parser.getName());
+                }
+            }
+            eventType = parser.next();
+        } while (eventType != XmlPullParser.END_DOCUMENT);
+
+        throw new XmlPullParserException("Document ended before " + endTag + " end tag");
+    }
+
+    /**
+     * Read a flattened object from an XmlPullParser.  The XML data could
+     * previously have been written with writeMapXml(), writeListXml(), or
+     * writeValueXml().  The XmlPullParser must be positioned <em>at</em> the
+     * tag that defines the value.
+     *
+     * @param parser The XmlPullParser from which to read the object.
+     * @param name   An array of one string, used to return the name attribute
+     *               of the value's tag.
+     * @return Object The newly generated value object.
+     * @see #readMapXml
+     * @see #readListXml
+     * @see #writeValueXml
+     */
+    public static Object readValueXml(XmlPullParser parser, String[] name)
+            throws XmlPullParserException, java.io.IOException {
+        int eventType = parser.getEventType();
+        do {
+            if (eventType == XmlPullParser.START_TAG) {
+                return readThisValueXml(parser, name, null);
+            } else if (eventType == XmlPullParser.END_TAG) {
+                throw new XmlPullParserException(
+                        "Unexpected end tag at: " + parser.getName());
+            } else if (eventType == XmlPullParser.TEXT) {
+                throw new XmlPullParserException(
+                        "Unexpected text: " + parser.getText());
+            }
+            eventType = parser.next();
+        } while (eventType != XmlPullParser.END_DOCUMENT);
+
+        throw new XmlPullParserException(
+                "Unexpected end of document");
+    }
+
+    private static Object readThisValueXml(XmlPullParser parser, String[] name,
+                                           ReadMapCallback callback)
+            throws XmlPullParserException, java.io.IOException {
+        final String valueName = parser.getAttributeValue(null, "name");
+        final String tagName = parser.getName();
+
+        //System.out.println("Reading this value tag: " + tagName + ", name=" + valueName);
+
+        Object res;
+
+        if (tagName.equals("null")) {
+            res = null;
+        } else if (tagName.equals("string")) {
+            String value = "";
+            int eventType;
+            while ((eventType = parser.next()) != XmlPullParser.END_DOCUMENT) {
+                if (eventType == XmlPullParser.END_TAG) {
+                    if (parser.getName().equals("string")) {
+                        name[0] = valueName;
+                        //System.out.println("Returning value for " + valueName + ": " + value);
+                        return value;
+                    }
+                    throw new XmlPullParserException(
+                            "Unexpected end tag in <string>: " + parser.getName());
+                } else if (eventType == XmlPullParser.TEXT) {
+                    value += parser.getText();
+                } else if (eventType == XmlPullParser.START_TAG) {
+                    throw new XmlPullParserException(
+                            "Unexpected start tag in <string>: " + parser.getName());
+                }
+            }
+            throw new XmlPullParserException(
+                    "Unexpected end of document in <string>");
+        } else //noinspection StatementWithEmptyBody
+            if ((res = readThisPrimitiveValueXml(parser, tagName)) != null) {
+                // all work already done by readThisPrimitiveValueXml
+            } else if (tagName.equals("int-array")) {
+                res = readThisIntArrayXml(parser, "int-array", name);
+                name[0] = valueName;
+                //System.out.println("Returning value for " + valueName + ": " + res);
+                return res;
+            } else if (tagName.equals("long-array")) {
+                res = readThisLongArrayXml(parser, "long-array", name);
+                name[0] = valueName;
+                //System.out.println("Returning value for " + valueName + ": " + res);
+                return res;
+            } else if (tagName.equals("double-array")) {
+                res = readThisDoubleArrayXml(parser, "double-array", name);
+                name[0] = valueName;
+                //System.out.println("Returning value for " + valueName + ": " + res);
+                return res;
+            } else if (tagName.equals("string-array")) {
+                res = readThisStringArrayXml(parser, "string-array", name);
+                name[0] = valueName;
+                //System.out.println("Returning value for " + valueName + ": " + res);
+                return res;
+            } else if (tagName.equals("map")) {
+                parser.next();
+                res = readThisMapXml(parser, "map", name);
+                name[0] = valueName;
+                //System.out.println("Returning value for " + valueName + ": " + res);
+                return res;
+            } else if (tagName.equals("list")) {
+                parser.next();
+                res = readThisListXml(parser, "list", name);
+                name[0] = valueName;
+                //System.out.println("Returning value for " + valueName + ": " + res);
+                return res;
+            } else if (tagName.equals("set")) {
+                parser.next();
+                res = readThisSetXml(parser, "set", name);
+                name[0] = valueName;
+                //System.out.println("Returning value for " + valueName + ": " + res);
+                return res;
+            } else if (callback != null) {
+                res = callback.readThisUnknownObjectXml(parser, tagName);
+                name[0] = valueName;
+                return res;
+            } else {
+                throw new XmlPullParserException("Unknown tag: " + tagName);
+            }
+
+        // Skip through to end tag.
+        int eventType;
+        while ((eventType = parser.next()) != XmlPullParser.END_DOCUMENT) {
+            if (eventType == XmlPullParser.END_TAG) {
+                if (parser.getName().equals(tagName)) {
+                    name[0] = valueName;
+                    //System.out.println("Returning value for " + valueName + ": " + res);
+                    return res;
+                }
+                throw new XmlPullParserException(
+                        "Unexpected end tag in <" + tagName + ">: " + parser.getName());
+            } else if (eventType == XmlPullParser.TEXT) {
+                throw new XmlPullParserException(
+                        "Unexpected text in <" + tagName + ">: " + parser.getName());
+            } else if (eventType == XmlPullParser.START_TAG) {
+                throw new XmlPullParserException(
+                        "Unexpected start tag in <" + tagName + ">: " + parser.getName());
+            }
+        }
+        throw new XmlPullParserException(
+                "Unexpected end of document in <" + tagName + ">");
+    }
+
+    private static Object readThisPrimitiveValueXml(XmlPullParser parser, String tagName)
+            throws XmlPullParserException {
+        try {
+            switch (tagName) {
+                case "int":
+                    return Integer.parseInt(parser.getAttributeValue(null, "value"));
+                case "long":
+                    return Long.valueOf(parser.getAttributeValue(null, "value"));
+                case "float":
+                    return Float.valueOf(parser.getAttributeValue(null, "value"));
+                case "double":
+                    return Double.valueOf(parser.getAttributeValue(null, "value"));
+                case "boolean":
+                    return Boolean.valueOf(parser.getAttributeValue(null, "value"));
+                default:
+                    return null;
+            }
+        } catch (NullPointerException e) {
+            throw new XmlPullParserException("Need value attribute in <" + tagName + ">");
+        } catch (NumberFormatException e) {
+            throw new XmlPullParserException(
+                    "Not a number in value attribute in <" + tagName + ">");
+        }
+    }
+
+    public static void beginDocument(XmlPullParser parser, String firstElementName)
+            throws XmlPullParserException, IOException {
+        int type;
+        //noinspection StatementWithEmptyBody
+        while ((type = parser.next()) != XmlPullParser.START_TAG
+                && type != XmlPullParser.END_DOCUMENT) ;
+
+        if (type != XmlPullParser.START_TAG) {
+            throw new XmlPullParserException("No start tag found");
+        }
+
+        if (!parser.getName().equals(firstElementName)) {
+            throw new XmlPullParserException("Unexpected start tag: found " + parser.getName() +
+                    ", expected " + firstElementName);
+        }
+    }
+
+    public static void nextElement(XmlPullParser parser) throws XmlPullParserException, IOException {
+        int type;
+        //noinspection StatementWithEmptyBody
+        while ((type = parser.next()) != XmlPullParser.START_TAG
+                && type != XmlPullParser.END_DOCUMENT) ;
+    }
+
+    public static boolean nextElementWithin(XmlPullParser parser, int outerDepth)
+            throws IOException, XmlPullParserException {
+        for (; ; ) {
+            int type = parser.next();
+            if (type == XmlPullParser.END_DOCUMENT
+                    || (type == XmlPullParser.END_TAG && parser.getDepth() == outerDepth)) {
+                return false;
+            }
+            if (type == XmlPullParser.START_TAG
+                    && parser.getDepth() == outerDepth + 1) {
+                return true;
+            }
+        }
+    }
+
+    public static int readIntAttribute(XmlPullParser in, String name, int defaultValue) {
+        final String value = in.getAttributeValue(null, name);
+        try {
+            return Integer.parseInt(value);
+        } catch (NumberFormatException e) {
+            return defaultValue;
+        }
+    }
+
+    public static int readIntAttribute(XmlPullParser in, String name) throws IOException {
+        final String value = in.getAttributeValue(null, name);
+        try {
+            return Integer.parseInt(value);
+        } catch (NumberFormatException e) {
+            throw new ProtocolException("problem parsing " + name + "=" + value + " as int");
+        }
+    }
+
+    public static void writeIntAttribute(XmlSerializer out, String name, int value)
+            throws IOException {
+        out.attribute(null, name, Integer.toString(value));
+    }
+
+    public static long readLongAttribute(XmlPullParser in, String name, long defaultValue) {
+        final String value = in.getAttributeValue(null, name);
+        try {
+            return Long.parseLong(value);
+        } catch (NumberFormatException e) {
+            return defaultValue;
+        }
+    }
+
+    public static long readLongAttribute(XmlPullParser in, String name) throws IOException {
+        final String value = in.getAttributeValue(null, name);
+        try {
+            return Long.parseLong(value);
+        } catch (NumberFormatException e) {
+            throw new ProtocolException("problem parsing " + name + "=" + value + " as long");
+        }
+    }
+
+    public static void writeLongAttribute(XmlSerializer out, String name, long value)
+            throws IOException {
+        out.attribute(null, name, Long.toString(value));
+    }
+
+    public static float readFloatAttribute(XmlPullParser in, String name) throws IOException {
+        final String value = in.getAttributeValue(null, name);
+        try {
+            return Float.parseFloat(value);
+        } catch (NumberFormatException e) {
+            throw new ProtocolException("problem parsing " + name + "=" + value + " as long");
+        }
+    }
+
+    public static void writeFloatAttribute(XmlSerializer out, String name, float value)
+            throws IOException {
+        out.attribute(null, name, Float.toString(value));
+    }
+
+    public static boolean readBooleanAttribute(XmlPullParser in, String name) {
+        final String value = in.getAttributeValue(null, name);
+        return Boolean.parseBoolean(value);
+    }
+
+    public static boolean readBooleanAttribute(XmlPullParser in, String name,
+                                               boolean defaultValue) {
+        final String value = in.getAttributeValue(null, name);
+        if (value == null) {
+            return defaultValue;
+        } else {
+            return Boolean.parseBoolean(value);
+        }
+    }
+
+    public static void writeBooleanAttribute(XmlSerializer out, String name, boolean value)
+            throws IOException {
+        out.attribute(null, name, Boolean.toString(value));
+    }
+
+    public static Uri readUriAttribute(XmlPullParser in, String name) {
+        final String value = in.getAttributeValue(null, name);
+        return (value != null) ? Uri.parse(value) : null;
+    }
+
+    public static void writeUriAttribute(XmlSerializer out, String name, Uri value)
+            throws IOException {
+        if (value != null) {
+            out.attribute(null, name, value.toString());
+        }
+    }
+
+    public static String readStringAttribute(XmlPullParser in, String name) {
+        return in.getAttributeValue(null, name);
+    }
+
+    public static void writeStringAttribute(XmlSerializer out, String name, String value)
+            throws IOException {
+        if (value != null) {
+            out.attribute(null, name, value);
+        }
+    }
+
+    public static byte[] readByteArrayAttribute(XmlPullParser in, String name) {
+        final String value = in.getAttributeValue(null, name);
+        if (value != null) {
+            return Base64.decode(value, Base64.DEFAULT);
+        } else {
+            return null;
+        }
+    }
+
+    public static void writeByteArrayAttribute(XmlSerializer out, String name, byte[] value)
+            throws IOException {
+        if (value != null) {
+            out.attribute(null, name, Base64.encodeToString(value, Base64.DEFAULT));
+        }
+    }
+
+    public static Bitmap readBitmapAttribute(XmlPullParser in, String name) {
+        final byte[] value = readByteArrayAttribute(in, name);
+        if (value != null) {
+            return BitmapFactory.decodeByteArray(value, 0, value.length);
+        } else {
+            return null;
+        }
+    }
+
+    @Deprecated
+    public static void writeBitmapAttribute(XmlSerializer out, String name, Bitmap value)
+            throws IOException {
+        if (value != null) {
+            final ByteArrayOutputStream os = new ByteArrayOutputStream();
+            value.compress(CompressFormat.PNG, 90, os);
+            writeByteArrayAttribute(out, name, os.toByteArray());
+        }
+    }
+
+    public interface WriteMapCallback {
+        /**
+         * Called from writeMapXml when an Object type is not recognized. The implementer
+         * must write out the entire element including start and end tags.
+         *
+         * @param v    The object to be written out
+         * @param name The mapping key for v. Must be written into the "name" attribute of the
+         *             start tag.
+         * @param out  The XML output stream.
+         * @throws XmlPullParserException on unrecognized Object type.
+         * @throws IOException            on XmlSerializer serialization errors.
+         */
+        public void writeUnknownObject(Object v, String name, XmlSerializer out)
+        ;
+    }
+
+    public interface ReadMapCallback {
+        /**
+         * Called from readThisMapXml when a START_TAG is not recognized. The input stream
+         * is positioned within the start tag so that attributes can be read using in.getAttribute.
+         *
+         * @param in  the XML input stream
+         * @param tag the START_TAG that was not recognized.
+         * @return the Object parsed from the stream which will be put into the map.
+         * @throws XmlPullParserException if the START_TAG is not recognized.
+         * @throws IOException            on XmlPullParser serialization errors.
+         */
+        public Object readThisUnknownObjectXml(XmlPullParser in, String tag)
+        ;
+    }
+
+}
\ No newline at end of file
diff --git a/project/app/src/main/java/com/achep/snake/ControllerView.java b/project/app/src/main/java/com/achep/snake/ControllerView.java
new file mode 100644
index 00000000..efc2518c
--- /dev/null
+++ b/project/app/src/main/java/com/achep/snake/ControllerView.java
@@ -0,0 +1,83 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.snake;
+
+import android.content.Context;
+import android.util.AttributeSet;
+import android.view.View;
+import android.widget.GridLayout;
+
+import com.achep.acdisplay.R;
+import com.achep.snake.snake.Animal;
+
+/**
+ * Created by Artem Chepurnoy on 25.11.2014.
+ */
+public class ControllerView extends GridLayout implements View.OnClickListener {
+
+    private IDirectionChangeListener mCallback;
+
+    private View mUpView;
+    private View mDownView;
+    private View mLeftView;
+    private View mRightView;
+
+    public ControllerView(Context context) {
+        super(context);
+    }
+
+    public ControllerView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    @Override
+    protected void onFinishInflate() {
+        super.onFinishInflate();
+
+        mUpView = findViewById(R.id.up);
+        mDownView = findViewById(R.id.down);
+        mLeftView = findViewById(R.id.left);
+        mRightView = findViewById(R.id.right);
+
+        mUpView.setOnClickListener(this);
+        mDownView.setOnClickListener(this);
+        mLeftView.setOnClickListener(this);
+        mRightView.setOnClickListener(this);
+    }
+
+    @Override
+    public void onClick(View v) {
+        if (mCallback == null) return;
+
+        if (v == mUpView) {
+            mCallback.onDirectionChange(Animal.DIRECTION_UP);
+        } else if (v == mDownView) {
+            mCallback.onDirectionChange(Animal.DIRECTION_DOWN);
+        } else if (v == mLeftView) {
+            mCallback.onDirectionChange(Animal.DIRECTION_LEFT);
+        } else if (v == mRightView) {
+            mCallback.onDirectionChange(Animal.DIRECTION_RIGHT);
+        }
+    }
+
+    public void setCallback(IDirectionChangeListener callback) {
+        mCallback = callback;
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/snake/GameView.java b/project/app/src/main/java/com/achep/snake/GameView.java
new file mode 100644
index 00000000..83e2a487
--- /dev/null
+++ b/project/app/src/main/java/com/achep/snake/GameView.java
@@ -0,0 +1,141 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.snake;
+
+import android.content.Context;
+import android.content.res.Resources;
+import android.graphics.Canvas;
+import android.support.annotation.NonNull;
+import android.util.AttributeSet;
+import android.view.MotionEvent;
+import android.view.View;
+
+import com.achep.acdisplay.R;
+import com.achep.snake.snake.Animal;
+import com.achep.snake.snake.GameObject;
+
+/**
+ * Created by Artem on 13.10.13.
+ */
+public class GameView extends View implements IDrawable {
+
+    private static final boolean SNAKE = false;
+
+    private Logic mLogic;
+    private IDirectionChangeListener mListener;
+
+    /**
+     * {@inheritDoc}
+     */
+    public GameView(Context context, AttributeSet attrs) {
+        super(context, attrs);
+    }
+
+    public void setLogic(Logic logic) {
+        Resources res = getResources();
+        mLogic = logic;
+        mLogic.getSurface().setDividerSize(res.getDimensionPixelSize(R.dimen.snake_divider_size));
+    }
+
+    public void setCallback(IDirectionChangeListener listener) {
+        mListener = listener;
+    }
+
+    @Override
+    public void onWindowFocusChanged(boolean hasWindowFocus) {
+        super.onWindowFocusChanged(hasWindowFocus);
+        if (hasWindowFocus) {
+            mLogic.resume();
+        } else {
+            mLogic.pause();
+        }
+    }
+
+    /*
+        Changes the direction of the snake on touch down.
+     */
+    @Override
+    public boolean onTouchEvent(@NonNull MotionEvent event) {
+        switch (event.getAction()) {
+            case MotionEvent.ACTION_DOWN:
+            case MotionEvent.ACTION_POINTER_DOWN:
+                byte direction;
+
+                float centerX;
+                float centerY;
+                if (SNAKE) {
+                    Surface surface = mLogic.getSurface();
+                    GameObject.Node head = mLogic.getSnake().getHead();
+                    centerX = surface.calculateRealX(head.x);
+                    centerY = surface.calculateRealY(head.y);
+                } else {
+                    centerX = getWidth() / 2;
+                    centerY = getHeight() / 2;
+                }
+
+                float deltaX = event.getX() - centerX;
+                float deltaY = event.getY() - centerY;
+                if (Math.abs(deltaX) > Math.abs(deltaY)) {
+                    direction = deltaX > 0
+                            ? Animal.DIRECTION_RIGHT
+                            : Animal.DIRECTION_LEFT;
+                } else {
+                    direction = deltaY > 0
+                            ? Animal.DIRECTION_DOWN
+                            : Animal.DIRECTION_UP;
+                }
+
+                if (mListener != null) {
+                    mListener.onDirectionChange(direction);
+                }
+                break;
+            default:
+                return super.onTouchEvent(event);
+        }
+        return true;
+    }
+
+    @Override
+    protected void onDraw(Canvas canvas) {
+        super.onDraw(canvas);
+
+        if (isInEditMode()) {
+            return;
+        }
+
+        mLogic.draw(canvas);
+    }
+
+    @Override
+    protected void onSizeChanged(int w, int h, int oldw, int oldh) {
+        super.onSizeChanged(w, h, oldw, oldh);
+
+        if (isInEditMode()) {
+            return;
+        }
+
+        mLogic.getSurface().setSize(w, h);
+    }
+
+    @Override
+    public void tweetRedrawCall() {
+        postInvalidate();
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/snake/IDirectionChangeListener.java b/project/app/src/main/java/com/achep/snake/IDirectionChangeListener.java
new file mode 100644
index 00000000..31ff91c5
--- /dev/null
+++ b/project/app/src/main/java/com/achep/snake/IDirectionChangeListener.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.snake;
+
+/**
+ * Created by Artem Chepurnoy on 27.11.2014.
+ */
+public interface IDirectionChangeListener {
+
+    void onDirectionChange(byte direction);
+
+}
diff --git a/project/app/src/main/java/com/achep/snake/IDrawable.java b/project/app/src/main/java/com/achep/snake/IDrawable.java
new file mode 100644
index 00000000..f88ddd24
--- /dev/null
+++ b/project/app/src/main/java/com/achep/snake/IDrawable.java
@@ -0,0 +1,28 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.snake;
+
+/**
+ * Created by Artem Chepurnoy on 28.11.2014.
+ */
+public interface IDrawable {
+
+    void tweetRedrawCall();
+
+}
diff --git a/project/app/src/main/java/com/achep/snake/Logic.java b/project/app/src/main/java/com/achep/snake/Logic.java
new file mode 100644
index 00000000..421404bf
--- /dev/null
+++ b/project/app/src/main/java/com/achep/snake/Logic.java
@@ -0,0 +1,316 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.snake;
+
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.os.Handler;
+import android.os.Message;
+import android.util.Log;
+
+import com.achep.snake.snake.Apple;
+import com.achep.snake.snake.Brick;
+import com.achep.snake.snake.ColorScheme;
+import com.achep.snake.snake.GameObject;
+import com.achep.snake.snake.Snake;
+
+import java.util.ArrayList;
+import java.util.Arrays;
+
+/**
+ * Created by Artem Chepurnoy on 23.11.2014.
+ */
+public class Logic implements
+        IDirectionChangeListener,
+        IDrawable {
+
+    private static final String TAG = "Logic";
+    private static final int TICK = 1;
+    private static final double PERIOD_MAX = 400;
+
+    private static int COLLISION_MAP_DEPTH = 5;
+
+    private static GameObject.Node sEmptyNode;
+
+    private ArrayList<GameObject.Node> mCollisionNodes;
+    private GameObject.Node[][][] mCollisionMap;
+    private int[] mTempArray = new int[2];
+
+    private final IDrawable mDrawable;
+    private final Surface mSurface;
+    private final int mColumnsNumber;
+    private final int mRowsNumber;
+    private int mScoreMax;
+    private Paint mPaint;
+
+    private final Snake mSnake;
+    private final Apple mApple;
+    private final Brick[] mBricks;
+
+    private final Handler mHandler = new Handler() {
+
+        @Override
+        public void handleMessage(Message msg) {
+            super.handleMessage(msg);
+            switch (msg.what) {
+                case TICK:
+                    begin();
+                    apply();
+
+                    sendEmptyMessageDelayed(TICK, getFramePeriod());
+                    break;
+            }
+        }
+
+    };
+
+    public Logic(IDrawable drawable, int n, int m, ColorScheme... colorSchemes) {
+        mColumnsNumber = n;
+        mRowsNumber = m;
+        mDrawable = drawable;
+
+        mSurface = new Surface(this);
+        mPaint = new Paint();
+        mPaint.setColor(0xFF555555);
+
+        // Initialize map.
+        mCollisionMap = new GameObject.Node[n][m][COLLISION_MAP_DEPTH];
+        mCollisionNodes = new ArrayList<>();
+
+        if (sEmptyNode == null)
+            sEmptyNode = new GameObject.Node(null);
+
+        // Init snake.
+        GameObject.Node node = new GameObject.Node(this, true);
+        node.move(n / 2, m / 2);
+        mSnake = new Snake(this);
+        mSnake.setHead(node);
+        mSnake.setColorScheme(colorSchemes[0]);
+
+        // Init apple.
+        mApple = new Apple(this);
+        mApple.setColorScheme(colorSchemes[1]);
+        mApple.getHead().move(generateRandomPosition());
+
+        // Init unbeatable bricks.
+        int length = (int) (Math.sqrt(n * m) / 2);
+        mBricks = new Brick[length];
+        for (int i = 0; i < length; i++) {
+            Brick brick = new Brick(this);
+            brick.getHead().move(generateRandomPosition());
+            brick.setColorScheme(colorSchemes[2]);
+            mBricks[i] = brick;
+        }
+    }
+
+    private int[] generateRandomPosition() {
+        int x, y;
+        do { // Pick new position
+            x = (int) (Math.random() * mColumnsNumber);
+            y = (int) (Math.random() * mRowsNumber);
+        } while (mCollisionMap[x][y][0] != null /* then it's free */);
+        mTempArray[0] = x;
+        mTempArray[1] = y;
+        return mTempArray;
+    }
+
+    /**
+     * Changes the direction of the snake to given one.
+     *
+     * @param direction one of the following
+     *                  {@link com.achep.snake.snake.Animal#DIRECTION_NONE} to not move,
+     *                  {@link com.achep.snake.snake.Animal#DIRECTION_LEFT} to move left,
+     *                  {@link com.achep.snake.snake.Animal#DIRECTION_RIGHT} to move right,
+     *                  {@link com.achep.snake.snake.Animal#DIRECTION_UP} to move up,
+     *                  {@link com.achep.snake.snake.Animal#DIRECTION_DOWN} to move down.
+     */
+    @Override
+    public void onDirectionChange(byte direction) {
+        mSnake.setDirection(direction);
+    }
+
+    /**
+     * {@inheritDoc}
+     */
+    @Override
+    public void tweetRedrawCall() {
+        mDrawable.tweetRedrawCall();
+    }
+
+    /**
+     *
+     */
+    public void resume() {
+        mHandler.sendEmptyMessage(TICK);
+    }
+
+    /**
+     *
+     */
+    public void pause() {
+        mHandler.removeMessages(TICK);
+    }
+
+    public void draw(Canvas canvas) {
+        canvas.drawRect(
+                mSurface.getPaddingLeft(),
+                mSurface.getPaddingTop(),
+                mSurface.getPaddingLeft() + mSurface.getWidth(),
+                mSurface.getPaddingTop() + mSurface.getHeight(), mPaint);
+
+        mSnake.draw(canvas);
+        mApple.draw(canvas);
+        for (Brick brick : mBricks) brick.draw(canvas);
+    }
+
+    public void begin() {
+        mSnake.tick();
+        mApple.tick();
+        for (Brick brick : mBricks) brick.tick();
+    }
+
+    public void commitMove(GameObject.Node node, int oldX, int oldY) {
+        mCollisionNodes.add(node);
+        int x = node.xp;
+        int y = node.yp;
+
+        for (int i = 0; i < COLLISION_MAP_DEPTH; i++) {
+            GameObject.Node[] stack = mCollisionMap[oldX][oldY];
+
+            if (stack[i] == node) {
+                int start = i + 1;
+                System.arraycopy(stack, start, stack, start - 1, COLLISION_MAP_DEPTH - start);
+                stack[COLLISION_MAP_DEPTH - 1] = null;
+                break;
+            }
+        }
+
+        for (int i = 0; i < COLLISION_MAP_DEPTH; i++) {
+            if (mCollisionMap[x][y][i] == null) {
+                mCollisionMap[x][y][i] = node;
+                break;
+            }
+        }
+    }
+
+    public void apply() {
+        for (GameObject.Node node : mCollisionNodes) {
+            GameObject.Node[] stack = mCollisionMap[node.xp][node.yp];
+
+            if (stack[0] == sEmptyNode) {
+                continue;
+            }
+
+            // Count the number of predators.
+            int predatorsCount = 0;
+            GameObject.Node predator = null;
+            for (GameObject.Node n : stack) {
+                if (n == null) break;
+                if (n.isPredator()) {
+                    predator = n;
+                    predatorsCount++;
+                }
+            }
+
+            // Handle the collision.
+            if (predator != null) {
+                GameObject.Node predatorInit = null;
+                if (predatorsCount > 0) {
+                    predatorInit = predator.getInitNode();
+                }
+
+                for (GameObject.Node n : stack) {
+                    if (n == null) break;
+                    if (predatorsCount > 1) {
+                        n.kill();
+                    } else if (n != predator) {
+                        if (n.getInitNode() != predatorInit) {
+                            Log.d(TAG, "Reparenting node.");
+                            predator.getFinalNode().reparent(n);
+                        } else {
+                            Log.d(TAG, "Killing node." + predatorInit);
+                            n.kill();
+                        }
+                    }
+                }
+            } else if (stack[1] != null) {
+                Log.i(TAG, "Collision between non-predators happened!");
+            }
+
+            // Clean collision map.
+            stack[0] = sEmptyNode;
+        }
+        mCollisionNodes.clear();
+
+        // Generate new stuff.
+        if (!mApple.hasHead()) {
+
+            // Put new apple on map.
+            GameObject.Node node = new GameObject.Node(this);
+            node.move(generateRandomPosition());
+            mApple.setHead(node);
+        }
+
+        // Clean-up collision map.
+        for (GameObject.Node[][] n : mCollisionMap) {
+            for (GameObject.Node[] m : n) {
+                Arrays.fill(m, null);
+            }
+        }
+
+        // Max score.
+        int score = mSnake.getSize();
+        mScoreMax = Math.max(mScoreMax, score);
+    }
+
+    /**
+     * Defines the speed of the game.
+     *
+     * @return the time in millis between two frames and
+     * {@link com.achep.snake.snake.GameObject#tick() moves}.
+     * @see #mScoreMax
+     * @see #PERIOD_MAX
+     */
+    private long getFramePeriod() {
+        double scoreMaxPossible = mColumnsNumber * mRowsNumber * 1 / 3;
+        double score = Math.min(mScoreMax, scoreMaxPossible);
+        return Math.round(PERIOD_MAX * (1 - score / scoreMaxPossible));
+    }
+
+    public int getScore() {
+        return mSnake.getSize();
+    }
+
+    public Snake getSnake() {
+        return mSnake;
+    }
+
+    public Surface getSurface() {
+        return mSurface;
+    }
+
+    public int getColumnsNumber() {
+        return mColumnsNumber;
+    }
+
+    public int getRowsNumber() {
+        return mRowsNumber;
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/snake/MainActivity.java b/project/app/src/main/java/com/achep/snake/MainActivity.java
new file mode 100644
index 00000000..74589d17
--- /dev/null
+++ b/project/app/src/main/java/com/achep/snake/MainActivity.java
@@ -0,0 +1,170 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.snake;
+
+import android.animation.Animator;
+import android.animation.AnimatorInflater;
+import android.app.AlertDialog;
+import android.content.DialogInterface;
+import android.os.Bundle;
+import android.support.annotation.NonNull;
+import android.support.v7.app.ActionBarActivity;
+import android.view.KeyEvent;
+import android.view.View;
+import android.view.ViewGroup;
+
+import com.achep.acdisplay.R;
+import com.achep.base.Device;
+import com.achep.base.ui.widgets.TextView;
+import com.achep.snake.snake.Animal;
+import com.achep.snake.snake.ColorScheme;
+import com.achep.snake.snake.GameObject;
+
+
+public class MainActivity extends ActionBarActivity implements
+        GameObject.OnGameObjectChangedListener {
+
+    private Logic mLogic;
+
+    private TextView mScoreTextView;
+    private Animator mScorePulseAnimation;
+
+    @Override
+    public void onWindowFocusChanged(boolean hasFocus) {
+        super.onWindowFocusChanged(hasFocus);
+        if (hasFocus) {
+            int visibilityUi = View.SYSTEM_UI_FLAG_LAYOUT_STABLE
+                    | View.SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION
+                    | View.SYSTEM_UI_FLAG_LOW_PROFILE
+                    | View.SYSTEM_UI_FLAG_LAYOUT_FULLSCREEN
+                    | View.SYSTEM_UI_FLAG_FULLSCREEN;
+
+            if (Device.hasKitKatApi()) {
+                // Hide navigation bar and flag sticky.
+                visibilityUi = visibilityUi
+                        | View.SYSTEM_UI_FLAG_IMMERSIVE_STICKY
+                        | View.SYSTEM_UI_FLAG_HIDE_NAVIGATION;
+            }
+
+            getWindow().getDecorView().setSystemUiVisibility(visibilityUi);
+        }
+    }
+
+    @Override
+    protected void onCreate(Bundle savedInstanceState) {
+        super.onCreate(savedInstanceState);
+        setContentView(R.layout.snake_fragment);
+
+        GameView gameView = (GameView) findViewById(R.id.game_view);
+        mLogic = new Logic(gameView, 12, 16,
+                new ColorScheme(0xFF03A9F4, 0xFF0277BD), // Snake
+                new ColorScheme(0xFF8BC34A, 0xFF558B2F), // Apple
+                new ColorScheme(0xFFF44336, 0xFFC62828) // Bricks
+        );
+        gameView.setLogic(mLogic);
+
+        ViewGroup scorePanel = (ViewGroup) findViewById(R.id.score_panel);
+        mScoreTextView = (TextView) scorePanel.findViewById(R.id.score);
+        ControllerView controller = (ControllerView) findViewById(R.id.game_controller);
+        controller.setCallback(mLogic);
+
+        mScorePulseAnimation = AnimatorInflater.loadAnimator(
+                this, R.animator.pulse);
+        mScorePulseAnimation.setTarget(scorePanel);
+    }
+
+    @Override
+    protected void onResume() {
+        super.onResume();
+        mLogic.getSnake().registerListener(this);
+        updateScoreTextView();
+    }
+
+    @Override
+    protected void onPause() {
+        mLogic.getSnake().unregisterListener(this);
+        mScorePulseAnimation.end();
+        super.onPause();
+    }
+
+    private void updateScoreTextView() {
+        int score = mLogic.getScore();
+        mScoreTextView.setText(String.valueOf(score));
+        mScorePulseAnimation.start();
+    }
+
+    @Override
+    public void onGameObjectChanged(GameObject object, int action) {
+        if (object == mLogic.getSnake()) {
+            switch (action) {
+                case GameObject.ACTION_SIZE_CHANGED:
+                    if (mLogic.getScore() == 0) {
+                        new AlertDialog.Builder(MainActivity.this)
+                                .setTitle("Game over.")
+                                .setOnDismissListener(new DialogInterface.OnDismissListener() {
+                                    @Override
+                                    public void onDismiss(DialogInterface dialog) {
+                                        finish();
+                                    }
+                                })
+                                .setPositiveButton("OK",
+                                        new DialogInterface.OnClickListener() {
+                                            @Override
+                                            public void onClick(DialogInterface dialog, int which) {
+                                                finish();
+                                            }
+                                        })
+                                .create()
+                                .show();
+                    }
+                    updateScoreTextView();
+                    break;
+            }
+        }
+    }
+
+    @Override
+    public boolean onKeyDown(int keyCode, @NonNull KeyEvent event) {
+        byte direction;
+        switch (event.getKeyCode()) {
+            case KeyEvent.KEYCODE_DPAD_DOWN:
+            case KeyEvent.KEYCODE_NUMPAD_2:
+                direction = Animal.DIRECTION_DOWN;
+                break;
+            case KeyEvent.KEYCODE_DPAD_UP:
+            case KeyEvent.KEYCODE_NUMPAD_8:
+                direction = Animal.DIRECTION_UP;
+                break;
+            case KeyEvent.KEYCODE_DPAD_RIGHT:
+            case KeyEvent.KEYCODE_NUMPAD_6:
+                direction = Animal.DIRECTION_RIGHT;
+                break;
+            case KeyEvent.KEYCODE_DPAD_LEFT:
+            case KeyEvent.KEYCODE_NUMPAD_4:
+                direction = Animal.DIRECTION_LEFT;
+                break;
+            default:
+                return super.onKeyDown(keyCode, event);
+        }
+
+        mLogic.onDirectionChange(direction);
+        return true;
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/snake/Surface.java b/project/app/src/main/java/com/achep/snake/Surface.java
new file mode 100644
index 00000000..52e78f9d
--- /dev/null
+++ b/project/app/src/main/java/com/achep/snake/Surface.java
@@ -0,0 +1,102 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.snake;
+
+/**
+ * Created by Artem Chepurnoy on 05.11.2014.
+ */
+public class Surface {
+
+    private int mWidth;
+    private int mHeight;
+    private int mPaddingLeft;
+    private int mPaddingTop;
+    private int mDividerSize;
+
+    private int mCeil = 15;
+    private int mCeilWidth;
+    private int mCeilHeight;
+
+    private final Logic mLogic;
+    private int mSize;
+
+    public Surface(Logic logic) {
+        mLogic = logic;
+    }
+
+    public int calculateRealX(float x) {
+        return mPaddingLeft + (int) (x * mSize) + (int) x * mDividerSize;
+    }
+
+    public int calculateRealY(float y) {
+        return mPaddingTop + (int) (y * mSize) + (int) y * mDividerSize;
+    }
+
+    public interface OnSurfaceChangedListener {
+
+        void onSurfaceSizeChanged(int n, int m);
+
+    }
+
+    public void registerListener(OnSurfaceChangedListener listener) {
+
+    }
+
+    public void unregisterListener(OnSurfaceChangedListener listener) {
+
+    }
+
+    public void setDividerSize(int dividerSize) {
+        mDividerSize = dividerSize;
+    }
+
+    public void setSize(int width, int height) {
+        int dw = -mDividerSize * (mLogic.getColumnsNumber() - 1);
+        int dh = -mDividerSize * (mLogic.getRowsNumber() - 1);
+        int cw = (width + dw) / mLogic.getColumnsNumber();
+        int ch = (height + dh) / mLogic.getRowsNumber();
+
+        mSize = Math.min(cw, ch);
+        mWidth = (mSize + mDividerSize) * mLogic.getColumnsNumber();
+        mHeight = (mSize + mDividerSize) * mLogic.getRowsNumber();
+        mPaddingLeft = (width - mWidth) / 2;
+        mPaddingTop = (height - mHeight) / 2;
+    }
+
+    public int getPaddingLeft() {
+        return mPaddingLeft;
+    }
+
+    public int getPaddingTop() {
+        return mPaddingTop;
+    }
+
+    public int getSize() {
+        return mSize;
+    }
+
+    public int getWidth() {
+        return mWidth;
+    }
+
+    public int getHeight() {
+        return mHeight;
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/snake/snake/Animal.java b/project/app/src/main/java/com/achep/snake/snake/Animal.java
new file mode 100644
index 00000000..410b2733
--- /dev/null
+++ b/project/app/src/main/java/com/achep/snake/snake/Animal.java
@@ -0,0 +1,104 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.snake.snake;
+
+import android.util.Log;
+
+import com.achep.snake.Logic;
+
+/**
+ * Created by Artem Chepurnoy on 18.11.2014.
+ */
+public class Animal extends GameObject {
+
+    private static final String TAG = "Animal";
+
+    public static final byte DIRECTION_NONE = -1;
+    public static final byte DIRECTION_LEFT = 0;
+    public static final byte DIRECTION_RIGHT = 1;
+    public static final byte DIRECTION_DOWN = 2;
+    public static final byte DIRECTION_UP = 3;
+
+    private static final int[][] DIRECTION_RULE = {
+            {-1, 0},
+            {1, 0},
+            {0, 1},
+            {0, -1},
+    };
+
+    private byte mDirection = DIRECTION_NONE;
+
+    public Animal(Logic logic) {
+        super(logic);
+    }
+
+    private int applyDirectionX(byte direction, int x) {
+        x = x + DIRECTION_RULE[direction][0];
+        x = x < 0
+                ? mLogic.getColumnsNumber() - 1
+                : x >= mLogic.getColumnsNumber() ? 0 : x;
+        return x;
+    }
+
+    private int applyDirectionY(byte direction, int y) {
+        y = y + DIRECTION_RULE[direction][1];
+        y = y < 0
+                ? mLogic.getRowsNumber() - 1
+                : y >= mLogic.getRowsNumber() ? 0 : y;
+        return y;
+    }
+
+    public void setDirection(byte direction) {
+        if (getHead() == null) return;
+
+        switch (direction) {
+            case DIRECTION_DOWN:
+            case DIRECTION_UP:
+            case DIRECTION_LEFT:
+            case DIRECTION_RIGHT:
+                Node child = getHead().child;
+                if (child != null) {
+                    int x = applyDirectionX(direction, getHead().xp);
+                    int y = applyDirectionY(direction, getHead().yp);
+                    if (x == child.xp && y == child.yp) {
+                        Log.d(TAG, "Ignoring reverting direction.");
+                        return;
+                    }
+                }
+            case DIRECTION_NONE:
+                break;
+            default:
+                throw new IllegalArgumentException("Trying to set an unknown direction.");
+        }
+
+        mDirection = direction;
+        Log.d(TAG, "Setting direction to " + direction);
+    }
+
+    public void tick() {
+        if (getHead() == null) return;
+        if (mDirection != DIRECTION_NONE) {
+            int x = applyDirectionX(mDirection, getHead().xp);
+            int y = applyDirectionY(mDirection, getHead().yp);
+            getHead().move(x, y);
+            // Log.d(TAG, "Tick x=" + getHead().x + " y=" + getHead().y);
+        }
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/snake/snake/Apple.java b/project/app/src/main/java/com/achep/snake/snake/Apple.java
new file mode 100644
index 00000000..a211f8b4
--- /dev/null
+++ b/project/app/src/main/java/com/achep/snake/snake/Apple.java
@@ -0,0 +1,61 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.snake.snake;
+
+import android.graphics.Paint;
+
+import com.achep.snake.Logic;
+
+/**
+ * Created by Artem Chepurnoy on 23.11.2014.
+ */
+public class Apple extends GameObject {
+
+    private final Paint mPaint;
+
+    public Apple(Logic logic) {
+        super(logic);
+        setHead(new Node(logic));
+
+        mPaint = new Paint();
+        mPaint.setAntiAlias(true);
+        mPaint.setStyle(Paint.Style.FILL);
+        mPaint.setColor(0xFF4CAF50);
+    }
+
+    @Override
+    public void tick() {
+        getHead().move(getHead().xp, getHead().yp);
+    }
+
+   /*@Override
+    public void draw(Canvas canvas) {
+        Surface surface = mLogic.getSurface();
+        int size = surface.getSize();
+
+        Node node = getHead();
+        do {
+            int x = surface.calculateRealX(node.x);
+            int y = surface.calculateRealY(node.y);
+            canvas.drawRect(x, y, x + size, y + size, mPaint);
+            node = node.child;
+        } while (node != null);
+    }*/
+
+}
diff --git a/project/app/src/main/java/com/achep/snake/snake/Brick.java b/project/app/src/main/java/com/achep/snake/snake/Brick.java
new file mode 100644
index 00000000..8f47a827
--- /dev/null
+++ b/project/app/src/main/java/com/achep/snake/snake/Brick.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.snake.snake;
+
+import android.support.annotation.NonNull;
+
+import com.achep.snake.Logic;
+
+/**
+ * Created by Artem Chepurnoy on 30.11.2014.
+ */
+public class Brick extends GameObject {
+
+    public Brick(Logic logic) {
+        super(logic);
+        setHead(new UnbeatableNode(logic, true));
+    }
+
+    @Override
+    public void tick() {
+        getHead().move(getHead().xp, getHead().yp);
+    }
+
+    @Override
+    public void setHead(@NonNull Node node) {
+        if (mNode != null) {
+            throw new RuntimeException("You can not kill The Chosen One.");
+        }
+        super.setHead(node);
+    }
+
+    @NonNull
+    @Override
+    public Node getHead() {
+        assert super.getHead() != null;
+        return super.getHead();
+    }
+
+    @Override
+    void detachHead(Node node) {
+        throw new RuntimeException("You can not kill The Chosen One.");
+    }
+
+    private static class UnbeatableNode extends Node {
+
+        public UnbeatableNode(@NonNull Logic logic) {
+            super(logic);
+        }
+
+        public UnbeatableNode(@NonNull Logic logic, boolean isPredator) {
+            super(logic, isPredator);
+        }
+
+        @Override
+        public void kill() { /* do not die. */ }
+
+        @Override
+        public boolean isUnbeatable() {
+            return true;
+        }
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/snake/snake/ColorScheme.java b/project/app/src/main/java/com/achep/snake/snake/ColorScheme.java
new file mode 100644
index 00000000..a75330d1
--- /dev/null
+++ b/project/app/src/main/java/com/achep/snake/snake/ColorScheme.java
@@ -0,0 +1,34 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.snake.snake;
+
+/**
+ * Created by Artem Chepurnoy on 30.11.2014.
+ */
+public class ColorScheme {
+
+    public int colorPrimary;
+    public int colorSecondary;
+
+    public ColorScheme(int colorPrimary, int colorSecondary) {
+        this.colorPrimary = colorPrimary;
+        this.colorSecondary = colorSecondary;
+    }
+
+}
diff --git a/project/app/src/main/java/com/achep/snake/snake/GameObject.java b/project/app/src/main/java/com/achep/snake/snake/GameObject.java
new file mode 100644
index 00000000..032ea069
--- /dev/null
+++ b/project/app/src/main/java/com/achep/snake/snake/GameObject.java
@@ -0,0 +1,400 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.snake.snake;
+
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.ColorFilter;
+import android.graphics.Paint;
+import android.graphics.drawable.Drawable;
+import android.support.annotation.NonNull;
+import android.support.annotation.Nullable;
+import android.util.Log;
+
+import com.achep.base.Build;
+import com.achep.snake.Logic;
+import com.achep.snake.Surface;
+
+import java.lang.ref.WeakReference;
+import java.util.ArrayList;
+
+/**
+ * @author Artem Chepurnoy
+ */
+public abstract class GameObject {
+
+    private static final String TAG = "GameObject";
+    private static final boolean DEBUG = Build.DEBUG && true;
+
+    public static final int ACTION_SIZE_CHANGED = 0;
+    public static final int ACTION_KILLED = 1;
+
+    protected final Logic mLogic;
+    protected ColorScheme mColorScheme;
+    protected Node mNode;
+
+    private ArrayList<WeakReference<OnGameObjectChangedListener>> mListenersRefs;
+
+    public interface OnGameObjectChangedListener {
+        void onGameObjectChanged(GameObject object, int action);
+    }
+
+    /**
+     * Adds new {@link java.lang.ref.WeakReference weak} listener to the object. Make sure you call
+     * {@link #unregisterListener(OnGameObjectChangedListener)} later!
+     *
+     * @param listener a listener to register to config changes.
+     * @see #unregisterListener(OnGameObjectChangedListener)
+     */
+    public void registerListener(@NonNull OnGameObjectChangedListener listener) {
+        // Make sure to register listener only once.
+        for (WeakReference<OnGameObjectChangedListener> ref : mListenersRefs) {
+            if (ref.get() == listener) {
+                Log.w(TAG, "Tried to register already registered listener!");
+                return;
+            }
+        }
+
+        mListenersRefs.add(new WeakReference<>(listener));
+    }
+
+    /**
+     * Un-registers listener is there's one.
+     *
+     * @param listener a listener to unregister from object's changes.
+     * @see #registerListener(OnGameObjectChangedListener)
+     */
+    public void unregisterListener(@NonNull OnGameObjectChangedListener listener) {
+        for (WeakReference<OnGameObjectChangedListener> ref : mListenersRefs) {
+            if (ref.get() == listener) {
+                mListenersRefs.remove(ref);
+                return;
+            }
+        }
+
+        Log.w(TAG, "Tried to unregister non-existent listener!");
+    }
+
+    private void notifyGameObjectChanged(int action) {
+        for (int i = mListenersRefs.size() - 1; i >= 0; i--) {
+            WeakReference<OnGameObjectChangedListener> ref = mListenersRefs.get(i);
+            OnGameObjectChangedListener l = ref.get();
+
+            if (l == null) {
+                // There were no links to this listener except
+                // our class.
+                Log.w(TAG, "Deleting unused listener!");
+                mListenersRefs.remove(i);
+            } else {
+                l.onGameObjectChanged(this, action);
+            }
+        }
+    }
+
+    public GameObject(Logic logic) {
+        mLogic = logic;
+        mListenersRefs = new ArrayList<>(3);
+    }
+
+    public void setColorScheme(@NonNull ColorScheme colorScheme) {
+        mColorScheme = colorScheme;
+        updateColors();
+    }
+
+    public abstract void tick();
+
+    public void draw(Canvas canvas) {
+        Node node = getHead();
+        while (node != null) {
+            node.draw(canvas);
+            node = node.child;
+        }
+    }
+
+    protected void onSizeChanged() {
+        notifyGameObjectChanged(ACTION_SIZE_CHANGED);
+    }
+
+    /**
+     * Sets the new head of this object.
+     *
+     * @see #getHead()
+     */
+    public void setHead(@NonNull Node node) {
+        mNode = node;
+        mNode.owner = this;
+        mNode.color = getColor(node);
+    }
+
+    /**
+     * @return the main {@link Node node} of this object, or
+     * {@code null} if this object is dead.
+     * @see #setHead(Node)
+     */
+    @Nullable
+    public Node getHead() {
+        return mNode;
+    }
+
+    public boolean hasHead() {
+        return mNode != null;
+    }
+
+    /**
+     * @see #getHead()
+     * @see #setHead(Node)
+     */
+    void detachHead(Node node) {
+        if (node == mNode) {
+            if (DEBUG) Log.d(TAG, "Detaching head of " + this);
+            mNode = null;
+
+            notifyGameObjectChanged(ACTION_KILLED);
+        }
+    }
+
+    int getColor(Node node) {
+        if (mColorScheme == null) return Color.RED;
+        return node.isHeadNode()
+                ? mColorScheme.colorPrimary
+                : mColorScheme.colorSecondary;
+    }
+
+    void updateColors() {
+        Node node = getHead();
+        while (node != null) {
+            node.color = getColor(node);
+            node = node.child;
+        }
+    }
+
+    public int getSize() {
+        Node head = getHead();
+        return head == null ? 0 : head.getChildCount() + 1;
+    }
+
+    /**
+     * Main component of the Snake game. The node is inside of apples
+     * or snakes or anything and itself node is a two-side-linked list.
+     *
+     * @author Artem Chepurnoy
+     */
+    public static class Node extends Drawable {
+
+        private static final String LOG = "GameObject.Node";
+
+        private final Logic mLogic;
+        private final Paint mPaint;
+        private int color;
+
+        public float x;
+        public float y;
+
+        public int xp; // Never change it directly!
+        public int yp; // Never change it directly!
+
+        public GameObject owner;
+        public Node child;
+        public Node parent;
+
+        public boolean isMeal;
+        public boolean isPredator;
+
+        public Node(@NonNull Logic logic) {
+            this(logic, false);
+        }
+
+        public Node(@NonNull Logic logic, boolean isPredator) {
+            mLogic = logic;
+            this.isMeal = !isPredator;
+            this.isPredator = isPredator;
+
+            mPaint = new Paint();
+            mPaint.setAntiAlias(true);
+            mPaint.setColor(Color.RED);
+        }
+
+        public void move(int[] pos) {
+            move(pos[0], pos[1]);
+        }
+
+        /**
+         * Moves this node and all its children.
+         *
+         * @param xp absolute {@code x} coordinate
+         * @param yp absolute {@code y} coordinate
+         */
+        public void move(int xp, int yp) {
+            if (child != null) {
+                child.move(this.xp, this.yp);
+            }
+
+            int oldX = this.xp;
+            int oldY = this.yp;
+            this.xp = xp;
+            this.yp = yp;
+            performMove(xp, yp);
+
+            // Please note, that this is called
+            // after Logic#begin()
+            mLogic.commitMove(this, oldX, oldY);
+        }
+
+        private void performMove(float x, float y) {
+            this.x = x;
+            this.y = y;
+            mLogic.tweetRedrawCall();
+        }
+
+        public void kill() {
+            if (parent != null) {
+                parent.child = null;
+                parent = null;
+            }
+
+            if (owner != null) {
+                owner.detachHead(this);
+                owner.onSizeChanged();
+                owner = null;
+            }
+        }
+
+        @SuppressWarnings("ConstantConditions")
+        public void reparent(@NonNull Node node) {
+            node.kill(); // Detach from any owner.
+
+            GameObject.Node parent = this;
+            parent.owner.onSizeChanged();
+            parent.child = node;
+            node.parent = parent;
+
+            do {
+                node.x = parent.x;
+                node.y = parent.y;
+                node.owner = parent.owner;
+                node.isMeal = parent.isMeal;
+                node.isPredator = false; // By design only init node may be a predator
+                node = node.child;
+            } while (node != null);
+
+            // Recalculate all colors.
+            owner.updateColors();
+        }
+
+        /**
+         * @return the count of children of this node.
+         */
+        public int getChildCount() {
+            int n = 0;
+
+            Node node = child;
+            while (node != null) {
+                node = node.child;
+                n++;
+            }
+            return n;
+        }
+
+        /**
+         * @return the latest linked node.
+         * @see #getInitNode()
+         */
+        @NonNull
+        public GameObject.Node getFinalNode() {
+            GameObject.Node node = this;
+            while (node.child != null) node = node.child;
+            return node;
+        }
+
+        /**
+         * @return the first node in the sequence
+         * @see #getFinalNode()
+         */
+        @NonNull
+        public GameObject.Node getInitNode() {
+            GameObject.Node node = this;
+            while (node.parent != null) node = node.parent;
+            return node;
+        }
+
+        /**
+         * @return {@code true} if the node is hungry and able to eat other nodes
+         * by {@link #reparent(com.achep.snake.snake.GameObject.Node) reparenting}
+         * or simple {@link #kill() killing}.
+         * @see com.achep.snake.snake.GameObject
+         * @see com.achep.snake.snake.Animal
+         * @see com.achep.snake.Logic
+         * @see #isMeal()
+         */
+        public boolean isPredator() {
+            return isPredator;
+        }
+
+        /**
+         * Defines if the node can be
+         * {@link #reparent(com.achep.snake.snake.GameObject.Node) eated}
+         * or no.
+         */
+        public boolean isMeal() {
+            return isMeal;
+        }
+
+        public boolean isUnbeatable() {
+            return false;
+        }
+
+        public boolean isInitNode() {
+            return this == getInitNode();
+        }
+
+        public boolean isHeadNode() {
+            return owner != null && owner.getHead() == this;
+        }
+
+        //-- DRAWABLE INTERFACE ---------------------------------------------------
+
+        @Override
+        public void draw(Canvas canvas) {
+            Surface surface = mLogic.getSurface();
+            int size = surface.getSize();
+
+            int x = surface.calculateRealX(this.x);
+            int y = surface.calculateRealY(this.y);
+
+            mPaint.setColor(color);
+            canvas.drawRect(x, y, x + size, y + size, mPaint);
+        }
+
+        @Override
+        public void setAlpha(int alpha) {
+            mPaint.setAlpha(alpha);
+        }
+
+        @Override
+        public void setColorFilter(ColorFilter cf) {
+            mPaint.setColorFilter(cf);
+        }
+
+        @Override
+        public int getOpacity() {
+            return mPaint.getAlpha();
+        }
+
+    }
+}
diff --git a/project/app/src/main/java/com/achep/snake/snake/Snake.java b/project/app/src/main/java/com/achep/snake/snake/Snake.java
new file mode 100644
index 00000000..f988b022
--- /dev/null
+++ b/project/app/src/main/java/com/achep/snake/snake/Snake.java
@@ -0,0 +1,79 @@
+/*
+ * Copyright (C) 2014 AChep@xda <artemchep@gmail.com>
+ *
+ * This program is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU General Public License
+ * as published by the Free Software Foundation; either version 2
+ * of the License, or (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
+ * MA  02110-1301, USA.
+ */
+package com.achep.snake.snake;
+
+import android.graphics.Color;
+import android.graphics.Paint;
+
+import com.achep.snake.Logic;
+
+/**
+ * Created by Artem Chepurnoy on 05.11.2014.
+ */
+public class Snake extends Animal {
+
+    private static final int COLOR_BG = 0xFF212121;
+    private static final int COLOR_HEAD = 0xFF03A9F4;
+    private static final int COLOR_BODY = 0xFF607D8B;
+
+    private Paint mPaint;
+
+    public Snake(Logic logic) {
+        super(logic);
+
+        mPaint = new Paint();
+        mPaint.setAntiAlias(true);
+        mPaint.setStyle(Paint.Style.FILL);
+        mPaint.setColor(Color.WHITE);
+    }
+/*
+    @Override
+    public void draw(Canvas canvas) {
+       Surface surface = mLogic.getSurface();
+        int size = surface.getSize();
+
+        // Draw the background.
+        mPaint.setColor(COLOR_BG);
+        canvas.drawRect(
+                surface.getPaddingLeft(),
+                surface.getPaddingTop(),
+                surface.getPaddingLeft() + surface.getWidth(),
+                surface.getPaddingTop() + surface.getHeight(), mPaint);
+
+        Node node = getHead();
+        if (node == null) return;
+        int xPrev = surface.calculateRealX(node.x);
+        int yPrev = surface.calculateRealY(node.y);
+
+        // Draw the head.
+        mPaint.setColor(COLOR_HEAD);
+        canvas.drawRect(xPrev, yPrev, xPrev + size, yPrev + size, mPaint);
+        node = node.child;
+
+        // Draw the body.
+        mPaint.setColor(COLOR_BODY);
+        while (node != null) {
+            int x = surface.calculateRealX(node.x);
+            int y = surface.calculateRealY(node.y);
+            canvas.drawRect(x, y, x + size, y + size, mPaint);
+            node = node.child;
+        }
+    }*/
+
+}
diff --git a/project/app/src/main/java/dreamers/graphics/Ripple.java b/project/app/src/main/java/dreamers/graphics/Ripple.java
new file mode 100644
index 00000000..6ed7f886
--- /dev/null
+++ b/project/app/src/main/java/dreamers/graphics/Ripple.java
@@ -0,0 +1,419 @@
+package dreamers.graphics;
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.animation.ObjectAnimator;
+import android.graphics.Canvas;
+import android.graphics.Paint;
+import android.graphics.Paint.Style;
+import android.graphics.Rect;
+import android.os.Build;
+import android.view.animation.Interpolator;
+import android.view.animation.LinearInterpolator;
+
+/**
+ * Draws a Material ripple.
+ */
+class Ripple {
+    private static final LinearInterpolator LINEAR_INTERPOLATOR = new LinearInterpolator();
+    private static final LogInterpolator DECEL_INTERPOLATOR = new LogInterpolator();
+
+    private static final float GLOBAL_SPEED = 1.0f;
+    private static final float WAVE_TOUCH_DOWN_ACCELERATION = 1024.0f * GLOBAL_SPEED;
+    private static final float WAVE_TOUCH_UP_ACCELERATION = 3400.0f * GLOBAL_SPEED;
+    private static final float WAVE_OPACITY_DECAY_VELOCITY = 3.0f / GLOBAL_SPEED;
+
+    private static final long RIPPLE_ENTER_DELAY = 80;
+
+    private final RippleDrawable mOwner;
+
+    /** Bounds used for computing max radius. */
+    private final Rect mBounds;
+
+    /** Full-opacity color for drawing this ripple. */
+    private int mColorOpaque;
+
+    /** Maximum ripple radius. */
+    private float mOuterRadius;
+
+    /** Screen density used to adjust pixel-based velocities. */
+    private float mDensity;
+
+    private float mStartingX;
+    private float mStartingY;
+    private float mClampedStartingX;
+    private float mClampedStartingY;
+
+    // Software animators.
+    private ObjectAnimator mAnimRadius;
+    private ObjectAnimator mAnimOpacity;
+    private ObjectAnimator mAnimX;
+    private ObjectAnimator mAnimY;
+
+    // Temporary paint used for creating canvas properties.
+    private Paint mTempPaint;
+
+    // Software rendering properties.
+    private float mOpacity = (float) 0x40 / 0xFF;
+    private float mOuterX;
+    private float mOuterY;
+
+    // Values used to tween between the start and end positions.
+    private float mTweenRadius = 0;
+    private float mTweenX = 0;
+    private float mTweenY = 0;
+
+    /** Whether we have an explicit maximum radius. */
+    private boolean mHasMaxRadius;
+
+    /** Whether we were canceled externally and should avoid self-removal. */
+    private boolean mCanceled;
+
+    /**
+     * Creates a new ripple.
+     */
+    public Ripple(RippleDrawable owner, Rect bounds, float startingX, float startingY) {
+        mOwner = owner;
+        mBounds = bounds;
+
+        mStartingX = startingX;
+        mStartingY = startingY;
+    }
+
+    public void setup(int maxRadius, int color, float density) {
+        mColorOpaque = color | 0xFF000000;
+
+        if (maxRadius != -1) {
+            mHasMaxRadius = true;
+            mOuterRadius = maxRadius;
+        } else {
+            final float halfWidth = mBounds.width() / 2.0f;
+            final float halfHeight = mBounds.height() / 2.0f;
+            mOuterRadius = (float) Math.sqrt(halfWidth * halfWidth + halfHeight * halfHeight);
+        }
+
+        mOuterX = 0;
+        mOuterY = 0;
+        mDensity = density;
+
+        clampStartingPosition();
+    }
+
+    private void clampStartingPosition() {
+        final float cX = mBounds.exactCenterX();
+        final float cY = mBounds.exactCenterY();
+        final float dX = mStartingX - cX;
+        final float dY = mStartingY - cY;
+        final float r = mOuterRadius;
+        if (dX * dX + dY * dY > r * r) {
+            // Point is outside the circle, clamp to the circumference.
+            final double angle = Math.atan2(dY, dX);
+            mClampedStartingX = cX + (float) (Math.cos(angle) * r);
+            mClampedStartingY = cY + (float) (Math.sin(angle) * r);
+        } else {
+            mClampedStartingX = mStartingX;
+            mClampedStartingY = mStartingY;
+        }
+    }
+
+    public void onHotspotBoundsChanged() {
+        if (!mHasMaxRadius) {
+            final float halfWidth = mBounds.width() / 2.0f;
+            final float halfHeight = mBounds.height() / 2.0f;
+            mOuterRadius = (float) Math.sqrt(halfWidth * halfWidth + halfHeight * halfHeight);
+
+            clampStartingPosition();
+        }
+    }
+
+    public void setOpacity(float a) {
+        mOpacity = a;
+        invalidateSelf();
+    }
+
+    public float getOpacity() {
+        return mOpacity;
+    }
+
+    @SuppressWarnings("unused")
+    public void setRadiusGravity(float r) {
+        mTweenRadius = r;
+        invalidateSelf();
+    }
+
+    @SuppressWarnings("unused")
+    public float getRadiusGravity() {
+        return mTweenRadius;
+    }
+
+    @SuppressWarnings("unused")
+    public void setXGravity(float x) {
+        mTweenX = x;
+        invalidateSelf();
+    }
+
+    @SuppressWarnings("unused")
+    public float getXGravity() {
+        return mTweenX;
+    }
+
+    @SuppressWarnings("unused")
+    public void setYGravity(float y) {
+        mTweenY = y;
+        invalidateSelf();
+    }
+
+    @SuppressWarnings("unused")
+    public float getYGravity() {
+        return mTweenY;
+    }
+
+    /**
+     * Draws the ripple centered at (0,0) using the specified paint.
+     */
+    public boolean draw(Canvas c, Paint p) {
+        final boolean hasContent;
+        hasContent = drawSoftware(c, p);
+
+        return hasContent;
+    }
+
+    private boolean drawSoftware(Canvas c, Paint p) {
+        boolean hasContent = false;
+
+        p.setColor(mColorOpaque);
+        final int alpha = (int) (255 * mOpacity + 0.5f);
+        final float radius = lerp(0, mOuterRadius, mTweenRadius);
+        if (alpha > 0 && radius > 0) {
+            final float x = lerp(
+                    mClampedStartingX - mBounds.exactCenterX(), mOuterX, mTweenX);
+            final float y = lerp(
+                    mClampedStartingY - mBounds.exactCenterY(), mOuterY, mTweenY);
+            p.setAlpha(alpha);
+            p.setStyle(Style.FILL);
+            c.drawCircle(x, y, radius, p);
+            hasContent = true;
+        }
+
+        return hasContent;
+    }
+
+    public static float lerp(float start, float stop, float amount) {
+        return start + (stop - start) * amount;
+    }
+
+    /**
+     * Returns the maximum bounds of the ripple relative to the ripple center.
+     */
+    public void getBounds(Rect bounds) {
+        final int outerX = (int) mOuterX;
+        final int outerY = (int) mOuterY;
+        final int r = (int) mOuterRadius + 1;
+        bounds.set(outerX - r, outerY - r, outerX + r, outerY + r);
+    }
+
+    /**
+     * Specifies the starting position relative to the drawable bounds. No-op if
+     * the ripple has already entered.
+     */
+    public void move(float x, float y) {
+        mStartingX = x;
+        mStartingY = y;
+
+        clampStartingPosition();
+    }
+
+    /**
+     * Starts the enter animation.
+     */
+    public void enter() {
+        cancel();
+
+        final int radiusDuration = (int)
+                (1000 * Math.sqrt(mOuterRadius / WAVE_TOUCH_DOWN_ACCELERATION * mDensity) + 0.5);
+
+        final ObjectAnimator radius = ObjectAnimator.ofFloat(this, "radiusGravity", 1);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) radius.setAutoCancel(true);
+        radius.setDuration(radiusDuration);
+        radius.setInterpolator(LINEAR_INTERPOLATOR);
+        radius.setStartDelay(RIPPLE_ENTER_DELAY);
+
+        final ObjectAnimator cX = ObjectAnimator.ofFloat(this, "xGravity", 1);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) cX.setAutoCancel(true);
+        cX.setDuration(radiusDuration);
+        cX.setInterpolator(LINEAR_INTERPOLATOR);
+        cX.setStartDelay(RIPPLE_ENTER_DELAY);
+
+        final ObjectAnimator cY = ObjectAnimator.ofFloat(this, "yGravity", 1);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) cY.setAutoCancel(true);
+        cY.setDuration(radiusDuration);
+        cY.setInterpolator(LINEAR_INTERPOLATOR);
+        cY.setStartDelay(RIPPLE_ENTER_DELAY);
+
+        mAnimRadius = radius;
+        mAnimX = cX;
+        mAnimY = cY;
+
+        // Enter animations always run on the UI thread, since it's unlikely
+        // that anything interesting is happening until the user lifts their
+        // finger.
+        radius.start();
+        cX.start();
+        cY.start();
+    }
+
+    /**
+     * Starts the exit animation.
+     */
+    public void exit() {
+        cancel();
+
+        final float radius = lerp(0, mOuterRadius, mTweenRadius);
+        final float remaining;
+        if (mAnimRadius != null && mAnimRadius.isRunning()) {
+            remaining = mOuterRadius - radius;
+        } else {
+            remaining = mOuterRadius;
+        }
+
+        final int radiusDuration = (int) (1000 * Math.sqrt(remaining / (WAVE_TOUCH_UP_ACCELERATION
+                + WAVE_TOUCH_DOWN_ACCELERATION) * mDensity) + 0.5);
+        final int opacityDuration = (int) (1000 * mOpacity / WAVE_OPACITY_DECAY_VELOCITY + 0.5f);
+
+        exitSoftware(radiusDuration, opacityDuration);
+    }
+
+
+
+    /**
+     * Jump all animations to their end state. The caller is responsible for
+     * removing the ripple from the list of animating ripples.
+     */
+    public void jump() {
+        mCanceled = true;
+        endSoftwareAnimations();
+        mCanceled = false;
+    }
+
+    private void endSoftwareAnimations() {
+        if (mAnimRadius != null) {
+            mAnimRadius.end();
+            mAnimRadius = null;
+        }
+
+        if (mAnimOpacity != null) {
+            mAnimOpacity.end();
+            mAnimOpacity = null;
+        }
+
+        if (mAnimX != null) {
+            mAnimX.end();
+            mAnimX = null;
+        }
+
+        if (mAnimY != null) {
+            mAnimY.end();
+            mAnimY = null;
+        }
+    }
+
+    private Paint getTempPaint() {
+        if (mTempPaint == null) {
+            mTempPaint = new Paint();
+        }
+        return mTempPaint;
+    }
+
+    private void exitSoftware(int radiusDuration, int opacityDuration) {
+        final ObjectAnimator radiusAnim = ObjectAnimator.ofFloat(this, "radiusGravity", 1);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) radiusAnim.setAutoCancel(true);
+        radiusAnim.setDuration(radiusDuration);
+        radiusAnim.setInterpolator(DECEL_INTERPOLATOR);
+
+        final ObjectAnimator xAnim = ObjectAnimator.ofFloat(this, "xGravity", 1);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) xAnim.setAutoCancel(true);
+        xAnim.setDuration(radiusDuration);
+        xAnim.setInterpolator(DECEL_INTERPOLATOR);
+
+        final ObjectAnimator yAnim = ObjectAnimator.ofFloat(this, "yGravity", 1);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) yAnim.setAutoCancel(true);
+        yAnim.setDuration(radiusDuration);
+        yAnim.setInterpolator(DECEL_INTERPOLATOR);
+
+        final ObjectAnimator opacityAnim = ObjectAnimator.ofFloat(this, "opacity", 0);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) opacityAnim.setAutoCancel(true);
+        opacityAnim.setDuration(opacityDuration);
+        opacityAnim.setInterpolator(LINEAR_INTERPOLATOR);
+        opacityAnim.addListener(mAnimationListener);
+
+        mAnimRadius = radiusAnim;
+        mAnimOpacity = opacityAnim;
+        mAnimX = xAnim;
+        mAnimY = yAnim;
+
+        radiusAnim.start();
+        opacityAnim.start();
+        xAnim.start();
+        yAnim.start();
+    }
+
+    /**
+     * Cancels all animations. The caller is responsible for removing
+     * the ripple from the list of animating ripples.
+     */
+    public void cancel() {
+        mCanceled = true;
+        cancelSoftwareAnimations();
+        mCanceled = false;
+    }
+
+    private void cancelSoftwareAnimations() {
+        if (mAnimRadius != null) {
+            mAnimRadius.cancel();
+            mAnimRadius = null;
+        }
+
+        if (mAnimOpacity != null) {
+            mAnimOpacity.cancel();
+            mAnimOpacity = null;
+        }
+
+        if (mAnimX != null) {
+            mAnimX.cancel();
+            mAnimX = null;
+        }
+
+        if (mAnimY != null) {
+            mAnimY.cancel();
+            mAnimY = null;
+        }
+    }
+
+    private void removeSelf() {
+        // The owner will invalidate itself.
+        if (!mCanceled) {
+            mOwner.removeRipple(this);
+        }
+    }
+
+    private void invalidateSelf() {
+        mOwner.invalidateSelf();
+    }
+
+    private final AnimatorListenerAdapter mAnimationListener = new AnimatorListenerAdapter() {
+        @Override
+        public void onAnimationEnd(Animator animation) {
+            removeSelf();
+        }
+    };
+
+    /**
+    * Interpolator with a smooth log deceleration
+    */
+    private static final class LogInterpolator implements Interpolator {
+        @Override
+        public float getInterpolation(float input) {
+            return 1 - (float) Math.pow(400, -input * 1.4);
+        }
+    }
+}
diff --git a/project/app/src/main/java/dreamers/graphics/RippleBackground.java b/project/app/src/main/java/dreamers/graphics/RippleBackground.java
new file mode 100644
index 00000000..eba98cf0
--- /dev/null
+++ b/project/app/src/main/java/dreamers/graphics/RippleBackground.java
@@ -0,0 +1,300 @@
+package dreamers.graphics;
+
+import android.animation.Animator;
+import android.animation.AnimatorListenerAdapter;
+import android.animation.ObjectAnimator;
+import android.graphics.Canvas;
+import android.graphics.Color;
+import android.graphics.Paint;
+import android.graphics.Paint.Style;
+import android.graphics.Rect;
+import android.os.Build;
+import android.view.animation.Interpolator;
+import android.view.animation.LinearInterpolator;
+
+/**
+ * Draws a Material ripple.
+ */
+class RippleBackground {
+    private static final Interpolator LINEAR_INTERPOLATOR = new LinearInterpolator();
+
+    private static final float GLOBAL_SPEED = 1.0f;
+    private static final float WAVE_OPACITY_DECAY_VELOCITY = 3.0f / GLOBAL_SPEED;
+    private static final float WAVE_OUTER_OPACITY_EXIT_VELOCITY_MAX = 4.5f * GLOBAL_SPEED;
+    private static final float WAVE_OUTER_OPACITY_EXIT_VELOCITY_MIN = 1.5f * GLOBAL_SPEED;
+    private static final float WAVE_OUTER_OPACITY_ENTER_VELOCITY = 10.0f * GLOBAL_SPEED;
+    private static final float WAVE_OUTER_SIZE_INFLUENCE_MAX = 200f;
+    private static final float WAVE_OUTER_SIZE_INFLUENCE_MIN = 40f;
+
+
+    private final RippleDrawable mOwner;
+
+    /** Bounds used for computing max radius. */
+    private final Rect mBounds;
+
+    /** Full-opacity color for drawing this ripple. */
+    private int mColorOpaque;
+
+    /** Maximum alpha value for drawing this ripple. */
+    private int mColorAlpha;
+
+    /** Maximum ripple radius. */
+    private float mOuterRadius;
+
+    /** Screen density used to adjust pixel-based velocities. */
+    private float mDensity;
+
+
+    // Software animators.
+    private ObjectAnimator mAnimOuterOpacity;
+
+    // Temporary paint used for creating canvas properties.
+    private Paint mTempPaint;
+
+    // Software rendering properties.
+    private float mOuterOpacity = 0;
+    private float mOuterX;
+    private float mOuterY;
+
+    /** Whether we should be drawing hardware animations. */
+    private boolean mHardwareAnimating;
+
+    /** Whether we can use hardware acceleration for the exit animation. */
+    private boolean mCanUseHardware;
+
+    /** Whether we have an explicit maximum radius. */
+    private boolean mHasMaxRadius;
+
+    /**
+     * Creates a new ripple.
+     */
+    public RippleBackground(RippleDrawable owner, Rect bounds) {
+        mOwner = owner;
+        mBounds = bounds;
+    }
+
+    public void setup(int maxRadius, int color, float density) {
+        mColorOpaque = color | 0xFF000000;
+        mColorAlpha = Color.alpha(color) / 2;
+
+        if (maxRadius != RippleDrawable.RADIUS_AUTO) {
+            mHasMaxRadius = true;
+            mOuterRadius = maxRadius;
+        } else {
+            final float halfWidth = mBounds.width() / 2.0f;
+            final float halfHeight = mBounds.height() / 2.0f;
+            mOuterRadius = (float) Math.sqrt(halfWidth * halfWidth + halfHeight * halfHeight);
+        }
+
+        mOuterX = 0;
+        mOuterY = 0;
+        mDensity = density;
+    }
+
+    public boolean isHardwareAnimating() {
+        return mHardwareAnimating;
+    }
+
+    public void onHotspotBoundsChanged() {
+        if (!mHasMaxRadius) {
+            final float halfWidth = mBounds.width() / 2.0f;
+            final float halfHeight = mBounds.height() / 2.0f;
+            mOuterRadius = (float) Math.sqrt(halfWidth * halfWidth + halfHeight * halfHeight);
+        }
+    }
+
+    @SuppressWarnings("unused")
+    public void setOuterOpacity(float a) {
+        mOuterOpacity = a;
+        invalidateSelf();
+    }
+
+    @SuppressWarnings("unused")
+    public float getOuterOpacity() {
+        return mOuterOpacity;
+    }
+
+    /**
+     * Draws the ripple centered at (0,0) using the specified paint.
+     */
+    public boolean draw(Canvas c, Paint p) {
+        return drawSoftware(c, p);
+    }
+
+    public boolean shouldDraw() {
+        final int outerAlpha = (int) (mColorAlpha * mOuterOpacity + 0.5f);
+        return mCanUseHardware && mHardwareAnimating || outerAlpha > 0 && mOuterRadius > 0;
+    }
+
+    private boolean drawSoftware(Canvas c, Paint p) {
+        boolean hasContent = false;
+
+        p.setColor(mColorOpaque);
+        final int outerAlpha = (int) (mColorAlpha * mOuterOpacity + 0.5f);
+        if (outerAlpha > 0 && mOuterRadius > 0) {
+            p.setAlpha(outerAlpha);
+            p.setStyle(Style.FILL);
+            c.drawCircle(mOuterX, mOuterY, mOuterRadius, p);
+            hasContent = true;
+        }
+
+        return hasContent;
+    }
+
+    /**
+     * Returns the maximum bounds of the ripple relative to the ripple center.
+     */
+    public void getBounds(Rect bounds) {
+        final int outerX = (int) mOuterX;
+        final int outerY = (int) mOuterY;
+        final int r = (int) mOuterRadius + 1;
+        bounds.set(outerX - r, outerY - r, outerX + r, outerY + r);
+    }
+
+    /**
+     * Starts the enter animation.
+     */
+    public void enter() {
+        cancel();
+
+        final int outerDuration = (int) (1000 * 1.0f / WAVE_OUTER_OPACITY_ENTER_VELOCITY);
+        final ObjectAnimator outer = ObjectAnimator.ofFloat(this, "outerOpacity", 0, 1);
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) outer.setAutoCancel(true);
+        outer.setDuration(outerDuration);
+        outer.setInterpolator(LINEAR_INTERPOLATOR);
+
+        mAnimOuterOpacity = outer;
+
+        // Enter animations always run on the UI thread, since it's unlikely
+        // that anything interesting is happening until the user lifts their
+        // finger.
+        outer.start();
+    }
+
+    /**
+     * Starts the exit animation.
+     */
+    public void exit() {
+        cancel();
+
+        // Scale the outer max opacity and opacity velocity based
+        // on the size of the outer radius.
+        final int opacityDuration = (int) (1000 / WAVE_OPACITY_DECAY_VELOCITY + 0.5f);
+        final float outerSizeInfluence = constrain(
+                (mOuterRadius - WAVE_OUTER_SIZE_INFLUENCE_MIN * mDensity)
+                / (WAVE_OUTER_SIZE_INFLUENCE_MAX * mDensity), 0, 1);
+        final float outerOpacityVelocity = Ripple.lerp(WAVE_OUTER_OPACITY_EXIT_VELOCITY_MIN,
+                WAVE_OUTER_OPACITY_EXIT_VELOCITY_MAX, outerSizeInfluence);
+
+        // Determine at what time the inner and outer opacity intersect.
+        // inner(t) = mOpacity - t * WAVE_OPACITY_DECAY_VELOCITY / 1000
+        // outer(t) = mOuterOpacity + t * WAVE_OUTER_OPACITY_VELOCITY / 1000
+        final int inflectionDuration = Math.max(0, (int) (1000 * (1 - mOuterOpacity)
+                / (WAVE_OPACITY_DECAY_VELOCITY + outerOpacityVelocity) + 0.5f));
+        final int inflectionOpacity = (int) (mColorAlpha * (mOuterOpacity
+                + inflectionDuration * outerOpacityVelocity * outerSizeInfluence / 1000) + 0.5f);
+
+        exitSoftware(opacityDuration, inflectionDuration, inflectionOpacity);
+    }
+
+    public static float constrain(float amount, float low, float high) {
+        return amount < low ? low : (amount > high ? high : amount);
+    }
+
+    /**
+     * Jump all animations to their end state. The caller is responsible for
+     * removing the ripple from the list of animating ripples.
+     */
+    public void jump() {
+        endSoftwareAnimations();
+    }
+
+    private void endSoftwareAnimations() {
+        if (mAnimOuterOpacity != null) {
+            mAnimOuterOpacity.end();
+            mAnimOuterOpacity = null;
+        }
+    }
+
+    private Paint getTempPaint() {
+        if (mTempPaint == null) {
+            mTempPaint = new Paint();
+        }
+        return mTempPaint;
+    }
+
+    private void exitSoftware(int opacityDuration, int inflectionDuration, int inflectionOpacity) {
+        final ObjectAnimator outerOpacityAnim;
+        if (inflectionDuration > 0) {
+            // Outer opacity continues to increase for a bit.
+            outerOpacityAnim = ObjectAnimator.ofFloat(this,
+                    "outerOpacity", inflectionOpacity / 255.0f);
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) outerOpacityAnim.setAutoCancel(true);
+            outerOpacityAnim.setDuration(inflectionDuration);
+            outerOpacityAnim.setInterpolator(LINEAR_INTERPOLATOR);
+
+            // Chain the outer opacity exit animation.
+            final int outerDuration = opacityDuration - inflectionDuration;
+            if (outerDuration > 0) {
+                outerOpacityAnim.addListener(new AnimatorListenerAdapter() {
+                    @Override
+                    public void onAnimationEnd(Animator animation) {
+                        final ObjectAnimator outerFadeOutAnim = ObjectAnimator.ofFloat(
+                                RippleBackground.this, "outerOpacity", 0);
+                        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) outerFadeOutAnim.setAutoCancel(true);
+                        outerFadeOutAnim.setDuration(outerDuration);
+                        outerFadeOutAnim.setInterpolator(LINEAR_INTERPOLATOR);
+                        outerFadeOutAnim.addListener(mAnimationListener);
+
+                        mAnimOuterOpacity = outerFadeOutAnim;
+
+                        outerFadeOutAnim.start();
+                    }
+
+                    @Override
+                    public void onAnimationCancel(Animator animation) {
+                        animation.removeListener(this);
+                    }
+                });
+            } else {
+                outerOpacityAnim.addListener(mAnimationListener);
+            }
+        } else {
+            outerOpacityAnim = ObjectAnimator.ofFloat(this, "outerOpacity", 0);
+            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) outerOpacityAnim.setAutoCancel(true);
+            outerOpacityAnim.setDuration(opacityDuration);
+            outerOpacityAnim.addListener(mAnimationListener);
+        }
+
+        mAnimOuterOpacity = outerOpacityAnim;
+
+        outerOpacityAnim.start();
+    }
+
+    /**
+     * Cancel all animations. The caller is responsible for removing
+     * the ripple from the list of animating ripples.
+     */
+    public void cancel() {
+        cancelSoftwareAnimations();
+    }
+
+    private void cancelSoftwareAnimations() {
+        if (mAnimOuterOpacity != null) {
+            mAnimOuterOpacity.cancel();
+            mAnimOuterOpacity = null;
+        }
+    }
+
+
+    private void invalidateSelf() {
+        mOwner.invalidateSelf();
+    }
+
+    private final AnimatorListenerAdapter mAnimationListener = new AnimatorListenerAdapter() {
+        @Override
+        public void onAnimationEnd(Animator animation) {
+            mHardwareAnimating = false;
+        }
+    };
+}
diff --git a/project/app/src/main/java/dreamers/graphics/RippleDrawable.java b/project/app/src/main/java/dreamers/graphics/RippleDrawable.java
index 2faf776f..1cc552dc 100644
--- a/project/app/src/main/java/dreamers/graphics/RippleDrawable.java
+++ b/project/app/src/main/java/dreamers/graphics/RippleDrawable.java
@@ -1,262 +1,657 @@
 package dreamers.graphics;
 
-import android.animation.Animator;
-import android.animation.ObjectAnimator;
+import android.content.res.ColorStateList;
 import android.graphics.Canvas;
+import android.graphics.Color;
 import android.graphics.ColorFilter;
 import android.graphics.Paint;
+import android.graphics.PixelFormat;
+import android.graphics.PorterDuff;
+import android.graphics.PorterDuffXfermode;
+import android.graphics.Rect;
 import android.graphics.drawable.Drawable;
 import android.os.Build;
-import android.util.Property;
-import android.view.MotionEvent;
+import android.util.DisplayMetrics;
 import android.view.View;
 
-public class RippleDrawable extends Drawable implements View.OnTouchListener{
+import java.util.Arrays;
 
-    final static Property<RippleDrawable, Float> CREATE_TOUCH_RIPPLE =
-            new FloatProperty<RippleDrawable>("createTouchRipple") {
-        @Override
-        public void setValue(RippleDrawable object, float value) {
-            object.createTouchRipple(value);
+public class RippleDrawable extends Drawable {
+    private static final PorterDuffXfermode DST_IN = new PorterDuffXfermode(PorterDuff.Mode.DST_IN);
+    private static final PorterDuffXfermode SRC_ATOP = new PorterDuffXfermode(PorterDuff.Mode.SRC_ATOP);
+    private static final PorterDuffXfermode SRC_OVER = new PorterDuffXfermode(PorterDuff.Mode.SRC_OVER);
+
+    /**
+     * Constant for automatically determining the maximum ripple radius.
+     *
+     * @see #setMaxRadius(int)
+     * @hide
+     */
+    public static final int RADIUS_AUTO = -1;
+
+    /** The maximum number of ripples supported. */
+    private static final int MAX_RIPPLES = 10;
+
+    /** Current ripple effect bounds, used to constrain ripple effects. */
+    private final Rect mHotspotBounds = new Rect();
+
+    ColorStateList mColor = ColorStateList.valueOf(Color.MAGENTA);
+
+    int mMaxRadius = RADIUS_AUTO;
+
+    private Drawable mContent;
+
+    /** The masking layer, e.g. the layer with id R.id.mask. */
+    private Drawable mMask;
+
+    /** The current background. May be actively animating or pending entry. */
+    private RippleBackground mBackground;
+
+    /** Whether we expect to draw a background when visible. */
+    private boolean mBackgroundActive;
+
+    /** The current ripple. May be actively animating or pending entry. */
+    private Ripple mRipple;
+
+    /** Whether we expect to draw a ripple when visible. */
+    private boolean mRippleActive;
+
+    // Hotspot coordinates that are awaiting activation.
+    private float mPendingX;
+    private float mPendingY;
+    private boolean mHasPending;
+
+    /**
+     * Lazily-created array of actively animating ripples. Inactive ripples are
+     * pruned during draw(). The locations of these will not change.
+     */
+    private Ripple[] mExitingRipples;
+    private int mExitingRipplesCount = 0;
+
+    /** Paint used to control appearance of ripples. */
+    private Paint mRipplePaint;
+
+    /** Paint used to control reveal layer masking. */
+    private Paint mMaskingPaint;
+
+    /** Target density of the display into which ripples are drawn. */
+    private float mDensity = 1.0f;
+
+    /** Whether bounds are being overridden. */
+    private boolean mOverrideBounds;
+
+    /**
+     * Whether the next draw MUST draw something to canvas. Used to work around
+     * a bug in hardware invalidation following a render thread-accelerated
+     * animation.
+     */
+    private boolean mNeedsDraw;
+
+    /**
+     * Creates a new ripple drawable with the specified ripple color and
+     * optional content and mask drawables.
+     *
+     * @param color The ripple color
+     */
+    public RippleDrawable(ColorStateList color) {
+        setColor(color);
+    }
+
+    public RippleDrawable(ColorStateList color, Drawable content){
+        this(color);
+
+        mContent = content;
+    }
+
+    @Override
+    public void jumpToCurrentState() {
+        if(Build.VERSION.SDK_INT > 11) {
+            super.jumpToCurrentState();
         }
 
-        @Override
-        public Float get(RippleDrawable object) {
-            return object.getAnimationState();
+        boolean needsDraw;
+
+        if (mRipple != null) {
+            mRipple.jump();
         }
-    };
 
-    final static Property<RippleDrawable, Float> DESTROY_TOUCH_RIPPLE =
-            new FloatProperty<RippleDrawable>("destroyTouchRipple") {
-        @Override
-        public void setValue(RippleDrawable object, float value) {
-            object.destroyTouchRipple(value);
+        if (mBackground != null) {
+            mBackground.jump();
         }
 
-        @Override
-        public Float get(RippleDrawable object) {
-            return object.getAnimationState();
+        needsDraw = cancelExitingRipples();
+
+        mNeedsDraw = needsDraw;
+        invalidateSelf();
+    }
+
+
+    private boolean cancelExitingRipples() {
+        final int count = mExitingRipplesCount;
+        final Ripple[] ripples = mExitingRipples;
+        for (int i = 0; i < count; i++) {
+            ripples[i].cancel();
+        }
+
+        if (ripples != null) {
+            Arrays.fill(ripples, 0, count, null);
+        }
+        mExitingRipplesCount = 0;
+
+        return false;
+    }
+
+    @Override
+    public void setAlpha(int alpha) {
+        mColor.withAlpha(alpha);
+    }
+
+    @Override
+    public int getAlpha() {
+        return Color.alpha(mColor.getDefaultColor());
+    }
+
+    @Override
+    public void setColorFilter(ColorFilter cf) {
+        //TODO how to implement?
+    }
+
+    @Override
+    public int getOpacity() {
+        // Worst-case scenario.
+        return PixelFormat.TRANSLUCENT;
+    }
+
+
+    @Override
+    protected boolean onStateChange(int[] stateSet) {
+        final boolean changed = super.onStateChange(stateSet);
+
+        boolean enabled = false;
+        boolean pressed = false;
+        boolean focused = false;
+
+        for (int state : stateSet) {
+            if (state == android.R.attr.state_enabled) {
+                enabled = true;
+            }
+            if (state == android.R.attr.state_focused) {
+                focused = true;
+            }
+            if (state == android.R.attr.state_pressed) {
+                pressed = true;
+            }
         }
-    };
 
-    final static int DEFAULT_ANIM_DURATION = 250;
-    final static float END_RIPPLE_TOUCH_RADIUS = 150f;
-    final static float END_SCALE = 1.3f;
+        setRippleActive(enabled && pressed);
+        setBackgroundActive(focused || (enabled && pressed));
 
-    final static int RIPPLE_TOUCH_MIN_ALPHA = 40;
-    final static int RIPPLE_TOUCH_MAX_ALPHA = 120;
-    final static int RIPPLE_BACKGROUND_ALPHA = 100;
+        return changed;
+    }
 
-    Paint mRipplePaint = new Paint(Paint.ANTI_ALIAS_FLAG);
-    Paint mRippleBackgroundPaint = new Paint(Paint.ANTI_ALIAS_FLAG);
+    private void setRippleActive(boolean active) {
+        if (mRippleActive != active) {
+            mRippleActive = active;
+            if (active) {
+                tryRippleEnter();
+            } else {
+                tryRippleExit();
+            }
+        }
+    }
 
-    Circle mTouchRipple;
-    Circle mBackgroundRipple;
+    private void setBackgroundActive(boolean active) {
+        if (mBackgroundActive != active) {
+            mBackgroundActive = active;
+            if (active) {
+                tryBackgroundEnter();
+            } else {
+                tryBackgroundExit();
+            }
+        }
+    }
 
-    ObjectAnimator mCurrentAnimator;
+    @Override
+    protected void onBoundsChange(Rect bounds) {
+        super.onBoundsChange(bounds);
 
-    Drawable mOriginalBackground;
+        if (!mOverrideBounds) {
+            mHotspotBounds.set(bounds);
+            onHotspotBoundsChanged();
+        }
 
-    public RippleDrawable() {
-        initRippleElements();
+        invalidateSelf();
     }
 
-    public static void createRipple(View v, int primaryColor){
-        RippleDrawable rippleDrawable = new RippleDrawable();
-        rippleDrawable.setDrawable(v.getBackground());
-        rippleDrawable.setColor(primaryColor);
-        rippleDrawable.setBounds(v.getPaddingLeft(), v.getPaddingTop(),
-                v.getPaddingRight(), v.getPaddingBottom());
+    @Override
+    public boolean setVisible(boolean visible, boolean restart) {
+        final boolean changed = super.setVisible(visible, restart);
+
+        if (!visible) {
+            clearHotspots();
+        } else if (changed) {
+            // If we just became visible, ensure the background and ripple
+            // visibilities are consistent with their internal states.
+            if (mRippleActive) {
+                tryRippleEnter();
+            }
 
-        v.setOnTouchListener(rippleDrawable);
-        if(Build.VERSION.SDK_INT >= 16) {
-            v.setBackground(rippleDrawable);
-        }else{
-            v.setBackgroundDrawable(rippleDrawable);
+            if (mBackgroundActive) {
+                tryBackgroundEnter();
+            }
         }
+        return changed;
     }
 
-    public static void createRipple(int x, int y, View v, int primaryColor){
-        if(!(v.getBackground() instanceof RippleDrawable)) {
-            createRipple(v, primaryColor);
+    public void setHotspot(float x, float y) {
+        if (mRipple == null || mBackground == null) {
+            mPendingX = x;
+            mPendingY = y;
+            mHasPending = true;
+        }
+
+        if (mRipple != null) {
+            mRipple.move(x, y);
         }
-        RippleDrawable drawable = (RippleDrawable) v.getBackground();
-        drawable.setColor(primaryColor);
-        drawable.onFingerDown(v, x, y);
     }
 
     /**
-     * Set colors of ripples
-     *
-     * @param primaryColor color of ripples
+     * Attempts to start an enter animation for the active hotspot. Fails if
+     * there are too many animating ripples.
      */
-    public void setColor(int primaryColor){
-        mRippleBackgroundPaint.setColor(primaryColor);
-        mRippleBackgroundPaint.setAlpha(RIPPLE_BACKGROUND_ALPHA);
-        mRipplePaint.setColor(primaryColor);
+    private void tryRippleEnter() {
+        if (mExitingRipplesCount >= MAX_RIPPLES) {
+            // This should never happen unless the user is tapping like a maniac
+            // or there is a bug that's preventing ripples from being removed.
+            return;
+        }
 
-        invalidateSelf();
+        if (mRipple == null) {
+            final float x;
+            final float y;
+            if (mHasPending) {
+                mHasPending = false;
+                x = mPendingX;
+                y = mPendingY;
+            } else {
+                x = mHotspotBounds.exactCenterX();
+                y = mHotspotBounds.exactCenterY();
+            }
+            mRipple = new Ripple(this, mHotspotBounds, x, y);
+        }
+
+        final int color = mColor.getColorForState(getState(), Color.TRANSPARENT);
+        mRipple.setup(mMaxRadius, color, mDensity);
+        mRipple.enter();
     }
 
     /**
-     * set first layer you background drawable
-     *
-     * @param drawable original background
+     * Attempts to start an exit animation for the active hotspot. Fails if
+     * there is no active hotspot.
      */
-    public void setDrawable(Drawable drawable){
-        mOriginalBackground = drawable;
+    private void tryRippleExit() {
+        if (mRipple != null) {
+            if (mExitingRipples == null) {
+                mExitingRipples = new Ripple[MAX_RIPPLES];
+            }
+            mExitingRipples[mExitingRipplesCount++] = mRipple;
+            mRipple.exit();
+            mRipple = null;
+        }
+    }
 
+    /**
+     * Cancels and removes the active ripple, all exiting ripples, and the
+     * background. Nothing will be drawn after this method is called.
+     */
+    private void clearHotspots() {
+        boolean needsDraw = false;
+
+        if (mRipple != null) {
+            needsDraw = false;
+            mRipple.cancel();
+            mRipple = null;
+        }
+
+        if (mBackground != null) {
+            needsDraw = mBackground.isHardwareAnimating();
+            mBackground.cancel();
+            mBackground = null;
+        }
+
+        needsDraw |= cancelExitingRipples();
+
+        mNeedsDraw = needsDraw;
         invalidateSelf();
     }
 
-    void initRippleElements(){
-        mTouchRipple = new Circle();
-        mBackgroundRipple = new Circle();
+    public void setHotspotBounds(int left, int top, int right, int bottom) {
+        mOverrideBounds = true;
+        mHotspotBounds.set(left, top, right, bottom);
 
-        mRipplePaint.setStyle(Paint.Style.FILL);
-        mRippleBackgroundPaint.setStyle(Paint.Style.FILL);
+        onHotspotBoundsChanged();
     }
 
-    @Override
-    public void draw(Canvas canvas) {
-        if(mOriginalBackground != null){
-            mOriginalBackground.setBounds(getBounds());
-            mOriginalBackground.draw(canvas);
+    /** @hide */
+    public void getHotspotBounds(Rect outRect) {
+        outRect.set(mHotspotBounds);
+    }
+
+    /**
+     * Notifies all the animating ripples that the hotspot bounds have changed.
+     */
+    private void onHotspotBoundsChanged() {
+        final int count = mExitingRipplesCount;
+        final Ripple[] ripples = mExitingRipples;
+        for (int i = 0; i < count; i++) {
+            ripples[i].onHotspotBoundsChanged();
+        }
+
+        if (mRipple != null) {
+            mRipple.onHotspotBoundsChanged();
         }
 
-        mBackgroundRipple.draw(canvas, mRippleBackgroundPaint);
-        mTouchRipple.draw(canvas, mRipplePaint);
+        if (mBackground != null) {
+            mBackground.onHotspotBoundsChanged();
+        }
     }
 
-    @Override public void setAlpha(int alpha) {}
+    /**
+     * Creates an active hotspot at the specified location.
+     */
+    private void tryBackgroundEnter() {
+        if (mBackground == null) {
+            mBackground = new RippleBackground(this, mHotspotBounds);
+        }
 
-    @Override public void setColorFilter(ColorFilter cf) {}
+        final int color = mColor.getColorForState(getState(), Color.TRANSPARENT);
+        mBackground.setup(mMaxRadius, color, mDensity);
+        mBackground.enter();
+    }
 
-    @Override public int getOpacity() {
-        return 0;
+    private void tryBackgroundExit() {
+        if (mBackground != null) {
+            // Don't null out the background, we need it to draw!
+            mBackground.exit();
+        }
     }
 
     @Override
-    public boolean onTouch(View v, MotionEvent event) {
-        final int action = event.getAction();
-        switch (action){
-            case MotionEvent.ACTION_DOWN:
-                onFingerDown(v, event.getX(), event.getY());
-                return v.onTouchEvent(event);
-            case MotionEvent.ACTION_MOVE:
-                onFingerMove(event.getX(), event.getY());
-                break;
-            case MotionEvent.ACTION_UP:
-            case MotionEvent.ACTION_CANCEL:
-                onFingerUp();
-                break;
+    public void draw(Canvas canvas) {
+        final boolean hasMask = mMask != null;
+        final boolean drawNonMaskContent = mContent != null;//TODO if contentDrawable is not null
+
+        final boolean drawMask = hasMask && mMask.getOpacity() != PixelFormat.OPAQUE;
+        final Rect bounds = getDirtyBounds();
+        final int saveCount = canvas.save(Canvas.CLIP_SAVE_FLAG);
+        canvas.clipRect(bounds);
+
+        // If we have content, draw it into a layer first.
+        if (drawNonMaskContent) {
+            drawContentLayer(canvas, bounds, SRC_OVER);
         }
-        return false;
-    }
 
-    int mViewSize = 0;
+        // Next, try to draw the ripples (into a layer if necessary). If we need
+        // to mask against the underlying content, set the xfermode to SRC_ATOP.
+        final PorterDuffXfermode xfermode = (hasMask || !drawNonMaskContent) ? SRC_OVER : SRC_ATOP;
+
+        // If we have a background and a non-opaque mask, draw the masking layer.
+        final int backgroundLayer = drawBackgroundLayer(canvas, bounds, xfermode, drawMask);
+        if (backgroundLayer >= 0) {
+            if (drawMask) {
+                drawMaskingLayer(canvas, bounds, DST_IN);
+            }
+            canvas.restoreToCount(backgroundLayer);
+        }
 
-    void onFingerDown(View v, float x, float y){
-        mTouchRipple.cx = mBackgroundRipple.cx = x;
-        mTouchRipple.cy = mBackgroundRipple.cy = y;
-        mTouchRipple.radius = mBackgroundRipple.radius = 0f;
-        mViewSize = Math.max(v.getWidth(), v.getHeight());
+        // If we have ripples and a non-opaque mask, draw the masking layer.
+        final int rippleLayer = drawRippleLayer(canvas, bounds, xfermode);
+        if (rippleLayer >= 0) {
+            if (drawMask) {
+                drawMaskingLayer(canvas, bounds, DST_IN);
+            }
+            canvas.restoreToCount(rippleLayer);
+        }
 
-        if(mCurrentAnimator == null){
-            mRippleBackgroundPaint.setAlpha(RIPPLE_BACKGROUND_ALPHA);
+        // If we failed to draw anything and we just canceled animations, at
+        // least draw a color so that hardware invalidation works correctly.
+        if (mNeedsDraw) {
+            canvas.drawColor(Color.TRANSPARENT);
 
-            mCurrentAnimator = ObjectAnimator.ofFloat(this, CREATE_TOUCH_RIPPLE, 0f, 1f);
-            mCurrentAnimator.setDuration(DEFAULT_ANIM_DURATION);
+            // Request another draw so we can avoid adding a transparent layer
+            // during the next display list refresh.
+            invalidateSelf();
         }
 
-        if(!mCurrentAnimator.isRunning()){
-            mCurrentAnimator.start();
+        mNeedsDraw = false;
+
+        canvas.restoreToCount(saveCount);
+    }
+
+    /**
+     * Removes a ripple from the exiting ripple list.
+     *
+     * @param ripple the ripple to remove
+     */
+    void removeRipple(Ripple ripple) {
+        // Ripple ripple ripple ripple. Ripple ripple.
+        final Ripple[] ripples = mExitingRipples;
+        final int count = mExitingRipplesCount;
+        final int index = getRippleIndex(ripple);
+        if (index >= 0) {
+            System.arraycopy(ripples, index + 1, ripples, index, count - (index + 1));
+            ripples[count - 1] = null;
+            mExitingRipplesCount--;
+
+            invalidateSelf();
         }
     }
 
+    private int getRippleIndex(Ripple ripple) {
+        final Ripple[] ripples = mExitingRipples;
+        final int count = mExitingRipplesCount;
+        for (int i = 0; i < count; i++) {
+            if (ripples[i] == ripple) {
+                return i;
+            }
+        }
+        return -1;
+    }
 
-    void createTouchRipple(float value){
-        mAnimationValue = value;
+    private int drawContentLayer(Canvas canvas, Rect bounds, PorterDuffXfermode mode) {
+        mContent.setBounds(bounds);
+        mContent.draw(canvas);
+        return -1;
+    }
 
-        mTouchRipple.radius = 40f + (mAnimationValue * (END_RIPPLE_TOUCH_RADIUS - 40f));
-        mBackgroundRipple.radius = mAnimationValue * (mViewSize * END_SCALE);
+    private int drawBackgroundLayer(
+            Canvas canvas, Rect bounds, PorterDuffXfermode mode, boolean drawMask) {
+        int saveCount = -1;
 
-        int min = RIPPLE_TOUCH_MIN_ALPHA;
-        int max = RIPPLE_TOUCH_MAX_ALPHA;
-        int alpha = min + (int) (mAnimationValue * (max - min));
-        mRipplePaint.setAlpha((max + min) - alpha);
+        if (mBackground != null && mBackground.shouldDraw()) {
+            // TODO: We can avoid saveLayer here if we push the xfermode into
+            // the background's render thread animator at exit() time.
+            if (drawMask || mode != SRC_OVER) {
+                //saveCount = canvas.saveLayer(bounds.left, bounds.top, bounds.right,
+                //                        bounds.bottom, getMaskingPaint(mode));
+            }
 
-        invalidateSelf();
+            final float x = mHotspotBounds.exactCenterX();
+            final float y = mHotspotBounds.exactCenterY();
+            canvas.translate(x, y);
+            mBackground.draw(canvas, getRipplePaint());
+            canvas.translate(-x, -y);
+        }
+
+        return saveCount;
     }
 
-    float mAnimationValue;
+    private int drawRippleLayer(Canvas canvas, Rect bounds, PorterDuffXfermode mode) {
+        boolean drewRipples = false;
+        int restoreToCount = -1;
+        int restoreTranslate = -1;
+
+        // Draw ripples and update the animating ripples array.
+        final int count = mExitingRipplesCount;
+        final Ripple[] ripples = mExitingRipples;
+        for (int i = 0; i <= count; i++) {
+            final Ripple ripple;
+            if (i < count) {
+                ripple = ripples[i];
+            } else if (mRipple != null) {
+                ripple = mRipple;
+            } else {
+                continue;
+            }
 
-    void destroyTouchRipple(float value){
-        mAnimationValue = value;
+            // If we're masking the ripple layer, make sure we have a layer
+            // first. This will merge SRC_OVER (directly) onto the canvas.
+            if (restoreToCount < 0) {
+                final Paint maskingPaint = getMaskingPaint(mode);
+                final int color = mColor.getColorForState(getState(), Color.TRANSPARENT);
+                final int alpha = Color.alpha(color);
+                maskingPaint.setAlpha(alpha / 2);
 
-        mTouchRipple.radius = END_RIPPLE_TOUCH_RADIUS + (mAnimationValue * (mViewSize * END_SCALE));
 
-        mRipplePaint.setAlpha((int) (RIPPLE_TOUCH_MIN_ALPHA - (mAnimationValue * RIPPLE_TOUCH_MIN_ALPHA)));
-        mRippleBackgroundPaint.setAlpha
-                ((int) (RIPPLE_BACKGROUND_ALPHA - (mAnimationValue * RIPPLE_BACKGROUND_ALPHA)));
+                // Translate the canvas to the current hotspot bounds.
+                restoreTranslate = canvas.save();
+                canvas.translate(mHotspotBounds.exactCenterX(), mHotspotBounds.exactCenterY());
+            }
 
-        invalidateSelf();
+            drewRipples |= ripple.draw(canvas, getRipplePaint());
+        }
+
+        // Always restore the translation.
+        if (restoreTranslate >= 0) {
+            canvas.restoreToCount(restoreTranslate);
+        }
+
+        // If we created a layer with no content, merge it immediately.
+        if (restoreToCount >= 0 && !drewRipples) {
+            canvas.restoreToCount(restoreToCount);
+            restoreToCount = -1;
+        }
+
+        return restoreToCount;
     }
 
-    float getAnimationState(){
-        return mAnimationValue;
+    private int drawMaskingLayer(Canvas canvas, Rect bounds, PorterDuffXfermode mode) {
+        // Ensure that DST_IN blends using the entire layer.
+        canvas.drawColor(Color.TRANSPARENT);
+
+        mMask.draw(canvas);
+
+        return -1;
     }
 
-    void onFingerUp(){
-        if(mCurrentAnimator != null) {
-            mCurrentAnimator.end();
-            mCurrentAnimator = null;
-            createTouchRipple(END_RIPPLE_TOUCH_RADIUS);
+    private Paint getRipplePaint() {
+        if (mRipplePaint == null) {
+            mRipplePaint = new Paint();
+            mRipplePaint.setAntiAlias(true);
         }
+        return mRipplePaint;
+    }
 
-        mCurrentAnimator = ObjectAnimator.ofFloat(this, DESTROY_TOUCH_RIPPLE, 0f, 1f);
-        mCurrentAnimator.setDuration(DEFAULT_ANIM_DURATION);
-        mCurrentAnimator.addListener(new SimpleAnimationListener(){
-            @Override
-            public void onAnimationEnd(Animator animation) {
-                super.onAnimationEnd(animation);
-                mCurrentAnimator = null;
-            }
-        });
-        mCurrentAnimator.start();
+    private Paint getMaskingPaint(PorterDuffXfermode xfermode) {
+        if (mMaskingPaint == null) {
+            mMaskingPaint = new Paint();
+        }
+        mMaskingPaint.setXfermode(xfermode);
+        mMaskingPaint.setAlpha(0xFF);
+        return mMaskingPaint;
     }
 
-    void onFingerMove(float x, float y){
-        mTouchRipple.cx = x;
-        mTouchRipple.cy = y;
 
-        invalidateSelf();
+    /**
+     * Set the density at which this drawable will be rendered.
+     *
+     * @param metrics The display metrics for this drawable.
+     */
+    private void setTargetDensity(DisplayMetrics metrics) {
+        if (mDensity != metrics.density) {
+            mDensity = metrics.density;
+            invalidateSelf();
+        }
     }
 
     @Override
-    public boolean setState(int[] stateSet) {
-        if(mOriginalBackground != null){
-            return mOriginalBackground.setState(stateSet);
-        }
-        return super.setState(stateSet);
+    public boolean isStateful() {
+        return true;
+    }
+
+    public void setColor(ColorStateList color) {
+        mColor = color;
+        invalidateSelf();
     }
 
     @Override
-    public int[] getState() {
-        if(mOriginalBackground != null){
-            return mOriginalBackground.getState();
-        }
-        return super.getState();
+    public Rect getDirtyBounds() {
+        return getBounds();
     }
 
-    final static class Circle{
-        float cx;
-        float cy;
-        float radius;
 
-        public void draw(Canvas canvas, Paint paint){
-            canvas.drawCircle(cx, cy, radius, paint);
+    /**
+     * Sets the maximum ripple radius in pixels. The default value of
+     * {@link #RADIUS_AUTO} defines the radius as the distance from the center
+     * of the drawable bounds (or hotspot bounds, if specified) to a corner.
+     *
+     * @param maxRadius the maximum ripple radius in pixels or
+     *            {@link #RADIUS_AUTO} to automatically determine the maximum
+     *            radius based on the bounds
+     * @see #getMaxRadius()
+     * @see #setHotspotBounds(int, int, int, int)
+     * @hide
+     */
+    public void setMaxRadius(int maxRadius) {
+        if (maxRadius != RADIUS_AUTO && maxRadius < 0) {
+            throw new IllegalArgumentException("maxRadius must be RADIUS_AUTO or >= 0");
         }
+
+        mMaxRadius = maxRadius;
+    }
+
+    /**
+     * @return the maximum ripple radius in pixels, or {@link #RADIUS_AUTO} if
+     *         the radius is determined automatically
+     * @see #setMaxRadius(int)
+     * @hide
+     */
+    public int getMaxRadius() {
+        return mMaxRadius;
+    }
+
+    /**
+     * @deprecated
+     */
+    public static RippleDrawable createRipple(View target, int color){
+        return For(target, color);
     }
 
-}
+    public static RippleDrawable For(View target, int color){
+        return makeFor(target, ColorStateList.valueOf(color));
+    }
+
+    public static RippleDrawable makeFor(View target, ColorStateList colors){
+        return makeFor(target, colors, false);
+    }
+
+    public static RippleDrawable makeFor(View target, ColorStateList colors, boolean parentIsScrollContainer){
+        RippleDrawable drawable = new RippleDrawable(colors, target.getBackground());
+
+        TouchTracker tracker = new TouchTracker(drawable);
+        tracker.setInsideScrollContainer(parentIsScrollContainer);
+
+        setBackground(target, drawable);
+        target.setOnTouchListener(tracker);
+
+        return drawable;
+    }
+
+    private static void setBackground(View target, Drawable drawable){
+        if(Build.VERSION.SDK_INT > 16){
+            target.setBackground(drawable);
+        }else{
+            target.setBackgroundDrawable(drawable);
+        }
+    }
+}
\ No newline at end of file
diff --git a/project/app/src/main/java/dreamers/graphics/SimpleAnimationListener.java b/project/app/src/main/java/dreamers/graphics/SimpleAnimationListener.java
deleted file mode 100644
index 5e80065f..00000000
--- a/project/app/src/main/java/dreamers/graphics/SimpleAnimationListener.java
+++ /dev/null
@@ -1,27 +0,0 @@
-package dreamers.graphics;
-
-import android.animation.Animator;
-
-
-public class SimpleAnimationListener implements Animator.AnimatorListener{
-
-    @Override
-    public void onAnimationStart(Animator animation) {
-
-    }
-
-    @Override
-    public void onAnimationEnd(Animator animation) {
-
-    }
-
-    @Override
-    public void onAnimationCancel(Animator animation) {
-
-    }
-
-    @Override
-    public void onAnimationRepeat(Animator animation) {
-
-    }
-}
diff --git a/project/app/src/main/java/dreamers/graphics/TouchTracker.java b/project/app/src/main/java/dreamers/graphics/TouchTracker.java
new file mode 100644
index 00000000..84025fa6
--- /dev/null
+++ b/project/app/src/main/java/dreamers/graphics/TouchTracker.java
@@ -0,0 +1,255 @@
+package dreamers.graphics;
+
+import android.view.MotionEvent;
+import android.view.View;
+import android.view.ViewConfiguration;
+
+import java.lang.ref.WeakReference;
+
+public class TouchTracker implements View.OnTouchListener{
+
+    RippleDrawable mHotspotDrawable;
+
+    PerformClick mPerformClick;
+    CheckForTap mPendingCheckForTap;
+    CheckForLongPress mPendingCheckForLongPress;
+    UnsetPressedState mUnsetPressedState;
+
+    boolean mHasPerformedLongPress;
+
+    int mTouchSlop;
+    boolean mPrePressed;
+    boolean mInsideScrollContainer;
+
+    public TouchTracker(RippleDrawable hotspot){
+        mHotspotDrawable = hotspot;
+
+        mTouchSlop = -1;
+    }
+
+    public void setInsideScrollContainer(boolean inside){
+        mInsideScrollContainer = inside;
+    }
+
+    @Override
+    public boolean onTouch(View v, MotionEvent event) {
+        final float x = event.getX();
+        final float y = event.getY();
+
+        if(v.isClickable() || v.isLongClickable()) {
+            switch (event.getAction()) {
+                case MotionEvent.ACTION_UP:
+                    if ((mPrePressed && pointInView(v, x, y, mTouchSlop)) || v.isPressed()) {
+                        // take focus if we don't have it already and we should in
+                        // touch mode.
+                        boolean focusTaken = false;
+                        if (v.isFocusable() && v.isFocusableInTouchMode() && !v.isFocused()) {
+                            focusTaken = v.requestFocus();
+                        }
+
+                        if (mPrePressed) {
+                            // The button is being released before we actually
+                            // showed it as pressed.  Make it show the pressed
+                            // state now (before scheduling the click) to ensure
+                            // the user sees it.
+                            setPressed(v, true, x, y);
+                        }
+
+                        if (!mHasPerformedLongPress) {
+                            // This is a tap, so remove the longpress check
+                            removeLongPressCallback(v);
+
+                            // Only perform take click actions if we were in the pressed state
+                            if (!focusTaken) {
+                                // Use a Runnable and post this rather than calling
+                                // performClick directly. This lets other visual state
+                                // of the view update before click actions start.
+                                if (mPerformClick == null) {
+                                    mPerformClick = new PerformClick(v);
+                                }
+                                if (!v.post(mPerformClick)) {
+                                    v.performClick();
+                                }
+                            }
+                        }
+
+                        if (mUnsetPressedState == null) {
+                            mUnsetPressedState = new UnsetPressedState(v);
+                        }
+
+                        if (mPrePressed) {
+                            v.postDelayed(mUnsetPressedState,
+                                    ViewConfiguration.getPressedStateDuration());
+                        } else if (!v.post(mUnsetPressedState)) {
+                            // If the post failed, unpress right now
+                            mUnsetPressedState.run();
+                        }
+
+                        removeTapCallback(v);
+
+                    }
+                    break;
+
+                case MotionEvent.ACTION_DOWN:
+                    mHasPerformedLongPress = false;
+
+                    if (mInsideScrollContainer) {
+
+                        mPrePressed = true;
+                        if (mPendingCheckForTap == null) {
+                            mPendingCheckForTap = new CheckForTap(v);
+                        }
+
+                        mPendingCheckForTap.x = event.getX();
+                        mPendingCheckForTap.y = event.getY();
+                        v.postDelayed(mPendingCheckForTap, ViewConfiguration.getTapTimeout());
+
+                    } else {
+                        setPressed(v, true, x, y);
+                        checkForLongClick(v, 0);
+                    }
+                    break;
+
+                case MotionEvent.ACTION_MOVE:
+                    mHotspotDrawable.setHotspot(x, y);
+
+                    if (mTouchSlop == -1) {
+                        mTouchSlop = ViewConfiguration.get(v.getContext()).getScaledTouchSlop();
+                    }
+
+                    // Be lenient about moving outside of buttons
+                    if (!pointInView(v, x, y, mTouchSlop)) {
+                        // Outside button
+                        removeTapCallback(v);
+                        if (v.isPressed()) {
+                            // Remove any future long press/tap checks
+                            removeLongPressCallback(v);
+
+                            v.setPressed(false);
+                        }
+                    }
+                    break;
+
+                case MotionEvent.ACTION_CANCEL:
+                    v.setPressed(false);
+                    removeTapCallback(v);
+                    removeLongPressCallback(v);
+                    break;
+            }
+            return true;
+        }
+
+        return false;
+    }
+
+    private void checkForLongClick(View target, int delayOffset) {
+        if (target.isLongClickable()) {
+            mHasPerformedLongPress = false;
+
+            if (mPendingCheckForLongPress == null) {
+                mPendingCheckForLongPress = new CheckForLongPress(target);
+            }
+            target.postDelayed(mPendingCheckForLongPress,
+                    ViewConfiguration.getLongPressTimeout() - delayOffset);
+        }
+    }
+
+    void setPressed(View target, boolean pressed, float x, float y){
+        target.setPressed(pressed);
+        mHotspotDrawable.setHotspot(x, y);
+    }
+
+    /**
+     * Utility method to determine whether the given point, in local coordinates,
+     * is inside the view, where the area of the view is expanded by the slop factor.
+     * This method is called while processing touch-move events to determine if the event
+     * is still within the view.
+     *
+     * @hide
+     */
+    public boolean pointInView(View target, float localX, float localY, float slop) {
+        return localX >= -slop && localY >= -slop && localX < ((target.getRight() - target.getLeft()) + slop) &&
+                localY < ((target.getBottom() - target.getTop()) + slop);
+    }
+
+
+    void removeTapCallback(View target){
+        if(mPendingCheckForTap != null){
+            target.removeCallbacks(mPendingCheckForTap);
+        }
+    }
+
+    void removeLongPressCallback(View target){
+        if (mPendingCheckForLongPress != null) {
+            target.removeCallbacks(mPendingCheckForLongPress);
+        }
+    }
+
+    private final static class PerformClick implements Runnable {
+
+        WeakReference<View> target;
+
+        private PerformClick(View target) {
+            this.target = new WeakReference<>(target);
+        }
+
+        @Override
+        public void run() {
+            if(target.get() != null){
+                target.get().performClick();
+            }
+        }
+    }
+
+
+    final class CheckForTap implements Runnable{
+
+        View target;
+        float x, y;
+
+        CheckForTap(View target) {
+            this.target = target;
+        }
+
+        @Override
+        public void run() {
+            mPrePressed = true;
+            setPressed(target, true, x, y);
+            checkForLongClick(target, ViewConfiguration.getTapTimeout());
+        }
+    }
+
+    private final class CheckForLongPress implements Runnable {
+
+        View target;
+
+        private CheckForLongPress(View target) {
+            this.target = target;
+        }
+
+        @Override
+        public void run() {
+            if (target.isPressed() && (target.getParent() != null)) {
+                if (target.performLongClick()) {
+                    mHasPerformedLongPress = true;
+                    mPrePressed = false;
+                }
+            }
+        }
+    }
+
+    private final class UnsetPressedState implements Runnable {
+
+        View target;
+
+        private UnsetPressedState(View target) {
+            this.target = target;
+        }
+
+        @Override
+        public void run() {
+            target.setPressed(false);
+        }
+    }
+
+}
diff --git a/project/app/src/main/java/org/apache/commons/lang/builder/HashCodeBuilder.java b/project/app/src/main/java/org/apache/commons/lang/builder/HashCodeBuilder.java
index 1e12243c..16066028 100644
--- a/project/app/src/main/java/org/apache/commons/lang/builder/HashCodeBuilder.java
+++ b/project/app/src/main/java/org/apache/commons/lang/builder/HashCodeBuilder.java
@@ -95,7 +95,7 @@ public class HashCodeBuilder {
      *
      * @since 2.3
      */
-    private static ThreadLocal registry = new ThreadLocal() {
+    private static final ThreadLocal registry = new ThreadLocal() {
         protected synchronized Object initialValue() {
             // The HashSet implementation is not synchronized,
             // which is just what we need here.
diff --git a/project/app/src/test/java/com/achep/acdisplay/AcDisplayRobolectricTest.java b/project/app/src/test/java/com/achep/acdisplay/AcDisplayRobolectricTest.java
index 8c0a2e80..71f97ea8 100644
--- a/project/app/src/test/java/com/achep/acdisplay/AcDisplayRobolectricTest.java
+++ b/project/app/src/test/java/com/achep/acdisplay/AcDisplayRobolectricTest.java
@@ -18,24 +18,18 @@
  */
 package com.achep.acdisplay;
 
-import android.app.Activity;
 import android.content.Context;
 import android.content.SharedPreferences;
 
-import com.achep.acdisplay.SharedList;
-import com.achep.acdisplay.utils.FileUtils;
+import com.achep.base.content.SharedList;
+import com.achep.base.utils.FileUtils;
 
 import org.junit.Test;
 import org.junit.runner.RunWith;
 import org.robolectric.Robolectric;
 import org.robolectric.RobolectricTestRunner;
-import org.robolectric.annotation.Config;
 
 import java.io.File;
-import java.lang.Double;
-import java.lang.Override;
-import java.lang.String;
-import java.lang.StringBuilder;
 import java.util.ArrayList;
 import java.util.Random;
 
@@ -130,7 +124,7 @@ public class AcDisplayRobolectricTest {
     }
 
     /**
-     * The most simple implementation of {@link com.achep.acdisplay.SharedList shared list}.
+     * The most simple implementation of {@link com.achep.base.content.SharedList shared list}.
      */
     private static class SharedListString extends SharedList<String, StringSaver> {
 
