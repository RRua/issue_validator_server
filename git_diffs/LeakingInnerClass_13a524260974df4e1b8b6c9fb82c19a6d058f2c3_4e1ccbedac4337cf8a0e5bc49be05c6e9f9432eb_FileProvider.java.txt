diff --git a/app/src/main/java/android/support/copied/FileProvider.java b/app/src/main/java/android/support/copied/FileProvider.java
deleted file mode 100644
index 4895841..0000000
--- a/app/src/main/java/android/support/copied/FileProvider.java
+++ /dev/null
@@ -1,823 +0,0 @@
-/*
- * Copyright (C) 2013 The Android Open Source Project
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- *      http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- */
-
-package android.support.copied;
-
-import static org.xmlpull.v1.XmlPullParser.END_DOCUMENT;
-import static org.xmlpull.v1.XmlPullParser.START_TAG;
-
-import android.content.ContentProvider;
-import android.content.ContentValues;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageManager;
-import android.content.pm.ProviderInfo;
-import android.content.res.XmlResourceParser;
-import android.database.Cursor;
-import android.database.MatrixCursor;
-import android.net.Uri;
-import android.os.Build;
-import android.os.Environment;
-import android.os.ParcelFileDescriptor;
-import android.provider.OpenableColumns;
-import android.text.TextUtils;
-import android.webkit.MimeTypeMap;
-
-import org.xmlpull.v1.XmlPullParserException;
-
-import java.io.File;
-import java.io.FileNotFoundException;
-import java.io.IOException;
-import java.util.HashMap;
-import java.util.Map;
-
-/**
- * FileProvider is a special subclass of {@link ContentProvider} that facilitates secure sharing
- * of files associated with an app by creating a <code>content://</code> {@link Uri} for a file
- * instead of a <code>file:///</code> {@link Uri}.
- * <p>
- * A content URI allows you to grant read and write access using
- * temporary access permissions. When you create an {@link Intent} containing
- * a content URI, in order to send the content URI
- * to a client app, you can also call {@link Intent#setFlags(int) Intent.setFlags()} to add
- * permissions. These permissions are available to the client app for as long as the stack for
- * a receiving {@link android.app.Activity} is active. For an {@link Intent} going to a
- * {@link android.app.Service}, the permissions are available as long as the
- * {@link android.app.Service} is running.
- * <p>
- * In comparison, to control access to a <code>file:///</code> {@link Uri} you have to modify the
- * file system permissions of the underlying file. The permissions you provide become available to
- * <em>any</em> app, and remain in effect until you change them. This level of access is
- * fundamentally insecure.
- * <p>
- * The increased level of file access security offered by a content URI
- * makes FileProvider a key part of Android's security infrastructure.
- * <p>
- * This overview of FileProvider includes the following topics:
- * </p>
- * <ol>
- *     <li><a href="#ProviderDefinition">Defining a FileProvider</a></li>
- *     <li><a href="#SpecifyFiles">Specifying Available Files</a></li>
- *     <li><a href="#GetUri">Retrieving the Content URI for a File</li>
- *     <li><a href="#Permissions">Granting Temporary Permissions to a URI</a></li>
- *     <li><a href="#ServeUri">Serving a Content URI to Another App</a></li>
- * </ol>
- * <h3 id="ProviderDefinition">Defining a FileProvider</h3>
- * <p>
- * Since the default functionality of FileProvider includes content URI generation for files, you
- * don't need to define a subclass in code. Instead, you can include a FileProvider in your app
- * by specifying it entirely in XML. To specify the FileProvider component itself, add a
- * <code><a href="{@docRoot}guide/topics/manifest/provider-element.html">&lt;provider&gt;</a></code>
- * element to your app manifest. Set the <code>android:name</code> attribute to
- * <code>android.support.v4.content.FileProvider</code>. Set the <code>android:authorities</code>
- * attribute to a URI authority based on a domain you control; for example, if you control the
- * domain <code>mydomain.com</code> you should use the authority
- * <code>com.mydomain.fileprovider</code>. Set the <code>android:exported</code> attribute to
- * <code>false</code>; the FileProvider does not need to be public. Set the
- * <a href="{@docRoot}guide/topics/manifest/provider-element.html#gprmsn"
- * >android:grantUriPermissions</a> attribute to <code>true</code>, to allow you
- * to grant temporary access to files. For example:
- * <pre class="prettyprint">
- *&lt;manifest&gt;
- *    ...
- *    &lt;application&gt;
- *        ...
- *        &lt;provider
- *            android:name="android.support.v4.content.FileProvider"
- *            android:authorities="com.mydomain.fileprovider"
- *            android:exported="false"
- *            android:grantUriPermissions="true"&gt;
- *            ...
- *        &lt;/provider&gt;
- *        ...
- *    &lt;/application&gt;
- *&lt;/manifest&gt;</pre>
- * <p>
- * If you want to override any of the default behavior of FileProvider methods, extend
- * the FileProvider class and use the fully-qualified class name in the <code>android:name</code>
- * attribute of the <code>&lt;provider&gt;</code> element.
- * <h3 id="SpecifyFiles">Specifying Available Files</h3>
- * A FileProvider can only generate a content URI for files in directories that you specify
- * beforehand. To specify a directory, specify the its storage area and path in XML, using child
- * elements of the <code>&lt;paths&gt;</code> element.
- * For example, the following <code>paths</code> element tells FileProvider that you intend to
- * request content URIs for the <code>images/</code> subdirectory of your private file area.
- * <pre class="prettyprint">
- *&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt;
- *    &lt;files-path name="my_images" path="images/"/&gt;
- *    ...
- *&lt;/paths&gt;
- *</pre>
- * <p>
- * The <code>&lt;paths&gt;</code> element must contain one or more of the following child elements:
- * </p>
- * <dl>
- *     <dt>
- * <pre class="prettyprint">
- *&lt;files-path name="<i>name</i>" path="<i>path</i>" /&gt;
- *</pre>
- *     </dt>
- *     <dd>
- *     Represents files in the <code>files/</code> subdirectory of your app's internal storage
- *     area. This subdirectory is the same as the value returned by {@link Context#getFilesDir()
- *     Context.getFilesDir()}.
- *     </dd>
- *     <dt>
- * <pre>
- *&lt;cache-path name="<i>name</i>" path="<i>path</i>" /&gt;
- *</pre>
- *     <dt>
- *     <dd>
- *     Represents files in the cache subdirectory of your app's internal storage area. The root path
- *     of this subdirectory is the same as the value returned by {@link Context#getCacheDir()
- *     getCacheDir()}.
- *     </dd>
- *     <dt>
- * <pre class="prettyprint">
- *&lt;external-path name="<i>name</i>" path="<i>path</i>" /&gt;
- *</pre>
- *     </dt>
- *     <dd>
- *     Represents files in the root of the external storage area. The root path of this subdirectory
- *     is the same as the value returned by
- *     {@link Environment#getExternalStorageDirectory() Environment.getExternalStorageDirectory()}.
- *     </dd>
- *     <dt>
- * <pre class="prettyprint">
- *&lt;external-files-path name="<i>name</i>" path="<i>path</i>" /&gt;
- *</pre>
- *     </dt>
- *     <dd>
- *     Represents files in the root of your app's external storage area. The root path of this
- *     subdirectory is the same as the value returned by
- *     {@code Context#getExternalFilesDir(String) Context.getExternalFilesDir(null)}.
- *     </dd>
- *     <dt>
- * <pre class="prettyprint">
- *&lt;external-cache-path name="<i>name</i>" path="<i>path</i>" /&gt;
- *</pre>
- *     </dt>
- *     <dd>
- *     Represents files in the root of your app's external cache area. The root path of this
- *     subdirectory is the same as the value returned by
- *     {@link Context#getExternalCacheDir() Context.getExternalCacheDir()}.
- *     </dd>
- * </dl>
- * <p>
- *     These child elements all use the same attributes:
- * </p>
- * <dl>
- *     <dt>
- *         <code>name="<i>name</i>"</code>
- *     </dt>
- *     <dd>
- *         A URI path segment. To enforce security, this value hides the name of the subdirectory
- *         you're sharing. The subdirectory name for this value is contained in the
- *         <code>path</code> attribute.
- *     </dd>
- *     <dt>
- *         <code>path="<i>path</i>"</code>
- *     </dt>
- *     <dd>
- *         The subdirectory you're sharing. While the <code>name</code> attribute is a URI path
- *         segment, the <code>path</code> value is an actual subdirectory name. Notice that the
- *         value refers to a <b>subdirectory</b>, not an individual file or files. You can't
- *         share a single file by its file name, nor can you specify a subset of files using
- *         wildcards.
- *     </dd>
- * </dl>
- * <p>
- * You must specify a child element of <code>&lt;paths&gt;</code> for each directory that contains
- * files for which you want content URIs. For example, these XML elements specify two directories:
- * <pre class="prettyprint">
- *&lt;paths xmlns:android="http://schemas.android.com/apk/res/android"&gt;
- *    &lt;files-path name="my_images" path="images/"/&gt;
- *    &lt;files-path name="my_docs" path="docs/"/&gt;
- *&lt;/paths&gt;
- *</pre>
- * <p>
- * Put the <code>&lt;paths&gt;</code> element and its children in an XML file in your project.
- * For example, you can add them to a new file called <code>res/xml/file_paths.xml</code>.
- * To link this file to the FileProvider, add a
- * <a href="{@docRoot}guide/topics/manifest/meta-data-element.html">&lt;meta-data&gt;</a> element
- * as a child of the <code>&lt;provider&gt;</code> element that defines the FileProvider. Set the
- * <code>&lt;meta-data&gt;</code> element's "android:name" attribute to
- * <code>android.support.FILE_PROVIDER_PATHS</code>. Set the element's "android:resource" attribute
- * to <code>&#64;xml/file_paths</code> (notice that you don't specify the <code>.xml</code>
- * extension). For example:
- * <pre class="prettyprint">
- *&lt;provider
- *    android:name="android.support.v4.content.FileProvider"
- *    android:authorities="com.mydomain.fileprovider"
- *    android:exported="false"
- *    android:grantUriPermissions="true"&gt;
- *    &lt;meta-data
- *        android:name="android.support.FILE_PROVIDER_PATHS"
- *        android:resource="&#64;xml/file_paths" /&gt;
- *&lt;/provider&gt;
- *</pre>
- * <h3 id="GetUri">Generating the Content URI for a File</h3>
- * <p>
- * To share a file with another app using a content URI, your app has to generate the content URI.
- * To generate the content URI, create a new {@link File} for the file, then pass the {@link File}
- * to {@link #getUriForFile(Context, String, File) getUriForFile()}. You can send the content URI
- * returned by {@link #getUriForFile(Context, String, File) getUriForFile()} to another app in an
- * {@link android.content.Intent}. The client app that receives the content URI can open the file
- * and access its contents by calling
- * {@link android.content.ContentResolver#openFileDescriptor(Uri, String)
- * ContentResolver.openFileDescriptor} to get a {@link ParcelFileDescriptor}.
- * <p>
- * For example, suppose your app is offering files to other apps with a FileProvider that has the
- * authority <code>com.mydomain.fileprovider</code>. To get a content URI for the file
- * <code>default_image.jpg</code> in the <code>images/</code> subdirectory of your internal storage
- * add the following code:
- * <pre class="prettyprint">
- *File imagePath = new File(Context.getFilesDir(), "images");
- *File newFile = new File(imagePath, "default_image.jpg");
- *Uri contentUri = getUriForFile(getContext(), "com.mydomain.fileprovider", newFile);
- *</pre>
- * As a result of the previous snippet,
- * {@link #getUriForFile(Context, String, File) getUriForFile()} returns the content URI
- * <code>content://com.mydomain.fileprovider/my_images/default_image.jpg</code>.
- * <h3 id="Permissions">Granting Temporary Permissions to a URI</h3>
- * To grant an access permission to a content URI returned from
- * {@link #getUriForFile(Context, String, File) getUriForFile()}, do one of the following:
- * <ul>
- * <li>
- *     Call the method
- *     {@link Context#grantUriPermission(String, Uri, int)
- *     Context.grantUriPermission(package, Uri, mode_flags)} for the <code>content://</code>
- *     {@link Uri}, using the desired mode flags. This grants temporary access permission for the
- *     content URI to the specified package, according to the value of the
- *     the <code>mode_flags</code> parameter, which you can set to
- *     {@link Intent#FLAG_GRANT_READ_URI_PERMISSION}, {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION}
- *     or both. The permission remains in effect until you revoke it by calling
- *     {@link Context#revokeUriPermission(Uri, int) revokeUriPermission()} or until the device
- *     reboots.
- * </li>
- * <li>
- *     Put the content URI in an {@link Intent} by calling {@link Intent#setData(Uri) setData()}.
- * </li>
- * <li>
- *     Next, call the method {@link Intent#setFlags(int) Intent.setFlags()} with either
- *     {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} or
- *     {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION} or both.
- * </li>
- * <li>
- *     Finally, send the {@link Intent} to
- *     another app. Most often, you do this by calling
- *     {@link android.app.Activity#setResult(int, android.content.Intent) setResult()}.
- *     <p>
- *     Permissions granted in an {@link Intent} remain in effect while the stack of the receiving
- *     {@link android.app.Activity} is active. When the stack finishes, the permissions are
- *     automatically removed. Permissions granted to one {@link android.app.Activity} in a client
- *     app are automatically extended to other components of that app.
- *     </p>
- * </li>
- * </ul>
- * <h3 id="ServeUri">Serving a Content URI to Another App</h3>
- * <p>
- * There are a variety of ways to serve the content URI for a file to a client app. One common way
- * is for the client app to start your app by calling
- * {@link android.app.Activity#startActivityForResult(Intent, int, Bundle) startActivityResult()},
- * which sends an {@link Intent} to your app to start an {@link android.app.Activity} in your app.
- * In response, your app can immediately return a content URI to the client app or present a user
- * interface that allows the user to pick a file. In the latter case, once the user picks the file
- * your app can return its content URI. In both cases, your app returns the content URI in an
- * {@link Intent} sent via {@link android.app.Activity#setResult(int, Intent) setResult()}.
- * </p>
- * <p>
- *  You can also put the content URI in a {@link android.content.ClipData} object and then add the
- *  object to an {@link Intent} you send to a client app. To do this, call
- *  {@link Intent#setClipData(ClipData) Intent.setClipData()}. When you use this approach, you can
- *  add multiple {@link android.content.ClipData} objects to the {@link Intent}, each with its own
- *  content URI. When you call {@link Intent#setFlags(int) Intent.setFlags()} on the {@link Intent}
- *  to set temporary access permissions, the same permissions are applied to all of the content
- *  URIs.
- * </p>
- * <p class="note">
- *  <strong>Note:</strong> The {@link Intent#setClipData(ClipData) Intent.setClipData()} method is
- *  only available in platform version 16 (Android 4.1) and later. If you want to maintain
- *  compatibility with previous versions, you should send one content URI at a time in the
- *  {@link Intent}. Set the action to {@link Intent#ACTION_SEND} and put the URI in data by calling
- *  {@link Intent#setData setData()}.
- * </p>
- * <h3 id="">More Information</h3>
- * <p>
- *    To learn more about FileProvider, see the Android training class
- *    <a href="{@docRoot}training/secure-file-sharing/index.html">Sharing Files Securely with URIs</a>.
- * </p>
- */
-public class FileProvider extends ContentProvider {
-    private static final String[] COLUMNS = {
-            OpenableColumns.DISPLAY_NAME, OpenableColumns.SIZE };
-
-    private static final String
-            META_DATA_FILE_PROVIDER_PATHS = "android.support.FILE_PROVIDER_PATHS";
-
-    private static final String TAG_ROOT_PATH = "root-path";
-    private static final String TAG_FILES_PATH = "files-path";
-    private static final String TAG_CACHE_PATH = "cache-path";
-    private static final String TAG_EXTERNAL = "external-path";
-    private static final String TAG_EXTERNAL_FILES = "external-files-path";
-    private static final String TAG_EXTERNAL_CACHE = "external-cache-path";
-
-    private static final String ATTR_NAME = "name";
-    private static final String ATTR_PATH = "path";
-
-    private static final File DEVICE_ROOT = new File("/");
-
-    // @GuardedBy("sCache")
-    private static HashMap<String, PathStrategy> sCache = new HashMap<String, PathStrategy>();
-
-    private PathStrategy mStrategy;
-
-    /**
-     * The default FileProvider implementation does not need to be initialized. If you want to
-     * override this method, you must provide your own subclass of FileProvider.
-     */
-    @Override
-    public boolean onCreate() {
-        return true;
-    }
-
-    /**
-     * After the FileProvider is instantiated, this method is called to provide the system with
-     * information about the provider.
-     *
-     * @param context A {@link Context} for the current component.
-     * @param info A {@link ProviderInfo} for the new provider.
-     */
-    @Override
-    public void attachInfo(Context context, ProviderInfo info) {
-        super.attachInfo(context, info);
-
-        // Sanity check our security
-        if (info.exported) {
-            throw new SecurityException("Provider must not be exported");
-        }
-        if (!info.grantUriPermissions) {
-            throw new SecurityException("Provider must grant uri permissions");
-        }
-
-        mStrategy = getPathStrategy(context, info.authority);
-    }
-
-    /**
-     * Return a content URI for a given {@link File}. Specific temporary
-     * permissions for the content URI can be set with
-     * {@link Context#grantUriPermission(String, Uri, int)}, or added
-     * to an {@link Intent} by calling {@link Intent#setData(Uri) setData()} and then
-     * {@link Intent#setFlags(int) setFlags()}; in both cases, the applicable flags are
-     * {@link Intent#FLAG_GRANT_READ_URI_PERMISSION} and
-     * {@link Intent#FLAG_GRANT_WRITE_URI_PERMISSION}. A FileProvider can only return a
-     * <code>content</code> {@link Uri} for file paths defined in their <code>&lt;paths&gt;</code>
-     * meta-data element. See the Class Overview for more information.
-     *
-     * @param context A {@link Context} for the current component.
-     * @param authority The authority of a {@link FileProvider} defined in a
-     *            {@code <provider>} element in your app's manifest.
-     * @param file A {@link File} pointing to the filename for which you want a
-     * <code>content</code> {@link Uri}.
-     * @return A content URI for the file.
-     * @throws IllegalArgumentException When the given {@link File} is outside
-     * the paths supported by the provider.
-     */
-    public static Uri getUriForFile(Context context, String authority, File file) {
-        final PathStrategy strategy = getPathStrategy(context, authority);
-        return strategy.getUriForFile(file);
-    }
-
-    /**
-     * Use a content URI returned by
-     * {@link #getUriForFile(Context, String, File) getUriForFile()} to get information about a file
-     * managed by the FileProvider.
-     * FileProvider reports the column names defined in {@link android.provider.OpenableColumns}:
-     * <ul>
-     * <li>{@link android.provider.OpenableColumns#DISPLAY_NAME}</li>
-     * <li>{@link android.provider.OpenableColumns#SIZE}</li>
-     * </ul>
-     * For more information, see
-     * {@link ContentProvider#query(Uri, String[], String, String[], String)
-     * ContentProvider.query()}.
-     *
-     * @param uri A content URI returned by {@link #getUriForFile}.
-     * @param projection The list of columns to put into the {@link Cursor}. If null all columns are
-     * included.
-     * @param selection Selection criteria to apply. If null then all data that matches the content
-     * URI is returned.
-     * @param selectionArgs An array of {@link java.lang.String}, containing arguments to bind to
-     * the <i>selection</i> parameter. The <i>query</i> method scans <i>selection</i> from left to
-     * right and iterates through <i>selectionArgs</i>, replacing the current "?" character in
-     * <i>selection</i> with the value at the current position in <i>selectionArgs</i>. The
-     * values are bound to <i>selection</i> as {@link java.lang.String} values.
-     * @param sortOrder A {@link java.lang.String} containing the column name(s) on which to sort
-     * the resulting {@link Cursor}.
-     * @return A {@link Cursor} containing the results of the query.
-     *
-     */
-    @Override
-    public Cursor query(Uri uri, String[] projection, String selection, String[] selectionArgs,
-                        String sortOrder) {
-        // ContentProvider has already checked granted permissions
-        final File file = mStrategy.getFileForUri(uri);
-
-        if (projection == null) {
-            projection = COLUMNS;
-        }
-
-        String[] cols = new String[projection.length];
-        Object[] values = new Object[projection.length];
-        int i = 0;
-        for (String col : projection) {
-            if (OpenableColumns.DISPLAY_NAME.equals(col)) {
-                cols[i] = OpenableColumns.DISPLAY_NAME;
-                values[i++] = file.getName();
-            } else if (OpenableColumns.SIZE.equals(col)) {
-                cols[i] = OpenableColumns.SIZE;
-                values[i++] = file.length();
-            }
-        }
-
-        cols = copyOf(cols, i);
-        values = copyOf(values, i);
-
-        final MatrixCursor cursor = new MatrixCursor(cols, 1);
-        cursor.addRow(values);
-        return cursor;
-    }
-
-    /**
-     * Returns the MIME type of a content URI returned by
-     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
-     *
-     * @param uri A content URI returned by
-     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
-     * @return If the associated file has an extension, the MIME type associated with that
-     * extension; otherwise <code>application/octet-stream</code>.
-     */
-    @Override
-    public String getType(Uri uri) {
-        // ContentProvider has already checked granted permissions
-        final File file = mStrategy.getFileForUri(uri);
-
-        final int lastDot = file.getName().lastIndexOf('.');
-        if (lastDot >= 0) {
-            final String extension = file.getName().substring(lastDot + 1);
-            final String mime = MimeTypeMap.getSingleton().getMimeTypeFromExtension(extension);
-            if (mime != null) {
-                return mime;
-            }
-        }
-
-        return "application/octet-stream";
-    }
-
-    /**
-     * By default, this method throws an {@link java.lang.UnsupportedOperationException}. You must
-     * subclass FileProvider if you want to provide different functionality.
-     */
-    @Override
-    public Uri insert(Uri uri, ContentValues values) {
-        throw new UnsupportedOperationException("No external inserts");
-    }
-
-    /**
-     * By default, this method throws an {@link java.lang.UnsupportedOperationException}. You must
-     * subclass FileProvider if you want to provide different functionality.
-     */
-    @Override
-    public int update(Uri uri, ContentValues values, String selection, String[] selectionArgs) {
-        throw new UnsupportedOperationException("No external updates");
-    }
-
-    /**
-     * Deletes the file associated with the specified content URI, as
-     * returned by {@link #getUriForFile(Context, String, File) getUriForFile()}. Notice that this
-     * method does <b>not</b> throw an {@link java.io.IOException}; you must check its return value.
-     *
-     * @param uri A content URI for a file, as returned by
-     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
-     * @param selection Ignored. Set to {@code null}.
-     * @param selectionArgs Ignored. Set to {@code null}.
-     * @return 1 if the delete succeeds; otherwise, 0.
-     */
-    @Override
-    public int delete(Uri uri, String selection, String[] selectionArgs) {
-        // ContentProvider has already checked granted permissions
-        final File file = mStrategy.getFileForUri(uri);
-        return file.delete() ? 1 : 0;
-    }
-
-    /**
-     * By default, FileProvider automatically returns the
-     * {@link ParcelFileDescriptor} for a file associated with a <code>content://</code>
-     * {@link Uri}. To get the {@link ParcelFileDescriptor}, call
-     * {@link android.content.ContentResolver#openFileDescriptor(Uri, String)
-     * ContentResolver.openFileDescriptor}.
-     *
-     * To override this method, you must provide your own subclass of FileProvider.
-     *
-     * @param uri A content URI associated with a file, as returned by
-     * {@link #getUriForFile(Context, String, File) getUriForFile()}.
-     * @param mode Access mode for the file. May be "r" for read-only access, "rw" for read and
-     * write access, or "rwt" for read and write access that truncates any existing file.
-     * @return A new {@link ParcelFileDescriptor} with which you can access the file.
-     */
-    @Override
-    public ParcelFileDescriptor openFile(Uri uri, String mode) throws FileNotFoundException {
-        // ContentProvider has already checked granted permissions
-        final File file = mStrategy.getFileForUri(uri);
-        final int fileMode = modeToMode(mode);
-        return ParcelFileDescriptor.open(file, fileMode);
-    }
-
-    /**
-     * Return {@link PathStrategy} for given authority, either by parsing or
-     * returning from cache.
-     */
-    private static PathStrategy getPathStrategy(Context context, String authority) {
-        PathStrategy strat;
-        synchronized (sCache) {
-            strat = sCache.get(authority);
-            if (strat == null) {
-                try {
-                    strat = parsePathStrategy(context, authority);
-                } catch (IOException e) {
-                    throw new IllegalArgumentException(
-                            "Failed to parse " + META_DATA_FILE_PROVIDER_PATHS + " meta-data", e);
-                } catch (XmlPullParserException e) {
-                    throw new IllegalArgumentException(
-                            "Failed to parse " + META_DATA_FILE_PROVIDER_PATHS + " meta-data", e);
-                }
-                sCache.put(authority, strat);
-            }
-        }
-        return strat;
-    }
-
-    /**
-     * Parse and return {@link PathStrategy} for given authority as defined in
-     * {@link #META_DATA_FILE_PROVIDER_PATHS} {@code <meta-data>}.
-     *
-     * @see #getPathStrategy(Context, String)
-     */
-    private static PathStrategy parsePathStrategy(Context context, String authority)
-            throws IOException, XmlPullParserException {
-        final SimplePathStrategy strat = new SimplePathStrategy(authority);
-
-        final ProviderInfo info = context.getPackageManager()
-                .resolveContentProvider(authority, PackageManager.GET_META_DATA);
-        final XmlResourceParser in = info.loadXmlMetaData(
-                context.getPackageManager(), META_DATA_FILE_PROVIDER_PATHS);
-        if (in == null) {
-            throw new IllegalArgumentException(
-                    "Missing " + META_DATA_FILE_PROVIDER_PATHS + " meta-data");
-        }
-
-        int type;
-        while ((type = in.next()) != END_DOCUMENT) {
-            if (type == START_TAG) {
-                final String tag = in.getName();
-
-                final String name = in.getAttributeValue(null, ATTR_NAME);
-                String path = in.getAttributeValue(null, ATTR_PATH);
-
-                File target = null;
-                if (TAG_ROOT_PATH.equals(tag)) {
-                    target = DEVICE_ROOT;
-                } else if (TAG_FILES_PATH.equals(tag)) {
-                    target = context.getFilesDir();
-                } else if (TAG_CACHE_PATH.equals(tag)) {
-                    target = context.getCacheDir();
-                } else if (TAG_EXTERNAL.equals(tag)) {
-                    target = Environment.getExternalStorageDirectory();
-                } else if (TAG_EXTERNAL_FILES.equals(tag)) {
-                    File[] externalFilesDirs = getExternalFilesDirs(context, null);
-                    if (externalFilesDirs.length > 0) {
-                        target = externalFilesDirs[0];
-                    }
-                } else if (TAG_EXTERNAL_CACHE.equals(tag)) {
-                    File[] externalCacheDirs = getExternalCacheDirs(context);
-                    if (externalCacheDirs.length > 0) {
-                        target = externalCacheDirs[0];
-                    }
-                }
-
-                if (target != null) {
-                    strat.addRoot(name, buildPath(target, path));
-                }
-            }
-        }
-
-        return strat;
-    }
-
-    public static File[] getExternalCacheDirs(Context context) {
-        if (Build.VERSION.SDK_INT >= 19) {
-            return context.getExternalCacheDirs();
-        } else {
-            return new File[] { context.getExternalCacheDir() };
-        }
-    }
-
-    public static File[] getExternalFilesDirs(Context context, String type) {
-        if (Build.VERSION.SDK_INT >= 19) {
-            return context.getExternalFilesDirs(type);
-        } else {
-            return new File[] { context.getExternalFilesDir(type) };
-        }
-    }
-
-    /**
-     * Strategy for mapping between {@link File} and {@link Uri}.
-     * <p>
-     * Strategies must be symmetric so that mapping a {@link File} to a
-     * {@link Uri} and then back to a {@link File} points at the original
-     * target.
-     * <p>
-     * Strategies must remain consistent across app launches, and not rely on
-     * dynamic state. This ensures that any generated {@link Uri} can still be
-     * resolved if your process is killed and later restarted.
-     *
-     * @see SimplePathStrategy
-     */
-    interface PathStrategy {
-        /**
-         * Return a {@link Uri} that represents the given {@link File}.
-         */
-        public Uri getUriForFile(File file);
-
-        /**
-         * Return a {@link File} that represents the given {@link Uri}.
-         */
-        public File getFileForUri(Uri uri);
-    }
-
-    /**
-     * Strategy that provides access to files living under a narrow whitelist of
-     * filesystem roots. It will throw {@link SecurityException} if callers try
-     * accessing files outside the configured roots.
-     * <p>
-     * For example, if configured with
-     * {@code addRoot("myfiles", context.getFilesDir())}, then
-     * {@code context.getFileStreamPath("foo.txt")} would map to
-     * {@code content://myauthority/myfiles/foo.txt}.
-     */
-    static class SimplePathStrategy implements PathStrategy {
-        private final String mAuthority;
-        private final HashMap<String, File> mRoots = new HashMap<String, File>();
-
-        public SimplePathStrategy(String authority) {
-            mAuthority = authority;
-        }
-
-        /**
-         * Add a mapping from a name to a filesystem root. The provider only offers
-         * access to files that live under configured roots.
-         */
-        public void addRoot(String name, File root) {
-            if (TextUtils.isEmpty(name)) {
-                throw new IllegalArgumentException("Name must not be empty");
-            }
-
-            try {
-                // Resolve to canonical path to keep path checking fast
-                root = root.getCanonicalFile();
-            } catch (IOException e) {
-                throw new IllegalArgumentException(
-                        "Failed to resolve canonical path for " + root, e);
-            }
-
-            mRoots.put(name, root);
-        }
-
-        @Override
-        public Uri getUriForFile(File file) {
-            String path;
-            try {
-                path = file.getCanonicalPath();
-            } catch (IOException e) {
-                throw new IllegalArgumentException("Failed to resolve canonical path for " + file);
-            }
-
-            // Find the most-specific root path
-            Map.Entry<String, File> mostSpecific = null;
-            for (Map.Entry<String, File> root : mRoots.entrySet()) {
-                final String rootPath = root.getValue().getPath();
-                if (path.startsWith(rootPath) && (mostSpecific == null
-                        || rootPath.length() > mostSpecific.getValue().getPath().length())) {
-                    mostSpecific = root;
-                }
-            }
-
-            if (mostSpecific == null) {
-                throw new IllegalArgumentException(
-                        "Failed to find configured root that contains " + path);
-            }
-
-            // Start at first char of path under root
-            final String rootPath = mostSpecific.getValue().getPath();
-            if (rootPath.endsWith("/")) {
-                path = path.substring(rootPath.length());
-            } else {
-                path = path.substring(rootPath.length() + 1);
-            }
-
-            // Encode the tag and path separately
-            path = Uri.encode(mostSpecific.getKey()) + '/' + Uri.encode(path, "/");
-            return new Uri.Builder().scheme("content")
-                    .authority(mAuthority).encodedPath(path).build();
-        }
-
-        @Override
-        public File getFileForUri(Uri uri) {
-            String path = uri.getEncodedPath();
-
-            final int splitIndex = path.indexOf('/', 1);
-            final String tag = Uri.decode(path.substring(1, splitIndex));
-            path = Uri.decode(path.substring(splitIndex + 1));
-
-            final File root = mRoots.get(tag);
-            if (root == null) {
-                throw new IllegalArgumentException("Unable to find configured root for " + uri);
-            }
-
-            File file = new File(root, path);
-            try {
-                file = file.getCanonicalFile();
-            } catch (IOException e) {
-                throw new IllegalArgumentException("Failed to resolve canonical path for " + file);
-            }
-
-            if (!file.getPath().startsWith(root.getPath())) {
-                throw new SecurityException("Resolved path jumped beyond configured root");
-            }
-
-            return file;
-        }
-    }
-
-    /**
-     * Copied from ContentResolver.java
-     */
-    private static int modeToMode(String mode) {
-        int modeBits;
-        if ("r".equals(mode)) {
-            modeBits = ParcelFileDescriptor.MODE_READ_ONLY;
-        } else if ("w".equals(mode) || "wt".equals(mode)) {
-            modeBits = ParcelFileDescriptor.MODE_WRITE_ONLY
-                    | ParcelFileDescriptor.MODE_CREATE
-                    | ParcelFileDescriptor.MODE_TRUNCATE;
-        } else if ("wa".equals(mode)) {
-            modeBits = ParcelFileDescriptor.MODE_WRITE_ONLY
-                    | ParcelFileDescriptor.MODE_CREATE
-                    | ParcelFileDescriptor.MODE_APPEND;
-        } else if ("rw".equals(mode)) {
-            modeBits = ParcelFileDescriptor.MODE_READ_WRITE
-                    | ParcelFileDescriptor.MODE_CREATE;
-        } else if ("rwt".equals(mode)) {
-            modeBits = ParcelFileDescriptor.MODE_READ_WRITE
-                    | ParcelFileDescriptor.MODE_CREATE
-                    | ParcelFileDescriptor.MODE_TRUNCATE;
-        } else {
-            throw new IllegalArgumentException("Invalid mode: " + mode);
-        }
-        return modeBits;
-    }
-
-    private static File buildPath(File base, String... segments) {
-        File cur = base;
-        for (String segment : segments) {
-            if (segment != null) {
-                cur = new File(cur, segment);
-            }
-        }
-        return cur;
-    }
-
-    private static String[] copyOf(String[] original, int newLength) {
-        final String[] result = new String[newLength];
-        System.arraycopy(original, 0, result, 0, newLength);
-        return result;
-    }
-
-    private static Object[] copyOf(Object[] original, int newLength) {
-        final Object[] result = new Object[newLength];
-        System.arraycopy(original, 0, result, 0, newLength);
-        return result;
-    }
-}
diff --git a/app/src/main/java/com/kanedias/vanilla/coverfetch/CoverArchiveEngine.java b/app/src/main/java/com/kanedias/vanilla/coverfetch/CoverArchiveEngine.java
index 7f0a6c2..524a551 100644
--- a/app/src/main/java/com/kanedias/vanilla/coverfetch/CoverArchiveEngine.java
+++ b/app/src/main/java/com/kanedias/vanilla/coverfetch/CoverArchiveEngine.java
@@ -23,12 +23,28 @@ import javax.net.ssl.HttpsURLConnection;
  */
 public class CoverArchiveEngine implements CoverEngine {
 
+    private static final String USER_AGENT = "Vanilla Cover Fetch (https://github.com/vanilla-music)";
+
     private static final String TAG = CoverArchiveEngine.class.getSimpleName();
 
     @Override
     public byte[] getCover(String artistName, String albumName) {
         try {
-            return makeApiCall(artistName, albumName);
+            String releaseGroupQuery = String.format("releasegroup:%s AND artistname:%s", albumName, artistName);
+            return makeApiCall(releaseGroupQuery);
+        } catch (IOException e) {
+            Log.w(TAG, "Couldn't connect to musicbrainz/coverartarchive REST endpoints", e);
+            return null;
+        } catch (JSONException e) {
+            Log.w(TAG, "Couldn't transform API answer to JSON entity", e);
+            return null;
+        }
+    }
+
+    @Override
+    public byte[] getCover(String query) {
+        try {
+            return makeApiCall(query);
         } catch (IOException e) {
             Log.w(TAG, "Couldn't connect to musicbrainz/coverartarchive REST endpoints", e);
             return null;
@@ -41,23 +57,23 @@ public class CoverArchiveEngine implements CoverEngine {
     /**
      * First call
      */
-    private byte[] makeApiCall(String artistName, String albumName) throws IOException, JSONException {
+    private byte[] makeApiCall(String query) throws IOException, JSONException {
         HttpsURLConnection apiCall = null;
         try {
             // build query
             // e.g. https://musicbrainz.org/ws/2/release-group/?query=releasegroup:new%20divide%20AND%20artist:linkin%20park&limit=3&fmt=json
-            String releaseGroupQuery = String.format("releasegroup:%s AND artistname:%s", albumName, artistName);
             Uri link = new Uri.Builder()
                     .scheme("https")
                     .authority("musicbrainz.org")
                     .path("ws/2/release-group/")
-                    .appendQueryParameter("query", releaseGroupQuery)
+                    .appendQueryParameter("query", query)
                     .appendQueryParameter("limit", "3")
                     .appendQueryParameter("fmt", "json")
                     .build();
 
             // construct an http request
             apiCall = (HttpsURLConnection) new URL(link.toString()).openConnection();
+            apiCall.setRequestProperty("User-Agent", USER_AGENT);
             apiCall.setReadTimeout(10_000);
             apiCall.setConnectTimeout(15_000);
 
@@ -107,6 +123,7 @@ public class CoverArchiveEngine implements CoverEngine {
                         .build();
 
                 imgCall = (HttpURLConnection) new URL(imgLink.toString()).openConnection();
+                imgCall.setRequestProperty("User-Agent", USER_AGENT);
                 imgCall.setReadTimeout(10_000);
                 imgCall.setConnectTimeout(15_000);
 
diff --git a/app/src/main/java/com/kanedias/vanilla/coverfetch/CoverEngine.java b/app/src/main/java/com/kanedias/vanilla/coverfetch/CoverEngine.java
index b53c251..901bac3 100644
--- a/app/src/main/java/com/kanedias/vanilla/coverfetch/CoverEngine.java
+++ b/app/src/main/java/com/kanedias/vanilla/coverfetch/CoverEngine.java
@@ -31,8 +31,16 @@ public interface CoverEngine {
      * or {@link Loader}
      * @param artistName band or artist name to search for
      * @param albumName full album name to search for
-     * @return string containing album cover if available, null if nothing found
+     * @return byte array containing album cover if available, null if nothing found
      */
     byte[] getCover(String artistName, String albumName);
 
+    /**
+     * Synchronous call to engine to retrieve cover. Most likely to be used in {@link HandlerThread}
+     * or {@link Loader}
+     * @param query raw query to search for
+     * @return byte array containing album cover if available, null if nothing found
+     */
+    byte[] getCover(String query);
+
 }
diff --git a/app/src/main/java/com/kanedias/vanilla/coverfetch/CoverFetchUtils.java b/app/src/main/java/com/kanedias/vanilla/coverfetch/CoverFetchUtils.java
deleted file mode 100644
index 3a72de9..0000000
--- a/app/src/main/java/com/kanedias/vanilla/coverfetch/CoverFetchUtils.java
+++ /dev/null
@@ -1,41 +0,0 @@
-package com.kanedias.vanilla.coverfetch;
-
-import android.content.Context;
-import android.content.pm.PackageManager;
-import android.os.Build;
-
-import java.io.File;
-
-/**
- * Common routines needed for operation of plugin
- *
- * @author Oleg Chernovskiy
- */
-
-public class CoverFetchUtils {
-
-    /**
-     * Check if Android Storage Access Framework routines apply here
-     * @return true if document seems to be SAF-accessible only, false otherwise
-     */
-    public static boolean isSafNeeded(File file) {
-        // on external SD card after KitKat this will return false
-        return !file.canWrite() && Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
-    }
-
-    /**
-     * Checks if all required permissions have been granted
-     *
-     * @param context The context to use
-     * @return boolean true if all permissions have been granded
-     */
-    public static boolean havePermissions(Context context, String perm) {
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-            if (context.checkSelfPermission(perm) != PackageManager.PERMISSION_GRANTED) {
-                return false;
-            }
-        } // else: granted during installation
-        return true;
-    }
-
-}
diff --git a/app/src/main/java/com/kanedias/vanilla/coverfetch/CoverShowActivity.java b/app/src/main/java/com/kanedias/vanilla/coverfetch/CoverShowActivity.java
index a9eaef3..697f524 100644
--- a/app/src/main/java/com/kanedias/vanilla/coverfetch/CoverShowActivity.java
+++ b/app/src/main/java/com/kanedias/vanilla/coverfetch/CoverShowActivity.java
@@ -21,7 +21,6 @@ import android.app.AlertDialog;
 import android.content.DialogInterface;
 import android.content.Intent;
 import android.content.SharedPreferences;
-import android.content.pm.PackageManager;
 import android.graphics.Bitmap;
 import android.graphics.BitmapFactory;
 import android.graphics.drawable.BitmapDrawable;
@@ -29,21 +28,20 @@ import android.graphics.drawable.Drawable;
 import android.media.MediaScannerConnection;
 import android.net.Uri;
 import android.os.AsyncTask;
-import android.os.Build;
 import android.os.Bundle;
 import android.os.ParcelFileDescriptor;
 import android.preference.PreferenceManager;
-import android.support.annotation.NonNull;
 import android.support.annotation.Nullable;
-import android.support.copied.FileProvider;
+import android.support.v4.content.FileProvider;
 import android.support.v4.provider.DocumentFile;
 import android.text.TextUtils;
 import android.util.Log;
+import android.view.KeyEvent;
 import android.view.View;
-import android.widget.Button;
-import android.widget.ImageView;
-import android.widget.Toast;
-import android.widget.ViewSwitcher;
+import android.view.Window;
+import android.widget.*;
+import com.kanedias.vanilla.plugins.PluginUtils;
+import com.kanedias.vanilla.plugins.saf.SafRequestActivity;
 
 import java.io.*;
 import java.util.ArrayList;
@@ -52,9 +50,10 @@ import java.util.List;
 import java.util.UUID;
 
 import static android.Manifest.permission.WRITE_EXTERNAL_STORAGE;
-import static com.kanedias.vanilla.coverfetch.PluginConstants.*;
-import static com.kanedias.vanilla.coverfetch.PluginService.PREF_SDCARD_URI;
+import static com.kanedias.vanilla.plugins.PluginConstants.*;
 import static com.kanedias.vanilla.coverfetch.PluginService.pluginInstalled;
+import static com.kanedias.vanilla.plugins.PluginUtils.*;
+import static com.kanedias.vanilla.plugins.saf.SafUtils.isSafNeeded;
 
 /**
  * Main activity of Cover Fetch plugin. This will be presented as a dialog to the user
@@ -67,13 +66,13 @@ import static com.kanedias.vanilla.coverfetch.PluginService.pluginInstalled;
  */
 public class CoverShowActivity extends Activity {
 
-    private static final int PERMISSIONS_REQUEST_CODE = 0;
-
     private SharedPreferences mPrefs;
 
     private ImageView mCoverImage;
     private ViewSwitcher mSwitcher;
-    private Button mOkButton, mWriteButton;
+    private Button mOkButton, mWriteButton, mCustomButton;
+    private EditText mCustomSearch;
+    private ProgressBar mProgressBar;
 
     private CoverEngine mEngine = new CoverArchiveEngine();
 
@@ -88,6 +87,9 @@ public class CoverShowActivity extends Activity {
         mCoverImage = (ImageView) findViewById(R.id.cover_image);
         mWriteButton = (Button) findViewById(R.id.write_button);
         mOkButton = (Button) findViewById(R.id.ok_button);
+        mCustomButton = (Button) findViewById(R.id.custom_button);
+        mProgressBar = (ProgressBar) findViewById(R.id.progress_bar);
+        mCustomSearch = (EditText) findViewById(R.id.search_custom);
 
         setupUI();
         handlePassedIntent(); // called in onCreate to be shown only once
@@ -97,27 +99,64 @@ public class CoverShowActivity extends Activity {
         // check if this is an answer from tag plugin
         if (TextUtils.equals(getIntent().getStringExtra(EXTRA_PARAM_P2P), P2P_READ_ART)) {
             // already checked this string in service, no need in additional checks
-            Uri imgLink = getIntent().getParcelableExtra(EXTRA_PARAM_P2P_VAL);
+            if (loadFromTag()) {
+                return;
+            }
+        }
 
-            try {
-                ParcelFileDescriptor pfd = getContentResolver().openFileDescriptor(imgLink, "r");
-                if (pfd == null) {
-                    return;
-                }
+        // we didn't receive artwork from tag plugin
 
-                Bitmap raw = BitmapFactory.decodeFileDescriptor(pfd.getFileDescriptor());
-                setCoverImage(raw);
-            } catch (FileNotFoundException e) {
-                Log.e(PluginConstants.LOG_TAG, "Passed Uri points to invalid fd! " + imgLink, e);
-            }
+        // try to retrieve from folder.jpg
+        if (loadFromFile()) {
             return;
         }
 
-        mWriteButton.setVisibility(View.VISIBLE);
-        mWriteButton.setOnClickListener(new SelectWriteAction());
+        // try to retrieve it via artwork engine
+        String artist = getIntent().getStringExtra(EXTRA_PARAM_SONG_ARTIST);
+        String album = getIntent().getStringExtra(EXTRA_PARAM_SONG_ALBUM);
+        new ArtworkFetcher().execute(artist, album);
+    }
+
+    private boolean loadFromTag() {
+        Uri imgLink = getIntent().getParcelableExtra(EXTRA_PARAM_P2P_VAL);
+        try {
+            ParcelFileDescriptor pfd = getContentResolver().openFileDescriptor(imgLink, "r");
+            if (pfd == null) {
+                return false;
+            }
+
+            Bitmap raw = BitmapFactory.decodeFileDescriptor(pfd.getFileDescriptor());
+            if (raw == null) {
+                return false;
+            }
+
+            setCoverImage(raw);
+            return true;
+        } catch (FileNotFoundException e) {
+            Log.e(LOG_TAG, "Passed Uri points to invalid fd! " + imgLink, e);
+        }
+        return false;
+    }
+
+    private boolean loadFromFile() {
+        if (!PluginUtils.havePermissions(this, WRITE_EXTERNAL_STORAGE)) {
+            return false;
+        }
+
+        Uri fileUri = getIntent().getParcelableExtra(EXTRA_PARAM_URI);
+        File media = new File(fileUri.getPath());
+        File folderJpg = new File(media.getParentFile(), "folder.jpg");
+        if (!folderJpg.exists()) {
+            return false;
+        }
+
+        Bitmap raw = BitmapFactory.decodeFile(folderJpg.getPath());
+        if (raw == null) {
+            return false;
+        }
 
-        // we didn't receive artwork from tag plugin, try to retrieve it via artwork engine
-        new ArtworkFetcher().execute(getIntent());
+        setCoverImage(raw);
+        return true;
     }
 
     private void setCoverImage(Bitmap raw) {
@@ -129,7 +168,7 @@ public class CoverShowActivity extends Activity {
         Drawable image = new BitmapDrawable(getResources(), raw);
         mCoverImage.setImageDrawable(image);
         mWriteButton.setEnabled(true);
-        mSwitcher.showNext();
+        mSwitcher.setDisplayedChild(1);
     }
 
     /**
@@ -142,26 +181,47 @@ public class CoverShowActivity extends Activity {
                 finish();
             }
         });
+        mWriteButton.setOnClickListener(new SelectWriteAction());
+        mCustomSearch.setOnEditorActionListener(new CustomSearchQueryListener());
+        mCustomButton.setOnClickListener(new View.OnClickListener() {
+            @Override
+            public void onClick(View v) {
+                mCustomSearch.setVisibility(mCustomSearch.getVisibility() == View.VISIBLE ? View.GONE : View.VISIBLE);
+            }
+        });
     }
 
     /**
      * External artwork fetcher (using network). Operates asynchronously, notifies dialog when finishes.
      * On no result (no artwork, couldn't fetch etc.) shows toast about this, on success updates dialog text.
      */
-    private class ArtworkFetcher extends AsyncTask<Intent, Void, byte[]> {
+    private class ArtworkFetcher extends AsyncTask<String, Void, byte[]> {
+        @Override
+        protected void onPreExecute() {
+            mSwitcher.setDisplayedChild(0);
+            mProgressBar.setVisibility(View.VISIBLE);
+        }
 
         @Override
-        protected byte[] doInBackground(Intent... params) {
-            String artist = getIntent().getStringExtra(EXTRA_PARAM_SONG_ARTIST);
-            String album = getIntent().getStringExtra(EXTRA_PARAM_SONG_ALBUM);
-            return mEngine.getCover(artist, album);
+        protected byte[] doInBackground(String... params) {
+            if (params.length == 1) {
+                return mEngine.getCover(params[0]);
+            }
+
+            if (params.length == 2) {
+                // artist, album
+                return mEngine.getCover(params[0], params[1]);
+            }
+
+            return null;
         }
 
         @Override
         protected void onPostExecute(byte[] imgData) {
+            mProgressBar.setVisibility(View.INVISIBLE);
+
             if(imgData == null || imgData.length == 0) {
                 // no artwork - show excuse
-                finish();
                 Toast.makeText(CoverShowActivity.this, R.string.cover_not_found, Toast.LENGTH_SHORT).show();
                 return;
             }
@@ -236,18 +296,17 @@ public class CoverShowActivity extends Activity {
             return;
         }
 
-        File folderTarget = new File(mediaFile.getParent(), "folder.jpg");
-
         // image must be present because this button enables only after it's downloaded
         Bitmap bitmap = ((BitmapDrawable) mCoverImage.getDrawable()).getBitmap();
         ByteArrayOutputStream stream = new ByteArrayOutputStream();
         bitmap.compress(Bitmap.CompressFormat.JPEG, 90, stream);
         byte[] imgData = stream.toByteArray();
 
-        if (CoverFetchUtils.isSafNeeded(folderTarget)) {
+        File folderTarget = new File(mediaFile.getParent(), "folder.jpg");
+        if (isSafNeeded(folderTarget)) {
             if (mPrefs.contains(PREF_SDCARD_URI)) {
                 // we already got the permission!
-                writeThroughSaf(imgData, mediaFile, folderTarget);
+                writeThroughSaf(imgData, mediaFile, folderTarget.getName());
                 return;
             }
 
@@ -268,32 +327,33 @@ public class CoverShowActivity extends Activity {
     /**
      * Write changes through SAF framework - the only way to do it in Android > 4.4 when working with SD card
      */
-    private void writeThroughSaf(byte[] data, File original, File target) {
-        Uri safUri;
+    private void writeThroughSaf(byte[] data, File original, String name) {
+        DocumentFile originalRef;
         if (mPrefs.contains(PREF_SDCARD_URI)) {
             // no sorcery can allow you to gain URI to the document representing file you've been provided with
             // you have to find it again now using Document API
 
             // /storage/volume/Music/some.mp3 will become [storage, volume, music, some.mp3]
-            List<String> pathSegments = new ArrayList<>(Arrays.asList(target.getAbsolutePath().split("/")));
+            List<String> pathSegments = new ArrayList<>(Arrays.asList(original.getAbsolutePath().split("/")));
             Uri allowedSdRoot = Uri.parse(mPrefs.getString(PREF_SDCARD_URI, ""));
-            safUri = findInDocumentTree(DocumentFile.fromTreeUri(this, allowedSdRoot), pathSegments);
+            originalRef = findInDocumentTree(DocumentFile.fromTreeUri(this, allowedSdRoot), pathSegments);
         } else {
             // user will click the button again
             return;
         }
 
-        if (safUri == null) {
+        if (originalRef == null) {
             // nothing selected or invalid file?
             Toast.makeText(this, R.string.saf_nothing_selected, Toast.LENGTH_LONG).show();
             return;
         }
 
+        DocumentFile folderJpgRef = originalRef.getParentFile().createFile("image/*", name);
         try {
-            ParcelFileDescriptor pfd = getContentResolver().openFileDescriptor(safUri, "rw");
+            ParcelFileDescriptor pfd = getContentResolver().openFileDescriptor(folderJpgRef.getUri(), "rw");
             if (pfd == null) {
                 // should not happen
-                Log.e(LOG_TAG, "SAF provided incorrect URI!" + safUri);
+                Log.e(LOG_TAG, "SAF provided incorrect URI!" + folderJpgRef.getUri());
                 return;
             }
 
@@ -315,10 +375,10 @@ public class CoverShowActivity extends Activity {
      * files such as "/a/b/c.mp3" and "/b/a/c.mp3", but I consider it complete enough to be usable.
      * @param currentDir - document file representing current dir of search
      * @param remainingPathSegments - path segments that are left to find
-     * @return URI for found file. Null if nothing found.
+     * @return Document file representing a target
      */
     @Nullable
-    private Uri findInDocumentTree(DocumentFile currentDir, List<String> remainingPathSegments) {
+    private DocumentFile findInDocumentTree(DocumentFile currentDir, List<String> remainingPathSegments) {
         for (DocumentFile file : currentDir.listFiles()) {
             int index = remainingPathSegments.indexOf(file.getName());
             if (index == -1) {
@@ -332,7 +392,7 @@ public class CoverShowActivity extends Activity {
 
             if (file.isFile() && index == remainingPathSegments.size() - 1) {
                 // got to the last part
-                return file.getUri();
+                return file;
             }
         }
 
@@ -361,21 +421,8 @@ public class CoverShowActivity extends Activity {
     }
 
     /**
-     * Checks for permission and requests it if needed.
-     * You should catch answer back in {@link #onRequestPermissionsResult(int, String[], int[])}
-     * <br/>
-     * (Or don't. This way request will appear forever as {@link #onResume()} will never end)
-     * @param perm permission to request
-     * @return true if this app had this permission prior to check, false otherwise.
+     * Listener which invokes action dialog on click with selection on where to write the retrieved cover
      */
-    private boolean checkAndRequestPermissions(String perm) {
-        if (!CoverFetchUtils.havePermissions(this, perm)  && Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-            requestPermissions(new String[]{perm}, PERMISSIONS_REQUEST_CODE);
-            return false;
-        }
-        return true;
-    }
-
     private class SelectWriteAction implements View.OnClickListener {
 
         @Override
@@ -395,7 +442,7 @@ public class CoverShowActivity extends Activity {
                             switch (which) {
                                 case 0: // to folder
                                     // onResume will fire both on first launch and on return from permission request
-                                    if (!checkAndRequestPermissions(WRITE_EXTERNAL_STORAGE)) {
+                                    if (!checkAndRequestPermissions(CoverShowActivity.this, WRITE_EXTERNAL_STORAGE)) {
                                         return;
                                     }
 
@@ -409,4 +456,16 @@ public class CoverShowActivity extends Activity {
                     }).create().show();
         }
     }
+
+    /**
+     * Listener which submits query to the artwork execution engine
+     */
+    private class CustomSearchQueryListener implements TextView.OnEditorActionListener {
+
+        @Override
+        public boolean onEditorAction(TextView v, int actionId, KeyEvent event) {
+            new ArtworkFetcher().execute(v.getText().toString());
+            return true;
+        }
+    }
 }
diff --git a/app/src/main/java/com/kanedias/vanilla/coverfetch/PluginConstants.java b/app/src/main/java/com/kanedias/vanilla/coverfetch/PluginConstants.java
deleted file mode 100644
index 37dbb19..0000000
--- a/app/src/main/java/com/kanedias/vanilla/coverfetch/PluginConstants.java
+++ /dev/null
@@ -1,54 +0,0 @@
-/*
- * Copyright (C) 2016 Oleg Chernovskiy <adonai@xaker.ru>
- *
- * This program is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *
- * This program is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
- * GNU General Public License for more details.
- *
- * You should have received a copy of the GNU General Public License
- * along with this program. If not, see <http://www.gnu.org/licenses/>.
- */
-package com.kanedias.vanilla.coverfetch;
-
-/**
- * This class constants should be synchronized with VanillaMusic <code>PluginUtils</code> class
- */
-public class PluginConstants {
-
-    private PluginConstants() {
-    }
-
-    // these actions are for passing between main player and plugins
-    static final String ACTION_REQUEST_PLUGIN_PARAMS = "ch.blinkenlights.android.vanilla.action.REQUEST_PLUGIN_PARAMS"; // broadcast
-    static final String ACTION_HANDLE_PLUGIN_PARAMS = "ch.blinkenlights.android.vanilla.action.HANDLE_PLUGIN_PARAMS"; // answer
-    static final String ACTION_WAKE_PLUGIN = "ch.blinkenlights.android.vanilla.action.WAKE_PLUGIN"; // targeted for each found
-    static final String ACTION_LAUNCH_PLUGIN = "ch.blinkenlights.android.vanilla.action.LAUNCH_PLUGIN"; // targeted at selected by user
-
-    // these are used by plugins to describe themselves
-    static final String EXTRA_PARAM_PLUGIN_NAME = "ch.blinkenlights.android.vanilla.extra.PLUGIN_NAME";
-    static final String EXTRA_PARAM_PLUGIN_APP = "ch.blinkenlights.android.vanilla.extra.PLUGIN_APP";
-    static final String EXTRA_PARAM_PLUGIN_DESC = "ch.blinkenlights.android.vanilla.extra.PLUGIN_DESC";
-
-    // this is passed to plugin when it is selected by user
-    static final String EXTRA_PARAM_URI = "ch.blinkenlights.android.vanilla.extra.URI";
-    static final String EXTRA_PARAM_SONG_TITLE = "ch.blinkenlights.android.vanilla.extra.SONG_TITLE";
-    static final String EXTRA_PARAM_SONG_ALBUM = "ch.blinkenlights.android.vanilla.extra.SONG_ALBUM";
-    static final String EXTRA_PARAM_SONG_ARTIST = "ch.blinkenlights.android.vanilla.extra.SONG_ARTIST";
-
-    // plugin-to-plugin extras (pass EXTRA_PARAM_PLUGIN_APP too to know whom to answer)
-    static final String EXTRA_PARAM_P2P = "ch.blinkenlights.android.vanilla.extra.P2P"; // marker
-    static final String EXTRA_PARAM_P2P_KEY = "ch.blinkenlights.android.vanilla.extra.P2P_KEY";
-    static final String EXTRA_PARAM_P2P_VAL = "ch.blinkenlights.android.vanilla.extra.P2P_VALUE";
-
-    // related to tag editor
-    static final String P2P_WRITE_ART = "WRITE_ART";
-    static final String P2P_READ_ART = "READ_ART";
-
-    static final String LOG_TAG = "Vanilla:CoverFetch";
-}
diff --git a/app/src/main/java/com/kanedias/vanilla/coverfetch/PluginQueryBroadcastReceiver.java b/app/src/main/java/com/kanedias/vanilla/coverfetch/PluginQueryBroadcastReceiver.java
index d58f527..29733aa 100644
--- a/app/src/main/java/com/kanedias/vanilla/coverfetch/PluginQueryBroadcastReceiver.java
+++ b/app/src/main/java/com/kanedias/vanilla/coverfetch/PluginQueryBroadcastReceiver.java
@@ -21,6 +21,8 @@ import android.content.Context;
 import android.content.Intent;
 import android.util.Log;
 
+import com.kanedias.vanilla.plugins.PluginConstants;
+
 /**
  * Broadcast receiver used for retrieving query intents
  *
diff --git a/app/src/main/java/com/kanedias/vanilla/coverfetch/PluginService.java b/app/src/main/java/com/kanedias/vanilla/coverfetch/PluginService.java
index 50878bc..511fe48 100644
--- a/app/src/main/java/com/kanedias/vanilla/coverfetch/PluginService.java
+++ b/app/src/main/java/com/kanedias/vanilla/coverfetch/PluginService.java
@@ -20,14 +20,14 @@ import android.app.Service;
 import android.content.Context;
 import android.content.Intent;
 import android.content.pm.ResolveInfo;
-import android.net.Uri;
 import android.os.IBinder;
 import android.text.TextUtils;
 import android.util.Log;
+import com.kanedias.vanilla.plugins.PluginConstants;
 
 import java.util.List;
 
-import static com.kanedias.vanilla.coverfetch.PluginConstants.*;
+import static com.kanedias.vanilla.plugins.PluginConstants.*;
 
 /**
  * Main service of Plugin system.
@@ -60,10 +60,6 @@ public class PluginService extends Service {
 
     public static final String PLUGIN_TAG_EDIT_PKG = "com.kanedias.vanilla.audiotag";
 
-    static final String EXTRA_PARAM_SAF_P2P = "ch.blinkenlights.android.vanilla.extra.SAF_P2P";
-
-    static final String PREF_SDCARD_URI = "ch.blinkenlights.android.vanilla.pref.SDCARD_URI";
-
     private Intent mOriginalIntent;
 
     @Override
diff --git a/app/src/main/java/com/kanedias/vanilla/coverfetch/SafRequestActivity.java b/app/src/main/java/com/kanedias/vanilla/coverfetch/SafRequestActivity.java
deleted file mode 100644
index a2835f1..0000000
--- a/app/src/main/java/com/kanedias/vanilla/coverfetch/SafRequestActivity.java
+++ /dev/null
@@ -1,106 +0,0 @@
-package com.kanedias.vanilla.coverfetch;
-
-import android.annotation.TargetApi;
-import android.app.Activity;
-import android.app.AlertDialog;
-import android.content.*;
-import android.net.Uri;
-import android.os.Build;
-import android.os.IBinder;
-import android.preference.PreferenceManager;
-import android.widget.Toast;
-
-import java.io.File;
-
-import static com.kanedias.vanilla.coverfetch.PluginConstants.ACTION_LAUNCH_PLUGIN;
-import static com.kanedias.vanilla.coverfetch.PluginConstants.EXTRA_PARAM_URI;
-
-/**
- * Activity that is needed solely for requesting SAF permissions for external SD cards.
- *
- * @author  Kanedias on 17.02.17.
- */
-public class SafRequestActivity extends Activity {
-
-    private static final int SAF_TREE_REQUEST_CODE = 2;
-
-    /**
-     * File to search access for
-     */
-    private SharedPreferences mPrefs;
-
-
-    @Override
-    protected void onResume() {
-        super.onResume();
-
-        mPrefs = PreferenceManager.getDefaultSharedPreferences(this);
-
-        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.LOLLIPOP) {
-            // it's Lollipop - let's request tree URI instead of nitpicking with specific files...
-            // deal with file passed after request is fulfilled
-            callSafRequestTree();
-            return;
-        }
-    }
-
-    /**
-     * Call tree-picker to select root of SD card.
-     * Shows a hint how to do this, continues if "ok" is clicked.
-     */
-    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
-    private void callSafRequestTree() {
-        new AlertDialog.Builder(this)
-                .setTitle(R.string.need_sd_card_access)
-                .setIcon(R.drawable.icon)
-                .setView(R.layout.sd_operate_instructions)
-                .setNegativeButton(android.R.string.cancel, new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        finish();
-                    }
-                })
-                .setPositiveButton(android.R.string.ok, new DialogInterface.OnClickListener() {
-                    @Override
-                    public void onClick(DialogInterface dialog, int which) {
-                        Intent selectFile = new Intent(Intent.ACTION_OPEN_DOCUMENT_TREE);
-                        startActivityForResult(selectFile, SAF_TREE_REQUEST_CODE);
-                    }
-                })
-                .create()
-                .show();
-    }
-
-    /**
-     * Mostly this is needed for SAF support. If the file is located on external SD card then android provides
-     * only Storage Access Framework to be able to write anything.
-     * @param requestCode our sent code
-     * @param resultCode success or error
-     * @param data URI-containing intent
-     */
-    @Override
-    protected void onActivityResult(int requestCode, int resultCode, Intent data) {
-        Intent serviceStart = new Intent(this, PluginService.class);
-        serviceStart.setAction(ACTION_LAUNCH_PLUGIN);
-        serviceStart.putExtras(getIntent());
-        serviceStart.putExtra(PluginService.EXTRA_PARAM_SAF_P2P, data);
-
-        if (requestCode == SAF_TREE_REQUEST_CODE && resultCode == Activity.RESULT_OK) {
-            saveTreeAccessForever(data);
-            finish();
-        }
-
-    }
-
-    /**
-     * Saves SAF-provided tree URI forever
-     * @param data intent containing tree URI in data
-     */
-    @TargetApi(Build.VERSION_CODES.LOLLIPOP)
-    private void saveTreeAccessForever(Intent data) {
-        Uri treeAccessUri = data.getData();
-        getContentResolver().takePersistableUriPermission(treeAccessUri, Intent.FLAG_GRANT_WRITE_URI_PERMISSION | Intent.FLAG_GRANT_READ_URI_PERMISSION);
-        mPrefs.edit().putString(PluginService.PREF_SDCARD_URI, treeAccessUri.toString()).apply();
-    }
-
-}
