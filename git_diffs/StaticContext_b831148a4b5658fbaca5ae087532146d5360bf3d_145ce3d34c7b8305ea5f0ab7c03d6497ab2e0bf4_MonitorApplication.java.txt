diff --git a/app/src/main/java/ca/farrelltonsolar/classic/BundleTypeAdapterFactory.java b/app/src/main/java/ca/farrelltonsolar/classic/BundleTypeAdapterFactory.java
new file mode 100644
index 0000000..ad24309
--- /dev/null
+++ b/app/src/main/java/ca/farrelltonsolar/classic/BundleTypeAdapterFactory.java
@@ -0,0 +1,177 @@
+package ca.farrelltonsolar.classic;
+
+/*
+ * Copyright (C) 2015 Gson Type Adapter Authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+import android.os.Bundle;
+import android.os.Parcelable;
+import android.util.Pair;
+
+import com.google.gson.Gson;
+import com.google.gson.TypeAdapter;
+import com.google.gson.TypeAdapterFactory;
+import com.google.gson.reflect.TypeToken;
+import com.google.gson.stream.JsonReader;
+import com.google.gson.stream.JsonToken;
+import com.google.gson.stream.JsonWriter;
+
+import java.io.IOException;
+import java.util.ArrayList;
+import java.util.List;
+
+/**
+ * Type adapter for Android Bundle. It only stores the actual properties set in the bundle
+ *
+ * @author Inderjeet Singh
+ */
+public class BundleTypeAdapterFactory implements TypeAdapterFactory {
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public <T> TypeAdapter<T> create(final Gson gson, TypeToken<T> type) {
+        if (!Bundle.class.isAssignableFrom(type.getRawType())) {
+            return null;
+        }
+        return (TypeAdapter<T>) new TypeAdapter<Bundle>() {
+            @Override public void write(JsonWriter out, Bundle bundle) throws IOException {
+                if (bundle == null) {
+                    out.nullValue();
+                    return;
+                }
+                out.beginObject();
+                for (String key : bundle.keySet()) {
+                    out.name(key);
+                    Object value = bundle.get(key);
+                    if (value == null) {
+                        out.nullValue();
+                    } else {
+                        gson.toJson(value, value.getClass(), out);
+                    }
+                }
+                out.endObject();
+            }
+
+            @Override public Bundle read(JsonReader in) throws IOException {
+                switch (in.peek()) {
+                    case NULL:
+                        in.nextNull();
+                        return null;
+                    case BEGIN_OBJECT:
+                        return toBundle(readObject(in));
+                    default: throw new IOException("expecting object: " + in.getPath());
+                }
+            }
+
+            private Bundle toBundle(List<Pair<String, Object>> values) throws IOException {
+                Bundle bundle = new Bundle();
+                for (Pair<String, Object> entry : values) {
+                    String key = entry.first;
+                    Object value = entry.second;
+                    if (value instanceof String) {
+                        bundle.putString(key, (String) value);
+                    } else if (value instanceof Integer) {
+                        bundle.putInt(key, ((Integer)value).intValue());
+                    } else if (value instanceof Boolean) {
+                        bundle.putBoolean(key, ((Boolean)value).booleanValue());
+                    } else if (value instanceof Long) {
+                        bundle.putLong(key, ((Long)value).longValue());
+                    } else if (value instanceof Float) {
+                        bundle.putFloat(key, ((Float) value).floatValue());
+                    } else if (value instanceof Double) {
+                        bundle.putDouble(key, ((Double) value).doubleValue());
+                    } else if (value instanceof Parcelable) {
+                        bundle.putParcelable(key, (Parcelable)value);
+                    } else if (value instanceof List) {
+                        List<Pair<String, Object>> objectValues = (List<Pair<String, Object>>) value;
+                        Bundle subBundle = toBundle(objectValues);
+                        bundle.putParcelable(key, subBundle);
+                    } else {
+                        throw new IOException("Unparcelable key, value: " + key + ", "+ value);
+                    }
+                }
+                return bundle;
+            }
+
+            private List<Pair<String, Object>> readObject(JsonReader in) throws IOException {
+                List<Pair<String, Object>> object = new ArrayList<Pair<String, Object>>();
+                in.beginObject();
+                while (in.peek() != JsonToken.END_OBJECT) {
+                    switch (in.peek()) {
+                        case NAME:
+                            String name = in.nextName();
+                            Object value = readValue(in);
+                            object.add(new Pair<String, Object>(name, value));
+                            break;
+                        case END_OBJECT:
+                            break;
+                        default: throw new IOException("expecting object: " + in.getPath());
+                    }
+                }
+                in.endObject();
+                return object;
+            }
+
+            private Object readValue(JsonReader in) throws IOException {
+                switch (in.peek()) {
+                    case BEGIN_ARRAY:
+                        return readArray(in);
+                    case BEGIN_OBJECT:
+                        return readObject(in);
+                    case BOOLEAN:
+                        return in.nextBoolean();
+                    case NULL:
+                        in.nextNull();
+                        return null;
+                    case NUMBER:
+                        return readNumber(in);
+                    case STRING:
+                        return in.nextString();
+                    default: throw new IOException("expecting value: " + in.getPath());
+                }
+            }
+
+            private Object readNumber(JsonReader in) throws IOException {
+                String res = in.nextString();
+                if (res.contains(".")) {
+                    return Float.parseFloat(res);
+                }
+                else {
+                    return Integer.parseInt(res);
+                }
+//                double doubleValue = in.nextDouble();
+//                if (doubleValue - Math.ceil(doubleValue) == 0) {
+//                    long longValue = (long) doubleValue;
+//                    if (longValue >= Integer.MIN_VALUE && longValue <= Integer.MAX_VALUE) {
+//                        return (int) longValue;
+//                    }
+//                    return longValue;
+//                }
+//                return doubleValue;
+            }
+
+            @SuppressWarnings("rawtypes")
+            private List readArray(JsonReader in) throws IOException {
+                List list = new ArrayList();
+                in.beginArray();
+                while (in.peek() != JsonToken.END_ARRAY) {
+                    Object element = readValue(in);
+                    list.add(element);
+                }
+                in.endArray();
+                return list;
+            }
+        };
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/ca/farrelltonsolar/classic/ChargeControllerInfo.java b/app/src/main/java/ca/farrelltonsolar/classic/ChargeControllerInfo.java
index ba33f11..79bc13e 100644
--- a/app/src/main/java/ca/farrelltonsolar/classic/ChargeControllerInfo.java
+++ b/app/src/main/java/ca/farrelltonsolar/classic/ChargeControllerInfo.java
@@ -299,5 +299,40 @@ public class ChargeControllerInfo implements Serializable {
         }
     }
 
+    public ChargeControllerTransfer GetTransfer() {
+        ChargeControllerTransfer tranfer = new ChargeControllerTransfer();
+        tranfer.unitID = unitID();
+        tranfer.deviceName = deviceName();
+        tranfer.hasWhizbang = hasWhizbang();
+        tranfer.deviceType = deviceType;
+        tranfer.model = model;
+        tranfer.lastVOC = lastVOC;
+        tranfer.appVersion = appVersion;
+        tranfer.netVersion = netVersion;
+        tranfer.buildDate = buildDate;
+        tranfer.nominalBatteryVoltage = nominalBatteryVoltage;
+        tranfer.mpptMode = mpptMode;
+        tranfer.endingAmps = endingAmps;
+        return tranfer;
+    }
+
+    public void LoadTransfer(ChargeControllerTransfer tranfer) {
+        unitID = tranfer.unitID;
+        deviceName = tranfer.deviceName;
+        hasWhizbang = tranfer.hasWhizbang;
+        deviceType = tranfer.deviceType;
+        model= tranfer.model;
+        lastVOC = tranfer.lastVOC;
+        appVersion = tranfer.appVersion;
+        netVersion = tranfer.netVersion;
+        buildDate = tranfer.buildDate;
+        nominalBatteryVoltage = tranfer.nominalBatteryVoltage;
+        mpptMode = tranfer.mpptMode;
+        endingAmps = tranfer.endingAmps;
+        isCurrent = true;
+        isReachable = true;
+        deviceIpAddress = "MQTT broker";
+        return;
+    }
 }
 
diff --git a/app/src/main/java/ca/farrelltonsolar/classic/ChargeControllerTransfer.java b/app/src/main/java/ca/farrelltonsolar/classic/ChargeControllerTransfer.java
new file mode 100644
index 0000000..14caa4d
--- /dev/null
+++ b/app/src/main/java/ca/farrelltonsolar/classic/ChargeControllerTransfer.java
@@ -0,0 +1,18 @@
+package ca.farrelltonsolar.classic;
+
+public class ChargeControllerTransfer {
+
+    public int unitID;
+    public String deviceName = "";
+    public boolean hasWhizbang;
+    public DeviceType deviceType;
+    public String model;
+    public float lastVOC;
+    public String appVersion;
+    public String netVersion;
+    public String buildDate;
+    public int nominalBatteryVoltage;
+    public int mpptMode;
+    public float endingAmps;
+
+}
diff --git a/app/src/main/java/ca/farrelltonsolar/classic/ChargeControllers.java b/app/src/main/java/ca/farrelltonsolar/classic/ChargeControllers.java
index 80f77a2..0959541 100644
--- a/app/src/main/java/ca/farrelltonsolar/classic/ChargeControllers.java
+++ b/app/src/main/java/ca/farrelltonsolar/classic/ChargeControllers.java
@@ -38,6 +38,12 @@ public final class ChargeControllers {
     private boolean uploadToPVOutput = false;
     private boolean bidirectionalUnitsInWatts;
     private boolean systemViewEnabled = false;
+    private String mqttBrokerHost = "";
+    private int mqttPort;
+    private String mqttUser = "";
+    private String mqttPassword = "";
+    private String mqttRootTopic = "";
+    private MQTT_Type mqttType = MQTT_Type.Off;
     private PVOutputSetting pVOutputSetting = new PVOutputSetting();
 
     // default ctor for de-serialization
@@ -289,4 +295,65 @@ public final class ChargeControllers {
             }
         }
     }
+
+    public synchronized MQTT_Type mqttType() {
+        return mqttType;
+    }
+
+    public synchronized boolean setMQTT_Type(MQTT_Type mqttType) {
+        boolean rVal = this.mqttType != mqttType;
+        this.mqttType = mqttType;
+        return rVal;
+    }
+
+    public synchronized String mqttBrokerHost() {
+        return mqttBrokerHost;
+    }
+
+    public synchronized boolean setMqttBrokerHost(String brokerHost) {
+        boolean rVal = this.mqttBrokerHost != brokerHost;
+        this.mqttBrokerHost = brokerHost;
+        return rVal;
+    }
+
+    public synchronized int mqttPort() {
+        return mqttPort;
+    }
+
+    public synchronized boolean setMqttPort(int mqttPort) {
+        boolean rVal = this.mqttPort != mqttPort;
+        this.mqttPort = mqttPort;
+        return rVal;
+    }
+
+    public synchronized String mqttUser() {
+        return mqttUser;
+    }
+
+    public synchronized boolean setMqttUser(String mqttUser) {
+        boolean rVal = this.mqttUser != mqttUser;
+        this.mqttUser = mqttUser;
+        return rVal;
+    }
+
+    public synchronized String mqttRootTopic() {
+        return mqttRootTopic;
+    }
+
+    public synchronized boolean setMqttRootTopic(String mqttRootTopic) {
+        boolean rVal = this.mqttRootTopic != mqttRootTopic;
+        this.mqttRootTopic = mqttRootTopic;
+        return rVal;
+    }
+
+    public synchronized String mqttPassword() {
+        return mqttPassword;
+    }
+
+    public synchronized boolean setMqttPassword(String mqttPassword) {
+        boolean rVal = this.mqttPassword != mqttPassword;
+        this.mqttPassword = mqttPassword;
+        return rVal;
+    }
+
 }
diff --git a/app/src/main/java/ca/farrelltonsolar/classic/ComplexPreferences.java b/app/src/main/java/ca/farrelltonsolar/classic/ComplexPreferences.java
index 92743e3..78aea99 100644
--- a/app/src/main/java/ca/farrelltonsolar/classic/ComplexPreferences.java
+++ b/app/src/main/java/ca/farrelltonsolar/classic/ComplexPreferences.java
@@ -30,14 +30,12 @@ import com.google.gson.Gson;
 public class ComplexPreferences {
 
     private static ComplexPreferences complexPreferences;
-    private Context context;
     private SharedPreferences preferences;
     private SharedPreferences.Editor editor;
     private static Gson GSON = new Gson();
     private String namePreferences;
 
     private ComplexPreferences(Context context, String namePreferences, int mode) {
-        this.context = context;
         if (namePreferences == null || namePreferences.equals("")) {
 //            namePreferences = context.getPackageName() + getVersion(context) + "_complexPreferences";
             namePreferences = context.getPackageName() + "211_complexPreferences";
diff --git a/app/src/main/java/ca/farrelltonsolar/classic/Constants.java b/app/src/main/java/ca/farrelltonsolar/classic/Constants.java
index 1898fd7..a1fe05c 100644
--- a/app/src/main/java/ca/farrelltonsolar/classic/Constants.java
+++ b/app/src/main/java/ca/farrelltonsolar/classic/Constants.java
@@ -71,4 +71,10 @@ public class Constants {
     public static final String CA_FARRELLTONSOLAR_CLASSIC_UPDATE_CHARGE_CONTROLLERS = "ca.farrelltonsolar.classic.UpdateChargeControllers";
     public static final String CA_FARRELLTONSOLAR_CLASSIC_MONITOR_CHARGE_CONTROLLER = "ca.farrelltonsolar.classic.MonitorChargeController";
 
+    //MQTT
+    public static final String CLIENT_ID = "Classic";
+    public static final String STAT_TOPIC_SUFFIX = "classic/stat";
+    public static final String CMND_TOPIC_SUFFIX = "classic/cmnd";
+    public static final long MQTT_IDLE_DELAY = 60000;
+
 }
diff --git a/app/src/main/java/ca/farrelltonsolar/classic/MQTT_Type.java b/app/src/main/java/ca/farrelltonsolar/classic/MQTT_Type.java
new file mode 100644
index 0000000..3062321
--- /dev/null
+++ b/app/src/main/java/ca/farrelltonsolar/classic/MQTT_Type.java
@@ -0,0 +1,7 @@
+package ca.farrelltonsolar.classic;
+
+public enum MQTT_Type {
+    Off,
+    Subscriber,
+    Publisher
+}
\ No newline at end of file
diff --git a/app/src/main/java/ca/farrelltonsolar/classic/MonitorActivity.java b/app/src/main/java/ca/farrelltonsolar/classic/MonitorActivity.java
index 612c2d1..fd5a627 100644
--- a/app/src/main/java/ca/farrelltonsolar/classic/MonitorActivity.java
+++ b/app/src/main/java/ca/farrelltonsolar/classic/MonitorActivity.java
@@ -114,9 +114,7 @@ public class MonitorActivity extends AppCompatActivity {
             }
             tabStripAdapter.addTab("RealTimeChart", R.string.RealTimeChartTabTitle, LiveChartFragment.class, null);
             tabStripAdapter.addTab("Temperature", TemperatureFragment.TabTitle, TemperatureFragment.class, null);
-            tabStripAdapter.addTab("DayChart", R.string.DayChartTabTitle, DayLogChart.class, null);
-            tabStripAdapter.addTab("HourChart", R.string.HourChartTabTitle, HourLogChart.class, null);
-            addDayLogCalendar();
+            AddCharts();
             tabStripAdapter.addTab("Info", R.string.InfoTabTitle, InfoFragment.class, null);
             tabStripAdapter.addTab("Messages", R.string.MessagesTabTitle, MessageFragment.class, null);
             tabStripAdapter.addTab("About", R.string.About, About.class, null);
@@ -143,9 +141,7 @@ public class MonitorActivity extends AppCompatActivity {
             tabStripAdapter.addTab("StateOfCharge", StateOfChargeFragment.TabTitle, StateOfChargeFragment.class, null);
             tabStripAdapter.addTab("RealTimeChart", R.string.RealTimeChartTabTitle, LiveChartFragment.class, null);
             tabStripAdapter.addTab("Temperature", TemperatureFragment.TabTitle, TemperatureFragment.class, null);
-            tabStripAdapter.addTab("DayChart", R.string.DayChartTabTitle, DayLogChart.class, null);
-            tabStripAdapter.addTab("HourChart",R.string.HourChartTabTitle, HourLogChart.class, null);
-            addDayLogCalendar();
+            AddCharts();
             tabStripAdapter.addTab("Info", R.string.InfoTabTitle, InfoFragment.class, null);
             tabStripAdapter.addTab("Messages", R.string.MessagesTabTitle, MessageFragment.class, null);
             tabStripAdapter.addTab("About", R.string.About, About.class, null);
@@ -163,6 +159,15 @@ public class MonitorActivity extends AppCompatActivity {
         return true;
     }
 
+    private void AddCharts() {
+        // no chart data over MQTT yet
+        if (MonitorApplication.chargeControllers().mqttType() != MQTT_Type.Subscriber) {
+            tabStripAdapter.addTab("DayChart", R.string.DayChartTabTitle, DayLogChart.class, null);
+            tabStripAdapter.addTab("HourChart", R.string.HourChartTabTitle, HourLogChart.class, null);
+            addDayLogCalendar();
+        }
+    }
+
     private void addDayLogCalendar() {
         if (Build.VERSION.SDK_INT >= 17) {
             tabStripAdapter.addTab("Calendar", R.string.DayLogTabTitle, MonthCalendarPager.class, null);
diff --git a/app/src/main/java/ca/farrelltonsolar/classic/MonitorApplication.java b/app/src/main/java/ca/farrelltonsolar/classic/MonitorApplication.java
index 58728a7..a2c8754 100644
--- a/app/src/main/java/ca/farrelltonsolar/classic/MonitorApplication.java
+++ b/app/src/main/java/ca/farrelltonsolar/classic/MonitorApplication.java
@@ -16,8 +16,10 @@
 
 package ca.farrelltonsolar.classic;
 
-import android.app.Activity;
 import android.app.Application;
+import android.arch.lifecycle.LifecycleObserver;
+import android.arch.lifecycle.LifecycleOwner;
+import android.arch.lifecycle.OnLifecycleEvent;
 import android.content.BroadcastReceiver;
 import android.content.ComponentName;
 import android.content.Context;
@@ -32,8 +34,20 @@ import android.support.v4.content.LocalBroadcastManager;
 import android.util.Log;
 import android.util.Pair;
 import android.widget.Toast;
+import android.arch.lifecycle.ProcessLifecycleOwner;
 
 import com.google.gson.Gson;
+import com.google.gson.GsonBuilder;
+
+import org.eclipse.paho.android.service.MqttAndroidClient;
+import org.eclipse.paho.client.mqttv3.DisconnectedBufferOptions;
+import org.eclipse.paho.client.mqttv3.IMqttActionListener;
+import org.eclipse.paho.client.mqttv3.IMqttDeliveryToken;
+import org.eclipse.paho.client.mqttv3.IMqttToken;
+import org.eclipse.paho.client.mqttv3.MqttCallbackExtended;
+import org.eclipse.paho.client.mqttv3.MqttConnectOptions;
+import org.eclipse.paho.client.mqttv3.MqttException;
+import org.eclipse.paho.client.mqttv3.MqttMessage;
 
 import java.util.HashMap;
 import java.util.Locale;
@@ -41,12 +55,15 @@ import java.util.Map;
 import java.util.Timer;
 import java.util.TimerTask;
 
+import static android.arch.lifecycle.Lifecycle.Event.ON_START;
+import static android.arch.lifecycle.Lifecycle.Event.ON_STOP;
+
 /**
  * Created by Graham on 26/12/13.
  */
-public class MonitorApplication extends Application implements Application.ActivityLifecycleCallbacks {
-    private static Context context;
 
+public class MonitorApplication extends Application implements LifecycleObserver {
+    private static MonitorApplication instance;
     static Map<Integer, String> chargeStates = new HashMap<Integer, String>();
     static Map<Integer, String> chargeStateTitles = new HashMap<Integer, String>();
     static Map<Integer, String> mpptModes = new HashMap<Integer, String>();
@@ -55,33 +72,25 @@ public class MonitorApplication extends Application implements Application.Activ
     static UDPListener UDPListenerService;
     static boolean isUDPListenerServiceBound = false;
     private static ChargeControllers chargeControllers;
-    private static Gson GSON = new Gson();
-    ComplexPreferences configuration;
-    WifiManager.WifiLock wifiLock;
+    private GsonBuilder gsonBuilder;
     ModbusService modbusService;
     static boolean isModbusServiceBound = false;
-    private Timer disconnectTimer;
+    WifiManager.WifiLock wifiLock;
+    private MqttAndroidClient mqttClient;
+    private String statTopic;
+    private String cmndTopic;
+    private long mqttPublishPeriod;
+    private boolean mqttIdle = true;
+    private Timer mqttWakeTimer;
 
-    @Override
-    protected void finalize() throws Throwable {
-        try {
-            if (isUDPListenerServiceBound) {
-                UDPListenerService.stopListening();
-                unbindService(UDPListenerServiceConnection);
-            }
-            if (isModbusServiceBound) {
-                unbindService(modbusServiceConnection);
-            }
-        } catch (Exception ex) {
-            Log.w(getClass().getName(), "onActivityDestroyed exception ex: " + ex);
-        }
-        super.finalize();
+    public MonitorApplication() {
+        super();
     }
 
     public void onCreate() {
         super.onCreate();
 
-        MonitorApplication.context = getApplicationContext();
+        instance = this;
         if (Constants.DEVELOPER_MODE) {
             StrictMode.enableDefaults();
         }
@@ -90,36 +99,384 @@ public class MonitorApplication extends Application implements Application.Activ
         InitializeMPPTModes();
         InitializeMessageLookup();
         InitializeReasonsForRestingLookup();
+        gsonBuilder = new GsonBuilder();
+        gsonBuilder.registerTypeAdapterFactory(new BundleTypeAdapterFactory());
         try {
-            configuration = ComplexPreferences.getComplexPreferences(this, null, Context.MODE_PRIVATE);
+            ComplexPreferences configuration = ComplexPreferences.getComplexPreferences(this, null, Context.MODE_PRIVATE);
             chargeControllers = configuration.getObject("devices", ChargeControllers.class);
-        }
-        catch (Exception ex) {
+        } catch (Exception ex) {
             Log.w(getClass().getName(), "getComplexPreferences failed to load");
             chargeControllers = null;
         }
         if (chargeControllers == null) { // save empty collection
-            chargeControllers = new ChargeControllers(context);
+            chargeControllers = new ChargeControllers(getApplicationContext());
         }
-        if (chargeControllers.uploadToPVOutput()) {
-            try {
-                startService(new Intent(this, PVOutputService.class)); // start PVOutputService intent service
+        ProcessLifecycleOwner.get().getLifecycle().addObserver(this);
+        if (chargeControllers.mqttType() != MQTT_Type.Subscriber) {  // do not use PVOutput & Modbus when MQTT subscriber
+            WifiManager wifi = (WifiManager) MonitorApplication.getAppContext().getApplicationContext().getSystemService(Context.WIFI_SERVICE);
+            chargeControllers = MonitorApplication.chargeControllers();
+            if (chargeControllers.mqttType() != MQTT_Type.Subscriber) {
+                if (wifi != null) {
+                    wifiLock = wifi.createWifiLock("ClassicMonitor");
+                }
             }
-            catch (Exception ex) {
-                Log.w(getClass().getName(), "Failed to start PVOutput service");
-                Toast.makeText(getApplicationContext(), "Failed to start PVOutput service", Toast.LENGTH_SHORT).show();
+            if (chargeControllers.uploadToPVOutput()) {
+                try {
+                    startService(new Intent(this, PVOutputService.class)); // start PVOutputService intent service
+                } catch (Exception ex) {
+                    Log.w(getClass().getName(), "Failed to start PVOutput service");
+                    Toast.makeText(getApplicationContext(), "Failed to start PVOutput service", Toast.LENGTH_SHORT).show();
+                }
             }
+            bindService(new Intent(this, UDPListener.class), UDPListenerServiceConnection, Context.BIND_AUTO_CREATE);
+            bindService(new Intent(this, ModbusService.class), modbusServiceConnection, Context.BIND_AUTO_CREATE);
         }
-        this.registerActivityLifecycleCallbacks(this);
-        bindService(new Intent(this, UDPListener.class), UDPListenerServiceConnection, Context.BIND_AUTO_CREATE);
-        WifiManager wifi = (WifiManager)getSystemService(Context.WIFI_SERVICE);
-        if (wifi != null){
-            wifiLock = wifi.createWifiLock("ClassicMonitor");
+        String rootTopic = chargeControllers.mqttRootTopic();
+        if (rootTopic.endsWith("/") == false) {
+            rootTopic += "/";
         }
-        bindService(new Intent(this, ModbusService.class), modbusServiceConnection, Context.BIND_AUTO_CREATE);
+        statTopic = String.format("%s%s", rootTopic, Constants.STAT_TOPIC_SUFFIX);
+        cmndTopic = String.format("%s%s", rootTopic, Constants.CMND_TOPIC_SUFFIX);
+        mqttPublishPeriod = System.currentTimeMillis();
         Log.d(getClass().getName(), "onCreate complete");
     }
 
+    @OnLifecycleEvent(ON_START)
+    void onStart(LifecycleOwner source) {
+        Log.d(getClass().getName(), "onStart event");
+        if (wifiLock != null) {
+            wifiLock.acquire();
+        }
+        if (chargeControllers.mqttType() != MQTT_Type.Subscriber) {
+            LocalBroadcastManager.getInstance(this).registerReceiver(addChargeControllerReceiver, new IntentFilter(Constants.CA_FARRELLTONSOLAR_CLASSIC_ADD_CHARGE_CONTROLLER));
+            LocalBroadcastManager.getInstance(this).registerReceiver(removeChargeControllerReceiver, new IntentFilter(Constants.CA_FARRELLTONSOLAR_CLASSIC_REMOVE_CHARGE_CONTROLLER));
+            if (isModbusServiceBound && modbusService != null) {
+                modbusService.monitorChargeControllers(chargeControllers());
+            } else {
+                bindService(new Intent(this, ModbusService.class), modbusServiceConnection, Context.BIND_AUTO_CREATE);
+            }
+            if (isUDPListenerServiceBound && UDPListenerService != null) {
+                if (chargeControllers().autoDetectClassic()) {
+                    UDPListenerService.listen(chargeControllers);
+                }
+            } else {
+                bindService(new Intent(this, UDPListener.class), UDPListenerServiceConnection, Context.BIND_AUTO_CREATE);
+            }
+        }
+        try {
+            connectToMQTT();
+        } catch (MqttException e) {
+            Log.w(getClass().getName(), "connectToMQTT exception");
+            e.printStackTrace();
+        }
+
+    }
+
+    @OnLifecycleEvent(ON_STOP)
+    void onStop(LifecycleOwner source) {
+        Log.d(getClass().getName(), "onStop event");
+        if (wifiLock != null) {
+            wifiLock.release();
+        }
+        ComplexPreferences configuration = ComplexPreferences.getComplexPreferences(MonitorApplication.getAppContext(), null, Context.MODE_PRIVATE);
+        if (configuration != null) {
+            configuration.putObject("devices", chargeControllers);
+            configuration.commit();
+        }
+        if (chargeControllers.mqttType() != MQTT_Type.Subscriber) {
+            LocalBroadcastManager.getInstance(this).unregisterReceiver(addChargeControllerReceiver);
+            LocalBroadcastManager.getInstance(this).unregisterReceiver(removeChargeControllerReceiver);
+            try {
+                if (isModbusServiceBound && modbusService != null) {
+                    modbusService.stopMonitoringChargeControllers();
+                }
+                if (isUDPListenerServiceBound && UDPListenerService != null) {
+                    UDPListenerService.stopListening();
+                }
+            } catch (Exception e) {
+                Log.w(getClass().getName(), "stop service exception");
+                e.printStackTrace();
+            }
+        }
+        try {
+            unSubscribe();
+            IMqttToken token = mqttClient.disconnect();
+//            token.waitForCompletion();
+//            mqttClient.unregisterResources();
+            Log.d(getClass().getName(), "mqttClient disconnected");
+        } catch (Exception e) {
+            Log.w(getClass().getName(), "unSubscribe exception");
+            e.printStackTrace();
+        }
+    }
+
+    private boolean connectToMQTT() throws MqttException {
+        boolean rVal = false;
+        if (chargeControllers.mqttType() != MQTT_Type.Off) {
+            try {
+                if (mqttClient != null) {
+                    rVal = mqttClient.isConnected();
+                }
+            } catch (Exception ex) {
+                mqttClient = null;
+            }
+            if (rVal == false) {
+                Log.d(getClass().getName(), "connectToMQTT");
+                String brokerUrl = String.format("tcp://%s:%d", chargeControllers.mqttBrokerHost(), chargeControllers.mqttPort());
+                if (mqttClient == null) {
+                    mqttClient = new MqttAndroidClient(MonitorApplication.getAppContext(), brokerUrl, generateClientId());
+                    Log.d(getClass().getName(), "creating new mqttClient");
+                }
+                MqttConnectOptions mqttConnectOptions = new MqttConnectOptions();
+                mqttConnectOptions.setCleanSession(true);
+                mqttConnectOptions.setAutomaticReconnect(true);
+                //mqttConnectOptions.setWill(Constants.PUBLISH_TOPIC, "I am going offline".getBytes(), 1, true);
+                mqttConnectOptions.setUserName(chargeControllers.mqttUser());
+                mqttConnectOptions.setPassword(chargeControllers.mqttPassword().toCharArray());
+                IMqttToken token = mqttClient.connect(mqttConnectOptions);
+                token.setActionCallback(new IMqttActionListener() {
+                    @Override
+                    public void onSuccess(IMqttToken asyncActionToken) {
+                        DisconnectedBufferOptions disconnectedBufferOptions = new DisconnectedBufferOptions();
+                        disconnectedBufferOptions.setBufferEnabled(true);
+                        disconnectedBufferOptions.setBufferSize(2048);
+                        disconnectedBufferOptions.setPersistBuffer(false);
+                        disconnectedBufferOptions.setDeleteOldestMessages(false);
+                        mqttClient.setBufferOpts(disconnectedBufferOptions);
+                        Log.d(getClass().getName(), "mqttClient connected");
+                        Subscribe();
+                    }
+
+                    @Override
+                    public void onFailure(IMqttToken asyncActionToken, Throwable exception) {
+                        Log.w(getClass().getName(), String.format("mqttClient failed to connect: %s", exception.getMessage()));
+                    }
+                });
+                rVal = true;
+            } else {
+                Log.d(getClass().getName(), "already connected To MQTT");
+                Subscribe();
+            }
+        }
+        return rVal;
+    }
+
+    private static String generateClientId() {
+        return Constants.CLIENT_ID + System.currentTimeMillis() * 1000000L;
+    }
+
+    protected BroadcastReceiver mMqttReadingsReceiver = new BroadcastReceiver() {
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            if (!mqttIdle || mqttPublishPeriod < System.currentTimeMillis()) {
+                try {
+                    Bundle b = intent.getBundleExtra("readings");
+                    Gson gson = gsonBuilder.create();
+                    String json = gson.toJson(b);
+                    MqttMessage message = new MqttMessage(json.getBytes("UTF-8"));
+                    message.setId(320);
+                    message.setRetained(false);
+                    message.setQos(1);
+                    mqttClient.publish(String.format("%s/readings", statTopic), message);
+                } catch (Exception e) {
+                    Log.w(getClass().getName(), String.format("Failed to publish payload to MQTT broker, ex: %s", e));
+                    e.printStackTrace();
+                }
+            }
+            if (mqttPublishPeriod < System.currentTimeMillis()) {
+                mqttPublishPeriod = System.currentTimeMillis() + (Constants.MQTT_IDLE_DELAY * 10); // idle: publish every 10 times the MQTT_IDLE_DELAY
+                mqttIdle = true;
+            }
+        }
+    };
+
+    private void WakeMQTT(String cmnd) {
+        try {
+            Gson gson = gsonBuilder.create();
+            String json = String.format("{\"%s\"}", cmnd);
+            MqttMessage message = new MqttMessage(json.getBytes("UTF-8"));
+            message.setId(321);
+            message.setRetained(false);
+            message.setQos(1);
+            mqttClient.publish(String.format("%s/%s", cmndTopic, cmnd), message);
+        } catch (Exception e) {
+            Log.w(getClass().getName(), String.format("Failed to publish payload to MQTT broker, ex: %s", e));
+            e.printStackTrace();
+        }
+
+    }
+
+    private void Subscribe() {
+        if (chargeControllers.mqttType() == MQTT_Type.Publisher) {
+            Log.d(getClass().getName(), "Subscribe to MQTT " + cmndTopic);
+            LocalBroadcastManager.getInstance(MonitorApplication.getAppContext()).registerReceiver(mMqttReadingsReceiver, new IntentFilter(Constants.CA_FARRELLTONSOLAR_CLASSIC_READINGS));
+            try {
+                IMqttToken token = mqttClient.subscribe(String.format("%s/#", cmndTopic), 1);
+                token.setActionCallback(new IMqttActionListener() {
+                    String topic = String.format("%s/#", cmndTopic);
+
+                    @Override
+                    public void onSuccess(IMqttToken iMqttToken) {
+                        Log.d(getClass().getName(), "Subscribe Successfully " + topic);
+                        mqttClient.setCallback(new MqttCallbackExtended() {
+                            @Override
+                            public void connectComplete(boolean b, String s) {
+                                Log.d(getClass().getName(), "connectComplete " + topic);
+                            }
+
+                            @Override
+                            public void connectionLost(Throwable throwable) {
+                                Log.w(getClass().getName(), "connectionLost " + topic);
+                            }
+
+                            @Override
+                            public void messageArrived(String topic, MqttMessage mqttMessage) throws Exception {
+
+                                try {
+                                    Gson gson = gsonBuilder.create();
+                                    if (topic.endsWith("info")) {
+                                        ChargeControllerTransfer controller = chargeControllers.getCurrentChargeController().GetTransfer();
+                                        String json = gson.toJson(controller);
+                                        MqttMessage message = new MqttMessage(json.getBytes("UTF-8"));
+                                        message.setId(322);
+                                        message.setRetained(false);
+                                        message.setQos(1);
+                                        mqttClient.publish(String.format("%s/info", statTopic), message);
+                                        mqttIdle = false; // publish readings every second for 5 minutes
+                                        mqttPublishPeriod = System.currentTimeMillis() + Constants.MQTT_IDLE_DELAY;
+                                    } else if (topic.endsWith("wake")) {
+                                        mqttIdle = false; // publish readings every second for 5 minutes
+                                        mqttPublishPeriod = System.currentTimeMillis() + Constants.MQTT_IDLE_DELAY;
+                                    }
+                                } catch (Exception e) {
+                                    Log.w(getClass().getName(), "MQTT deserialize Exception " + topic);
+                                    e.printStackTrace();
+                                }
+                            }
+
+                            @Override
+                            public void deliveryComplete(IMqttDeliveryToken iMqttDeliveryToken) {
+                                Log.d(getClass().getName(), "MQTT Publisher deliveryComplete ");
+                            }
+                        });
+                    }
+
+                    @Override
+                    public void onFailure(IMqttToken iMqttToken, Throwable throwable) {
+                        Log.w(getClass().getName(), "Subscribe Failed " + topic);
+
+                    }
+                });
+            } catch (Exception e) {
+                Log.w(getClass().getName(), String.format("Subscribe Exception %s/#", cmndTopic));
+                e.printStackTrace();
+            }
+        } else if (chargeControllers.mqttType() == MQTT_Type.Subscriber) {
+            Log.d(getClass().getName(), "Subscribe to MQTT " + statTopic);
+            try {
+                IMqttToken token = mqttClient.subscribe(String.format("%s/#", statTopic), 1);
+                token.setActionCallback(new IMqttActionListener() {
+                    String topic = String.format("%s/#", statTopic);
+
+                    @Override
+                    public void onSuccess(IMqttToken iMqttToken) {
+                        Log.d(getClass().getName(), "Subscribe Successfully " + topic);
+                        mqttClient.setCallback(new MqttCallbackExtended() {
+                            @Override
+                            public void connectComplete(boolean b, String s) {
+                                Log.d(getClass().getName(), "connectComplete " + topic);
+                            }
+
+                            @Override
+                            public void connectionLost(Throwable throwable) {
+                                Log.w(getClass().getName(), "connectionLost " + topic);
+                            }
+
+                            @Override
+                            public void messageArrived(String topic, MqttMessage mqttMessage) throws Exception {
+
+                                try {
+                                    String str = mqttMessage.toString();
+                                    Gson gson = gsonBuilder.create();
+                                    if (topic.endsWith("readings")) {
+
+                                        Bundle b = gson.fromJson(str, Bundle.class);
+                                        Readings readings = new Readings(b);
+                                        readings.broadcastReadings(MonitorApplication.getAppContext(), "MQTT", Constants.CA_FARRELLTONSOLAR_CLASSIC_READINGS);
+                                    } else if (topic.endsWith("info")) {
+                                        ChargeControllerTransfer t = gson.fromJson(str, ChargeControllerTransfer.class);
+                                        if (chargeControllers.count() == 0) {
+                                            ChargeControllerInfo c = new ChargeControllerInfo();
+                                            c.setIsCurrent(true);
+                                            c.setIsReachable(true);
+                                            c.LoadTransfer(t);
+                                            chargeControllers.add(c);
+                                        } else {
+                                            chargeControllers.getCurrentChargeController().LoadTransfer(t);
+                                        }
+                                    }
+                                } catch (Exception e) {
+                                    Log.w(getClass().getName(), "MQTT deserialize Exception " + topic);
+                                    e.printStackTrace();
+                                }
+                            }
+
+                            @Override
+                            public void deliveryComplete(IMqttDeliveryToken iMqttDeliveryToken) {
+                                Log.d(getClass().getName(), "MQTT Subscriber deliveryComplete ");
+                            }
+                        });
+                    }
+
+                    @Override
+                    public void onFailure(IMqttToken iMqttToken, Throwable throwable) {
+                        Log.w(getClass().getName(), "Subscribe Failed " + topic);
+
+                    }
+                });
+                WakeMQTT("info");
+                mqttWakeTimer = new Timer();
+                mqttWakeTimer.schedule(new TimerTask() {
+                    @Override
+                    public void run() {
+                        WakeMQTT("wake");
+                    }
+
+                }, (Constants.MQTT_IDLE_DELAY - 2000), (Constants.MQTT_IDLE_DELAY - 2000));
+            } catch (Exception e) {
+                Log.w(getClass().getName(), String.format("Subscribe Exception %s/#", statTopic));
+                e.printStackTrace();
+            }
+        }
+    }
+
+    private void unSubscribe() throws MqttException {
+        if (mqttClient.isConnected()) {
+            String topic = statTopic;
+            if (chargeControllers.mqttType() == MQTT_Type.Publisher) {
+                topic = cmndTopic;
+                LocalBroadcastManager.getInstance(MonitorApplication.getAppContext()).unregisterReceiver(mMqttReadingsReceiver);
+            }
+            IMqttToken token = mqttClient.unsubscribe(topic);
+            token.setActionCallback(new IMqttActionListener() {
+                @Override
+                public void onSuccess(IMqttToken iMqttToken) {
+                    Log.d(getClass().getName(), "UnSubscribe Successfully ");
+                }
+
+                @Override
+                public void onFailure(IMqttToken iMqttToken, Throwable throwable) {
+                    Log.w(getClass().getName(), "UnSubscribe Failed ");
+                }
+            });
+        }
+        if (mqttWakeTimer != null) {
+            mqttWakeTimer.cancel();
+            mqttWakeTimer.purge();
+            Log.d(getClass().getName(), "mqttWakeTimer.purge");
+        }
+    }
+
     public static Pair<Severity, String> getMessage(int cs) {
         if (messages.containsKey(cs)) {
             return messages.get(cs);
@@ -149,6 +506,7 @@ public class MonitorApplication extends Application implements Application.Activ
         }
         return null;
     }
+
     private void InitializeReasonsForRestingLookup() {
         reasonsForResting.put(1, new Pair(Severity.info, getString(R.string.reasonsForResting_message_1)));
         reasonsForResting.put(2, new Pair(Severity.alert, getString(R.string.reasonsForResting_message_2)));
@@ -189,7 +547,7 @@ public class MonitorApplication extends Application implements Application.Activ
     }
 
     public static Context getAppContext() {
-        return MonitorApplication.context;
+        return instance.getApplicationContext();
     }
 
     public static ChargeControllers chargeControllers() {
@@ -280,6 +638,7 @@ public class MonitorApplication extends Application implements Application.Activ
         }
 
         public void onServiceDisconnected(ComponentName arg0) {
+            Log.d(getClass().getName(), "ModbusService onServiceDisconnected");
             isModbusServiceBound = false;
             modbusService = null;
             Log.d(getClass().getName(), "ModbusService ServiceDisconnected");
@@ -290,7 +649,8 @@ public class MonitorApplication extends Application implements Application.Activ
     private BroadcastReceiver addChargeControllerReceiver = new BroadcastReceiver() {
         @Override
         public void onReceive(Context context, Intent intent) {
-            ChargeControllerInfo cc = GSON.fromJson(intent.getStringExtra("ChargeController"), ChargeController.class);
+            Gson gson = gsonBuilder.create();
+            ChargeControllerInfo cc = gson.fromJson(intent.getStringExtra("ChargeController"), ChargeController.class);
             Log.d(getClass().getName(), String.format("adding new controller to list (%s)", cc.toString()));
             chargeControllers.add(cc);
             modbusService.monitorChargeControllers(chargeControllers());
@@ -318,84 +678,13 @@ public class MonitorApplication extends Application implements Application.Activ
             return;
         }
         if (chargeControllers.setCurrent(device)) {
-            LocalBroadcastManager broadcaster = LocalBroadcastManager.getInstance(context);
+            LocalBroadcastManager broadcaster = LocalBroadcastManager.getInstance(getAppContext());
             Intent pkg = new Intent(Constants.CA_FARRELLTONSOLAR_CLASSIC_MONITOR_CHARGE_CONTROLLER);
             pkg.putExtra("DifferentController", true);
             broadcaster.sendBroadcast(pkg); //notify activity
         }
     }
 
-    @Override
-    public void onActivityCreated(Activity activity, Bundle savedInstanceState) {
-        if (wifiLock != null) {
-            wifiLock.acquire();
-        }
-    }
-
-    @Override
-    public void onActivityDestroyed(Activity activity) {
-        if (wifiLock != null) {
-            wifiLock.release();
-        }
-    }
-
-    @Override
-    public void onActivityStarted(Activity activity) {
-
-    }
-
-    @Override
-    public void onActivityResumed(Activity activity) {
-        if (activity.getLocalClassName().compareTo("MonitorActivity") == 0) {
-            LocalBroadcastManager.getInstance(this).registerReceiver(addChargeControllerReceiver, new IntentFilter(Constants.CA_FARRELLTONSOLAR_CLASSIC_ADD_CHARGE_CONTROLLER));
-            LocalBroadcastManager.getInstance(this).registerReceiver(removeChargeControllerReceiver, new IntentFilter(Constants.CA_FARRELLTONSOLAR_CLASSIC_REMOVE_CHARGE_CONTROLLER));
-            if (disconnectTimer != null) {
-                disconnectTimer.cancel();
-                disconnectTimer.purge();
-            }
-            if (isModbusServiceBound && modbusService != null){
-                modbusService.monitorChargeControllers(chargeControllers());
-            }
-            else {
-                bindService(new Intent(this, ModbusService.class), modbusServiceConnection, Context.BIND_AUTO_CREATE);
-            }
-        }
-    }
-
-    @Override
-    public void onActivityPaused(Activity activity) {
-        if (activity.getLocalClassName().compareTo("MonitorActivity") == 0) {
-            LocalBroadcastManager.getInstance(this).unregisterReceiver(addChargeControllerReceiver);
-            LocalBroadcastManager.getInstance(this).unregisterReceiver(removeChargeControllerReceiver);
-            disconnectTimer = new Timer();
-            disconnectTimer.schedule(new TimerTask() {
-                @Override
-                public void run() {
-                    // this code will be executed after 10 seconds unless Activity Resumed
-                    modbusService.stopMonitoringChargeControllers();
-                }
-            }, 10000);
-        }
-    }
-
-    @Override
-    public void onActivityStopped(Activity activity) {
-        Log.d(getClass().getName(), "saving chargeController settings");
-        if (configuration != null) {
-            configuration.putObject("devices", chargeControllers);
-            configuration.commit();
-        }
-    }
-
-    public MonitorApplication() {
-        super();
-    }
-
-    @Override
-    public void onActivitySaveInstanceState(Activity activity, Bundle outState) {
-
-    }
-
     // get supported language code, default to english
     public static String getLanguage() {
         String rVal = Locale.getDefault().getLanguage();
@@ -405,7 +694,7 @@ public class MonitorApplication extends Application implements Application.Activ
             case "de":
             case "es":
             case "fr":
-            break;
+                break;
             default:
                 rVal = "en";
                 break;
diff --git a/app/src/main/java/ca/farrelltonsolar/classic/Settings.java b/app/src/main/java/ca/farrelltonsolar/classic/Settings.java
index 3d5f0c0..0827121 100644
--- a/app/src/main/java/ca/farrelltonsolar/classic/Settings.java
+++ b/app/src/main/java/ca/farrelltonsolar/classic/Settings.java
@@ -22,6 +22,7 @@ import android.net.Uri;
 import android.os.Bundle;
 import android.preference.CheckBoxPreference;
 import android.preference.EditTextPreference;
+import android.preference.ListPreference;
 import android.preference.Preference;
 import android.preference.PreferenceActivity;
 import android.util.Log;
@@ -38,7 +39,12 @@ public class Settings extends PreferenceActivity implements SharedPreferences.On
     private CheckBoxPreference systemViewEnabled;
     private EditTextPreference _SID;
     private EditTextPreference _APIKey;
-
+    private ListPreference _mListPreference;
+    private EditTextPreference _brokerHost;
+    private EditTextPreference _mqttPort;
+    private EditTextPreference _mqttUser;
+    private EditTextPreference _mqttPassword;
+    private EditTextPreference _mqttRootTopic;
     @Override
     protected void onSaveInstanceState(Bundle outState) {
         super.onSaveInstanceState(outState);
@@ -83,6 +89,13 @@ public class Settings extends PreferenceActivity implements SharedPreferences.On
                 if (setting != null) {
                     setting.setSID(_SID.getText());
                 }
+                MQTT_Type mqtt = MQTT_Type.valueOf(_mListPreference.getValue());
+                MonitorApplication.chargeControllers().setMQTT_Type(mqtt);
+                MonitorApplication.chargeControllers().setMqttBrokerHost(_brokerHost.getText());
+                MonitorApplication.chargeControllers().setMqttPort(Integer.parseInt(_mqttPort.getText()));
+                MonitorApplication.chargeControllers().setMqttUser(_mqttUser.getText());
+                MonitorApplication.chargeControllers().setMqttPassword(_mqttPassword.getText());
+                MonitorApplication.chargeControllers().setMqttRootTopic(_mqttRootTopic.getText());
                 Settings.this.finish();
             }
         });
@@ -95,7 +108,12 @@ public class Settings extends PreferenceActivity implements SharedPreferences.On
             systemViewEnabled = (CheckBoxPreference) findPreference(Constants.SystemViewEnabled);
             _SID = (EditTextPreference) findPreference(Constants.SID);
             _APIKey = (EditTextPreference) findPreference(Constants.APIKey);
-
+            _mListPreference = (ListPreference)getPreferenceScreen().findPreference("listPref");
+            _brokerHost = (EditTextPreference) findPreference("brokerHost");
+            _mqttPort = (EditTextPreference) findPreference("mqttPort");
+            _mqttUser = (EditTextPreference) findPreference("mqttUser");
+            _mqttPassword = (EditTextPreference) findPreference("mqttPassword");
+            _mqttRootTopic = (EditTextPreference) findPreference("mqttRootTopic");
             useFahrenheit.setChecked(MonitorApplication.chargeControllers().useFahrenheit());
             autoDetectClassics.setChecked(MonitorApplication.chargeControllers().autoDetectClassic());
             showPopupMessages.setChecked(MonitorApplication.chargeControllers().showPopupMessages());
@@ -111,6 +129,7 @@ public class Settings extends PreferenceActivity implements SharedPreferences.On
                 }
             });
             UploadToPVOutputEnabled(uploadToPVOutput.isChecked());
+
             _APIKey.setSummary(MonitorApplication.chargeControllers().aPIKey());
             PVOutputSetting setting = MonitorApplication.chargeControllers().getPVOutputSetting();
             if (setting != null) {
@@ -125,19 +144,38 @@ public class Settings extends PreferenceActivity implements SharedPreferences.On
                 }
             });
 
+            CharSequence[] entries = new CharSequence[]{"Off", "Subscriber", "Publisher"};
+            CharSequence[] entryValues = new CharSequence[]{ MQTT_Type.Off.name(), MQTT_Type.Subscriber.name(), MQTT_Type.Publisher.name() };
+            _mListPreference.setEntries(entries);
+            _mListPreference.setEntryValues(entryValues);
+            _mListPreference.setValueIndex(MonitorApplication.chargeControllers().mqttType().ordinal());
+            _mListPreference.setSummary("MQTT " + _mListPreference.getValue());
+            _brokerHost.setSummary(MonitorApplication.chargeControllers().mqttBrokerHost());
+            _mqttPort.setSummary( Integer.toString(MonitorApplication.chargeControllers().mqttPort()));
+            _mqttUser.setSummary(MonitorApplication.chargeControllers().mqttUser());
+            _mqttPassword.setSummary(MonitorApplication.chargeControllers().mqttPassword());
+            _mqttRootTopic.setSummary(MonitorApplication.chargeControllers().mqttRootTopic());
+            MQTTEnabled();
         } catch (Exception ex) {
             Log.w(getClass().getName(), String.format("settings failed ex: %s", ex));
         }
 
     }
 
-
-
     private void UploadToPVOutputEnabled(boolean isEnabled) {
         _SID.setEnabled(isEnabled);
         _APIKey.setEnabled(isEnabled);
     }
 
+    private void MQTTEnabled() {
+        boolean isEnabled = (_mListPreference.getEntry().toString() != MQTT_Type.Off.name());
+        _brokerHost.setEnabled(isEnabled);
+        _mqttPort.setEnabled(isEnabled);
+        _mqttUser.setEnabled(isEnabled);
+        _mqttPassword.setEnabled(isEnabled);
+        _mqttRootTopic.setEnabled(isEnabled);
+    }
+
     @Override
     protected void onResume() {
         super.onResume();
@@ -163,5 +201,9 @@ public class Settings extends PreferenceActivity implements SharedPreferences.On
     @Override
     public void onSharedPreferenceChanged(SharedPreferences sharedPreferences, String key) {
         updatePreferences(findPreference(key));
+        if (key.equals("listPref")) {
+            _mListPreference.setSummary("MQTT " + _mListPreference.getEntry().toString());
+            MQTTEnabled();
+        }
     }
 }
