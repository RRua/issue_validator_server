diff --git a/app/src/fdroid/java/com/amaze/filemanager/activities/MainActivity.java b/app/src/fdroid/java/com/amaze/filemanager/activities/MainActivity.java
index c40aa3080..1dbfa7222 100644
--- a/app/src/fdroid/java/com/amaze/filemanager/activities/MainActivity.java
+++ b/app/src/fdroid/java/com/amaze/filemanager/activities/MainActivity.java
@@ -588,7 +588,7 @@ public class MainActivity extends ThemedActivity implements OnRequestPermissions
                     closeInteractiveShell();
                     sharedPref.edit().putBoolean(PreferenceUtils.KEY_ROOT, false).apply();
                 }
-            } catch (RootNotPermittedException e) {
+            } catch (ShellNotRunningException e) {
                 e.printStackTrace();
                 sharedPref.edit().putBoolean(PreferenceUtils.KEY_ROOT, false).apply();
             }*/
diff --git a/app/src/main/java/com/amaze/filemanager/activities/DatabaseViewerActivity.java b/app/src/main/java/com/amaze/filemanager/activities/DatabaseViewerActivity.java
index d59d1fc90..9c1e11445 100644
--- a/app/src/main/java/com/amaze/filemanager/activities/DatabaseViewerActivity.java
+++ b/app/src/main/java/com/amaze/filemanager/activities/DatabaseViewerActivity.java
@@ -40,7 +40,7 @@ import android.widget.ListView;
 
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.superclasses.ThemedActivity;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.fragments.DbViewerFragment;
 import com.amaze.filemanager.fragments.preference_fragments.PrefFrag;
 import com.amaze.filemanager.utils.PreferenceUtils;
@@ -159,7 +159,7 @@ public class DatabaseViewerActivity extends ThemedActivity {
                     RootUtils.copy(pathFile.getPath(),
                             new File(file1.getPath(), file.getName()).getPath());
                     pathFile = new File(file1.getPath(), file.getName());
-                } catch (RootNotPermittedException e) {
+                } catch (ShellNotRunningException e) {
                     e.printStackTrace();
                 }
                 delete = true;
diff --git a/app/src/main/java/com/amaze/filemanager/activities/TextEditorActivity.java b/app/src/main/java/com/amaze/filemanager/activities/TextEditorActivity.java
index 2702c000b..bc31209fc 100644
--- a/app/src/main/java/com/amaze/filemanager/activities/TextEditorActivity.java
+++ b/app/src/main/java/com/amaze/filemanager/activities/TextEditorActivity.java
@@ -34,7 +34,6 @@ import android.net.Uri;
 import android.os.Build;
 import android.os.Bundle;
 import android.os.ParcelFileDescriptor;
-import android.preference.PreferenceManager;
 import android.provider.MediaStore;
 import android.support.v7.widget.Toolbar;
 import android.text.Editable;
@@ -42,7 +41,6 @@ import android.text.Spanned;
 import android.text.TextWatcher;
 import android.text.style.BackgroundColorSpan;
 import android.util.DisplayMetrics;
-import android.util.Log;
 import android.view.Menu;
 import android.view.MenuItem;
 import android.view.View;
@@ -63,7 +61,7 @@ import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.superclasses.ThemedActivity;
 import com.amaze.filemanager.asynchronous.asynctasks.SearchTextTask;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.exceptions.StreamNotFoundException;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.FileUtil;
@@ -73,7 +71,6 @@ import com.amaze.filemanager.utils.MapEntry;
 import com.amaze.filemanager.utils.PreferenceUtils;
 import com.amaze.filemanager.utils.RootUtils;
 import com.amaze.filemanager.utils.Utils;
-import com.amaze.filemanager.utils.application.AppConfig;
 import com.amaze.filemanager.utils.color.ColorUsage;
 import com.amaze.filemanager.utils.files.FileUtils;
 import com.amaze.filemanager.utils.files.GenericCopyUtil;
@@ -332,7 +329,7 @@ public class TextEditorActivity extends ThemedActivity implements TextWatcher, V
                     Toast.makeText(getApplicationContext(), R.string.error_io,
                             Toast.LENGTH_SHORT).show();
                 });
-            } catch (RootNotPermittedException e) {
+            } catch (ShellNotRunningException e) {
                 e.printStackTrace();
                 runOnUiThread(() -> {
                     Toast.makeText(getApplicationContext(), R.string.rootfailure,
@@ -351,11 +348,11 @@ public class TextEditorActivity extends ThemedActivity implements TextWatcher, V
      * @param inputText
      * @throws StreamNotFoundException
      * @throws IOException
-     * @throws RootNotPermittedException
+     * @throws ShellNotRunningException
      * @see #saveFile(Uri, File, String)
      */
     private void writeTextFile(final Uri uri, final File file, String inputText)
-            throws StreamNotFoundException, IOException, RootNotPermittedException {
+            throws StreamNotFoundException, IOException, ShellNotRunningException {
         OutputStream outputStream = null;
 
         if (uri.toString().contains("file://")) {
@@ -636,7 +633,7 @@ public class TextEditorActivity extends ThemedActivity implements TextWatcher, V
                         e.printStackTrace();
                         stream = null;
                     }
-                } catch (RootNotPermittedException e) {
+                } catch (ShellNotRunningException e) {
                     e.printStackTrace();
                     stream = null;
                 }
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java
index 3806eac60..c1b06a247 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/DeleteTask.java
@@ -32,7 +32,7 @@ import android.widget.Toast;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.database.CryptHandler;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.fragments.CompressedExplorerFragment;
 import com.amaze.filemanager.utils.DataUtils;
@@ -130,7 +130,7 @@ public class DeleteTask extends AsyncTask<ArrayList<HybridFileParcelable>, Strin
             for(HybridFileParcelable a : files)
                 try {
                     (a).delete(cd, rootMode);
-                } catch (RootNotPermittedException e) {
+                } catch (ShellNotRunningException e) {
                     e.printStackTrace();
                     b = false;
                 }
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/MoveFiles.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/MoveFiles.java
index 5d29c9da0..cee1b0b5d 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/MoveFiles.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/MoveFiles.java
@@ -27,7 +27,7 @@ import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.activities.superclasses.ThemedActivity;
 import com.amaze.filemanager.database.CryptHandler;
 import com.amaze.filemanager.database.models.EncryptedEntry;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.fragments.MainFragment;
 import com.amaze.filemanager.utils.application.AppConfig;
@@ -40,7 +40,6 @@ import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.RootUtils;
 import com.amaze.filemanager.utils.ServiceWatcherUtil;
 import com.cloudrail.si.interfaces.CloudStorage;
-import com.squareup.haha.perflib.Main;
 
 import java.io.File;
 import java.net.MalformedURLException;
@@ -105,7 +104,7 @@ public class MoveFiles extends AsyncTask<ArrayList<String>, Void, Boolean> {
                                 try {
                                     if (!RootUtils.rename(f.getPath(), paths.get(i) + "/" + f.getName()))
                                         return false;
-                                } catch (RootNotPermittedException e) {
+                                } catch (ShellNotRunningException e) {
                                     e.printStackTrace();
                                     return false;
                                 }
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/SearchTextTask.java b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/SearchTextTask.java
index ebf4ea3fc..cd8baedf4 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/SearchTextTask.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/asynctasks/SearchTextTask.java
@@ -9,6 +9,7 @@ import android.widget.EditText;
 import android.widget.ImageButton;
 
 import com.amaze.filemanager.activities.TextEditorActivity;
+import com.amaze.filemanager.utils.ImmutableEntry;
 import com.amaze.filemanager.utils.MapEntry;
 import com.amaze.filemanager.utils.theme.AppTheme;
 
@@ -63,7 +64,7 @@ public class SearchTextTask extends AsyncTask<Editable, Void, ArrayList<MapEntry
             // comparing and adding searched phrase to a list
             if (searchSubString.equalsIgnoreCase(params[0].toString())) {
 
-                nodes.add(new MapEntry(new MapEntry.KeyMapEntry(i, i + params[0].length()),
+                nodes.add(new MapEntry(new ImmutableEntry<>(i, i + params[0].length()),
                         lineNumberReader.getLineNumber()));
             }
 
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/ftpservice/FTPService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/ftpservice/FTPService.java
index 8f984b625..4b22122ba 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/ftpservice/FTPService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/ftpservice/FTPService.java
@@ -21,7 +21,6 @@ import android.util.Log;
 import android.widget.Toast;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.exceptions.CryptException;
 import com.amaze.filemanager.utils.files.CryptUtil;
 
 import org.apache.commons.compress.utils.IOUtils;
@@ -46,6 +45,7 @@ import java.net.NetworkInterface;
 import java.net.ServerSocket;
 import java.net.SocketException;
 import java.net.UnknownHostException;
+import java.security.GeneralSecurityException;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Enumeration;
@@ -131,7 +131,7 @@ public class FTPService extends Service implements Runnable {
             try {
                 password = CryptUtil.decryptPassword(getApplicationContext(), preferences.getString(KEY_PREFERENCE_PASSWORD, ""));
                 isPasswordProtected = true;
-            } catch (CryptException e) {
+            } catch (GeneralSecurityException | IOException e) {
                 e.printStackTrace();
 
                 Toast.makeText(getApplicationContext(), getResources().getString(R.string.error), Toast.LENGTH_SHORT).show();
diff --git a/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java b/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
index f4601a02b..48df12429 100644
--- a/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
+++ b/app/src/main/java/com/amaze/filemanager/asynchronous/services/CopyService.java
@@ -41,10 +41,10 @@ import com.amaze.filemanager.activities.superclasses.ThemedActivity;
 import com.amaze.filemanager.asynchronous.asynctasks.DeleteTask;
 import com.amaze.filemanager.database.CryptHandler;
 import com.amaze.filemanager.database.models.EncryptedEntry;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.FileUtil;
 import com.amaze.filemanager.filesystem.HybridFile;
-import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.Operations;
 import com.amaze.filemanager.filesystem.RootHelper;
 import com.amaze.filemanager.fragments.ProcessViewerFragment;
@@ -56,7 +56,6 @@ import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.ProgressHandler;
 import com.amaze.filemanager.utils.RootUtils;
 import com.amaze.filemanager.utils.ServiceWatcherUtil;
-import com.amaze.filemanager.utils.files.CryptUtil;
 import com.amaze.filemanager.utils.files.FileUtils;
 import com.amaze.filemanager.utils.files.GenericCopyUtil;
 
@@ -360,7 +359,7 @@ public class CopyService extends Service {
                     if (!move) RootUtils.copy(sourceFile.getPath(), targetFile.getPath());
                     else if (move) RootUtils.move(sourceFile.getPath(), targetFile.getPath());
                     ServiceWatcherUtil.POSITION += sourceFile.getSize();
-                } catch (RootNotPermittedException e) {
+                } catch (ShellNotRunningException e) {
                     failedFOps.add(sourceFile);
                     e.printStackTrace();
                 }
@@ -531,7 +530,7 @@ public class CopyService extends Service {
     //check if copy is successful
     // avoid using the method as there is no way to know when we would be returning from command callbacks
     // rather confirm from the command result itself, inside it's callback
-    boolean checkFiles(HybridFile hFile1, HybridFile hFile2) throws RootNotPermittedException {
+    boolean checkFiles(HybridFile hFile1, HybridFile hFile2) throws ShellNotRunningException {
         if (RootHelper.isDirectory(hFile1.getPath(), ThemedActivity.rootMode, 5)) {
             if (RootHelper.fileExists(hFile2.getPath())) return false;
             ArrayList<HybridFileParcelable> baseFiles = RootHelper.getFilesList(hFile1.getPath(), true, true, null);
diff --git a/app/src/main/java/com/amaze/filemanager/database/CryptHandler.java b/app/src/main/java/com/amaze/filemanager/database/CryptHandler.java
index bb632d0ca..b58f7ad65 100644
--- a/app/src/main/java/com/amaze/filemanager/database/CryptHandler.java
+++ b/app/src/main/java/com/amaze/filemanager/database/CryptHandler.java
@@ -7,24 +7,13 @@ import android.database.sqlite.SQLiteDatabase;
 import android.database.sqlite.SQLiteOpenHelper;
 
 import com.amaze.filemanager.database.models.EncryptedEntry;
-import com.amaze.filemanager.exceptions.CryptException;
 import com.amaze.filemanager.utils.files.CryptUtil;
 
 import java.io.IOException;
-import java.security.InvalidAlgorithmParameterException;
-import java.security.InvalidKeyException;
-import java.security.KeyStoreException;
-import java.security.NoSuchAlgorithmException;
-import java.security.NoSuchProviderException;
-import java.security.UnrecoverableEntryException;
-import java.security.cert.CertificateException;
+import java.security.GeneralSecurityException;
 import java.util.ArrayList;
 import java.util.List;
 
-import javax.crypto.BadPaddingException;
-import javax.crypto.IllegalBlockSizeException;
-import javax.crypto.NoSuchPaddingException;
-
 /**
  * Created by vishal on 15/4/17.
  */
@@ -63,7 +52,7 @@ public class CryptHandler extends SQLiteOpenHelper {
         onCreate(db);
     }
 
-    public void addEntry(EncryptedEntry encryptedEntry) throws CryptException {
+    public void addEntry(EncryptedEntry encryptedEntry) throws GeneralSecurityException, IOException {
 
         ContentValues contentValues = new ContentValues();
         //contentValues.put(COLUMN_ENCRYPTED_ID, encryptedEntry.getId());
@@ -84,7 +73,7 @@ public class CryptHandler extends SQLiteOpenHelper {
         }
     }
 
-    public void updateEntry(EncryptedEntry oldEncryptedEntry, EncryptedEntry newEncryptedEntry) throws CryptException {
+    public void updateEntry(EncryptedEntry oldEncryptedEntry, EncryptedEntry newEncryptedEntry) throws GeneralSecurityException, IOException  {
         SQLiteDatabase sqLiteDatabase = getWritableDatabase();
         ContentValues contentValues = new ContentValues();
         contentValues.put(COLUMN_ENCRYPTED_ID, newEncryptedEntry.getId());
@@ -96,7 +85,7 @@ public class CryptHandler extends SQLiteOpenHelper {
                 new String[]{oldEncryptedEntry.getId() + ""});
     }
 
-    public EncryptedEntry findEntry(String path) throws CryptException {
+    public EncryptedEntry findEntry(String path) throws GeneralSecurityException, IOException {
         String query = "Select * FROM " + TABLE_ENCRYPTED + " WHERE " + COLUMN_ENCRYPTED_PATH
                 + "= \"" + path + "\"";
         SQLiteDatabase sqLiteDatabase = getReadableDatabase();
@@ -115,7 +104,7 @@ public class CryptHandler extends SQLiteOpenHelper {
         return encryptedEntry;
     }
 
-    public List<EncryptedEntry> getAllEntries() throws CryptException {
+    public List<EncryptedEntry> getAllEntries() throws GeneralSecurityException, IOException {
         List<EncryptedEntry> entryList = new ArrayList<EncryptedEntry>();
         // Select all query
         String query = "Select * FROM " + TABLE_ENCRYPTED;
diff --git a/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.java b/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.java
index b892870e3..3d6858679 100644
--- a/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.java
+++ b/app/src/main/java/com/amaze/filemanager/database/UtilsHandler.java
@@ -9,13 +9,14 @@ import android.os.Environment;
 import android.widget.Toast;
 
 import com.amaze.filemanager.R;
-import com.amaze.filemanager.exceptions.CryptException;
 import com.amaze.filemanager.utils.SmbUtil;
 import com.googlecode.concurrenttrees.radix.ConcurrentRadixTree;
 import com.googlecode.concurrenttrees.radix.node.concrete.DefaultCharArrayNodeFactory;
 import com.googlecode.concurrenttrees.radix.node.concrete.voidvalue.VoidValue;
 
 import java.io.File;
+import java.io.IOException;
+import java.security.GeneralSecurityException;
 import java.util.ArrayList;
 import java.util.LinkedList;
 
@@ -226,7 +227,7 @@ public class UtilsHandler extends SQLiteOpenHelper {
                             cursor.getString(cursor.getColumnIndex(COLUMN_NAME)),
                             SmbUtil.getSmbDecryptedPath(context, cursor.getString(cursor.getColumnIndex(COLUMN_PATH)))
                     });
-                } catch (CryptException e) {
+                } catch (GeneralSecurityException | IOException e) {
                     e.printStackTrace();
 
                     // failing to decrypt the path, removing entry from database
@@ -281,12 +282,12 @@ public class UtilsHandler extends SQLiteOpenHelper {
         try {
             if (path.equals("")) {
                 // we don't have a path, remove the entry with this name
-                throw new CryptException();
+                throw new IOException();
             }
 
             sqLiteDatabase.delete(TABLE_SMB, COLUMN_NAME + " = ? AND " + COLUMN_PATH + " = ?",
                     new String[] {name, SmbUtil.getSmbEncryptedPath(context, path)});
-        } catch (CryptException e) {
+        } catch (IOException | GeneralSecurityException e) {
             e.printStackTrace();
             // force remove entry, we end up deleting all entries with same name
 
diff --git a/app/src/main/java/com/amaze/filemanager/exceptions/CryptException.java b/app/src/main/java/com/amaze/filemanager/exceptions/CryptException.java
deleted file mode 100644
index 31ae84a5d..000000000
--- a/app/src/main/java/com/amaze/filemanager/exceptions/CryptException.java
+++ /dev/null
@@ -1,11 +0,0 @@
-package com.amaze.filemanager.exceptions;
-
-/**
- * Created by Vishal on 01-07-2017.
- *
- * Exception thrown when there is some problem with cryptographic function and the operation fails.
- * The problem can by anything from no padding, wrong cryptographic algorithm to illegal block size
- */
-
-public class CryptException extends Exception {
-}
diff --git a/app/src/main/java/com/amaze/filemanager/exceptions/RootNotPermittedException.java b/app/src/main/java/com/amaze/filemanager/exceptions/RootNotPermittedException.java
deleted file mode 100644
index cd97d6e71..000000000
--- a/app/src/main/java/com/amaze/filemanager/exceptions/RootNotPermittedException.java
+++ /dev/null
@@ -1,17 +0,0 @@
-package com.amaze.filemanager.exceptions;
-
-/**
- * Created by vishal on 24/12/16.
- * Exception thrown when root is
- */
-
-public class RootNotPermittedException extends Exception {
-
-    private static final String MESSAGE = "Exception thrown when root is";
-
-    public RootNotPermittedException() { super(MESSAGE); }
-    public RootNotPermittedException(String message) { super(message); }
-    public RootNotPermittedException(String message, Throwable cause) { super(message, cause); }
-    public RootNotPermittedException(Throwable cause) { super(MESSAGE, cause); }
-
-}
diff --git a/app/src/main/java/com/amaze/filemanager/exceptions/ShellNotRunningException.java b/app/src/main/java/com/amaze/filemanager/exceptions/ShellNotRunningException.java
new file mode 100644
index 000000000..78dec852a
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/exceptions/ShellNotRunningException.java
@@ -0,0 +1,12 @@
+package com.amaze.filemanager.exceptions;
+
+/**
+ * Created by vishal on 24/12/16.
+ * Exception thrown when root is
+ */
+
+public class ShellNotRunningException extends Exception {
+    public ShellNotRunningException() {
+        super("Shell stopped running!");
+    }
+}
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java b/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java
index 5752fd011..914dd175f 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/FileUtil.java
@@ -18,7 +18,7 @@ import android.util.Log;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.database.CloudHandler;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.ui.icons.MimeTypes;
 import com.amaze.filemanager.utils.DataUtils;
 import com.amaze.filemanager.utils.OTGUtil;
@@ -338,7 +338,7 @@ public abstract class FileUtil {
         return !file.exists();
     }
 
-    private static boolean rename(File f, String name, boolean root) throws RootNotPermittedException {
+    private static boolean rename(File f, String name, boolean root) throws ShellNotRunningException {
         String newPath = f.getParent() + "/" + name;
         if (f.getParentFile().canWrite()) {
             return f.renameTo(new File(newPath));
@@ -357,7 +357,7 @@ public abstract class FileUtil {
      * @return true if the renaming was successful.
      */
     static boolean renameFolder(@NonNull final File source, @NonNull final File target,
-                                Context context) throws RootNotPermittedException {
+                                Context context) throws ShellNotRunningException {
         // First try the normal rename.
         if (rename(source, target.getName(), false)) {
             return true;
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/HybridFile.java b/app/src/main/java/com/amaze/filemanager/filesystem/HybridFile.java
index 2ff13482a..9e80e17fe 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/HybridFile.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/HybridFile.java
@@ -9,18 +9,17 @@ import android.util.Log;
 
 import com.amaze.filemanager.database.CloudHandler;
 import com.amaze.filemanager.exceptions.CloudPluginException;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.fragments.MainFragment;
 import com.amaze.filemanager.ui.LayoutElementParcelable;
 import com.amaze.filemanager.ui.icons.Icons;
 import com.amaze.filemanager.utils.DataUtils;
-import com.amaze.filemanager.utils.OnFileFound;
-import com.amaze.filemanager.utils.cloud.CloudUtil;
-import com.amaze.filemanager.utils.files.FileUtils;
-import com.amaze.filemanager.utils.Logger;
 import com.amaze.filemanager.utils.OTGUtil;
+import com.amaze.filemanager.utils.OnFileFound;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.RootUtils;
+import com.amaze.filemanager.utils.cloud.CloudUtil;
+import com.amaze.filemanager.utils.files.FileUtils;
 import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
 import com.cloudrail.si.interfaces.CloudStorage;
 import com.cloudrail.si.types.SpaceAllocation;
@@ -422,7 +421,7 @@ public class HybridFile {
             case ROOT:
                 try {
                     isDirectory = RootHelper.isDirectory(path, true, 5);
-                } catch (RootNotPermittedException e) {
+                } catch (ShellNotRunningException e) {
                     e.printStackTrace();
                     isDirectory = false;
                 }
@@ -461,7 +460,7 @@ public class HybridFile {
             case ROOT:
                 try {
                     isDirectory = RootHelper.isDirectory(path,true,5);
-                } catch (RootNotPermittedException e) {
+                } catch (ShellNotRunningException e) {
                     e.printStackTrace();
                     isDirectory = false;
                 }
@@ -878,7 +877,7 @@ public class HybridFile {
         } else if (isRoot()) {
             try {
                 return RootHelper.fileExists(path);
-            } catch (RootNotPermittedException e) {
+            } catch (ShellNotRunningException e) {
                 e.printStackTrace();
                 return false;
             }
@@ -932,7 +931,7 @@ public class HybridFile {
             try {
                 new SmbFile(path).mkdirs();
             } catch (SmbException | MalformedURLException e) {
-                Logger.log(e, path, context);
+                e.printStackTrace();
             }
         } else if (isOtgFile()) {
             if (!exists(context)) {
@@ -977,12 +976,12 @@ public class HybridFile {
             FileUtil.mkdir(new File(path), context);
     }
 
-    public boolean delete(Context context, boolean rootmode) throws RootNotPermittedException {
+    public boolean delete(Context context, boolean rootmode) throws ShellNotRunningException {
         if (isSmb()) {
             try {
                 new SmbFile(path).delete();
             } catch (SmbException | MalformedURLException e) {
-                Logger.log(e, path, context);
+                e.printStackTrace();
             }
         } else {
             if (isRoot() && rootmode) {
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java b/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java
index 20b4b66f7..f5a665fcc 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/Operations.java
@@ -6,14 +6,13 @@ import android.os.Build;
 import android.support.annotation.NonNull;
 import android.support.v4.provider.DocumentFile;
 
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.utils.DataUtils;
-import com.amaze.filemanager.utils.cloud.CloudUtil;
-import com.amaze.filemanager.utils.Logger;
 import com.amaze.filemanager.utils.MainActivityHelper;
 import com.amaze.filemanager.utils.OTGUtil;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.RootUtils;
+import com.amaze.filemanager.utils.cloud.CloudUtil;
 import com.cloudrail.si.interfaces.CloudStorage;
 
 import java.io.ByteArrayInputStream;
@@ -109,7 +108,7 @@ public class Operations {
                     try {
                         file.getSmbFile(2000).mkdirs();
                     } catch (SmbException e) {
-                        Logger.log(e, file.getPath(), context);
+                        e.printStackTrace();
                         errorCallBack.done(file, false);
                         return null;
                     }
@@ -178,8 +177,8 @@ public class Operations {
                             try {
 
                                 RootUtils.mkDir(file.getParent(context), file.getName(context));
-                            } catch (RootNotPermittedException e) {
-                                Logger.log(e, file.getPath(), context);
+                            } catch (ShellNotRunningException e) {
+                                e.printStackTrace();
                             }
                             errorCallBack.done(file, file.exists());
                             return null;
@@ -219,7 +218,7 @@ public class Operations {
                     try {
                         file.getSmbFile(2000).createNewFile();
                     } catch (SmbException e) {
-                        Logger.log(e, file.getPath(), context);
+                        e.printStackTrace();
                         errorCallBack.done(file, false);
                         return null;
                     }
@@ -304,8 +303,8 @@ public class Operations {
                             try {
 
                                 RootUtils.mkFile(file.getPath());
-                            } catch (RootNotPermittedException e) {
-                                Logger.log(e, file.getPath(), context);
+                            } catch (ShellNotRunningException e) {
+                                e.printStackTrace();
                             }
                             errorCallBack.done(file, file.exists());
                             return null;
@@ -421,15 +420,15 @@ public class Operations {
                             } else if (mode == 1 || mode == 0) {
                                 try {
                                     FileUtil.renameFolder(file, file1, context);
-                                } catch (RootNotPermittedException e) {
+                                } catch (ShellNotRunningException e) {
                                     e.printStackTrace();
                                 }
                                 boolean a = !file.exists() && file1.exists();
                                 if (!a && rootMode) {
                                     try {
                                         RootUtils.rename(file.getPath(), file1.getPath());
-                                    } catch (Exception e) {
-                                        Logger.log(e, oldFile.getPath() + "\n" + newFile.getPath(), context);
+                                    } catch (ShellNotRunningException e) {
+                                        e.printStackTrace();
                                     }
                                     oldFile.setMode(OpenMode.ROOT);
                                     newFile.setMode(OpenMode.ROOT);
@@ -441,10 +440,9 @@ public class Operations {
                             break;
                         case ROOT:
                             try {
-
                                 RootUtils.rename(file.getPath(), file1.getPath());
-                            } catch (Exception e) {
-                                Logger.log(e, oldFile.getPath() + "\n" + newFile.getPath(), context);
+                            } catch (ShellNotRunningException e) {
+                                e.printStackTrace();
                             }
 
                             newFile.setMode(OpenMode.ROOT);
diff --git a/app/src/main/java/com/amaze/filemanager/filesystem/RootHelper.java b/app/src/main/java/com/amaze/filemanager/filesystem/RootHelper.java
index 60d92a566..8c3f04453 100644
--- a/app/src/main/java/com/amaze/filemanager/filesystem/RootHelper.java
+++ b/app/src/main/java/com/amaze/filemanager/filesystem/RootHelper.java
@@ -22,7 +22,7 @@ package com.amaze.filemanager.filesystem;
 import android.support.v4.provider.DocumentFile;
 
 import com.amaze.filemanager.activities.MainActivity;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.utils.OnFileFound;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.files.FileUtils;
@@ -43,11 +43,10 @@ public class RootHelper {
      * @param cmd the command
      * @return a list of results. Null only if the command passed is a blocking call or no output is
      * there for the command passed
-     * @throws RootNotPermittedException
      */
-    public static ArrayList<String> runShellCommand(String cmd) throws RootNotPermittedException {
+    public static ArrayList<String> runShellCommand(String cmd) throws ShellNotRunningException {
         if (MainActivity.shellInteractive == null || !MainActivity.shellInteractive.isRunning())
-            throw new RootNotPermittedException();
+            throw new ShellNotRunningException();
         final ArrayList<String> result = new ArrayList<>();
 
         // callback being called on a background handler thread
@@ -70,12 +69,11 @@ public class RootHelper {
      * @param callback
      * @return a list of results. Null only if the command passed is a blocking call or no output is
      * there for the command passed
-     * @throws RootNotPermittedException
      */
     public static void runShellCommand(String cmd, Shell.OnCommandResultListener callback)
-            throws RootNotPermittedException {
+            throws ShellNotRunningException {
         if (MainActivity.shellInteractive == null || !MainActivity.shellInteractive.isRunning())
-            throw new RootNotPermittedException();
+            throw new ShellNotRunningException();
         MainActivity.shellInteractive.addCommand(cmd, 0, callback);
         MainActivity.shellInteractive.waitForIdle();
     }
@@ -84,7 +82,7 @@ public class RootHelper {
      * @param cmd the command
      * @return a list of results. Null only if the command passed is a blocking call or no output is
      * there for the command passed
-     * @throws RootNotPermittedException
+     * @throws ShellNotRunningException
      * @deprecated Use {@link #runShellCommand(String)} instead which runs command on an interactive shell
      * <p>
      * Runs the command and stores output in a list. The listener is set on the caller thread,
@@ -198,9 +196,9 @@ public class RootHelper {
      *
      * @param path
      * @return
-     * @throws RootNotPermittedException
+     * @throws ShellNotRunningException
      */
-    public static boolean fileExists(String path) throws RootNotPermittedException {
+    public static boolean fileExists(String path) throws ShellNotRunningException {
         File f = new File(path);
         String p = f.getParent();
         if (p != null && p.length() > 0) {
@@ -232,7 +230,7 @@ public class RootHelper {
      * @return TODO: Avoid parsing ls
      */
     public static boolean isDirectory(String toTest, boolean root, int count)
-            throws RootNotPermittedException {
+            throws ShellNotRunningException {
         File f = new File(toTest);
         String name = f.getName();
         String p = f.getParent();
@@ -337,7 +335,7 @@ public class RootHelper {
                 }
 
                 if (getModeCallBack != null) getModeCallBack.getMode(mode);
-            } catch (RootNotPermittedException e) {
+            } catch (ShellNotRunningException e) {
                 e.printStackTrace();
             }
         }
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/FTPServerFragment.java b/app/src/main/java/com/amaze/filemanager/fragments/FTPServerFragment.java
index 615f28775..1d6e14727 100644
--- a/app/src/main/java/com/amaze/filemanager/fragments/FTPServerFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/fragments/FTPServerFragment.java
@@ -33,15 +33,16 @@ import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.asynchronous.ftpservice.FTPService;
-import com.amaze.filemanager.exceptions.CryptException;
 import com.amaze.filemanager.utils.Utils;
 import com.amaze.filemanager.utils.color.ColorUsage;
 import com.amaze.filemanager.utils.files.CryptUtil;
 import com.amaze.filemanager.utils.theme.AppTheme;
 
 import java.io.File;
+import java.io.IOException;
 import java.io.InputStream;
 import java.net.InetAddress;
+import java.security.GeneralSecurityException;
 
 /**
  * Created by yashwanthreddyg on 10-06-2016.
@@ -547,7 +548,7 @@ public class FTPServerFragment extends Fragment {
             } else {
                 return CryptUtil.decryptPassword(getContext(), encryptedPassword);
             }
-        } catch (CryptException e) {
+        } catch (GeneralSecurityException | IOException e) {
             e.printStackTrace();
 
             Toast.makeText(getContext(), getResources().getString(R.string.error), Toast.LENGTH_SHORT).show();
@@ -595,7 +596,7 @@ public class FTPServerFragment extends Fragment {
 
         try {
             preferences.edit().putString(FTPService.KEY_PREFERENCE_PASSWORD, CryptUtil.encryptPassword(getContext(), password)).apply();
-        } catch (CryptException e) {
+        } catch (GeneralSecurityException | IOException e) {
             e.printStackTrace();
             Toast.makeText(getContext(), getResources().getString(R.string.error), Toast.LENGTH_LONG).show();
         }
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/TabFragment.java b/app/src/main/java/com/amaze/filemanager/fragments/TabFragment.java
index ba7968989..53b94808d 100644
--- a/app/src/main/java/com/amaze/filemanager/fragments/TabFragment.java
+++ b/app/src/main/java/com/amaze/filemanager/fragments/TabFragment.java
@@ -28,7 +28,6 @@ import com.amaze.filemanager.ui.drawer.EntryItem;
 import com.amaze.filemanager.ui.views.DisablableViewPager;
 import com.amaze.filemanager.ui.views.Indicator;
 import com.amaze.filemanager.utils.DataUtils;
-import com.amaze.filemanager.utils.Logger;
 import com.amaze.filemanager.utils.MainActivityHelper;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.PreferenceUtils;
@@ -242,21 +241,16 @@ public class TabFragment extends android.support.v4.app.Fragment
     @Override
     public void onSaveInstanceState(Bundle outState) {
         super.onSaveInstanceState(outState);
-        try {
-            int i = 0;
-            if (sharedPrefs != null)
-                sharedPrefs.edit().putInt(PreferenceUtils.KEY_CURRENT_TAB, MainActivity.currentTab).commit();
-            if (fragments != null && fragments.size() != 0) {
-                if (fragmentManager == null) return;
-                for (Fragment fragment : fragments) {
-                    fragmentManager.putFragment(outState, "tab" + i, fragment);
-                    i++;
-                }
-                outState.putInt("pos", mViewPager.getCurrentItem());
+        int i = 0;
+        if (sharedPrefs != null)
+            sharedPrefs.edit().putInt(PreferenceUtils.KEY_CURRENT_TAB, MainActivity.currentTab).commit();
+        if (fragments != null && fragments.size() != 0) {
+            if (fragmentManager == null) return;
+            for (Fragment fragment : fragments) {
+                fragmentManager.putFragment(outState, "tab" + i, fragment);
+                i++;
             }
-        } catch (Exception e) {
-            Logger.log(e, "puttingtosavedinstance", getActivity());
-            e.printStackTrace();
+            outState.putInt("pos", mViewPager.getCurrentItem());
         }
     }
 
diff --git a/app/src/main/java/com/amaze/filemanager/fragments/preference_fragments/PrefFrag.java b/app/src/main/java/com/amaze/filemanager/fragments/preference_fragments/PrefFrag.java
index f8ec8f04b..59116ae4c 100644
--- a/app/src/main/java/com/amaze/filemanager/fragments/preference_fragments/PrefFrag.java
+++ b/app/src/main/java/com/amaze/filemanager/fragments/preference_fragments/PrefFrag.java
@@ -45,7 +45,6 @@ import com.amaze.filemanager.BuildConfig;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.AboutActivity;
 import com.amaze.filemanager.activities.PreferencesActivity;
-import com.amaze.filemanager.exceptions.CryptException;
 import com.amaze.filemanager.ui.views.preference.CheckBox;
 import com.amaze.filemanager.utils.MainActivityHelper;
 import com.amaze.filemanager.utils.PreferenceUtils;
@@ -54,6 +53,8 @@ import com.amaze.filemanager.utils.files.CryptUtil;
 import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
 import com.amaze.filemanager.utils.theme.AppTheme;
 
+import java.io.IOException;
+import java.security.GeneralSecurityException;
 import java.util.List;
 
 import static com.amaze.filemanager.R.string.feedback;
@@ -94,7 +95,6 @@ public class PrefFrag extends PreferenceFragment implements Preference.OnPrefere
         super.onCreate(savedInstanceState);
         utilsProvider = (UtilitiesProviderInterface) getActivity();
 
-        PreferenceUtils.reset();
         // Load the preferences from an XML resource
         addPreferencesFromResource(R.xml.preferences);
 
@@ -262,7 +262,7 @@ public class PrefFrag extends PreferenceFragment implements Preference.OnPrefere
                         // no password set in preferences, just leave the field empty
                         decryptedPassword = "";
                     }
-                } catch (CryptException e) {
+                } catch (GeneralSecurityException | IOException e) {
                     e.printStackTrace();
                 }
 
@@ -296,9 +296,8 @@ public class PrefFrag extends PreferenceFragment implements Preference.OnPrefere
                                 sharedPref.edit().putString(PREFERENCE_CRYPT_MASTER_PASSWORD,
                                         "").apply();
                             }
-                        } catch (CryptException e) {
+                        } catch (GeneralSecurityException | IOException e) {
                             e.printStackTrace();
-
                             sharedPref.edit().putString(PREFERENCE_CRYPT_MASTER_PASSWORD,
                                     PREFERENCE_CRYPT_MASTER_PASSWORD_DEFAULT).apply();
                         }
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java b/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java
index b38345a52..412fd3d34 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/GeneralDialogCreation.java
@@ -35,8 +35,7 @@ import com.amaze.filemanager.adapters.HiddenAdapter;
 import com.amaze.filemanager.asynchronous.asynctasks.CountItemsOrAndSizeTask;
 import com.amaze.filemanager.asynchronous.asynctasks.GenerateHashesTask;
 import com.amaze.filemanager.asynchronous.asynctasks.LoadFolderSpaceDataTask;
-import com.amaze.filemanager.exceptions.CryptException;
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.filesystem.HybridFile;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.RootHelper;
@@ -47,6 +46,7 @@ import com.amaze.filemanager.ui.LayoutElementParcelable;
 import com.amaze.filemanager.utils.DataUtils;
 import com.amaze.filemanager.utils.FingerprintHandler;
 import com.amaze.filemanager.utils.OpenMode;
+import com.amaze.filemanager.utils.RootUtils;
 import com.amaze.filemanager.utils.Utils;
 import com.amaze.filemanager.utils.color.ColorUsage;
 import com.amaze.filemanager.utils.files.CryptUtil;
@@ -63,7 +63,9 @@ import com.github.mikephil.charting.formatter.IValueFormatter;
 import com.github.mikephil.charting.utils.ViewPortHandler;
 
 import java.io.File;
+import java.io.IOException;
 import java.lang.ref.WeakReference;
+import java.security.GeneralSecurityException;
 import java.util.ArrayList;
 import java.util.List;
 import java.util.concurrent.ExecutorService;
@@ -630,7 +632,8 @@ public class GeneralDialogCreation {
     public static void showDecryptFingerprintDialog(final Context c, MainActivity main,
                                                     final Intent intent, AppTheme appTheme,
                                                     final EncryptDecryptUtils.DecryptButtonCallbackInterface
-                                                            decryptButtonCallbackInterface) throws CryptException {
+                                                            decryptButtonCallbackInterface)
+            throws GeneralSecurityException, IOException {
 
         int accentColor = main.getColorPreference().getColor(ColorUsage.ACCENT);
         MaterialDialog.Builder builder = new MaterialDialog.Builder(c);
@@ -907,28 +910,12 @@ public class GeneralDialogCreation {
         exegroup.setChecked(exe[1]);
         exeother.setChecked(exe[2]);
         but.setOnClickListener(v1 -> {
-            int a = 0, b = 0, c = 0;
-            if (readown.isChecked()) a = 4;
-            if (writeown.isChecked()) b = 2;
-            if (exeown.isChecked()) c = 1;
-            int owner = a + b + c;
-            int d = 0;
-            int e = 0;
-            int f1 = 0;
-            if (readgroup.isChecked()) d = 4;
-            if (writegroup.isChecked()) e = 2;
-            if (exegroup.isChecked()) f1 = 1;
-            int group = d + e + f1;
-            int g = 0, h = 0, i = 0;
-            if (readother.isChecked()) g = 4;
-            if (writeother.isChecked()) h = 2;
-            if (exeother.isChecked()) i = 1;
-            int other = g + h + i;
-            String finalValue = owner + "" + group + "" + other;
-
-            String command = "chmod " + finalValue + " " + file.getPath();
-            if (file.isDirectory())
-                command = "chmod -R " + finalValue + " \"" + file.getPath() + "\"";
+            int perms = RootUtils.permissionsToOctalString(readown.isChecked(), writeown.isChecked(), exeown.isChecked(),
+                                                                    readgroup.isChecked(), writegroup.isChecked(), exegroup.isChecked(),
+                                                                    readother.isChecked(), writeother.isChecked(), exeother.isChecked());
+
+            String options =  !file.isDirectory(context)? "-R":"";
+            String command = String.format(RootUtils.CHMOD_COMMAND, options, perms, file.getPath());
 
             try {
                 RootHelper.runShellCommand(command, (commandCode, exitCode, output) -> {
@@ -941,7 +928,7 @@ public class GeneralDialogCreation {
                     }
                 });
                 mainFrag.updateList();
-            } catch (RootNotPermittedException e1) {
+            } catch (ShellNotRunningException e1) {
                 Toast.makeText(context, mainFrag.getResources().getString(R.string.rootfailure),
                         Toast.LENGTH_LONG).show();
                 e1.printStackTrace();
diff --git a/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbConnectDialog.java b/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbConnectDialog.java
index 0f60a9d4a..f0cd8f1f3 100644
--- a/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbConnectDialog.java
+++ b/app/src/main/java/com/amaze/filemanager/ui/dialogs/SmbConnectDialog.java
@@ -21,7 +21,6 @@ import android.widget.Toast;
 import com.afollestad.materialdialogs.MaterialDialog;
 import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.superclasses.ThemedActivity;
-import com.amaze.filemanager.exceptions.CryptException;
 import com.amaze.filemanager.utils.EditTextColorStateUtil;
 import com.amaze.filemanager.utils.SimpleTextWatcher;
 import com.amaze.filemanager.utils.SmbUtil;
@@ -29,11 +28,13 @@ import com.amaze.filemanager.utils.Utils;
 import com.amaze.filemanager.utils.color.ColorUsage;
 import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
 
+import java.io.IOException;
 import java.io.UnsupportedEncodingException;
 import java.net.MalformedURLException;
 import java.net.URL;
 import java.net.URLDecoder;
 import java.net.URLEncoder;
+import java.security.GeneralSecurityException;
 
 import jcifs.smb.SmbFile;
 
@@ -264,8 +265,8 @@ public class SmbConnectDialog extends DialogFragment {
 
             try {
                 s = new String[]{conName.getText().toString(), SmbUtil.getSmbEncryptedPath(getActivity(),
-                        smbFile.getPath())};
-            } catch (CryptException e) {
+                            smbFile.getPath())};
+            } catch (GeneralSecurityException | IOException e) {
                 e.printStackTrace();
                 Toast.makeText(getActivity(), getResources().getString(R.string.error), Toast.LENGTH_LONG).show();
                 return;
diff --git a/app/src/main/java/com/amaze/filemanager/utils/ImmutableEntry.java b/app/src/main/java/com/amaze/filemanager/utils/ImmutableEntry.java
new file mode 100644
index 000000000..db57003c0
--- /dev/null
+++ b/app/src/main/java/com/amaze/filemanager/utils/ImmutableEntry.java
@@ -0,0 +1,53 @@
+/*
+ * Copyright (C) 2008 The Guava Authors
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ * http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ */
+
+package com.amaze.filemanager.utils;
+
+import android.support.annotation.Nullable;
+
+import java.util.Map;
+
+/**
+ * From: https://github.com/google/guava/blob/master/guava/src/com/google/common/collect/ImmutableEntry.java
+ * Author: Guava
+ */
+public class ImmutableEntry<K, V> implements Map.Entry<K, V> {
+    private final K key;
+    private final V value;
+
+    public ImmutableEntry(@Nullable K key, @Nullable V value) {
+        this.key = key;
+        this.value = value;
+    }
+
+    @Nullable
+    @Override
+    public final K getKey() {
+        return key;
+    }
+
+    @Nullable
+    @Override
+    public final V getValue() {
+        return value;
+    }
+
+    @Override
+    public final V setValue(V value) {
+        throw new UnsupportedOperationException();
+    }
+
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/amaze/filemanager/utils/InterestingConfigChange.java b/app/src/main/java/com/amaze/filemanager/utils/InterestingConfigChange.java
index e5e76e8b6..28fd03757 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/InterestingConfigChange.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/InterestingConfigChange.java
@@ -21,20 +21,12 @@ public class InterestingConfigChange {
     /**
      * Check for any config change between various callbacks to this method.
      * Make sure to recycle after done
-     * @param resources
-     * @return
      */
     public static boolean isConfigChanged(Resources resources) {
         int changedFieldsMask = lastConfiguration.updateFrom(resources.getConfiguration());
-        boolean densityChanged = lastDensity!=resources.getDisplayMetrics().densityDpi;
-
-        if (densityChanged || (changedFieldsMask &
-                (ActivityInfo.CONFIG_SCREEN_LAYOUT | ActivityInfo.CONFIG_UI_MODE | ActivityInfo.CONFIG_LOCALE)) != 0) {
-            // we have density changed from last time we came here
-            return true;
-        }
-
-        return false;
+        boolean densityChanged = lastDensity != resources.getDisplayMetrics().densityDpi;
+        int mode = ActivityInfo.CONFIG_SCREEN_LAYOUT | ActivityInfo.CONFIG_UI_MODE | ActivityInfo.CONFIG_LOCALE;
+        return densityChanged || (changedFieldsMask & mode) != 0;
     }
 
     /**
diff --git a/app/src/main/java/com/amaze/filemanager/utils/Logger.java b/app/src/main/java/com/amaze/filemanager/utils/Logger.java
deleted file mode 100644
index f5d746c36..000000000
--- a/app/src/main/java/com/amaze/filemanager/utils/Logger.java
+++ /dev/null
@@ -1,37 +0,0 @@
-package com.amaze.filemanager.utils;
-
-import android.content.Context;
-
-import java.io.BufferedWriter;
-import java.io.File;
-import java.io.FileWriter;
-import java.io.IOException;
-import java.io.PrintWriter;
-import java.io.StringWriter;
-
-/**
- * Created by arpitkh996 on 13-01-2016.
- */
-public class Logger {
-
-    public static void log(final Exception s, final String s1, Context context) {
-        if (context == null) return;
-        final File f = new File(context.getExternalFilesDir("internal"), "log.txt");
-        new Thread(() -> {
-            FileWriter output = null;
-            try {
-                StringWriter sw = new StringWriter();
-                PrintWriter pw = new PrintWriter(sw);
-                if (s != null)
-                    s.printStackTrace(pw);
-                output = new FileWriter(f.getPath());
-                BufferedWriter writer = new BufferedWriter(output);
-                writer.write(s1 + "\n");
-                writer.write(sw.toString());
-                writer.close();
-                output.close();
-            } catch (IOException e) {
-            }
-        }).start();
-    }
-}
diff --git a/app/src/main/java/com/amaze/filemanager/utils/MapEntry.java b/app/src/main/java/com/amaze/filemanager/utils/MapEntry.java
index f06fb58da..08424c860 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/MapEntry.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/MapEntry.java
@@ -1,65 +1,19 @@
 package com.amaze.filemanager.utils;
 
-import java.util.LinkedHashMap;
-import java.util.Map;
-
 /**
- * Created by Vishal on 21/12/15.
+ * Created by Vishal on 21/12/15 edited by Emmanuel Messulam <emmanuelbendavid@gmail.com>
  * A helper class which provides data structure of key/value pair
+ *
+ * typedef ImmutableEntry<ImmutableEntry<Integer, Integer>, Integer> MapEntry
  */
-public class MapEntry implements Map.Entry {
-
-    private KeyMapEntry key;
-    private Integer value;
+public class MapEntry extends ImmutableEntry<ImmutableEntry<Integer, Integer>, Integer> {
 
     /**
      * Constructor to provide values to the pair
-     * @param key object of {@link KeyMapEntry} which is another key/value pair
+     * @param key object of {@link ImmutableEntry} which is another key/value pair
      * @param value integer object in the pair
      */
-    public MapEntry(KeyMapEntry key, Integer value) {
-        this.key = key;
-        this.value = value;
-    }
-    @Override
-    public Object getKey() {
-        return this.key;
-    }
-
-    @Override
-    public Object getValue() {
-        return this.value;
-    }
-
-    @Override
-    public Object setValue(Object object) {
-        // use constructor
-        return null;
-    }
-
-    public static class KeyMapEntry implements Map.Entry {
-
-        private Integer key, value;
-
-        public KeyMapEntry(Integer key, Integer value) {
-            this.key = key;
-            this.value = value;
-        }
-
-        @Override
-        public Object getKey() {
-            return this.key;
-        }
-
-        @Override
-        public Object getValue() {
-            return this.value;
-        }
-
-        @Override
-        public Object setValue(Object object) {
-            // use constructor
-            return null;
-        }
+    public MapEntry(ImmutableEntry<Integer, Integer> key, Integer value) {
+        super(key, value);
     }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/OTGUtil.java b/app/src/main/java/com/amaze/filemanager/utils/OTGUtil.java
index 7f11bc623..2de138a36 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/OTGUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/OTGUtil.java
@@ -32,12 +32,7 @@ public class OTGUtil {
      */
     public static ArrayList<HybridFileParcelable> getDocumentFilesList(String path, Context context) {
         final ArrayList<HybridFileParcelable> files = new ArrayList<>();
-        getDocumentFiles(path, context, new OnFileFound() {
-            @Override
-            public void onFileFound(HybridFileParcelable file) {
-                files.add(file);
-            }
-        });
+        getDocumentFiles(path, context, files::add);
         return files;
     }
 
@@ -55,13 +50,13 @@ public class OTGUtil {
         DocumentFile rootUri = DocumentFile.fromTreeUri(context, Uri.parse(rootUriString));
 
         String[] parts = path.split("/");
-        for (int i = 0; i < parts.length; i++) {
+        for (String part : parts) {
             // first omit 'otg:/' before iterating through DocumentFile
             if (path.equals(OTGUtil.PREFIX_OTG + "/")) break;
-            if (parts[i].equals("otg:") || parts[i].equals("")) continue;
-            Log.d(context.getClass().getSimpleName(), "Currently at: " + parts[i]);
+            if (part.equals("otg:") || part.equals("")) continue;
+
             // iterating through the required path to find the end point
-            rootUri = rootUri.findFile(parts[i]);
+            rootUri = rootUri.findFile(part);
         }
 
         // we have the end point DocumentFile, list the files inside it and return
@@ -82,11 +77,8 @@ public class OTGUtil {
     /**
      * Traverse to a specified path in OTG
      *
-     * @param path
-     * @param context
      * @param createRecursive flag used to determine whether to create new file while traversing to path,
      *                        in case path is not present. Notably useful in opening an output stream.
-     * @return
      */
     public static DocumentFile getDocumentFile(String path, Context context, boolean createRecursive) {
         SharedPreferences manager = PreferenceManager.getDefaultSharedPreferences(context);
@@ -96,22 +88,18 @@ public class OTGUtil {
         DocumentFile rootUri = DocumentFile.fromTreeUri(context, Uri.parse(rootUriString));
 
         String[] parts = path.split("/");
-        for (int i = 0; i < parts.length; i++) {
-
+        for (String part : parts) {
             if (path.equals("otg:/")) break;
-            if (parts[i].equals("otg:") || parts[i].equals("")) continue;
-            Log.d(context.getClass().getSimpleName(), "Currently at: " + parts[i]);
-            // iterating through the required path to find the end point
+            if (part.equals("otg:") || part.equals("")) continue;
 
-            DocumentFile nextDocument = rootUri.findFile(parts[i]);
-            if (createRecursive) {
-                if (nextDocument == null || !nextDocument.exists()) {
-                    nextDocument = rootUri.createFile(parts[i].substring(parts[i].lastIndexOf(".")), parts[i]);
-                    Log.d(context.getClass().getSimpleName(), "NOT FOUND! File created: " + parts[i]);
-                }
+            // iterating through the required path to find the end point
+            DocumentFile nextDocument = rootUri.findFile(part);
+            if (createRecursive && (nextDocument == null || !nextDocument.exists())) {
+                nextDocument = rootUri.createFile(part.substring(part.lastIndexOf(".")), part);
             }
             rootUri = nextDocument;
         }
+
         return rootUri;
     }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/PreferenceUtils.java b/app/src/main/java/com/amaze/filemanager/utils/PreferenceUtils.java
index f4e7df77e..6a88eee2e 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/PreferenceUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/PreferenceUtils.java
@@ -1,15 +1,11 @@
 package com.amaze.filemanager.utils;
 
-import android.content.SharedPreferences;
 import android.graphics.Color;
 
-import java.util.Calendar;
-
 /**
  * Created by Vishal on 12-05-2015.
  */
 public class PreferenceUtils {
-    private static int primary = -1, accent = -1, folder = -1, primaryTwo = -1;
 
     public static final String KEY_PRIMARY_TWO = "skin_two";
     public static final String KEY_PRIMARY = "skin";
@@ -25,43 +21,22 @@ public class PreferenceUtils {
     public static final int DEFAULT_CURRENT_TAB = 1;
 
     public static int getStatusColor(String skin) {
-        return darker(Color.parseColor(skin),0.6f);
+        return darker(Color.parseColor(skin));
     }
 
     public static int getStatusColor(int skin) {
-        return darker(skin,0.6f);
+        return darker(skin);
     }
 
-    public static int darker (int color, float factor) {
+    private static int darker(int color) {
         int a = Color.alpha(color);
-        int r = Color.red( color );
-        int g = Color.green( color );
-        int b = Color.blue( color );
-
-        return Color.argb( a,
-                Math.max( (int)(r * factor), 0 ),
-                Math.max( (int)(g * factor), 0 ),
-                Math.max( (int)(b * factor), 0 ) );
-    }
-
-    /**
-     * Get primary color of second tab from preferences
-     * @return the color position in color array; from the preferences
-     */
-    public static int getPrimaryTwoColor(SharedPreferences Sp) {
-        return primaryTwo==-1 ? Sp.getInt(KEY_PRIMARY_TWO, DEFAULT_PRIMARY) : null;
-    }
-
-    public static int getFolderColor(SharedPreferences Sp){
-        if(folder==DEFAULT_ICON) {
-            int icon = Sp.getInt(KEY_ICON_SKIN, DEFAULT_ICON);
-            folder = icon == DEFAULT_ICON ? Sp.getInt(KEY_ACCENT, DEFAULT_ACCENT) : icon;
-        }
-        return folder;
-    }
+        int r = Color.red(color);
+        int g = Color.green(color);
+        int b = Color.blue(color);
 
-    public static void reset(){
-        primary=accent=folder=primaryTwo=-1;
+        return Color.argb(a, Math.max((int) (r * 0.6f), 0),
+                Math.max((int) (g * 0.6f), 0),
+                Math.max((int) (b * 0.6f), 0));
     }
 
     public static final String LICENCE_TERMS = "<html><body>" +
@@ -300,13 +275,4 @@ public class PreferenceUtils {
             "<br><br></code></p>" +
             "</body></html>";
 
-    @Deprecated
-    public static int hourOfDay() {
-        Calendar calendar = Calendar.getInstance();
-        int hour = calendar.get(Calendar.HOUR_OF_DAY);
-        if (hour <= 6 || hour >= 18) {
-            return 1;
-        } else
-            return 0;
-    }
 }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/RootUtils.java b/app/src/main/java/com/amaze/filemanager/utils/RootUtils.java
index 2684f9c5a..47118f4d4 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/RootUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/RootUtils.java
@@ -4,14 +4,20 @@ package com.amaze.filemanager.utils;
  * Created by arpitkh996 on 25-01-2016.
  */
 
-import com.amaze.filemanager.exceptions.RootNotPermittedException;
+import com.amaze.filemanager.exceptions.ShellNotRunningException;
 import com.amaze.filemanager.filesystem.RootHelper;
 
 import java.util.ArrayList;
 import java.util.regex.Pattern;
 
 public class RootUtils {
+    public static final int CHMOD_READ = 4, CHMOD_WRITE = 2, CHMOD_EXECUTE = 1;
     public static final String DATA_APP_DIR = "/data/app";
+    /**
+     * This is the chmod command, it should be used with String.format().
+     * String.format(CHMOD_COMMAND, options, permsOctalInt, path);
+     */
+    public static final String CHMOD_COMMAND = "chmod %s %o \"%s\"";
     private static final String LS = "ls -lAnH \"%\" --color=never";
     private static final String LSDIR = "ls -land \"%\" --color=never";
     public static final String SYSTEM_APP_DIR = "/system/app";
@@ -21,55 +27,15 @@ public class RootUtils {
         mLsPattern = Pattern.compile(".[rwxsStT-]{9}\\s+.*");
     }
 
-    public static boolean isValid(String str) {
-        return mLsPattern.matcher(str).matches();
-    }
-
-    public static boolean isUnixVirtualDirectory(String str) {
-        return str.startsWith("/proc") || str.startsWith("/sys");
-    }
-
-    /**
-     * Get a shell based listing
-     * Context is superuser level shell
-     * @param str
-     * @return
-     */
-    public static ArrayList<String> getDirListingSu(String str) throws RootNotPermittedException {
-        ArrayList<String> arrayLis=RootHelper.runShellCommand(LS.replace("%", str));
-        return arrayLis;
-    }
-
-    /**
-     * Change permissions (owner/group/others) of a specified path
-     * @param path
-     * @param octalNotation octal notation of permission
-     * @throws RootNotPermittedException
-     */
-    public static void chmod(String path, int octalNotation) throws RootNotPermittedException {
-
-        String mountPoint = mountFileSystemRW(path);
-
-        String command = "chmod %d \"%s\"";
-
-        RootHelper.runShellCommand(String.format(command, octalNotation, path));
-
-        if (mountPoint!=null) {
-            // we mounted the filesystem as rw, let's mount it back to ro
-            mountFileSystemRO(mountPoint);
-        }
-    }
-
-
     /**
      * Mount filesystem associated with path for writable access (rw)
      * Since we don't have the root of filesystem to remount, we need to parse output of
      * # mount command.
+     *
      * @param path the path on which action to perform
      * @return String the root of mount point that was ro, and mounted to rw; null otherwise
-     * @throws RootNotPermittedException
      */
-    private static String mountFileSystemRW(String path) throws RootNotPermittedException {
+    private static String mountFileSystemRW(String path) throws ShellNotRunningException {
         String command = "mount";
         ArrayList<String> output = RootHelper.runShellCommand(command);
         String mountPoint = "", types = null;
@@ -87,8 +53,7 @@ public class RootUtils {
             }
         }
 
-        if (!mountPoint.equals("") && types!=null) {
-
+        if (!mountPoint.equals("") && types != null) {
             // we have the mountpoint, check for mount options if already rw
             if (types.contains("rw")) {
                 // already a rw filesystem return
@@ -98,7 +63,7 @@ public class RootUtils {
                 String mountCommand = "mount -o rw,remount " + mountPoint;
                 ArrayList<String> mountOutput = RootHelper.runShellCommand(mountCommand);
 
-                if (mountOutput.size()!=0) {
+                if (mountOutput.size() != 0) {
                     // command failed, and we got a reason echo'ed
                     return null;
                 } else return mountPoint;
@@ -109,28 +74,24 @@ public class RootUtils {
 
     /**
      * Mount path for read-only access (ro)
+     *
      * @param path the root of device/filesystem to be mounted as ro
-     * @throws RootNotPermittedException
      */
-    private static void mountFileSystemRO(String path) throws RootNotPermittedException {
+    private static void mountFileSystemRO(String path) throws ShellNotRunningException {
         String command = "umount -r \"" + path + "\"";
         RootHelper.runShellCommand(command);
     }
 
     /**
      * Copies file using root
-     * @param source
-     * @param destination
-     * @throws RootNotPermittedException
      */
-    public static void copy(String source, String destination) throws RootNotPermittedException {
-
+    public static void copy(String source, String destination) throws ShellNotRunningException {
         // remounting destination as rw
         String mountPoint = mountFileSystemRW(destination);
 
         RootHelper.runShellCommand("cp \"" + source + "\" \"" + destination + "\"");
 
-        if (mountPoint!=null) {
+        if (mountPoint != null) {
             // we mounted the filesystem as rw, let's mount it back to ro
             mountFileSystemRO(mountPoint);
         }
@@ -138,16 +99,16 @@ public class RootUtils {
 
     /**
      * Creates an empty directory using root
+     *
      * @param path path to new directory
      * @param name name of directory
-     * @throws RootNotPermittedException
      */
-    public static void mkDir(String path, String name) throws RootNotPermittedException {
+    public static void mkDir(String path, String name) throws ShellNotRunningException {
 
         String mountPoint = mountFileSystemRW(path);
 
         RootHelper.runShellCommand("mkdir \"" + path + "/" + name + "\"");
-        if (mountPoint!=null) {
+        if (mountPoint != null) {
             // we mounted the filesystem as rw, let's mount it back to ro
             mountFileSystemRO(mountPoint);
         }
@@ -155,28 +116,24 @@ public class RootUtils {
 
     /**
      * Creates an empty file using root
+     *
      * @param path path to new file
-     * @throws RootNotPermittedException
      */
-    public static void mkFile(String path) throws RootNotPermittedException {
-
+    public static void mkFile(String path) throws ShellNotRunningException {
         String mountPoint = mountFileSystemRW(path);
 
-        RootHelper.runShellCommand("touch \"" + path +"\"");
-        if (mountPoint!=null) {
+        RootHelper.runShellCommand("touch \"" + path + "\"");
+        if (mountPoint != null) {
             // we mounted the filesystem as rw, let's mount it back to ro
             mountFileSystemRO(mountPoint);
         }
     }
 
-
     /**
      * Returns file permissions in octal notation
      * Method requires busybox
-     * @param path
-     * @return
      */
-    private static int getFilePermissions(String path) throws RootNotPermittedException {
+    private static int getFilePermissions(String path) throws ShellNotRunningException {
         String line = RootHelper.runShellCommand("stat -c  %a \"" + path + "\"").get(0);
 
         return Integer.valueOf(line);
@@ -184,45 +141,32 @@ public class RootUtils {
 
     /**
      * Recursively removes a path with it's contents (if any)
-     * @param path
+     *
      * @return boolean whether file was deleted or not
-     * @throws RootNotPermittedException
      */
-    public static boolean delete(String path) throws RootNotPermittedException {
-
+    public static boolean delete(String path) throws ShellNotRunningException {
         String mountPoint = mountFileSystemRW(path);
-
         ArrayList<String> result = RootHelper.runShellCommand("rm -rf \"" + path + "\"");
 
-        if (mountPoint!=null) {
+        if (mountPoint != null) {
             // we mounted the filesystem as rw, let's mount it back to ro
             mountFileSystemRO(mountPoint);
         }
 
-        return result.size()!=0;
+        return result.size() != 0;
     }
 
-    /*public static boolean isBusyboxAvailable() throws RootNotPermittedException {
-        ArrayList<String> output = RootHelper.runShellCommand("busybox");
-        return output.size()!=0;
-    }*/
-
     /**
      * Moves file using root
-     * @param path
-     * @param destination
-     * @throws RootNotPermittedException
      */
-    public static void move(String path, String destination)
-            throws RootNotPermittedException {
-
+    public static void move(String path, String destination) throws ShellNotRunningException {
         // remounting destination as rw
         String mountPoint = mountFileSystemRW(destination);
 
         //mountOwnerRW(mountPath);
         RootHelper.runShellCommand("mv \"" + path + "\" \"" + destination + "\"");
 
-        if (mountPoint!=null) {
+        if (mountPoint != null) {
             // we mounted the filesystem as rw, let's mount it back to ro
             mountFileSystemRO(mountPoint);
         }
@@ -230,74 +174,48 @@ public class RootUtils {
 
     /**
      * Renames file using root
+     *
      * @param oldPath path to file before rename
      * @param newPath path to file after rename
-     * @throws RootNotPermittedException
      * @return if rename was successful or not
      */
-    public static boolean rename(String oldPath, String newPath)
-            throws RootNotPermittedException {
-
+    public static boolean rename(String oldPath, String newPath) throws ShellNotRunningException {
         String mountPoint = mountFileSystemRW(oldPath);
-
         ArrayList<String> output = RootHelper.runShellCommand("mv \"" + oldPath + "\" \"" + newPath + "\"");
 
-        if (mountPoint!=null) {
+        if (mountPoint != null) {
             // we mounted the filesystem as rw, let's mount it back to ro
             mountFileSystemRO(mountPoint);
         }
 
-        return output.size()==0;
+        return output.size() == 0;
     }
 
     public static void cat(String sourcePath, String destinationPath)
-            throws RootNotPermittedException {
+            throws ShellNotRunningException {
 
         String mountPoint = mountFileSystemRW(destinationPath);
 
         RootHelper.runShellCommand("cat \"" + sourcePath + "\" > \"" + destinationPath + "\"");
-        if (mountPoint!=null) {
+        if (mountPoint != null) {
             // we mounted the filesystem as rw, let's mount it back to ro
             mountFileSystemRO(mountPoint);
         }
     }
 
-    public static String parsePermission(String permLine) {
-        int owner = 0;
-        int READ = 4;
-        int WRITE = 2;
-        int EXECUTE = 1;
-        if (permLine.charAt(1) == 'r') {
-            owner += READ;
-        }
-        if (permLine.charAt(2) == 'w') {
-            owner += WRITE;
-        }
-        if (permLine.charAt(3) == 'x') {
-            owner += EXECUTE;
-        }
-        int group = 0;
-        if (permLine.charAt(4) == 'r') {
-            group += READ;
-        }
-        if (permLine.charAt(5) == 'w') {
-            group += WRITE;
-        }
-        if (permLine.charAt(6) == 'x') {
-            group += EXECUTE;
-        }
-        int world = 0;
-        if (permLine.charAt(7) == 'r') {
-            world += READ;
-        }
-        if (permLine.charAt(8) == 'w') {
-            world += WRITE;
-        }
-        if (permLine.charAt(9) == 'x') {
-            world += EXECUTE;
-        }
-        String finalValue = owner + "" + group + "" + world;
-        return finalValue;
+    /**
+     * This converts from a set of booleans to OCTAL permissions notations.
+     * For use with {@link RootUtils.CHMOD_COMMAND}
+     * (true, false, false,  true, true, false,  false, false, true) => 0461
+     */
+    public static int permissionsToOctalString(boolean ur, boolean uw, boolean ux,
+                                                  boolean gr, boolean gw, boolean gx,
+                                                  boolean or, boolean ow, boolean ox) {
+        int u = ((ur?CHMOD_READ:0) | (uw?CHMOD_WRITE:0) | (ux?CHMOD_EXECUTE:0)) << 6;
+        int g = ((gr?CHMOD_READ:0) | (gw?CHMOD_WRITE:0) | (gx?CHMOD_EXECUTE:0)) << 3;
+        int o = (or?CHMOD_READ:0) | (ow?CHMOD_WRITE:0) | (ox?CHMOD_EXECUTE:0);
+        return u | g | o;
     }
+
 }
 
diff --git a/app/src/main/java/com/amaze/filemanager/utils/SmbStreamer/StreamServer.java b/app/src/main/java/com/amaze/filemanager/utils/SmbStreamer/StreamServer.java
index 698e8b76c..262d5344d 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/SmbStreamer/StreamServer.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/SmbStreamer/StreamServer.java
@@ -18,7 +18,6 @@ import java.io.OutputStream;
 import java.io.PrintWriter;
 import java.net.ServerSocket;
 import java.net.Socket;
-import java.net.URLEncoder;
 import java.util.Date;
 import java.util.Enumeration;
 import java.util.Locale;
@@ -92,44 +91,16 @@ public abstract class StreamServer {
      * HTTP response.
      * Return one of these from serve().
      */
-    public class Response
-    {
-        /**
-         * Default constructor: response = HTTP_OK, data = mime = 'null'
-         */
-        public Response()
-        {
-            this.status = HTTP_OK;
-        }
-
+    public class Response {
         /**
          * Basic constructor.
          */
-        public Response( String status, String mimeType, StreamSource data )
-        {
+        public Response( String status, String mimeType, StreamSource data ) {
             this.status = status;
             this.mimeType = mimeType;
             this.data = data;
         }
 
-        /**
-         * Convenience method that makes an InputStream out of
-         * given text.
-         */
-        //              public Response( String status, String mimeType, String txt )
-        //              {
-        //                      this.status = status;
-        //                      this.mimeType = mimeType;
-        //                      try
-        //                      {
-        //                              this.data = new ByteArrayInputStream( txt.getBytes("UTF-8"));
-        //                      }
-        //                      catch ( java.io.UnsupportedEncodingException uee )
-        //                      {
-        //                              uee.printStackTrace();
-        //                      }
-        //              }
-
         /**
          * Adds given line to the header.
          */
@@ -193,22 +164,13 @@ public abstract class StreamServer {
      */
 
     //private HTTPSession session;
-    public StreamServer( int port, File wwwroot ) throws IOException
-    {
+    public StreamServer( int port, File wwwroot ) throws IOException {
         myTcpPort = port;
         this.myRootDir = wwwroot;
         myServerSocket = new ServerSocket( myTcpPort );
         myThread = new Thread(() -> {
             try {
                 while (true) {
-                    //                                                      if(session!=null){
-                    //                                                              session.interrupt();
-                    //                                                              try {
-                    //                                                                      session.join();
-                    //                                                              } catch (InterruptedException e) {
-                    //                                                                      e.printStackTrace();
-                    //                                                              }
-                    //                                                      }
                     Socket accept = myServerSocket.accept();
                     new HTTPSession(accept);
                 }
@@ -219,129 +181,54 @@ public abstract class StreamServer {
         myThread.start();
     }
 
-    public StreamServer( File wwwroot ) throws IOException
-    {
-        this.myRootDir = wwwroot;
-        myServerSocket = new ServerSocket( myTcpPort );
-        myThread = new Thread(() -> {
-            try {
-                while (true) {
-                    //                                                      if(session!=null){
-                    //                                                              session.interrupt();
-                    //                                                              try {
-                    //                                                                      session.join();
-                    //                                                              } catch (InterruptedException e) {
-                    //                                                                      e.printStackTrace();
-                    //                                                              }
-                    //                                                      }
-                    Socket accept = myServerSocket.accept();
-                    new HTTPSession(accept);
-                }
-            } catch (IOException ioe) {
-            }
-        });
-        myThread.setDaemon( true );
-        myThread.start();
-    }
 
     /**
      * Stops the server.
      */
-    public void stop()
-    {
-        try
-        {
+    public void stop() {
+        try {
             myServerSocket.close();
             myThread.join();
+        } catch (IOException | InterruptedException e) {
         }
-        catch ( IOException ioe ) {}
-        catch ( InterruptedException e ) {}
     }
 
-    //
-    //      /**
-    //       * Starts as a standalone file server and waits for Enter.
-    //       */
-    //      public static void main( String[] args )
-    //      {
-    //              System.out.println( "NanoHTTPD 1.24 (C) 2001,2005-2011 Jarno Elonen and (C) 2010 Konstantinos Togias\n" +
-    //                                                      "(Command line options: [-p port] [-d root-dir] [--licence])\n" );
-    //
-    //              // Defaults
-    //              int port = 80;
-    //              File wwwroot = new File(".").getAbsoluteFile();
-    //
-    //              // Show licence if requested
-    //              for ( int i=0; i<args.length; ++i )
-    //              if(args[i].equalsIgnoreCase("-p"))
-    //                      port = Integer.parseInt( args[i+1] );
-    //              else if(args[i].equalsIgnoreCase("-d"))
-    //                      wwwroot = new File( args[i+1] ).getAbsoluteFile();
-    //              else if ( args[i].toLowerCase().endsWith( "licence" ))
-    //              {
-    //                      System.out.println( LICENCE + "\n" );
-    //                      break;
-    //              }
-    //
-    //              try
-    //              {
-    //                      new NanoHTTPD( port, wwwroot );
-    //              }
-    //              catch( IOException ioe )
-    //              {
-    //                      System.err.println( "Couldn't start server:\n" + ioe );
-    //                      System.exit( -1 );
-    //              }
-    //
-    //              System.out.println( "Now serving files in port " + port + " from \"" + wwwroot + "\"" );
-    //              System.out.println( "Hit Enter to stop.\n" );
-    //
-    //              try { System.in.read(); } catch( Throwable t ) {}
-    //      }
-
     /**
      * Handles one session, i.e. parses the HTTP request
      * and returns the response.
      */
-    private class HTTPSession implements Runnable
-    {
+    private class HTTPSession implements Runnable {
         private InputStream is;
         private final Socket socket;
 
-        public HTTPSession( Socket s )
-        {
+        public HTTPSession(Socket s) {
             socket = s;
             //mySocket = s;
-            Thread t = new Thread( this );
-            t.setDaemon( true );
+            Thread t = new Thread(this);
+            t.setDaemon(true);
             t.start();
         }
 
-        public void run()
-        {
-            try{
+        public void run() {
+            try {
                 //openInputStream();
                 handleResponse(socket);
-            }finally {
-                if(is!=null) {
-                    try{
+            } finally {
+                if (is != null) {
+                    try {
                         is.close();
                         socket.close();
-                    }catch(IOException e){
+                    } catch (IOException e) {
                         e.printStackTrace();
                     }
                 }
             }
         }
 
-//              private void openInputStream() throws IOException {
-//                      is = socket.getInputStream();
-//              }
-
         private void handleResponse(Socket socket) {
             try {
                 is = socket.getInputStream();
-                if ( is == null) return;
+                if (is == null) return;
 
                 // Read the first 8192 bytes.
                 // The full header should fit in here.
@@ -353,7 +240,7 @@ public abstract class StreamServer {
 
                 // Create a BufferedReader for parsing the header.
                 ByteArrayInputStream hbis = new ByteArrayInputStream(buf, 0, rlen);
-                BufferedReader hin = new BufferedReader( new InputStreamReader( hbis , "utf-8"));
+                BufferedReader hin = new BufferedReader(new InputStreamReader(hbis, "utf-8"));
                 Properties pre = new Properties();
                 Properties parms = new Properties();
                 Properties header = new Properties();
@@ -362,25 +249,25 @@ public abstract class StreamServer {
                 // Decode the header into parms and header java properties
                 decodeHeader(hin, pre, parms, header);
                 Log.d("Explorer", pre.toString());
-                Log.d("Explorer", "Params: "+parms.toString());
-                Log.d("Explorer", "Header: "+header.toString());
+                Log.d("Explorer", "Params: " + parms.toString());
+                Log.d("Explorer", "Header: " + header.toString());
                 String method = pre.getProperty("method");
                 String uri = pre.getProperty("uri");
 
                 long size = 0x7FFFFFFFFFFFFFFFL;
                 String contentLength = header.getProperty("content-length");
-                if (contentLength != null)
-                {
-                    try { size = Integer.parseInt(contentLength); }
-                    catch (NumberFormatException ex) {}
+                if (contentLength != null) {
+                    try {
+                        size = Integer.parseInt(contentLength);
+                    } catch (NumberFormatException ex) {
+                    }
                 }
 
                 // We are looking for the byte separating header from body.
                 // It must be the last byte of the first two sequential new lines.
                 int splitbyte = 0;
                 boolean sbfound = false;
-                while (splitbyte < rlen)
-                {
+                while (splitbyte < rlen) {
                     if (buf[splitbyte] == '\r' && buf[++splitbyte] == '\n' && buf[++splitbyte] == '\r' && buf[++splitbyte] == '\n') {
                         sbfound = true;
                         break;
@@ -391,7 +278,7 @@ public abstract class StreamServer {
 
                 // Write the part of body already read to ByteArrayOutputStream f
                 ByteArrayOutputStream f = new ByteArrayOutputStream();
-                if (splitbyte < rlen) f.write(buf, splitbyte, rlen-splitbyte);
+                if (splitbyte < rlen) f.write(buf, splitbyte, rlen - splitbyte);
 
                 // While Firefox sends on the first read all the data fitting
                 // our buffer, Chrome and Opera sends only the headers even if
@@ -400,14 +287,13 @@ public abstract class StreamServer {
                 // have reached the end of the data to be sent or we should
                 // expect the first byte of the body at the next read.
                 if (splitbyte < rlen)
-                    size -= rlen - splitbyte +1;
+                    size -= rlen - splitbyte + 1;
                 else if (!sbfound || size == 0x7FFFFFFFFFFFFFFFL)
                     size = 0;
 
                 // Now read all the body and write it to f
                 buf = new byte[512];
-                while ( rlen >= 0 && size > 0 )
-                {
+                while (rlen >= 0 && size > 0) {
                     rlen = is.read(buf, 0, 512);
                     size -= rlen;
                     if (rlen > 0)
@@ -415,75 +301,65 @@ public abstract class StreamServer {
                 }
 
                 // Get the raw body as a byte []
-                byte [] fbuf = f.toByteArray();
+                byte[] fbuf = f.toByteArray();
 
                 // Create a BufferedReader for easily reading it as string.
                 ByteArrayInputStream bin = new ByteArrayInputStream(fbuf);
-                BufferedReader in = new BufferedReader( new InputStreamReader(bin));
+                BufferedReader in = new BufferedReader(new InputStreamReader(bin));
 
                 // If the method is POST, there may be parameters
                 // in data section, too, read it:
-                if ( method.equalsIgnoreCase( "POST" ))
-                {
+                if (method.equalsIgnoreCase("POST")) {
                     String contentType = "";
                     String contentTypeHeader = header.getProperty("content-type");
-                    StringTokenizer st = new StringTokenizer( contentTypeHeader , "; " );
-                    if ( st.hasMoreTokens()) {
+                    StringTokenizer st = new StringTokenizer(contentTypeHeader, "; ");
+                    if (st.hasMoreTokens()) {
                         contentType = st.nextToken();
                     }
 
-                    if (contentType.equalsIgnoreCase("multipart/form-data"))
-                    {
+                    if (contentType.equalsIgnoreCase("multipart/form-data")) {
                         // Handle multipart/form-data
-                        if ( !st.hasMoreTokens())
-                            sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Content type is multipart/form-data but boundary missing. Usage: GET /example/file.html" );
+                        if (!st.hasMoreTokens())
+                            sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Content type is multipart/form-data but boundary missing. Usage: GET /example/file.html");
                         String boundaryExp = st.nextToken();
-                        st = new StringTokenizer( boundaryExp , "=" );
+                        st = new StringTokenizer(boundaryExp, "=");
                         if (st.countTokens() != 2)
-                            sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Content type is multipart/form-data but boundary syntax error. Usage: GET /example/file.html" );
+                            sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Content type is multipart/form-data but boundary syntax error. Usage: GET /example/file.html");
                         st.nextToken();
                         String boundary = st.nextToken();
 
                         decodeMultipartData(boundary, fbuf, in, parms, files);
-                    }
-                    else
-                    {
+                    } else {
                         // Handle application/x-www-form-urlencoded
                         String postLine = "";
                         char pbuf[] = new char[512];
                         int read = in.read(pbuf);
-                        while ( read >= 0 && !postLine.endsWith("\r\n") )
-                        {
+                        while (read >= 0 && !postLine.endsWith("\r\n")) {
                             postLine += String.valueOf(pbuf, 0, read);
                             read = in.read(pbuf);
-                            if(Thread.interrupted()){
+                            if (Thread.interrupted()) {
                                 throw new InterruptedException();
                             }
                         }
                         postLine = postLine.trim();
-                        decodeParms( postLine, parms );
+                        decodeParms(postLine, parms);
                     }
                 }
 
                 // Ok, now do the serve()
-                Response r = serve( uri, method, header, parms, files );
-                if ( r == null )
-                    sendError(socket, HTTP_INTERNALERROR, "SERVER INTERNAL ERROR: Serve() returned a null response." );
+                Response r = serve(uri, method, header, parms, files);
+                if (r == null)
+                    sendError(socket, HTTP_INTERNALERROR, "SERVER INTERNAL ERROR: Serve() returned a null response.");
                 else
-                    sendResponse(socket, r.status, r.mimeType, r.header, r.data );
+                    sendResponse(socket, r.status, r.mimeType, r.header, r.data);
 
                 in.close();
-            }
-            catch ( IOException ioe )
-            {
-                try
-                {
+            } catch (IOException ioe) {
+                try {
                     sendError(socket, HTTP_INTERNALERROR, "SERVER INTERNAL ERROR: IOException: " + ioe.getMessage());
+                } catch (Throwable t) {
                 }
-                catch ( Throwable t ) {}
-            }
-            catch ( InterruptedException ie )
-            {
+            } catch (InterruptedException ie) {
                 // Thrown by sendError, ignore and exit the thread.
             }
 
@@ -493,54 +369,47 @@ public abstract class StreamServer {
          * Decodes the sent headers and loads the data into
          * java Properties' key - value pairs
          **/
-        private  void decodeHeader(BufferedReader in, Properties pre, Properties parms, Properties header)
-                throws InterruptedException
-        {
+        private void decodeHeader(BufferedReader in, Properties pre, Properties parms, Properties header)
+                throws InterruptedException {
             try {
                 // Read the request line
                 String inLine = in.readLine();
                 if (inLine == null) return;
-                StringTokenizer st = new StringTokenizer( inLine );
-                if ( !st.hasMoreTokens())
-                    sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Syntax error. Usage: GET /example/file.html" );
+                StringTokenizer st = new StringTokenizer(inLine);
+                if (!st.hasMoreTokens())
+                    sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Syntax error. Usage: GET /example/file.html");
 
                 String method = st.nextToken();
                 pre.put("method", method);
 
-                if ( !st.hasMoreTokens())
-                    sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Missing URI. Usage: GET /example/file.html" );
+                if (!st.hasMoreTokens())
+                    sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Missing URI. Usage: GET /example/file.html");
 
                 String uri = st.nextToken();
 
                 // Decode parameters from the URI
-                int qmi = uri.indexOf( '?' );
-                if ( qmi >= 0 )
-                {
-                    decodeParms( uri.substring( qmi+1 ), parms );
-                    uri = decodePercent( uri.substring( 0, qmi ));
-                }
-                else uri = Uri.decode(uri);//decodePercent(uri);
+                int qmi = uri.indexOf('?');
+                if (qmi >= 0) {
+                    decodeParms(uri.substring(qmi + 1), parms);
+                    uri = decodePercent(uri.substring(0, qmi));
+                } else uri = Uri.decode(uri);//decodePercent(uri);
 
                 // If there's another token, it's protocol version,
                 // followed by HTTP headers. Ignore version but parse headers.
                 // NOTE: this now forces header names lowercase since they are
                 // case insensitive and vary by client.
-                if ( st.hasMoreTokens())
-                {
+                if (st.hasMoreTokens()) {
                     String line = in.readLine();
-                    while ( line != null && line.trim().length() > 0 )
-                    {
-                        int p = line.indexOf( ':' );
-                        if ( p >= 0 )
-                            header.put( line.substring(0,p).trim().toLowerCase(), line.substring(p+1).trim());
+                    while (line != null && line.trim().length() > 0) {
+                        int p = line.indexOf(':');
+                        if (p >= 0)
+                            header.put(line.substring(0, p).trim().toLowerCase(), line.substring(p + 1).trim());
                         line = in.readLine();
                     }
                 }
 
                 pre.put("uri", uri);
-            }
-            catch ( IOException ioe )
-            {
+            } catch (IOException ioe) {
                 sendError(socket, HTTP_INTERNALERROR, "SERVER INTERNAL ERROR: IOException: " + ioe.getMessage());
             }
         }
@@ -550,70 +419,59 @@ public abstract class StreamServer {
          * into java Properties' key - value pairs.
          **/
         private void decodeMultipartData(String boundary, byte[] fbuf, BufferedReader in, Properties parms, Properties files)
-                throws InterruptedException
-        {
-            try
-            {
-                int[] bpositions = getBoundaryPositions(fbuf,boundary.getBytes());
+                throws InterruptedException {
+            try {
+                int[] bpositions = getBoundaryPositions(fbuf, boundary.getBytes());
                 int boundarycount = 1;
                 String mpline = in.readLine();
-                while ( mpline != null )
-                {
+                while (mpline != null) {
                     if (mpline.indexOf(boundary) == -1)
-                        sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Content type is multipart/form-data but next chunk does not start with boundary. Usage: GET /example/file.html" );
+                        sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Content type is multipart/form-data but next chunk does not start with boundary. Usage: GET /example/file.html");
                     boundarycount++;
                     Properties item = new Properties();
                     mpline = in.readLine();
-                    while (mpline != null && mpline.trim().length() > 0)
-                    {
-                        int p = mpline.indexOf( ':' );
+                    while (mpline != null && mpline.trim().length() > 0) {
+                        int p = mpline.indexOf(':');
                         if (p != -1)
-                            item.put( mpline.substring(0,p).trim().toLowerCase(), mpline.substring(p+1).trim());
+                            item.put(mpline.substring(0, p).trim().toLowerCase(), mpline.substring(p + 1).trim());
                         mpline = in.readLine();
                     }
-                    if (mpline != null)
-                    {
+                    if (mpline != null) {
                         String contentDisposition = item.getProperty("content-disposition");
-                        if (contentDisposition == null)
-                        {
-                            sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Content type is multipart/form-data but no content-disposition info found. Usage: GET /example/file.html" );
+                        if (contentDisposition == null) {
+                            sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Content type is multipart/form-data but no content-disposition info found. Usage: GET /example/file.html");
                         }
-                        StringTokenizer st = new StringTokenizer( contentDisposition , "; " );
+                        StringTokenizer st = new StringTokenizer(contentDisposition, "; ");
                         Properties disposition = new Properties();
-                        while ( st.hasMoreTokens())
-                        {
+                        while (st.hasMoreTokens()) {
                             String token = st.nextToken();
-                            int p = token.indexOf( '=' );
-                            if (p!=-1)
-                                disposition.put( token.substring(0,p).trim().toLowerCase(), token.substring(p+1).trim());
+                            int p = token.indexOf('=');
+                            if (p != -1)
+                                disposition.put(token.substring(0, p).trim().toLowerCase(), token.substring(p + 1).trim());
                         }
                         String pname = disposition.getProperty("name");
-                        pname = pname.substring(1,pname.length()-1);
+                        pname = pname.substring(1, pname.length() - 1);
 
                         String value = "";
                         if (item.getProperty("content-type") == null) {
-                            while (mpline != null && mpline.indexOf(boundary) == -1)
-                            {
+                            while (mpline != null && mpline.indexOf(boundary) == -1) {
                                 mpline = in.readLine();
-                                if ( mpline != null)
-                                {
+                                if (mpline != null) {
                                     int d = mpline.indexOf(boundary);
                                     if (d == -1)
-                                        value+=mpline;
+                                        value += mpline;
                                     else
-                                        value+=mpline.substring(0,d-2);
+                                        value += mpline.substring(0, d - 2);
                                 }
                             }
-                        }
-                        else
-                        {
-                            if (boundarycount> bpositions.length)
-                                sendError(socket, HTTP_INTERNALERROR, "Error processing request" );
-                            int offset = stripMultipartHeaders(fbuf, bpositions[boundarycount-2]);
-                            String path = saveTmpFile(fbuf, offset, bpositions[boundarycount-1]-offset-4);
+                        } else {
+                            if (boundarycount > bpositions.length)
+                                sendError(socket, HTTP_INTERNALERROR, "Error processing request");
+                            int offset = stripMultipartHeaders(fbuf, bpositions[boundarycount - 2]);
+                            String path = saveTmpFile(fbuf, offset, bpositions[boundarycount - 1] - offset - 4);
                             files.put(pname, path);
                             value = disposition.getProperty("filename");
-                            value = value.substring(1,value.length()-1);
+                            value = value.substring(1, value.length() - 1);
                             do {
                                 mpline = in.readLine();
                             } while (mpline != null && mpline.indexOf(boundary) == -1);
@@ -621,9 +479,7 @@ public abstract class StreamServer {
                         parms.put(pname, value);
                     }
                 }
-            }
-            catch ( IOException ioe )
-            {
+            } catch (IOException ioe) {
                 sendError(socket, HTTP_INTERNALERROR, "SERVER INTERNAL ERROR: IOException: " + ioe.getMessage());
             }
         }
@@ -631,35 +487,28 @@ public abstract class StreamServer {
         /**
          * Find the byte positions where multipart boundaries start.
          **/
-        public int[] getBoundaryPositions(byte[] b, byte[] boundary)
-        {
+        public int[] getBoundaryPositions(byte[] b, byte[] boundary) {
             int matchcount = 0;
             int matchbyte = -1;
             Vector matchbytes = new Vector();
-            for (int i=0; i<b.length; i++)
-            {
-                if (b[i] == boundary[matchcount])
-                {
+            for (int i = 0; i < b.length; i++) {
+                if (b[i] == boundary[matchcount]) {
                     if (matchcount == 0)
                         matchbyte = i;
                     matchcount++;
-                    if (matchcount==boundary.length)
-                    {
+                    if (matchcount == boundary.length) {
                         matchbytes.addElement(matchbyte);
                         matchcount = 0;
                         matchbyte = -1;
                     }
-                }
-                else
-                {
+                } else {
                     i -= matchcount;
                     matchcount = 0;
                     matchbyte = -1;
                 }
             }
             int[] ret = new int[matchbytes.size()];
-            for (int i=0; i < ret.length; i++)
-            {
+            for (int i = 0; i < ret.length; i++) {
                 ret[i] = (Integer) matchbytes.elementAt(i);
             }
             return ret;
@@ -670,11 +519,9 @@ public abstract class StreamServer {
          * to a temporary file.
          * The full path to the saved file is returned.
          **/
-        private String saveTmpFile(byte[] b, int offset, int len)
-        {
+        private String saveTmpFile(byte[] b, int offset, int len) {
             String path = "";
-            if (len > 0)
-            {
+            if (len > 0) {
                 String tmpdir = System.getProperty("java.io.tmpdir");
                 try {
                     File temp = File.createTempFile("NanoHTTPD", "", new File(tmpdir));
@@ -694,48 +541,40 @@ public abstract class StreamServer {
          * It returns the offset separating multipart file headers
          * from the file's data.
          **/
-        private int stripMultipartHeaders(byte[] b, int offset)
-        {
+        private int stripMultipartHeaders(byte[] b, int offset) {
             int i = 0;
-            for (i=offset; i<b.length; i++)
-            {
+            for (i = offset; i < b.length; i++) {
                 if (b[i] == '\r' && b[++i] == '\n' && b[++i] == '\r' && b[++i] == '\n')
                     break;
             }
-            return i+1;
+            return i + 1;
         }
 
         /**
          * Decodes the percent encoding scheme. <br/>
          * For example: "an+example%20string" -> "an example string"
          */
-        private String decodePercent( String str ) throws InterruptedException
-        {
-            try
-            {
+        private String decodePercent(String str) throws InterruptedException {
+            try {
                 StringBuffer sb = new StringBuffer();
-                for( int i=0; i<str.length(); i++ )
-                {
-                    char c = str.charAt( i );
-                    switch ( c )
-                    {
+                for (int i = 0; i < str.length(); i++) {
+                    char c = str.charAt(i);
+                    switch (c) {
                         case '+':
-                            sb.append( ' ' );
+                            sb.append(' ');
                             break;
                         case '%':
-                            sb.append((char)Integer.parseInt( str.substring(i+1,i+3), 16 ));
+                            sb.append((char) Integer.parseInt(str.substring(i + 1, i + 3), 16));
                             i += 2;
                             break;
                         default:
-                            sb.append( c );
+                            sb.append(c);
                             break;
                     }
                 }
                 return sb.toString();
-            }
-            catch( Exception e )
-            {
-                sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Bad percent-encoding." );
+            } catch (Exception e) {
+                sendError(socket, HTTP_BADREQUEST, "BAD REQUEST: Bad percent-encoding.");
                 return null;
             }
         }
@@ -747,20 +586,18 @@ public abstract class StreamServer {
          * identical keys due to the simplicity of Properties -- if you need multiples,
          * you might want to replace the Properties with a Hashtable of Vectors or such.
          */
-        private void decodeParms( String parms, Properties p )
-                throws InterruptedException
-        {
-            if ( parms == null )
+        private void decodeParms(String parms, Properties p)
+                throws InterruptedException {
+            if (parms == null)
                 return;
 
-            StringTokenizer st = new StringTokenizer( parms, "&" );
-            while ( st.hasMoreTokens())
-            {
+            StringTokenizer st = new StringTokenizer(parms, "&");
+            while (st.hasMoreTokens()) {
                 String e = st.nextToken();
-                int sep = e.indexOf( '=' );
-                if ( sep >= 0 )
-                    p.put( decodePercent( e.substring( 0, sep )).trim(),
-                            decodePercent( e.substring( sep+1 )));
+                int sep = e.indexOf('=');
+                if (sep >= 0)
+                    p.put(decodePercent(e.substring(0, sep)).trim(),
+                            decodePercent(e.substring(sep + 1)));
             }
         }
 
@@ -768,8 +605,7 @@ public abstract class StreamServer {
          * Returns an error message as a HTTP response and
          * throws InterruptedException to stop further request processing.
          */
-        private void sendError(Socket socket, String status, String msg ) throws InterruptedException
-        {
+        private void sendError(Socket socket, String status, String msg) throws InterruptedException {
             sendResponse(socket, status, MIME_PLAINTEXT, null, null);
             throw new InterruptedException();
         }
@@ -777,32 +613,28 @@ public abstract class StreamServer {
         /**
          * Sends given response to the socket.
          */
-        private void sendResponse(Socket socket, String status, String mime, Properties header, StreamSource data )
-        {
-            try
-            {
-                if ( status == null )
-                    throw new Error( "sendResponse(): Status can't be null." );
+        private void sendResponse(Socket socket, String status, String mime, Properties header, StreamSource data) {
+            try {
+                if (status == null)
+                    throw new Error("sendResponse(): Status can't be null.");
 
                 OutputStream out = socket.getOutputStream();
-                PrintWriter pw = new PrintWriter( out );
+                PrintWriter pw = new PrintWriter(out);
                 pw.print("HTTP/1.0 " + status + " \r\n");
 
 
-                if ( mime != null )
+                if (mime != null)
                     pw.print("Content-Type: " + mime + "\r\n");
 
-                if ( header == null || header.getProperty( "Date" ) == null )
-                    pw.print( "Date: " + gmtFrmt.format( new Date()) + "\r\n");
+                if (header == null || header.getProperty("Date") == null)
+                    pw.print("Date: " + gmtFrmt.format(new Date()) + "\r\n");
 
-                if ( header != null )
-                {
+                if (header != null) {
                     Enumeration e = header.keys();
-                    while ( e.hasMoreElements())
-                    {
-                        String key = (String)e.nextElement();
-                        String value = header.getProperty( key );
-                        pw.print( key + ": " + value + "\r\n");
+                    while (e.hasMoreElements()) {
+                        String key = (String) e.nextElement();
+                        String value = header.getProperty(key);
+                        pw.print(key + ": " + value + "\r\n");
                     }
                 }
 
@@ -810,56 +642,29 @@ public abstract class StreamServer {
                 pw.flush();
 
 
-                if ( data != null )
-                {
+                if (data != null) {
                     //long pending = data.available();      // This is to support partial sends, see serveFile()
                     data.open();
                     byte[] buff = new byte[8192];
                     int read = 0;
-                    while ((read = data.read(buff))>0){
+                    while ((read = data.read(buff)) > 0) {
                         //if(SolidExplorer.LOG)Log.d("Explorer", "Read: "+ read +", pending: "+ data.available());
-                        out.write( buff, 0, read );
+                        out.write(buff, 0, read);
                     }
                 }
                 out.flush();
                 out.close();
-                if ( data != null )
+                if (data != null)
                     data.close();
 
-            }
-            catch( IOException ioe )
-            {
+            } catch (IOException ioe) {
                 // Couldn't write? No can do.
-                try { socket.close(); } catch( Throwable t ) {}
-            }
-        }
-
-        //private Socket mySocket;
-    }
-
-    /**
-     * URL-encodes everything between "/"-characters.
-     * Encodes spaces as '%20' instead of '+'.
-     */
-    private String encodeUri( String uri )
-    {
-        String newUri = "";
-        StringTokenizer st = new StringTokenizer( uri, "/ ", true );
-        while ( st.hasMoreTokens())
-        {
-            String tok = st.nextToken();
-            if ( tok.equals( "/" ))
-                newUri += "/";
-            else if ( tok.equals( " " ))
-                newUri += "%20";
-            else
-            {
-                newUri += URLEncoder.encode( tok );
-                // For Java 1.4 you'll want to use this instead:
-                // try { newUri += URLEncoder.encode( tok, "UTF-8" ); } catch ( java.io.UnsupportedEncodingException uee ) {}
+                try {
+                    socket.close();
+                } catch (Throwable t) {
+                }
             }
         }
-        return newUri;
     }
 
     private int myTcpPort;
@@ -867,244 +672,12 @@ public abstract class StreamServer {
     private Thread myThread;
     private File myRootDir;
 
-    // ==================================================
-    // File server code
-    // ==================================================
-
-    //      /**
-    //       * Serves file from homeDir and its' subdirectories (only).
-    //       * Uses only URI, ignores all headers and HTTP parameters.
-    //       */
-    //      public Response serveFile( String uri, Properties header, File homeDir,
-    //                                                         boolean allowDirectoryListing )
-    //      {
-    //              Response res = null;
-    //
-    //              // Make sure we won't die of an exception later
-    //              if ( !homeDir.isDirectory())
-    //                      res = new Response( HTTP_INTERNALERROR, MIME_PLAINTEXT,
-    //                              "INTERNAL ERRROR: serveFile(): given homeDir is not a directory." );
-    //
-    //              if ( res == null )
-    //              {
-    //                      // Remove URL arguments
-    //                      uri = uri.trim().replace( File.separatorChar, '/' );
-    //                      if ( uri.indexOf( '?' ) >= 0 )
-    //                              uri = uri.substring(0, uri.indexOf( '?' ));
-    //
-    //                      // Prohibit getting out of current directory
-    //                      if ( uri.startsWith( ".." ) || uri.endsWith( ".." ) || uri.indexOf( "../" ) >= 0 )
-    //                              res = new Response( HTTP_FORBIDDEN, MIME_PLAINTEXT,
-    //                                      "FORBIDDEN: Won't serve ../ for security reasons." );
-    //              }
-    //
-    //              File f = new File( homeDir, uri );
-    //              if ( res == null && !f.exists())
-    //                      res = new Response( HTTP_NOTFOUND, MIME_PLAINTEXT,
-    //                              "Error 404, file not found." );
-    //
-    //              // List the directory, if necessary
-    //              if ( res == null && f.isDirectory())
-    //              {
-    //                      // Browsers get confused without '/' after the
-    //                      // directory, send a redirect.
-    //                      if ( !uri.endsWith( "/" ))
-    //                      {
-    //                              uri += "/";
-    //                              res = new Response( HTTP_REDIRECT, MIME_HTML,
-    //                                      "<html><body>Redirected: <a href=\"" + uri + "\">" +
-    //                                      uri + "</a></body></html>");
-    //                              res.addHeader( "Location", uri );
-    //                      }
-    //
-    //                      if ( res == null )
-    //                      {
-    //                              // First try index.html and index.htm
-    //                              if ( new File( f, "index.html" ).exists())
-    //                                      f = new File( homeDir, uri + "/index.html" );
-    //                              else if ( new File( f, "index.htm" ).exists())
-    //                                      f = new File( homeDir, uri + "/index.htm" );
-    //                              // No index file, list the directory if it is readable
-    //                              else if ( allowDirectoryListing && f.canRead() )
-    //                              {
-    //                                      String[] files = f.list();
-    //                                      String msg = "<html><body><h1>Directory " + uri + "</h1><br/>";
-    //
-    //                                      if ( uri.length() > 1 )
-    //                                      {
-    //                                              String u = uri.substring( 0, uri.length()-1 );
-    //                                              int slash = u.lastIndexOf( '/' );
-    //                                              if ( slash >= 0 && slash  < u.length())
-    //                                                      msg += "<b><a href=\"" + uri.substring(0, slash+1) + "\">..</a></b><br/>";
-    //                                      }
-    //
-    //                                      if (files!=null)
-    //                                      {
-    //                                              for ( int i=0; i<files.length; ++i )
-    //                                              {
-    //                                                      File curFile = new File( f, files[i] );
-    //                                                      boolean dir = curFile.isDirectory();
-    //                                                      if ( dir )
-    //                                                      {
-    //                                                              msg += "<b>";
-    //                                                              files[i] += "/";
-    //                                                      }
-    //
-    //                                                      msg += "<a href=\"" + encodeUri( uri + files[i] ) + "\">" +
-    //                                                                files[i] + "</a>";
-    //
-    //                                                      // Show file size
-    //                                                      if ( curFile.isFile())
-    //                                                      {
-    //                                                              long len = curFile.length();
-    //                                                              msg += " &nbsp;<font size=2>(";
-    //                                                              if ( len < 1024 )
-    //                                                                      msg += len + " bytes";
-    //                                                              else if ( len < 1024 * 1024 )
-    //                                                                      msg += len/1024 + "." + (len%1024/10%100) + " KB";
-    //                                                              else
-    //                                                                      msg += len/(1024*1024) + "." + len%(1024*1024)/10%100 + " MB";
-    //
-    //                                                              msg += ")</font>";
-    //                                                      }
-    //                                                      msg += "<br/>";
-    //                                                      if ( dir ) msg += "</b>";
-    //                                              }
-    //                                      }
-    //                                      msg += "</body></html>";
-    //                                      res = new Response( HTTP_OK, MIME_HTML, msg );
-    //                              }
-    //                              else
-    //                              {
-    //                                      res = new Response( HTTP_FORBIDDEN, MIME_PLAINTEXT,
-    //                                              "FORBIDDEN: No directory listing." );
-    //                              }
-    //                      }
-    //              }
-    //
-    //              try
-    //              {
-    //                      if ( res == null )
-    //                      {
-    //                              // Get MIME type from file name extension, if possible
-    //                              String mime = null;
-    //                              int dot = f.getCanonicalPath().lastIndexOf( '.' );
-    //                              if ( dot >= 0 )
-    //                                      mime = (String)theMimeTypes.get( f.getCanonicalPath().substring( dot + 1 ).toLowerCase());
-    //                              if ( mime == null )
-    //                                      mime = MIME_DEFAULT_BINARY;
-    //
-    //                              // Calculate etag
-    //                              String etag = Integer.toHexString((f.getAbsolutePath() + f.lastModified() + "" + f.length()).hashCode());
-    //
-    //                              // Support (simple) skipping:
-    //                              long startFrom = 0;
-    //                              long endAt = -1;
-    //                              String range = header.getProperty( "range" );
-    //                              if ( range != null )
-    //                              {
-    //                                      if ( range.startsWith( "bytes=" ))
-    //                                      {
-    //                                              range = range.substring( "bytes=".length());
-    //                                              int minus = range.indexOf( '-' );
-    //                                              try {
-    //                                                      if ( minus > 0 )
-    //                                                      {
-    //                                                              startFrom = Long.parseLong( range.substring( 0, minus ));
-    //                                                              endAt = Long.parseLong( range.substring( minus+1 ));
-    //                                                      }
-    //                                              }
-    //                                              catch ( NumberFormatException nfe ) {}
-    //                                      }
-    //                              }
-    //
-    //                              // Change return code and add Content-Range header when skipping is requested
-    //                              long fileLen = f.length();
-    //                              if (range != null && startFrom >= 0)
-    //                              {
-    //                                      if ( startFrom >= fileLen)
-    //                                      {
-    //                                              res = new Response( HTTP_RANGE_NOT_SATISFIABLE, MIME_PLAINTEXT, "" );
-    //                                              res.addHeader( "Content-Range", "bytes 0-0/" + fileLen);
-    //                                              res.addHeader( "ETag", etag);
-    //                                      }
-    //                                      else
-    //                                      {
-    //                                              if ( endAt < 0 )
-    //                                                      endAt = fileLen-1;
-    //                                              long newLen = endAt - startFrom + 1;
-    //                                              if ( newLen < 0 ) newLen = 0;
-    //
-    //                                              final long dataLen = newLen;
-    //                                              FileInputStream fis = new FileInputStream( f ) {
-    //                                                      public int available() throws IOException { return (int)dataLen; }
-    //                                              };
-    //                                              fis.skip( startFrom );
-    //
-    //                                              res = new Response( HTTP_PARTIALCONTENT, mime, fis );
-    //                                              res.addHeader( "Content-Length", "" + dataLen);
-    //                                              res.addHeader( "Content-Range", "bytes " + startFrom + "-" + endAt + "/" + fileLen);
-    //                                              res.addHeader( "ETag", etag);
-    //                                      }
-    //                              }
-    //                              else
-    //                              {
-    //                                      res = new Response( HTTP_OK, mime, new FileInputStream( f ));
-    //                                      res.addHeader( "Content-Length", "" + fileLen);
-    //                                      res.addHeader( "ETag", etag);
-    //                              }
-    //                      }
-    //              }
-    //              catch( IOException ioe )
-    //              {
-    //                      res = new Response( HTTP_FORBIDDEN, MIME_PLAINTEXT, "FORBIDDEN: Reading file failed." );
-    //              }
-    //
-    //              res.addHeader( "Accept-Ranges", "bytes"); // Announce that the file server accepts partial content requestes
-    //              return res;
-    //      }
-
-    //      /**
-    //       * Hashtable mapping (String)FILENAME_EXTENSION -> (String)MIME_TYPE
-    //       */
-    //      private static Hashtable theMimeTypes = new Hashtable();
-    //      static
-    //      {
-    //              StringTokenizer st = new StringTokenizer(
-    //                      "css            text/css "+
-    //                      "htm            text/html "+
-    //                      "html           text/html "+
-    //                      "xml            text/xml "+
-    //                      "txt            text/plain "+
-    //                      "asc            text/plain "+
-    //                      "gif            image/gif "+
-    //                      "jpg            image/jpeg "+
-    //                      "jpeg           image/jpeg "+
-    //                      "png            image/png "+
-    //                      "mp3            audio/mpeg "+
-    //                      "m3u            audio/mpeg-url " +
-    //                      "mp4            video/mp4 " +
-    //                      "ogv            video/ogg " +
-    //                      "flv            video/x-flv " +
-    //                      "mov            video/quicktime " +
-    //                      "swf            application/x-shockwave-flash " +
-    //                      "js                     application/javascript "+
-    //                      "pdf            application/pdf "+
-    //                      "doc            application/msword "+
-    //                      "ogg            application/x-ogg "+
-    //                      "zip            application/octet-stream "+
-    //                      "exe            application/octet-stream "+
-    //                      "class          application/octet-stream " );
-    //              while ( st.hasMoreTokens())
-    //                      theMimeTypes.put( st.nextToken(), st.nextToken());
-    //      }
-
     /**
      * GMT date formatter
      */
     private static java.text.SimpleDateFormat gmtFrmt;
-    static
-    {
+
+    static {
         gmtFrmt = new java.text.SimpleDateFormat( "E, d MMM yyyy HH:mm:ss 'GMT'", Locale.US);
         gmtFrmt.setTimeZone(TimeZone.getTimeZone("GMT"));
     }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.java b/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.java
index 1b2083675..4db67aa29 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/SmbUtil.java
@@ -3,9 +3,11 @@ package com.amaze.filemanager.utils;
 import android.content.Context;
 import android.text.TextUtils;
 
-import com.amaze.filemanager.exceptions.CryptException;
 import com.amaze.filemanager.utils.files.CryptUtil;
 
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+
 /**
  * Created by Vishal on 30-05-2017.
  *
@@ -16,24 +18,20 @@ public class SmbUtil {
 
     /**
      * Parse path to decrypt smb password
-     * @return
      */
-    public static String getSmbDecryptedPath(Context context, String path) throws CryptException {
-
+    public static String getSmbDecryptedPath(Context context, String path) throws GeneralSecurityException, IOException {
         if (!(path.contains(":") && path.contains("@"))) {
             // smb path doesn't have any credentials
             return path;
         }
 
-        StringBuffer buffer = new StringBuffer();
+        StringBuilder buffer = new StringBuilder();
 
         buffer.append(path.substring(0, path.indexOf(":", 4)+1));
         String encryptedPassword = path.substring(path.indexOf(":", 4)+1, path.lastIndexOf("@"));
 
         if (!TextUtils.isEmpty(encryptedPassword)) {
-
             String decryptedPassword = CryptUtil.decryptPassword(context, encryptedPassword);
-
             buffer.append(decryptedPassword);
         }
         buffer.append(path.substring(path.lastIndexOf("@"), path.length()));
@@ -43,25 +41,19 @@ public class SmbUtil {
 
     /**
      * Parse path to encrypt smb password
-     * @param context
-     * @param path
-     * @return
      */
-    public static String getSmbEncryptedPath(Context context, String path) throws CryptException {
-
+    public static String getSmbEncryptedPath(Context context, String path) throws GeneralSecurityException, IOException  {
         if (!(path.contains(":") && path.contains("@"))) {
             // smb path doesn't have any credentials
             return path;
         }
 
-        StringBuffer buffer = new StringBuffer();
+        StringBuilder buffer = new StringBuilder();
         buffer.append(path.substring(0, path.indexOf(":", 4)+1));
         String decryptedPassword = path.substring(path.indexOf(":", 4)+1, path.lastIndexOf("@"));
 
         if (!TextUtils.isEmpty(decryptedPassword)) {
-
             String encryptPassword =  CryptUtil.encryptPassword(context, decryptedPassword);
-
             buffer.append(encryptPassword);
         }
         buffer.append(path.substring(path.lastIndexOf("@"), path.length()));
diff --git a/app/src/main/java/com/amaze/filemanager/utils/SubnetScanner.java b/app/src/main/java/com/amaze/filemanager/utils/SubnetScanner.java
index 090fe4ec0..6d469c4d4 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/SubnetScanner.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/SubnetScanner.java
@@ -25,13 +25,16 @@ import jcifs.netbios.NbtAddress;
 import jcifs.smb.SmbFile;
 
 public class SubnetScanner extends Thread {
-    public static final int RETRY_COUNT = 5;
+
+    private static final int RETRY_COUNT = 5;
+
     private Thread bdThread;
     private final Object mLock;
     private List<ComputerParcelable> mResults;
     private ScanObserver observer;
-    ExecutorService pool;
+    private ExecutorService pool;
     private List<Future<ComputerParcelable>> tasks;
+    private Context context;
 
     public interface ScanObserver {
         void computerFound(ComputerParcelable computer);
@@ -39,8 +42,6 @@ public class SubnetScanner extends Thread {
         void searchFinished();
     }
 
-
-
     class Task implements Callable<ComputerParcelable> {
         String addr;
 
@@ -65,24 +66,24 @@ public class SubnetScanner extends Thread {
         configure();
     }
 
-    public static void configure() {
+    private static void configure() {
         Config.setProperty("jcifs.resolveOrder", "BCAST");
         Config.setProperty("jcifs.smb.client.responseTimeout", "30000");
         Config.setProperty("jcifs.netbios.retryTimeout", "5000");
         Config.setProperty("jcifs.netbios.cachePolicy", "-1");
     }
-    Context context;
+
     public SubnetScanner(Context context) {
-        this.context=context;
-        this.mLock = new Object();
-        this.tasks = new ArrayList(260);
-        this.pool = Executors.newFixedThreadPool(60);
-        this.mResults = new ArrayList();
+        this.context = context;
+        mLock = new Object();
+        tasks = new ArrayList<>(260);
+        pool = Executors.newFixedThreadPool(60);
+        mResults = new ArrayList<>();
     }
 
-
     public void run() {
-        int ipAddress = ((WifiManager) context.getSystemService(Context.WIFI_SERVICE)).getConnectionInfo().getIpAddress();
+        int ipAddress = ((WifiManager) context.getApplicationContext().getSystemService(Context.WIFI_SERVICE))
+                .getConnectionInfo().getIpAddress();
         if (ipAddress != 0) {
             tryWithBroadcast();
             String formatIpAddress = Formatter.formatIpAddress(ipAddress);
@@ -105,18 +106,13 @@ public class SubnetScanner extends Thread {
                                 this.tasks.remove(i);
                                 size--;
                                 if (computer.name != null) {
-                                    //SELog.d("SMB host found at ", computer.addr);
                                     onFound(computer);
-                                } else {
-                                    //SELog.d("No SMB host found at ", computer.addr);
                                 }
                                 ipAddress = size;
                             } catch (InterruptedException e) {
                                 return;
                             } catch (ExecutionException e2) {
-                                Throwable th = e2;
                                 ipAddress = size;
-                              //  SELog.w(th);
                             } catch (TimeoutException e3) {
                                 ipAddress = size;
                             }
@@ -153,14 +149,15 @@ public class SubnetScanner extends Thread {
                         SmbFile[] listFiles = smbFile.listFiles();
                         for (SmbFile smbFile2 : listFiles) {
                             SmbFile[] listFiles2 = smbFile2.listFiles();
-                            for (int i2 = 0; i2 < listFiles2.length; i2++) {
+                            for (SmbFile files : listFiles2) {
                                 try {
-                                    String substring = listFiles2[i2].getName().substring(0, listFiles2[i2].getName().length() - 1);
+                                    String substring = files.getName().substring(0, files.getName().length() - 1);
                                     UniAddress byName = UniAddress.getByName(substring);
                                     if (byName != null) {
                                         SubnetScanner.this.onFound(new ComputerParcelable(substring, byName.getHostAddress()));
                                     }
                                 } catch (Throwable e) {
+
                                 }
                             }
                         }
@@ -173,8 +170,8 @@ public class SubnetScanner extends Thread {
         this.bdThread.start();
     }
 
-    void onFound(ComputerParcelable computer) {
-        this.mResults.add(computer);
+    private void onFound(ComputerParcelable computer) {
+        mResults.add(computer);
         synchronized (this.mLock) {
             if (this.observer != null) {
                 this.observer.computerFound(computer);
@@ -193,12 +190,12 @@ public class SubnetScanner extends Thread {
         try {
             this.pool.shutdownNow();
         } catch (Throwable th) {
-
+            
         }
     }
 
     public List<ComputerParcelable> getResults() {
-        return new ArrayList(this.mResults);
+        return new ArrayList<>(this.mResults);
     }
 
 }
diff --git a/app/src/main/java/com/amaze/filemanager/utils/TinyDB.java b/app/src/main/java/com/amaze/filemanager/utils/TinyDB.java
index 33eff597e..eed500df1 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/TinyDB.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/TinyDB.java
@@ -23,13 +23,11 @@ package com.amaze.filemanager.utils;
 import android.content.SharedPreferences;
 import android.text.TextUtils;
 
-import java.util.ArrayList;
-import java.util.Arrays;
-
-//import com.google.gson.Gson;
-
+/**
+ * Extract from: https://github.com/kcochibili/TinyDB--Android-Shared-Preferences-Turbo
+ * Author: https://github.com/kcochibili
+ */
 public class TinyDB {
-
     /*
      *  The "" character is not a comma, it is the SINGLE LOW-9 QUOTATION MARK. U-201A
      *  + U-2017 + U-201A are used for separating the items in a list.
@@ -63,69 +61,4 @@ public class TinyDB {
         return newArray;
     }
 
-    /**
-     * Get parsed ArrayList of T from SharedPreferences at 'key'
-     * @param key SharedPreferences key
-     * @return ArrayList of T
-     */
-    public static <T> ArrayList<T> getList(SharedPreferences preferences, Class<T> klazz, String key,
-                                           ArrayList<T> defaultValue) {
-        String pref = preferences.getString(key, "");
-
-        if(pref.equals("")) {
-            return defaultValue;
-        }
-
-        String[] myList = TextUtils.split(pref, DIVIDER);
-        ArrayList<String> arrayToList = new ArrayList<>(Arrays.asList(myList));
-        ArrayList<T> newList = new ArrayList<>();
-
-        for (String item : arrayToList)
-            newList.add(valueOf(klazz, item));
-
-        return newList;
-    }
-
-    // Put methods
-
-    /**
-     * Put ArrayList of T into SharedPreferences with 'key' and save
-     * @param key SharedPreferences key
-     */
-    public static <T> void putList(SharedPreferences preferences, String key, ArrayList<T> list) {
-        checkForNullKey(key);
-        Object[] myList = list.toArray();
-        preferences.edit().putString(key, TextUtils.join(DIVIDER, myList)).apply();
-    }
-
-    /**
-     * null keys would corrupt the shared pref file and make them unreadable this is a preventive measure
-     * @param key the pref key
-     */
-    private static void checkForNullKey(String key){
-        if (key == null){
-            throw new NullPointerException();
-        }
-    }
-
-    private static <T> T valueOf(Class<T> klazz, String arg) {
-        Exception cause = null;
-
-        if(klazz != String.class) {
-            T ret = null;
-            try {
-                ret = klazz.cast(klazz.getDeclaredMethod("valueOf", String.class).invoke(null, arg));
-            } catch (Exception e) {
-                cause = e;
-            }
-
-            if (cause == null) {
-                return ret;
-            } else {
-                throw new IllegalArgumentException(cause);
-            }
-        } else {
-            return (T) arg;//Is string but String.valueOf(String) doesn't exist
-        }
-    }
 }
\ No newline at end of file
diff --git a/app/src/main/java/com/amaze/filemanager/utils/Utils.java b/app/src/main/java/com/amaze/filemanager/utils/Utils.java
index dbb548658..497129303 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/Utils.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/Utils.java
@@ -12,7 +12,6 @@ import android.support.annotation.ColorRes;
 import android.support.v4.content.ContextCompat;
 import android.support.v4.graphics.drawable.DrawableCompat;
 import android.util.DisplayMetrics;
-import android.util.Log;
 import android.view.View;
 import android.widget.CheckBox;
 import android.widget.Toast;
@@ -48,12 +47,6 @@ public class Utils {
         return Math.min(minimum, max);
     }
 
-    /**
-     * TODO
-     *
-     * @param view
-     * @return
-     */
     public static float getViewRawY(View view) {
         int[] location = new int[2];
         location[0] = 0;
@@ -78,10 +71,6 @@ public class Utils {
         }
     }
 
-    public String getDate(File f) {
-        return getDate(f.lastModified());
-    }
-
     public static String getDate(long f) {
         return DATE_WITH_MINUTES.format(f);
     }
@@ -93,14 +82,6 @@ public class Utils {
         return date;
     }
 
-    /**
-     * TODO
-     *
-     * @param options
-     * @param reqWidth
-     * @param reqHeight
-     * @return
-     */
     public static int calculateInSampleSize(BitmapFactory.Options options, int reqWidth, int reqHeight) {
         // Raw height and width of image
         final int height = options.outHeight;
@@ -123,14 +104,9 @@ public class Utils {
         return inSampleSize;
     }
 
-    public boolean isAtleastKitkat() {
-        return Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT;
-    }
-
     /**
      * Gets color
      *
-     * @param c     Context
      * @param color the resource id for the color
      * @return the color
      */
@@ -170,71 +146,55 @@ public class Utils {
      *  (https://commons.apache.org/proper/commons-lang/javadocs/api-2.6/org/apache/commons/lang/StringUtils.html#difference(java.lang.String,%20java.lang.String))
      */
     public static String differenceStrings(String str1, String str2) {
-        if (str1 == null) {
-            return str2;
-        }
-        if (str2 == null) {
-            return str1;
-        }
+        if (str1 == null) return str2;
+        if (str2 == null) return str1;
+
         int at = indexOfDifferenceStrings(str1, str2);
-        if (at == INDEX_NOT_FOUND) {
-            return "";
-        }
+
+        if (at == INDEX_NOT_FOUND) return "";
+
         return str2.substring(at);
     }
 
     private static int indexOfDifferenceStrings(CharSequence cs1, CharSequence cs2) {
-        if (cs1 == cs2) {
-            return INDEX_NOT_FOUND;
-        }
-        if (cs1 == null || cs2 == null) {
-            return 0;
-        }
+        if (cs1 == cs2) return INDEX_NOT_FOUND;
+        if (cs1 == null || cs2 == null) return 0;
+
         int i;
         for (i = 0; i < cs1.length() && i < cs2.length(); ++i) {
-            if (cs1.charAt(i) != cs2.charAt(i)) {
-                break;
-            }
-        }
-        if (i < cs2.length() || i < cs1.length()) {
-            return i;
+            if (cs1.charAt(i) != cs2.charAt(i)) break;
         }
+
+        if (i < cs2.length() || i < cs1.length()) return i;
+
         return INDEX_NOT_FOUND;
     }
 
     /**
      * Force disables screen rotation. Useful when we're temporarily in activity because of external intent,
      * and don't have to really deal much with filesystem.
-     * @param mainActivity
      */
     public static void disableScreenRotation(MainActivity mainActivity) {
         int screenOrientation = mainActivity.getResources().getConfiguration().orientation;
 
         if (screenOrientation == Configuration.ORIENTATION_LANDSCAPE) {
-
             mainActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_LANDSCAPE);
         } else if (screenOrientation == Configuration.ORIENTATION_PORTRAIT) {
-
             mainActivity.setRequestedOrientation(ActivityInfo.SCREEN_ORIENTATION_PORTRAIT);
         }
     }
 
     /**
      * Sanitizes input from external application to avoid any attempt of command injection
-     * @param input
-     * @return
      */
     public static String sanitizeInput(String input) {
-
         // iterate through input and keep sanitizing until it's fully injection proof
         String sanitizedInput;
         String sanitizedInputTemp = input;
+        
         while (true) {
-
             sanitizedInput = sanitizeInputOnce(sanitizedInputTemp);
-            if (sanitizedInput.equals(sanitizedInputTemp))
-                break;
-
+            if (sanitizedInput.equals(sanitizedInputTemp)) break;
             sanitizedInputTemp = sanitizedInput;
         }
 
@@ -242,22 +202,16 @@ public class Utils {
     }
 
     private static String sanitizeInputOnce(String input) {
-
-        String sanitizedInput = input.replaceAll(INPUT_INTENT_BLACKLIST_PIPE, "").
+        return input.replaceAll(INPUT_INTENT_BLACKLIST_PIPE, "").
                 replaceAll(INPUT_INTENT_BLACKLIST_AMP, "").
                 replaceAll(INPUT_INTENT_BLACKLIST_DOTS, "").
-                replaceAll(INPUT_INTENT_BLACKLIST_COLON, "")
-                ;
-        return sanitizedInput;
+                replaceAll(INPUT_INTENT_BLACKLIST_COLON, "");
     }
 
     /**
      * Returns uri associated to specific basefile
-     * @param baseFile
-     * @return
      */
     public static Uri getUriForBaseFile(Context context, HybridFileParcelable baseFile) {
-
         switch (baseFile.getMode()) {
             case FILE:
             case ROOT:
diff --git a/app/src/main/java/com/amaze/filemanager/utils/files/CryptUtil.java b/app/src/main/java/com/amaze/filemanager/utils/files/CryptUtil.java
index 64e151174..5764d1e32 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/files/CryptUtil.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/files/CryptUtil.java
@@ -10,12 +10,10 @@ import android.security.keystore.KeyProperties;
 import android.support.annotation.RequiresApi;
 import android.util.Base64;
 
-import com.amaze.filemanager.exceptions.CryptException;
-import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.filesystem.FileUtil;
 import com.amaze.filemanager.filesystem.HybridFile;
+import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.fragments.preference_fragments.PrefFrag;
-import com.amaze.filemanager.utils.OnFileFound;
 import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.ProgressHandler;
 import com.amaze.filemanager.utils.ServiceWatcherUtil;
@@ -26,8 +24,8 @@ import java.io.ByteArrayInputStream;
 import java.io.ByteArrayOutputStream;
 import java.io.IOException;
 import java.math.BigInteger;
+import java.security.GeneralSecurityException;
 import java.security.InvalidAlgorithmParameterException;
-import java.security.InvalidKeyException;
 import java.security.Key;
 import java.security.KeyPairGenerator;
 import java.security.KeyStore;
@@ -35,19 +33,15 @@ import java.security.KeyStoreException;
 import java.security.NoSuchAlgorithmException;
 import java.security.NoSuchProviderException;
 import java.security.SecureRandom;
-import java.security.UnrecoverableEntryException;
 import java.security.UnrecoverableKeyException;
 import java.security.cert.CertificateException;
 import java.util.ArrayList;
 import java.util.Calendar;
 
-import javax.crypto.BadPaddingException;
 import javax.crypto.Cipher;
 import javax.crypto.CipherInputStream;
 import javax.crypto.CipherOutputStream;
-import javax.crypto.IllegalBlockSizeException;
 import javax.crypto.KeyGenerator;
-import javax.crypto.NoSuchPaddingException;
 import javax.crypto.spec.GCMParameterSpec;
 import javax.crypto.spec.IvParameterSpec;
 import javax.crypto.spec.SecretKeySpec;
@@ -107,21 +101,14 @@ public class CryptUtil {
      * @param sourceFile the file to encrypt
      */
     public CryptUtil(Context context, HybridFileParcelable sourceFile, ProgressHandler progressHandler,
-                     ArrayList<HybridFile> failedOps) throws CryptException {
+                     ArrayList<HybridFile> failedOps) throws GeneralSecurityException, IOException {
 
         this.progressHandler = progressHandler;
         this.failedOps = failedOps;
 
         // target encrypted file
         HybridFile hFile = new HybridFile(sourceFile.getMode(), sourceFile.getParent(context));
-
-        try {
-
-            encrypt(context, sourceFile, hFile);
-        } catch (Exception e) {
-            e.printStackTrace();
-            throw new CryptException();
-        }
+        encrypt(context, sourceFile, hFile);
     }
 
     /**
@@ -138,7 +125,7 @@ public class CryptUtil {
      *                   the source's parent in normal case
      */
     public CryptUtil(Context context, HybridFileParcelable baseFile, String targetPath,
-                     ProgressHandler progressHandler, ArrayList<HybridFile> failedOps) throws CryptException {
+                     ProgressHandler progressHandler, ArrayList<HybridFile> failedOps) throws GeneralSecurityException, IOException {
 
         this.progressHandler = progressHandler;
         this.failedOps = failedOps;
@@ -150,13 +137,7 @@ public class CryptUtil {
             targetDirectory.setMode(baseFile.getMode());
         }
 
-        try {
-
-            decrypt(context, baseFile, targetDirectory);
-        } catch (Exception e) {
-            e.printStackTrace();
-            throw new CryptException();
-        }
+        decrypt(context, baseFile, targetDirectory);
     }
 
     /**
@@ -164,22 +145,9 @@ public class CryptUtil {
      * @param context
      * @param sourceFile        the source file to decrypt
      * @param targetDirectory   the target directory inside which we're going to decrypt
-     * @throws IOException
-     * @throws CertificateException
-     * @throws NoSuchAlgorithmException
-     * @throws UnrecoverableEntryException
-     * @throws InvalidKeyException
-     * @throws InvalidAlgorithmParameterException
-     * @throws NoSuchPaddingException
-     * @throws NoSuchProviderException
-     * @throws BadPaddingException
-     * @throws KeyStoreException
-     * @throws IllegalBlockSizeException
      */
-    private void decrypt(final Context context, HybridFileParcelable sourceFile, HybridFile targetDirectory) throws IOException,
-            CertificateException, NoSuchAlgorithmException, UnrecoverableEntryException,
-            InvalidKeyException, InvalidAlgorithmParameterException, NoSuchPaddingException,
-            NoSuchProviderException, BadPaddingException, KeyStoreException, IllegalBlockSizeException {
+    private void decrypt(final Context context, HybridFileParcelable sourceFile, HybridFile targetDirectory)
+            throws GeneralSecurityException, IOException {
 
         if (sourceFile.isDirectory()) {
 
@@ -187,14 +155,11 @@ public class CryptUtil {
                     sourceFile.getName().replace(CRYPT_EXTENSION, ""), sourceFile.isDirectory());
             FileUtil.mkdirs(context, hFile);
 
-            sourceFile.forEachChildrenFile(context, sourceFile.isRoot(), new OnFileFound() {
-                @Override
-                public void onFileFound(HybridFileParcelable file) {
-                    try {
-                        decrypt(context, file, hFile);
-                    } catch (IOException | BadPaddingException | CertificateException | UnrecoverableEntryException | NoSuchAlgorithmException | InvalidAlgorithmParameterException | InvalidKeyException | NoSuchProviderException | NoSuchPaddingException | IllegalBlockSizeException | KeyStoreException e) {
-                        throw new IllegalStateException(e); //throw unchecked exception, no throws needed
-                    }
+            sourceFile.forEachChildrenFile(context, sourceFile.isRoot(), file -> {
+                try {
+                    decrypt(context, file, hFile);
+                } catch (IOException | GeneralSecurityException e) {
+                    throw new IllegalStateException(e); //throw unchecked exception, no throws needed
                 }
             });
         } else {
@@ -231,22 +196,9 @@ public class CryptUtil {
      * @param context
      * @param sourceFile        the source file to encrypt
      * @param targetDirectory   the target directory in which we're going to encrypt
-     * @throws IOException
-     * @throws CertificateException
-     * @throws NoSuchAlgorithmException
-     * @throws UnrecoverableEntryException
-     * @throws InvalidKeyException
-     * @throws InvalidAlgorithmParameterException
-     * @throws NoSuchPaddingException
-     * @throws NoSuchProviderException
-     * @throws BadPaddingException
-     * @throws KeyStoreException
-     * @throws IllegalBlockSizeException
      */
-    private void encrypt(final Context context, HybridFileParcelable sourceFile, HybridFile targetDirectory) throws IOException,
-            CertificateException, NoSuchAlgorithmException, UnrecoverableEntryException,
-            InvalidKeyException, InvalidAlgorithmParameterException, NoSuchPaddingException,
-            NoSuchProviderException, BadPaddingException, KeyStoreException, IllegalBlockSizeException {
+    private void encrypt(final Context context, HybridFileParcelable sourceFile, HybridFile targetDirectory)
+            throws GeneralSecurityException, IOException {
 
         if (sourceFile.isDirectory()) {
 
@@ -256,14 +208,11 @@ public class CryptUtil {
                     sourceFile.isDirectory());
             FileUtil.mkdirs(context, hFile);
 
-            sourceFile.forEachChildrenFile(context, sourceFile.isRoot(), new OnFileFound() {
-                @Override
-                public void onFileFound(HybridFileParcelable file) {
-                    try {
-                        encrypt(context, file, hFile);
-                    } catch (IOException | IllegalBlockSizeException | KeyStoreException | CertificateException | UnrecoverableEntryException | NoSuchAlgorithmException | NoSuchPaddingException | InvalidKeyException | InvalidAlgorithmParameterException | BadPaddingException | NoSuchProviderException e) {
-                        throw new IllegalStateException(e);//throw unchecked exception, no throws needed
-                    }
+            sourceFile.forEachChildrenFile(context, sourceFile.isRoot(), file -> {
+                try {
+                    encrypt(context, file, hFile);
+                } catch (IOException | GeneralSecurityException e) {
+                    throw new IllegalStateException(e);//throw unchecked exception, no throws needed
                 }
             });
         } else {
@@ -298,26 +247,10 @@ public class CryptUtil {
 
     /**
      * Helper method to encrypt plain text password
-     * @param plainTextPassword
-     * @return
-     * @throws CertificateException
-     * @throws NoSuchAlgorithmException
-     * @throws KeyStoreException
-     * @throws NoSuchProviderException
-     * @throws InvalidAlgorithmParameterException
-     * @throws IOException
-     * @throws NoSuchPaddingException
-     * @throws UnrecoverableKeyException
-     * @throws InvalidKeyException
-     * @throws BadPaddingException
-     * @throws IllegalBlockSizeException
      */
     @RequiresApi(api = Build.VERSION_CODES.M)
     private static String aesEncryptPassword(String plainTextPassword)
-            throws CertificateException, NoSuchAlgorithmException, KeyStoreException,
-            NoSuchProviderException, InvalidAlgorithmParameterException, IOException,
-            NoSuchPaddingException, UnrecoverableKeyException, InvalidKeyException,
-            BadPaddingException, IllegalBlockSizeException {
+            throws GeneralSecurityException, IOException {
 
         Cipher cipher = Cipher.getInstance(ALGO_AES);
         GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, IV.getBytes());
@@ -329,26 +262,9 @@ public class CryptUtil {
 
     /**
      * Helper method to decrypt cipher text password
-     * @param cipherPassword
-     * @return
-     * @throws NoSuchPaddingException
-     * @throws NoSuchAlgorithmException
-     * @throws CertificateException
-     * @throws UnrecoverableKeyException
-     * @throws KeyStoreException
-     * @throws NoSuchProviderException
-     * @throws InvalidAlgorithmParameterException
-     * @throws IOException
-     * @throws InvalidKeyException
-     * @throws BadPaddingException
-     * @throws IllegalBlockSizeException
      */
     @RequiresApi(api = Build.VERSION_CODES.M)
-    private static String aesDecryptPassword(String cipherPassword) throws NoSuchPaddingException,
-            NoSuchAlgorithmException, CertificateException,
-            UnrecoverableKeyException, KeyStoreException, NoSuchProviderException,
-            InvalidAlgorithmParameterException, IOException, InvalidKeyException,
-            BadPaddingException, IllegalBlockSizeException {
+    private static String aesDecryptPassword(String cipherPassword) throws GeneralSecurityException, IOException {
 
         Cipher cipher = Cipher.getInstance(ALGO_AES);
         GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, IV.getBytes());
@@ -362,24 +278,10 @@ public class CryptUtil {
      * Helper method to encrypt a file
      * @param inputStream stream associated with the file to be encrypted
      * @param outputStream stream associated with new output encrypted file
-     * @throws CertificateException
-     * @throws NoSuchAlgorithmException
-     * @throws KeyStoreException
-     * @throws NoSuchProviderException
-     * @throws InvalidAlgorithmParameterException
-     * @throws IOException
-     * @throws NoSuchPaddingException
-     * @throws UnrecoverableKeyException
-     * @throws InvalidKeyException
-     * @throws BadPaddingException
-     * @throws IllegalBlockSizeException
      */
     @RequiresApi(api = Build.VERSION_CODES.M)
     private static void aesEncrypt(BufferedInputStream inputStream, BufferedOutputStream outputStream)
-            throws CertificateException, NoSuchAlgorithmException, KeyStoreException,
-            NoSuchProviderException, InvalidAlgorithmParameterException, IOException,
-            NoSuchPaddingException, UnrecoverableKeyException, InvalidKeyException,
-            BadPaddingException, IllegalBlockSizeException {
+            throws GeneralSecurityException, IOException {
 
         Cipher cipher = Cipher.getInstance(ALGO_AES);
 
@@ -411,24 +313,10 @@ public class CryptUtil {
      * Helper method to decrypt file
      * @param inputStream stream associated with encrypted file
      * @param outputStream stream associated with new output decrypted file
-     * @throws NoSuchPaddingException
-     * @throws NoSuchAlgorithmException
-     * @throws CertificateException
-     * @throws UnrecoverableKeyException
-     * @throws KeyStoreException
-     * @throws NoSuchProviderException
-     * @throws InvalidAlgorithmParameterException
-     * @throws IOException
-     * @throws InvalidKeyException
-     * @throws BadPaddingException
-     * @throws IllegalBlockSizeException
      */
     @RequiresApi(api = Build.VERSION_CODES.M)
     private static void aesDecrypt(BufferedInputStream inputStream, BufferedOutputStream outputStream)
-            throws NoSuchPaddingException, NoSuchAlgorithmException, CertificateException,
-            UnrecoverableKeyException, KeyStoreException, NoSuchProviderException,
-            InvalidAlgorithmParameterException, IOException, InvalidKeyException,
-            BadPaddingException, IllegalBlockSizeException {
+            throws GeneralSecurityException, IOException {
 
         Cipher cipher = Cipher.getInstance(ALGO_AES);
         GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, IV.getBytes());
@@ -467,10 +355,7 @@ public class CryptUtil {
      * @throws UnrecoverableKeyException
      */
     @RequiresApi(api = Build.VERSION_CODES.M)
-    private static Key getSecretKey() throws KeyStoreException, CertificateException,
-            NoSuchAlgorithmException, IOException, NoSuchProviderException,
-            InvalidAlgorithmParameterException,
-            UnrecoverableKeyException {
+    private static Key getSecretKey() throws GeneralSecurityException, IOException {
 
         KeyStore keyStore = KeyStore.getInstance(KEY_STORE_ANDROID);
         keyStore.load(null);
@@ -493,10 +378,7 @@ public class CryptUtil {
 
     @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
     private static void rsaEncrypt(Context context, BufferedInputStream inputStream, BufferedOutputStream outputStream)
-            throws NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException,
-            CertificateException, BadPaddingException, InvalidAlgorithmParameterException,
-            KeyStoreException, UnrecoverableEntryException, IllegalBlockSizeException,
-            InvalidKeyException, IOException {
+            throws GeneralSecurityException, IOException {
 
         Cipher cipher = Cipher.getInstance(ALGO_AES, "BC");
         RSAKeygen keygen = new RSAKeygen(context);
@@ -525,10 +407,7 @@ public class CryptUtil {
 
     @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
     private static void rsaDecrypt(Context context, BufferedInputStream inputStream,
-                                   BufferedOutputStream outputStream) throws NoSuchPaddingException,
-            NoSuchAlgorithmException, NoSuchProviderException, CertificateException,
-            BadPaddingException, InvalidAlgorithmParameterException, KeyStoreException,
-            UnrecoverableEntryException, IllegalBlockSizeException, InvalidKeyException, IOException {
+                                   BufferedOutputStream outputStream) throws GeneralSecurityException, IOException {
 
         Cipher cipher = Cipher.getInstance(ALGO_AES, "BC");
         RSAKeygen keygen = new RSAKeygen(context);
@@ -556,11 +435,7 @@ public class CryptUtil {
     }
 
     @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
-    private static String rsaEncryptPassword(Context context, String password) throws
-            NoSuchPaddingException, NoSuchAlgorithmException, NoSuchProviderException,
-            CertificateException, BadPaddingException, InvalidAlgorithmParameterException,
-            KeyStoreException, UnrecoverableEntryException, IllegalBlockSizeException,
-            InvalidKeyException, IOException {
+    private static String rsaEncryptPassword(Context context, String password) throws GeneralSecurityException, IOException {
 
         Cipher cipher = Cipher.getInstance(ALGO_AES, "BC");
         RSAKeygen keygen = new RSAKeygen(context);
@@ -572,10 +447,7 @@ public class CryptUtil {
     }
 
     @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
-    private static String rsaDecryptPassword(Context context, String cipherText) throws NoSuchPaddingException,
-            NoSuchAlgorithmException, NoSuchProviderException, CertificateException, BadPaddingException,
-            InvalidAlgorithmParameterException, KeyStoreException, UnrecoverableEntryException,
-            IllegalBlockSizeException, InvalidKeyException, IOException {
+    private static String rsaDecryptPassword(Context context, String cipherText) throws GeneralSecurityException, IOException {
 
         Cipher cipher = Cipher.getInstance(ALGO_AES, "BC");
         RSAKeygen keygen = new RSAKeygen(context);
@@ -592,84 +464,44 @@ public class CryptUtil {
      * @param plainText
      * @return
      */
-    public static String encryptPassword(Context context, String plainText) throws CryptException {
-
-        try {
+    public static String encryptPassword(Context context, String plainText) throws GeneralSecurityException, IOException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
 
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-
-                return CryptUtil.aesEncryptPassword(plainText);
-            } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            return CryptUtil.aesEncryptPassword(plainText);
+        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
 
-                return CryptUtil.rsaEncryptPassword(context, plainText);
-            } else return plainText;
-        } catch (Exception e) {
-            e.printStackTrace();
-            throw new CryptException();
-        }
+            return CryptUtil.rsaEncryptPassword(context, plainText);
+        } else return plainText;
     }
 
     /**
      * Method handles decryption of cipher text on various APIs
-     * @param context
-     * @param cipherText
-     * @return
      */
-    public static String decryptPassword(Context context, String cipherText) throws CryptException {
-
-        try {
-
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-
-                return CryptUtil.aesDecryptPassword(cipherText);
-            } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
-
-                return CryptUtil.rsaDecryptPassword(context, cipherText);
-            } else return cipherText;
-        } catch (Exception e) {
-            e.printStackTrace();
-            throw new CryptException();
-        }
+    public static String decryptPassword(Context context, String cipherText) throws GeneralSecurityException, IOException {
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+            return CryptUtil.aesDecryptPassword(cipherText);
+        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            return CryptUtil.rsaDecryptPassword(context, cipherText);
+        } else return cipherText;
     }
 
     /**
      * Method initializes a Cipher to be used by {@link android.hardware.fingerprint.FingerprintManager}
-     * @param context
-     * @return
-     * @throws NoSuchPaddingException
-     * @throws NoSuchAlgorithmException
-     * @throws CertificateException
-     * @throws UnrecoverableEntryException
-     * @throws KeyStoreException
-     * @throws NoSuchProviderException
-     * @throws InvalidAlgorithmParameterException
-     * @throws IOException
-     * @throws InvalidKeyException
-     * @throws BadPaddingException
-     * @throws IllegalBlockSizeException
      */
-    public static Cipher initCipher(Context context) throws CryptException {
-
-        try {
-
-            Cipher cipher = null;
-
-            if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
-
-                cipher = Cipher.getInstance(ALGO_AES);
-                GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, IV.getBytes());
-                cipher.init(Cipher.ENCRYPT_MODE, getSecretKey(), gcmParameterSpec);
-            } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
-                cipher = Cipher.getInstance(ALGO_AES, "BC");
-                RSAKeygen keygen = new RSAKeygen(context);
-
-                cipher.init(Cipher.ENCRYPT_MODE, keygen.getSecretKey());
-            }
-            return cipher;
-        } catch (Exception e) {
-            e.printStackTrace();
-            throw new CryptException();
+    public static Cipher initCipher(Context context) throws GeneralSecurityException, IOException {
+        Cipher cipher = null;
+
+        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
+            cipher = Cipher.getInstance(ALGO_AES);
+            GCMParameterSpec gcmParameterSpec = new GCMParameterSpec(128, IV.getBytes());
+            cipher.init(Cipher.ENCRYPT_MODE, getSecretKey(), gcmParameterSpec);
+        } else if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.JELLY_BEAN_MR2) {
+            cipher = Cipher.getInstance(ALGO_AES, "BC");
+            RSAKeygen keygen = new RSAKeygen(context);
+
+            cipher.init(Cipher.ENCRYPT_MODE, keygen.getSecretKey());
         }
+        return cipher;
     }
 
     /**
@@ -687,45 +519,16 @@ public class CryptUtil {
             try {
                 generateKeyPair(context);
                 setKeyPreference();
-            } catch (KeyStoreException e) {
-                e.printStackTrace();
-            } catch (CertificateException e) {
-                e.printStackTrace();
-            } catch (NoSuchAlgorithmException e) {
-                e.printStackTrace();
-            } catch (IOException e) {
-                e.printStackTrace();
-            } catch (NoSuchProviderException e) {
-                e.printStackTrace();
-            } catch (InvalidAlgorithmParameterException e) {
-                e.printStackTrace();
-            } catch (NoSuchPaddingException e) {
-                e.printStackTrace();
-            } catch (InvalidKeyException e) {
-                e.printStackTrace();
-            } catch (UnrecoverableEntryException e) {
-                e.printStackTrace();
-            } catch (IllegalBlockSizeException e) {
-                e.printStackTrace();
-            } catch (BadPaddingException e) {
+            } catch (GeneralSecurityException | IOException e) {
                 e.printStackTrace();
             }
         }
 
         /**
          * Generates a RSA public/private key pair to encrypt AES key
-         * @param context
-         * @throws KeyStoreException
-         * @throws CertificateException
-         * @throws NoSuchAlgorithmException
-         * @throws IOException
-         * @throws NoSuchProviderException
-         * @throws InvalidAlgorithmParameterException
          */
         @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
-        private void generateKeyPair(Context context) throws KeyStoreException,
-                CertificateException, NoSuchAlgorithmException, IOException, NoSuchProviderException,
-                InvalidAlgorithmParameterException {
+        private void generateKeyPair(Context context) throws GeneralSecurityException, IOException {
 
             KeyStore keyStore = KeyStore.getInstance(KEY_STORE_ANDROID);
             keyStore.load(null);
@@ -754,10 +557,7 @@ public class CryptUtil {
         /**
          * Encrypts AES key and set into preference
          */
-        private void setKeyPreference() throws IOException, CertificateException,
-                NoSuchAlgorithmException, InvalidKeyException, UnrecoverableEntryException,
-                NoSuchPaddingException, NoSuchProviderException, BadPaddingException,
-                KeyStoreException, IllegalBlockSizeException {
+        private void setKeyPreference() throws GeneralSecurityException, IOException {
 
             SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context);
             String encodedAesKey = preferences.getString(PREFERENCE_KEY, null);
@@ -777,12 +577,8 @@ public class CryptUtil {
 
         /**
          * Encrypts randomly generated AES key using RSA public key
-         * @param secretKey
-         * @return
          */
-        private byte[] encryptAESKey(byte[] secretKey) throws KeyStoreException,
-                UnrecoverableEntryException, NoSuchAlgorithmException, IOException,
-                CertificateException, NoSuchProviderException, NoSuchPaddingException, InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
+        private byte[] encryptAESKey(byte[] secretKey) throws GeneralSecurityException, IOException {
 
             KeyStore keyStore = KeyStore.getInstance(KEY_STORE_ANDROID);
             keyStore.load(null);
@@ -801,23 +597,9 @@ public class CryptUtil {
 
         /**
          * Decodes encrypted AES key from preference and decrypts using RSA private key
-         * @return
-         * @throws CertificateException
-         * @throws NoSuchPaddingException
-         * @throws InvalidKeyException
-         * @throws NoSuchAlgorithmException
-         * @throws KeyStoreException
-         * @throws NoSuchProviderException
-         * @throws UnrecoverableEntryException
-         * @throws IOException
-         * @throws InvalidAlgorithmParameterException
-         * @throws BadPaddingException
-         * @throws IllegalBlockSizeException
          */
         @RequiresApi(api = Build.VERSION_CODES.JELLY_BEAN_MR2)
-        private Key getSecretKey() throws CertificateException, NoSuchPaddingException, InvalidKeyException,
-                NoSuchAlgorithmException, KeyStoreException, NoSuchProviderException, UnrecoverableEntryException,
-                IOException, InvalidAlgorithmParameterException, BadPaddingException, IllegalBlockSizeException {
+        private Key getSecretKey() throws GeneralSecurityException, IOException {
 
             SharedPreferences preferences = PreferenceManager.getDefaultSharedPreferences(context);
             String encodedString = preferences.getString(PREFERENCE_KEY, null);
@@ -833,20 +615,8 @@ public class CryptUtil {
 
         /**
          * Decrypts AES decoded key from preference using RSA private key
-         * @param encodedBytes
-         * @return
-         * @throws KeyStoreException
-         * @throws CertificateException
-         * @throws NoSuchAlgorithmException
-         * @throws IOException
-         * @throws UnrecoverableEntryException
-         * @throws NoSuchProviderException
-         * @throws NoSuchPaddingException
-         * @throws InvalidKeyException
          */
-        private byte[] decryptAESKey(byte[] encodedBytes) throws KeyStoreException, CertificateException, NoSuchAlgorithmException,
-                IOException, UnrecoverableEntryException, NoSuchProviderException, NoSuchPaddingException,
-                InvalidKeyException, BadPaddingException, IllegalBlockSizeException {
+        private byte[] decryptAESKey(byte[] encodedBytes) throws GeneralSecurityException, IOException {
 
             KeyStore keyStore = KeyStore.getInstance(KEY_STORE_ANDROID);
             keyStore.load(null);
diff --git a/app/src/main/java/com/amaze/filemanager/utils/files/EncryptDecryptUtils.java b/app/src/main/java/com/amaze/filemanager/utils/files/EncryptDecryptUtils.java
index 17757deef..3165583d1 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/files/EncryptDecryptUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/files/EncryptDecryptUtils.java
@@ -11,7 +11,6 @@ import com.amaze.filemanager.R;
 import com.amaze.filemanager.activities.MainActivity;
 import com.amaze.filemanager.database.CryptHandler;
 import com.amaze.filemanager.database.models.EncryptedEntry;
-import com.amaze.filemanager.exceptions.CryptException;
 import com.amaze.filemanager.filesystem.HybridFileParcelable;
 import com.amaze.filemanager.fragments.MainFragment;
 import com.amaze.filemanager.fragments.preference_fragments.PrefFrag;
@@ -21,6 +20,9 @@ import com.amaze.filemanager.utils.OpenMode;
 import com.amaze.filemanager.utils.ServiceWatcherUtil;
 import com.amaze.filemanager.utils.provider.UtilitiesProviderInterface;
 
+import java.io.IOException;
+import java.security.GeneralSecurityException;
+
 /**
  * Provides useful interfaces and methods for encryption/decryption
  *
@@ -68,7 +70,7 @@ public class EncryptDecryptUtils {
 
         try {
             encryptedEntry = findEncryptedEntry(main.getContext(), sourceFile.getPath());
-        } catch (CryptException e) {
+        } catch (GeneralSecurityException | IOException e) {
             e.printStackTrace();
 
             // we couldn't find any entry in database or lost the key to decipher
@@ -102,13 +104,11 @@ public class EncryptDecryptUtils {
                     if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
                         GeneralDialogCreation.showDecryptFingerprintDialog(c,
                                 mainActivity, decryptIntent, utilsProvider.getAppTheme(), decryptButtonCallbackInterface);
-                    } else throw new CryptException();
-                } catch (CryptException e) {
+                    } else throw new IllegalStateException("API < M!");
+                } catch (GeneralSecurityException | IOException | IllegalStateException e) {
                     e.printStackTrace();
 
-                    Toast.makeText(main.getContext(),
-                            main.getResources().getString(R.string.crypt_decryption_fail),
-                            Toast.LENGTH_LONG).show();
+                    Toast.makeText(main.getContext(), main.getResources().getString(R.string.crypt_decryption_fail), Toast.LENGTH_LONG).show();
                 }
                 break;
             case PrefFrag.ENCRYPT_PASSWORD_MASTER:
@@ -117,13 +117,9 @@ public class EncryptDecryptUtils {
                             mainActivity, decryptIntent, utilsProvider.getAppTheme(),
                             CryptUtil.decryptPassword(c, preferences1.getString(PrefFrag.PREFERENCE_CRYPT_MASTER_PASSWORD,
                                     PrefFrag.PREFERENCE_CRYPT_MASTER_PASSWORD_DEFAULT)), decryptButtonCallbackInterface);
-                } catch (CryptException e) {
+                } catch (GeneralSecurityException | IOException e) {
                     e.printStackTrace();
-
-
-                    Toast.makeText(main.getContext(),
-                            main.getResources().getString(R.string.crypt_decryption_fail),
-                            Toast.LENGTH_LONG).show();
+                    Toast.makeText(main.getContext(), main.getResources().getString(R.string.crypt_decryption_fail), Toast.LENGTH_LONG).show();
                 }
                 break;
             default:
@@ -140,7 +136,7 @@ public class EncryptDecryptUtils {
      * @param path the path to match with
      * @return the entry
      */
-    private static EncryptedEntry findEncryptedEntry(Context context, String path) throws CryptException {
+    private static EncryptedEntry findEncryptedEntry(Context context, String path) throws GeneralSecurityException, IOException {
 
         CryptHandler handler = new CryptHandler(context);
 
diff --git a/app/src/main/java/com/amaze/filemanager/utils/files/FileUtils.java b/app/src/main/java/com/amaze/filemanager/utils/files/FileUtils.java
index 739a64f28..f35efddd7 100644
--- a/app/src/main/java/com/amaze/filemanager/utils/files/FileUtils.java
+++ b/app/src/main/java/com/amaze/filemanager/utils/files/FileUtils.java
@@ -85,10 +85,6 @@ import jcifs.smb.SmbFile;
  */
 public class FileUtils {
 
-    public static final int READ = 4;
-    public static final int WRITE = 2;
-    public static final int EXECUTE = 1;
-
     public static long folderSize(File directory, OnProgressUpdate<Long> updateState) {
         long length = 0;
         try {
@@ -325,10 +321,8 @@ public class FileUtils {
     }
 
     public static float readableFileSizeFloat(long size) {
-        if (size <= 0)
-            return 0;
-        float digitGroups = (float) (size / (1024*1024));
-        return digitGroups;
+        if (size <= 0) return 0;
+        return (float) (size / (1024*1024));
     }
 
     /**
@@ -371,9 +365,6 @@ public class FileUtils {
 
     /**
      * Open file from OTG
-     * @param f
-     * @param c
-     * @param forcechooser
      */
     public static void openunknown(DocumentFile f, Context c, boolean forcechooser, boolean useNewStack) {
         Intent chooserIntent = new Intent();
@@ -503,8 +494,6 @@ public class FileUtils {
 
     /**
      * Method supports showing a UI to ask user to open a file without any extension/mime
-     * @param f
-     * @param c
      */
     public static void openWith(final File f, final Context c, final boolean useNewStack) {
         MaterialDialog.Builder a=new MaterialDialog.Builder(c);
@@ -596,9 +585,6 @@ public class FileUtils {
 
     /**
      * Method determines if there is something to go back to
-     * @param currentFile
-     * @param context
-     * @return
      */
     public static boolean canGoBack(Context context, HybridFile currentFile) {
         switch (currentFile.getMode()) {
@@ -738,8 +724,6 @@ public class FileUtils {
 
     /**
      * Support file opening for {@link DocumentFile} (eg. OTG)
-     * @param f
-     * @param m
      */
     public static void openFile(final DocumentFile f, final MainActivity m, SharedPreferences sharedPrefs) {
         boolean useNewStack = sharedPrefs.getBoolean(PrefFrag.PREFERENCE_TEXTEDITOR_NEWSTACK, false);
@@ -827,15 +811,17 @@ public class FileUtils {
     /**
      * We're parsing a line returned from a stdout of shell.
      * @param line must be the line returned from a 'ls' command
-     * @return
      */
     public static HybridFileParcelable parseName(String line) {
         boolean linked = false;
-        String name = "", link = "", size = "-1", date = "";
+        StringBuilder name = new StringBuilder();
+        StringBuilder link = new StringBuilder();
+        String size = "-1";
+        String date = "";
         String[] array = line.split(" ");
         if(array.length<6)return null;
-        for (int i = 0; i < array.length; i++) {
-            if (array[i].contains("->") && array[0].startsWith("l")) {
+        for (String anArray : array) {
+            if (anArray.contains("->") && array[0].startsWith("l")) {
                 linked = true;
             }
         }
@@ -845,17 +831,17 @@ public class FileUtils {
             size = array[p - 2];}
         if (!linked) {
             for (int i = p + 1; i < array.length; i++) {
-                name = name + " " + array[i];
+                name.append(" ").append(array[i]);
             }
-            name = name.trim();
+            name = new StringBuilder(name.toString().trim());
         } else {
             int q = getLinkPosition(array);
             for (int i = p + 1; i < q; i++) {
-                name = name + " " + array[i];
+                name.append(" ").append(array[i]);
             }
-            name = name.trim();
+            name = new StringBuilder(name.toString().trim());
             for (int i = q + 1; i < array.length; i++) {
-                link = link + " " + array[i];
+                link.append(" ").append(array[i]);
             }
         }
         long Size = (size==null || size.trim().length()==0)?-1:Long.parseLong(size);
@@ -863,12 +849,12 @@ public class FileUtils {
             ParsePosition pos = new ParsePosition(0);
             SimpleDateFormat simpledateformat = new SimpleDateFormat("yyyy-MM-dd | HH:mm");
             Date stringDate = simpledateformat.parse(date, pos);
-            HybridFileParcelable baseFile=new HybridFileParcelable(name,array[0],stringDate.getTime(),Size,true);
-            baseFile.setLink(link);
+            HybridFileParcelable baseFile=new HybridFileParcelable(name.toString(),array[0],stringDate.getTime(),Size,true);
+            baseFile.setLink(link.toString());
             return baseFile;
         }else {
-            HybridFileParcelable baseFile= new HybridFileParcelable(name,array[0],new File("/").lastModified(),Size,true);
-            baseFile.setLink(link);
+            HybridFileParcelable baseFile= new HybridFileParcelable(name.toString(),array[0],new File("/").lastModified(),Size,true);
+            baseFile.setLink(link.toString());
             return baseFile;
         }
     }
@@ -888,49 +874,19 @@ public class FileUtils {
     }
 
     public static ArrayList<Boolean[]> parse(String permLine) {
-        ArrayList<Boolean[]> arrayList= new ArrayList<>();
-        Boolean[] read=new Boolean[]{false,false,false};
-        Boolean[] write=new Boolean[]{false,false,false};
-        Boolean[] execute=new Boolean[]{false,false,false};
-        int owner = 0;// TODO: 17/5/2017 many variables are unused
-        if (permLine.charAt(1) == 'r') {
-            owner += READ;
-            read[0]=true;
-        }
-        if (permLine.charAt(2) == 'w') {
-            owner += WRITE;
-            write[0]=true;
-        }
-        if (permLine.charAt(3) == 'x') {
-            owner += EXECUTE;
-            execute[0]=true;
-        }
-        int group = 0;
-        if (permLine.charAt(4) == 'r') {
-            group += READ;
-            read[1]=true;
-        }
-        if (permLine.charAt(5) == 'w') {
-            group += WRITE;
-            write[1]=true;
-        }
-        if (permLine.charAt(6) == 'x') {
-            group += EXECUTE;
-            execute[1]=true;
-        }
-        int world = 0;
-        if (permLine.charAt(7) == 'r') {
-            world += READ;
-            read[2]=true;
-        }
-        if (permLine.charAt(8) == 'w') {
-            world += WRITE;
-            write[2]=true;
-        }
-        if (permLine.charAt(9) == 'x') {
-            world += EXECUTE;
-            execute[2]=true;
-        }
+        ArrayList<Boolean[]> arrayList= new ArrayList<>(3);
+        Boolean[] read =new Boolean[]{permLine.charAt(1) == 'r',
+                permLine.charAt(4) == 'r',
+                permLine.charAt(7) == 'r'};
+
+        Boolean[] write=new Boolean[]{permLine.charAt(2) == 'w',
+                permLine.charAt(5) == 'w',
+                permLine.charAt(8) == 'w'};
+
+        Boolean[] execute=new Boolean[]{permLine.charAt(3) == 'x',
+                permLine.charAt(6) == 'x',
+                permLine.charAt(9) == 'x'};
+
         arrayList.add(read);
         arrayList.add(write);
         arrayList.add(execute);
diff --git a/app/src/play/java/com/amaze/filemanager/activities/MainActivity.java b/app/src/play/java/com/amaze/filemanager/activities/MainActivity.java
index 11a4f6581..f098554bf 100644
--- a/app/src/play/java/com/amaze/filemanager/activities/MainActivity.java
+++ b/app/src/play/java/com/amaze/filemanager/activities/MainActivity.java
@@ -619,7 +619,7 @@ public class MainActivity extends ThemedActivity implements OnRequestPermissions
                     closeInteractiveShell();
                     sharedPref.edit().putBoolean(PreferenceUtils.KEY_ROOT, false).apply();
                 }
-            } catch (RootNotPermittedException e) {
+            } catch (ShellNotRunningException e) {
                 e.printStackTrace();
                 sharedPref.edit().putBoolean(PreferenceUtils.KEY_ROOT, false).apply();
             }*/
