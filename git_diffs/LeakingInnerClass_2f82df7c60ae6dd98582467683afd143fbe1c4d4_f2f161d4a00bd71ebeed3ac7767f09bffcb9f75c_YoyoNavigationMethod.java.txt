diff --git a/app/src/main/java/cn/rbc/termuc/EditFragment.java b/app/src/main/java/cn/rbc/termuc/EditFragment.java
new file mode 100644
index 0000000..8100049
--- /dev/null
+++ b/app/src/main/java/cn/rbc/termuc/EditFragment.java
@@ -0,0 +1,156 @@
+package cn.rbc.termuc;
+import android.app.*;
+import android.os.*;
+import android.view.*;
+import android.widget.*;
+import java.io.*;
+import org.json.*;
+import android.net.*;
+import java.util.*;
+/*import tiiehenry.code.view.*;
+import tiiehenry.code.language.c.*;
+import tiiehenry.code.language.cpp.*;
+import tiiehenry.code.language.java.*;*/
+import cn.rbc.codeeditor.lang.*;
+import cn.rbc.codeeditor.common.*;
+import cn.rbc.codeeditor.util.*;
+import android.util.*;
+
+public class EditFragment extends Fragment implements OnTextChangeListener
+{
+	public final static int TYPE_C = 0;
+	public final static int TYPE_CPP = 1;
+	public final static int TYPE_H = 2;
+	public final static int TYPE_HPP = 3;
+	final static String FL = "f", TP = "t";
+	private File fl;
+	private TextEditor ed;
+	int type;
+	//private int id;
+	//private int _ed;
+	private String C = "gcc";
+
+	public EditFragment() {
+		cgs = new ArrayList<>();
+	}
+
+	public EditFragment(String path, int type) {
+		cgs = new ArrayList<>();
+		Bundle bd = new Bundle();
+		bd.putString(FL, path);
+		bd.putInt(TP, type);
+		setArguments(bd);
+	}
+
+	@Override
+	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)
+	{
+		// TODO: Implement this method
+		setRetainInstance(true);
+		Bundle arg = getArguments();
+		if (arg == null)
+			return null;
+		fl = new File(arg.getString(FL));
+		type = arg.getInt(TP);
+		final MainActivity ma = (MainActivity)getActivity();
+		TextEditor editor = new TextEditor(ma);
+		editor.setVerticalScrollBarEnabled(true);
+		editor.setLayoutParams(new FrameLayout.LayoutParams(
+			FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT));
+		try {
+			FileReader fr = new FileReader(fl);
+			char[] cs = new char[1024];
+			int i;
+			StringBuilder sb = new StringBuilder();
+			while ((i=fr.read(cs)) != -1)
+				sb.append(cs, 0, i);
+			fr.close();
+			//sb.trimToSize();
+			String s = sb.toString();
+			editor.setText(s);
+			editor.getText().setOnTextChangeListener(this);
+			if ((type&1) == 0) {
+				C = "gcc";
+				editor.setLanguage(LanguageC.getInstance());
+			} else {
+				C = "g++";
+				editor.setLanguage(LanguageCpp.getInstance());
+			}
+			//editor.setLanguage(.getInstance());
+			ma.setEditor(editor);
+			ma.lsp.didOpen(fl, (type&1)==1?"cpp":"c", s);
+		} catch(Exception fnf) {
+			fnf.printStackTrace();
+			Toast.makeText(ma, "打开失败！", Toast.LENGTH_SHORT).show();
+		}
+		return ed = editor;
+	}
+
+	public String getC() {
+		return C;
+	}
+
+	private int lastVer = -1;
+	private ArrayList<Quart> cgs;
+
+	public void onChanged(CharSequence c, int s, int ver, boolean ins, boolean typ) {
+		Document dp = ed.getText();
+		boolean b = ed.isWordWrap();
+		Quart q = new Quart();
+		if (b) {
+			q.sr = dp.findLineNumber(s);
+			q.sc = dp.getLineOffset(q.sr);
+		} else {
+			q.sr = dp.findRowNumber(s);
+			q.sc = dp.getRowOffset(q.sr);
+		}
+		q.sc = s - q.sc;
+		if (ins) { // i
+			q.er = q.sr;
+			q.ec = q.sc;
+		} else { // d
+			int e = s + c.length();
+			c = "";
+			if (b) {
+				q.er = dp.findLineNumber(e);
+				q.ec = dp.getLineOffset(q.er);
+			} else {
+				q.er = dp.findRowNumber(e);
+				q.ec = dp.getRowOffset(q.er);
+			}
+			q.ec = e - q.ec;
+		}
+		q.tx = (String)c;
+		cgs.add(q);
+		//lastStr = (String)c;
+		//if (lastVer != ver) {
+		Lsp l = ((MainActivity)getActivity()).lsp;
+		l.didChange(fl, ver, cgs);
+		//lastStart = s;
+		//lastVer = ver;
+		if (ins && typ && (s=c.length())==1 && l.completionTry(fl, q.er, q.ec+1, c.charAt(0)))
+			ed.getAutoCompletePanel().dismiss();
+		cgs.clear();
+		//}
+	}
+
+	@Override
+	public void onHiddenChanged(boolean hidden)
+	{
+		// TODO: Implement this method
+		super.onHiddenChanged(hidden);
+		if (!hidden) {
+			((MainActivity)getActivity()).setEditor(ed);
+			if ((type&1) == 0) { // C
+				ed.setLanguage(LanguageC.getInstance());
+			} else {
+				ed.setLanguage(LanguageCpp.getInstance());
+			}
+			//_tmp = 0;
+		}
+	}
+
+	public File getFile() {
+		return fl;
+	}
+}
diff --git a/app/src/main/java/cn/rbc/termuc/Lsp.java b/app/src/main/java/cn/rbc/termuc/Lsp.java
new file mode 100644
index 0000000..d3bd106
--- /dev/null
+++ b/app/src/main/java/cn/rbc/termuc/Lsp.java
@@ -0,0 +1,212 @@
+package cn.rbc.termuc;
+import android.net.Uri;
+import android.content.*;
+import java.net.*;
+import java.io.*;
+import org.json.JSONObject;
+import java.util.*;
+import android.util.Log;
+import android.app.*;
+import java.nio.charset.StandardCharsets;
+import android.os.*;
+
+public class Lsp {
+	//final static String METHOD = "method";
+	//final static String PARAMS = "params";
+	final static int INITIALIZE = 0, INITIALIZED = 1,
+	OPEN = 2, CLOSE = 3,
+	COMPLETION = 4, FIX = 5, CHANGE = 6, SAVE = 7, NOTI = 8;
+	private final static String TAG = "LSP";
+	//private static int idx;
+	private int tp;
+	int id = 0;
+	private Socket sk;
+	private char[] compTrigs = {};
+	private Thread t;
+	//private Context mA;
+
+	public void start(Context c, final Handler read) {
+		Utils.run(c, "/system/bin/nc", new String[]{"-l", "-s", "127.0.0.1", "-p", "48455", "clangd", "--header-insertion-decorators=0"}, Environment.getExternalStorageDirectory().getAbsolutePath(), false);
+		new Thread(){
+			public void run() {
+				try {
+					Thread.sleep(200L);
+					sk = new Socket("127.0.0.1", 48455);
+					InputStream is = sk.getInputStream();
+					final int L = 2048;
+					byte[] b = new byte[L];
+					while (is.read(b, 0, 16) != -1) {
+						if (new String(b, 0, 14).equals("Content-Length")) {
+							int c = 0, d;
+							while (Character.isDigit(d = is.read())) {
+								c = c * 10 + d - 48;
+							}
+							is.skip(3L);
+							StringBuilder sb = new StringBuilder();
+							while (c > L) {
+								int rl = is.read(b);
+								c -= rl;
+								String s = new String(b, 0, rl, StandardCharsets.UTF_8);
+								sb.append(s);
+							}
+							for (d=0; d<c; d++)
+								b[d] = (byte)is.read();
+							String s = sb.append(new String(b,0,c, StandardCharsets.UTF_8)).toString();
+							Message msg = new Message();
+							msg.what = tp;
+							msg.obj = s;
+							read.sendMessage(msg);
+							//tp = NOTI;
+						}
+					}
+					is.close();
+				} catch (Exception ioe) {
+					Log.e(TAG, ioe.getMessage());
+				}
+			}
+		}.start();
+	}
+
+	private static String wrap(String m, Object p, boolean req) {
+		StringBuilder s = new StringBuilder("{\"jsonrpc\":\"2.0\"");
+		if (req)
+			s.append(",\"id\":0");
+		return s.append(",\"method\":\"").append(m)
+		.append("\",\"params\":").append(JSONObject.wrap(p))
+		.append("}").toString();
+	}
+
+	public void initialize() {
+		tp = INITIALIZE;
+		StringBuilder sb = new StringBuilder("{\"processId\":")
+		.append(android.os.Process.myPid())
+		.append(",\"initializationOptions\":{\"fallbackFlags\":[\"-Wall\"]}}");
+		new SendThread("initialize", sb.toString(), true).start();
+	}
+
+	public void setCompTrigs(char[] c) {
+		compTrigs = c;
+	}
+
+	public byte isCompTrig(char c) {
+		if (Character.isJavaIdentifierPart(c))
+			return 1;
+		for (int i=0,l=compTrigs.length; i<l; i++)
+			if (compTrigs[i] == c)
+				return 2;
+		return 0;
+	}
+
+	public void initialized() {
+		tp = INITIALIZED;
+		new SendThread("initialized", new HashMap(), false).start();
+	}
+
+	public void didClose(File f) {
+		HashMap<String,String> m = new HashMap<>();
+		m.put("uri", Uri.fromFile(f).toString());
+		HashMap<String,HashMap> k = new HashMap<>();
+		k.put("textDocument", m);
+		tp = CLOSE;
+		new SendThread("textDocument/didClose", k, false).start();
+	}
+
+	public void didOpen(File f, String lang, String ct) {
+		StringBuilder m = new StringBuilder("{\"textDocument\":{\"uri\":")
+		.append(JSONObject.quote(Uri.fromFile(f).toString()))
+		.append(",\"languageId\":\"").append(lang)
+		.append("\",\"version\":0,\"text\":")
+		.append(JSONObject.quote(ct))
+		.append("}}");
+		//tp = OPEN;
+		new SendThread("textDocument/didOpen", m.toString(), false).start();
+	}
+
+	public void didSave(File f) {
+		String s = new StringBuilder("{\"textDocument\":{\"uri\":")
+		.append(JSONObject.quote(Uri.fromFile(f).toString()))
+		.append("}}").toString();
+		//tp = SAVE;
+		new SendThread("textDocument/didSave", s, false).start();
+	}
+
+	public synchronized void didChange(File f, int version, List<Quart> chs) {
+		StringBuilder sb = new StringBuilder("{\"textDocument\":{\"uri\":")
+		.append(JSONObject.quote(Uri.fromFile(f).toString()))
+		.append(",\"version\":")
+		.append(version)
+		.append("},\"contentChanges\":[");
+		for (int i=0,j=chs.size(); i<j; i++) {
+			Quart c = chs.get(i);
+			sb.append("{\"range\":{\"start\":{\"line\":")
+			.append(c.sr)
+			.append(",\"character\":")
+			.append(c.sc)
+			.append("},\"end\":{\"line\":")
+			.append(c.er)
+			.append(",\"character\":")
+			.append(c.ec)
+			.append("}},\"text\":")
+			.append(JSONObject.quote(c.tx))
+			.append("},");
+		}
+		sb.setCharAt(sb.length()-1, ']');
+		sb.append('}');
+		Log.d(TAG, sb.toString());
+		//tp = CHANGE;
+		new SendThread("textDocument/didChange", sb.toString(), false).start();
+	}
+
+	public synchronized boolean completionTry(File f, int l, int c, char tgc) {
+		byte b = isCompTrig(tgc);
+		if (b==0)
+			return false;
+		StringBuilder sb = new StringBuilder("{\"textDocument\":{\"uri\":")
+		.append(JSONObject.quote(Uri.fromFile(f).toString()))
+		.append("},\"position\":{\"line\":")
+		.append(l)
+		.append(",\"character\":")
+		.append(c)
+		.append("},\"context\":{\"triggerKind\":")
+		.append(b);
+		if (b==2)
+			sb.append(",\"triggerCharacter\":\"")
+			.append(tgc)
+			.append('"');
+		sb.append("}}");
+		tp = COMPLETION;
+		Log.d(TAG, sb.toString());
+		new SendThread("textDocument/completion", sb.toString(), true).start();
+		return true;
+	}
+
+	public boolean isConnected() {
+		return sk.isConnected();
+	}
+
+	class SendThread extends Thread {
+		private byte[] s;
+
+		public SendThread(String cmd, Object hm, boolean req) {
+			super();
+			s = wrap(cmd, hm, req).getBytes(StandardCharsets.UTF_8);
+		}
+
+		public void run() {
+			try {
+				if (sk==null || sk.isClosed())
+					sk = new Socket("127.0.0.1", 48455);
+				else if (!sk.isConnected())
+					sk.connect(new InetSocketAddress("127.0.0.1", 48455));
+				OutputStream ow = sk.getOutputStream();
+				synchronized(Lsp.class) {
+					ow.write(new StringBuilder("Content-Length: ").append(s.length).append("\r\n\r\n").toString().getBytes());
+					ow.write(s);
+					ow.flush();
+				}
+			} catch(IOException e) {
+				Log.e(TAG, e.getMessage());
+			}
+		}
+	}
+}
diff --git a/app/src/main/java/com/mrikso/texteditor/MainActivity.java b/app/src/main/java/cn/rbc/termuc/MainActivity.java
similarity index 52%
rename from app/src/main/java/com/mrikso/texteditor/MainActivity.java
rename to app/src/main/java/cn/rbc/termuc/MainActivity.java
index 29f0f5b..e897c8c 100644
--- a/app/src/main/java/com/mrikso/texteditor/MainActivity.java
+++ b/app/src/main/java/cn/rbc/termuc/MainActivity.java
@@ -1,10 +1,8 @@
-package com.mrikso.texteditor;
+package cn.rbc.termuc;
 
 import android.app.*;
 
-import android.os.Bundle;
 import android.widget.*;
-import com.mrikso.codeeditor.util.*;
 import android.view.*;
 import java.io.*;
 import android.os.*;
@@ -12,34 +10,34 @@ import android.view.ViewTreeObserver.*;
 import android.view.inputmethod.*;
 import java.lang.reflect.*;
 import android.content.*;
-import com.mrikso.codeeditor.lang.*;
 import android.content.res.*;
-import android.util.*;
+import android.util.Log;
+import java.util.*;
+import org.json.*;
+import java.net.*;
+import android.net.*;
+import cn.rbc.codeeditor.util.*;
 
-public class MainActivity extends Activity {
-	private static StrComp cmp = new StrComp();
-    private static File root = Environment.getExternalStorageDirectory();
-    private final static String PREF = "/data/data/com.termux/files";
-    private final static String PREFC = "com.termux.RUN_COMMAND_";
+public class MainActivity extends Activity implements
+	ActionBar.OnNavigationListener, OnGlobalLayoutListener,
+	AdapterView.OnItemClickListener, AdapterView.OnItemLongClickListener {
+	private StrComp cmp = new StrComp();
+    private File root = Environment.getExternalStorageDirectory();
+    
     private ArrayAdapter<String> adp, hda;
 	private FragmentManager mFmgr;
 	private EditFragment lastFrag = null;
-	private boolean byhand = true;
+	private boolean byhand = true, inited = false;
     private View keys, showlist;
     private File pwd;
     private TextView pwdpth, msgEmpty;
     private LinearLayout subc;
-    private TextEditor textEditor;
+    private TextEditor codeEditor;
 	private Menu _appmenu;
 	private ActionBar ab;
-	private ActionBar.OnNavigationListener abnlisr = new ActionBar.OnNavigationListener() {
-		public boolean onNavigationItemSelected(int p1, long p2) {
-			if (byhand)
-				showFrag(mFmgr.findFragmentByTag(hda.getItem(p1)));
-			return false;
-		}
-	};
 	private SearchAction mSearchAction;
+	private Handler hand = new MainHandler(this);
+	public Lsp lsp;
 
 	private void envInit() {
 		pwd = new File(getPreferences(MODE_PRIVATE).getString("pwd", root.getPath()));
@@ -56,35 +54,24 @@ public class MainActivity extends Activity {
 		_appmenu.findItem(R.id.run).setEnabled(lastFrag.type<2);
 	}
 
+	public boolean onNavigationItemSelected(int p1, long p2) {
+		if (byhand)
+			showFrag(mFmgr.findFragmentByTag(hda.getItem(p1)));
+		return false;
+	}
+
     @Override
     protected void onCreate(Bundle savedInstanceState) {
         super.onCreate(savedInstanceState);
 		envInit();
-		getWindow().getDecorView().getViewTreeObserver().addOnGlobalLayoutListener(new OnGlobalLayoutListener() {
-			public void onGlobalLayout() {
-				try {
-					InputMethodManager inputMethodManager = (InputMethodManager)getSystemService(INPUT_METHOD_SERVICE);
-					Method declaredMethod = inputMethodManager.getClass().getDeclaredMethod("getInputMethodWindowVisibleHeight", new Class[0]);
-					declaredMethod.setAccessible(true);
-					if (((Integer)declaredMethod.invoke(inputMethodManager, new Object[0])).intValue() > 0) {
-						showlist.setVisibility(View.GONE);
-						subc.setVisibility(View.GONE);
-						keys.setVisibility(View.VISIBLE);
-						return;
-					}
-					showlist.setVisibility(View.VISIBLE);
-					keys.setVisibility(View.GONE);
-				} catch (Exception e) {
-					e.printStackTrace();
-				}
-			}});
+		getWindow().getDecorView().getViewTreeObserver().addOnGlobalLayoutListener(this);
 		mFmgr = getFragmentManager();
-		hda = new ArrayAdapter<String>(new ContextThemeWrapper(getBaseContext(), android.R.style.Theme_Holo), R.layout.header_dropdown_item);
+		hda = new ArrayAdapter<>(new ContextThemeWrapper(getBaseContext(), android.R.style.Theme_Holo), R.layout.header_dropdown_item);
 		Resources.Theme rt = getResources().newTheme();
 		rt.applyStyle(android.R.style.Theme_Holo, true);
 		hda.setDropDownViewTheme(rt);
 		ab = getActionBar();
-        ab.setListNavigationCallbacks(hda, abnlisr);
+        ab.setListNavigationCallbacks(hda, this);
 		setContentView(R.layout.activity_main);
         showlist = findViewById(R.id.show_list);
 		keys = findViewById(R.id.keys);
@@ -94,93 +81,14 @@ public class MainActivity extends Activity {
 		pwdpth = hd.findViewById(R.id.pwd);
 		msgEmpty = findViewById(R.id.msg_empty);
 		l.addHeaderView(hd);
-		adp = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1);
+		adp = new ArrayAdapter<>(this, android.R.layout.simple_list_item_1);
 		l.setAdapter(adp);
-		l.setOnItemClickListener(new ListView.OnItemClickListener() {
-			public void onItemClick(AdapterView<?> av, View v, int i, long n) {
-				String _it = adp.getItem(i-1);
-				if ("..".equals(_it))
-					pwd = pwd.getParentFile();
-				else {
-					pwd = new File(pwd, _it);
-					if (pwd.isFile()) {
-						_it = pwd.getAbsolutePath();
-						int _i = hda.getCount();
-						if (mFmgr.findFragmentByTag(_it)!=null) {
-							for (_i--; -1<_i && !_it.equals(hda.getItem(_i)); _i--);
-						} else {
-							int _idx;
-							if (_it.endsWith(".c"))
-								_idx = EditFragment.TYPE_C;
-							else if (_it.endsWith(".cpp"))
-								_idx = EditFragment.TYPE_CPP;
-							else if (_it.endsWith(".h"))
-								_idx = EditFragment.TYPE_H;
-							else if (_it.endsWith(".hpp"))
-								_idx = EditFragment.TYPE_HPP;
-							else
-								_idx = _i = -1;
-							if (_idx != -1) {
-								EditFragment ef = new EditFragment(_it, _idx);
-								FragmentTransaction mts = mFmgr.beginTransaction()
-								.add(R.id.editFrag, ef, _it);
-								if (lastFrag!=null)
-									mts.hide(lastFrag);
-								mts.show(ef)
-								.commit();
-								lastFrag = ef;
-								hda.add(_it);
-								byhand = false;
-								if (_i==0) {
-									getMenuInflater().inflate(R.menu.main, _appmenu);
-									ab.setNavigationMode(ActionBar.NAVIGATION_MODE_LIST);
-									ab.setDisplayShowTitleEnabled(false);
-									msgEmpty.setVisibility(View.GONE);
-								}
-								_appmenu.findItem(R.id.run).setEnabled(_idx<2);
-							}
-						}
-						if (_i != -1) {
-							ab.setSelectedNavigationItem(_i);
-							byhand = true;
-						}
-						pwd = pwd.getParentFile();
-						return;
-					}
-				}
-				refresh();
-			}
-		});
-		l.setOnItemLongClickListener(new ListView.OnItemLongClickListener() {
-			public boolean onItemLongClick(AdapterView<?> av, View v, final int i, long l) {
-				PopupMenu pm = new PopupMenu(MainActivity.this, v);
-				Menu _m = pm.getMenu();
-				_m.add("删除").setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener(){
-					public boolean onMenuItemClick(MenuItem mi) {
-						if (new File(pwd, adp.getItem(i-1)).delete())
-							adp.remove(adp.getItem(i-1));
-						return true;
-					}
-				});
-				pm.show();
-				return true;
-			}
-		});
+		l.setOnItemClickListener(this);
+		l.setOnItemLongClickListener(this);
 		refresh();
 		mSearchAction = new SearchAction(this);
-    }
-
-	private void run() {
-        Intent intent = new Intent();
-        intent.setClassName("com.termux", "com.termux.app.RunCommandService");
-        intent.setAction("com.termux.RUN_COMMAND");
-        intent.putExtra(new StringBuffer(PREFC).append("PATH").toString(), new StringBuffer(PREF).append("/usr/bin/bash").toString());
-        intent.putExtra(new StringBuffer(PREFC).append("RUNNER").toString(), "app-shell");
-        intent.putExtra(new StringBuffer(PREFC).append("ARGUMENTS").toString(), new String[]{"-c", new StringBuffer(lastFrag.getC()).append(" \"").append(escape(lastFrag.getPath())).append("\" -lm -Wall -o $TMPDIR/m && $TMPDIR/m && echo -n \"\nPress any key to continue...\" && read").toString()});
-        intent.putExtra(new StringBuffer(PREFC).append("WORKDIR").toString(), pwd.getPath());
-        intent.putExtra(new StringBuffer(PREFC).append("BACKGROUND").toString(), false);
-        intent.putExtra(new StringBuffer(PREFC).append("SESSION_ACTION").toString(), "0");
-        startService(intent);
+		lsp = new Lsp();
+		lsp.start(this, hand);
     }
 
     private void refresh() {
@@ -196,26 +104,121 @@ public class MainActivity extends Activity {
         }
     }
 
+	@Override
+	public void onGlobalLayout() {
+		try {
+			InputMethodManager inputMethodManager = (InputMethodManager)getSystemService(INPUT_METHOD_SERVICE);
+			Method declaredMethod = inputMethodManager.getClass().getDeclaredMethod("getInputMethodWindowVisibleHeight", new Class[0]);
+			declaredMethod.setAccessible(true);
+			if (((Integer)declaredMethod.invoke(inputMethodManager, new Object[0])).intValue() > 0) {
+				showlist.setVisibility(View.GONE);
+				subc.setVisibility(View.GONE);
+				keys.setVisibility(View.VISIBLE);
+				return;
+			}
+			showlist.setVisibility(View.VISIBLE);
+			keys.setVisibility(View.GONE);
+		} catch (Exception e) {
+			e.printStackTrace();
+		}
+	}
+
+	public void onItemClick(AdapterView<?> av, View v, int i, long n) {
+		String _it = adp.getItem(i-1);
+		if ("..".equals(_it))
+			pwd = pwd.getParentFile();
+		else {
+			pwd = new File(pwd, _it);
+			if (pwd.isFile()) {
+				_it = pwd.getAbsolutePath();
+				int _i = hda.getCount(), _idx = -1;
+				if (mFmgr.findFragmentByTag(_it)!=null) {
+					for (_i--; -1<_i && !_it.equals(hda.getItem(_i)); _i--);
+				} else {
+					if (_it.endsWith(".c"))
+						_idx = EditFragment.TYPE_C;
+					else if (_it.endsWith(".cpp"))
+						_idx = EditFragment.TYPE_CPP;
+					else if (_it.endsWith(".h"))
+						_idx = EditFragment.TYPE_H;
+					else if (_it.endsWith(".hpp"))
+						_idx = EditFragment.TYPE_HPP;
+					else
+						_i = -1;
+					if (_idx != -1) {
+						if (!inited) {
+							lsp.initialize();
+							inited = true;
+						}
+						EditFragment ef = new EditFragment(pwd.getPath(), _idx);
+						FragmentTransaction mts = mFmgr.beginTransaction()
+							.add(R.id.editFrag, ef, _it);
+						if (lastFrag!=null)
+							mts.hide(lastFrag);
+						mts.show(ef)
+							.commit();
+						lastFrag = ef;
+						hda.add(_it);
+						byhand = false;
+						if (_i==0) {
+							getMenuInflater().inflate(R.menu.main, _appmenu);
+							ab.setNavigationMode(ActionBar.NAVIGATION_MODE_LIST);
+							ab.setDisplayShowTitleEnabled(false);
+							msgEmpty.setVisibility(View.GONE);
+						}
+						_appmenu.findItem(R.id.run).setEnabled(_idx<2);
+					}
+				}
+				if (_i != -1) {
+					ab.setSelectedNavigationItem(_i);
+					byhand = true;
+				}
+				pwd = pwd.getParentFile();
+				return;
+			}
+		}
+		refresh();
+	}
+
+	public boolean onItemLongClick(AdapterView<?> av, View v, final int i, long l) {
+		if ("..".equals(adp.getItem(i-1)))
+			return true;
+		PopupMenu pm = new PopupMenu(MainActivity.this, v);
+		Menu _m = pm.getMenu();
+		_m.add("删除").setOnMenuItemClickListener(new MenuItem.OnMenuItemClickListener(){
+				public boolean onMenuItemClick(MenuItem mi) {
+					if (new File(pwd, adp.getItem(i-1)).delete())
+						adp.remove(adp.getItem(i-1));
+					return true;
+				}
+			});
+		pm.show();
+		return true;
+	}
+
     @Override
     public boolean onOptionsItemSelected(MenuItem menuItem) {
         switch (menuItem.getItemId()) {
             case R.id.run:
                 try {
                     save();
-                    run();
+                    Utils.run(this, new StringBuffer(Utils.PREF).append("/usr/bin/bash").toString(), new String[]{"-c",
+					new StringBuffer(lastFrag.getC()).append(" \"").append(escape(lastFrag.getFile().getAbsolutePath())).append("\" -lm -Wall -o $TMPDIR/m && $TMPDIR/m && echo -n \"\nPress any key to exit...\" && read").toString()},
+					pwd.getPath(), false);
                 } catch (IOException e) {
                     e.printStackTrace();
                 }
 				break;
 			case R.id.undo:
-                this.textEditor.undo();
+                codeEditor.undo();
                 break;
             case R.id.redo:
-                this.textEditor.redo();
+                codeEditor.redo();
                 break;
             case R.id.save:
 				try {
 					save();
+					toast("已保存");
 				} catch(IOException e) {
 					e.printStackTrace();
 				}
@@ -242,7 +245,14 @@ public class MainActivity extends Activity {
 					mTans.show(lastFrag);
 				}
 				mTans.commit();
+				lsp.didClose(pwd);
+				break;
+			case R.id.test:
+				lsp.initialize();
 				break;
+			/*case R.id.swth:
+				FreeScrollingTextField.jj = !FreeScrollingTextField.jj;
+				break;*/
         }
         return true;
     }
@@ -251,7 +261,9 @@ public class MainActivity extends Activity {
         String charSequence = ((TextView) view).getText().toString();
         if ("⇥".equals(charSequence))
             charSequence = "\t";
-        textEditor.insert(textEditor.getCaretPosition(), charSequence);
+		codeEditor.selectText(false);
+		codeEditor.getText().setTyping(true);
+        codeEditor.paste(charSequence);
     }
 
     @Override
@@ -266,13 +278,30 @@ public class MainActivity extends Activity {
     @Override
     protected void onRestoreInstanceState(Bundle bundle) {
         super.onRestoreInstanceState(bundle);
-        textEditor.setDocument((Document) bundle.getCharSequence("code"));
         pwd = new File(bundle.getString("pwd"));
+		int i = 0, j = 0;
+		for (Fragment f:getFragmentManager().getFragments()) {
+			hda.add(f.getTag());
+			if (!f.isHidden()) {
+				j = i;
+				codeEditor = (TextEditor)f.getView();
+			}
+			i++;
+		}
+		if (!hda.isEmpty()) {
+			getMenuInflater().inflate(R.menu.main, _appmenu);
+			ab.setNavigationMode(ActionBar.NAVIGATION_MODE_LIST);
+			ab.setDisplayShowTitleEnabled(false);
+			msgEmpty.setVisibility(View.GONE);
+			byhand = false;
+			ab.setSelectedNavigationItem(j);
+			byhand = true;
+		}
     }
 
     @Override
     public void onSaveInstanceState(Bundle bundle) {
-        bundle.putCharSequence("code", textEditor.getText());
+        //bundle.putCharSequence("code", textEditor.getText());
         bundle.putString("pwd", pwd.getPath());
         super.onSaveInstanceState(bundle);
     }
@@ -310,9 +339,11 @@ public class MainActivity extends Activity {
     }
 
     public void save() throws IOException {
-        FileWriter fileWriter = new FileWriter(lastFrag.getPath());
-        fileWriter.write(textEditor.getText().toString());
+		File f = lastFrag.getFile();
+        FileWriter fileWriter = new FileWriter(f);
+        fileWriter.write(codeEditor.getText().toString());
         fileWriter.close();
+		lsp.didSave(f);
     }
 
 	@Override
@@ -341,10 +372,10 @@ public class MainActivity extends Activity {
     }
 
 	public void setEditor(TextEditor edit) {
-		textEditor = edit;
+		codeEditor = edit;
 	}
 
 	public TextEditor getEditor() {
-		return textEditor;
+		return codeEditor;
 	}
 }
diff --git a/app/src/main/java/cn/rbc/termuc/MainHandler.java b/app/src/main/java/cn/rbc/termuc/MainHandler.java
new file mode 100644
index 0000000..1366faf
--- /dev/null
+++ b/app/src/main/java/cn/rbc/termuc/MainHandler.java
@@ -0,0 +1,220 @@
+package cn.rbc.termuc;
+import android.os.*;
+import cn.rbc.codeeditor.util.*;
+import java.util.*;
+import android.app.*;
+import android.util.*;
+import android.widget.*;
+import java.io.*;
+import cn.rbc.codeeditor.view.autocomplete.*;
+import static android.util.JsonToken.*;
+
+public class MainHandler extends Handler implements Comparator<ErrSpan> {
+	private MainActivity ma;
+	private static final String
+	ADDEDIT = "additionalTextEdits",
+	CAPA = "capabilities",
+	COMPLE = "completionProvider",
+	DG = "diagnostics",
+	END = "end",
+	IT = "items",
+	KIND = "kind",
+	LABEL = "label",
+	L = "line",
+	MSG = "message",
+	NEWTX = "newText",
+	PARA = "params",
+	RNG = "range",
+	RESU = "result",
+	SEVE = "severity",
+	TEDIT = "textEdit",
+	TG = "triggerCharacters";
+
+	public MainHandler(MainActivity ma) {
+		this.ma = ma;
+	}
+
+	@Override
+	public void handleMessage(Message msg) {
+		switch (msg.what) {
+			case Lsp.INITIALIZE:
+				ma.lsp.initialized();
+				break;
+			case Lsp.CLOSE:
+				return;
+		}
+		try {
+			JsonReader jr = new JsonReader(new StringReader((String)msg.obj));
+			jr.beginObject();
+			Deque<String> st = new ArrayDeque<>();
+			int sl = 0, sc = 0, el = 0, ec = 0;
+			Object tmp1 = null, tmp2 = null, tmp3 = null;
+			boolean _ct = true;
+			while (_ct) {
+				//Log.i("LSP", st.toString());
+				switch (jr.peek()) {
+					case NAME:
+						String n = jr.nextName();
+						switch (n) {
+							case NEWTX:
+								//if (tmp3 instanceof Edit)
+								((Edit)tmp3).text = jr.nextString();
+								break;
+							case LABEL:
+								if (tmp2 instanceof ListItem)
+									((ListItem)tmp2).label = jr.nextString();
+								break;
+							case KIND:
+								if (tmp2 instanceof ListItem)
+									((ListItem)tmp2).kind = jr.nextInt();
+								break;
+							case MSG:
+								if (tmp2 instanceof ErrSpan)
+									((ErrSpan)tmp2).msg = jr.nextString();
+								break;
+							case SEVE:
+								if (tmp2 instanceof ErrSpan)
+									((ErrSpan)tmp2).severity = jr.nextInt() - 1;
+								break;
+							case IT:
+							case DG:
+								tmp1 = new ArrayList();
+							case ADDEDIT:
+								jr.beginArray();
+								st.push(n);
+								break;
+							case TG:
+								jr.beginArray();
+								StringBuilder sb = new StringBuilder();
+								while (jr.hasNext())
+									sb.append(jr.nextString());
+								jr.close();
+								ma.lsp.setCompTrigs(sb.toString().toCharArray());
+								_ct = false;
+								break;
+							case RNG:
+								jr.beginObject();
+								while (jr.hasNext()) {
+									String tp = jr.nextName();
+									jr.beginObject();
+									if (END.equals(tp))
+										while (jr.hasNext())
+											if (L.equals(jr.nextName()))
+												el = jr.nextInt();
+											else
+												ec = jr.nextInt();
+									else
+										while (jr.hasNext())
+											if (L.equals(jr.nextName()))
+												sl = jr.nextInt();
+											else
+												sc = jr.nextInt();
+									jr.endObject();
+								}
+								jr.endObject();
+								break;
+							case TEDIT:
+								tmp3 = new Edit();
+							case COMPLE:
+							case CAPA:
+							case PARA:
+							case RESU:
+								jr.beginObject();
+								st.push(n);
+								break;
+							default:
+								jr.skipValue();
+								break;
+						}
+						break;
+					case BEGIN_OBJECT:
+						jr.beginObject();
+						if (!st.isEmpty()) {
+						switch (st.peek()) {
+							case ADDEDIT:
+								tmp3 = new Edit();
+								break;
+							case IT:
+								tmp2 = new ListItem();
+								break;
+							case DG:
+								tmp2 = new ErrSpan();
+								break;
+						}
+						}
+						break;
+					case END_OBJECT:
+						jr.endObject();
+						if (!st.isEmpty())
+						switch (st.peek()) {
+							case ADDEDIT:
+								Edit _p = (Edit)tmp3;
+								Document te = ma.getEditor().getText();
+								_p.start = te.getLineOffset(sl) + sc;
+								_p.len = te.getLineOffset(el) + ec - _p.start;
+								((ListItem)tmp2).edits.addLast(_p);
+								break;
+							case TEDIT:
+								_p = (Edit)tmp3;
+								te = ma.getEditor().getText();
+								_p.start = te.getLineOffset(sl) + sc;
+								_p.len = te.getLineOffset(el) + ec - _p.start;
+								((ListItem)tmp2).edits.addFirst(_p);
+								st.pop();
+								break;
+							case IT:
+								((ArrayList)tmp1).add(tmp2);
+								break;
+							case DG:
+								if (sc != ec || sl != el) {
+									ErrSpan e = (ErrSpan)tmp2;
+									e.stl = sl + 1;
+									e.stc = sc;
+									e.enl = el + 1;
+									e.enc = ec;
+									((ArrayList<ErrSpan>)tmp1).add(e);
+								}
+								break;
+							default:
+								st.pop();
+						}
+						break;
+					case END_ARRAY:
+						jr.endArray();
+						if (!st.isEmpty())
+						switch (st.peek()) {
+							case ADDEDIT:
+								st.pop();
+								break;
+							case IT:
+								ma.getEditor().getAutoCompletePanel().update((ArrayList<ListItem>)tmp1);
+								_ct = false;
+								break;
+							case DG:
+								jr.close();
+								ArrayList<ErrSpan> a = (ArrayList<ErrSpan>)tmp1;
+								a.sort(this);
+								TextEditor te = ma.getEditor();
+								te.getText().setDiag(a);
+								te.invalidate();
+								_ct = false;
+								break;
+						}
+						break;
+					case END_DOCUMENT:
+						jr.close();
+						_ct = false;
+						break;
+					default:
+						jr.skipValue();
+				}
+			}
+		} catch (IOException j) {
+			Log.e("LSP", j.getMessage());
+		}
+	}
+
+	public int compare(ErrSpan p1, ErrSpan p2) {
+		return p1.stl - p2.stl;
+	}
+}
diff --git a/app/src/main/java/cn/rbc/termuc/Quart.java b/app/src/main/java/cn/rbc/termuc/Quart.java
new file mode 100644
index 0000000..d657b7c
--- /dev/null
+++ b/app/src/main/java/cn/rbc/termuc/Quart.java
@@ -0,0 +1,7 @@
+package cn.rbc.termuc;
+
+public class Quart
+{
+	public int sr, sc, er, ec;
+	public String tx;
+}
diff --git a/app/src/main/java/com/mrikso/texteditor/SearchAction.java b/app/src/main/java/cn/rbc/termuc/SearchAction.java
similarity index 94%
rename from app/src/main/java/com/mrikso/texteditor/SearchAction.java
rename to app/src/main/java/cn/rbc/termuc/SearchAction.java
index d0ac7b4..99e1b58 100644
--- a/app/src/main/java/com/mrikso/texteditor/SearchAction.java
+++ b/app/src/main/java/cn/rbc/termuc/SearchAction.java
@@ -1,11 +1,11 @@
-package com.mrikso.texteditor;
+package cn.rbc.termuc;
 import android.view.ActionMode;
 import android.view.*;
 import android.content.*;
 import android.app.*;
 import android.widget.*;
 import android.text.*;
-import com.mrikso.codeeditor.util.*;
+import cn.rbc.codeeditor.util.*;
 
 public class SearchAction implements ActionMode.Callback, TextWatcher {
 	private MainActivity ma;
@@ -15,7 +15,6 @@ public class SearchAction implements ActionMode.Callback, TextWatcher {
 
 	public SearchAction(MainActivity ma) {
 		this.ma = ma;
-		//st = ma.getEditor().getText();
 	}
 
 	public void onDestroyActionMode(ActionMode p1) {
@@ -39,7 +38,6 @@ public class SearchAction implements ActionMode.Callback, TextWatcher {
 			idx = 0;
 		e.addTextChangedListener(this);
 		e.requestFocus();
-		//t1 = v.findViewById(R.id.search_msg);
 		p1.setCustomView(v);
 		dp = ma.getEditor().getText();
 		ma.getMenuInflater().inflate(R.menu.search, p2);
diff --git a/app/src/main/java/com/mrikso/texteditor/StrComp.java b/app/src/main/java/cn/rbc/termuc/StrComp.java
similarity index 79%
rename from app/src/main/java/com/mrikso/texteditor/StrComp.java
rename to app/src/main/java/cn/rbc/termuc/StrComp.java
index e67a377..ad397d4 100644
--- a/app/src/main/java/com/mrikso/texteditor/StrComp.java
+++ b/app/src/main/java/cn/rbc/termuc/StrComp.java
@@ -1,9 +1,8 @@
-package com.mrikso.texteditor;
+package cn.rbc.termuc;
 import java.util.*;
 
 public class StrComp implements Comparator<String>
 {
-	@Override
 	public int compare(String p1, String p2)
 	{
 		return p1.compareToIgnoreCase(p2);
diff --git a/app/src/main/java/com/mrikso/texteditor/TextEditor.java b/app/src/main/java/cn/rbc/termuc/TextEditor.java
similarity index 70%
rename from app/src/main/java/com/mrikso/texteditor/TextEditor.java
rename to app/src/main/java/cn/rbc/termuc/TextEditor.java
index 9726022..81da65e 100644
--- a/app/src/main/java/com/mrikso/texteditor/TextEditor.java
+++ b/app/src/main/java/cn/rbc/termuc/TextEditor.java
@@ -1,4 +1,4 @@
-package com.mrikso.texteditor;
+package cn.rbc.termuc;
 
 import android.content.Context;
 import android.graphics.Color;
@@ -8,23 +8,15 @@ import android.util.DisplayMetrics;
 import android.util.TypedValue;
 import android.view.KeyEvent;
 import android.widget.Toast;
-
-import com.mrikso.codeeditor.util.Document;
-//import com.mrikso.codeeditor.util.DocumentProvider;
-import com.mrikso.codeeditor.util.Lexer;
-import com.mrikso.codeeditor.view.ColorScheme;
-import com.mrikso.codeeditor.view.FreeScrollingTextField;
-import com.mrikso.codeeditor.view.YoyoNavigationMethod;
-import com.mrikso.codeeditor.view.autocomplete.AutoCompletePanel;
-
 import java.io.File;
+import cn.rbc.codeeditor.view.*;
+import cn.rbc.codeeditor.util.*;
+import cn.rbc.codeeditor.view.autocomplete.*;
+import cn.rbc.codeeditor.lang.*;
 
-import com.mrikso.codeeditor.lang.*;
-
-
-public class TextEditor extends FreeScrollingTextField {
+public class TextEditor extends FreeScrollingTextField{
    // private Document _inputtingDoc;
-    private boolean _isWordWrap;
+   // private boolean _isWordWrap;
     private Context mContext;
     private String _lastSelectFile;
     private int _index;
@@ -49,8 +41,8 @@ public class TextEditor extends FreeScrollingTextField {
                     break;
             }
         }
-    };
-/*/
+    };*/
+
     public TextEditor(Context context) {
         super(context);
         mContext = context;
@@ -73,15 +65,12 @@ public class TextEditor extends FreeScrollingTextField {
         setShowLineNumbers(true);
         setHighlightCurrentRow(true);
         //setWordWrap(true);
-        setAutoComplete(true);
+        setAutoComplete(false);
         setAutoIndent(true);
         setUseGboard(true);
+		setShowNonPrinting(true);
         //setLanguage(LanguageC.getInstance());
         setNavigationMethod(new YoyoNavigationMethod(this));
-        //int textColor = Color.BLACK;// 默认文字颜色
-        //int selectionText = Color.argb(255, 0, 120, 215);//选择文字颜色
-        //setTextColor(textColor);
-        //setTextHighlightColor(selectionText);
     }
 
     @Override
@@ -93,34 +82,6 @@ public class TextEditor extends FreeScrollingTextField {
             _index = 0;
         }
     }
-/*
-    public void setKeywordColor(int color) {
-        getColorScheme().setColor(ColorScheme.Colorable.KEYWORD, color);
-    }
-
-    public void setBaseWordColor(int color) {
-        getColorScheme().setColor(ColorScheme.Colorable.NAME, color);
-    }
-
-    public void setStringColor(int color) {
-        getColorScheme().setColor(ColorScheme.Colorable.STRING, color);
-    }
-
-    public void setCommentColor(int color) {
-        getColorScheme().setColor(ColorScheme.Colorable.COMMENT, color);
-    }
-
-    public void setBackgroundColor(int color) {
-        getColorScheme().setColor(ColorScheme.Colorable.BACKGROUND, color);
-    }
-
-    public void setTextColor(int color) {
-        getColorScheme().setColor(ColorScheme.Colorable.FOREGROUND, color);
-    }
-
-    public void setTextHighlightColor(int color) {
-        getColorScheme().setColor(ColorScheme.Colorable.SELECTION_BACKGROUND, color);
-    }*/
 
     public static void setLanguage(Language language){
         AutoCompletePanel.setLanguage(language);
@@ -162,24 +123,17 @@ public class TextEditor extends FreeScrollingTextField {
         return super.onKeyShortcut(keyCode, event);
     }
 
-    @Override
-    public void setWordWrap(boolean enable) {
-        // TODO: Implement this method
-        _isWordWrap = enable;
-        super.setWordWrap(enable);
-    }
-
-    public Document getText() {
-        return createDocument();
-    }
-
     public void setText(CharSequence c) {
         Document doc = new Document(this);
-        doc.setWordWrap(_isWordWrap);
+        doc.setWordWrap(isWordWrap());
         doc.setText(c);
         setDocument(doc);
     }
 
+	public AutoCompletePanel getAutoCompletePanel() {
+		return mAutoCompletePanel;
+	}
+
     public File getOpenedFile() {
         if (_lastSelectFile != null)
             return new File(_lastSelectFile);
@@ -191,12 +145,6 @@ public class TextEditor extends FreeScrollingTextField {
         _lastSelectFile = file;
     }
 
-    public void insert(int idx, String text) {
-        selectText(false);
-        moveCaret(idx);
-        paste(text);
-    }
-
     public void replaceAll(CharSequence c) {
         replaceText(0, getLength() - 1, c.toString());
     }
@@ -210,30 +158,28 @@ public class TextEditor extends FreeScrollingTextField {
     }
 
     public void undo() {
-        Document doc = createDocument();
-        int newPosition = doc.undo();
+        int newPosition = hDoc.undo();
 
         if (newPosition >= 0) {
             //TODO editor.setEdited(false);
             // if reached original condition of file
             setEdited(true);
-            respan();
+            mCtrlr.determineSpans();
+			//tc
             selectText(false);
             moveCaret(newPosition);
-            invalidate();
         }
     }
 
     public void redo() {
-        Document doc = createDocument();
-        int newPosition = doc.redo();
+        int newPosition = hDoc.redo();
 
         if (newPosition >= 0) {
             setEdited(true);
-            respan();
+            mCtrlr.determineSpans();
+			//tc
             selectText(false);
             moveCaret(newPosition);
-            invalidate();
         }
     }
 /*
diff --git a/app/src/main/java/cn/rbc/termuc/Utils.java b/app/src/main/java/cn/rbc/termuc/Utils.java
new file mode 100644
index 0000000..2bf2972
--- /dev/null
+++ b/app/src/main/java/cn/rbc/termuc/Utils.java
@@ -0,0 +1,21 @@
+package cn.rbc.termuc;
+import android.content.*;
+
+public class Utils
+{
+	public final static String PREF = "/data/data/com.termux/files";
+    private final static String PREFC = "com.termux.RUN_COMMAND_";
+
+	public static void run(Context cont, String cmd, String[] args, String pwd, boolean background) {
+		Intent intent = new Intent()
+        .setClassName("com.termux", "com.termux.app.RunCommandService")
+        .setAction("com.termux.RUN_COMMAND")
+        .putExtra(new StringBuffer(PREFC).append("PATH").toString(), cmd)
+        .putExtra(new StringBuffer(PREFC).append("RUNNER").toString(), "app-shell")
+        .putExtra(new StringBuffer(PREFC).append("ARGUMENTS").toString(), args)
+        .putExtra(new StringBuffer(PREFC).append("WORKDIR").toString(), pwd)
+        .putExtra(new StringBuffer(PREFC).append("BACKGROUND").toString(), background)
+        .putExtra(new StringBuffer(PREFC).append("SESSION_ACTION").toString(), "0");
+        cont.startService(intent);
+	}
+}
diff --git a/app/src/main/java/com/mrikso/texteditor/EditFragment.java b/app/src/main/java/com/mrikso/texteditor/EditFragment.java
deleted file mode 100644
index 4fb246a..0000000
--- a/app/src/main/java/com/mrikso/texteditor/EditFragment.java
+++ /dev/null
@@ -1,70 +0,0 @@
-package com.mrikso.texteditor;
-import android.app.*;
-import android.os.*;
-import android.view.*;
-import android.widget.*;
-import java.io.*;
-import com.mrikso.codeeditor.lang.*;
-
-public class EditFragment extends Fragment
-{
-	public final static int TYPE_C = 0;
-	public final static int TYPE_CPP = 1;
-	public final static int TYPE_H = 2;
-	public final static int TYPE_HPP = 3;
-	private String path;
-	int type;
-	private String C = "gcc";
-
-	public EditFragment(String path, int type) {
-		this.path = path;
-		this.type = type;
-	}
-
-	@Override
-	public View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState)
-	{
-		// TODO: Implement this method
-		MainActivity ma = (MainActivity)getActivity();
-		TextEditor editor = new TextEditor(ma);
-		editor.setLayoutParams(new FrameLayout.LayoutParams(
-			FrameLayout.LayoutParams.MATCH_PARENT, FrameLayout.LayoutParams.MATCH_PARENT));
-		try {
-			FileInputStream fr = new FileInputStream(path);
-			byte[] cs = new byte[fr.available()];
-			fr.read(cs);
-			fr.close();
-			editor.setText(new String(cs));
-			if ((type&1) == 0) {
-				C = "gcc";
-				editor.setLanguage(LanguageC.getInstance());
-			} else {
-				C = "g++";
-				editor.setLanguage(LanguageCpp.getInstance());
-			}
-			ma.setEditor(editor);
-		} catch(Exception fnf) {
-			fnf.printStackTrace();
-			Toast.makeText(ma, "Open failed!", Toast.LENGTH_SHORT).show();
-		}
-		return editor;
-	}
-
-	public String getC() {
-		return C;
-	}
-
-	@Override
-	public void onHiddenChanged(boolean hidden)
-	{
-		// TODO: Implement this method
-		super.onHiddenChanged(hidden);
-		if (!hidden) {
-			((MainActivity)getActivity()).setEditor((TextEditor)getView());
-		}
-	}
-
-	public String getPath() {
-		return path;
-	}
-}
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/common/OnCaretScrollListener.java b/codeeditor/src/main/java/cn/rbc/codeeditor/common/OnCaretScrollListener.java
similarity index 68%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/common/OnCaretScrollListener.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/common/OnCaretScrollListener.java
index baf179e..ae96a6c 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/common/OnCaretScrollListener.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/common/OnCaretScrollListener.java
@@ -1,4 +1,4 @@
-package com.mrikso.codeeditor.common;
+package cn.rbc.codeeditor.common;
 
 public interface OnCaretScrollListener {
     void updateCaret(int caretIndex);
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/common/OnKeyShortcutListener.java b/codeeditor/src/main/java/cn/rbc/codeeditor/common/OnKeyShortcutListener.java
similarity index 76%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/common/OnKeyShortcutListener.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/common/OnKeyShortcutListener.java
index ccc0bbc..b4e2e3b 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/common/OnKeyShortcutListener.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/common/OnKeyShortcutListener.java
@@ -1,4 +1,4 @@
-package com.mrikso.codeeditor.common;
+package cn.rbc.codeeditor.common;
 
 import android.view.KeyEvent;
 
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/common/OnRowChangedListener.java b/codeeditor/src/main/java/cn/rbc/codeeditor/common/OnRowChangedListener.java
similarity index 67%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/common/OnRowChangedListener.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/common/OnRowChangedListener.java
index 018e6b8..d04bbe1 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/common/OnRowChangedListener.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/common/OnRowChangedListener.java
@@ -1,4 +1,4 @@
-package com.mrikso.codeeditor.common;
+package cn.rbc.codeeditor.common;
 
 public interface OnRowChangedListener {
 	void onRowChanged(int newRowIndex);
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/common/OnSelectionChangedListener.java b/codeeditor/src/main/java/cn/rbc/codeeditor/common/OnSelectionChangedListener.java
similarity index 75%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/common/OnSelectionChangedListener.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/common/OnSelectionChangedListener.java
index 275370b..11770c3 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/common/OnSelectionChangedListener.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/common/OnSelectionChangedListener.java
@@ -1,4 +1,4 @@
-package com.mrikso.codeeditor.common;
+package cn.rbc.codeeditor.common;
 
 public interface OnSelectionChangedListener {
 	 void onSelectionChanged(boolean active,int selStart, int selEnd);
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/common/OnTextChangeListener.java b/codeeditor/src/main/java/cn/rbc/codeeditor/common/OnTextChangeListener.java
new file mode 100644
index 0000000..b73831e
--- /dev/null
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/common/OnTextChangeListener.java
@@ -0,0 +1,6 @@
+package cn.rbc.codeeditor.common;
+import cn.rbc.codeeditor.util.*;
+
+public interface OnTextChangeListener {
+	void onChanged(CharSequence c, int start, int ver, boolean ins, boolean typ);
+}
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/Language.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/Language.java
similarity index 98%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/lang/Language.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/lang/Language.java
index 6f26f61..98f557f 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/Language.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/Language.java
@@ -6,9 +6,9 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.lang;
+package cn.rbc.codeeditor.lang;
 
-import com.mrikso.codeeditor.util.Lexer;
+import cn.rbc.codeeditor.util.Lexer;
 
 import java.util.HashMap;
 import java.util.*;
@@ -79,7 +79,7 @@ public abstract class Language
 	{
 		_keyword = new String[keywords.length];
 		for(int i=0;i<keywords.length;i++){
-			_keyword[i]=keywords[i]+"[keyword]";
+			_keyword[i]="[K]"+keywords[i];
 		}
 
 		_keywordsMap = new HashSet<String>(keywords.length);
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageC.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageC.java
similarity index 88%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageC.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageC.java
index 5bb1bb5..869418c 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageC.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageC.java
@@ -6,7 +6,7 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.lang;
+package cn.rbc.codeeditor.lang;
 
 import java.util.ArrayList;
 import java.util.Arrays;
@@ -23,11 +23,10 @@ public class LanguageC extends Language{
 		"enum", "struct", "union",
 		"break", "case", "continue", "default", "do", "else", "for",
 		"goto", "if", "return", "switch", "while",
-		//"define","include","ifdef","endif","ifndef","error","elif","line","pragma","undef"
 		};
 	private final static String[] types = {
 		"char", "double", "float", "int", "long", "short", "void",
-		"signed", "unsigned"
+		"signed", "unsigned", "_Bool", "_Complex", "_Imaginary"
 	};
 	private  final  static  String[] functions={
 			"abort","abs","acos","asctime","asin","assert","atan","atan2","atexit","atof","atoi","atol"
@@ -48,24 +47,25 @@ public class LanguageC extends Language{
 	private final static String[] keynames = {
 		"EOF", "NULL"
 	};
+	private final static String[] extraWord = {
+		"define","include","ifdef","endif","ifndef","error","elif","line","pragma","undef","main"
+	};
 	private final static char[] BASIC_C_OPERATORS = {
 			'(', ')', '{', '}', '.', ',', ';', '=', '+', '-',
 			'/', '*', '&', '!', '|', ':', '[', ']', '<', '>',
 			'?', '~', '%', '^'
 	};
 	public static Language getInstance(){
-		if(_theOne == null){
+		if (_theOne == null)
 			_theOne = new LanguageC();
-		}
 		return _theOne;
 	}
 	
 	private LanguageC(){
-		String[] diyWord= new String[header.length+functions.length];
-		System.arraycopy(functions,0,diyWord,0,functions.length);
-		System.arraycopy(header,0,diyWord,functions.length,header.length);
 		setKeywords(keywords);
-		addNames(diyWord);
+		addNames(header);
+		addNames(functions);
+		addNames(extraWord);
 		addKeynames(keynames);
 		addTypes(types);
 		setOperators(BASIC_C_OPERATORS);
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageCFamily.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageCFamily.java
similarity index 97%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageCFamily.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageCFamily.java
index 48fbd8b..511f5e6 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageCFamily.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageCFamily.java
@@ -6,9 +6,9 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.lang;
+package cn.rbc.codeeditor.lang;
 
-import com.mrikso.codeeditor.util.Lexer;
+import cn.rbc.codeeditor.util.Lexer;
 
 import java.util.HashMap;
 
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageCpp.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageCpp.java
similarity index 96%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageCpp.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageCpp.java
index 7f8e129..d042861 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageCpp.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageCpp.java
@@ -6,16 +6,14 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.lang;
+package cn.rbc.codeeditor.lang;
 
 public class LanguageCpp extends Language{
 	private static Language _theOne = null;
 	
 	private final static String[] keywords = {
-		"bool", "char", "double", "float", "int", "long", "short", "void", "wchar_t",
-		"auto", "const", "extern", "mutable", "register", "static", "volatile",
-		"signed", "unsigned",
-		"new", "delete", "sizeof", "typedef", "typeid", "typename",
+		"auto", "const", "extern", "mutable", "register", "static", "thread_local", "volatile",
+		"new", "delete", "sizeof", "typedef", "typeid", "typename", "constexpr", "decltype",
 		"const_cast", "dynamic_cast", "reinterpret_cast", "static_cast",
 		"class", "enum", "explicit", "operator", "struct", "template", "union", "virtual",
 		"private", "protected", "public", "friend", "this",
@@ -23,6 +21,10 @@ public class LanguageCpp extends Language{
 		"goto", "if", "return", "switch", "throw", "try", "while",
 		"export", "namespace", "using", "asm", "inline","restrict"
 		};
+	private final static String[] types = {
+		"bool", "char", "double", "float", "int", "long", "short", "void", "wchar_t",
+		"signed", "unsigned", "char16_t", "char32_t"
+	};
 	private  final  static  String[] cFunctions={
 		"abort()","abs(int num):int","acos(double arg):double","asctime(const struct tm *ptr):char *","asin(double arg):double","assert(int exp)","atan(double arg):double","atan2(double y,double x):double","atexit(void (*func)(void)):int","atof(const char *str):double","atoi(const char *str):int","atol(const char *str):long"
 		,"bsearch(const void *key,const void *buf,size_t num,size_t size,int (*compare)(const void *,const void *))","calloc(size_t num, size_t size)","ceil(double num):double","clearerr(FILE *stream)","clock():clock_t","cos(double arg):double","cosh(double arg):double","ctime(const time_t *time):char *","difftime(time_t time2,time_t time1):double","div(int numerator,int denominator):div_t"
@@ -33,14 +35,13 @@ public class LanguageCpp extends Language{
 		,"putc(int ch,FILE *stream):int","putchar(int ch):int","puts(char *str):int","qsort(void *buf,size_t num,size_t size,int (*compare)(const void *,const void *))","raise(int signal):int","rand():int","realloc(void *ptr,size_t size):void *","remove(const char *fname):int","rename(const char *oldfname,const char *newfname):int","rewind(FILE *stream)"
 		,"scanf(const char *format,...):int","setbuf(FILE *stream,char *buffer)","setjmp(jmp_buf envbuf):int","setvbuf(FILE *stream,char *buffer,int mode,size_t size):int","signal(int signal,void (*func)(int))","sin(double arg):double","sinh(double arg):double","sprintf(char *buffer,const char *format,...):int","sqrt(double num):double","srand(unsigned seed)","sscanf(const char *buffer,const char *format,...):int","strcat(char *str1,const char *str2):char *","strchr(const char *str, int ch):char *","strcmp(const char *str1,const char *str2):int","strcoll(const char *str1,const char *str2):int","strcpy(char *to,const char *from):char *","strcspn(const char *str1,const char *str2):size_t","strerror(int num):char *","strftime(char *str,size_t maxsize,const char *fmt,struct tm *time):size_t","strlen(char *str):size_t","strncat(char *str1,const char *str2,size_t count):char *","strncmp(const char *str1,const char *str2,size_t count):int","strncpy(char *to,const char *from,size_t count):char *","strpbrk(const char *str1,const char *str2):char *","strrchr(const char *str,int ch):char *","strspn(const char *str1, const char *str2):size_t","strstr(const char *str1, const char *str2):char *","strtod(const char *start,char **end):double","strtok(char *str1,const char *str2):char *","strtol(const char *start,char **end,int base):long","strtoul(const char *start,char **end,int base):unsigned long","strxfrm(char *str1,const char *str2,size_t num):size_t","system(const char *command):int"
 		,"tan(double arg):double","tanh(double arg):double","time(time_t *time):time_t","tmpfile():FILE *","tmpnam(char *name):char *","tolower(int ch):int","toupper(int ch):int","ungetc(int ch, FILE *stream):int","va_arg(va_list arg_ptr,type):type","vprintf(char *format,va_list arg_ptr):int","vfprintf(FILE *stream,const char *format,va_list arg_ptr):int","vsprintf(char *buffer,char *format,va_list arg_ptr):int"
-
 	};
 
 	private  final  static  String[]  preDefineField={
 		"__LINE__","__FILE__","__DATE__","__TIME__","__cplusplus","__STDC__","__func__","__VA_ARGS__","__attribute__"
 	};
 	private  final  static  String[] cppNamespace ={
-			"std"
+		"std"
 	};
 	private final static String[] cppNames = {
 		"NULL", "EOF", "nullptr", "true", "false"
@@ -70,15 +71,15 @@ public class LanguageCpp extends Language{
 			'?', '~', '%', '^'
 	};
 	public static Language getInstance(){
-		if(_theOne == null){
+		if (_theOne == null)
 			_theOne = new LanguageCpp();
-		}
 		return _theOne;
 	}
 	private LanguageCpp(){
 		setOperators(BASIC_C_OPERATORS);
 		setKeywords(keywords);
 		addKeynames(cppNames);
+		addTypes(types);
 		addNames(cFunctions);
 		addNames(preDefineField);
 		addNames(cppNamespace);
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageCsharp.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageCsharp.java
similarity index 97%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageCsharp.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageCsharp.java
index c5f760e..f557b20 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageCsharp.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageCsharp.java
@@ -6,7 +6,7 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.lang;
+package cn.rbc.codeeditor.lang;
 
 /**
  * Singleton class containing the symbols and operators of the C# language
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageJava.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageJava.java
similarity index 97%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageJava.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageJava.java
index 1738b85..67d6417 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageJava.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageJava.java
@@ -6,7 +6,7 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.lang;
+package cn.rbc.codeeditor.lang;
 
 /**
  * Singleton class containing the symbols and operators of the Java language
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageJavascript.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageJavascript.java
similarity index 97%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageJavascript.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageJavascript.java
index 887c035..45501f7 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageJavascript.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageJavascript.java
@@ -6,7 +6,7 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.lang;
+package cn.rbc.codeeditor.lang;
 
 /**
  * Singleton class containing the symbols and operators of the Javascript language
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageLua.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageLua.java
similarity index 99%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageLua.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageLua.java
index 6b8085c..5d89524 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageLua.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageLua.java
@@ -6,7 +6,7 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.lang;
+package cn.rbc.codeeditor.lang;
 
 /**
  * Singleton class containing the symbols and operators of the Javascript language
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageNonProg.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageNonProg.java
similarity index 97%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageNonProg.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageNonProg.java
index 5998b83..18cc454 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageNonProg.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageNonProg.java
@@ -6,7 +6,7 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.lang;
+package cn.rbc.codeeditor.lang;
 
 /**
  * Singleton class that represents a non-programming language without keywords, 
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageObjectiveC.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageObjectiveC.java
similarity index 97%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageObjectiveC.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageObjectiveC.java
index a4b34a5..d186f86 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageObjectiveC.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageObjectiveC.java
@@ -6,7 +6,7 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.lang;
+package cn.rbc.codeeditor.lang;
 
 /**
  * Singleton class containing the symbols and operators of the Objective-C language
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguagePHP.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguagePHP.java
similarity index 98%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguagePHP.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguagePHP.java
index c1863b7..9fd955e 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguagePHP.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguagePHP.java
@@ -6,7 +6,7 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.lang;
+package cn.rbc.codeeditor.lang;
 
 /**
  * Singleton class containing the symbols and operators of the PHP language
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguagePython.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguagePython.java
similarity index 97%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguagePython.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguagePython.java
index 21d3eed..cb0a781 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguagePython.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguagePython.java
@@ -6,7 +6,7 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.lang;
+package cn.rbc.codeeditor.lang;
 
 /**
  * Singleton class containing the symbols and operators of the Python language
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageRuby.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageRuby.java
similarity index 97%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageRuby.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageRuby.java
index f9caed2..63375db 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageRuby.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageRuby.java
@@ -6,7 +6,7 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.lang;
+package cn.rbc.codeeditor.lang;
 
 /**
  * Singleton class containing the symbols and operators of the Ruby language
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageSmali.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageSmali.java
similarity index 99%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageSmali.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageSmali.java
index a5caf66..8a55969 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/LanguageSmali.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/LanguageSmali.java
@@ -6,7 +6,7 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.lang;
+package cn.rbc.codeeditor.lang;
 
 /**
  * Singleton class containing the symbols and operators of the Smali language
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/xml/XMLLanguage.java b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/xml/XMLLanguage.java
similarity index 93%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/lang/xml/XMLLanguage.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/lang/xml/XMLLanguage.java
index 31ecbb3..5c0a9b2 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/lang/xml/XMLLanguage.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/lang/xml/XMLLanguage.java
@@ -1,6 +1,6 @@
-package com.mrikso.codeeditor.lang.xml;
+package cn.rbc.codeeditor.lang.xml;
 
-import com.mrikso.codeeditor.lang.Language;
+import cn.rbc.codeeditor.lang.Language;
 
 
 /**
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/util/DLog.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/DLog.java
similarity index 98%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/util/DLog.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/util/DLog.java
index ace741a..a33c2c5 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/util/DLog.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/DLog.java
@@ -1,4 +1,4 @@
-package com.mrikso.codeeditor.util;
+package cn.rbc.codeeditor.util;
 
 import java.util.Arrays;
 
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/util/Document.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/Document.java
similarity index 99%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/util/Document.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/util/Document.java
index 7bd1e9a..5b37997 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/util/Document.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/Document.java
@@ -6,9 +6,9 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.util;
+package cn.rbc.codeeditor.util;
 
-import com.mrikso.codeeditor.lang.Language;
+import cn.rbc.codeeditor.lang.Language;
 
 import java.util.ArrayList;
 
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/util/ErrSpan.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/ErrSpan.java
new file mode 100644
index 0000000..7715763
--- /dev/null
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/ErrSpan.java
@@ -0,0 +1,31 @@
+package cn.rbc.codeeditor.util;
+
+public class ErrSpan
+{
+	public final static int
+		ERROR = 0,
+		WARNING = 1,
+		INFOR = 2,
+		HINT = 3;
+	public String msg;
+	public int stl, stc, enl, enc, severity = 0;
+
+	@Override
+	public String toString() {
+		// TODO: Implement this method
+		return new StringBuilder()
+			.append('(')
+			.append(stl)
+			.append(':')
+			.append(stc)
+			.append(',')
+			.append(enl)
+			.append(':')
+			.append(enc)
+			.append(",sev=")
+			.append(severity)
+			.append(",msg=")
+			.append(msg)
+			.append(')').toString();
+	}
+}
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/util/FindThread.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/FindThread.java
similarity index 99%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/util/FindThread.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/util/FindThread.java
index 7255a7d..2afd774 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/util/FindThread.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/FindThread.java
@@ -6,7 +6,7 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.util;
+package cn.rbc.codeeditor.util;
 
 import java.util.Vector;
 
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/util/Flag.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/Flag.java
similarity index 94%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/util/Flag.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/util/Flag.java
index 926dc25..92d6b2d 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/util/Flag.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/Flag.java
@@ -6,7 +6,7 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.util;
+package cn.rbc.codeeditor.util;
 
 public class Flag {
 	private boolean state = false;
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/util/HelperUtils.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/HelperUtils.java
similarity index 70%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/util/HelperUtils.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/util/HelperUtils.java
index 4614690..492aef5 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/util/HelperUtils.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/HelperUtils.java
@@ -1,4 +1,4 @@
-package com.mrikso.codeeditor.util;
+package cn.rbc.codeeditor.util;
 
 import android.content.Context;
 import android.content.res.TypedArray;
@@ -7,17 +7,13 @@ import android.graphics.Canvas;
 import android.graphics.drawable.Drawable;
 import android.util.TypedValue;
 
-import com.mrikso.codeeditor.R;
+import cn.rbc.termuc.R;
+import android.widget.*;
+import android.annotation.*;
 
 public class HelperUtils {
 
-    //get AccentColor
-    public static int fetchAccentColor(Context context) {
-        /*TypedArray typedArray = context.obtainStyledAttributes(new TypedValue().data, new int[]{android.R.attr.colorAccent});
-        int color = typedArray.getColor(0, 0);
-        typedArray.recycle();*/
-        return 0xff0080ff;
-    }
+	private static Toast _t;
 
     public static float getDpi(Context context) {
         return context.getResources().getDisplayMetrics().density;
@@ -30,7 +26,7 @@ public class HelperUtils {
         Drawable vectorDrawable = context.getDrawable(res);
         if (vectorDrawable != null) {
             vectorDrawable.setAlpha(210);
-            vectorDrawable.setTint(fetchAccentColor(context));
+            //vectorDrawable.setTint(fetchAccentColor(context));
             bitmap = Bitmap.createBitmap(vectorDrawable.getIntrinsicWidth(), vectorDrawable.getIntrinsicHeight(), Bitmap.Config.ARGB_8888);
             Canvas canvas = new Canvas(bitmap);
             vectorDrawable.setBounds(0, 0, canvas.getWidth(), canvas.getHeight());
@@ -39,4 +35,10 @@ public class HelperUtils {
         }
         return bitmap;
     }
+
+	public static void show(@NonNull Toast t) {
+		if (_t != null)
+			_t.cancel();
+		(_t = t).show();
+	}
 }
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/util/Lexer.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/Lexer.java
similarity index 78%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/util/Lexer.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/util/Lexer.java
index ef13ffd..d51d2d1 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/util/Lexer.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/Lexer.java
@@ -6,10 +6,10 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.util;
+package cn.rbc.codeeditor.util;
 
-import com.mrikso.codeeditor.lang.Language;
-import com.mrikso.codeeditor.lang.LanguageNonProg;
+import cn.rbc.codeeditor.lang.Language;
+import cn.rbc.codeeditor.lang.LanguageNonProg;
 
 import java.util.ArrayList;
 import java.util.List;
@@ -88,24 +88,21 @@ public class Lexer {
     }
 
     public void tokenize(Document hDoc) {
-        if (!Lexer.getLanguage().isProgLang()) {
+        if (!Lexer.getLanguage().isProgLang())
             return;
-        }
 
         //tokenize will modify the state of hDoc; make a copy
         setDocument(hDoc);
         if (_workerThread == null) {
             _workerThread = new LexThread(this);
             _workerThread.start();
-        } else {
+        } else
             _workerThread.restart();
-        }
     }
 
     void tokenizeDone(List<Pair> result) {
-        if (_callback != null) {
+        if (_callback != null)
             _callback.lexDone(result);
-        }
         _workerThread = null;
     }
 
@@ -126,7 +123,6 @@ public class Lexer {
 
 
     public interface LexCallback {
-		public boolean lexing;
         public void lexDone(List<Pair> results);
     }
 
@@ -154,13 +150,11 @@ public class Lexer {
                 rescan = false;
                 _abort.clear();
                 tokenize();
-            }
-            while (rescan);
+            } while (rescan);
 
-            if (!_abort.isSet()) {
+            if (!_abort.isSet())
                 // lex complete
                 _lexManager.tokenizeDone(_tokens);
-            }
         }
 
         public void restart() {
@@ -188,7 +182,7 @@ public class Lexer {
             }
 
             char[] candidateWord = new char[MAX_KEYWORD_LENGTH];
-            int currentCharInWord = 0;
+            int currCharInWord = 0;
 
             int spanStartPosition = 0;
             int workingPosition = 0;
@@ -199,17 +193,17 @@ public class Lexer {
 
             //hDoc.seekChar(0);
             for (int idx=0, mL=hDoc.getTextLength(); idx<mL && !_abort.isSet();) {
-                char currentChar = hDoc.charAt(idx++);
+                char currChar = hDoc.charAt(idx++);
 
                 switch (state) {
 					case NUMBER:
 						stateChanged = false;
 						boolean t = (substate&NUM_HEX)==0;
 						boolean f = (substate&NUM_FLOAT)==0;
-						char upc = Character.toLowerCase(currentChar);
+						char upc = Character.toLowerCase(currChar);
 						char plc;
 						// 十六进制
-						if (currentCharInWord==1&&prevChar=='0'&&upc=='x') {
+						if (currCharInWord==1&&prevChar=='0'&&upc=='x') {
 							substate |= NUM_HEX;
 							stateChanged = true;
 							// 浮点数
@@ -230,17 +224,17 @@ public class Lexer {
 							stateChanged = true;
 							// 结尾
 						} else if (f&&upc=='l' || (!f)&&upc=='f') {
-							currentChar = ' ';
+							currChar = ' ';
 						}
-						if (stateChanged||Character.isDigit(currentChar)||((!t)&&'a'<=upc&&'f'>=upc)) {
-							currentCharInWord++;
+						if (stateChanged||Character.isDigit(currChar)||((!t)&&'a'<=upc&&'f'>=upc)) {
+							currCharInWord++;
 							break;
 						}
-						if (!Character.isJavaIdentifierStart(currentChar)) {
-							spanStartPosition = workingPosition - currentCharInWord;
+						if (!Character.isJavaIdentifierStart(currChar)) {
+							spanStartPosition = workingPosition - currCharInWord;
 							tokens.add(new Pair(spanStartPosition, state));
 						}
-						currentCharInWord = 0;
+						currCharInWord = 0;
 						state = UNKNOWN;
 					case OPERATOR:
                     case UNKNOWN: //fall-through
@@ -251,24 +245,24 @@ public class Lexer {
                     case SINGLE_SYMBOL_WORD:
                         int pendingState = state;
                         stateChanged = false;
-                        if (language.isLineStart(prevChar, currentChar)) {
+                        if (language.isLineStart(prevChar, currChar)) {
                             pendingState = DOUBLE_SYMBOL_LINE;
                             stateChanged = true;
-                        } else if (language.isMultilineStartDelimiter(prevChar, currentChar)) {
+                        } else if (language.isMultilineStartDelimiter(prevChar, currChar)) {
                             pendingState = DOUBLE_SYMBOL_DELIMITED_MULTILINE;
                             stateChanged = true;
-                        } else if (language.isDelimiterA(currentChar)) {
+                        } else if (language.isDelimiterA(currChar)) {
                             pendingState = SINGLE_SYMBOL_DELIMITED_A;
                             stateChanged = true;
-                        } else if (language.isDelimiterB(currentChar)) {
+                        } else if (language.isDelimiterB(currChar)) {
                             pendingState = SINGLE_SYMBOL_DELIMITED_B;
                             stateChanged = true;
-						} else if ((!Character.isJavaIdentifierPart(prevChar)) && Character.isDigit(currentChar)) {
+						} else if ((!Character.isJavaIdentifierPart(prevChar)) && Character.isDigit(currChar)) {
 							state = NUMBER;
-                        } else if (language.isLineAStart(currentChar)) {
+                        } else if (language.isLineAStart(currChar)) {
                             pendingState = SINGLE_SYMBOL_LINE_A;
                             stateChanged = true;
-                        } else if (language.isLineBStart(currentChar)) {
+                        } else if (language.isLineBStart(currChar)) {
                             pendingState = SINGLE_SYMBOL_LINE_B;
                             stateChanged = true;
                         }
@@ -279,34 +273,31 @@ public class Lexer {
                                 // account for previous char
                                 spanStartPosition = workingPosition - 1;
 								//TODO consider less greedy approach and avoid adding token for previous char
-                                if (tokens.get(tokens.size() - 1).first == spanStartPosition) {
+                                if (tokens.get(tokens.size() - 1).first == spanStartPosition)
                                     tokens.remove(tokens.size() - 1);
-                                }
-                            } else {
+                            } else
                                 spanStartPosition = workingPosition;
-                            }
 
                             // If a span appears mid-word, mark the chars preceding
                             // it as NORMAL, if the previous span isn't already NORMAL
-                            if (currentCharInWord > 0 && state != NORMAL) {
-                                tokens.add(new Pair(workingPosition - currentCharInWord, NORMAL));
-                            }
+                            if (currCharInWord > 0 && state != NORMAL)
+                                tokens.add(new Pair(workingPosition - currCharInWord, NORMAL));
 
                             state = pendingState;
                             tokens.add(new Pair(spanStartPosition, state));
-                            currentCharInWord = 0;
-                        } else if (language.isWhitespace(currentChar) || language.isOperator(currentChar)) {
-                            if (currentCharInWord > 0) {
+                            currCharInWord = 0;
+                        } else if (language.isWhitespace(currChar) || language.isOperator(currChar)) {
+                            if (currCharInWord > 0) {
                                 // full word obtained; mark the beginning of the word accordingly
 								stateChanged = false;
                                 if (language.isWordStart(candidateWord[0])) {
                                     state = SINGLE_SYMBOL_WORD;
 									stateChanged = true;
-                                } else if (language.isKeyword(new String(candidateWord, 0, currentCharInWord))) {
+                                } else if (language.isKeyword(new String(candidateWord, 0, currCharInWord))) {
                                     state = KEYWORD;
 									stateChanged = true;
                                 } else {
-									Integer i = language.type(new String(candidateWord, 0, currentCharInWord));
+									Integer i = language.type(new String(candidateWord, 0, currCharInWord));
 									int _t;
 									if (i != null && (_t=i.intValue()) != Lexer.NAME) {
 										state = _t;
@@ -317,66 +308,60 @@ public class Lexer {
                                 	}
 								}
 								if (stateChanged) {
-									spanStartPosition = workingPosition - currentCharInWord;
+									spanStartPosition = workingPosition - currCharInWord;
 									tokens.add(new Pair(spanStartPosition, state));
 								}
-                                currentCharInWord = 0;
+                                currCharInWord = 0;
                             }
 
                             // mark operators as normal
-                            if (state != OPERATOR && language.isOperator(currentChar)) {
+                            if (state != OPERATOR && language.isOperator(currChar)) {
                                 state = OPERATOR;
                                 tokens.add(new Pair(workingPosition, state));
                             }
-                        } else if (currentCharInWord < MAX_KEYWORD_LENGTH) {
+                        } else if (currCharInWord < MAX_KEYWORD_LENGTH) {
                             // collect non-whitespace chars up to MAX_KEYWORD_LENGTH
-                            candidateWord[currentCharInWord] = currentChar;
-                            currentCharInWord++;
+                            candidateWord[currCharInWord] = currChar;
+                            currCharInWord++;
                         }
                         break;
 
 
+					case DOUBLE_SYMBOL_LINE:
                     case SINGLE_SYMBOL_LINE_A: // fall-through
 						if (language.isEscapeChar(prevChar))
 							break;
-					case DOUBLE_SYMBOL_LINE:
                     case SINGLE_SYMBOL_LINE_B:
-                        if (currentChar == '\n') {
+                        if (currChar == '\n')
                             state = UNKNOWN;
-                        }
                         break;
 
 
                     case SINGLE_SYMBOL_DELIMITED_A:
-                        if ((language.isDelimiterA(currentChar) || currentChar == '\n')
-                                && !language.isEscapeChar(prevChar)) {
+                        if ((language.isDelimiterA(currChar) || currChar == '\n')
+                                && !language.isEscapeChar(prevChar))
                             state = UNKNOWN;
-                        }
                         // consume escape of the escape character by assigning
-                        // currentChar as something else so that it would not be
+                        // currChar as something else so that it would not be
                         // treated as an escape char in the next iteration
-                        else if (language.isEscapeChar(currentChar) && language.isEscapeChar(prevChar)) {
-                            currentChar = ' ';
-                        }
+                        else if (language.isEscapeChar(currChar) && language.isEscapeChar(prevChar))
+                            currChar = ' ';
                         break;
                     case SINGLE_SYMBOL_DELIMITED_B:
-                        if ((language.isDelimiterB(currentChar) || currentChar == '\n')
-                                && !language.isEscapeChar(prevChar)) {
+                        if ((language.isDelimiterB(currChar) || currChar == '\n')
+                                && !language.isEscapeChar(prevChar))
                             state = UNKNOWN;
-                        }
                         // consume escape of the escape character by assigning
-                        // currentChar as something else so that it would not be
+                        // currChar as something else so that it would not be
                         // treated as an escape char in the next iteration
-                        else if (language.isEscapeChar(currentChar)
-                                && language.isEscapeChar(prevChar)) {
-                            currentChar = ' ';
-                        }
+                        else if (language.isEscapeChar(currChar)
+                                && language.isEscapeChar(prevChar))
+                            currChar = ' ';
                         break;
 
                     case DOUBLE_SYMBOL_DELIMITED_MULTILINE:
-                        if (language.isMultilineEndDelimiter(prevChar, currentChar)) {
+                        if (language.isMultilineEndDelimiter(prevChar, currChar))
                             state = UNKNOWN;
-                        }
                         break;
 
                     default:
@@ -384,19 +369,16 @@ public class Lexer {
                         break;
                 }
                 ++workingPosition;
-                prevChar = currentChar;
+                prevChar = currChar;
             }
             // end state machine
 
-
-            if (tokens.isEmpty()) {
+            if (tokens.isEmpty())
                 // return value cannot be empty
                 tokens.add(new Pair(0, NORMAL));
-            }
 
             _tokens = tokens;
         }
 
-
     }//end inner class
 }
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/util/LinearSearchStrategy.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/LinearSearchStrategy.java
similarity index 98%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/util/LinearSearchStrategy.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/util/LinearSearchStrategy.java
index 94e8573..80f71e4 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/util/LinearSearchStrategy.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/LinearSearchStrategy.java
@@ -6,10 +6,9 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.util;
+package cn.rbc.codeeditor.util;
 
-
-import com.mrikso.codeeditor.lang.Language;
+import cn.rbc.codeeditor.lang.Language;
 
 public class LinearSearchStrategy implements SearchStrategy {
     private int _unitsDone = 0;
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/util/Pair.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/Pair.java
similarity index 93%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/util/Pair.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/util/Pair.java
index 4fac682..e446c70 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/util/Pair.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/Pair.java
@@ -6,7 +6,7 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.util;
+package cn.rbc.codeeditor.util;
 
 public final class Pair {
 	public int first;
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/util/ProgressObserver.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/ProgressObserver.java
similarity index 94%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/util/ProgressObserver.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/util/ProgressObserver.java
index a9361a3..7c94932 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/util/ProgressObserver.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/ProgressObserver.java
@@ -6,7 +6,7 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.util;
+package cn.rbc.codeeditor.util;
 
 /**
  * Can be registered with a {@link ProgressSource} of interest, which will cause
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/util/ProgressSource.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/ProgressSource.java
similarity index 97%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/util/ProgressSource.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/util/ProgressSource.java
index 6a43dae..10236f5 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/util/ProgressSource.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/ProgressSource.java
@@ -6,7 +6,7 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.util;
+package cn.rbc.codeeditor.util;
 
 /**
  * Represents tasks that carry out long computations
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/util/SearchStrategy.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/SearchStrategy.java
similarity index 98%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/util/SearchStrategy.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/util/SearchStrategy.java
index 1e51228..57ca454 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/util/SearchStrategy.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/SearchStrategy.java
@@ -6,7 +6,7 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.util;
+package cn.rbc.codeeditor.util;
 
 public interface SearchStrategy {
 	/**
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/util/TextBuffer.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/TextBuffer.java
similarity index 83%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/util/TextBuffer.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/util/TextBuffer.java
index c1af135..4e4693d 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/util/TextBuffer.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/TextBuffer.java
@@ -6,13 +6,14 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.util;
+package cn.rbc.codeeditor.util;
 
-import com.mrikso.codeeditor.lang.Language;
+import cn.rbc.codeeditor.lang.Language;
 
 import java.util.List;
 import java.util.Vector;
 import java.util.stream.*;
+import cn.rbc.codeeditor.common.*;
 
 
 //TODO Have all methods work with charOffsets and move all gap handling to logicalToRealIndex()
@@ -20,8 +21,7 @@ public class TextBuffer implements CharSequence
 {
 
 	@Override
-	public int length()
-	{
+	public int length() {
 		// TODO: Implement this method
 		return getTextLength();
 	}
@@ -40,9 +40,12 @@ public class TextBuffer implements CharSequence
 
 	/** Continuous seq of chars that have the same format (color, font, etc.) */
 	protected List<Pair> _spans;
+	protected List<ErrSpan> _diag;
 
+	OnTextChangeListener _txLis;
+	private boolean _typ;
 
-	public TextBuffer(){
+	public TextBuffer() {
 		_contents = new char[MIN_GAP_SIZE + 1]; // extra char for EOF
 		_contents[MIN_GAP_SIZE] = Language.EOF;
 		_allocMultiplier = 1;
@@ -51,6 +54,7 @@ public class TextBuffer implements CharSequence
 		_lineCount = 1;
 		_cache = new TextBufferCache();
 		_undoStack = new UndoStack(this);
+		_typ = false;
 	}
 
 	/**
@@ -66,13 +70,12 @@ public class TextBuffer implements CharSequence
 	 */
 	public static int memoryNeeded(int textSize){
 		long bufferSize = textSize + MIN_GAP_SIZE + 1; // extra char for EOF
-		if(bufferSize < Integer.MAX_VALUE){
+		if (bufferSize < Integer.MAX_VALUE)
 			return (int) bufferSize;
-		}
 		return -1;
 	}
 
-	synchronized public void setBuffer(char[] newBuffer, int textSize, int lineCount){
+	synchronized public void setBuffer(char[] newBuffer, int textSize, int lineCount) {
 		_contents = newBuffer;
 		initGap(textSize);
 		_lineCount = lineCount;
@@ -82,10 +85,9 @@ public class TextBuffer implements CharSequence
 	synchronized public void setBuffer(char[] newBuffer){
 		int lineCount=1;
 		int len=newBuffer.length;
-		for(int i=0;i<len;i++){
-			if(newBuffer[i]=='\n')
+		for (int i=0;i<len;i++)
+			if (newBuffer[i]=='\n')
 				lineCount++;
-		}
 		setBuffer(newBuffer,len,lineCount);
 	}
 
@@ -99,9 +101,8 @@ public class TextBuffer implements CharSequence
 	synchronized public String getLine(int lineNumber){
 		int startIndex = getLineOffset(lineNumber);
 
-		if(startIndex < 0){
+		if (startIndex < 0)
 			return new String();
-		}
 		int lineSize = getLineSize(lineNumber);
 
 		return subSequence(startIndex, lineSize).toString();
@@ -115,9 +116,8 @@ public class TextBuffer implements CharSequence
 	 * @return The character offset of lineNumber, or -1 if the line does not exist
 	 */
 	synchronized public int getLineOffset(int lineNumber){
-		if(lineNumber < 0){
+		if (lineNumber < 0)
 			return -1;
-		}
 
 		// start search from nearest known lineIndex~charOffset pair
 		Pair cachedEntry = _cache.getNearestLine(lineNumber);
@@ -125,34 +125,26 @@ public class TextBuffer implements CharSequence
 		int cachedOffset = cachedEntry.second;
 
 		int offset;
-		if (lineNumber > cachedLine){
+		if (lineNumber > cachedLine)
 			offset = findCharOffset(lineNumber, cachedLine, cachedOffset);
-		}
-		else if (lineNumber < cachedLine){
+		else if (lineNumber < cachedLine)
 			offset = findCharOffsetBackward(lineNumber, cachedLine, cachedOffset);
-		}
-		else{
+		else
 			offset = cachedOffset;
-		}
 
-		if (offset >= 0){
+		if (offset >= 0)
 			// seek successful
 			_cache.updateEntry(lineNumber, offset);
-		}
 
 		return offset;
 	}
 
-	@Override
-	public IntStream chars()
-	{
+	public IntStream chars() {
 		// TODO: Implement this method
 		return null;
 	}
 
-	@Override
-	public IntStream codePoints()
-	{
+	public IntStream codePoints() {
 		// TODO: Implement this method
 		return null;
 	}
@@ -168,20 +160,17 @@ public class TextBuffer implements CharSequence
 			"findCharOffsetBackward: Invalid startingOffset given");
 
 		while((workingLine < targetLine) && (offset < _contents.length)){
-			if (_contents[offset] == Language.NEWLINE){
+			if (_contents[offset] == Language.NEWLINE)
 				++workingLine;
-			}
 			++offset;
 
 			// skip the gap
-			if(offset == _gapStartIndex){
+			if (offset == _gapStartIndex)
 				offset = _gapEndIndex;
-			}
 		}
 
-		if (workingLine != targetLine){
+		if (workingLine != targetLine)
 			return -1;
-		}
 		return realToLogicalIndex(offset);
 	}
 
@@ -189,9 +178,8 @@ public class TextBuffer implements CharSequence
 	 * Precondition: startOffset is the offset of startLine
 	 */
 	private int findCharOffsetBackward(int targetLine, int startLine, int startOffset){
-		if (targetLine == 0){
+		if (targetLine == 0)
 			return 0;
-		}
 
 		TextWarriorException.assertVerbose(isValid(startOffset),
 			"findCharOffsetBackward: Invalid startOffset given");
@@ -200,15 +188,12 @@ public class TextBuffer implements CharSequence
 		int offset = logicalToRealIndex(startOffset);
 		while(workingLine > (targetLine-1) && offset >= 0){
 			// skip behind the gap
-			if(offset == _gapEndIndex){
+			if(offset == _gapEndIndex)
 				offset = _gapStartIndex;
-			}
-			--offset;
-
-			if (_contents[offset] == Language.NEWLINE){
-				--workingLine;
-			}
+			offset--;
 
+			if (_contents[offset] == Language.NEWLINE)
+				workingLine--;
 		}
 
 		int charOffset;
@@ -216,8 +201,7 @@ public class TextBuffer implements CharSequence
 			// now at the '\n' of the line before targetLine
 			charOffset = realToLogicalIndex(offset);
 			++charOffset;
-		}
-		else{
+		} else {
 			TextWarriorException.assertVerbose(false,
 				"findCharOffsetBackward: Invalid cache entry or line arguments");
 			charOffset = -1;
@@ -232,9 +216,8 @@ public class TextBuffer implements CharSequence
 	 * @return The line number that charOffset is on, or -1 if charOffset is invalid
 	 */
 	synchronized public int findLineNumber(int charOffset){
-		if(!isValid(charOffset)){
+		if (!isValid(charOffset))
 			return -1;
-		}
 
 		Pair cachedEntry = _cache.getNearestCharOffset(charOffset);
 		int line = cachedEntry.first;
@@ -245,7 +228,7 @@ public class TextBuffer implements CharSequence
 
 		if (targetOffset > offset){
 			// search forward
-			while((offset < targetOffset) && (offset < _contents.length)){
+			while ((offset < targetOffset) && (offset < _contents.length)){
 				if (_contents[offset] == Language.NEWLINE){
 					++line;
 					lastKnownLine = line;
@@ -254,39 +237,32 @@ public class TextBuffer implements CharSequence
 
 				++offset;
 				// skip the gap
-				if(offset == _gapStartIndex){
+				if (offset == _gapStartIndex)
 					offset = _gapEndIndex;
-				}
 			}
-		}
-		else if (targetOffset < offset){
+		} else if (targetOffset < offset)
 			// search backward
 			while((offset > targetOffset) && (offset > 0)){
 				// skip behind the gap
-				if(offset == _gapEndIndex){
+				if(offset == _gapEndIndex)
 					offset = _gapStartIndex;
-				}
-				--offset;
+				offset--;
 
 				if (_contents[offset] == Language.NEWLINE){
 					lastKnownLine = line;
 					lastKnownCharOffset = realToLogicalIndex(offset) + 1;
-					--line;
+					line--;
 				}
 			}
-		}
 
 
-		if (offset == targetOffset){
-			if(lastKnownLine != -1){
+		if (offset == targetOffset) {
+			if(lastKnownLine != -1)
 				// cache the lookup entry
 				_cache.updateEntry(lastKnownLine, lastKnownCharOffset);
-			}
 			return line;
-		}
-		else{
+		} else
 			return -1;
-		}
 	}
 
 
@@ -301,18 +277,17 @@ public class TextBuffer implements CharSequence
 		int lineLength = 0;
 		int pos = getLineOffset(lineNumber);
 
-		if (pos != -1){
+		if (pos != -1) {
 			pos = logicalToRealIndex(pos);
 			//TODO consider adding check for (pos < _contents.length) in case EOF is not properly set
-			while(_contents[pos] != Language.NEWLINE &&
-			 _contents[pos] != Language.EOF){
+			while (_contents[pos] != Language.NEWLINE &&
+			 _contents[pos] != Language.EOF) {
 				++lineLength;
 				++pos;
 
 				// skip the gap
-				if(pos == _gapStartIndex){
+				if (pos == _gapStartIndex)
 					pos = _gapEndIndex;
-				}
 			}
 			++lineLength; // account for the line terminator char
 		}
@@ -339,13 +314,11 @@ public class TextBuffer implements CharSequence
 	 *		non-positive.
 	 */
 	synchronized public CharSequence subSequence(int charOffset, int maxChars){
-		if(!isValid(charOffset) || maxChars <= 0){
+		if (!isValid(charOffset) || maxChars <= 0)
 			return new String();
-		}
 		int totalChars = maxChars;
-		if((charOffset + totalChars) > getTextLength()){
+		if ((charOffset + totalChars) > getTextLength())
 			totalChars = getTextLength() - charOffset;
-		}
 		int realIndex = logicalToRealIndex(charOffset);
 		char[] chars = new char[totalChars];
 
@@ -353,9 +326,8 @@ public class TextBuffer implements CharSequence
 			chars[i] = _contents[realIndex];
 			++realIndex;
 			// skip the gap
-			if(realIndex == _gapStartIndex){
+			if(realIndex == _gapStartIndex)
 				realIndex = _gapEndIndex;
-			}
 		}
 
 		return new String(chars);
@@ -369,9 +341,8 @@ public class TextBuffer implements CharSequence
 	char[] gapSubSequence(int charCount){
 		char[] chars = new char[charCount];
 
-		for (int i = 0; i < charCount; ++i){
+		for (int i = 0; i < charCount; ++i)
 			chars[i] = _contents[_gapStartIndex + i];
-		}
 
 		return chars;
 	}
@@ -383,30 +354,29 @@ public class TextBuffer implements CharSequence
 	 */
 	public synchronized void insert(char[] c, int charOffset, long timestamp,
 			boolean undoable){
-		if(undoable){
+		if (undoable) {
 			_undoStack.captureInsert(charOffset, c.length, timestamp);
+			if (_txLis != null) {
+				UndoStack.Command cm = _undoStack.getLastCommand();
+				_txLis.onChanged(new String(c), charOffset, cm._group, true, _typ);
+				_typ = false;
+			}
 		}
 
 		int insertIndex = logicalToRealIndex(charOffset);
 
 		// shift gap to insertion point
-		if (insertIndex != _gapEndIndex){
-			if (isBeforeGap(insertIndex)){
-				shiftGapLeft(insertIndex);
-			}
-			else{
-				shiftGapRight(insertIndex);
-			}
-		}
+		if (insertIndex<_gapStartIndex)
+			shiftGapLeft(insertIndex);
+		else if (insertIndex>_gapStartIndex)
+			shiftGapRight(insertIndex);
 
-		if(c.length >= gapSize()){
+		if (c.length >= gapSize())
 			growBufferBy(c.length - gapSize());
-		}
 
 		for (int i = 0; i < c.length; ++i){
-			if(c[i] == Language.NEWLINE){
+			if(c[i] == Language.NEWLINE)
 				++_lineCount;
-			}
 			_contents[_gapStartIndex] = c[i];
 			++_gapStartIndex;
 		}
@@ -422,28 +392,30 @@ public class TextBuffer implements CharSequence
 	 */
 	public synchronized void delete(int charOffset, int totalChars, long timestamp,
 			boolean undoable){
-		if(undoable){
+		if (undoable) {
 			_undoStack.captureDelete(charOffset, totalChars, timestamp);
+			if (_txLis != null) {
+				UndoStack.Command cm = _undoStack.getLastCommand();
+				_txLis.onChanged(subSequence(charOffset, totalChars), charOffset, cm._group, false, _typ);
+				_typ = false;
+			}
 		}
 
 		int newGapStart = charOffset + totalChars;
 
 		// shift gap to deletion point
 		if (newGapStart != _gapStartIndex){
-			if (isBeforeGap(newGapStart)){
+			if (newGapStart<_gapStartIndex)
 				shiftGapLeft(newGapStart);
-			}
-			else{
+			else
 				shiftGapRight(newGapStart + gapSize());
-			}
 		}
 
 		// increase gap size
 		for(int i = 0; i < totalChars; ++i){
 			--_gapStartIndex;
-			if(_contents[_gapStartIndex] == Language.NEWLINE){
+			if (_contents[_gapStartIndex] == Language.NEWLINE)
 				--_lineCount;
-			}
 		}
 
 		_cache.invalidateCache(charOffset);
@@ -457,12 +429,10 @@ public class TextBuffer implements CharSequence
 	 * of insertions/deletions. No error checking is done.
 	 */
 	synchronized void shiftGapStart(int displacement){
-		if(displacement >= 0){
+		if(displacement >= 0)
 			_lineCount += countNewlines(_gapStartIndex, displacement);
-		}
-		else{
+		else
 			_lineCount -= countNewlines(_gapStartIndex + displacement, -displacement);
-		}
 
 		_gapStartIndex += displacement;
 		_cache.invalidateCache(realToLogicalIndex(_gapStartIndex - 1) + 1);
@@ -471,11 +441,9 @@ public class TextBuffer implements CharSequence
 	//does NOT skip the gap when examining consecutive positions
 	private int countNewlines(int start, int totalChars){
 		int newlines = 0;
-		for(int i = start; i < (start + totalChars); ++i){
-			if(_contents[i] == Language.NEWLINE){
+		for(int i = start; i < (start + totalChars); ++i)
+			if(_contents[i] == Language.NEWLINE)
 				++newlines;
-			}
-		}
 
 		return newlines;
 	}
@@ -517,6 +485,9 @@ public class TextBuffer implements CharSequence
 		_gapEndIndex = toPosition + 1; // went one-past in the while loop
 	}
 
+	public void setTyping(boolean tp) {
+		_typ = tp;
+	}
 	/**
 	 * Copies _contents into a buffer that is larger by
 	 * 		minIncrement + INITIAL_GAP_SIZE * _allocCount bytes.
@@ -566,25 +537,11 @@ public class TextBuffer implements CharSequence
 	}
 
 	final protected int logicalToRealIndex(int i){
-		if (isBeforeGap(i)){
-			return i;
-		}
-		else{
-			return i + gapSize();
-		}
+		return i<_gapStartIndex ? i : i + gapSize();
 	}
 
 	final protected int realToLogicalIndex(int i){
-		if (isBeforeGap(i)){
-			return i;
-		}
-		else{
-			return i - gapSize();
-		}
-	}
-
-	final protected boolean isBeforeGap(int i){
-		return i < _gapStartIndex;
+		return i<_gapStartIndex ? i : i - gapSize();
 	}
 
 	public void clearSpans(){
@@ -608,6 +565,13 @@ public class TextBuffer implements CharSequence
 		_spans = spans;
 	}
 
+	public List<ErrSpan> getDiag(){
+		return _diag;
+	}
+
+	public void setDiag(List<ErrSpan> diag) {
+		_diag = diag;
+	}
 	/**
 	 * Returns true if in batch edit mode
 	 */
@@ -648,19 +612,19 @@ public class TextBuffer implements CharSequence
 	}
 
 	@Override
-	public String toString()
-	{
-		// TODO: Implement this method
+	public String toString() {
 		int len=getTextLength();
 		StringBuffer buf=new StringBuffer();
-		for (int i=0;i < len;i++){
+		for (int i=0; i < len;i++) {
 			char c=charAt(i);
 			if (c==Language.EOF)
 				break;
 			buf.append(c);
 		}
-		return new String(buf);
+		return buf.toString();
 	}
 
-
+	public void setOnTextChangeListener(OnTextChangeListener txLis) {
+		_txLis = txLis;
+	}
 }
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/util/TextBufferCache.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/TextBufferCache.java
similarity index 89%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/util/TextBufferCache.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/util/TextBufferCache.java
index c7db4da..0747d96 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/util/TextBufferCache.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/TextBufferCache.java
@@ -6,7 +6,7 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.util;
+package cn.rbc.codeeditor.util;
 
 /**
  * A LRU cache that stores the last seek line and its corresponding index so
@@ -27,12 +27,11 @@ public class TextBufferCache {
 	private static final int CACHE_SIZE = 4; // minimum = 1
 	private Pair[] _cache = new Pair[CACHE_SIZE];
 	
-	public TextBufferCache(){
+	public TextBufferCache() {
 		_cache[0] = new Pair(0, 0); // invariant lineIndex and charOffset relation
-		for (int i = 1; i < CACHE_SIZE; ++i){
+		for (int i = 1; i < CACHE_SIZE; ++i)
 			_cache[i] = new Pair(-1, -1);
 			// -1 line index is used implicitly in calculations in getNearestMatch
-		}
 	}
 
 	//TODO consider extracting common parts with getNearestCharOffset(int)
@@ -72,35 +71,30 @@ public class TextBufferCache {
 	 * Place _cache[newHead] at the top of the list
 	 */
 	private void makeHead(int newHead){
-		if(newHead == 0){
+		if (newHead == 0)
 			return;
-		}
 		
 		Pair temp = _cache[newHead];
-		for(int i = newHead; i > 1; --i){
+		for (int i = newHead; i > 1; --i)
 			_cache[i] = _cache[i-1];
-		}
 		_cache[1] = temp; // _cache[0] is always occupied by (0,0)
 	}
 	
 	public void updateEntry(int lineIndex, int charOffset){
-		if(lineIndex <= 0){
+		if(lineIndex <= 0)
 		// lineIndex 0 always has 0 charOffset; ignore. Also ignore negative lineIndex
 			return;
-		}
 
-		if(!replaceEntry(lineIndex, charOffset)){
+		if(!replaceEntry(lineIndex, charOffset))
 			insertEntry(lineIndex, charOffset);
-		}
 	}
 	
 	private boolean replaceEntry(int lineIndex, int charOffset){
-		for (int i = 1; i < CACHE_SIZE; ++i){
+		for (int i = 1; i < CACHE_SIZE; ++i)
 			if(_cache[i].first == lineIndex){
 				_cache[i].second = charOffset;
 				return true;
 			}
-		}
 		return false;
 	}
 	
@@ -114,10 +108,8 @@ public class TextBufferCache {
 	 * Invalidate all cache entries that have char offset >= fromCharOffset
 	 */
 	final protected void invalidateCache(int fromCharOffset){
-		for (int i = 1; i < CACHE_SIZE; ++i){
-			if(_cache[i].second >= fromCharOffset){
+		for (int i = 1; i < CACHE_SIZE; ++i)
+			if(_cache[i].second >= fromCharOffset)
 				_cache[i] = new Pair(-1, -1);
-			}
-		}
 	}
 }
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/util/TextWarriorException.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/TextWarriorException.java
similarity index 93%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/util/TextWarriorException.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/util/TextWarriorException.java
index eefa2fc..f81e6c1 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/util/TextWarriorException.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/TextWarriorException.java
@@ -6,7 +6,7 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.util;
+package cn.rbc.codeeditor.util;
 
 import android.util.Log;
 
@@ -32,7 +32,7 @@ public class TextWarriorException extends Exception {
              * to display the error message on the device screen */
             System.err.print("TextWarrior assertion failed: ");
          //   System.err.println(details);
-            Log.i("codeeditor", details);
+            Log.i("CodeEditor", details);
         }
     }
 }
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/util/UndoStack.java b/codeeditor/src/main/java/cn/rbc/codeeditor/util/UndoStack.java
similarity index 76%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/util/UndoStack.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/util/UndoStack.java
index efc095e..0395a93 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/util/UndoStack.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/util/UndoStack.java
@@ -1,7 +1,9 @@
 
-package com.mrikso.codeeditor.util;
+package cn.rbc.codeeditor.util;
 
 import java.util.LinkedList;
+import static cn.rbc.codeeditor.util.DLog.log;
+import cn.rbc.codeeditor.common.*;
 
 /**
  * Implements undo/redo for insertion and deletion events of TextBuffer
@@ -51,61 +53,69 @@ public class UndoStack {
 	private int _top = 0;
 	/** timestamp for the previous edit operation */
 	long _lastEditTime = -1;
-	
-	public UndoStack(TextBuffer buf){
+
+	public UndoStack(TextBuffer buf) {
 		_buf = buf;
 	}
-	
+
+	public Command getLastCommand() {
+		if (_stack.isEmpty())
+			return null;
+		return _stack.get(_top - 1);
+	}
+
 	/**
 	 * Undo the previous insert/delete operation
 	 * 
 	 * @return The suggested position of the caret after the undo, or -1 if
 	 *			there is nothing to undo
 	 */
-	public int undo(){
-		if(canUndo()){
+	public int undo() {
+		if (canUndo()) {
 			Command lastUndone = _stack.get(_top-1);
 			int group = lastUndone._group;
-			do{
+			OnTextChangeListener lis = _buf._txLis;
+			do {
 				Command c = _stack.get(_top-1);
-				if(c._group != group){
+				if (c._group != group)
 					break;
-				}
-				
+
 				lastUndone = c;
+				if (lis != null) {
+					boolean b = c instanceof Delete;
+					lis.onChanged(c._data != null ? c._data : (b ? new String(_buf.gapSubSequence(c._length)) : _buf.subSequence(c._start, c._length)), c._start, group, b, false);
+				}
 				c.undo();
 				--_top;
-			}
-			while(canUndo());
-
+			} while (canUndo());
 			return lastUndone.findUndoPosition();
 		}
 		
 		return -1;
 	}
-	
+
 	/**
 	 * Redo the previous insert/delete operation
 	 * 
 	 * @return The suggested position of the caret after the redo, or -1 if
 	 *			there is nothing to redo
 	 */
-	public int redo(){
-		if(canRedo()){
+	public int redo() {
+		if (canRedo()) {
 			Command lastRedone = _stack.get(_top);
 			int group = lastRedone._group;
-			do{
+			OnTextChangeListener lis = _buf._txLis;
+			do {
 				Command c = _stack.get(_top);
-				if(c._group != group){
+				if (c._group != group)
 					break;
-				}
 
 				lastRedone = c;
+				if (lis != null)
+					lis.onChanged(c._data, c._start, group, c instanceof Insert, false);
 				c.redo();
 				++_top;
-			}
-			while(canRedo());
-			
+			} while (canRedo());
 			return lastRedone.findRedoPosition();
 		}
 
@@ -117,30 +127,27 @@ public class UndoStack {
 	 * Records an insert operation. Should be called before the insertion is
 	 * actually done.
 	 */
-	public void captureInsert(int start, int length, long time){
-		boolean mergeSuccess = false;
-		
-		if(canUndo()){
+	public void captureInsert(int start, int length, long time) {
+		boolean merged = false;
+
+		if (canUndo()) {
 			Command c = _stack.get(_top - 1);
 			
-			if(c instanceof InsertCommand
-					&& c.merge(start, length, time)){
-				mergeSuccess = true;
-			}
-			else{
+			if(c instanceof Insert
+					&& c.merge(start, length, time))
+				merged = true;
+			else
 				c.recordData();
-			}
 		}
 		
-		if(!mergeSuccess){
-			push(new InsertCommand(start, length, _groupId));
-			
-			if(!_isBatchEdit){
+		if (!merged) {
+			push(new Insert(start, length, _groupId));
+
+			if(!_isBatchEdit)
 				_groupId++;
-			}
 		}
-		
 		_lastEditTime = time;
+		//return merged;
 	}
 
 	/**
@@ -148,67 +155,61 @@ public class UndoStack {
 	 * actually done.
 	 */
 	public void captureDelete(int start, int length, long time){
-		boolean mergeSuccess = false;
+		boolean merged = false;
 		
-		if(canUndo()){
+		if (canUndo()) {
 			Command c = _stack.get(_top - 1);
 			
-			if(c instanceof DeleteCommand
-					&& c.merge(start, length, time)){
-				mergeSuccess = true;
-			}
-			else{
+			if (c instanceof Delete
+					&& c.merge(start, length, time))
+				merged = true;
+			else
 				c.recordData();
-			}
 		}
-		
-		if(!mergeSuccess){
-			push(new DeleteCommand(start, length, _groupId));
 
-			if(!_isBatchEdit){
+		if (!merged) {
+			push(new Delete(start, length, _groupId));
+
+			if(!_isBatchEdit)
 				_groupId++;
-			}
 		}
-		
 		_lastEditTime = time;
+		//return merged;
 	}
-	
-	private void push(Command c){
+
+	private void push(Command c) {
 		trimStack();
 		++_top;
 		_stack.add(c);
 	}
-	
-	private void trimStack(){
-		while(_stack.size() > _top){
+
+	private void trimStack() {
+		while (_stack.size() > _top)
 			_stack.removeLast();
-		}
 	}
-	
-	public final boolean canUndo(){
+
+	public final boolean canUndo() {
 		return _top > 0;
 	}
 
-	public final boolean canRedo(){
+	public final boolean canRedo() {
 		return _top < _stack.size();
 	}
 
 	public boolean isBatchEdit(){
 		return _isBatchEdit;
 	}
-	
+
 	public void beginBatchEdit(){
 		_isBatchEdit = true;
 	}
-	
+
 	public void endBatchEdit(){
 		_isBatchEdit = false;
 		_groupId++;
 	}
-	
-	
-	
-	private abstract class Command{
+
+	public abstract class Command{
 		public final static long MERGE_TIME = 1000000000; //750ms in nanoseconds
 		/** Start position of the edit */
 		public int _start;
@@ -242,12 +243,12 @@ public class UndoStack {
 		public abstract boolean merge(int start, int length, long time);
 	}
 	
-	private class InsertCommand extends Command{
+	public class Insert extends Command{
 		/**
 		 * Corresponds to an insertion of text of size length just before
 		 * start position.
 		 */
-		public InsertCommand(int start, int length, int groupNumber){
+		public Insert(int start, int length, int groupNumber){
 			_start = start;
 			_length = length;
 			_group = groupNumber;
@@ -255,11 +256,10 @@ public class UndoStack {
 
 		@Override
 		public boolean merge(int newStart, int length, long time) {
-			if(_lastEditTime < 0){
+			if (_lastEditTime < 0)
 				return false;
-			}
 			
-			if((time - _lastEditTime) < MERGE_TIME
+			if ((time - _lastEditTime) < MERGE_TIME
 					&& newStart == _start + _length){
 				_length += length;
 				trimStack();
@@ -272,7 +272,7 @@ public class UndoStack {
 		@Override
 		public void recordData() {
 			//TODO handle memory allocation failure
-			_data = _buf.subSequence(_start, _length).toString();
+			_data = (String)_buf.subSequence(_start, _length);
 		}
 
 		@Override
@@ -280,16 +280,16 @@ public class UndoStack {
 			if(_data == null){
 				recordData();
 				_buf.shiftGapStart(-_length);
-			}
-			else{
+			} else
 				//dummy timestamp of 0
 				_buf.delete(_start, _length, 0 ,false);
-			}
+			//log("D", _data);
 		}
 
 		@Override
 		public void redo() {
 			//dummy timestamp of 0
+			//log("I", _data);
 			_buf.insert(_data.toCharArray(), _start, 0, false);
 		}
 
@@ -305,12 +305,12 @@ public class UndoStack {
 	}
 	
 	
-	private class DeleteCommand extends Command{
+	public class Delete extends Command{
 		/**
 		 * Corresponds to an deletion of text of size length starting from
 		 * start position, inclusive.
 		 */
-		public DeleteCommand(int start, int length, int seqNumber){
+		public Delete(int start, int length, int seqNumber){
 			_start = start;
 			_length = length;
 			_group = seqNumber;
@@ -318,18 +318,17 @@ public class UndoStack {
 
 		@Override
 		public boolean merge(int newStart, int length, long time) {
-			if(_lastEditTime < 0){
+			if (_lastEditTime < 0)
 				return false;
-			}
-			
-			if((time - _lastEditTime) < MERGE_TIME
-					&& newStart == _start - _length - length + 1){
+
+			if ((time - _lastEditTime) < MERGE_TIME
+					&& newStart == _start - _length - length + 1) {
 				_start = newStart;
 				_length += length;
 				trimStack();
 				return true;
 			}
-			
+
 			return false;
 		}
 
@@ -341,19 +340,19 @@ public class UndoStack {
 
 		@Override
 		public void undo() {
-			if(_data == null){
+			if (_data == null) {
 				recordData();
 				_buf.shiftGapStart(_length);
-			}
-			else{
+			} else
 				//dummy timestamp of 0
 				_buf.insert(_data.toCharArray(), _start, 0, false);
-			}
+			//log("I", _data);
 		}
 
 		@Override
 		public void redo() {
 			//dummy timestamp of 0
+			//log("D", _data);
 			_buf.delete(_start, _length, 0, false);
 		}
 
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/view/ClipboardPanel.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/ClipboardPanel.java
similarity index 98%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/view/ClipboardPanel.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/view/ClipboardPanel.java
index d1a136b..00d626a 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/view/ClipboardPanel.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/ClipboardPanel.java
@@ -1,4 +1,4 @@
-package com.mrikso.codeeditor.view;
+package cn.rbc.codeeditor.view;
 
 import android.content.Context;
 import android.content.res.TypedArray;
@@ -9,7 +9,7 @@ import android.view.Menu;
 import android.view.MenuItem;
 import android.view.View;
 
-import com.mrikso.codeeditor.R;
+import cn.rbc.termuc.R;
 
 public class ClipboardPanel {
     protected FreeScrollingTextField _textField;
@@ -174,6 +174,7 @@ public class ClipboardPanel {
                     case 3:
                         _textField.paste();
                         mode.finish();
+						break;
                     case 4:
                         _textField.delete();
                         mode.finish();
@@ -196,7 +197,6 @@ public class ClipboardPanel {
                 caret = _textField.getBoundingBox(_textField.getCaretPosition());
 				caret.top -= _textField.getScrollY();
 				caret.left += _textField.getScrollX();
-                //outRect = caret;
 				outRect.set(caret);
                // super.onGetContentRect(mode, view, caret);
             }
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/view/ColorScheme.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/ColorScheme.java
similarity index 93%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/view/ColorScheme.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/view/ColorScheme.java
index 6a9c98d..901bb7d 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/view/ColorScheme.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/ColorScheme.java
@@ -7,12 +7,13 @@
  * This software is provided "as is". Use at your own risk.
  */
 
-package com.mrikso.codeeditor.view;
+package cn.rbc.codeeditor.view;
 
-import com.mrikso.codeeditor.util.Lexer;
-import com.mrikso.codeeditor.util.TextWarriorException;
+import cn.rbc.codeeditor.util.Lexer;
+import cn.rbc.codeeditor.util.TextWarriorException;
 
 import java.util.HashMap;
+import android.graphics.*;
 
 public abstract class ColorScheme {
     public enum Colorable {
@@ -98,7 +99,7 @@ public abstract class ColorScheme {
         colors.put(Colorable.CARET_DISABLED, GREY);
         colors.put(Colorable.LINE_HIGHLIGHT, 0x20888888);
 
-        colors.put(Colorable.NON_PRINTING_GLYPH, GREY);//行号
+        colors.put(Colorable.NON_PRINTING_GLYPH, 0xFFBBBBBB);//行号
         colors.put(Colorable.COMMENT, OLIVE_GREEN); //注释
         colors.put(Colorable.KEYWORD, BLUE); //关键字
         colors.put(Colorable.NAME, GREY); // Eclipse default color
@@ -117,4 +118,6 @@ public abstract class ColorScheme {
     private static final int OLIVE_GREEN = 0xFF3F7F5F;
     private static final int WHITE = 0xFFFFFFE0;
     private static final int LIGHT_BLUE2 = 0xFF40B0FF;
+
+	static final int[] DIAG = {Color.RED, 0xFFFFD000, Color.GREEN, Color.GRAY};
 }
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/view/ColorSchemeLight.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/ColorSchemeLight.java
similarity index 98%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/view/ColorSchemeLight.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/view/ColorSchemeLight.java
index 5c7cb48..4a21ea9 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/view/ColorSchemeLight.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/ColorSchemeLight.java
@@ -7,7 +7,7 @@
  * This software is provided "as is". Use at your own risk.
  */
 
-package com.mrikso.codeeditor.view;
+package cn.rbc.codeeditor.view;
 
 
 /**
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/view/FreeScrollingTextField.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/FreeScrollingTextField.java
similarity index 76%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/view/FreeScrollingTextField.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/view/FreeScrollingTextField.java
index d0e569f..11979fd 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/view/FreeScrollingTextField.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/FreeScrollingTextField.java
@@ -29,7 +29,7 @@
  * on screen.
  *
  */
-package com.mrikso.codeeditor.view;
+package cn.rbc.codeeditor.view;
 
 import android.content.Context;
 import android.content.DialogInterface;
@@ -60,21 +60,21 @@ import android.view.inputmethod.InputMethodManager;
 import android.widget.EdgeEffect;
 import android.widget.Scroller;
 
-import com.mrikso.codeeditor.common.OnCaretScrollListener;
-import com.mrikso.codeeditor.common.OnRowChangedListener;
-import com.mrikso.codeeditor.common.OnSelectionChangedListener;
-import com.mrikso.codeeditor.common.OnTextChangeListener;
-import com.mrikso.codeeditor.lang.Language;
-import com.mrikso.codeeditor.util.Document;
-import com.mrikso.codeeditor.util.HelperUtils;
-import com.mrikso.codeeditor.util.Pair;
-import com.mrikso.codeeditor.util.TextWarriorException;
-import com.mrikso.codeeditor.view.autocomplete.AutoCompletePanel;
-import com.mrikso.codeeditor.view.ColorScheme.Colorable;
+import cn.rbc.codeeditor.common.OnCaretScrollListener;
+import cn.rbc.codeeditor.common.OnRowChangedListener;
+import cn.rbc.codeeditor.common.OnSelectionChangedListener;
+import cn.rbc.codeeditor.common.OnTextChangeListener;
+import cn.rbc.codeeditor.lang.Language;
+import cn.rbc.codeeditor.util.Document;
+import cn.rbc.codeeditor.util.HelperUtils;
+import cn.rbc.codeeditor.util.Pair;
+import cn.rbc.codeeditor.util.TextWarriorException;
+import cn.rbc.codeeditor.view.autocomplete.AutoCompletePanel;
+import cn.rbc.codeeditor.view.ColorScheme.Colorable;
 
 import java.util.List;
-import android.util.*;
-import com.mrikso.codeeditor.util.*;
+import android.util.SparseIntArray;
+import cn.rbc.codeeditor.util.*;
 
 /**
  * A custom text view that uses a solid shaded caret (aka cursor) instead of a
@@ -182,7 +182,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
         PICKER_SETS.put('y', "\u00FD\u00FF");
         PICKER_SETS.put('z', "\u017A\u017C\u017E");
         PICKER_SETS.put(KeyCharacterMap.PICKER_DIALOG_INPUT,
-                "\u2026\u00A5\u2022\u00AE\u00A9\u00B1[]{}\\|");
+						"\u2026\u00A5\u2022\u00AE\u00A9\u00B1[]{}\\|");
         PICKER_SETS.put('/', "\\");
 
         // From packages/inputmethods/LatinIME/res/xml/kbd_symbols.xml
@@ -215,12 +215,11 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
 
     //光标宽度
     public final int mCursorWidth = 4;
-    public TextFieldController mFieldController; // the controller in MVC
+    public TextFieldController mCtrlr; // the controller in MVC
     public TextFieldInputConnection mInputConnection;
-    public OnTextChangeListener mTextListener;
     public OnRowChangedListener mRowListener;
-    public OnSelectionChangedListener mSelModeListener;
-    public OnCaretScrollListener mCaretListener;
+    public OnSelectionChangedListener selLis;
+    public OnCaretScrollListener crtLis;
     public int mCaretRow = 0; // can be calculated, but stored for efficiency purposes
     protected boolean isEdited = false; // whether the text field is dirtied
     protected TouchNavigationMethod mNavMethod;
@@ -237,7 +236,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
     protected boolean isLongPressCaps = false;
     protected AutoCompletePanel mAutoCompletePanel;
     private Scroller mScroller;
-    private Paint mTextPaint, mLineNumPaint, mLineNumBgPaint;
+    private Paint mTextPaint, mLineBrush;
     /**
      * Max amount that can be scrolled horizontally based on the longest line
      * displayed on screen so far
@@ -255,39 +254,35 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
     private final Runnable mScrollCaretDownTask = new Runnable() {
         @Override
         public void run() {
-            mFieldController.moveCaretDown();
-            if (!caretOnLastRowOfFile()) {
+            mCtrlr.moveCaretDown();
+            if (!caretOnLastRowOfFile())
                 postDelayed(mScrollCaretDownTask, SCROLL_PERIOD);
-            }
         }
     };
     private final Runnable mScrollCaretUpTask = new Runnable() {
         @Override
         public void run() {
-            mFieldController.moveCaretUp();
-            if (!caretOnFirstRowOfFile()) {
+            mCtrlr.moveCaretUp();
+            if (!caretOnFirstRowOfFile())
                 postDelayed(mScrollCaretUpTask, SCROLL_PERIOD);
-            }
         }
     };
     private final Runnable mScrollCaretLeftTask = new Runnable() {
         @Override
         public void run() {
-            mFieldController.moveCaretLeft(false);
+            mCtrlr.moveCaretLeft(false);
             if (mCaretPosition > 0 &&
-                    mCaretRow == hDoc.findRowNumber(mCaretPosition - 1)) {
+				mCaretRow == hDoc.findRowNumber(mCaretPosition - 1))
                 postDelayed(mScrollCaretLeftTask, SCROLL_PERIOD);
-            }
         }
     };
     private final Runnable mScrollCaretRightTask = new Runnable() {
         @Override
         public void run() {
-            mFieldController.moveCaretRight(false);
+            mCtrlr.moveCaretRight(false);
             if (!caretOnEOF() &&
-                    mCaretRow == hDoc.findRowNumber(mCaretPosition + 1)) {
+				mCaretRow == hDoc.findRowNumber(mCaretPosition + 1))
                 postDelayed(mScrollCaretRightTask, SCROLL_PERIOD);
-            }
         }
     };
     private boolean isUseGboard = false;
@@ -302,7 +297,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
     private Pair mCaretSpan = new Pair(0, 0);
     private Typeface defTypeface = Typeface.DEFAULT;
     private Typeface boldTypeface = Typeface.DEFAULT_BOLD;
-    private Typeface italicTypeface = Typeface.create(Typeface.DEFAULT, Typeface.ITALIC);
+    //private Typeface italicTypeface = Typeface.create(Typeface.DEFAULT, Typeface.ITALIC);
     private int mTypeInput = InputType.TYPE_CLASS_TEXT;
     private Context mContext;
 	private SparseIntArray chrAdvs = new SparseIntArray();
@@ -323,7 +318,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
     }
 
     public void setCaretListener(OnCaretScrollListener caretScrollListener) {
-        mCaretListener = caretScrollListener;
+        crtLis = caretScrollListener;
     }
 
     protected void initTextField(Context context) {
@@ -368,6 +363,10 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
         isShowLineNumbers = showLineNumbers;
     }
 
+	public void setShowNonPrinting(boolean showNonPrinting) {
+		isShowNonPrinting = showNonPrinting;
+	}
+
     public void setCaretScrolled(boolean scrolled) {
         isCaretScrolled = scrolled;
     }
@@ -393,34 +392,32 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
 	}
 
     public void setTextSize(int pix, float cx, float cy) {
-        if (pix <= 20 || pix >= 80 || pix == mTextPaint.getTextSize()) {
+        if (pix <= 20 || pix >= 80 || pix == mTextPaint.getTextSize())
             return;
-        }
         float oldHeight = rowHeight();
-        float oldWidth = getAdvance('a');
+        float oldWidth = getCharAdvance('a');
         mZoomFactor = pix / BASE_TEXT_SIZE_PIXELS;
         mTextPaint.setTextSize(pix);
-        mLineNumPaint.setTextSize(pix);
+		mLineBrush.setTextSize(pix);
         if (hDoc.isWordWrap())
             hDoc.analyzeWordWrap();
-        mFieldController.updateCaretRow();
+        mCtrlr.updateCaretRow();
 		chrAdvs.clear();
 		mAlphaWidth = getCharAdvance('a');
+		mLineBrush.setStrokeWidth(mAlphaWidth*.15f);
         float x = (getScrollX() + cx) * mAlphaWidth / oldWidth - cx;
         float y = (getScrollY() + cy) * rowHeight() / oldHeight - cy;
         scrollTo(Math.max((int)x, 0), Math.max((int)y, 0));
         mSpaceWidth = (int) mTextPaint.measureText(" ");
         //int idx=coordToCharIndex(getScrollX(), getScrollY());
         //if (!makeCharVisible(idx))
-        {
             invalidate();
-        }
     }
 
     public void replaceText(int from, int charCount, String text) {
         hDoc.beginBatchEdit();
-        mFieldController.replaceText(from, charCount, text);
-        mFieldController.stopTextComposing();
+        mCtrlr.replaceText(from, charCount, text);
+        mCtrlr.stopTextComposing();
         hDoc.endBatchEdit();
     }
 
@@ -440,16 +437,14 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
 
     private void initView(Context context) {
 
-        mFieldController = new TextFieldController(this);
+        mCtrlr = new TextFieldController(this);
         mClipboardManager = (ClipboardManager) context.getSystemService(Context.CLIPBOARD_SERVICE);
         mTextPaint = new Paint();
         mTextPaint.setAntiAlias(true);
         mTextPaint.setTextSize(BASE_TEXT_SIZE_PIXELS);
-        mLineNumPaint = new Paint();
-        mLineNumPaint.setAntiAlias(true);
-        mLineNumPaint.setTextSize(BASE_TEXT_SIZE_PIXELS);
-        mLineNumBgPaint = new Paint();
-        mLineNumBgPaint.setAntiAlias(true);
+        mLineBrush = new Paint();
+		mLineBrush.setAntiAlias(true);
+		mLineBrush.setTextSize(BASE_TEXT_SIZE_PIXELS);
         mTopEdge = new EdgeEffect(mContext);
         mBottomEdge = new EdgeEffect(mContext);
         mRect = new RectF();
@@ -460,53 +455,6 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
         setHapticFeedbackEnabled(true);
         mColorScheme = new ColorSchemeLight();
 
-        mTextListener = new OnTextChangeListener() {
-
-            @Override
-            public void onNewLine(String s, int caretPosition, int pos) {
-                // TODO: Implement this method
-                isTextChanged = true;
-                mCaretSpan.first = mCaretSpan.first + 1;
-                mAutoCompletePanel.dismiss();
-            }
-
-            @Override
-            public void onDel(CharSequence text, int cursorPosition, int delCount) {
-                isTextChanged = true;
-                if (delCount <= mCaretSpan.first) {
-                    mCaretSpan.first = mCaretSpan.first - 1;
-                }
-                mAutoCompletePanel.dismiss();
-            }
-
-            @Override
-            public void onAdd(CharSequence text, int cursorPosition, int addCount) {
-                isTextChanged = true;
-                mCaretSpan.first = mCaretSpan.first + addCount;
-                int curr = cursorPosition;
-                if (text.length() == 0) return;
-                //找到空格或者其他
-                for (; curr >= 0; curr--) {
-                    char c = hDoc.charAt(curr - 1);
-                    if (!(Character.isLetterOrDigit(c) || c == '_' || c == '.')) {
-                        break;
-                    }
-                }
-                char ch = text.charAt(0);
-                if (isAutoCompeted && cursorPosition - curr > 0 && Character.isLetterOrDigit(ch)) {
-                    //是否开启代码提示
-                    // log("subSequence:"+hDoc.subSequence(curr, caretPosition - curr));
-                    // if (isAutoCompeted) {
-					// Log.i("AutoCompete", text+" "+cursorPosition+" "+curr);
-                    mAutoCompletePanel.update(hDoc.subSequence(curr, cursorPosition - curr));
-                    // }
-                } else {
-                    mAutoCompletePanel.dismiss();
-                }
-				//Log.e("Lsp", "row: "+mCaretRow+", col: "+getColumn(cursorPosition));
-            }
-        };
-
         mRowListener = new OnRowChangedListener() {
             @Override
             public void onRowChanged(int newRowIndex) {
@@ -514,7 +462,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
             }
         };
 
-        mSelModeListener = new OnSelectionChangedListener() {
+        selLis = new OnSelectionChangedListener() {
             @Override
             public void onSelectionChanged(boolean active, int selStart, int selEnd) {
                 // TODO: Implement this method
@@ -533,26 +481,60 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
         invalidate();
     }
 
+	public void onNewLine(String s, int caretPosition, int pos) {
+		// TODO: Implement this method
+		isTextChanged = true;
+		mCaretSpan.first += 1;
+		mAutoCompletePanel.dismiss();
+	}
+
+	public void onDel(CharSequence text, int cursorPosition, int delCount) {
+		isTextChanged = true;
+		if (delCount <= mCaretSpan.first)
+			mCaretSpan.first -= 1;
+		mAutoCompletePanel.dismiss();
+	}
+
+	public void onAdd(CharSequence text, int cursorPosition, int addCount) {
+		isTextChanged = true;
+		mCaretSpan.first += addCount;
+		if (text.length() == 0) return;
+		//找到空格或者其他
+		int curr = cursorPosition;
+		for (; curr > 0; curr--) {
+			char c = hDoc.charAt(curr - 1);
+			if (!(Character.isLetterOrDigit(c) || c == '_' || c == '.'))
+				break;
+		}
+		mAutoCompletePanel._off = cursorPosition - curr;
+		/*
+		char ch = text.charAt(0);
+		if (isAutoCompeted && cursorPosition - curr > 0 && Character.isLetterOrDigit(ch))
+			//是否开启代码提示
+			// log("subSequence:"+hDoc.subSequence(curr, caretPosition - curr));
+			// if (isAutoCompeted) {
+			// Log.i("AutoCompete", text+" "+cursorPosition+" "+curr);
+			mAutoCompletePanel.update(hDoc.subSequence(curr, cursorPosition - curr));
+			// }
+		else
+			mAutoCompletePanel.dismiss();*/
+	}
+
     private void resetView() {
         mCaretPosition = mCaretRow = 0;
         xExtent = mLineMaxWidth = 0;
-        mFieldController.setSelectText(false);
-        mFieldController.stopTextComposing();
+        mCtrlr.setSelectText(false);
+        mCtrlr.stopTextComposing();
         ((InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE)).restartInput(this);
         hDoc.clearSpans();
-        if (getContentWidth() > 0 || !hDoc.isWordWrap()) {
+        if (getContentWidth() > 0 || !hDoc.isWordWrap())
             hDoc.analyzeWordWrap();
-        }
         mRowListener.onRowChanged(0);
         scrollTo(0, 0);
     }
 
     public void setSuggestion(boolean enable) {
-        if (enable) {
-            mTypeInput = InputType.TYPE_CLASS_TEXT;
-        } else {
-            mTypeInput = InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS;
-        }
+        mTypeInput = enable ? InputType.TYPE_CLASS_TEXT : InputType.TYPE_TEXT_FLAG_NO_SUGGESTIONS;
     }
 
     /**
@@ -562,16 +544,15 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
     public void setDocument(Document doc) {
         hDoc = doc;
         resetView();
-        mFieldController.cancelSpanning(); //stop existing lex threads
-        mFieldController.determineSpans();
-       // invalidate();
+        mCtrlr.cancelSpanning(); //stop existing lex threads
+        mCtrlr.determineSpans();
     }
 
     /**
      * Returns a DocumentProvider that references the same Document used by the
      * FreeScrollingTextField.
      */
-    public Document createDocument() {
+    public Document getText() {
         return hDoc;
     }
 
@@ -580,7 +561,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
     }
 
     public void setOnSelectionChangedListener(OnSelectionChangedListener sLis) {
-        mSelModeListener = sLis;
+        selLis = sLis;
     }
 
     /**
@@ -614,16 +595,15 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
     public InputConnection onCreateInputConnection(EditorInfo outAttrs) {
         outAttrs.inputType = mTypeInput | InputType.TYPE_TEXT_FLAG_MULTI_LINE;
         outAttrs.imeOptions = EditorInfo.IME_FLAG_NO_ENTER_ACTION | EditorInfo.IME_ACTION_DONE
-                | EditorInfo.IME_FLAG_NO_EXTRACT_UI;
+			| EditorInfo.IME_FLAG_NO_EXTRACT_UI;
         if (isUseGboard) {
             outAttrs.initialSelStart = getCaretPosition();
             outAttrs.initialSelEnd = getCaretPosition();
         }
-        if (mInputConnection == null) {
+        if (mInputConnection == null)
             mInputConnection = new TextFieldInputConnection(this);
-        } else {
+        else
             mInputConnection.resetComposingState();
-        }
         return mInputConnection;
     }
 
@@ -643,11 +623,11 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
             getWindowVisibleDisplayFrame(rect);
             mTopOffset = rect.top + rect.height() - getHeight();
             if (!isLayout)
-                respan();
+                mCtrlr.determineSpans();
             isLayout = right > 0;
 			invalidate();
-            mAutoCompletePanel.setWidth(getWidth() / 2);
-            mAutoCompletePanel.setHeight(getHeight() / 2);
+           // mAutoCompletePanel.setWidth(getWidth() / 2);
+            //mAutoCompletePanel.setHeight(getHeight() / 2);
         }
         super.onLayout(changed, left, top, right, bottom);
     }
@@ -657,7 +637,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
         super.onSizeChanged(w, h, oldw, oldh);
         if (hDoc.isWordWrap() && oldw != w)
             hDoc.analyzeWordWrap();
-        mFieldController.updateCaretRow();
+        mCtrlr.updateCaretRow();
         if (h < oldh)
             makeCharVisible(mCaretPosition);
     }
@@ -736,9 +716,9 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
         canvas.save();
         //translate clipping region to create padding around edges
         canvas.clipRect(getScrollX() + getPaddingLeft(),
-                getScrollY() + getPaddingTop(),
-                getScrollX() + getWidth() - getPaddingRight(),
-                getScrollY() + getHeight() - getPaddingBottom());
+						getScrollY() + getPaddingTop(),
+						getScrollX() + getWidth() - getPaddingRight(),
+						getScrollY() + getHeight() - getPaddingBottom());
         canvas.translate(getPaddingLeft(), getPaddingTop());
         realDraw(canvas);
 
@@ -746,23 +726,17 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
         mNavMethod.onTextDrawComplete(canvas);
     }
 
-	public static boolean jj = false;
+	//public static boolean jj = false;
 
     private void realDraw(Canvas canvas) {
         int currRowNum = getBeginPaintRow(canvas);
         int currIndex = hDoc.getRowOffset(currRowNum);
 
-        if (currIndex < 0) {
+        if (currIndex < 0)
             return;
-        }
         int currLineNum = 1 + (isWordWrap() ? hDoc.findLineNumber(currIndex) : currRowNum);
         int lastLineNum = 0;
-        if (isShowLineNumbers) {
-            mLeftOffset = (int) mLineNumPaint.measureText(" "+hDoc.getRowCount());
-        } else {
-            mLeftOffset = 0;
-        }
-        int endRowNum = getEndPaintRow(canvas);
+        mLeftOffset = isShowLineNumbers ? (int) mTextPaint.measureText(" "+hDoc.getRowCount()) : 0;
 
         int paintX = 0;
         int paintY = getPaintBaseline(currRowNum);
@@ -777,23 +751,20 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
 		int spanIndex = 0, r = spanSize-1, m;
 
 		while (spanIndex < r) {
-			m = (spanIndex+r+1)>>1;
+			m = (spanIndex+r+1) >> 1;
 			if (spans.get(m).first <= currIndex)
 				spanIndex = m;
 			else
 				r = m-1;
 		}
 		Pair currSpan = spans.get(spanIndex++);
-		Pair nextSpan = spanIndex < spans.size() ? spans.get(spanIndex++) : null;
+		Pair nextSpan = spanIndex < spanSize ? spans.get(spanIndex++) : null;
 
 		int currType = currSpan.second;
         int lastType = currType;
 
-        if (currSpan.second==Lexer.KEYWORD)
-			mTextPaint.setTypeface(boldTypeface);
-		else
-			mTextPaint.setTypeface(defTypeface);
-	
+        mTextPaint.setTypeface(currSpan.second==Lexer.KEYWORD ? boldTypeface : defTypeface);
+
         int spanColor = mColorScheme.getTokenColor(currSpan.second);
         mTextPaint.setColor(spanColor);
 
@@ -801,31 +772,49 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
         // start painting!
         //----------------------------------------------
 
-        int rowCount = hDoc.getRowCount();
-        if (isShowLineNumbers) {
-            mLineNumPaint.setColor(mColorScheme.getColor(Colorable.NON_PRINTING_GLYPH));
-            int left = mLeftOffset - mSpaceWidth / 2;
-            canvas.drawLine(left, getScrollY(), left, getScrollY() + getHeight(), mLineNumPaint);
-        }
-		int mWidth = getMeasuredWidth()+getScrollX();
+		boolean showLN = isShowLineNumbers && mLeftOffset >= getScrollX();
+		int endRowNum = Math.min(hDoc.getRowCount(), getEndPaintRow(canvas));
+		int mWidth = canvas.getClipBounds().right;
 		int mL = hDoc.getTextLength();
+		int rowheight = rowHeight();
+
+		int idx, dgl;
+		List<ErrSpan> dg = hDoc.getDiag();
+		ErrSpan p;
+		if (dg==null || dg.isEmpty()) {
+			p = null;
+			dgl = 0;
+			idx = 1;
+		} else {
+			dgl = dg.size();
+			r = 0;
+			idx = dgl - 1;
+			while (r < idx) {
+				m = (idx+r)>>1;
+				if (dg.get(m).stl >= currLineNum)
+					idx = m;
+				else
+					r = m+1;
+			}
+			p = dg.get(idx++);
+		}
 
-        while (currRowNum <= endRowNum && currIndex<mL) {
+		// 逐行
+        while (currRowNum <= endRowNum && currIndex < mL) {
 
-            if (currRowNum > rowCount) {
-                break;
-            }
             int rowLen = hDoc.getRowSize(currRowNum);
 
-			if (isShowLineNumbers && currLineNum != lastLineNum) {
+			if (showLN && currLineNum != lastLineNum) {
                 String num = String.valueOf(currLineNum);
-				int padx = (int) (mLeftOffset - mLineNumPaint.measureText(num) - mSpaceWidth);
+				int padx = (int) (mLeftOffset - mTextPaint.measureText(num) - mSpaceWidth);
 				lastLineNum = currLineNum;
                 drawLineNum(canvas, num, padx, paintY);
             }
             paintX = mLeftOffset;
-			int i;
-            for (i = 0; i < rowLen; i++) {
+			m = -1;
+
+			// 逐字
+            for (int i = 0; i < rowLen; i++) {
                 // check if formatting changes are needed
                 if (reachedNextSpan(currIndex, nextSpan)) {
                     currSpan = nextSpan;
@@ -836,54 +825,60 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
                     spanColor = mColorScheme.getTokenColor(currSpan.second);
                     mTextPaint.setColor(spanColor);
 					if (lastType != currType) {
-                        Typeface currTypeface;
-                        if (currType==Lexer.KEYWORD)
-                            currTypeface = boldTypeface;
-						else
-                            currTypeface = defTypeface;
+                        Typeface currTypeface = currType==Lexer.KEYWORD ? boldTypeface : defTypeface;
 
-                        if (mTextPaint.getTypeface() != currTypeface) {
+                        if (mTextPaint.getTypeface() != currTypeface)
                             mTextPaint.setTypeface(currTypeface);
-                        }
 
                         spanColor = mColorScheme.getTokenColor(currType);
                         mTextPaint.setColor(spanColor);
                     }
-                    if (spanIndex < spans.size()) {
-                        nextSpan = spans.get(spanIndex++);
-                    } else {
-                        nextSpan = null;
-                    }
+					nextSpan = spanIndex<spanSize ? spans.get(spanIndex++) : null;
                 }
 
 				if (paintX < mWidth) {
 					int x = paintX;
 					char c = hDoc.charAt(currIndex);
-					if (mFieldController.inSelectionRange(currIndex)) {
+					if (mCtrlr.inSelectionRange(currIndex))
 						paintX += drawSelectedText(canvas, c, paintX, paintY);
-					} else {
+					else {
 						r = getAdvance(c, paintX);
 						drawChar(canvas, c, paintX, paintY);
 						paintX += r;
 					}
-					if (currIndex == mCaretPosition && isCursorVisiable) {
+					if (currIndex == mCaretPosition && isCursorVisiable)
                         //draw cursor
 						drawCaret(canvas, x, paintY);
-					} else if (currIndex + 1 == mCaretPosition) {
+					else if (currIndex + 1 == mCaretPosition)
 						mCaretSpan = currSpan;
+					// draw err line
+					if (idx <= dgl && p.stl == currLineNum) {
+						if (m < 0 && p.stc == i)
+								m = x;
+						// 假设 p.stl==p.enl
+						if (m >= 0 && (p.enc == i+1 || i+1 == rowLen || paintX >= mWidth)) {
+							mLineBrush.setColor(ColorScheme.DIAG[p.severity]);
+							canvas.drawLine(m, paintY, paintX, paintY, mLineBrush);
+							m = -1;
+							if (idx<dgl)
+								p = dg.get(idx++);
+						}
 					}
 				}
                 ++currIndex;
             }
-            if (hDoc.charAt(currIndex - 1) == Language.NEWLINE)
+
+            if (hDoc.charAt(currIndex - 1) == Language.NEWLINE) {
                 ++currLineNum;
+				while (idx < dgl && p.stl < currLineNum)
+					p = dg.get(idx++);
+			}
 
-            paintY += rowHeight();
+            paintY += rowheight;
 
-            if (paintX > xExtent) {
+            if (paintX > xExtent)
                 // record widest line seen so far
                 xExtent = paintX;
-            }
             if (paintX > mLineMaxWidth)
                 mLineMaxWidth = paintX;
 
@@ -891,10 +886,13 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
 
         }
         // end while
-
-        if (!mFieldController.isSelectText()) {
-            doOptionHighlightRow(canvas);
+		if (showLN) {
+			int left = mLeftOffset - mSpaceWidth / 2;
+            mTextPaint.setColor(mColorScheme.getColor(Colorable.NON_PRINTING_GLYPH));
+            canvas.drawLine(left, getScrollY(), left, getScrollY() + getHeight(), mTextPaint);
         }
+
+        doOptionHighlightRow(canvas);
         //drawScrollBars(canvas);
     }
 
@@ -903,7 +901,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
      * 高亮当前行
      */
     private void doOptionHighlightRow(Canvas canvas) {
-        if (isHighlightRow) {
+        if (isHighlightRow && !mCtrlr.isSelectText()) {
             int y = getPaintBaseline(mCaretRow);
             int originalColor = mTextPaint.getColor();
             mTextPaint.setColor(mColorScheme.getColor(Colorable.LINE_HIGHLIGHT));
@@ -919,7 +917,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
     //draw smiles, tab, whitespace
     private void drawChar(Canvas canvas, char c, int paintX, int paintY) {
 
-        int originalColor = mTextPaint.getColor();
+        //int originalColor = mTextPaint.getColor();
 
         if (paintX > getScrollX() || paintX < (getScrollX() + getContentWidth()))
             switch (c) {
@@ -929,28 +927,22 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
                     break;
                 case ' ':
                     if (isShowNonPrinting) {
-                        mTextPaint.setColor(mColorScheme.getColor(Colorable.NON_PRINTING_GLYPH));
-                        canvas.drawText(Language.GLYPH_SPACE, 0, 1, paintX, paintY, mTextPaint);
-                        mTextPaint.setColor(originalColor);
-                    } else {
-                        canvas.drawText(" ", 0, 1, paintX, paintY, mTextPaint);
+                        mLineBrush.setColor(mColorScheme.getColor(Colorable.NON_PRINTING_GLYPH));
+                        canvas.drawText(Language.GLYPH_SPACE, 0, 1, paintX, paintY, mLineBrush);
                     }
                     break;
-
                 case Language.EOF: //fall-through
                 case Language.NEWLINE:
                     if (isShowNonPrinting) {
-                        mTextPaint.setColor(mColorScheme.getColor(Colorable.NON_PRINTING_GLYPH));
-                        canvas.drawText(Language.GLYPH_NEWLINE, 0, 1, paintX, paintY, mTextPaint);
-                        mTextPaint.setColor(originalColor);
+                        mLineBrush.setColor(mColorScheme.getColor(Colorable.NON_PRINTING_GLYPH));
+                        canvas.drawText(Language.GLYPH_NEWLINE, 0, 1, paintX, paintY, mLineBrush);
                     }
                     break;
 
                 case Language.TAB:
                     if (isShowNonPrinting) {
-                        mTextPaint.setColor(mColorScheme.getColor(Colorable.NON_PRINTING_GLYPH));
-                        canvas.drawText(Language.GLYPH_TAB, 0, 1, paintX, paintY, mTextPaint);
-                        mTextPaint.setColor(originalColor);
+                        mLineBrush.setColor(mColorScheme.getColor(Colorable.NON_PRINTING_GLYPH));
+                        canvas.drawText(Language.GLYPH_TAB, 0, 1, paintX, paintY, mLineBrush);
                     }
                     break;
 
@@ -958,10 +950,8 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
                     if (mCharEmoji != 0) {
                         canvas.drawText(new char[]{mCharEmoji, c}, 0, 2, paintX, paintY, mTextPaint);
                         mCharEmoji = 0;
-                    } else {
-                        char[] ca = {c};
-                        canvas.drawText(ca, 0, 1, paintX, paintY, mTextPaint);
-                    }
+                    } else
+                        canvas.drawText(new char[]{c}, 0, 1, paintX, paintY, mTextPaint);
                     break;
             }
 
@@ -972,10 +962,10 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
     private void drawTextBackground(Canvas canvas, int paintX, int paintY, int advance) {
         Paint.FontMetricsInt metrics = mTextPaint.getFontMetricsInt();
         canvas.drawRect(paintX,
-                paintY + metrics.ascent,
-                paintX + advance,
-                paintY + metrics.descent,
-                mTextPaint);
+						paintY + metrics.ascent,
+						paintX + advance,
+						paintY + metrics.descent,
+						mTextPaint);
     }
 
     private int drawSelectedText(Canvas canvas, char c, int paintX, int paintY) {
@@ -1007,99 +997,83 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
     }
 
     // 绘制行号
-    private int drawLineNum(Canvas canvas, String s, int paintX, int paintY) {
-        int originalColor = mTextPaint.getColor();
-        mTextPaint.setColor(mColorScheme.getColor(Colorable.NON_PRINTING_GLYPH));
-        canvas.drawText(s, paintX, paintY, mLineNumPaint);
-        mTextPaint.setColor(originalColor);
-        return 0;
+    private void drawLineNum(Canvas canvas, String s, int paintX, int paintY) {
+        mLineBrush.setColor(mColorScheme.getColor(Colorable.NON_PRINTING_GLYPH));
+        canvas.drawText(s, paintX, paintY, mLineBrush);
     }
 
-    /*draw line number Background
-    private void drawLineBackground(Canvas canvas, int paintX, int advance) {
-        int hght = getScrollY() + getHeight();
-        mLineNumBgPaint.setColor(mColorScheme.getColor(Colorable.CARET_FOREGROUND));
-        // mLineNumPaint.setShadowLayer(2.0f, 1.0f, 0, mColorScheme.getColor(Colorable.LINENUMBER_FG));
-        canvas.drawRect(paintX,
-                0,
-                paintX + advance,
-                hght,
-                mLineNumBgPaint);
-        //mLineNumPaint.setShadowLayer(0, 0, 0, 0);
-    }*/
-
     /**
      * Draw scroll bars and tracks
      *
      * @param canvas The canvas to draw
      *
-    private void drawScrollBars(Canvas canvas) {
-        // if(!mEventHandler.shouldDrawScrollBar()){
-        //    return;
-        // }
-//        mVerticalScrollBar.setEmpty();
-        /*if (getMaxScrollY() > getHeight() / 2) {
-            //  drawScrollBarTrackVertical(canvas,10);
-        }*
-        if (getMaxScrollY() > getHeight() / 2) {
-              //drawScrollBarVertical(canvas,10);
-        }
-    }
-
-    /**
+	 private void drawScrollBars(Canvas canvas) {
+	 // if(!mEventHandler.shouldDrawScrollBar()){
+	 //    return;
+	 // }
+	 //        mVerticalScrollBar.setEmpty();
+	 /*if (getMaxScrollY() > getHeight() / 2) {
+	 //  drawScrollBarTrackVertical(canvas,10);
+	 }*
+	 if (getMaxScrollY() > getHeight() / 2) {
+	 //drawScrollBarVertical(canvas,10);
+	 }
+	 }
+
+	 /**
      * Draw vertical scroll bar track
      *
      * @param canvas Canvas to draw
      * @param width  The size of scroll bar,dp unit
      *
-    private void drawScrollBarTrackVertical(Canvas canvas, int width) {
-        //  if(mEventHandler.holdVerticalScrollBar()) {
-        float mDpUnit = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 2, Resources.getSystem().getDisplayMetrics()) / 2;
-
-        mRect.right = getWidth();
-        mRect.left = getWidth() - mDpUnit * width;
-        mRect.top = 0;
-        mRect.bottom = getScrollY() + getHeight();//длина скролбара
-        drawColor(canvas, mColorScheme.getColor(Colorable.COMMENT), mRect);
-        // }
-    }
-
-    /**
+	 private void drawScrollBarTrackVertical(Canvas canvas, int width) {
+	 //  if(mEventHandler.holdVerticalScrollBar()) {
+	 float mDpUnit = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 2, Resources.getSystem().getDisplayMetrics()) / 2;
+
+	 mRect.right = getWidth();
+	 mRect.left = getWidth() - mDpUnit * width;
+	 mRect.top = 0;
+	 mRect.bottom = getScrollY() + getHeight();//длина скролбара
+	 drawColor(canvas, mColorScheme.getColor(Colorable.COMMENT), mRect);
+	 // }
+	 }
+
+	 /**
      * Draw vertical scroll bar
      *
      * @param canvas Canvas to draw
      * @param width  The size of scroll bar,dp unit
      *
-    private void drawScrollBarVertical(Canvas canvas, int width) {
-        int page = getHeight();
-        float mDpUnit = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 2, Resources.getSystem().getDisplayMetrics()) / 2;
-        float all = getContentHeight() + getHeight() / 2;
-        float length = page / all * getHeight();
-        float topY;
-        int a = getScrollY() + getHeight();
-        if (length < mDpUnit * 30) {
-            length = mDpUnit * 30;
-            topY = (a + page / 2f) / all * (getHeight() - length);
-        } else {
-            topY = a / all * getHeight();
-        }
-
-        mRect.right = getWidth();
-        mRect.left = getWidth() - mDpUnit * width;
-        mRect.top = topY;
-        mRect.bottom = topY + length;
-        mVerticalScrollBar.set(mRect);
-        drawColor(canvas, mColorScheme.getColor(Colorable.LINE_HIGHLIGHT), mRect);
-    }
-
-    private void drawColor(Canvas canvas, int color, RectF rect) {
-        if (color != 0) {
-            int originalColor = mTextPaint.getColor();
-            mTextPaint.setColor(color);
-            canvas.drawRect(rect, mTextPaint);
-            mTextPaint.setColor(originalColor);
-        }
-    }*/
+	 private void drawScrollBarVertical(Canvas canvas, int width) {
+	 int page = getHeight();
+	 float mDpUnit = TypedValue.applyDimension(TypedValue.COMPLEX_UNIT_DIP, 2, Resources.getSystem().getDisplayMetrics()) / 2;
+	 float all = getContentHeight() + getHeight() / 2;
+	 float length = page / all * getHeight();
+	 float topY;
+	 int a = getScrollY() + getHeight();
+	 if (length < mDpUnit * 30) {
+	 length = mDpUnit * 30;
+	 topY = (a + page / 2f) / all * (getHeight() - length);
+	 } else {
+	 topY = a / all * getHeight();
+	 }
+
+	 mRect.right = getWidth();
+	 mRect.left = getWidth() - mDpUnit * width;
+	 mRect.top = topY;
+	 mRect.bottom = topY + length;
+	 mVerticalScrollBar.set(mRect);
+	 drawColor(canvas, mColorScheme.getColor(Colorable.LINE_HIGHLIGHT), mRect);
+	 }
+
+	 private void drawColor(Canvas canvas, int color, RectF rect) {
+	 if (color != 0) {
+	 int originalColor = mTextPaint.getColor();
+	 mTextPaint.setColor(color);
+	 canvas.drawRect(rect, mTextPaint);
+	 mTextPaint.setColor(originalColor);
+	 }
+	 }*/
 
     @Override
     final public int getRowWidth() {
@@ -1112,8 +1086,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
      * @return Length of single line
      */
     public int getLineLength() {
-        int lineLength = Math.max(getWidth(), mLineMaxWidth + mLeftOffset);
-        return lineLength;
+        return Math.max(getWidth(), mLineMaxWidth + mLeftOffset);
     }
 
     /**
@@ -1151,9 +1124,8 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
                 if (mCharEmoji != 0) {
                     char[] ca = {mCharEmoji, c};
                     advance = (int) mTextPaint.measureText(ca, 0, 2);
-                } else {
+                } else
                     advance = getCharAdvance(c);
-                }
                 break;
         }
 
@@ -1174,52 +1146,45 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
     }
 
     protected int getSpaceAdvance() {
-        if (isShowNonPrinting) {
-            return (int) mTextPaint.measureText(Language.GLYPH_SPACE,
-                    0, Language.GLYPH_SPACE.length());
-        } else {
-            return mSpaceWidth;
-        }
+        return isShowNonPrinting
+            ? (int) mTextPaint.measureText(Language.GLYPH_SPACE,
+												0, Language.GLYPH_SPACE.length())
+            :mSpaceWidth;
     }
 
     protected int getEOLAdvance() {
         if (isShowNonPrinting) {
             return (int) mTextPaint.measureText(Language.GLYPH_NEWLINE,
-                    0, Language.GLYPH_NEWLINE.length());
+												0, Language.GLYPH_NEWLINE.length());
         } else {
             return (int) (EMPTY_CARET_WIDTH_SCALE * mTextPaint.measureText(" ", 0, 1));
         }
     }
 
     protected int getTabAdvance() {
-        if (isShowNonPrinting) {
-            return mTabLength * (int) mTextPaint.measureText(Language.GLYPH_SPACE,
-                    0, Language.GLYPH_SPACE.length());
-        } else {
-            return mTabLength * mSpaceWidth;
-        }
+        return mTabLength * /* (isShowNonPrinting
+            ? (int) mTextPaint.measureText(Language.GLYPH_SPACE,
+											0, Language.GLYPH_SPACE.length())
+            :*/ mSpaceWidth;
     }
 
     protected int getTabAdvance(int x) {
-        if (isShowNonPrinting) {
+        /*if (isShowNonPrinting)
             return mTabLength * (int) mTextPaint.measureText(Language.GLYPH_SPACE,
-                    0, Language.GLYPH_SPACE.length());
-        } else {
-            int i = (x - mLeftOffset) / mSpaceWidth % mTabLength;
-            return (mTabLength - i) * mSpaceWidth;
-        }
+															 0, Language.GLYPH_SPACE.length());
+        else {*/
+        int i = (x - mLeftOffset) / mSpaceWidth % mTabLength;
+        return (mTabLength - i) * mSpaceWidth;
     }
 
     /**
      * Invalidate rows from startRow (inclusive) to endRow (exclusive)
      */
     void invalidateRows(int startRow, int endRow) {
-		if (mFieldController.lexing)
+		if (mCtrlr.lexing)
 			return;
-		//for (StackTraceElement s:Thread.currentThread().getStackTrace())
-		//	Log.d("DRAW", s.getClassName()+": "+s.getMethodName());
 		TextWarriorException.assertVerbose(startRow <= endRow && startRow >= 0,
-                "Invalid startRow and/or endRow");
+										   "Invalid startRow and/or endRow");
         Rect caretSpill = mNavMethod.getCaretBloat();
         //TODO The ascent of (startRow+1) may jut inside startRow, so part of
         // that rows have to be invalidated as well.
@@ -1230,9 +1195,9 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
         top = Math.max(0, top);
 
         super.invalidate(0,
-                top,
-                getScrollX() + getWidth(),
-                endRow * rowHeight() + getPaddingTop() + caretSpill.bottom);
+						 top,
+						 getScrollX() + getWidth(),
+						 endRow * rowHeight() + getPaddingTop() + caretSpill.bottom);
     }
 
     /**
@@ -1240,7 +1205,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
      */
     void invalidateFromRow(int startRow) {
         TextWarriorException.assertVerbose(startRow >= 0,
-                "Invalid startRow");
+										   "Invalid startRow");
 
         Rect caretSpill = mNavMethod.getCaretBloat();
         //TODO The ascent of (startRow+1) may jut inside startRow, so part of
@@ -1252,9 +1217,9 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
         top = Math.max(0, top);
 
         super.invalidate(0,
-                top,
-                getScrollX() + getWidth(),
-                getScrollY() + getHeight());
+						 top,
+						 getScrollX() + getWidth(),
+						 getScrollY() + getHeight());
     }
 
     void invalidateCaretRow() {
@@ -1282,9 +1247,9 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
         int scrollVerticalBy = makeCharRowVisible(charOffset);
         int scrollHorizontalBy = makeCharColumnVisible(charOffset);
 
-        if (scrollVerticalBy == 0 && scrollHorizontalBy == 0) {
+        if (scrollVerticalBy == 0 && scrollHorizontalBy == 0)
             return false;
-        } else {
+        else {
             scrollBy(scrollHorizontalBy, scrollVerticalBy);
             return true;
         }
@@ -1305,19 +1270,16 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
 
         if (isCaretScrolled) {
             // 拖动水滴滚动在距离SCROLL_EDGE_SLOP的时候就开始滚动
-            if (charTop < getScrollY()) {
+            if (charTop < getScrollY())
                 scrollBy = charTop - getScrollY();
-            } else if (charBottom + SCROLL_EDGE_SLOP > (getScrollY() + getContentHeight())) {
+            else if (charBottom + SCROLL_EDGE_SLOP > (getScrollY() + getContentHeight()))
                 scrollBy = charBottom + SCROLL_EDGE_SLOP - getScrollY() - getContentHeight();
-            }
-        } else {
+        } else
             // 默认情况在水滴移动到屏幕上下边缘时才开始滚动
-            if (charTop < getScrollY()) {
+            if (charTop < getScrollY())
                 scrollBy = charTop - getScrollY();
-            } else if (charBottom > (getScrollY() + getContentHeight())) {
+            else if (charBottom > (getScrollY() + getContentHeight()))
                 scrollBy = charBottom - getScrollY() - getContentHeight();
-            }
-        }
 
         return scrollBy;
     }
@@ -1339,22 +1301,19 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
 
         if (isCaretScrolled) {
             // 拖动水滴滚动在距离SCROLL_EDGE_SLOP / 3的时候就开始滚动
-            if (charRight + SCROLL_EDGE_SLOP / 3 >= (getScrollX() + getContentWidth())) {
+            if (charRight + SCROLL_EDGE_SLOP / 3 >= (getScrollX() + getContentWidth()))
                 scrollBy = charRight + SCROLL_EDGE_SLOP / 3 - getScrollX() - getContentWidth();
-
-            } else if (charLeft - SCROLL_EDGE_SLOP / 3 <= getScrollX() + mAlphaWidth) {
+			else if (charLeft - SCROLL_EDGE_SLOP / 3 <= getScrollX() + mAlphaWidth) {
                 scrollBy = charLeft - SCROLL_EDGE_SLOP / 3 - getScrollX() - mAlphaWidth;
                 if (charLeft <= mLeftOffset)
                     scrollBy = 0;
             }
-        } else {
+        } else
             // 默认情况在水滴移动到屏幕左右边缘时才开始滚动
-            if (charRight > (getScrollX() + getContentWidth())) {
+            if (charRight > (getScrollX() + getContentWidth()))
                 scrollBy = charRight - getScrollX() - getContentWidth();
-            } else if (charLeft < getScrollX() + mAlphaWidth) {
+            else if (charLeft < getScrollX() + mAlphaWidth)
                 scrollBy = charLeft - getScrollX() - mAlphaWidth;
-            }
-        }
 
         return scrollBy;
     }
@@ -1417,9 +1376,8 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
      * or Rect(-1, -1, -1, -1) if there is no character at that coordinate.
      */
     Rect getBoundingBox(int charOffset) {
-        if (charOffset < 0 || charOffset >= hDoc.getTextLength()) {
+        if (charOffset < 0 || charOffset >= hDoc.getTextLength())
             return new Rect(-1, -1, -1, -1);
-        }
 
         int row = hDoc.findRowNumber(charOffset);
         int top = row * rowHeight();
@@ -1460,14 +1418,12 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
             return hDoc.getTextLength() - 1;
 
         int charIndex = hDoc.getRowOffset(row);
-        if (charIndex < 0) {
+        if (charIndex < 0)
             //non-existent row
             return -1;
-        }
 
-        if (x < 0) {
+        if (x < 0)
             return charIndex; // coordinate is outside, to the left of view
-        }
 
         String rowText = hDoc.getRow(row);
 
@@ -1504,17 +1460,15 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
 
             }
 
-            if (extent >= x) {
+            if (extent >= x)
                 break;
-            }
 
             ++i;
         }
 
 
-        if (i < rowText.length()) {
+        if (i < rowText.length())
             return charIndex + i;
-        }
         //nearest char is last char of line
         return charIndex + i - 1;
     }
@@ -1681,7 +1635,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
 
     void flingScroll(int velocityX, int velocityY) {
         mScroller.fling(getScrollX(), getScrollY(), velocityX, velocityY,
-                0, getMaxScrollX(), 0, getMaxScrollY());
+						0, getMaxScrollX(), 0, getMaxScrollY());
         // Keep on drawing until the animation has finished.
         postInvalidate();
         //postInvalidateOnAnimation();
@@ -1721,7 +1675,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
             case SCROLL_LEFT:
                 removeCallbacks(mScrollCaretLeftTask);
                 if (mCaretPosition > 0 &&
-                        mCaretRow == hDoc.findRowNumber(mCaretPosition - 1)) {
+					mCaretRow == hDoc.findRowNumber(mCaretPosition - 1)) {
                     post(mScrollCaretLeftTask);
                     scrolled = true;
                 }
@@ -1729,7 +1683,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
             case SCROLL_RIGHT:
                 removeCallbacks(mScrollCaretRightTask);
                 if (!caretOnEOF() &&
-                        mCaretRow == hDoc.findRowNumber(mCaretPosition + 1)) {
+					mCaretRow == hDoc.findRowNumber(mCaretPosition + 1)) {
                     post(mScrollCaretRightTask);
                     scrolled = true;
                 }
@@ -1791,7 +1745,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
      * @param i The character index that the caret should be set to
      */
     public void moveCaret(int i) {
-        mFieldController.moveCaret(i);
+        mCtrlr.moveCaret(i);
     }
 
     /**
@@ -1801,7 +1755,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
      * If the caret is already on the first character, nothing will happen.
      */
     public void moveCaretLeft() {
-        mFieldController.moveCaretLeft(false);
+        mCtrlr.moveCaretLeft(false);
     }
 
     /**
@@ -1811,7 +1765,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
      * If the caret is already on the last character, nothing will happen.
      */
     public void moveCaretRight() {
-        mFieldController.moveCaretRight(false);
+        mCtrlr.moveCaretRight(false);
     }
 
     /**
@@ -1821,7 +1775,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
      * If the caret is already on the last row, nothing will happen.
      */
     public void moveCaretDown() {
-        mFieldController.moveCaretDown();
+        mCtrlr.moveCaretDown();
     }
 
 
@@ -1835,7 +1789,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
      * If the caret is already on the first row, nothing will happen.
      */
     public void moveCaretUp() {
-        mFieldController.moveCaretUp();
+        mCtrlr.moveCaretUp();
     }
 
     /**
@@ -1851,7 +1805,7 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
     protected int getColumn(int charOffset) {
         int row = hDoc.findRowNumber(charOffset);
         TextWarriorException.assertVerbose(row >= 0,
-                "Invalid char offset given to getColumn");
+										   "Invalid char offset given to getColumn");
         int firstCharOfRow = hDoc.getRowOffset(row);
         return mCaretCol = charOffset - firstCharOfRow;
     }
@@ -1869,11 +1823,11 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
     }
 
     public final boolean isSelectText() {
-        return mFieldController.isSelectText();
+        return mCtrlr.isSelectText();
     }
 
     public final boolean isSelectText2() {
-        return mFieldController.isSelectText2();
+        return mCtrlr.isSelectText2();
     }
 
     /**
@@ -1883,51 +1837,49 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
      * @param mode If true, enter select mode; else exit select mode
      */
     public void selectText(boolean mode) {
-        if (mFieldController.isSelectText() && !mode) {
+        if (mCtrlr.isSelectText() && !mode) {
             invalidateSelectionRows();
-            mFieldController.setSelectText(false);
-        } else if (!mFieldController.isSelectText() && mode) {
+            mCtrlr.setSelectText(false);
+        } else if (!mCtrlr.isSelectText() && mode) {
             invalidateCaretRow();
-            mFieldController.setSelectText(true);
+            mCtrlr.setSelectText(true);
         }
     }
 
     public void selectAll() {
-        mFieldController.setSelectionRange(0, hDoc.getTextLength() - 1, false, true);
+        mCtrlr.setSelectionRange(0, hDoc.getTextLength() - 1, false, true);
     }
 
     public void setSelection(int beginPosition, int numChars) {
-        mFieldController.setSelectionRange(beginPosition, numChars, true, false);
+        mCtrlr.setSelectionRange(beginPosition, numChars, true, false);
     }
 
     public void setSelectionRange(int beginPosition, int numChars) {
-        mFieldController.setSelectionRange(beginPosition, numChars, true, true);
+        mCtrlr.setSelectionRange(beginPosition, numChars, true, true);
     }
 
     public boolean inSelectionRange(int charOffset) {
-        return mFieldController.inSelectionRange(charOffset);
+        return mCtrlr.inSelectionRange(charOffset);
     }
 
     public int getSelectionStart() {
         if (mSelectionAnchor < 0)
             return mCaretPosition;
-        else
-            return mSelectionAnchor;
+        return mSelectionAnchor;
     }
 
     public int getSelectionEnd() {
         if (mSelectionEdge < 0)
             return mCaretPosition;
-        else
-            return mSelectionEdge;
+        return mSelectionEdge;
     }
 
     public void focusSelectionStart() {
-        mFieldController.focusSelection(true);
+        mCtrlr.focusSelection(true);
     }
 
     public void focusSelectionEnd() {
-        mFieldController.focusSelection(false);
+        mCtrlr.focusSelection(false);
     }
 
     //---------------------------------------------------------------------
@@ -1935,47 +1887,45 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
 
     public void cut() {
         if (mSelectionAnchor != mSelectionEdge)
-            mFieldController.cut(mClipboardManager);
+            mCtrlr.cut(mClipboardManager);
     }
 
     public void copy() {
         if (mSelectionAnchor != mSelectionEdge)
-            mFieldController.copy(mClipboardManager);
+            mCtrlr.copy(mClipboardManager);
         selectText(false);
     }
 
     public void paste() {
         CharSequence text = mClipboardManager.getText();
         if (text != null)
-            mFieldController.paste(text.toString());
+            mCtrlr.paste(text.toString());
     }
 
     public void cut(ClipboardManager cb) {
-        mFieldController.cut(cb);
+        mCtrlr.cut(cb);
     }
 
     public void copy(ClipboardManager cb) {
-        mFieldController.copy(cb);
+        mCtrlr.copy(cb);
     }
 
     public void paste(String text) {
-        mFieldController.paste(text);
+        mCtrlr.paste(text);
     }
 
     public void delete() {
-        mFieldController.selectionDelete();
+        mCtrlr.selectionDelete();
+		mCtrlr.determineSpans();
+		//tc
     }
 
     private boolean reachedNextSpan(int charIndex, Pair span) {
         return span != null && (charIndex == span.first);
     }
 
-    public void respan() {
-        mFieldController.determineSpans();
-    }
-
     public void cancelSpanning() {
-        mFieldController.cancelSpanning();
+        mCtrlr.cancelSpanning();
     }
 
     /**
@@ -1985,20 +1935,19 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
     public void setTypeface(Typeface typeface) {
         defTypeface = typeface;
         boldTypeface = Typeface.create(typeface, Typeface.BOLD);
-        italicTypeface = Typeface.create(typeface, Typeface.ITALIC);
+        //italicTypeface = Typeface.create(typeface, Typeface.ITALIC);
         mTextPaint.setTypeface(typeface);
-        mLineNumPaint.setTypeface(typeface);
+        mLineBrush.setTypeface(typeface);
         if (hDoc.isWordWrap())
             hDoc.analyzeWordWrap();
-        mFieldController.updateCaretRow();
-        if (!makeCharVisible(mCaretPosition)) {
+        mCtrlr.updateCaretRow();
+        if (!makeCharVisible(mCaretPosition))
             invalidate();
-        }
     }
 
-    public void setItalicTypeface(Typeface typeface) {
+    /*public void setItalicTypeface(Typeface typeface) {
         italicTypeface = typeface;
-    }
+    }*/
 
     public void setBoldTypeface(Typeface typeface) {
         boldTypeface = typeface;
@@ -2014,10 +1963,9 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
             xExtent = 0;
             scrollTo(0, 0);
         }
-        mFieldController.updateCaretRow();
-        if (!makeCharVisible(mCaretPosition)) {
+        mCtrlr.updateCaretRow();
+        if (!makeCharVisible(mCaretPosition))
             invalidate();
-        }
     }
 
     public float getZoom() {
@@ -2029,16 +1977,15 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
      * to display the caret if needed, and invalidates the entire view
      */
     public void setZoom(float factor) {
-        if (factor <= 0.5 || factor >= 5 || factor == mZoomFactor) {
+        if (factor <= 0.5 || factor >= 5 || factor == mZoomFactor)
             return;
-        }
         mZoomFactor = factor;
-        int newSize = (int) (factor * BASE_TEXT_SIZE_PIXELS);
+        float newSize = factor * BASE_TEXT_SIZE_PIXELS;
         mTextPaint.setTextSize(newSize);
-        mLineNumPaint.setTextSize(newSize);
+        mLineBrush.setTextSize(newSize);
         if (hDoc.isWordWrap())
             hDoc.analyzeWordWrap();
-        mFieldController.updateCaretRow();
+        mCtrlr.updateCaretRow();
         mAlphaWidth = (int) mTextPaint.measureText("a");
         //if(!makeCharVisible(mCaretPosition)){
         invalidate();
@@ -2052,16 +1999,14 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
      * @param spaceCount The number of spaces a tab represents
      */
     public void setTabSpaces(int spaceCount) {
-        if (spaceCount < 0) {
+        if (spaceCount < 0)
             return;
-        }
         mTabLength = spaceCount;
         if (hDoc.isWordWrap())
             hDoc.analyzeWordWrap();
-        mFieldController.updateCaretRow();
-        if (!makeCharVisible(mCaretPosition)) {
+        mCtrlr.updateCaretRow();
+        if (!makeCharVisible(mCaretPosition))
             invalidate();
-        }
     }
 
     /**
@@ -2104,10 +2049,9 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
             isShowNonPrinting = enable;
             if (hDoc.isWordWrap())
                 hDoc.analyzeWordWrap();
-            mFieldController.updateCaretRow();
-            if (!makeCharVisible(mCaretPosition)) {
+            mCtrlr.updateCaretRow();
+            if (!makeCharVisible(mCaretPosition))
                 invalidate();
-            }
         }
     }
 
@@ -2122,14 +2066,14 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
         //but is put here for end-user's convenience. Unfortunately this may
         //cause some IMEs to break. Remove this feature in future.
         if (isLongPressCaps
-                && event.getRepeatCount() == 1
-                && event.getAction() == KeyEvent.ACTION_DOWN) {
+			&& event.getRepeatCount() == 1
+			&& event.getAction() == KeyEvent.ACTION_DOWN) {
 
             char c = KeysInterpreter.keyEventToPrintableChar(event);
             if (Character.isLowerCase(c)
-                    && c == Character.toLowerCase(hDoc.charAt(mCaretPosition - 1))) {
-                mFieldController.onPrintableChar(Language.BACKSPACE);
-                mFieldController.onPrintableChar(Character.toUpperCase(c));
+				&& c == Character.toLowerCase(hDoc.charAt(mCaretPosition - 1))) {
+                mCtrlr.onPrintableChar(Language.BACKSPACE);
+                mCtrlr.onPrintableChar(Character.toUpperCase(c));
                 return true;
             }
         }
@@ -2140,40 +2084,36 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
     @Override
     public boolean onKeyDown(int keyCode, KeyEvent event) {
         // Let touch navigation method intercept key event first
-        if (mNavMethod.onKeyDown(keyCode, event)) {
+        if (mNavMethod.onKeyDown(keyCode, event))
             return true;
-        }
 
         //check if direction or symbol key
         if (KeysInterpreter.isNavigationKey(event)) {
             handleNavigationKey(keyCode, event);
             return true;
         } else if (keyCode == KeyEvent.KEYCODE_SYM ||
-                keyCode == KeyCharacterMap.PICKER_DIALOG_INPUT) {
+				   keyCode == KeyCharacterMap.PICKER_DIALOG_INPUT) {
             showCharacterPicker(
-                    PICKER_SETS.get(KeyCharacterMap.PICKER_DIALOG_INPUT), false);
+				PICKER_SETS.get(KeyCharacterMap.PICKER_DIALOG_INPUT), false);
             return true;
         }
 
         //check if character is printable
         char c = KeysInterpreter.keyEventToPrintableChar(event);
-        if (c == Language.NULL_CHAR) {
+        if (c == Language.NULL_CHAR)
             return super.onKeyDown(keyCode, event);
-        }
 
         int repeatCount = event.getRepeatCount();
         //handle multiple (held) key presses
         if (repeatCount == 1) {
-            if (isLongPressCaps) {
+            if (isLongPressCaps)
                 handleLongPressCaps(c);
-            } else {
+            else
                 handleLongPressDialogDisplay(c);
-            }
         } else if (repeatCount == 0
-                || isLongPressCaps && !Character.isLowerCase(c)
-                || !isLongPressCaps && PICKER_SETS.get(c) == null) {
-            mFieldController.onPrintableChar(c);
-        }
+				   || isLongPressCaps && !Character.isLowerCase(c)
+				   || !isLongPressCaps && PICKER_SETS.get(c) == null)
+            mCtrlr.onPrintableChar(c);
 
         return true;
     }
@@ -2181,27 +2121,27 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
     private void handleNavigationKey(int keyCode, KeyEvent event) {
         if (event.isShiftPressed() && !isSelectText()) {
             invalidateCaretRow();
-            mFieldController.setSelectText(true);
+            mCtrlr.setSelectText(true);
         } else if (!event.isShiftPressed() && isSelectText()) {
             invalidateSelectionRows();
-            mFieldController.setSelectText(false);
+            mCtrlr.setSelectText(false);
         }
         switch (keyCode) {
             case KeyEvent.KEYCODE_DPAD_RIGHT:
-                mFieldController.moveCaretRight(false);
+                mCtrlr.moveCaretRight(false);
                 break;
             case KeyEvent.KEYCODE_DPAD_LEFT:
-                mFieldController.moveCaretLeft(false);
+                mCtrlr.moveCaretLeft(false);
                 break;
             case KeyEvent.KEYCODE_DPAD_DOWN:
-                mFieldController.moveCaretDown();
+                mCtrlr.moveCaretDown();
                 break;
             case KeyEvent.KEYCODE_DPAD_UP:
-                mFieldController.moveCaretUp();
+                mCtrlr.moveCaretUp();
                 break;
             case KeyEvent.KEYCODE_ENTER:
                 if (mAutoCompletePanel.isShow())
-                    mAutoCompletePanel.selectFirst();
+                    mAutoCompletePanel.select(0);
                 break;
             default:
                 break;
@@ -2210,12 +2150,11 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
 
     private void handleLongPressCaps(char c) {
         if (Character.isLowerCase(c)
-                && c == hDoc.charAt(mCaretPosition - 1)) {
-            mFieldController.onPrintableChar(Language.BACKSPACE);
-            mFieldController.onPrintableChar(Character.toUpperCase(c));
-        } else {
-            mFieldController.onPrintableChar(c);
-        }
+			&& c == hDoc.charAt(mCaretPosition - 1)) {
+            mCtrlr.onPrintableChar(Language.BACKSPACE);
+            mCtrlr.onPrintableChar(Character.toUpperCase(c));
+        } else
+            mCtrlr.onPrintableChar(c);
     }
 
     //Precondition: If c is alphabetical, the character before the caret is
@@ -2227,11 +2166,10 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
 
         String candidates = PICKER_SETS.get(base);
         if (candidates != null) {
-            mFieldController.stopTextComposing();
+            mCtrlr.stopTextComposing();
             showCharacterPicker(candidates, true);
-        } else {
-            mFieldController.onPrintableChar(c);
-        }
+        } else
+            mCtrlr.onPrintableChar(c);
     }
 
     /**
@@ -2246,28 +2184,25 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
         Selection.setSelection(dummyString, 0);
 
         CharacterPickerDialog dialog = new CharacterPickerDialog(getContext(),
-                this, dummyString, candidates, true);
+																 this, dummyString, candidates, true);
 
         dialog.setOnDismissListener(new OnDismissListener() {
-            @Override
-            public void onDismiss(DialogInterface dialog) {
-                if (dummyString.length() > 0) {
-                    if (shouldReplace) {
-                        mFieldController.onPrintableChar(Language.BACKSPACE);
-                    }
-                    mFieldController.onPrintableChar(dummyString.charAt(0));
-                }
-            }
-        });
+				@Override
+				public void onDismiss(DialogInterface dialog) {
+					if (dummyString.length() > 0) {
+						if (shouldReplace)
+							mCtrlr.onPrintableChar(Language.BACKSPACE);
+						mCtrlr.onPrintableChar(dummyString.charAt(0));
+					}
+				}
+			});
         dialog.show();
     }
 
     @Override
     public boolean onKeyUp(int keyCode, KeyEvent event) {
-        if (mNavMethod.onKeyUp(keyCode, event)) {
+        if (mNavMethod.onKeyUp(keyCode, event))
             return true;
-        }
-
         return super.onKeyUp(keyCode, event);
     }
 
@@ -2276,43 +2211,32 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
         // TODO Test on real device
         int deltaX = Math.round(event.getX());
         int deltaY = Math.round(event.getY());
-        while (deltaX > 0) {
-            mFieldController.moveCaretRight(false);
-            --deltaX;
-        }
-        while (deltaX < 0) {
-            mFieldController.moveCaretLeft(false);
-            ++deltaX;
-        }
-        while (deltaY > 0) {
-            mFieldController.moveCaretDown();
-            --deltaY;
-        }
-        while (deltaY < 0) {
-            mFieldController.moveCaretUp();
-            ++deltaY;
-        }
+        while (deltaX-- > 0)
+            mCtrlr.moveCaretRight(false);
+        while (deltaX++ < 0)
+            mCtrlr.moveCaretLeft(false);
+        while (deltaY-- > 0)
+            mCtrlr.moveCaretDown();
+        while (deltaY++ < 0)
+            mCtrlr.moveCaretUp();
         return true;
     }
 
     @Override
     public boolean onTouchEvent(MotionEvent event) {
-        if (isFocused()) {
+        if (isFocused())
             mNavMethod.onTouchEvent(event);
-        } else {
-            if ((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_UP
-                    && isPointInView((int) event.getX(), (int) event.getY())) {
-                // somehow, the framework does not automatically change the focus
-                // to this view when it is touched
-                requestFocus();
-            }
-        }
+        else if ((event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_UP
+				&& isPointInView((int) event.getX(), (int) event.getY()))
+            // somehow, the framework does not automatically change the focus
+            // to this view when it is touched
+            requestFocus();
         return true;
     }
 
     final private boolean isPointInView(int x, int y) {
         return (x >= 0 && x < getWidth() &&
-                y >= 0 && y < getHeight());
+			y >= 0 && y < getHeight());
     }
 
     @Override
@@ -2326,11 +2250,10 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
      */
     public void showIME(boolean show) {
         InputMethodManager im = (InputMethodManager) mContext.getSystemService(Context.INPUT_METHOD_SERVICE);
-        if (show) {
+        if (show)
             im.showSoftInput(this, 0);
-        } else {
+        else
             im.hideSoftInputFromWindow(this.getWindowToken(), 0);
-        }
     }
 
     /**
@@ -2347,7 +2270,6 @@ public abstract class FreeScrollingTextField extends View implements Document.Te
     }
 
     void onDestroy() {
-        mFieldController.cancelSpanning();
+        mCtrlr.cancelSpanning();
     }
-
 }
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/view/KeysInterpreter.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/KeysInterpreter.java
similarity index 96%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/view/KeysInterpreter.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/view/KeysInterpreter.java
index 294e3b2..b037810 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/view/KeysInterpreter.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/KeysInterpreter.java
@@ -6,11 +6,11 @@
  *
  * This software is provided "as is". Use at your own risk.
  */
-package com.mrikso.codeeditor.view;
+package cn.rbc.codeeditor.view;
 
 import android.view.KeyEvent;
 
-import com.mrikso.codeeditor.lang.Language;
+import cn.rbc.codeeditor.lang.Language;
 
 public class KeysInterpreter {
     public static boolean isSwitchPanel(KeyEvent event) {
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/view/TextFieldController.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/TextFieldController.java
new file mode 100644
index 0000000..6184748
--- /dev/null
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/TextFieldController.java
@@ -0,0 +1,748 @@
+package cn.rbc.codeeditor.view;
+
+import android.content.Context;
+import android.text.ClipboardManager;
+import android.view.inputmethod.InputMethodManager;
+
+import cn.rbc.codeeditor.lang.Language;
+import cn.rbc.codeeditor.util.Lexer;
+import cn.rbc.codeeditor.util.Pair;
+import cn.rbc.codeeditor.util.TextWarriorException;
+
+import java.util.List;
+
+import static cn.rbc.codeeditor.util.DLog.log;
+import android.util.*;
+import cn.rbc.codeeditor.util.*;
+
+//*********************************************************************
+//************************ Controller logic ***************************
+//*********************************************************************
+public class TextFieldController implements Lexer.LexCallback {
+    private final Lexer _lexer = new Lexer(this);
+    public boolean _isInSelectionMode = false;
+    private boolean _isInSelectionMode2;
+	public boolean lexing;
+    private FreeScrollingTextField field;
+
+    public TextFieldController(FreeScrollingTextField textField) {
+        field = textField;
+		lexing = false;
+    }
+
+    /**
+     * Analyze the text for programming language keywords and redraws the
+     * text view when done. The global programming language used is set with
+     * the static method Lexer.setLanguage(Language)
+     * <p>
+     * Does nothing if the Lexer language is not a programming language
+     */
+    public void determineSpans() {
+		lexing = true;
+		//Log.i("CodeEditor", field.hDoc.);
+		_lexer.tokenize(field.hDoc);
+    }
+
+    public void cancelSpanning() {
+		lexing = false;
+        _lexer.cancelTokenize();
+    }
+
+    @Override
+    //This is usually called from a non-UI thread
+    public void lexDone(final List<Pair> results) {
+        field.post(new Runnable() {
+				@Override
+				public void run() {
+					field.hDoc.setSpans(results);
+					lexing = false;
+					field.invalidate();
+				}
+			});
+    }
+
+    //- TextFieldController -----------------------------------------------
+    //---------------------------- Key presses ----------------------------
+
+    //TODO minimise invalidate calls from moveCaret(), insertion/deletion and word wrap
+    public void onPrintableChar(char c) {
+        // delete currently selected text, if any
+		lexing = true;
+        boolean selectionDeleted = false;
+        if (_isInSelectionMode) {
+            selectionDelete();
+            selectionDeleted = true;
+        }
+
+		int pos = field.mCaretPosition;
+		field.hDoc.setTyping(true);
+        switch (c) {
+            case Language.BACKSPACE:
+                if (selectionDeleted)
+                    break;
+                if (pos > 0) {
+					//pos--;
+					//char p;
+					int l = pos > 1 && ((c=field.hDoc.charAt(pos-2)) == 0xd83d || c == 0xd83c)? 2 : 1;
+					//String s = 
+                    field.hDoc.deleteAt(pos-l, l, System.nanoTime());
+                    /*if (pos>0 && field.hDoc.charAt(--pos) == 0xd83d || field.hDoc.charAt(pos) == 0xd83c) {
+                        field.hDoc.deleteAt(pos, System.nanoTime());
+                        moveCaretLeft(true);
+                    }*/
+
+                    field.onDel(String.valueOf(c), field.mCaretPosition, 1);
+                    moveCaretLeft(true);
+					if (l==2)
+						moveCaretLeft(true);
+                }
+                break;
+
+            case Language.NEWLINE:
+                if (field.isAutoIndent) {
+                    char[] indent = createAutoIndent();
+                    field.hDoc.insertBefore(indent, pos, System.nanoTime());
+                    moveCaret(field.mCaretPosition + indent.length);
+					break;
+                }
+            default:
+                field.hDoc.insertBefore(new char[]{c}, pos, System.nanoTime());
+                moveCaretRight(true);
+                field.onAdd(String.valueOf(c), pos, 1);
+                break;
+        }
+
+        field.setEdited(true);
+        determineSpans();
+		//tc
+    }
+
+    /**
+     * Return a char[] with a newline as the 0th element followed by the
+     * leading spaces and tabs of the line that the caret is on
+     * 创建自动缩进
+     */
+    private char[] createAutoIndent() {
+        int lineNum = field.hDoc.findLineNumber(field.mCaretPosition);
+        int startOfLine = field.hDoc.getLineOffset(lineNum);
+        int whitespaceCount = 0;
+        //查找上一行的空白符个数
+		int i, mL = field.hDoc.getTextLength();
+		char c;
+        for (i=startOfLine; i<mL;) {
+            c = field.hDoc.charAt(i++);
+            if ((c != ' ' && c != Language.TAB) || startOfLine + whitespaceCount >= field.mCaretPosition)
+                break;
+            if (c == Language.TAB)
+                whitespaceCount += field.getAutoIndentWidth();
+            else if (c == ' ')
+                ++whitespaceCount;
+        }
+        //寻找最后字符
+        int endChar = 0;
+        for (i=startOfLine;i<mL;) {
+            c = field.hDoc.charAt(i++);
+            if (c == Language.NEWLINE)
+                break;
+            endChar = c;
+        }
+        //最后字符为'{',缩进
+        if (endChar == '{')
+            whitespaceCount += field.getAutoIndentWidth();
+        if (whitespaceCount < 0)
+            return new char[]{Language.NEWLINE};
+
+        char[] indent = new char[1 + whitespaceCount];
+        indent[0] = Language.NEWLINE;
+
+        for (i = 0; i < whitespaceCount; ++i)
+            indent[1 + i] = ' ';
+        return indent;
+    }
+
+    public void moveCaretDown() {
+        if (!field.caretOnLastRowOfFile()) {
+            int currCaret = field.mCaretPosition;
+            int currRow = field.mCaretRow;
+            int newRow = currRow + 1;
+            int currColumn = field.getColumn(currCaret);
+            int currRowLength = field.hDoc.getRowSize(currRow);
+            int newRowLength = field.hDoc.getRowSize(newRow);
+
+            if (currColumn < newRowLength)
+                // Position at the same column as old row.
+                field.mCaretPosition += currRowLength;
+            else
+                // Column does not exist in the new row (new row is too short).
+                // Position at end of new row instead.
+                field.mCaretPosition +=
+					currRowLength - currColumn + newRowLength - 1;
+            ++field.mCaretRow;
+
+            updateSelectionRange(currCaret, field.mCaretPosition);
+            if (!field.makeCharVisible(field.mCaretPosition))
+                field.invalidateRows(currRow, newRow + 1);
+            // 拖动yoyo球滚动时，保证yoyo球的坐标与光标一致
+            field.crtLis.updateCaret(field.mCaretPosition);
+            field.mRowListener.onRowChanged(newRow);
+            stopTextComposing();
+        }
+    }
+
+    public void moveCaretUp() {
+        if (!field.caretOnFirstRowOfFile()) {
+            int currCaret = field.mCaretPosition;
+            int currRow = field.mCaretRow;
+            int newRow = currRow - 1;
+            int currColumn = field.getColumn(currCaret);
+            int newRowLength = field.hDoc.getRowSize(newRow);
+
+            if (currColumn < newRowLength)
+                // Position at the same column as old row.
+                field.mCaretPosition -= newRowLength;
+            else
+                // Column does not exist in the new row (new row is too short).
+                // Position at end of new row instead.
+                field.mCaretPosition -= (currColumn + 1);
+            --field.mCaretRow;
+
+            updateSelectionRange(currCaret, field.mCaretPosition);
+            if (!field.makeCharVisible(field.mCaretPosition))
+                field.invalidateRows(newRow, currRow + 1);
+            // 拖动yoyo球滚动时，保证yoyo球的坐标与光标一致
+            field.crtLis.updateCaret(field.mCaretPosition);
+            field.mRowListener.onRowChanged(newRow);
+            stopTextComposing();
+        }
+    }
+
+    /**
+     * @param isTyping Whether caret is moved to a consecutive position as
+     *                 a result of entering text
+     */
+    public void moveCaretRight(boolean isTyping) {
+        if (!field.caretOnEOF()) {
+            int originalRow = field.mCaretRow;
+            ++field.mCaretPosition;
+            updateCaretRow();
+            updateSelectionRange(field.mCaretPosition - 1, field.mCaretPosition);
+            if (!field.makeCharVisible(field.mCaretPosition))
+                field.invalidateRows(originalRow, field.mCaretRow + 1);
+
+            if (!isTyping)
+                stopTextComposing();
+            // 拖动yoyo球滚动时，保证yoyo球的坐标与光标一致
+            field.crtLis.updateCaret(field.mCaretPosition);
+        }
+    }
+
+    /**
+     * @param isTyping Whether caret is moved to a consecutive position as
+     *                 a result of deleting text
+     */
+    public void moveCaretLeft(boolean isTyping) {
+        if (field.mCaretPosition > 0) {
+            int originalRow = field.mCaretRow;
+            --field.mCaretPosition;
+            updateCaretRow();
+            updateSelectionRange(field.mCaretPosition + 1, field.mCaretPosition);
+            if (!field.makeCharVisible(field.mCaretPosition))
+                field.invalidateRows(field.mCaretRow, originalRow + 1);
+
+            if (!isTyping)
+                stopTextComposing();
+            // 拖动yoyo球滚动时，保证yoyo球的坐标与光标一致
+            field.crtLis.updateCaret(field.mCaretPosition);
+        }
+    }
+
+    public void moveCaret(int i) {
+        if (i < 0 || i >= field.hDoc.getTextLength()) {
+            TextWarriorException.fail("Invalid caret position");
+            return;
+        }
+        updateSelectionRange(field.mCaretPosition, i);
+
+        field.mCaretPosition = i;
+        updateAfterCaretJump();
+    }
+
+    private void updateAfterCaretJump() {
+        int oldRow = field.mCaretRow;
+        updateCaretRow();
+        if (!field.makeCharVisible(field.mCaretPosition)) {
+            field.invalidateRows(oldRow, oldRow + 1); //old caret row
+            field.invalidateCaretRow(); //new caret row
+        }
+        stopTextComposing();
+    }
+
+    /**
+     * This helper method should only be used by internal methods after setting
+     * mTextFiledl.mCaretPosition, in order to to recalculate the new row the caret is on.
+     */
+    void updateCaretRow() {
+        int newRow = field.hDoc.findRowNumber(field.mCaretPosition);
+        if (field.mCaretRow != newRow) {
+            field.mCaretRow = newRow;
+            field.mRowListener.onRowChanged(newRow);
+        }
+    }
+
+    public void stopTextComposing() {
+        InputMethodManager im = (InputMethodManager) field.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
+        // This is an overkill way to inform the InputMethod that the caret
+        // might have changed position and it should re-evaluate the
+        // caps mode to use.
+        im.restartInput(field);
+
+        if (field.mInputConnection != null && field.mInputConnection.isComposingStarted())
+            field.mInputConnection.resetComposingState();
+    }
+
+    //- TextFieldController -----------------------------------------------
+    //-------------------------- Selection mode ---------------------------
+    public final boolean isSelectText() {
+        return _isInSelectionMode;
+    }
+
+    /**
+     * Enter or exit select mode.
+     * Does not invalidate view.
+     *
+     * @param mode If true, enter select mode; else exit select mode
+     */
+    public void setSelectText(boolean mode) {
+        if (mode == _isInSelectionMode)
+            return;
+
+        if (mode) {
+            field.mSelectionAnchor = field.mCaretPosition;
+            field.mSelectionEdge = field.mCaretPosition;
+        } else {
+            field.mSelectionAnchor = -1;
+            field.mSelectionEdge = -1;
+        }
+        _isInSelectionMode = mode;
+        _isInSelectionMode2 = mode;
+        field.selLis.onSelectionChanged(mode, field.getSelectionStart(), field.getSelectionEnd());
+    }
+
+    public final boolean isSelectText2() {
+        return _isInSelectionMode2;
+    }
+
+    public boolean inSelectionRange(int charOffset) {
+        if (field.mSelectionAnchor < 0)
+            return false;
+        return (field.mSelectionAnchor <= charOffset && charOffset < field.mSelectionEdge);
+    }
+
+    /**
+     * Selects numChars count of characters starting from beginPosition.
+     * Invalidates necessary areas.
+     *
+     * @param beginPosition
+     * @param numChars
+     * @param scrollToStart If true, the start of the selection will be scrolled
+     *                      into view. Otherwise, the end of the selection will be scrolled.
+     */
+
+    public void setSelectionRange(int beginPosition, int numChars, boolean scrollToStart, boolean mode) {
+        TextWarriorException.assertVerbose(
+			(beginPosition >= 0) && numChars <= (field.hDoc.getTextLength() - 1) && numChars >= 0,
+			"Invalid range to select");
+
+        if (_isInSelectionMode)
+            // unhighlight previous selection
+            field.invalidateSelectionRows();
+        else {
+            // unhighlight caret
+            field.invalidateCaretRow();
+            if (mode)
+                setSelectText(true);
+            else
+                _isInSelectionMode = true;
+        }
+
+        field.mSelectionAnchor = beginPosition;
+        field.mSelectionEdge = field.mSelectionAnchor + numChars;
+
+        field.mCaretPosition = field.mSelectionEdge;
+        stopTextComposing();
+        updateCaretRow();
+        if (mode)
+            field.selLis.onSelectionChanged(isSelectText(), field.mSelectionAnchor, field.mSelectionEdge);
+        boolean scrolled = field.makeCharVisible(field.mSelectionEdge);
+
+        if (scrollToStart)
+            //TODO reduce unnecessary scrolling and write a method to scroll
+            // the beginning of multi-line selections as far left as possible
+            scrolled = field.makeCharVisible(field.mSelectionAnchor);
+
+        if (!scrolled)
+            field.invalidateSelectionRows();
+    }
+
+    /**
+     * Moves the caret to an edge of selected text and scrolls it to view.
+     *
+     * @param start If true, moves the caret to the beginning of
+     *              the selection. Otherwise, moves the caret to the end of the selection.
+     *              In all cases, the caret is scrolled to view if it is not visible.
+     */
+    public void focusSelection(boolean start) {
+        if (_isInSelectionMode) {
+            if (start && field.mCaretPosition != field.mSelectionAnchor) {
+                field.mCaretPosition = field.mSelectionAnchor;
+                updateAfterCaretJump();
+            } else if (!start && field.mCaretPosition != field.mSelectionEdge) {
+                field.mCaretPosition = field.mSelectionEdge;
+                updateAfterCaretJump();
+            }
+        }
+    }
+
+
+    /**
+     * Used by internal methods to update selection boundaries when a new
+     * caret position is set.
+     * Does nothing if not in selection mode.
+     */
+    private void updateSelectionRange(int oldCaretPosition, int newCaretPosition) {
+
+        if (!_isInSelectionMode)
+            return;
+
+        if (oldCaretPosition < field.mSelectionEdge) {
+            if (newCaretPosition > field.mSelectionEdge) {
+                field.mSelectionAnchor = field.mSelectionEdge;
+                field.mSelectionEdge = newCaretPosition;
+            } else
+                field.mSelectionAnchor = newCaretPosition;
+
+        } else if (newCaretPosition < field.mSelectionAnchor) {
+            field.mSelectionEdge = field.mSelectionAnchor;
+            field.mSelectionAnchor = newCaretPosition;
+        } else
+            field.mSelectionEdge = newCaretPosition;
+    }
+
+    //- TextFieldController -----------------------------------------------
+    //------------------------ Cut, copy, paste, delete ---------------------------
+
+    /**
+     * Convenience method for consecutive copy and paste calls
+     */
+    public void cut(ClipboardManager cb) {
+        copy(cb);
+        selectionDelete();
+		determineSpans();
+		//tc
+    }
+
+    /**
+     * Copies the selected text to the clipboard.
+     * <p>
+     * Does nothing if not in select mode.
+     */
+    public void copy(ClipboardManager cb) {
+        //TODO catch OutOfMemoryError
+        if (_isInSelectionMode &&
+			field.mSelectionAnchor < field.mSelectionEdge) {
+            CharSequence contents = field.hDoc.subSequence(field.mSelectionAnchor,
+															field.mSelectionEdge - field.mSelectionAnchor);
+            cb.setText(contents);
+        }
+    }
+
+    /**
+     * Inserts text at the caret position.
+     * Existing selected text will be deleted and select mode will end.
+     * The deleted area will be invalidated.
+     * <p>
+     * After insertion, the inserted area will be invalidated.
+     */
+    public void paste(String text) {
+        if (text == null)
+            return;
+
+		Document doc = field.hDoc;
+		doc.setTyping(true);
+        doc.beginBatchEdit();
+        selectionDelete();
+
+        doc.insertBefore(text.toCharArray(), field.mCaretPosition, System.nanoTime());
+        field.onAdd(text, field.mCaretPosition, text.length());
+        doc.endBatchEdit();
+
+        field.mCaretPosition += text.length();
+        updateCaretRow();
+
+        field.setEdited(true);
+        determineSpans();
+		//tc
+        stopTextComposing();
+    }
+
+    /**
+     * Deletes selected text, exits select mode and invalidates deleted area.
+     * If the selected range is empty, this method exits select mode and
+     * invalidates the caret.
+     * <p>
+     * Does nothing if not in select mode.
+     */
+    public void selectionDelete() {
+        if (!_isInSelectionMode)
+            return;
+
+        int totalChars = field.mSelectionEdge - field.mSelectionAnchor;
+
+        if (totalChars > 0) {
+            int originalRow = field.hDoc.findRowNumber(field.mSelectionAnchor);
+            int originalOffset = field.hDoc.getRowOffset(originalRow);
+            boolean isSingleRowSel = field.hDoc.findRowNumber(field.mSelectionEdge) == originalRow;
+            field.hDoc.deleteAt(field.mSelectionAnchor, totalChars, System.nanoTime());
+            field.onDel("", field.mCaretPosition, totalChars);
+            field.mCaretPosition = field.mSelectionAnchor;
+            updateCaretRow();
+            field.setEdited(true);
+            setSelectText(false);
+            stopTextComposing();
+
+            if (!field.makeCharVisible(field.mCaretPosition)) {
+                int invalidateStartRow = originalRow;
+                //invalidate previous row too if its wrapping changed
+                if (field.hDoc.isWordWrap() &&
+					originalOffset != field.hDoc.getRowOffset(originalRow)) {
+                    --invalidateStartRow;
+                }
+
+                if (isSingleRowSel && !field.hDoc.isWordWrap())
+                    //pasted text only affects current row
+                    field.invalidateRows(invalidateStartRow, invalidateStartRow + 1);
+                else
+                    //TODO invalidate damaged rows only
+                    field.invalidateFromRow(invalidateStartRow);
+            }
+        } else {
+            setSelectText(false);
+            field.invalidateCaretRow();
+        }
+    }
+
+    void replaceText(int from, int charCount, String text) {
+        int invalidateStartRow, originalOffset;
+        boolean isInvalidateSingleRow = true;
+        boolean dirty = false;
+        //delete selection
+        if (_isInSelectionMode) {
+            invalidateStartRow = field.hDoc.findRowNumber(field.mSelectionAnchor);
+            originalOffset = field.hDoc.getRowOffset(invalidateStartRow);
+
+            int totalChars = field.mSelectionEdge - field.mSelectionAnchor;
+
+            if (totalChars > 0) {
+                field.mCaretPosition = field.mSelectionAnchor;
+                field.hDoc.deleteAt(field.mSelectionAnchor, totalChars, System.nanoTime());
+
+                if (invalidateStartRow != field.mCaretRow)
+                    isInvalidateSingleRow = false;
+                dirty = true;
+            }
+
+            setSelectText(false);
+        } else {
+            invalidateStartRow = field.mCaretRow;
+            originalOffset = field.hDoc.getRowOffset(field.mCaretRow);
+        }
+
+        //delete requested chars
+        if (charCount > 0) {
+            int delFromRow = field.hDoc.findRowNumber(from);
+            if (delFromRow < invalidateStartRow) {
+                invalidateStartRow = delFromRow;
+                originalOffset = field.hDoc.getRowOffset(delFromRow);
+            }
+
+            if (invalidateStartRow != field.mCaretRow)
+                isInvalidateSingleRow = false;
+
+            field.mCaretPosition = from;
+            field.hDoc.deleteAt(from, charCount, System.nanoTime());
+            dirty = true;
+        }
+
+        //insert
+        if (text != null && text.length() > 0) {
+            int insFromRow = field.hDoc.findRowNumber(from);
+            if (insFromRow < invalidateStartRow) {
+                invalidateStartRow = insFromRow;
+                originalOffset = field.hDoc.getRowOffset(insFromRow);
+            }
+
+            field.hDoc.insertBefore(text.toCharArray(), field.mCaretPosition, System.nanoTime());
+            field.mCaretPosition += text.length();
+            dirty = true;
+        }
+
+        if (dirty) {
+            field.setEdited(true);
+            determineSpans();
+			//tc
+			return;
+        }
+
+        int originalRow = field.mCaretRow;
+        updateCaretRow();
+        if (originalRow != field.mCaretRow)
+            isInvalidateSingleRow = false;
+
+        if (!field.makeCharVisible(field.mCaretPosition)) {
+            //invalidate previous row too if its wrapping changed
+            if (field.hDoc.isWordWrap() &&
+				originalOffset != field.hDoc.getRowOffset(invalidateStartRow))
+                --invalidateStartRow;
+
+            if (isInvalidateSingleRow && !field.hDoc.isWordWrap())
+                //replaced text only affects current row
+                field.invalidateRows(field.mCaretRow, field.mCaretRow + 1);
+            else
+                //TODO invalidate damaged rows only
+                field.invalidateFromRow(invalidateStartRow);
+        }
+    }
+
+    //- TextFieldController -----------------------------------------------
+    //----------------- Helper methods for InputConnection ----------------
+
+    /**
+     * Deletes existing selected text, then deletes charCount number of
+     * characters starting at from, and inserts text in its place.
+     * <p>
+     * Unlike paste or selectionDelete, does not signal the end of
+     * text composing to the IME.
+     */
+    void replaceComposingText(int from, int charCount, String text) {
+        int invalidateStartRow, originalOffset;
+        boolean isInvalidateSingleRow = true;
+        boolean dirty = false;
+
+		Document doc = field.hDoc;
+		doc.setTyping(true);
+        //delete selection
+        if (_isInSelectionMode) {
+            invalidateStartRow = doc.findRowNumber(field.mSelectionAnchor);
+            originalOffset = doc.getRowOffset(invalidateStartRow);
+
+            int totalChars = field.mSelectionEdge - field.mSelectionAnchor;
+
+            if (totalChars > 0) {
+                field.mCaretPosition = field.mSelectionAnchor;
+                doc.deleteAt(field.mSelectionAnchor, totalChars, System.nanoTime());
+
+                if (invalidateStartRow != field.mCaretRow)
+                    isInvalidateSingleRow = false;
+                dirty = true;
+            }
+
+            setSelectText(false);
+        } else {
+            invalidateStartRow = field.mCaretRow;
+            originalOffset = doc.getRowOffset(field.mCaretRow);
+        }
+
+        //delete requested chars
+        if (charCount > 0) {
+            int delFromRow = doc.findRowNumber(from);
+            if (delFromRow < invalidateStartRow) {
+                invalidateStartRow = delFromRow;
+                originalOffset = doc.getRowOffset(delFromRow);
+            }
+
+            if (invalidateStartRow != field.mCaretRow)
+                isInvalidateSingleRow = false;
+
+            field.mCaretPosition = from;
+            doc.deleteAt(from, charCount, System.nanoTime());
+            dirty = true;
+        }
+
+        //insert
+        if (text != null && text.length() > 0) {
+            int insFromRow = doc.findRowNumber(from);
+            if (insFromRow < invalidateStartRow) {
+                invalidateStartRow = insFromRow;
+                originalOffset = doc.getRowOffset(insFromRow);
+            }
+
+            log("inserted text:" + text);
+            doc.insertBefore(text.toCharArray(), field.mCaretPosition, System.nanoTime());
+            field.mCaretPosition += text.length();
+            dirty = true;
+
+        }
+
+        field.onAdd(text, field.mCaretPosition, text.length() - charCount);
+        if (dirty) {
+            field.setEdited(true);
+            determineSpans();
+			//tc
+			return;
+        }
+
+        int originalRow = field.mCaretRow;
+        updateCaretRow();
+        if (originalRow != field.mCaretRow)
+            isInvalidateSingleRow = false;
+
+        if (!field.makeCharVisible(field.mCaretPosition)) {
+            //invalidate previous row too if its wrapping changed
+            if (doc.isWordWrap() &&
+				originalOffset != doc.getRowOffset(invalidateStartRow))
+                --invalidateStartRow;
+
+            if (isInvalidateSingleRow && !doc.isWordWrap())
+                //replaced text only affects current row
+                field.invalidateRows(field.mCaretRow, field.mCaretRow + 1);
+            else
+                //TODO invalidate damaged rows only
+                field.invalidateFromRow(invalidateStartRow);
+        }
+    }
+
+    /**
+     * Delete leftLength characters of text before the current caret
+     * position, and delete rightLength characters of text after the current
+     * cursor position.
+     * <p>
+     * Unlike paste or selectionDelete, does not signal the end of
+     * text composing to the IME.
+     */
+    void deleteAroundComposingText(int left, int right) {
+        int start = field.mCaretPosition - left;
+        if (start < 0)
+            start = 0;
+        int end = field.mCaretPosition + right;
+        int docLength = field.hDoc.getTextLength();
+        if (end > docLength - 1) //exclude the terminal EOF
+            end = docLength - 1;
+        replaceComposingText(start, end - start, "");
+    }
+
+    String getTextAfterCursor(int maxLen) {
+        int docLength = field.hDoc.getTextLength();
+        if ((field.mCaretPosition + maxLen) > (docLength - 1))
+            //exclude the terminal EOF
+            return field.hDoc.subSequence(field.mCaretPosition, docLength - field.mCaretPosition - 1).toString();
+
+        return field.hDoc.subSequence(field.mCaretPosition, maxLen).toString();
+    }
+
+    String getTextBeforeCursor(int maxLen) {
+        int start = field.mCaretPosition - maxLen;
+        if (start < 0)
+            start = 0;
+        return field.hDoc.subSequence(start, field.mCaretPosition - start).toString();
+    }
+}//end inner controller class
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/view/TextFieldInputConnection.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/TextFieldInputConnection.java
similarity index 78%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/view/TextFieldInputConnection.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/view/TextFieldInputConnection.java
index 3422d3d..f7065a3 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/view/TextFieldInputConnection.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/TextFieldInputConnection.java
@@ -1,14 +1,14 @@
-package com.mrikso.codeeditor.view;
+package cn.rbc.codeeditor.view;
 
 import android.text.InputType;
 import android.view.KeyEvent;
 import android.view.inputmethod.BaseInputConnection;
 
-import com.mrikso.codeeditor.lang.Language;
-import com.mrikso.codeeditor.util.DLog;
-import com.mrikso.codeeditor.util.Lexer;
+import cn.rbc.codeeditor.lang.Language;
+import cn.rbc.codeeditor.util.DLog;
+import cn.rbc.codeeditor.util.Lexer;
 
-import static com.mrikso.codeeditor.util.DLog.log;
+import static cn.rbc.codeeditor.util.DLog.log;
 
 //*********************************************************************
 //************************** InputConnection **************************
@@ -84,11 +84,10 @@ public class TextFieldInputConnection extends BaseInputConnection {
                 break;
             case KeyEvent.KEYCODE_ENTER:
             case KeyEvent.KEYCODE_NUMPAD_ENTER:
-                if (textField.mAutoCompletePanel.isShow()) {
-                    textField.mAutoCompletePanel.selectFirst();
-                } else {
+                if (textField.mAutoCompletePanel.isShow())
+                    textField.mAutoCompletePanel.select(0);
+                else
                     return super.sendKeyEvent(event);
-                }
                 break;
             default:
                 return super.sendKeyEvent(event);
@@ -114,26 +113,29 @@ public class TextFieldInputConnection extends BaseInputConnection {
     @Override
     public boolean setComposingText(CharSequence text, int newCursorPosition) {
         isComposing = true;
-        if(!textField.hDoc.isBatchEdit()) {
+        if(!textField.hDoc.isBatchEdit())
             textField.hDoc.beginBatchEdit();
-        }
-        if (textField.mFieldController._isInSelectionMode) {
-            textField.mFieldController.selectionDelete();
+		boolean sel = false;
+		TextFieldController tf = textField.mCtrlr;
+        if (tf._isInSelectionMode) {
+            tf.selectionDelete();
             composingCharCount = 0;
-        }
-        else {
-            textField.mFieldController.replaceComposingText(
+			sel = true;
+        } else {
+            tf.replaceComposingText(
                     textField.getCaretPosition() - composingCharCount,
                     composingCharCount,
                     text.toString());
             composingCharCount = text.length();
         }
         //TODO reduce invalidate calls
-        if(newCursorPosition > 1) {
-            textField.mFieldController.moveCaret(mCaretPosition + newCursorPosition - 1);
-        } else if(newCursorPosition <= 0) {
-            textField.mFieldController.moveCaret(mCaretPosition - text.length() - newCursorPosition);
-        }
+        if(newCursorPosition > 1)
+            tf.moveCaret(mCaretPosition + newCursorPosition - 1);
+        else if(newCursorPosition <= 0)
+            tf.moveCaret(mCaretPosition - text.length() - newCursorPosition);
+		if (sel)
+			tf.determineSpans();
+			//tc
         // log("setComposingText:"+text+","+newCursorPosition);
         return true;
     }
@@ -142,7 +144,7 @@ public class TextFieldInputConnection extends BaseInputConnection {
     public boolean commitText(CharSequence text, int newCursorPosition) {
         log("commitText:"+text+","+newCursorPosition+","+composingCharCount);
              /*
-            mFieldController.replaceComposingText(
+            mCtrlr.replaceComposingText(
                     getCaretPosition() - composingCharCount,
                     composingCharCount,
                     text.toString());
@@ -150,13 +152,13 @@ public class TextFieldInputConnection extends BaseInputConnection {
             hDoc.endBatchEdit();
             //TODO reduce invalidate calls
             if (newCursorPosition > 1) {
-                mFieldController.moveCaret(mCaretPosition + newCursorPosition - 1);
+                mCtrlr.moveCaret(mCaretPosition + newCursorPosition - 1);
             }
           else if(newCursorPosition==1){
-              mFieldController.moveCaret(mCaretPosition + newCursorPosition);
+              mCtrlr.moveCaret(mCaretPosition + newCursorPosition);
         }
          //   else if (newCursorPosition <= 0) {
-             //   mFieldController.moveCaret(mCaretPosition - text.length() - newCursorPosition);
+             //   mCtrlr.moveCaret(mCaretPosition - text.length() - newCursorPosition);
             //}
             isComposing = false;
             return true;
@@ -168,12 +170,11 @@ public class TextFieldInputConnection extends BaseInputConnection {
 
     @Override
     public boolean deleteSurroundingText(int leftLength, int rightLength) {
-        if (composingCharCount != 0) {
+        if (composingCharCount != 0)
             DLog.d("codeeditor","Warning: Implmentation of InputConnection.deleteSurroundingText" +
                     " will not skip composing text");
-        }
 
-        textField.mFieldController.deleteAroundComposingText(leftLength, rightLength);
+        textField.mCtrlr.deleteAroundComposingText(leftLength, rightLength);
         return true;
     }
 
@@ -197,9 +198,8 @@ public class TextFieldInputConnection extends BaseInputConnection {
 
                 //set CAP_SENTENCES if client is interested in it
                 if ((reqModes & InputType.TYPE_TEXT_FLAG_CAP_SENTENCES)
-                        == InputType.TYPE_TEXT_FLAG_CAP_SENTENCES) {
+                        == InputType.TYPE_TEXT_FLAG_CAP_SENTENCES)
                     capsMode |= InputType.TYPE_TEXT_FLAG_CAP_SENTENCES;
-                }
             }
         }
 
@@ -220,14 +220,12 @@ public class TextFieldInputConnection extends BaseInputConnection {
             // Examples: "abc.com" but "abc. Com"
             while (prevChar >= 0) {
                 char c = textField.hDoc.charAt(prevChar);
-                if (c == Language.NEWLINE) {
+                if (c == Language.NEWLINE)
                     break;
-                }
 
                 if (!lang.isWhitespace(c)) {
-                    if (whitespaceCount == 0 || !lang.isSentenceTerminator(c)) {
+                    if (whitespaceCount == 0 || !lang.isSentenceTerminator(c))
                         capsOn = false;
-                    }
                     break;
                 }
 
@@ -235,9 +233,8 @@ public class TextFieldInputConnection extends BaseInputConnection {
                 --prevChar;
             }
 
-            if (capsOn) {
+            if (capsOn)
                 capsMode |= InputType.TYPE_TEXT_FLAG_CAP_SENTENCES;
-            }
         }
 
         return capsMode;
@@ -245,12 +242,12 @@ public class TextFieldInputConnection extends BaseInputConnection {
 
     @Override
     public CharSequence getTextAfterCursor(int maxLen, int flags) {
-        return textField.mFieldController.getTextAfterCursor(maxLen); //ignore flags
+        return textField.mCtrlr.getTextAfterCursor(maxLen); //ignore flags
     }
 
     @Override
     public CharSequence getTextBeforeCursor(int maxLen, int flags) {
-        return textField.mFieldController.getTextBeforeCursor(maxLen); //ignore flags
+        return textField.mCtrlr.getTextBeforeCursor(maxLen); //ignore flags
     }
 
     @Override
@@ -264,19 +261,16 @@ public class TextFieldInputConnection extends BaseInputConnection {
     @Override
     public boolean setSelection(int start, int end) {
         log("setSelection:"+start+","+end);
-
+		TextFieldController fc = textField.mCtrlr;
         if (start == end) {
             if (start == 0) {
                 //适配搜狗输入法
-                if (textField.getCaretPosition() > 0) {
-                    textField.mFieldController.moveCaret(textField.getCaretPosition() - 1);
-                }
-            } else {
-                textField.mFieldController.moveCaret(start);
-            }
-        } else {
-            textField.mFieldController.setSelectionRange(start, end - start, false, true);
-        }
+                if (textField.getCaretPosition() > 0)
+                    fc.moveCaret(textField.getCaretPosition() - 1);
+            } else
+                fc.moveCaret(start);
+        } else
+            fc.setSelectionRange(start, end - start, false, true);
         return true;
     }
 }// end inner class
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/view/TouchNavigationMethod.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/TouchNavigationMethod.java
similarity index 87%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/view/TouchNavigationMethod.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/view/TouchNavigationMethod.java
index 378031c..dc86a42 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/view/TouchNavigationMethod.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/TouchNavigationMethod.java
@@ -1,4 +1,4 @@
-package com.mrikso.codeeditor.view;
+package cn.rbc.codeeditor.view;
 
 import android.graphics.Canvas;
 import android.graphics.Rect;
@@ -7,7 +7,10 @@ import android.view.HapticFeedbackConstants;
 import android.view.KeyEvent;
 import android.view.MotionEvent;
 import android.view.*;
-import com.mrikso.codeeditor.util.*;
+import cn.rbc.codeeditor.util.*;
+import java.util.*;
+import android.widget.*;
+import android.util.*;
 
 //TODO minimise unnecessary invalidate calls
 
@@ -52,7 +55,7 @@ public class TouchNavigationMethod extends GestureDetector.SimpleOnGestureListen
 
     @Override
     public boolean onDown(MotionEvent e) {
-       // mTextField.getParent().requestDisallowInterceptTouchEvent(e.getX() > 10);
+		// mTextField.getParent().requestDisallowInterceptTouchEvent(e.getX() > 10);
         int x = screenToViewX((int) e.getX());
         int y = screenToViewY((int) e.getY());
         isCaretTouched = isNearChar(x, y, mTextField.getCaretPosition());
@@ -92,8 +95,8 @@ public class TouchNavigationMethod extends GestureDetector.SimpleOnGestureListen
         if (mTextField.isSelectText()) {
             int strictCharOffset = mTextField.coordToCharIndexStrict(x, y);
             if (mTextField.inSelectionRange(strictCharOffset) ||
-                    isNearChar(x, y, mTextField.getSelectionStart()) ||
-                    isNearChar(x, y, mTextField.getSelectionEnd())) {
+				isNearChar(x, y, mTextField.getSelectionStart()) ||
+				isNearChar(x, y, mTextField.getSelectionEnd())) {
                 // do nothing
             } else {
                 mTextField.selectText(false);
@@ -181,8 +184,8 @@ public class TouchNavigationMethod extends GestureDetector.SimpleOnGestureListen
         if (!scrolled) {
             mTextField.stopAutoScrollCaret();
             int newCaretIndex = mTextField.coordToCharIndex(
-                    screenToViewX((int) e.getX()),
-                    screenToViewY((int) e.getY())
+				screenToViewX((int) e.getX()),
+				screenToViewY((int) e.getY())
             );
             if (newCaretIndex >= 0) {
                 mTextField.moveCaret(newCaretIndex);
@@ -247,7 +250,7 @@ public class TouchNavigationMethod extends GestureDetector.SimpleOnGestureListen
                     lastY = (e.getY(0) + e.getY(1)) * .5f;
                     lastSize = mTextField.getTextSize();
                 } else
-					mTextField.setTextSize((int)(lastSize*rt/lastDist), lastX, lastY);
+					mTextField.setTextSize((int)(lastSize * rt / lastDist), lastX, lastY);
                 return true;
             }
         }
@@ -262,7 +265,7 @@ public class TouchNavigationMethod extends GestureDetector.SimpleOnGestureListen
         onTouchZoom(event);
         boolean handled = mGestureDetector.onTouchEvent(event);
         if (!handled
-                && (event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_UP) {
+			&& (event.getAction() & MotionEvent.ACTION_MASK) == MotionEvent.ACTION_UP) {
             // propagate up events since GestureDetector does not do so
             handled = onUp(event);
         }
@@ -276,37 +279,53 @@ public class TouchNavigationMethod extends GestureDetector.SimpleOnGestureListen
 
     @Override
     public boolean onDoubleTap(MotionEvent e) {
-         isCaretTouched = true;
+		isCaretTouched = true;
         int x = screenToViewX((int) e.getX());
         int y = screenToViewY((int) e.getY());
         int charOffset = mTextField.coordToCharIndex(x, y);
 
         if (mTextField.isSelectText() && mTextField.inSelectionRange(charOffset)) {
-            Document doc = mTextField.createDocument();
+            Document doc = mTextField.getText();
             int line = doc.findLineNumber(charOffset);
             int start = doc.getLineOffset(line);
-            int end = doc.getLineOffset(line+1)-1;
+            int end = doc.getLineOffset(line + 1) - 1;
             mTextField.setSelectionRange(start, end - start);
         } else {
             if (charOffset >= 0) {
                 mTextField.moveCaret(charOffset);
-                Document doc = mTextField.createDocument();
-                int start;
-                int end;
-                for (start = charOffset; start >= 0; start--) {
-                    char c = doc.charAt(start);
-                    if (!Character.isJavaIdentifierPart(c))
+                Document doc = mTextField.getText();
+                int start, end;
+                for (start = charOffset; start >= 0; start--)
+                    if (!Character.isJavaIdentifierPart(doc.charAt(start)))
                         break;
-                }
                 if (start != charOffset)
                     start++;
-                for (end = charOffset; end >= 0; end++) {
-                    char c = doc.charAt(end);
-                    if (!Character.isJavaIdentifierPart(c))
-                        break;
-                }
+                for (end = charOffset; Character.isJavaIdentifierPart(doc.charAt(end)); end++);
                 mTextField.selectText(true);
                 mTextField.setSelectionRange(start, end - start);
+				// err msg
+				List<ErrSpan> dg = mTextField.hDoc.getDiag();
+				if (!(dg == null || dg.isEmpty())) {
+					y = dg.size() - 1;
+					int m, line = 1 + doc.findLineNumber(charOffset);
+					x = doc.getLineOffset(line - 1);
+					start -= x;
+					end -= x;
+					x = 0;
+					ErrSpan es;
+					while (x < y) {
+						m = (x + y) >> 1;
+						es = dg.get(m);
+						if (es.stl > line || (es.stl == line && es.enc >= start))
+							y = m;
+						else
+							x = m + 1;
+					}
+					es = dg.get(y);
+					if (es.stl == line && start <= es.enc && es.stc <= end && es.msg != null) {
+						HelperUtils.show(Toast.makeText(mTextField.getContext(), es.msg, Toast.LENGTH_SHORT));
+					}
+				}
             }
         }
         return true;
@@ -374,7 +393,7 @@ public class TouchNavigationMethod extends GestureDetector.SimpleOnGestureListen
 
     final protected int getPointerId(MotionEvent e) {
         return (e.getAction() & MotionEvent.ACTION_POINTER_ID_MASK)
-                >> MotionEvent.ACTION_POINTER_ID_SHIFT;
+			>> MotionEvent.ACTION_POINTER_ID_SHIFT;
     }
 
     /**
@@ -415,9 +434,9 @@ public class TouchNavigationMethod extends GestureDetector.SimpleOnGestureListen
         Rect bounds = mTextField.getBoundingBox(charOffset);
 
         return (y >= (bounds.top - TOUCH_SLOP)
-                && y < (bounds.bottom + TOUCH_SLOP)
-                && x >= (bounds.left - TOUCH_SLOP)
-                && x < (bounds.right + TOUCH_SLOP)
-        );
+			&& y < (bounds.bottom + TOUCH_SLOP)
+			&& x >= (bounds.left - TOUCH_SLOP)
+			&& x < (bounds.right + TOUCH_SLOP)
+			);
     }
 }
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/view/YoyoNavigationMethod.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/YoyoNavigationMethod.java
similarity index 99%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/view/YoyoNavigationMethod.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/view/YoyoNavigationMethod.java
index 105ae0d..f42fcba 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/view/YoyoNavigationMethod.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/YoyoNavigationMethod.java
@@ -1,4 +1,4 @@
-package com.mrikso.codeeditor.view;
+package cn.rbc.codeeditor.view;
 
 import android.content.Context;
 import android.graphics.Canvas;
@@ -9,8 +9,8 @@ import android.util.DisplayMetrics;
 import android.util.TypedValue;
 import android.view.MotionEvent;
 
-import com.mrikso.codeeditor.common.OnCaretScrollListener;
-import com.mrikso.codeeditor.util.Pair;
+import cn.rbc.codeeditor.common.OnCaretScrollListener;
+import cn.rbc.codeeditor.util.Pair;
 
 public class YoyoNavigationMethod extends TouchNavigationMethod implements OnCaretScrollListener {
 
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/view/autocomplete/AutoCompletePanel.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/AutoCompletePanel.java
similarity index 67%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/view/autocomplete/AutoCompletePanel.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/AutoCompletePanel.java
index bdedbf8..722ca62 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/view/autocomplete/AutoCompletePanel.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/AutoCompletePanel.java
@@ -1,4 +1,4 @@
-package com.mrikso.codeeditor.view.autocomplete;
+package cn.rbc.codeeditor.view.autocomplete;
 
 import android.content.Context;
 import android.content.res.TypedArray;
@@ -11,18 +11,24 @@ import android.widget.Filter;
 import android.widget.ListPopupWindow;
 import android.widget.TextView;
 
-import com.mrikso.codeeditor.R;
-import com.mrikso.codeeditor.lang.Language;
-import com.mrikso.codeeditor.lang.LanguageNonProg;
-import com.mrikso.codeeditor.view.FreeScrollingTextField;
+import cn.rbc.termuc.R;
+import cn.rbc.codeeditor.lang.Language;
+import cn.rbc.codeeditor.lang.LanguageNonProg;
+import cn.rbc.codeeditor.view.FreeScrollingTextField;
 import android.view.*;
 import android.widget.*;
+import java.util.*;
+import android.annotation.*;
+import android.graphics.*;
+import android.util.*;
+import cn.rbc.codeeditor.util.*;
 
 
 public class AutoCompletePanel {
 
     public static Language _globalLanguage = LanguageNonProg.getInstance();
-    public CharSequence _constraint;
+   // public CharSequence _constraint;
+    public int _off;
     private FreeScrollingTextField _textField;
     private Context _context;
     private ListPopupWindow _autoCompletePanel;
@@ -33,7 +39,7 @@ public class AutoCompletePanel {
     private int _horizontal;
     private int _backgroundColor;
     private GradientDrawable gd;
-    public int _textColor;
+    public int _textColor, _mxHeight;
     private boolean isShow = false;
 
     public AutoCompletePanel(FreeScrollingTextField textField) {
@@ -70,14 +76,15 @@ public class AutoCompletePanel {
     @SuppressWarnings("ResourceType")
     private void initAutoCompletePanel() {
         _autoCompletePanel = new ListPopupWindow(_context);
+		_autoCompletePanel.setInputMethodMode(PopupWindow.INPUT_METHOD_NEEDED);
         _autoCompletePanel.setAnchorView(_textField);
         _adapter = new AutoPanelAdapter(_context, this, _textField);
         _autoCompletePanel.setAdapter(_adapter);
 		_autoCompletePanel.setAnimationStyle(0);
         _filter = _adapter.getFilter();
         //_autoCompletePanel.setContentWidth(ListPopupWindow.WRAP_CONTENT);
-        setHeight(300);
-
+        _autoCompletePanel.setHeight(300);
+	  // _mxHeight = _adapter.getItemHeight() * 3;
         TypedArray array = _context.getTheme().obtainStyledAttributes(new int[]{
                 android.R.attr.colorBackground,
                 android.R.attr.textColorPrimary,
@@ -92,35 +99,43 @@ public class AutoCompletePanel {
         setTextColor(textColor);
         _autoCompletePanel.setBackgroundDrawable(gd);
         _autoCompletePanel.setOnItemClickListener(new OnItemClickListener() {
-            @Override
             public void onItemClick(AdapterView<?> p1, View p2, int p3, long p4) {
                 select(p3);
             }
         });
     }
 
-    public void selectFirst() {
-        select(0);
-    }
-
     public void select(int pos) {
-        View view = _adapter.getView(pos, null, null);
+		Deque<Edit> edits = _adapter.getItem(pos).edits;
+        /*View view = _adapter.getView(pos, null, null);
         TextView textView = view.findViewById(R.id.auto_panel_text);
         String text = textView.getText().toString();
-        String commitText = null;
-        boolean isFunc = text.contains("(");
-        if (isFunc) {
-            commitText = text.substring(0, text.indexOf('(')) + "()";
-        } else {
-            commitText = text;
-        }
-        _textField.replaceText(_textField.getCaretPosition() - _constraint.length(), _constraint.length(), commitText);
+        int it = text.indexOf('(');
+		if (it >= 0)
+			text = text.substring(0, it + 1);*/
+		Document doc = _textField.getText();
+		doc.beginBatchEdit();
+		doc.setTyping(false);
+		long tp = System.nanoTime();
+		Edit it = edits.pollFirst();
+		int mc = it.start + it.text.length();
+		doc.deleteAt(it.start, it.len, tp);
+		doc.insertBefore(it.text.toCharArray(), it.start, tp);
+		while (!edits.isEmpty()) {
+			it = edits.pop();
+			doc.deleteAt(it.start, it.len, tp);
+			doc.insertBefore(it.text.toCharArray(), it.start, tp);
+			if (it.start + it.len <= mc)
+				mc += it.text.length() - it.len;
+			else if (it.start < mc)
+				mc = it.start + it.text.length();
+		}
+		doc.endBatchEdit();
+		_textField.moveCaret(mc);
+		_textField.mCtrlr.determineSpans();
+        //_textField.replaceText(_textField.getCaretPosition() - _off, _off, text);
         _adapter.abort();
         dismiss();
-        if (isFunc) {
-            _textField.moveCaretLeft();
-        }
-
     }
 
     public void setWidth(int width) {
@@ -160,8 +175,24 @@ public class AutoCompletePanel {
         _filter.filter(constraint);
     }
 
+	public void update(@NonNull ArrayList<ListItem> l) {
+		_adapter.setData(l);
+		//_autoCompletePanel.set
+		int y = _textField.getCaretY() + _textField.rowHeight() / 2 - _textField.getScrollY();
+		setHeight(_adapter.getItemHeight() * Math.min(3, l.size()));
+		setHorizontalOffset(AutoPanelAdapter.PADDING);
+		setWidth(_textField.getWidth() - AutoPanelAdapter.PADDING * 2);
+		setVerticalOffset(y - _textField.getHeight());//_textField.getCaretY()-_textField.getScrollY()-_textField.getHeight());
+		_adapter.notifyDataSetChanged();
+		show();
+	}
+
+	public Bitmap getBitmap() {
+		return _adapter.bitmap;
+	}
+
     public void show() {
-        if (!_autoCompletePanel.isShowing()) {
+        if (!isShow()) {
 			_autoCompletePanel.show();
         }
 		//_autoCompletePanel.getListView();.setFadingEdgeLength(0);
@@ -169,14 +200,14 @@ public class AutoCompletePanel {
     }
 
     public void dismiss() {
-        if (_autoCompletePanel.isShowing()) {
+        if (isShow()) {
             isShow = false;
-            _autoCompletePanel.dismiss();
+			_autoCompletePanel.dismiss();
         }
     }
 
     public boolean isShow() {
-        return _autoCompletePanel.isShowing();
+        return isShow && _autoCompletePanel.isShowing();
     }
 
 }
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/view/autocomplete/AutoPanelAdapter.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/AutoPanelAdapter.java
similarity index 84%
rename from codeeditor/src/main/java/com/mrikso/codeeditor/view/autocomplete/AutoPanelAdapter.java
rename to codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/AutoPanelAdapter.java
index 96b5a85..fd7e954 100644
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/view/autocomplete/AutoPanelAdapter.java
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/AutoPanelAdapter.java
@@ -1,4 +1,4 @@
-package com.mrikso.codeeditor.view.autocomplete;
+package cn.rbc.codeeditor.view.autocomplete;
 
 import android.content.Context;
 import android.graphics.Bitmap;
@@ -18,26 +18,29 @@ import android.widget.Filterable;
 import android.widget.ImageView;
 import android.widget.TextView;
 
-import com.mrikso.codeeditor.R;
-import com.mrikso.codeeditor.util.Flag;
-import com.mrikso.codeeditor.view.FreeScrollingTextField;
+import cn.rbc.termuc.R;
+import cn.rbc.codeeditor.util.Flag;
+import cn.rbc.codeeditor.view.FreeScrollingTextField;
 
 import java.util.ArrayList;
 import java.util.List;
 
-import static com.mrikso.codeeditor.util.DLog.log;
+import static cn.rbc.codeeditor.util.DLog.log;
+import android.annotation.*;
+import android.text.style.*;
+import android.graphics.*;
 
 /**
  * Adapter定义
  */
-public class AutoPanelAdapter extends BaseAdapter implements Filterable {
+public class AutoPanelAdapter extends BaseAdapter  {
 
-    private final int PADDING = 20;
+    final static int PADDING = 20;
     private int _h;
     private Flag _abort;
     private DisplayMetrics dm;
-    private List<ListItem> listItems;
-    private Bitmap bitmap;
+    private ArrayList<ListItem> listItems;
+    public Bitmap bitmap;
     private Context _context;
     private AutoCompletePanel mAutoComplete;
     private FreeScrollingTextField mTextFiled;
@@ -82,12 +85,15 @@ public class AutoPanelAdapter extends BaseAdapter implements Filterable {
         }
         TextView textView = tempView.findViewById(R.id.auto_panel_text);
         ImageView imageView = tempView.findViewById(R.id.auto_panel_icon);
-        String text = getItem(i).getText();
+		ListItem it = getItem(i);
+        String text = it.label;
+		int tp = it.kind;
         SpannableString spannableString = null;
         ForegroundColorSpan foregroundColorSpan = null;
         //   Setting setting = Setting.getInstance(_context);
         log(text);
-        if (text.contains("(")) {
+		int t;
+        if ((t=text.indexOf('(')) >= 0) {
             //函数
             ForegroundColorSpan argsForegroundColorSpan = null;
             spannableString = new SpannableString(text);
@@ -99,9 +105,9 @@ public class AutoPanelAdapter extends BaseAdapter implements Filterable {
             foregroundColorSpan = new ForegroundColorSpan(Color.BLACK);
             argsForegroundColorSpan = new ForegroundColorSpan(Color.GRAY);
             //     }
-            spannableString.setSpan(foregroundColorSpan, 0, text.indexOf('('), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-            spannableString.setSpan(argsForegroundColorSpan, text.indexOf('('), text.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
-        } else if (text.contains("[keyword]")) {
+            spannableString.setSpan(foregroundColorSpan, 0, t, Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+            spannableString.setSpan(argsForegroundColorSpan, t, text.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
+        } else if (tp == 14) {
             //关键字
             //    if(setting.isDarkMode()) {
             //       foregroundColorSpan = new ForegroundColorSpan(Color.YELLOW);
@@ -109,9 +115,9 @@ public class AutoPanelAdapter extends BaseAdapter implements Filterable {
             //     else{
             foregroundColorSpan = new ForegroundColorSpan(mAutoComplete._textColor);
             //    }
-            int idx = text.indexOf("[keyword]");
-            text = text.substring(0, idx);
+          //  text = text.substring(3);
             spannableString = new SpannableString(text);
+			spannableString.setSpan(new StyleSpan(Typeface.BOLD), 0, text.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
             spannableString.setSpan(foregroundColorSpan, 0, text.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
         } else {
             //其他
@@ -121,11 +127,12 @@ public class AutoPanelAdapter extends BaseAdapter implements Filterable {
             //    }
             //    else{
             foregroundColorSpan = new ForegroundColorSpan(mAutoComplete._textColor);
-            //      }
+            //    }
             spannableString.setSpan(foregroundColorSpan, 0, text.length(), Spanned.SPAN_EXCLUSIVE_EXCLUSIVE);
         }
         textView.setText(spannableString);
-        imageView.setImageBitmap(getItem(i).getBitmap());
+		//t = getItem(i).kind;
+		imageView.setImageBitmap(tp==2 || tp==3 ? bitmap : null);
         return tempView;
     }
 
@@ -133,6 +140,9 @@ public class AutoPanelAdapter extends BaseAdapter implements Filterable {
         _abort.clear();
     }
 
+	public void setData(@NonNull ArrayList<ListItem> l) {
+		listItems = l;
+	}
     /**
      * 计算列表高
      *
@@ -152,7 +162,6 @@ public class AutoPanelAdapter extends BaseAdapter implements Filterable {
     /**
      * 实现自动完成的过滤算法
      */
-    @Override
     public Filter getFilter() {
         Filter filter = new Filter() {
             /**
@@ -180,7 +189,7 @@ public class AutoPanelAdapter extends BaseAdapter implements Filterable {
                     if (k.toLowerCase().startsWith(input))
                         buf.add(k);
                 }
-                mAutoComplete._constraint = input;
+               // mAutoComplete._off = input;
                 FilterResults filterResults = new FilterResults();
                 filterResults.values = buf;   // results是上面的过滤结果
                 filterResults.count = buf.size();  // 结果数量
@@ -198,11 +207,9 @@ public class AutoPanelAdapter extends BaseAdapter implements Filterable {
                     ArrayList<String> stringArrayList = (ArrayList<String>) results.values;
                     for (int i = 0; i < stringArrayList.size(); i++) {
                         String itemText = stringArrayList.get(i);
-                        if (itemText.contains("(")) {
-                            listItems.add(new ListItem(bitmap, itemText));
-                        } else {
-                            listItems.add(new ListItem(null, itemText));
-                        }
+						ListItem it = new ListItem();
+						it.label = itemText;
+						//it.bitmap = itemText.contains("(") ? bitmap : null;
                     }
                     int y = mTextFiled.getCaretY() + mTextFiled.rowHeight() / 2 - mTextFiled.getScrollY();
                     mAutoComplete.setHeight(getItemHeight() * Math.min(2, results.count));
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/Edit.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/Edit.java
new file mode 100644
index 0000000..25049b6
--- /dev/null
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/Edit.java
@@ -0,0 +1,13 @@
+package cn.rbc.codeeditor.view.autocomplete;
+
+public class Edit
+{
+	public String text;
+	public int start, len;
+
+	@Override
+	public String toString() {
+		// TODO: Implement this method
+		return text == null ? "null" : text;
+	}
+}
diff --git a/codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/ListItem.java b/codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/ListItem.java
new file mode 100644
index 0000000..441c640
--- /dev/null
+++ b/codeeditor/src/main/java/cn/rbc/codeeditor/view/autocomplete/ListItem.java
@@ -0,0 +1,11 @@
+package cn.rbc.codeeditor.view.autocomplete;
+
+//import android.graphics.Bitmap;
+import java.util.*;
+
+public class ListItem {
+    //public Bitmap bitmap;
+    public String label;
+	public int kind;
+	public Deque<Edit> edits = new ArrayDeque<>();
+}
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/common/OnTextChangeListener.java b/codeeditor/src/main/java/com/mrikso/codeeditor/common/OnTextChangeListener.java
deleted file mode 100644
index 0c2389f..0000000
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/common/OnTextChangeListener.java
+++ /dev/null
@@ -1,10 +0,0 @@
-package com.mrikso.codeeditor.common;
-
-public interface OnTextChangeListener {
-    void onNewLine(String s, int caretPosition, int pos);
-
-    void onDel(CharSequence text, int cursorPosition, int delCount);
-
-    void onAdd(CharSequence text, int cursorPosition, int addCount);
-
-}
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/view/TextFieldController.java b/codeeditor/src/main/java/com/mrikso/codeeditor/view/TextFieldController.java
deleted file mode 100644
index 2b5ab52..0000000
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/view/TextFieldController.java
+++ /dev/null
@@ -1,787 +0,0 @@
-package com.mrikso.codeeditor.view;
-
-import android.content.Context;
-import android.text.ClipboardManager;
-import android.view.inputmethod.InputMethodManager;
-
-import com.mrikso.codeeditor.lang.Language;
-import com.mrikso.codeeditor.util.Lexer;
-import com.mrikso.codeeditor.util.Pair;
-import com.mrikso.codeeditor.util.TextWarriorException;
-
-import java.util.List;
-
-import static com.mrikso.codeeditor.util.DLog.log;
-
-//*********************************************************************
-//************************ Controller logic ***************************
-//*********************************************************************
-public class TextFieldController implements Lexer.LexCallback {
-    private final Lexer _lexer = new Lexer(this);
-    public boolean _isInSelectionMode = false;
-    private boolean _isInSelectionMode2;
-    private FreeScrollingTextField mTextField;
-
-    public TextFieldController(FreeScrollingTextField textField) {
-        mTextField = textField;
-		lexing = false;
-    }
-
-    /**
-     * Analyze the text for programming language keywords and redraws the
-     * text view when done. The global programming language used is set with
-     * the static method Lexer.setLanguage(Language)
-     * <p>
-     * Does nothing if the Lexer language is not a programming language
-     */
-    public void determineSpans() {
-		lexing = true;
-        _lexer.tokenize(mTextField.hDoc);
-    }
-
-    public void cancelSpanning() {
-		lexing = false;
-        _lexer.cancelTokenize();
-    }
-
-    @Override
-    //This is usually called from a non-UI thread
-    public void lexDone(final List<Pair> results) {
-        mTextField.post(new Runnable() {
-            @Override
-            public void run() {
-                mTextField.hDoc.setSpans(results);
-				lexing = false;
-                mTextField.invalidate();
-            }
-        });
-    }
-
-    //- TextFieldController -----------------------------------------------
-    //---------------------------- Key presses ----------------------------
-
-    //TODO minimise invalidate calls from moveCaret(), insertion/deletion and word wrap
-    public void onPrintableChar(char c) {
-        // delete currently selected text, if any
-		lexing = true;
-        boolean selectionDeleted = false;
-        if (_isInSelectionMode) {
-            selectionDelete();
-            selectionDeleted = true;
-        }
-
-        switch (c) {
-            case Language.BACKSPACE:
-                if (selectionDeleted) {
-                    break;
-                }
-                if (mTextField.mCaretPosition > 0) {
-                    mTextField.hDoc.deleteAt(mTextField.mCaretPosition - 1, System.nanoTime());
-                    if (mTextField.hDoc.charAt(mTextField.mCaretPosition - 2) == 0xd83d || mTextField.hDoc.charAt(mTextField.mCaretPosition - 2) == 0xd83c) {
-                        mTextField.hDoc.deleteAt(mTextField.mCaretPosition - 2, System.nanoTime());
-                        moveCaretLeft(true);
-                    }
-
-                    mTextField.mTextListener.onDel(String.valueOf(c), mTextField.mCaretPosition, 1);
-                    moveCaretLeft(true);
-                }
-                break;
-
-            case Language.NEWLINE:
-                if (mTextField.isAutoIndent) {
-                    char[] indent = createAutoIndent();
-                    mTextField.hDoc.insertBefore(indent, mTextField.mCaretPosition, System.nanoTime());
-                    moveCaret(mTextField.mCaretPosition + indent.length);
-					break;
-                }
-            default:
-                mTextField.hDoc.insertBefore(new char[]{c}, mTextField.mCaretPosition, System.nanoTime());
-                moveCaretRight(true);
-                mTextField.mTextListener.onAdd(String.valueOf(c), mTextField.mCaretPosition, 1);
-                break;
-        }
-
-        mTextField.setEdited(true);
-        determineSpans();
-    }
-
-    /**
-     * Return a char[] with a newline as the 0th element followed by the
-     * leading spaces and tabs of the line that the caret is on
-     * 创建自动缩进
-     */
-    private char[] createAutoIndent() {
-        int lineNum = mTextField.hDoc.findLineNumber(mTextField.mCaretPosition);
-        int startOfLine = mTextField.hDoc.getLineOffset(lineNum);
-        int whitespaceCount = 0;
-        //查找上一行的空白符个数
-		int i, mL = mTextField.hDoc.getTextLength();
-        for (i=startOfLine; i<mL;) {
-            char c = mTextField.hDoc.charAt(i++);
-            if ((c != ' ' && c != Language.TAB) || startOfLine + whitespaceCount >= mTextField.mCaretPosition) {
-                break;
-            }
-            if (c == Language.TAB) {
-                whitespaceCount += mTextField.getAutoIndentWidth();
-            }
-            if (c == ' ')
-                ++whitespaceCount;
-        }
-        //寻找最后字符
-        int endChar = 0;
-        for (i=startOfLine;i<mL;) {
-            char c = mTextField.hDoc.charAt(i++);
-            if (c == Language.NEWLINE) {
-                break;
-            }
-            endChar = c;
-        }
-        //最后字符为'{',缩进
-        if (endChar == '{')
-            whitespaceCount += mTextField.getAutoIndentWidth();
-        if (whitespaceCount < 0)
-            return new char[]{Language.NEWLINE};
-
-        char[] indent = new char[1 + whitespaceCount];
-        indent[0] = Language.NEWLINE;
-
-        for (i = 0; i < whitespaceCount; ++i) {
-            indent[1 + i] = ' ';
-        }
-        return indent;
-    }
-
-    public void moveCaretDown() {
-        if (!mTextField.caretOnLastRowOfFile()) {
-            int currCaret = mTextField.mCaretPosition;
-            int currRow = mTextField.mCaretRow;
-            int newRow = currRow + 1;
-            int currColumn = mTextField.getColumn(currCaret);
-            int currRowLength = mTextField.hDoc.getRowSize(currRow);
-            int newRowLength = mTextField.hDoc.getRowSize(newRow);
-
-            if (currColumn < newRowLength) {
-                // Position at the same column as old row.
-                mTextField.mCaretPosition += currRowLength;
-            } else {
-                // Column does not exist in the new row (new row is too short).
-                // Position at end of new row instead.
-                mTextField.mCaretPosition +=
-                        currRowLength - currColumn + newRowLength - 1;
-            }
-            ++mTextField.mCaretRow;
-
-            updateSelectionRange(currCaret, mTextField.mCaretPosition);
-            if (!mTextField.makeCharVisible(mTextField.mCaretPosition)) {
-                mTextField.invalidateRows(currRow, newRow + 1);
-            }
-            // 拖动yoyo球滚动时，保证yoyo球的坐标与光标一致
-            mTextField.mCaretListener.updateCaret(mTextField.mCaretPosition);
-            mTextField.mRowListener.onRowChanged(newRow);
-            stopTextComposing();
-        }
-    }
-
-    public void moveCaretUp() {
-        if (!mTextField.caretOnFirstRowOfFile()) {
-            int currCaret = mTextField.mCaretPosition;
-            int currRow = mTextField.mCaretRow;
-            int newRow = currRow - 1;
-            int currColumn = mTextField.getColumn(currCaret);
-            int newRowLength = mTextField.hDoc.getRowSize(newRow);
-
-            if (currColumn < newRowLength) {
-                // Position at the same column as old row.
-                mTextField.mCaretPosition -= newRowLength;
-            } else {
-                // Column does not exist in the new row (new row is too short).
-                // Position at end of new row instead.
-                mTextField.mCaretPosition -= (currColumn + 1);
-            }
-            --mTextField.mCaretRow;
-
-            updateSelectionRange(currCaret, mTextField.mCaretPosition);
-            if (!mTextField.makeCharVisible(mTextField.mCaretPosition)) {
-                mTextField.invalidateRows(newRow, currRow + 1);
-            }
-            // 拖动yoyo球滚动时，保证yoyo球的坐标与光标一致
-            mTextField.mCaretListener.updateCaret(mTextField.mCaretPosition);
-            mTextField.mRowListener.onRowChanged(newRow);
-            stopTextComposing();
-        }
-    }
-
-    /**
-     * @param isTyping Whether caret is moved to a consecutive position as
-     *                 a result of entering text
-     */
-    public void moveCaretRight(boolean isTyping) {
-        if (!mTextField.caretOnEOF()) {
-            int originalRow = mTextField.mCaretRow;
-            ++mTextField.mCaretPosition;
-            updateCaretRow();
-            updateSelectionRange(mTextField.mCaretPosition - 1, mTextField.mCaretPosition);
-            if (!mTextField.makeCharVisible(mTextField.mCaretPosition)) {
-                mTextField.invalidateRows(originalRow, mTextField.mCaretRow + 1);
-            }
-
-            if (!isTyping) {
-                stopTextComposing();
-            }
-            // 拖动yoyo球滚动时，保证yoyo球的坐标与光标一致
-            mTextField.mCaretListener.updateCaret(mTextField.mCaretPosition);
-        }
-    }
-
-    /**
-     * @param isTyping Whether caret is moved to a consecutive position as
-     *                 a result of deleting text
-     */
-    public void moveCaretLeft(boolean isTyping) {
-        if (mTextField.mCaretPosition > 0) {
-            int originalRow = mTextField.mCaretRow;
-            --mTextField.mCaretPosition;
-            updateCaretRow();
-            updateSelectionRange(mTextField.mCaretPosition + 1, mTextField.mCaretPosition);
-            if (!mTextField.makeCharVisible(mTextField.mCaretPosition)) {
-                mTextField.invalidateRows(mTextField.mCaretRow, originalRow + 1);
-            }
-
-            if (!isTyping) {
-                stopTextComposing();
-            }
-            // 拖动yoyo球滚动时，保证yoyo球的坐标与光标一致
-            mTextField.mCaretListener.updateCaret(mTextField.mCaretPosition);
-        }
-    }
-
-    public void moveCaret(int i) {
-        if (i < 0 || i >= mTextField.hDoc.getTextLength()) {
-            TextWarriorException.fail("Invalid caret position");
-            return;
-        }
-        updateSelectionRange(mTextField.mCaretPosition, i);
-
-        mTextField.mCaretPosition = i;
-        updateAfterCaretJump();
-    }
-
-    private void updateAfterCaretJump() {
-        int oldRow = mTextField.mCaretRow;
-        updateCaretRow();
-        if (!mTextField.makeCharVisible(mTextField.mCaretPosition)) {
-            mTextField.invalidateRows(oldRow, oldRow + 1); //old caret row
-            mTextField.invalidateCaretRow(); //new caret row
-        }
-        stopTextComposing();
-    }
-
-    /**
-     * This helper method should only be used by internal methods after setting
-     * mTextFiledl.mCaretPosition, in order to to recalculate the new row the caret is on.
-     */
-    void updateCaretRow() {
-        int newRow = mTextField.hDoc.findRowNumber(mTextField.mCaretPosition);
-        if (mTextField.mCaretRow != newRow) {
-            mTextField.mCaretRow = newRow;
-            mTextField.mRowListener.onRowChanged(newRow);
-        }
-    }
-
-    public void stopTextComposing() {
-        InputMethodManager im = (InputMethodManager) mTextField.getContext().getSystemService(Context.INPUT_METHOD_SERVICE);
-        // This is an overkill way to inform the InputMethod that the caret
-        // might have changed position and it should re-evaluate the
-        // caps mode to use.
-        im.restartInput(mTextField);
-
-        if (mTextField.mInputConnection != null && mTextField.mInputConnection.isComposingStarted()) {
-            mTextField.mInputConnection.resetComposingState();
-        }
-    }
-
-    //- TextFieldController -----------------------------------------------
-    //-------------------------- Selection mode ---------------------------
-    public final boolean isSelectText() {
-        return _isInSelectionMode;
-    }
-
-    /**
-     * Enter or exit select mode.
-     * Does not invalidate view.
-     *
-     * @param mode If true, enter select mode; else exit select mode
-     */
-    public void setSelectText(boolean mode) {
-        if (mode == _isInSelectionMode) {
-            return;
-        }
-
-        if (mode) {
-            mTextField.mSelectionAnchor = mTextField.mCaretPosition;
-            mTextField.mSelectionEdge = mTextField.mCaretPosition;
-        } else {
-            mTextField.mSelectionAnchor = -1;
-            mTextField.mSelectionEdge = -1;
-        }
-        _isInSelectionMode = mode;
-        _isInSelectionMode2 = mode;
-        mTextField.mSelModeListener.onSelectionChanged(mode, mTextField.getSelectionStart(), mTextField.getSelectionEnd());
-    }
-
-    public final boolean isSelectText2() {
-        return _isInSelectionMode2;
-    }
-
-    public boolean inSelectionRange(int charOffset) {
-        if (mTextField.mSelectionAnchor < 0) {
-            return false;
-        }
-        return (mTextField.mSelectionAnchor <= charOffset && charOffset < mTextField.mSelectionEdge);
-    }
-
-    /**
-     * Selects numChars count of characters starting from beginPosition.
-     * Invalidates necessary areas.
-     *
-     * @param beginPosition
-     * @param numChars
-     * @param scrollToStart If true, the start of the selection will be scrolled
-     *                      into view. Otherwise, the end of the selection will be scrolled.
-     */
-
-    public void setSelectionRange(int beginPosition, int numChars, boolean scrollToStart, boolean mode) {
-        TextWarriorException.assertVerbose(
-                (beginPosition >= 0) && numChars <= (mTextField.hDoc.getTextLength() - 1) && numChars >= 0,
-                "Invalid range to select");
-
-        if (_isInSelectionMode) {
-            // unhighlight previous selection
-            mTextField.invalidateSelectionRows();
-        } else {
-            // unhighlight caret
-            mTextField.invalidateCaretRow();
-            if (mode)
-                setSelectText(true);
-            else
-                _isInSelectionMode = true;
-        }
-
-        mTextField.mSelectionAnchor = beginPosition;
-        mTextField.mSelectionEdge = mTextField.mSelectionAnchor + numChars;
-
-        mTextField.mCaretPosition = mTextField.mSelectionEdge;
-        stopTextComposing();
-        updateCaretRow();
-        if (mode)
-            mTextField.mSelModeListener.onSelectionChanged(isSelectText(), mTextField.mSelectionAnchor, mTextField.mSelectionEdge);
-        boolean scrolled = mTextField.makeCharVisible(mTextField.mSelectionEdge);
-
-        if (scrollToStart) {
-            //TODO reduce unnecessary scrolling and write a method to scroll
-            // the beginning of multi-line selections as far left as possible
-            scrolled = mTextField.makeCharVisible(mTextField.mSelectionAnchor);
-        }
-
-        if (!scrolled) {
-            mTextField.invalidateSelectionRows();
-        }
-    }
-
-    /**
-     * Moves the caret to an edge of selected text and scrolls it to view.
-     *
-     * @param start If true, moves the caret to the beginning of
-     *              the selection. Otherwise, moves the caret to the end of the selection.
-     *              In all cases, the caret is scrolled to view if it is not visible.
-     */
-    public void focusSelection(boolean start) {
-        if (_isInSelectionMode) {
-            if (start && mTextField.mCaretPosition != mTextField.mSelectionAnchor) {
-                mTextField.mCaretPosition = mTextField.mSelectionAnchor;
-                updateAfterCaretJump();
-            } else if (!start && mTextField.mCaretPosition != mTextField.mSelectionEdge) {
-                mTextField.mCaretPosition = mTextField.mSelectionEdge;
-                updateAfterCaretJump();
-            }
-        }
-    }
-
-
-    /**
-     * Used by internal methods to update selection boundaries when a new
-     * caret position is set.
-     * Does nothing if not in selection mode.
-     */
-    private void updateSelectionRange(int oldCaretPosition, int newCaretPosition) {
-
-        if (!_isInSelectionMode) {
-            return;
-        }
-
-        if (oldCaretPosition < mTextField.mSelectionEdge) {
-            if (newCaretPosition > mTextField.mSelectionEdge) {
-                mTextField.mSelectionAnchor = mTextField.mSelectionEdge;
-                mTextField.mSelectionEdge = newCaretPosition;
-            } else {
-                mTextField.mSelectionAnchor = newCaretPosition;
-            }
-
-        } else {
-            if (newCaretPosition < mTextField.mSelectionAnchor) {
-                mTextField.mSelectionEdge = mTextField.mSelectionAnchor;
-                mTextField.mSelectionAnchor = newCaretPosition;
-            } else {
-                mTextField.mSelectionEdge = newCaretPosition;
-            }
-        }
-    }
-
-    //- TextFieldController -----------------------------------------------
-    //------------------------ Cut, copy, paste, delete ---------------------------
-
-    /**
-     * Convenience method for consecutive copy and paste calls
-     */
-    public void cut(ClipboardManager cb) {
-        copy(cb);
-        selectionDelete();
-		determineSpans();
-    }
-
-    /**
-     * Copies the selected text to the clipboard.
-     * <p>
-     * Does nothing if not in select mode.
-     */
-    public void copy(ClipboardManager cb) {
-        //TODO catch OutOfMemoryError
-        if (_isInSelectionMode &&
-                mTextField.mSelectionAnchor < mTextField.mSelectionEdge) {
-            CharSequence contents = mTextField.hDoc.subSequence(mTextField.mSelectionAnchor,
-                    mTextField.mSelectionEdge - mTextField.mSelectionAnchor);
-            cb.setText(contents);
-        }
-    }
-
-    /**
-     * Inserts text at the caret position.
-     * Existing selected text will be deleted and select mode will end.
-     * The deleted area will be invalidated.
-     * <p>
-     * After insertion, the inserted area will be invalidated.
-     */
-    public void paste(String text) {
-        if (text == null) {
-            return;
-        }
-
-        mTextField.hDoc.beginBatchEdit();
-        selectionDelete();
-
-        int originalRow = mTextField.mCaretRow;
-        int originalOffset = mTextField.hDoc.getRowOffset(originalRow);
-        mTextField.hDoc.insertBefore(text.toCharArray(), mTextField.mCaretPosition, System.nanoTime());
-        mTextField.mTextListener.onAdd(text, mTextField.mCaretPosition, text.length());
-        //_textLis.onAdd(text, mTextFiledl.mCaretPosition, text.length());
-        mTextField.hDoc.endBatchEdit();
-
-        mTextField.mCaretPosition += text.length();
-        updateCaretRow();
-
-        mTextField.setEdited(true);
-        determineSpans();
-        stopTextComposing();
-
-        if (!mTextField.makeCharVisible(mTextField.mCaretPosition)) {
-            int invalidateStartRow = originalRow;
-            //invalidate previous row too if its wrapping changed
-            if (mTextField.hDoc.isWordWrap() &&
-                    originalOffset != mTextField.hDoc.getRowOffset(originalRow)) {
-                --invalidateStartRow;
-            }
-
-            if (originalRow == mTextField.mCaretRow && !mTextField.hDoc.isWordWrap()) {
-                //pasted text only affects caret row
-                mTextField.invalidateRows(invalidateStartRow, invalidateStartRow + 1);
-            } else {
-                //TODO invalidate damaged rows only
-                mTextField.invalidateFromRow(invalidateStartRow);
-            }
-        }
-    }
-
-    /**
-     * Deletes selected text, exits select mode and invalidates deleted area.
-     * If the selected range is empty, this method exits select mode and
-     * invalidates the caret.
-     * <p>
-     * Does nothing if not in select mode.
-     */
-    public void selectionDelete() {
-        if (!_isInSelectionMode) {
-            return;
-        }
-
-        int totalChars = mTextField.mSelectionEdge - mTextField.mSelectionAnchor;
-
-        if (totalChars > 0) {
-            int originalRow = mTextField.hDoc.findRowNumber(mTextField.mSelectionAnchor);
-            int originalOffset = mTextField.hDoc.getRowOffset(originalRow);
-            boolean isSingleRowSel = mTextField.hDoc.findRowNumber(mTextField.mSelectionEdge) == originalRow;
-            mTextField.hDoc.deleteAt(mTextField.mSelectionAnchor, totalChars, System.nanoTime());
-            mTextField.mTextListener.onDel("", mTextField.mCaretPosition, totalChars);
-            mTextField.mCaretPosition = mTextField.mSelectionAnchor;
-            updateCaretRow();
-            mTextField.setEdited(true);
-            //determineSpans();
-            setSelectText(false);
-            stopTextComposing();
-
-            if (!mTextField.makeCharVisible(mTextField.mCaretPosition)) {
-                int invalidateStartRow = originalRow;
-                //invalidate previous row too if its wrapping changed
-                if (mTextField.hDoc.isWordWrap() &&
-                        originalOffset != mTextField.hDoc.getRowOffset(originalRow)) {
-                    --invalidateStartRow;
-                }
-
-                if (isSingleRowSel && !mTextField.hDoc.isWordWrap()) {
-                    //pasted text only affects current row
-                    mTextField.invalidateRows(invalidateStartRow, invalidateStartRow + 1);
-                } else {
-                    //TODO invalidate damaged rows only
-                    mTextField.invalidateFromRow(invalidateStartRow);
-                }
-            }
-        } else {
-            setSelectText(false);
-            mTextField.invalidateCaretRow();
-        }
-    }
-
-    void replaceText(int from, int charCount, String text) {
-        int invalidateStartRow, originalOffset;
-        boolean isInvalidateSingleRow = true;
-        boolean dirty = false;
-        //delete selection
-        if (_isInSelectionMode) {
-            invalidateStartRow = mTextField.hDoc.findRowNumber(mTextField.mSelectionAnchor);
-            originalOffset = mTextField.hDoc.getRowOffset(invalidateStartRow);
-
-            int totalChars = mTextField.mSelectionEdge - mTextField.mSelectionAnchor;
-
-            if (totalChars > 0) {
-                mTextField.mCaretPosition = mTextField.mSelectionAnchor;
-                mTextField.hDoc.deleteAt(mTextField.mSelectionAnchor, totalChars, System.nanoTime());
-
-                if (invalidateStartRow != mTextField.mCaretRow) {
-                    isInvalidateSingleRow = false;
-                }
-                dirty = true;
-            }
-
-            setSelectText(false);
-        } else {
-            invalidateStartRow = mTextField.mCaretRow;
-            originalOffset = mTextField.hDoc.getRowOffset(mTextField.mCaretRow);
-        }
-
-        //delete requested chars
-        if (charCount > 0) {
-            int delFromRow = mTextField.hDoc.findRowNumber(from);
-            if (delFromRow < invalidateStartRow) {
-                invalidateStartRow = delFromRow;
-                originalOffset = mTextField.hDoc.getRowOffset(delFromRow);
-            }
-
-            if (invalidateStartRow != mTextField.mCaretRow) {
-                isInvalidateSingleRow = false;
-            }
-
-            mTextField.mCaretPosition = from;
-            mTextField.hDoc.deleteAt(from, charCount, System.nanoTime());
-            dirty = true;
-        }
-
-        //insert
-        if (text != null && text.length() > 0) {
-            int insFromRow = mTextField.hDoc.findRowNumber(from);
-            if (insFromRow < invalidateStartRow) {
-                invalidateStartRow = insFromRow;
-                originalOffset = mTextField.hDoc.getRowOffset(insFromRow);
-            }
-
-            mTextField.hDoc.insertBefore(text.toCharArray(), mTextField.mCaretPosition, System.nanoTime());
-            mTextField.mCaretPosition += text.length();
-            dirty = true;
-        }
-
-        if (dirty) {
-            mTextField.setEdited(true);
-            determineSpans();
-			return;
-        }
-
-        int originalRow = mTextField.mCaretRow;
-        updateCaretRow();
-        if (originalRow != mTextField.mCaretRow) {
-            isInvalidateSingleRow = false;
-        }
-
-        if (!mTextField.makeCharVisible(mTextField.mCaretPosition)) {
-            //invalidate previous row too if its wrapping changed
-            if (mTextField.hDoc.isWordWrap() &&
-                    originalOffset != mTextField.hDoc.getRowOffset(invalidateStartRow)) {
-                --invalidateStartRow;
-            }
-
-            if (isInvalidateSingleRow && !mTextField.hDoc.isWordWrap()) {
-                //replaced text only affects current row
-                mTextField.invalidateRows(mTextField.mCaretRow, mTextField.mCaretRow + 1);
-            } else {
-                //TODO invalidate damaged rows only
-                mTextField.invalidateFromRow(invalidateStartRow);
-            }
-        }
-    }
-
-    //- TextFieldController -----------------------------------------------
-    //----------------- Helper methods for InputConnection ----------------
-
-    /**
-     * Deletes existing selected text, then deletes charCount number of
-     * characters starting at from, and inserts text in its place.
-     * <p>
-     * Unlike paste or selectionDelete, does not signal the end of
-     * text composing to the IME.
-     */
-    void replaceComposingText(int from, int charCount, String text) {
-        int invalidateStartRow, originalOffset;
-        boolean isInvalidateSingleRow = true;
-        boolean dirty = false;
-
-        //delete selection
-        if (_isInSelectionMode) {
-            invalidateStartRow = mTextField.hDoc.findRowNumber(mTextField.mSelectionAnchor);
-            originalOffset = mTextField.hDoc.getRowOffset(invalidateStartRow);
-
-            int totalChars = mTextField.mSelectionEdge - mTextField.mSelectionAnchor;
-
-            if (totalChars > 0) {
-                mTextField.mCaretPosition = mTextField.mSelectionAnchor;
-                mTextField.hDoc.deleteAt(mTextField.mSelectionAnchor, totalChars, System.nanoTime());
-
-                if (invalidateStartRow != mTextField.mCaretRow) {
-                    isInvalidateSingleRow = false;
-                }
-                dirty = true;
-            }
-
-            setSelectText(false);
-        } else {
-            invalidateStartRow = mTextField.mCaretRow;
-            originalOffset = mTextField.hDoc.getRowOffset(mTextField.mCaretRow);
-        }
-
-        //delete requested chars
-        if (charCount > 0) {
-            int delFromRow = mTextField.hDoc.findRowNumber(from);
-            if (delFromRow < invalidateStartRow) {
-                invalidateStartRow = delFromRow;
-                originalOffset = mTextField.hDoc.getRowOffset(delFromRow);
-            }
-
-            if (invalidateStartRow != mTextField.mCaretRow) {
-                isInvalidateSingleRow = false;
-            }
-
-            mTextField.mCaretPosition = from;
-            mTextField.hDoc.deleteAt(from, charCount, System.nanoTime());
-            dirty = true;
-        }
-
-        //insert
-        if (text != null && text.length() > 0) {
-            int insFromRow = mTextField.hDoc.findRowNumber(from);
-            if (insFromRow < invalidateStartRow) {
-                invalidateStartRow = insFromRow;
-                originalOffset = mTextField.hDoc.getRowOffset(insFromRow);
-            }
-
-            log("inserted text:" + text);
-            mTextField.hDoc.insertBefore(text.toCharArray(), mTextField.mCaretPosition, System.nanoTime());
-            mTextField.mCaretPosition += text.length();
-            dirty = true;
-
-        }
-
-        mTextField.mTextListener.onAdd(text, mTextField.mCaretPosition, text.length() - charCount);
-        if (dirty) {
-            mTextField.setEdited(true);
-            determineSpans();
-			return;
-        }
-
-        int originalRow = mTextField.mCaretRow;
-        updateCaretRow();
-        if (originalRow != mTextField.mCaretRow) {
-            isInvalidateSingleRow = false;
-        }
-
-        if (!mTextField.makeCharVisible(mTextField.mCaretPosition)) {
-            //invalidate previous row too if its wrapping changed
-            if (mTextField.hDoc.isWordWrap() &&
-                    originalOffset != mTextField.hDoc.getRowOffset(invalidateStartRow)) {
-                --invalidateStartRow;
-            }
-
-            if (isInvalidateSingleRow && !mTextField.hDoc.isWordWrap()) {
-                //replaced text only affects current row
-                mTextField.invalidateRows(mTextField.mCaretRow, mTextField.mCaretRow + 1);
-            } else {
-                //TODO invalidate damaged rows only
-                mTextField.invalidateFromRow(invalidateStartRow);
-            }
-        }
-    }
-
-    /**
-     * Delete leftLength characters of text before the current caret
-     * position, and delete rightLength characters of text after the current
-     * cursor position.
-     * <p>
-     * Unlike paste or selectionDelete, does not signal the end of
-     * text composing to the IME.
-     */
-    void deleteAroundComposingText(int left, int right) {
-        int start = mTextField.mCaretPosition - left;
-        if (start < 0) {
-            start = 0;
-        }
-        int end = mTextField.mCaretPosition + right;
-        int docLength = mTextField.hDoc.getTextLength();
-        if (end > (docLength - 1)) { //exclude the terminal EOF
-            end = docLength - 1;
-        }
-        replaceComposingText(start, end - start, "");
-    }
-
-    String getTextAfterCursor(int maxLen) {
-        int docLength = mTextField.hDoc.getTextLength();
-        if ((mTextField.mCaretPosition + maxLen) > (docLength - 1)) {
-            //exclude the terminal EOF
-            return mTextField.hDoc.subSequence(mTextField.mCaretPosition, docLength - mTextField.mCaretPosition - 1).toString();
-        }
-
-        return mTextField.hDoc.subSequence(mTextField.mCaretPosition, maxLen).toString();
-    }
-
-    String getTextBeforeCursor(int maxLen) {
-        int start = mTextField.mCaretPosition - maxLen;
-        if (start < 0) {
-            start = 0;
-        }
-        return mTextField.hDoc.subSequence(start, mTextField.mCaretPosition - start).toString();
-    }
-}//end inner controller class
diff --git a/codeeditor/src/main/java/com/mrikso/codeeditor/view/autocomplete/ListItem.java b/codeeditor/src/main/java/com/mrikso/codeeditor/view/autocomplete/ListItem.java
deleted file mode 100644
index 73f85cb..0000000
--- a/codeeditor/src/main/java/com/mrikso/codeeditor/view/autocomplete/ListItem.java
+++ /dev/null
@@ -1,30 +0,0 @@
-package com.mrikso.codeeditor.view.autocomplete;
-
-import android.graphics.Bitmap;
-
-public class ListItem {
-    private Bitmap bitmap;
-    private String text;
-
-    public ListItem(Bitmap bitmap, String text) {
-        this.bitmap = bitmap;
-        this.text = text;
-    }
-
-    public Bitmap getBitmap() {
-        return bitmap;
-    }
-
-    public void setBitmap(Bitmap bitmap) {
-        this.bitmap = bitmap;
-    }
-
-    public String getText() {
-        return text;
-    }
-
-    public void setText(String text) {
-        this.text = text;
-    }
-
-}
\ No newline at end of file
