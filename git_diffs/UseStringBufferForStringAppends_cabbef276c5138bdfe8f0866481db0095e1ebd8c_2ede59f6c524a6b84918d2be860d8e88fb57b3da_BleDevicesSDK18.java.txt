diff --git a/app/src/main/java/ch/bailu/aat/activities/CockpitActivity.java b/app/src/main/java/ch/bailu/aat/activities/CockpitActivity.java
index 668aacb0..550feda5 100644
--- a/app/src/main/java/ch/bailu/aat/activities/CockpitActivity.java
+++ b/app/src/main/java/ch/bailu/aat/activities/CockpitActivity.java
@@ -3,12 +3,10 @@ package ch.bailu.aat.activities;
 import android.os.Bundle;
 import android.view.View;
 
-import ch.bailu.aat.description.AltitudeConfigurationDescription;
-import ch.bailu.aat.description.AltitudeDescription;
 import ch.bailu.aat.description.AverageSpeedDescriptionAP;
+import ch.bailu.aat.description.CadenceDescription;
 import ch.bailu.aat.description.CurrentSpeedDescription;
 import ch.bailu.aat.description.DistanceDescription;
-import ch.bailu.aat.description.HeartRateDescription;
 import ch.bailu.aat.description.MaximumSpeedDescription;
 import ch.bailu.aat.description.PredictiveTimeDescription;
 import ch.bailu.aat.dispatcher.BleSensorSource;
@@ -19,7 +17,6 @@ import ch.bailu.aat.dispatcher.TrackerSource;
 import ch.bailu.aat.dispatcher.TrackerTimerSource;
 import ch.bailu.aat.gpx.InfoID;
 import ch.bailu.aat.map.MapFactory;
-import ch.bailu.aat.preferences.location.SolidProvideAltitude;
 import ch.bailu.aat.util.ui.AppLayout;
 import ch.bailu.aat.views.ContentView;
 import ch.bailu.aat.views.bar.ControlBar;
@@ -63,13 +60,15 @@ public class CockpitActivity extends AbsKeepScreenOnActivity {
         CockpitView c1 = new CockpitView(this);
 
 
-        c1.add(this, new CurrentSpeedDescription(this), InfoID.LOCATION);
+        c1.add(this, new CurrentSpeedDescription(this), InfoID.SPEED_SENSOR);
         c1.addAltitude(this);
         c1.add(this, new PredictiveTimeDescription(this), InfoID.TRACKER_TIMER);
         c1.addC(this, new DistanceDescription(this), InfoID.TRACKER);
         c1.addC(this, new AverageSpeedDescriptionAP(this), InfoID.TRACKER);
         c1.add(this, new MaximumSpeedDescription(this), InfoID.TRACKER);
-        c1.add(this, new HeartRateDescription(this), InfoID.HEART_RATE_SENSOR);
+        //c1.add(this, new HeartRateDescription(this), InfoID.HEART_RATE_SENSOR);
+        //c1.add(this, new CurrentSpeedDescription(this), InfoID.SPEED_SENSOR);
+        c1.add(this, new CadenceDescription(this), InfoID.CADENCE_SENSOR);
 
         return c1;
     }
@@ -95,6 +94,8 @@ public class CockpitActivity extends AbsKeepScreenOnActivity {
         addSource(new TrackerTimerSource(getServiceContext()));
         addSource(new CurrentLocationSource(getServiceContext()));
         addSource(new OverlaySource(getServiceContext()));
-        addSource(new BleSensorSource(getServiceContext()));
+        //addSource(new BleSensorSource(getServiceContext(), InfoID.HEART_RATE_SENSOR));
+        addSource(new BleSensorSource(getServiceContext(), InfoID.CADENCE_SENSOR));
+        addSource(new BleSensorSource(getServiceContext(), InfoID.SPEED_SENSOR));
     }
 }
diff --git a/app/src/main/java/ch/bailu/aat/description/CadenceDescription.java b/app/src/main/java/ch/bailu/aat/description/CadenceDescription.java
new file mode 100644
index 00000000..68e55ceb
--- /dev/null
+++ b/app/src/main/java/ch/bailu/aat/description/CadenceDescription.java
@@ -0,0 +1,46 @@
+package ch.bailu.aat.description;
+
+import android.content.Context;
+
+import ch.bailu.aat.gpx.GpxInformation;
+import ch.bailu.aat.gpx.InfoID;
+import ch.bailu.aat.services.bluetooth_le.CscServiceID;
+import ch.bailu.aat.util.ToDo;
+
+public class CadenceDescription  extends ContentDescription {
+    private static final String LABEL = ToDo.translate("Cadence");
+    private static final String UNIT = "rpm";
+
+    private String value = "  ";
+    private String unit = UNIT;
+    private String label = LABEL;
+
+
+    public CadenceDescription(Context c) {
+        super(c);
+    }
+
+    @Override
+    public String getValue() {
+        return value;
+    }
+
+    @Override
+    public String getLabel() {
+        return label;
+    }
+
+    @Override
+    public String getUnit() {
+        return unit;
+    }
+
+
+    @Override
+    public void onContentUpdated(int iid, GpxInformation info) {
+        if (iid == InfoID.CADENCE_SENSOR) {
+            value = info.getAttributes().getValue(CscServiceID.KEY_INDEX_CRANK_RPM_AVERAGE);
+            unit = UNIT + " " + info.getAttributes().getValue(CscServiceID.KEY_INDEX_CRANK_RPM);
+        }
+    }
+}
diff --git a/app/src/main/java/ch/bailu/aat/description/HeartRateDescription.java b/app/src/main/java/ch/bailu/aat/description/HeartRateDescription.java
index db22d4e3..42efc4d5 100644
--- a/app/src/main/java/ch/bailu/aat/description/HeartRateDescription.java
+++ b/app/src/main/java/ch/bailu/aat/description/HeartRateDescription.java
@@ -39,9 +39,9 @@ public class HeartRateDescription extends ContentDescription {
     @Override
     public void onContentUpdated(int iid, GpxInformation info) {
         if (iid == InfoID.HEART_RATE_SENSOR) {
-            String bpm = info.getAttributes().getValue(HeartRateServiceID.BPM_KEY_INDEX);
-            String bpma = info.getAttributes().getValue(HeartRateServiceID.BPMA_KEY_INDEX);
-            String contact = info.getAttributes().getValue(HeartRateServiceID.CONTACT_KEY_INDEX);
+            String bpm = info.getAttributes().getValue(HeartRateServiceID.KEY_INDEX_BPM);
+            String bpma = info.getAttributes().getValue(HeartRateServiceID.KEY_INDEX_BPM_AVERAGE);
+            String contact = info.getAttributes().getValue(HeartRateServiceID.KEY_INDEX_CONTACT);
 
 
             value = bpma;
diff --git a/app/src/main/java/ch/bailu/aat/dispatcher/BleSensorSource.java b/app/src/main/java/ch/bailu/aat/dispatcher/BleSensorSource.java
index 5db67c5a..19f77510 100644
--- a/app/src/main/java/ch/bailu/aat/dispatcher/BleSensorSource.java
+++ b/app/src/main/java/ch/bailu/aat/dispatcher/BleSensorSource.java
@@ -5,16 +5,17 @@ import android.content.Context;
 import android.content.Intent;
 
 import ch.bailu.aat.gpx.GpxInformation;
-import ch.bailu.aat.gpx.InfoID;
 import ch.bailu.aat.services.ServiceContext;
 import ch.bailu.aat.util.AppBroadcaster;
 import ch.bailu.aat.util.ui.AppLog;
 
 public class BleSensorSource extends ContentSource {
     private final ServiceContext scontext;
+    private final int iid;
 
-    public BleSensorSource(ServiceContext sc) {
+    public BleSensorSource(ServiceContext sc, int i) {
         scontext = sc;
+        iid = i;
     }
 
 
@@ -41,17 +42,17 @@ public class BleSensorSource extends ContentSource {
 
     @Override
     public void onResume() {
-        AppBroadcaster.register(scontext.getContext(), onSensorUpdated, AppBroadcaster.BLE_DEVICE_NOTIFIED);
+        AppBroadcaster.register(scontext.getContext(), onSensorUpdated, AppBroadcaster.BLE_NOTIFIED + iid);
 
     }
 
     @Override
     public int getIID() {
-        return InfoID.HEART_RATE_SENSOR;
+        return iid;
     }
 
     @Override
     public GpxInformation getInfo() {
-        return scontext.getBleService().getInformation();
+        return scontext.getBleService().getInformation(iid);
     }
 }
diff --git a/app/src/main/java/ch/bailu/aat/gpx/InfoID.java b/app/src/main/java/ch/bailu/aat/gpx/InfoID.java
index b771b2bf..e02960d2 100644
--- a/app/src/main/java/ch/bailu/aat/gpx/InfoID.java
+++ b/app/src/main/java/ch/bailu/aat/gpx/InfoID.java
@@ -22,4 +22,6 @@ public class InfoID {
 
 
     public static final int HEART_RATE_SENSOR = 71;
+    public static final int CADENCE_SENSOR = 72;
+    public static final int SPEED_SENSOR = 73;
 }
diff --git a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/Averager.java b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/Averager.java
new file mode 100644
index 00000000..6d2b0f2d
--- /dev/null
+++ b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/Averager.java
@@ -0,0 +1,40 @@
+package ch.bailu.aat.services.bluetooth_le;
+
+public class Averager {
+
+
+    private final int values[];
+    private int size = 0;
+    private int next = 0;
+    private int average = 0;
+
+    public Averager(int sapmles) {
+        values = new int[sapmles];
+    }
+
+    public void add(int b) {
+        values[next] = b;
+        if (size < values.length) size++;
+
+        next++;
+        if (next >= values.length) next = 0;
+
+        average = average();
+    }
+
+    private int average() {
+        int r = 0;
+
+        if (size > 0) {
+            for (int i = 0; i < size; i++) {
+                r = r + values[i];
+            }
+            r = r / size;
+        }
+        return r;
+    }
+
+    public int get() {
+        return average;
+    }
+}
diff --git a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/BleDevices.java b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/BleDevices.java
index 5aa91e05..e37b6f86 100644
--- a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/BleDevices.java
+++ b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/BleDevices.java
@@ -1,23 +1,23 @@
 package ch.bailu.aat.services.bluetooth_le;
 
-import android.content.Context;
 import android.os.Build;
 
 import java.io.Closeable;
 
 import ch.bailu.aat.gpx.GpxInformation;
+import ch.bailu.aat.services.ServiceContext;
 
 public class BleDevices implements Closeable {
 
     public void scann() {}
-    public GpxInformation getInformation() {
+    public GpxInformation getInformation(int iid) {
         return GpxInformation.NULL;
     }
 
 
-    public static BleDevices factory(Context context) {
+    public static BleDevices factory(ServiceContext sc) {
         if (Build.VERSION.SDK_INT >= 18) {
-            return new BleDevicesSDK18(context);
+            return new BleDevicesSDK18(sc);
         } else {
             return new BleDevices();
         }
diff --git a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/BleDevicesSDK18.java b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/BleDevicesSDK18.java
index 84a4e37f..76967c97 100644
--- a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/BleDevicesSDK18.java
+++ b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/BleDevicesSDK18.java
@@ -6,13 +6,11 @@ import android.bluetooth.BluetoothManager;
 import android.content.Context;
 import android.support.annotation.RequiresApi;
 
-import java.util.ArrayList;
-
 import ch.bailu.aat.gpx.GpxInformation;
+import ch.bailu.aat.services.ServiceContext;
 import ch.bailu.aat.util.AppBroadcaster;
 import ch.bailu.aat.util.Timer;
 import ch.bailu.aat.util.ToDo;
-import ch.bailu.util_java.util.Objects;
 
 @RequiresApi(api = 18)
 public class BleDevicesSDK18 extends BleDevices {
@@ -20,13 +18,12 @@ public class BleDevicesSDK18 extends BleDevices {
     private final static long SCAN_DURATION = 5000;
 
     private final Context context;
-    private final BluetoothAdapter adapter;
+    private final ServiceContext scontext;
 
-    private ArrayList<Device> scanned = new ArrayList<>(5);
+    private final BluetoothAdapter adapter;
 
+    private final Devices devices = new Devices();
     private final BleScanner scanner;
-
-
     private final Timer timer = new Timer(new Runnable() {
         @Override
         public void run() {
@@ -37,8 +34,10 @@ public class BleDevicesSDK18 extends BleDevices {
 
 
 
-    public BleDevicesSDK18(Context c) {
-        context = c;
+    public BleDevicesSDK18(ServiceContext sc) {
+        scontext = sc;
+        context = sc.getContext();
+
         adapter = getAdapter();
         scanner = BleScanner.factory(adapter, this);
 
@@ -48,18 +47,15 @@ public class BleDevicesSDK18 extends BleDevices {
 
 
     @Override
-    public void scann() {
+    public  synchronized void scann() {
+        stopScanner();
+
         if (isEnabled()) {
-            timer.kick();
-            scanner.stop();
-            removeInvalidDevices();
-            scanner.start();
+            devices.closeDisconnectedDevices();
+            startScanner();
 
         } else {
-            timer.cancel();
-            scanner.stop();
-            scanned.clear();
-
+            devices.closeAllDevices();
         }
 
         AppBroadcaster.broadcast(context, AppBroadcaster.BLE_DEVICE_SCANNED);
@@ -79,87 +75,55 @@ public class BleDevicesSDK18 extends BleDevices {
 
 
 
-    private void removeInvalidDevices() {
-        for (int i = scanned.size()-1; i > -1; i--) {
-            if (scanned.get(i).isConnected() == false) {
-                scanned.remove(i);
-            }
-        }
-    }
 
 
-    void foundDevice(BluetoothDevice device) {
-        if (!isScanned(device)) {
-            scannDevice(device);
+    public synchronized void foundDevice(BluetoothDevice device) {
+        if (!devices.isInList(device)) {
+            devices.addAndConnectDevice(scontext, device);
         }
     }
 
 
-    private void scannDevice(BluetoothDevice device) {
-        Device d = new Device(context, device);
-        scanned.add(d);
-        device.connectGatt(context, true, d);
-    }
 
+    @Override
+    public  synchronized String toString() {
+        if (isEnabled()) {
+            return devices.toString();
 
-    private boolean isScanned(BluetoothDevice device) {
-        for (Device d : scanned) {
-            if (Objects.equals(d.getAddress(), device.getAddress())) return true;
+        } else {
+            return ToDo.translate("Bluetooth is disabled");
         }
-        return false;
     }
 
 
     @Override
-    public String toString() {
+    public synchronized GpxInformation getInformation(int iid) {
 
+        GpxInformation information = devices.getInformation(iid);
 
-        String s = "";
-
-        if (isEnabled()) {
-            String nl = "";
-
-            for (Device d : scanned) {
-                if (d.isValid()) {
-                    s = s + nl + d.toString();
-                    nl = "\n";
-                }
-            }
-
-            if (s.length() == 0) {
-                s = ToDo.translate("No sensors found");
-            }
-        } else {
-            s = ToDo.translate("Bluetooth is disabled");
+        if (information == null) {
+            information = GpxInformation.NULL;
         }
-        return s;
-    }
 
-
-    @Override
-    public GpxInformation getInformation() {
-        for (Device device : scanned) {
-            if (device.isValid()) {
-                GpxInformation information = device.getInformation();
-                if (information != null) return information;
-            }
-        }
-        return GpxInformation.NULL;
+        return information;
     }
 
 
     @Override
-    public void close() {
-        timer.cancel();
-        scanner.stop();
+    public synchronized void close() {
+        stopScanner();
+        devices.close();
+    }
 
-        for (Device device : scanned) {
-            device.close();
-        }
 
-        scanned.clear();
+    private void startScanner() {
+        timer.kick();
+        scanner.start();
+    }
 
 
+    private void stopScanner() {
+        timer.cancel();
+        scanner.stop();
     }
-
 }
diff --git a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/BleService.java b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/BleService.java
index aee3b7aa..8c503250 100644
--- a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/BleService.java
+++ b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/BleService.java
@@ -17,7 +17,7 @@ public class BleService extends VirtualService {
     public BleService(ServiceContext sc) {
         super(sc);
 
-        devices = BleDevices.factory(sc.getContext());
+        devices = BleDevices.factory(sc);
 
 
         AppBroadcaster.register(getContext(),
@@ -45,23 +45,23 @@ public class BleService extends VirtualService {
 
 
     @Override
-    public void close() {
+    public synchronized void close() {
         devices.close();
         getContext().unregisterReceiver(onBluetoothStateChanged);
     }
 
 
-    public void scan() {
+    public  synchronized void scan() {
         devices.scann();
     }
 
 
     @Override
-    public String toString() {
+    public synchronized String toString() {
         return devices.toString();
     }
 
-    public GpxInformation getInformation() {
-        return devices.getInformation();
+    public synchronized GpxInformation getInformation(int iid) {
+        return devices.getInformation(iid);
     }
 }
diff --git a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/CscService.java b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/CscService.java
index 584dba6e..09d4730d 100644
--- a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/CscService.java
+++ b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/CscService.java
@@ -1,59 +1,58 @@
 package ch.bailu.aat.services.bluetooth_le;
 
 import android.bluetooth.BluetoothGattCharacteristic;
+import android.content.Context;
 import android.support.annotation.RequiresApi;
 
-import java.util.UUID;
+import java.io.Closeable;
+import java.io.IOException;
+
+import ch.bailu.aat.gpx.GpxAttributes;
+import ch.bailu.aat.gpx.GpxInformation;
+import ch.bailu.aat.gpx.InfoID;
+import ch.bailu.aat.services.ServiceContext;
+import ch.bailu.aat.util.AppBroadcaster;
 
 @RequiresApi(api = 18)
-public class CscService {
+public class CscService extends CscServiceID implements Closeable {
     /**
      *
      * RPM BBB BCP-66 SmartCadence RPM Sensor
      *
-     * CSC ( Cycling Speed And Cadence)
+     * CSC (Cycling Speed And Cadence)
      * https://www.bluetooth.com/specifications/gatt/viewer?attributeXmlFile=org.bluetooth.service.cycling_speed_and_cadence.xml
+     * https://developer.polar.com/wiki/Cycling_Speed_%26_Cadence
      */
 
+    private static final long BROADCAST_TIMEOUT = 3000;
+
 
-    public final static UUID CSC_SERVICE = ID.toUUID(0x1816);
-    public final static UUID CSC_MESUREMENT = ID.toUUID(0x2A5B);
-    public final static int BIT_SPEED = 0;
-    public final static int BIT_CADENCE = 1;
-    public final static int BIT_SPEED_AND_CADENCE = 2;
-
-    public final static UUID CSC_FEATURE = ID.toUUID(0x2A5C);
-    public final static UUID CSC_SENSOR_LOCATION = ID.toUUID(0x2A5D);
-    public final static UUID CSC_CONTROL_POINT = ID.toUUID(0x2A55);
-
-
-    private final static String[] SENSOR_LOCATION = {
-            "Other",
-            "Top of shoe",
-            "In shoe",
-            "Hip",
-            "Front Wheel",
-            "Left Crank",
-            "Right Crank",
-            "Left Pedal",
-            "Right Pedal",
-            "Front Hub",
-            "Rear Dropout",
-            "Chainstay",
-            "Rear Wheel",
-            "Rear Hub",
-            "Chest",
-            "Spider",
-            "Chain Ring",
-    };
+    private long lastBroadcast = 0L;
 
     private String location = SENSOR_LOCATION[0];
 
-    private boolean speed = false;
-    private boolean cadence = false;
+    private boolean isSpeedSensor = false;
+    private boolean isCadenceSensor = false;
+
+    private final Revolution cadence = new Revolution();
+    private final Revolution speed = new Revolution();
+    private final Averager averageCadence = new Averager(5);
+    private final WheelCircumference wheelCircumference;
+    private float circumference = 0f;
+
+
+    private GpxInformation information = GpxInformation.NULL;
+
+    private final Context context;
 
     private boolean valid = false;
 
+    public CscService(ServiceContext c) {
+        context = c.getContext();
+        wheelCircumference = new WheelCircumference(c, speed);
+    }
+
+
     public boolean isValid() {
         return valid;
     }
@@ -107,42 +106,10 @@ public class CscService {
     }
 
 
-    private int cumulative_wheel_revolutions = 0;
-    private double last_wheel_event_time = 0d;
 
-    private int cumulative_crank_revolutions = 0;
-    private double last_crank_event_time = 0d;
-
-    private long timestamp = 0;
 
     private void readCscMesurement(BluetoothGattCharacteristic c, byte[] value) {
-        int offset = 0;
-
-        timestamp = System.currentTimeMillis();
-
-        byte data = value[offset];
-
-        offset += 1;
-
-        if (ID.isBitSet(data, BIT_SPEED)) {
-            cumulative_wheel_revolutions =
-                    c.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT32, offset);
-            offset += 4;
-
-            last_wheel_event_time = c.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT16, offset);
-            last_wheel_event_time /= 1024d;
-            offset += 2;
-
-        }
-
-
-        if (ID.isBitSet(data, BIT_CADENCE)) {
-            cumulative_crank_revolutions = c.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT16, offset);
-            offset += 2;
-
-            last_crank_event_time = c.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT16, offset);
-            last_crank_event_time /= 1024d;
-        }
+        information = new Information(new Attributes(c, value));
     }
 
 
@@ -152,14 +119,14 @@ public class CscService {
             byte b = v[0];
 
             if (ID.isBitSet(b, BIT_SPEED)) {
-                speed = true;
+                isSpeedSensor = true;
 
             } else if (ID.isBitSet(b, BIT_CADENCE)) {
-                cadence = true;
+                isCadenceSensor = true;
 
             } else if (ID.isBitSet(b, BIT_SPEED_AND_CADENCE)) {
-                speed = true;
-                cadence = true;
+                isSpeedSensor = true;
+                isCadenceSensor = true;
             }
         }
     }
@@ -173,11 +140,11 @@ public class CscService {
             name = "No ";
         }
 
-        if (speed) {
+        if (isSpeedSensor) {
             name = "Speed ";
         }
 
-        if (cadence) {
+        if (isCadenceSensor) {
             name += "Cadence ";
         }
 
@@ -185,4 +152,192 @@ public class CscService {
     }
 
 
+    @Override
+    public void close()  {
+        wheelCircumference.close();
+    }
+
+
+    private class Attributes extends GpxAttributes {
+
+        boolean haveCadence, haveSpeed;
+        private int speed_rpm = 0;
+        private int cadence_rpm = 0;
+        private int cadence_rpm_average = 0;
+        private float speedSI = 0f;
+
+
+        public Attributes(BluetoothGattCharacteristic c, byte[] v) {
+            int offset = 0;
+
+            byte data = v[offset];
+            offset += 1;
+
+            haveCadence = ID.isBitSet(data, BIT_CADENCE);
+            haveSpeed = ID.isBitSet(data, BIT_SPEED);
+
+            if (haveSpeed) {
+                long revolutions = c.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT32, offset);
+                offset += 4;
+
+                int time = c.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT16, offset);
+
+                offset += 2;
+
+                speed.addUINT32(time, revolutions);
+
+                speed_rpm = speed.rpm();
+
+                if (circumference == 0f)
+                    circumference = wheelCircumference.getCircumference();
+
+                if (circumference != 0f) {
+                    speedSI = speed.getSpeedSI(circumference);
+                    wheelCircumference.close();
+                }
+            }
+
+
+            if (haveCadence) {
+                int revolutions = c.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT16, offset);
+                offset += 2;
+
+                int time = c.getIntValue(BluetoothGattCharacteristic.FORMAT_UINT16, offset);
+
+                cadence.add(time, revolutions);
+                cadence_rpm = cadence.rpm();
+
+                if (cadence_rpm != 0) {
+                    averageCadence.add(cadence_rpm);
+                }
+            }
+            cadence_rpm_average = averageCadence.get();
+
+            broadcast();
+        }
+
+
+        private void broadcast() {
+            final long time = System.currentTimeMillis();
+
+            if (haveSpeed && isSpeedSensor && (timeout(time) || speed_rpm != 0)) {
+                AppBroadcaster.broadcast(
+                        context, AppBroadcaster.BLE_NOTIFIED + InfoID.SPEED_SENSOR);
+
+                lastBroadcast = time;
+            }
+
+            if (haveCadence && isCadenceSensor) {
+                AppBroadcaster.broadcast(
+                        context, AppBroadcaster.BLE_NOTIFIED + InfoID.CADENCE_SENSOR);
+            }
+
+
+        }
+
+
+        public float getSpeedSI() {
+            return speedSI;
+        }
+
+        @Override
+        public String get(String key) {
+            for (int i = 0; i< KEYS.length; i++) {
+                if (key.equalsIgnoreCase(KEYS[i])) return getValue(i);
+            }
+
+            return null;
+        }
+
+        @Override
+        public String getValue(int index) {
+            if (index == KEY_INDEX_SENSOR_LOCATION) {
+                return location;
+
+            } else if (index == KEY_INDEX_CADENCE_SENSOR) {
+                return String.valueOf(isCadenceSensor);
+
+            } else if (index == KEY_INDEX_SPEED_SENSOR) {
+                return String.valueOf(isSpeedSensor);
+
+            } else if (index == KEY_INDEX_CRANK_RPM) {
+                return String.valueOf(cadence_rpm);
+
+            } else if (index == KEY_INDEX_CRANK_RPM_AVERAGE) {
+                return String.valueOf(cadence_rpm_average);
+
+            } else if (index == KEY_INDEX_WHEEL_CIRCUMFERENCE) {
+                return String.valueOf(wheelCircumference);
+            }
+
+
+            return NULL_VALUE;
+        }
+
+        @Override
+        public String getKey(int index) {
+            if (index < KEYS.length) return KEYS[index];
+            return null;
+        }
+
+        @Override
+        public void put(String key, String value) {
+
+        }
+
+        @Override
+        public int size() {
+            return KEYS.length;
+        }
+
+        @Override
+        public void remove(String key) {
+
+        }
+    }
+
+
+    private static class Information extends GpxInformation {
+        private final Attributes attributes;
+        private final long timeStamp = System.currentTimeMillis();
+
+
+        public Information(Attributes a) {
+            attributes = a;
+
+        }
+
+        @Override
+        public GpxAttributes getAttributes() {
+            return attributes;
+        }
+
+        @Override
+        public long getTimeStamp() {
+            return timeStamp;
+        }
+
+
+        @Override
+        public float getSpeed() {
+            return attributes.getSpeedSI();
+        }
+    }
+
+
+    public GpxInformation getInformation(int iid) {
+        if (isSpeedSensor && iid == InfoID.SPEED_SENSOR)
+            return information;
+
+        else if (isCadenceSensor && iid == InfoID.CADENCE_SENSOR) {
+            return information;
+        }
+
+        return null;
+    }
+
+
+    private boolean timeout(long time) {
+        return (lastBroadcast - time > BROADCAST_TIMEOUT);
+    }
 }
diff --git a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/CscServiceID.java b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/CscServiceID.java
new file mode 100644
index 00000000..8571d768
--- /dev/null
+++ b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/CscServiceID.java
@@ -0,0 +1,55 @@
+package ch.bailu.aat.services.bluetooth_le;
+
+import java.util.UUID;
+
+public class CscServiceID extends ID {
+
+    public final static UUID CSC_SERVICE = toUUID(0x1816);
+    public final static UUID CSC_MESUREMENT = toUUID(0x2A5B);
+    public final static int BIT_SPEED = 0;
+    public final static int BIT_CADENCE = 1;
+    public final static int BIT_SPEED_AND_CADENCE = 2;
+
+    public final static UUID CSC_FEATURE = toUUID(0x2A5C);
+    public final static UUID CSC_SENSOR_LOCATION = toUUID(0x2A5D);
+    public final static UUID CSC_CONTROL_POINT = toUUID(0x2A55);
+
+
+    public final static String[] SENSOR_LOCATION = {
+            "Other",
+            "Top of shoe",
+            "In shoe",
+            "Hip",
+            "Front Wheel",
+            "Left Crank",
+            "Right Crank",
+            "Left Pedal",
+            "Right Pedal",
+            "Front Hub",
+            "Rear Dropout",
+            "Chainstay",
+            "Rear Wheel",
+            "Rear Hub",
+            "Chest",
+            "Spider",
+            "Chain Ring",
+    };
+
+
+    public static final int KEY_INDEX_SENSOR_LOCATION = 0;
+    public static final int KEY_INDEX_SPEED_SENSOR = 1;
+    public static final int KEY_INDEX_CADENCE_SENSOR = 2;
+    public static final int KEY_INDEX_CRANK_RPM = 3;
+    public static final int KEY_INDEX_CRANK_RPM_AVERAGE = 4;
+    public static final int KEY_INDEX_WHEEL_CIRCUMFERENCE = 5;
+
+
+    public final static String[] KEYS = {
+            "SensorLocation",
+            "SpeedSensor",
+            "CadenceSensor",
+            "RevolutionsPerMinute",
+            "AbverageRevolutionsPerMinute",
+            "WheelCircumference"
+    };
+}
diff --git a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/Device.java b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/Device.java
index 9b8deab6..16f635b8 100644
--- a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/Device.java
+++ b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/Device.java
@@ -14,6 +14,7 @@ import java.io.Closeable;
 import java.util.List;
 
 import ch.bailu.aat.gpx.GpxInformation;
+import ch.bailu.aat.services.ServiceContext;
 import ch.bailu.aat.util.AppBroadcaster;
 
 @RequiresApi(api = 18)
@@ -21,81 +22,87 @@ public class Device extends BluetoothGattCallback implements Closeable {
 
     private final Executer execute = new Executer();
 
-    private final HeartRateService heartRate;
-    private final BatteryService battery = new BatteryService();
-    private final CscService csc = new CscService();
+    private final HeartRateService heartRateService;
+    private final BatteryService batteryService = new BatteryService();
+    private final CscService cscService;
 
     private final BluetoothDevice device;
 
     private final Context context;
     private BluetoothGatt gatt = null;
 
-    private boolean connected = false;
+    private int state;
 
-    public Device(Context c, BluetoothDevice d) {
+    public Device(ServiceContext c, BluetoothDevice d) {
         device = d;
-        context = c;
+        context = c.getContext();
 
-        heartRate = new HeartRateService(context);
+        cscService = new CscService(c);
+        heartRateService = new HeartRateService(context);
     }
 
 
-    public boolean isConnected() {
-        return connected;
+    public synchronized boolean isConnected() {
+        return  state == BluetoothProfile.STATE_CONNECTED || 
+                state ==BluetoothProfile.STATE_CONNECTING;
     }
 
-    public boolean isValid() {
-        return connected && (csc.isValid() || heartRate.isValid());
+    public synchronized boolean isValid() {
+        return state == BluetoothProfile.STATE_CONNECTED &&
+                (cscService.isValid() || heartRateService.isValid());
     }
 
     @Override
-    public String toString() {
+    public synchronized String toString() {
         String s = device.getName();
 
-        if (csc.isValid()) {
-            s = s + ", " + csc.toString();
+        if (cscService.isValid()) {
+            s = s + ", " + cscService.toString();
         }
 
-        if (heartRate.isValid()) {
-            s = s+ ", " + heartRate.toString();
+        if (heartRateService.isValid()) {
+            s = s+ ", " + heartRateService.toString();
         }
 
-        s = s + ", " + battery.getBatteryLevelPercentage() + "%";
+        s = s + ", " + batteryService.getBatteryLevelPercentage() + "%";
         return s;
     }
 
 
     @Override
-    public void onConnectionStateChange(BluetoothGatt g, int status, int newState) {
+    public synchronized void onConnectionStateChange(BluetoothGatt g, int status, int newState) {
         gatt = g;
-        if (status == BluetoothGatt.GATT_SUCCESS && newState == BluetoothProfile.STATE_CONNECTED) {
+        state = newState;
+        
+        if (status == BluetoothGatt.GATT_SUCCESS && state == BluetoothProfile.STATE_CONNECTED) {
             gatt.discoverServices();
-        } else {
+            
+        } else if (state == BluetoothProfile.STATE_DISCONNECTED) {
             broadcast();
         }
-
-        connected = (newState == BluetoothProfile.STATE_CONNECTED
-                || newState == BluetoothProfile.STATE_CONNECTING);
     }
 
+    
     private void broadcast() {
         AppBroadcaster.broadcast(context, AppBroadcaster.BLE_DEVICE_SCANNED);
     }
 
+    
     private void executeOrBroadcast(BluetoothGatt gatt) {
         if (!execute.next(gatt)) {
             broadcast();
         }
     }
 
+    
     @Override
-    public void onServicesDiscovered(BluetoothGatt gatt, int status) {
+    public synchronized void onServicesDiscovered(BluetoothGatt gatt, int status) {
         discover(gatt);
 
-        if (isValid()) {
+        if ((cscService.isValid() || heartRateService.isValid())) {
             executeOrBroadcast(gatt);
         } else {
-            gatt.close();
+            close();
         }
     }
 
@@ -103,16 +110,16 @@ public class Device extends BluetoothGattCallback implements Closeable {
 
 
     @Override
-    public void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {
+    public synchronized void onDescriptorWrite(BluetoothGatt gatt, BluetoothGattDescriptor descriptor, int status) {
         executeOrBroadcast(gatt);
     }
 
     @Override
-    public void onCharacteristicChanged(BluetoothGatt gatt,
+    public synchronized void onCharacteristicChanged(BluetoothGatt gatt,
                                         BluetoothGattCharacteristic c) {
 
-        heartRate.notify(c);
-        csc.notify(c);
+        heartRateService.notify(c);
+        cscService.notify(c);
 
     }
 
@@ -131,37 +138,51 @@ public class Device extends BluetoothGattCallback implements Closeable {
         List<BluetoothGattCharacteristic> list = service.getCharacteristics();
 
         for (BluetoothGattCharacteristic c : list) {
-            heartRate.discovered(c, execute);
-            battery.discovered(c, execute);
-            csc.discovered(c, execute);
+            heartRateService.discovered(c, execute);
+            batteryService.discovered(c, execute);
+            cscService.discovered(c, execute);
 
         }
     }
 
 
-    public void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic c,
+    @Override
+    public synchronized void onCharacteristicRead(BluetoothGatt gatt, BluetoothGattCharacteristic c,
                                      int status) {
-        heartRate.read(c);
-        battery.read(c);
-        csc.read(c);
+        heartRateService.read(c);
+        batteryService.read(c);
+        cscService.read(c);
 
         executeOrBroadcast(gatt);
     }
 
-    public String getAddress() {
+
+    public synchronized String getAddress() {
         return device.getAddress();
     }
 
-    public GpxInformation getInformation() {
-        return heartRate.getInformation();
+
+    public synchronized GpxInformation getInformation(int iid) {
+        GpxInformation i = heartRateService.getInformation(iid);
+
+        if (i == null) {
+            i = cscService.getInformation(iid);
+        }
+
+        return i;
     }
 
+    
     @Override
-    public void close() {
+    public synchronized void close() {
+        cscService.close();
+
+
         if (gatt != null) {
             gatt.close();
-            connected = false;
+            state = BluetoothProfile.STATE_DISCONNECTED;
             gatt = null;
+            broadcast();
         }
     }
 }
diff --git a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/Devices.java b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/Devices.java
new file mode 100644
index 00000000..dc2cbd7f
--- /dev/null
+++ b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/Devices.java
@@ -0,0 +1,91 @@
+package ch.bailu.aat.services.bluetooth_le;
+
+import android.bluetooth.BluetoothDevice;
+import android.content.Context;
+import android.support.annotation.RequiresApi;
+
+import java.io.Closeable;
+import java.util.ArrayList;
+
+import ch.bailu.aat.gpx.GpxInformation;
+import ch.bailu.aat.services.ServiceContext;
+import ch.bailu.aat.util.ToDo;
+import ch.bailu.util_java.util.Objects;
+
+@RequiresApi(api = 18)
+public class Devices implements Closeable {
+
+    private final ArrayList<Device> devices = new ArrayList<>(5);
+
+
+
+
+    public synchronized void addAndConnectDevice(ServiceContext scontext, BluetoothDevice device) {
+        Device d = new Device(scontext, device);
+        devices.add(d);
+        device.connectGatt(scontext.getContext(), true, d);
+    }
+
+
+    public synchronized boolean isInList(BluetoothDevice device) {
+        for (Device d : devices) {
+            if (Objects.equals(d.getAddress(), device.getAddress())) return true;
+        }
+        return false;
+    }
+
+
+
+    @Override
+    public synchronized String toString() {
+        String s = "";
+        String nl = "";
+
+        for (Device d : devices) {
+            if (d.isValid()) {
+                s = s + nl + d.toString();
+                nl = "\n";
+            }
+        }
+
+        if (s.length() == 0) {
+            s = ToDo.translate("No sensors found");
+        }
+
+        return s;
+    }
+
+    public synchronized GpxInformation getInformation(int iid) {
+        for (Device device : devices) {
+            if (device.isValid()) {
+                GpxInformation information = device.getInformation(iid);
+                if (information != null) return information;
+            }
+        }
+        return null;
+    }
+
+    @Override
+    public synchronized void close()  {
+        closeAllDevices();
+    }
+
+    public synchronized void closeAllDevices() {
+        for (Device device : devices) {
+            device.close();
+        }
+        devices.clear();
+    }
+
+
+    public synchronized void closeDisconnectedDevices() {
+        for (int i = devices.size()-1; i > -1; i--) {
+            final Device device = devices.get(i);
+
+            if (device.isConnected() == false) {
+                device.close();
+                devices.remove(i);
+            }
+        }
+    }
+}
diff --git a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/HeartRateService.java b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/HeartRateService.java
index b56e5b0c..add618c3 100644
--- a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/HeartRateService.java
+++ b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/HeartRateService.java
@@ -8,6 +8,7 @@ import java.util.UUID;
 
 import ch.bailu.aat.gpx.GpxAttributes;
 import ch.bailu.aat.gpx.GpxInformation;
+import ch.bailu.aat.gpx.InfoID;
 import ch.bailu.aat.util.AppBroadcaster;
 
 @RequiresApi(api = 18)
@@ -74,7 +75,7 @@ public class HeartRateService extends HeartRateServiceID {
 
     private void readHeartRateMesurement(BluetoothGattCharacteristic c, byte[] value) {
         information = new Information(new Attributes(c, value));
-        AppBroadcaster.broadcast(context, AppBroadcaster.BLE_DEVICE_NOTIFIED);
+        AppBroadcaster.broadcast(context, AppBroadcaster.BLE_NOTIFIED + InfoID.HEART_RATE_SENSOR);
     }
 
 
@@ -92,7 +93,7 @@ public class HeartRateService extends HeartRateServiceID {
 
 
 
-    private final Averager averager = new Averager();
+    private final Averager averager = new Averager(10);
 
     private class Attributes extends GpxAttributes {
 
@@ -103,7 +104,7 @@ public class HeartRateService extends HeartRateServiceID {
         private boolean haveRrIntervall = false;
 
         private int bpm = 0;
-        private int bpma = 0;
+        private int bpmAverage = 0;
 
         private float rrIntervall = 0f;
 
@@ -148,7 +149,7 @@ public class HeartRateService extends HeartRateServiceID {
 
             if (bpm > 0) {
                 averager.add(bpm);
-                bpma = averager.get();
+                bpmAverage = averager.get();
                 if (!haveSensorContactStatus) haveSensorContact = true;
             } else {
                 if (!haveSensorContactStatus) haveSensorContact = false;
@@ -168,19 +169,23 @@ public class HeartRateService extends HeartRateServiceID {
 
         @Override
         public String getValue(int index) {
-            if (index == BPM_KEY_INDEX) {
+            if (index == KEY_INDEX_BPM) {
                 return String.valueOf(bpm);
 
-            } else if (index == BPMA_KEY_INDEX) {
-                return String.valueOf(bpma);
+            } else if (index == KEY_INDEX_BPM_AVERAGE) {
+                return String.valueOf(bpmAverage);
 
-            } else if (index == RR_KEY_INDEX) {
+            } else if (index == KEY_INDEX_RR) {
                 return String.valueOf(rrIntervall);
 
 
-            } else if (index == CONTACT_KEY_INDEX) {
+            } else if (index == KEY_INDEX_CONTACT) {
                  if (haveSensorContact) return "on";
                  return "...";
+
+            } else if (index == KEY_INDEX_LOCATION) {
+                return location;
+
             }
 
             return NULL_VALUE;
@@ -230,37 +235,9 @@ public class HeartRateService extends HeartRateServiceID {
     }
 
 
-    public GpxInformation getInformation() {
-        return information;
-    }
-
-
-    private static class Averager {
-        private final static int MAX_SAMPLES = 20;
-
-        private final int values[] = new int[MAX_SAMPLES];
-        private int size = 0;
-        private int next = 0;
-
-        public void add(int b) {
-            values[next] = b;
-            if (size < MAX_SAMPLES) size++;
-
-            next++;
-            if (next >= MAX_SAMPLES) next = 0;
-        }
-
-        public int get() {
-            int r = 0;
-
-            if (size > 0) {
-                for (int i = 0; i < size; i++) {
-                    r = r + values[i];
-                }
-
-                r = r / size;
-            }
-            return r;
-        }
+    public GpxInformation getInformation(int iid) {
+        if (iid == InfoID.HEART_RATE_SENSOR)
+            return information;
+        return null;
     }
 }
diff --git a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/HeartRateServiceID.java b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/HeartRateServiceID.java
index 6e0b40d0..0a7580c5 100644
--- a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/HeartRateServiceID.java
+++ b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/HeartRateServiceID.java
@@ -2,24 +2,27 @@ package ch.bailu.aat.services.bluetooth_le;
 
 import java.util.UUID;
 
-public class HeartRateServiceID {
+public class HeartRateServiceID extends ID {
 
     public final static int SERVICE_ID = 0x180d;
-    public final static UUID HEART_RATE_SERVICE = ID.toUUID(SERVICE_ID);
-    public final static UUID HEART_RATE_MESUREMENT = ID.toUUID(0x2a37);
-    public final static UUID BODY_SENSOR_LOCATION = ID.toUUID(0x2a38);
+    public final static UUID HEART_RATE_SERVICE = toUUID(SERVICE_ID);
+    public final static UUID HEART_RATE_MESUREMENT = toUUID(0x2a37);
+    public final static UUID BODY_SENSOR_LOCATION = toUUID(0x2a38);
 
 
-    public static final int BPM_KEY_INDEX=0;
-    public static final int BPMA_KEY_INDEX=1;
-    public static final int RR_KEY_INDEX=2;
-    public static final int CONTACT_KEY_INDEX=3;
+    public static final int KEY_INDEX_BPM = 0;
+    public static final int KEY_INDEX_BPM_AVERAGE = 1;
+    public static final int KEY_INDEX_RR = 2;
+    public static final int KEY_INDEX_CONTACT = 3;
+    public static final int KEY_INDEX_LOCATION = 3;
+
 
     public static final String[] KEYS = {
             "BPM",
             "AverageBPM",
             "RR",
             "ContactStatus",
+            "Location"
     };
 
 
diff --git a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/ID.java b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/ID.java
index 9ad85351..727fa937 100644
--- a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/ID.java
+++ b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/ID.java
@@ -15,7 +15,6 @@ public class ID {
         return Integer.toHexString(id);
     }
 
-
     public static int toID(UUID uuid) {
         return (int) (uuid.getMostSignificantBits() >> 32);
     }
diff --git a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/Revolution.java b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/Revolution.java
new file mode 100644
index 00000000..da9cfc62
--- /dev/null
+++ b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/Revolution.java
@@ -0,0 +1,49 @@
+package ch.bailu.aat.services.bluetooth_le;
+
+public class Revolution {
+    private final static int MINUTE = 60 * 1024;
+
+    private final Rollover time = new Rollover();
+    private final Rollover revolution = new Rollover();
+
+
+    public void addUINT32(int t, long r) {
+        time.add(t);
+        revolution.addUINT32(r);
+    }
+
+    public void add(int t, int r) {
+        time.add(t);
+        revolution.add(r);
+    }
+
+
+    public int rpm() {
+        int rpm = 0;
+        final int time_for_one_revolution = intervall();
+
+        if (time_for_one_revolution > 0)
+            rpm = MINUTE / time_for_one_revolution;
+
+        return rpm;
+    }
+
+
+    public int intervall() {
+        if (revolution.getDelta() > 0)
+            return time.getDelta() / revolution.getDelta();
+
+        return 0;
+    }
+
+    public float getSpeedSI(float wheel_size) {
+        final float seconds = ((float)intervall()) / 1024f;
+        final float meters = wheel_size;
+
+        return meters / seconds;
+    }
+
+    public long getTotalRevolutions() {
+        return revolution.getTotal();
+    }
+}
diff --git a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/Rollover.java b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/Rollover.java
new file mode 100644
index 00000000..53996820
--- /dev/null
+++ b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/Rollover.java
@@ -0,0 +1,59 @@
+package ch.bailu.aat.services.bluetooth_le;
+
+public class Rollover {
+    private final static int MAX_UINT16 = 0xffff;
+
+    private boolean first = true;
+
+    private long previous = 0;
+    private long current = 0;
+    private int delta = 0;
+
+    private long total = 0;
+
+
+
+    public void add(long v) {
+        if (first) {
+            first = false;
+            current = v;
+        }
+        previous = current;
+        current = v;
+        delta = difference(current, previous);
+        total += delta;
+    }
+
+
+    public void addUINT32(long v) {
+        // reset intead of rollover (no documentation found on rollover)
+
+        if (v < current) {
+            previous = v;
+            current = v;
+        }
+
+        add(v);
+    }
+
+
+    private static int difference(long newer, long older) {
+        if (newer > older)
+            return (int) (newer - older);
+
+        else if (older > newer)
+            return (int) ((newer + MAX_UINT16) - older);
+
+        return 0;
+    }
+
+
+    public int getDelta() {
+        return delta;
+    }
+
+    public long getTotal() {
+        return total;
+    }
+
+}
diff --git a/app/src/main/java/ch/bailu/aat/services/bluetooth_le/WheelCircumference.java b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/WheelCircumference.java
new file mode 100644
index 00000000..f5b8bae0
--- /dev/null
+++ b/app/src/main/java/ch/bailu/aat/services/bluetooth_le/WheelCircumference.java
@@ -0,0 +1,136 @@
+package ch.bailu.aat.services.bluetooth_le;
+
+import android.content.BroadcastReceiver;
+import android.content.Context;
+import android.content.Intent;
+
+import java.io.Closeable;
+
+import ch.bailu.aat.gpx.GpxDeltaHelper;
+import ch.bailu.aat.gpx.GpxInformation;
+import ch.bailu.aat.gpx.interfaces.GpxPointInterface;
+import ch.bailu.aat.services.ServiceContext;
+import ch.bailu.aat.util.AppBroadcaster;
+
+public class WheelCircumference implements Closeable {
+    private static final float MIN_SAMPLE_DISTANCE = 0.5f;
+    private static final float MAX_SAMPLE_DISTANCE = 100f;
+    private static final float MIN_ACCURACY = 5f;
+    private static final int MIN_REVOLUTIONS = 10;
+    private static final int SAMPLE_COUNT = 10;
+
+    private final ServiceContext scontext;
+    private final Revolution revolution;
+    private final Sample samples[] = new Sample[SAMPLE_COUNT];
+
+    private float distance;
+    private int revolutions;
+
+    private int next = 0;
+
+    private boolean registered = true;
+
+    private final BroadcastReceiver onLocationChanged = new BroadcastReceiver() {
+
+        @Override
+        public void onReceive(Context context, Intent intent) {
+            GpxInformation location = scontext.getLocationService().getLocationInformation();
+
+            if (location.getAccuracy() <= MIN_ACCURACY) {
+                samples[next] = new Sample(location, revolution.getTotalRevolutions());
+                next = (next + 1) % SAMPLE_COUNT;
+            }
+
+        }
+    };
+
+    public WheelCircumference (ServiceContext sc, Revolution r) {
+        scontext = sc;
+        revolution = r;
+        AppBroadcaster.register(sc.getContext(), onLocationChanged, AppBroadcaster.LOCATION_CHANGED);
+    }
+
+
+    public float getCircumference() {
+        if (haveAllSamples() && haveMinRevolutions() && haveUsableDistances()) {
+            return distance / revolutions;
+        }
+
+        return 0f;
+    }
+
+
+    private boolean haveAllSamples() {
+        for (Sample s : samples) {
+            if (s == null)
+                return false;
+        }
+
+        return true;
+    }
+
+
+    private boolean haveUsableDistances() {
+        int a = next;
+        int b = a++;
+
+        distance = 0f;
+
+        for (int i = 0; i < SAMPLE_COUNT - 1; i++) {
+            a = a % SAMPLE_COUNT;
+            b = b % SAMPLE_COUNT;
+
+
+            float d = GpxDeltaHelper.getDistance(samples[a].location, samples[b].location);
+
+            if (d < MIN_SAMPLE_DISTANCE || d > MAX_SAMPLE_DISTANCE)
+                return false;
+
+            distance += d;
+            a++;
+            b++;
+        }
+
+        return true;
+    }
+
+
+    private boolean haveMinRevolutions() {
+        revolutions = getRevolutions();
+
+        return revolutions >= MIN_REVOLUTIONS;
+
+    }
+
+
+    private int getRevolutions() {
+        int a = next;
+        int z = next-1;
+
+        if (z < 0) z = SAMPLE_COUNT-1;
+
+        long first = samples[a].revolutions;
+        long last = samples[z].revolutions;
+
+        return (int) (last - first);
+    }
+
+    @Override
+    public void close() {
+        if (registered) {
+            scontext.getContext().unregisterReceiver(onLocationChanged);
+            registered = false;
+        }
+    }
+
+
+    private static class Sample {
+        public final GpxPointInterface location;
+        public final long revolutions;
+
+        public Sample(GpxPointInterface l, long r) {
+            revolutions = r;
+            location = l;
+        }
+    }
+}
diff --git a/app/src/main/java/ch/bailu/aat/util/AppBroadcaster.java b/app/src/main/java/ch/bailu/aat/util/AppBroadcaster.java
index 99733919..3ec3db65 100644
--- a/app/src/main/java/ch/bailu/aat/util/AppBroadcaster.java
+++ b/app/src/main/java/ch/bailu/aat/util/AppBroadcaster.java
@@ -22,7 +22,7 @@ public class AppBroadcaster {
     public static final String DB_SYNC_CHANGED=NAME_SPACE+"SYNC_CHANGED";
 
     public static final String BLE_DEVICE_SCANNED = NAME_SPACE+"BLE_DEVICE_SCANNED";
-    public static final String BLE_DEVICE_NOTIFIED = NAME_SPACE + "BLE_NOTIFIED";
+    public static final String BLE_NOTIFIED = NAME_SPACE + "BLE_NOTIFIED";
 
     /** 
      *   Information about state changes of files (in cache and on disk)
