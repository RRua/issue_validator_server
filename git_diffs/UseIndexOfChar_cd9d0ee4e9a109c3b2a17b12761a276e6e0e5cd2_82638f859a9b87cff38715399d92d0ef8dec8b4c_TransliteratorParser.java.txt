diff --git a/app/src/main/java/com/ibm/icu/impl/SoftCache.java b/app/src/main/java/com/ibm/icu/impl/SoftCache.java
deleted file mode 100644
index e77f86c..0000000
--- a/app/src/main/java/com/ibm/icu/impl/SoftCache.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*
-*******************************************************************************
-*   Copyright (C) 2010-2011, International Business Machines
-*   Corporation and others.  All Rights Reserved.
-*******************************************************************************
-*/
-package com.ibm.icu.impl;
-
-import java.lang.ref.SoftReference;
-import java.util.concurrent.ConcurrentHashMap;
-
-/**
- * Generic, thread-safe cache implementation, storing SoftReferences to cached instances.
- * To use, instantiate a subclass which implements the createInstance() method,
- * and call get() with the key and the data. The get() call will use the data
- * only if it needs to call createInstance(), otherwise the data is ignored.
- *
- * By using SoftReferences to instances, the Java runtime can release instances
- * once they are not used any more at all. If such an instance is then requested again,
- * the get() method will call createInstance() again and also create a new SoftReference.
- * The cache holds on to its map of keys to SoftReferenced instances forever.
- *
- * @param <K> Cache lookup key type
- * @param <V> Cache instance value type
- * @param <D> Data type for creating a new instance value
- *
- * @author Markus Scherer, Mark Davis
- */
-public abstract class SoftCache<K, V, D> extends CacheBase<K, V, D> {
-    @Override
-    public final V getInstance(K key, D data) {
-        // We synchronize twice, once on the map and once on valueRef,
-        // because we prefer the fine-granularity locking of the ConcurrentHashMap
-        // over coarser locking on the whole cache instance.
-        // We use a SettableSoftReference (a second level of indirection) because
-        // ConcurrentHashMap.putIfAbsent() never replaces the key's value, and if it were
-        // a simple SoftReference we would not be able to reset its value after it has been cleared.
-        // (And ConcurrentHashMap.put() always replaces the value, which we don't want either.)
-        SettableSoftReference<V> valueRef = map.get(key);
-        V value;
-        if(valueRef != null) {
-            synchronized(valueRef) {
-                value = valueRef.ref.get();
-                if(value != null) {
-                    return value;
-                } else {
-                    // The instance has been evicted, its SoftReference cleared.
-                    // Create and set a new instance.
-                    value = createInstance(key, data);
-                    if (value != null) {
-                        valueRef.ref = new SoftReference<V>(value);
-                    }
-                    return value;
-                }
-            }
-        } else /* valueRef == null */ {
-            // We had never cached an instance for this key.
-            value = createInstance(key, data);
-            if (value == null) {
-                return null;
-            }
-            valueRef = map.putIfAbsent(key, new SettableSoftReference<V>(value));
-            if(valueRef == null) {
-                // Normal "put": Our new value is now cached.
-                return value;
-            } else {
-                // Race condition: Another thread beat us to putting a SettableSoftReference
-                // into the map. Return its value, but just in case the garbage collector
-                // was aggressive, we also offer our new instance for caching.
-                return valueRef.setIfAbsent(value);
-            }
-        }
-    }
-    /**
-     * Value type for cache items: Has a SoftReference which can be set
-     * to a new value when the SoftReference has been cleared.
-     * The SoftCache class sometimes accesses the ref field directly.
-     *
-     * @param <V> Cache instance value type
-     */
-    private static final class SettableSoftReference<V> {
-        private SettableSoftReference(V value) {
-            ref = new SoftReference<V>(value);
-        }
-        /**
-         * If the SoftReference has been cleared, then this replaces it with a new SoftReference
-         * for the new value and returns the new value; otherwise returns the current
-         * SoftReference's value.
-         * @param value Replacement value, for when the current reference has been cleared
-         * @return The value that is held by the SoftReference, old or new
-         */
-        private synchronized V setIfAbsent(V value) {
-            V oldValue = ref.get();
-            if(oldValue == null) {
-                ref = new SoftReference<V>(value);
-                return value;
-            } else {
-                return oldValue;
-            }
-        }
-        private SoftReference<V> ref;  // never null
-    }
-    private ConcurrentHashMap<K, SettableSoftReference<V>> map =
-        new ConcurrentHashMap<K, SettableSoftReference<V>>();
-}
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_da_DK.java b/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_da_DK.java
deleted file mode 100644
index 351cf3d..0000000
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_da_DK.java
+++ /dev/null
@@ -1,41 +0,0 @@
-/*
- *******************************************************************************
- * Copyright (C) 1996-2010, International Business Machines Corporation and    *
- * others. All Rights Reserved.                                                *
- *******************************************************************************
- */
-
-package com.ibm.icu.impl.data;
-
-import java.util.Calendar;
-import java.util.ListResourceBundle;
-
-import com.ibm.icu.util.EasterHoliday;
-import com.ibm.icu.util.Holiday;
-import com.ibm.icu.util.SimpleHoliday;
-
-public class HolidayBundle_da_DK extends ListResourceBundle
-{
-    static private final Holiday[] fHolidays = {
-        SimpleHoliday.NEW_YEARS_DAY,
-        new SimpleHoliday(Calendar.APRIL,   30, -Calendar.FRIDAY, "General Prayer Day"),
-        new SimpleHoliday(Calendar.JUNE,    5,                    "Constitution Day"),
-        SimpleHoliday.CHRISTMAS_EVE,
-        SimpleHoliday.CHRISTMAS,
-        SimpleHoliday.BOXING_DAY,
-        SimpleHoliday.NEW_YEARS_EVE,
-
-        // Easter and related holidays
-        EasterHoliday.MAUNDY_THURSDAY,
-        EasterHoliday.GOOD_FRIDAY,
-        EasterHoliday.EASTER_SUNDAY,
-        EasterHoliday.EASTER_MONDAY,
-        EasterHoliday.ASCENSION,
-        EasterHoliday.WHIT_MONDAY,
-    };
-
-    static private final Object[][] fContents = {
-        {   "holidays",             fHolidays },
-    };
-    public synchronized Object[][] getContents() { return fContents; }
-}
diff --git a/app/src/main/java/com/ibm/icu/text/CompactDecimalDataCache.java b/app/src/main/java/com/ibm/icu/text/CompactDecimalDataCache.java
deleted file mode 100644
index 6aa386b..0000000
--- a/app/src/main/java/com/ibm/icu/text/CompactDecimalDataCache.java
+++ /dev/null
@@ -1,462 +0,0 @@
-/*
- *******************************************************************************
- * Copyright (C) 2012-2016, International Business Machines Corporation and    *
- * others. All Rights Reserved.                                                *
- *******************************************************************************
- */
-package com.ibm.icu.text;
-
-import java.util.HashMap;
-import java.util.Map;
-import java.util.MissingResourceException;
-
-import com.ibm.icu.impl.ICUCache;
-import com.ibm.icu.impl.ICUResourceBundle;
-import com.ibm.icu.impl.SimpleCache;
-import com.ibm.icu.util.ULocale;
-import com.ibm.icu.util.UResourceBundle;
-
-/**
- * A cache containing data by locale for {@link CompactDecimalFormat}
- *
- * @author Travis Keep
- */
-class CompactDecimalDataCache {
-
-    private static final String SHORT_STYLE = "short";
-    private static final String LONG_STYLE = "long";
-    private static final String SHORT_CURRENCY_STYLE = "shortCurrency";
-    private static final String NUMBER_ELEMENTS = "NumberElements";
-    private static final String PATTERN_LONG_PATH = "patternsLong/decimalFormat";
-    private static final String PATTERNS_SHORT_PATH = "patternsShort/decimalFormat";
-    private static final String PATTERNS_SHORT_CURRENCY_PATH = "patternsShort/currencyFormat";
-
-    static final String OTHER = "other";
-
-    /**
-     * We can specify prefixes or suffixes for values with up to 15 digits,
-     * less than 10^15.
-     */
-    static final int MAX_DIGITS = 15;
-
-    private static final String LATIN_NUMBERING_SYSTEM = "latn";
-
-    private final ICUCache<ULocale, DataBundle> cache =
-            new SimpleCache<ULocale, DataBundle>();
-
-    /**
-     * Data contains the compact decimal data for a particular locale. Data consists
-     * of one array and two hashmaps. The index of the divisors array as well
-     * as the arrays stored in the values of the two hashmaps correspond
-     * to log10 of the number being formatted, so when formatting 12,345, the 4th
-     * index of the arrays should be used. Divisors contain the number to divide
-     * by before doing formatting. In the case of english, <code>divisors[4]</code>
-     * is 1000.  So to format 12,345, divide by 1000 to get 12. Then use
-     * PluralRules with the current locale to figure out which of the 6 plural variants
-     * 12 matches: "zero", "one", "two", "few", "many", or "other." Prefixes and
-     * suffixes are maps whose key is the plural variant and whose values are
-     * arrays of strings with indexes corresponding to log10 of the original number.
-     * these arrays contain the prefix or suffix to use.
-     *
-     * Each array in data is 15 in length, and every index is filled.
-     *
-     * @author Travis Keep
-     *
-     */
-    static class Data {
-        long[] divisors;
-        Map<String, DecimalFormat.Unit[]> units;
-
-        Data(long[] divisors, Map<String, DecimalFormat.Unit[]> units)
-        {
-            this.divisors = divisors;
-            this.units = units;
-        }
-    }
-
-    /**
-     * DataBundle contains compact decimal data for all the styles in a particular
-     * locale. Currently available styles are short and long for decimals, and
-     * short only for currencies.
-     *
-     * @author Travis Keep
-     */
-    static class DataBundle {
-        Data shortData;
-        Data longData;
-        Data shortCurrencyData;
-
-        DataBundle(Data shortData, Data longData, Data shortCurrencyData) {
-            this.shortData = shortData;
-            this.longData = longData;
-            this.shortCurrencyData = shortCurrencyData;
-        }
-    }
-
-    private static enum UResFlags {
-        ANY,  // Any locale will do.
-        NOT_ROOT  // Locale cannot be root.
-    }
-
-
-    /**
-     * Fetch data for a particular locale. Clients must not modify any part
-     * of the returned data. Portions of returned data may be shared so modifying
-     * it will have unpredictable results.
-     */
-    DataBundle get(ULocale locale) {
-        DataBundle result = cache.get(locale);
-        if (result == null) {
-            result = load(locale);
-            cache.put(locale, result);
-        }
-        return result;
-    }
-
-    /**
-     * Loads the "patternsShort" and "patternsLong" data for a particular locale.
-     * We look for both of them in 3 places in this order:<ol>
-     * <li>local numbering system no ROOT fallback</li>
-     * <li>latin numbering system no ROOT fallback</li>
-     * <li>latin numbering system ROOT locale.</li>
-     * </ol>
-     * If we find "patternsShort" data before finding "patternsLong" data, we
-     * make the "patternsLong" data be the same as "patternsShort."
-     * @param ulocale the locale for which we are loading the data.
-     * @return The returned data, never null.
-     */
-    private static DataBundle load(ULocale ulocale) {
-        NumberingSystem ns = NumberingSystem.getInstance(ulocale);
-        ICUResourceBundle r = (ICUResourceBundle)UResourceBundle.
-                getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, ulocale);
-        r = r.getWithFallback(NUMBER_ELEMENTS);
-        String numberingSystemName = ns.getName();
-
-        ICUResourceBundle shortDataBundle = null;
-        ICUResourceBundle longDataBundle = null;
-        ICUResourceBundle shortCurrencyDataBundle = null;
-        if (!LATIN_NUMBERING_SYSTEM.equals(numberingSystemName)) {
-            ICUResourceBundle bundle = findWithFallback(r, numberingSystemName, UResFlags.NOT_ROOT);
-            shortDataBundle = findWithFallback(bundle, PATTERNS_SHORT_PATH, UResFlags.NOT_ROOT);
-            longDataBundle = findWithFallback(bundle, PATTERN_LONG_PATH, UResFlags.NOT_ROOT);
-            shortCurrencyDataBundle = findWithFallback(bundle, PATTERNS_SHORT_CURRENCY_PATH, UResFlags.NOT_ROOT);
-        }
-
-        // If we haven't found, look in latin numbering system.
-        if (shortDataBundle == null) {
-            ICUResourceBundle bundle = getWithFallback(r, LATIN_NUMBERING_SYSTEM, UResFlags.ANY);
-            shortDataBundle = getWithFallback(bundle, PATTERNS_SHORT_PATH, UResFlags.ANY);
-            if (longDataBundle == null) {
-                longDataBundle = findWithFallback(bundle, PATTERN_LONG_PATH, UResFlags.ANY);
-                if (longDataBundle != null && isRoot(longDataBundle) && !isRoot(shortDataBundle)) {
-                    longDataBundle = null;
-                }
-            }
-        }
-        if (shortCurrencyDataBundle == null) {
-            ICUResourceBundle bundle = getWithFallback(r, LATIN_NUMBERING_SYSTEM, UResFlags.ANY);
-            shortCurrencyDataBundle = getWithFallback(bundle, PATTERNS_SHORT_CURRENCY_PATH, UResFlags.ANY);
-        }
-        Data shortData = loadStyle(shortDataBundle, ulocale, SHORT_STYLE);
-        Data longData;
-        if (longDataBundle == null) {
-            longData = shortData;
-        } else {
-            longData = loadStyle(longDataBundle, ulocale, LONG_STYLE);
-        }
-        Data shortCurrencyData = loadStyle(shortCurrencyDataBundle, ulocale, SHORT_CURRENCY_STYLE);
-        return new DataBundle(shortData, longData, shortCurrencyData);
-    }
-
-    /**
-     * findWithFallback finds a sub-resource bundle within r.
-     * @param r a resource bundle. It may be null in which case sub-resource bundle
-     *   won't be found.
-     * @param path the path relative to r
-     * @param flags ANY or NOT_ROOT for locale of found sub-resource bundle.
-     * @return The sub-resource bundle or NULL if none found.
-     */
-    private static ICUResourceBundle findWithFallback(
-            ICUResourceBundle r, String path, UResFlags flags) {
-        if (r == null) {
-            return null;
-        }
-        ICUResourceBundle result = r.findWithFallback(path);
-        if (result == null) {
-            return null;
-        }
-        switch (flags) {
-        case NOT_ROOT:
-            return isRoot(result) ? null : result;
-        case ANY:
-            return result;
-        default:
-            throw new IllegalArgumentException();
-        }
-    }
-
-    /**
-     * Like findWithFallback but throws MissingResourceException if no
-     * resource found instead of returning null.
-     */
-    private static ICUResourceBundle getWithFallback(
-            ICUResourceBundle r, String path, UResFlags flags) {
-        ICUResourceBundle result = findWithFallback(r, path, flags);
-        if (result == null) {
-            throw new MissingResourceException(
-                    "Cannot find " + path,
-                    ICUResourceBundle.class.getName(), path);
-
-        }
-        return result;
-    }
-
-    /**
-     * isRoot returns true if r is in root locale or false otherwise.
-     */
-    private static boolean isRoot(ICUResourceBundle r) {
-        ULocale bundleLocale = r.getULocale();
-        // Note: bundleLocale for root should be ULocale.ROOT, which is equivalent to new ULocale("").
-        // However, resource bundle might be initialized with locale ID "root", which should be
-        // actually normalized to "" in ICUResourceBundle. For now, this logic also compare to
-        // "root", not just ULocale.ROOT.
-        return bundleLocale.equals(ULocale.ROOT) || bundleLocale.toString().equals("root");
-    }
-
-    /**
-     * Loads the data
-     * @param r the main resource bundle.
-     * @param numberingSystemName The namespace name.
-     * @param allowNullResult If true, returns null if no data can be found
-     * for particular locale and style. If false, throws a runtime exception
-     * if data cannot be found.
-     * @return The loaded data or possibly null if allowNullResult is true.
-     */
-    private static Data loadStyle(ICUResourceBundle r, ULocale locale, String style) {
-        int size = r.getSize();
-        Data result = new Data(
-                new long[MAX_DIGITS],
-                new HashMap<String, DecimalFormat.Unit[]>());
-        for (int i = 0; i < size; i++) {
-            populateData(r.get(i), locale, style, result);
-        }
-        fillInMissing(result);
-        return result;
-    }
-
-    /**
-     * Populates Data object with data for a particular divisor from resource bundle.
-     * @param divisorData represents the rules for numbers of a particular size.
-     * This may look like:
-     * <pre>
-     *   10000{
-     *       few{"00K"}
-     *       many{"00K"}
-     *       one{"00 xnb"}
-     *       other{"00 xnb"}
-     *   }
-     * </pre>
-     * @param locale the locale
-     * @param style the style
-     * @param result rule stored here.
-     *
-     */
-    private static void populateData(
-            UResourceBundle divisorData, ULocale locale, String style, Data result) {
-        // This value will always be some even pwoer of 10. e.g 10000.
-        long magnitude = Long.parseLong(divisorData.getKey());
-        int thisIndex = (int) Math.log10(magnitude);
-
-        // Silently ignore divisors that are too big.
-        if (thisIndex >= MAX_DIGITS) {
-            return;
-        }
-
-        int size = divisorData.getSize();
-
-        // keep track of how many zeros are used in the plural variants.
-        // For "00K" this would be 2. This number must be the same for all
-        // plural variants. If they differ, we throw a runtime exception as
-        // such an anomaly is unrecoverable. We expect at least one zero.
-        int numZeros = 0;
-
-        // Keep track if this block defines "other" variant. If a block
-        // fails to define the "other" variant, we must immediately throw
-        // an exception as it is assumed that "other" variants are always
-        // defined.
-        boolean otherVariantDefined = false;
-
-        // Loop over all the plural variants. e.g one, other.
-        for (int i = 0; i < size; i++) {
-            UResourceBundle pluralVariantData = divisorData.get(i);
-            String pluralVariant = pluralVariantData.getKey();
-            String template = pluralVariantData.getString();
-            if (pluralVariant.equals(OTHER)) {
-                otherVariantDefined = true;
-            }
-            int nz = populatePrefixSuffix(
-                    pluralVariant, thisIndex, template, locale, style, result);
-            if (nz != numZeros) {
-                if (numZeros != 0) {
-                    throw new IllegalArgumentException(
-                        "Plural variant '" + pluralVariant + "' template '" +
-                        template + "' for 10^" + thisIndex +
-                        " has wrong number of zeros in " + localeAndStyle(locale, style));
-                }
-                numZeros = nz;
-            }
-        }
-
-        if (!otherVariantDefined) {
-            throw new IllegalArgumentException(
-                    "No 'other' plural variant defined for 10^" + thisIndex +
-                    "in " +localeAndStyle(locale, style));
-        }
-
-        // We craft our divisor such that when we divide by it, we get a
-        // number with the same number of digits as zeros found in the
-        // plural variant templates. If our magnitude is 10000 and we have
-        // two 0's in our plural variants, then we want a divisor of 1000.
-        // Note that if we have 43560 which is of same magnitude as 10000.
-        // When we divide by 1000 we a quotient which rounds to 44 (2 digits)
-        long divisor = magnitude;
-        for (int i = 1; i < numZeros; i++) {
-            divisor /= 10;
-        }
-        result.divisors[thisIndex] = divisor;
-    }
-
-
-    /**
-     * Populates prefix and suffix information for a particular plural variant
-     * and index (log10 value).
-     * @param pluralVariant e.g "one", "other"
-     * @param idx the index (log10 value of the number) 0 <= idx < MAX_DIGITS
-     * @param template e.g "00K"
-     * @param locale the locale
-     * @param style the style
-     * @param result Extracted prefix and suffix stored here.
-     * @return number of zeros found before any decimal point in template.
-     */
-    private static int populatePrefixSuffix(
-            String pluralVariant, int idx, String template, ULocale locale, String style,
-            Data result) {
-        int firstIdx = template.indexOf("0");
-        int lastIdx = template.lastIndexOf("0");
-        if (firstIdx == -1) {
-            throw new IllegalArgumentException(
-                "Expect at least one zero in template '" + template +
-                "' for variant '" +pluralVariant + "' for 10^" + idx +
-                " in " + localeAndStyle(locale, style));
-        }
-        String prefix = template.substring(0, firstIdx);
-        String suffix = template.substring(lastIdx + 1);
-        saveUnit(new DecimalFormat.Unit(prefix, suffix), pluralVariant, idx, result.units);
-
-        // If there is effectively no prefix or suffix, ignore the actual
-        // number of 0's and act as if the number of 0's matches the size
-        // of the number
-        if (prefix.trim().length() == 0 && suffix.trim().length() == 0) {
-          return idx + 1;
-        }
-
-        // Calculate number of zeros before decimal point.
-        int i = firstIdx + 1;
-        while (i <= lastIdx && template.charAt(i) == '0') {
-            i++;
-        }
-        return i - firstIdx;
-    }
-
-
-    /**
-     * Returns locale and style. Used to form useful messages in thrown
-     * exceptions.
-     * @param locale the locale
-     * @param style the style
-     */
-    private static String localeAndStyle(ULocale locale, String style) {
-        return "locale '" + locale + "' style '" + style + "'";
-    }
-
-    /**
-     * After reading information from resource bundle into a Data object, there
-     * is guarantee that it is complete.
-     *
-     * This method fixes any incomplete data it finds within <code>result</code>.
-     * It looks at each log10 value applying the two rules.
-     *   <p>
-     *   If no prefix is defined for the "other" variant, use the divisor, prefixes and
-     *   suffixes for all defined variants from the previous log10. For log10 = 0,
-     *   use all empty prefixes and suffixes and a divisor of 1.
-     *   </p><p>
-     *   Otherwise, examine each plural variant defined for the given log10 value.
-     *   If it has no prefix and suffix for a particular variant, use the one from the
-     *   "other" variant.
-     *   </p>
-     *
-     * @param result this instance is fixed in-place.
-     */
-    private static void fillInMissing(Data result) {
-        // Initially we assume that previous divisor is 1 with no prefix or suffix.
-        long lastDivisor = 1L;
-        for (int i = 0; i < result.divisors.length; i++) {
-            if (result.units.get(OTHER)[i] == null) {
-                result.divisors[i] = lastDivisor;
-                copyFromPreviousIndex(i, result.units);
-            } else {
-                lastDivisor = result.divisors[i];
-                propagateOtherToMissing(i, result.units);
-            }
-        }
-    }
-
-    private static void propagateOtherToMissing(
-            int idx, Map<String, DecimalFormat.Unit[]> units) {
-        DecimalFormat.Unit otherVariantValue = units.get(OTHER)[idx];
-        for (DecimalFormat.Unit[] byBase : units.values()) {
-            if (byBase[idx] == null) {
-                byBase[idx] = otherVariantValue;
-            }
-        }
-    }
-
-    private static void copyFromPreviousIndex(int idx, Map<String, DecimalFormat.Unit[]> units) {
-        for (DecimalFormat.Unit[] byBase : units.values()) {
-            if (idx == 0) {
-                byBase[idx] = DecimalFormat.NULL_UNIT;
-            } else {
-                byBase[idx] = byBase[idx - 1];
-            }
-        }
-    }
-
-    private static void saveUnit(
-            DecimalFormat.Unit unit, String pluralVariant, int idx,
-            Map<String, DecimalFormat.Unit[]> units) {
-        DecimalFormat.Unit[] byBase = units.get(pluralVariant);
-        if (byBase == null) {
-            byBase = new DecimalFormat.Unit[MAX_DIGITS];
-            units.put(pluralVariant, byBase);
-        }
-        byBase[idx] = unit;
-
-    }
-
-    /**
-     * Fetches a prefix or suffix given a plural variant and log10 value. If it
-     * can't find the given variant, it falls back to "other".
-     * @param prefixOrSuffix the prefix or suffix map
-     * @param variant the plural variant
-     * @param base log10 value. 0 <= base < MAX_DIGITS.
-     * @return the prefix or suffix.
-     */
-    static DecimalFormat.Unit getUnit(
-            Map<String, DecimalFormat.Unit[]> units, String variant, int base) {
-        DecimalFormat.Unit[] byBase = units.get(variant);
-        if (byBase == null) {
-            byBase = units.get(CompactDecimalDataCache.OTHER);
-        }
-        return byBase[base];
-    }
-}
diff --git a/app/src/main/java/com/ibm/icu/text/SpoofChecker.java b/app/src/main/java/com/ibm/icu/text/SpoofChecker.java
deleted file mode 100644
index 7a5fcbe..0000000
--- a/app/src/main/java/com/ibm/icu/text/SpoofChecker.java
+++ /dev/null
@@ -1,2495 +0,0 @@
-/*
- ***************************************************************************
- * Copyright (C) 2008-2016 International Business Machines Corporation
- * and others. All Rights Reserved.
- ***************************************************************************
- *
- * Unicode Spoof Detection
- */
-
-package com.ibm.icu.text;
-
-import java.io.DataOutputStream;
-import java.io.IOException;
-import java.io.LineNumberReader;
-import java.io.Reader;
-import java.nio.ByteBuffer;
-import java.text.ParseException;
-import java.util.ArrayList;
-import java.util.Arrays;
-import java.util.Collections;
-import java.util.Comparator;
-import java.util.HashSet;
-import java.util.Hashtable;
-import java.util.LinkedHashSet;
-import java.util.Locale;
-import java.util.Set;
-import java.util.Vector;
-import java.util.regex.Matcher;
-import java.util.regex.Pattern;
-
-import com.ibm.icu.impl.ICUBinary;
-import com.ibm.icu.impl.ICUBinary.Authenticate;
-import com.ibm.icu.impl.Trie2;
-import com.ibm.icu.impl.Trie2Writable;
-import com.ibm.icu.lang.UCharacter;
-import com.ibm.icu.lang.UCharacterCategory;
-import com.ibm.icu.lang.UProperty;
-import com.ibm.icu.lang.UScript;
-import com.ibm.icu.util.ULocale;
-
-/**
- *
- * <b>Unicode Security and Spoofing Detection.</b>
- *
- * <p>This class is intended to check strings, typically
- * identifiers of some type, such as URLs, for the presence of
- * characters that are likely to be visually confusing -
- * for cases where the displayed form of an identifier may
- * not be what it appears to be.
- *
- * <p>Unicode Technical Report #36,
- * <a href="http://unicode.org/reports/tr36">http://unicode.org/reports/tr36</a> and
- * Unicode Technical Standard #39,
- * <a href="http://unicode.org/reports/tr39">http://unicode.org/reports/tr39</a>
- * "Unicode security considerations", give more background on
- * security and spoofing issues with Unicode identifiers.
- * The tests and checks provided by this module implement the recommendations
- * from these Unicode documents.
- *
- * <p>The tests available on identifiers fall into two general categories:
- *   <ul>
- *     <li>  Single identifier tests.  Check whether an identifier is
- *       potentially confusable with any other string, or is suspicious
- *       for other reasons. </li>
- *     <li> Two identifier tests.  Check whether two specific identifiers are confusable.
- *       This does not consider whether either of strings is potentially
- *       confusable with any string other than the exact one specified. </li>
- *   </ul>
- *
- * <p>The steps to perform confusability testing are
- *   <ul>
- *     <li>  Create a <code>SpoofChecker.Builder</code> </li>
- *     <li>  Configure the Builder for the desired set of tests.  The tests that will
- *           be performed are specified by a set of SpoofCheck flags. </li>
- *     <li>  Build a <code>SpoofChecker</code> from the Builder. </li>
- *     <li>  Perform the checks using the pre-configured <code>SpoofChecker</code>.  The results indicate
- *           which (if any) of the selected tests have identified possible problems with the identifier.
- *           Results are reported as a set of SpoofCheck flags;  this mirrors the form in which
- *           the set of tests to perform was originally specified to the SpoofChecker. </li>
- *    </ul>
- *
- * <p>A <code>SpoofChecker</code> instance may be used repeatedly to perform checks on any number
- *    of identifiers.
- *
- * <p>Thread Safety: The methods on SpoofChecker objects are thread safe.
- * The test functions for checking a single identifier, or for testing
- * whether two identifiers are potentially confusable,  may called concurrently
- * from multiple threads using the same SpoofChecker instance.
- *
- *
- * <p>Descriptions of the available checks.
- *
- * <p>When testing whether pairs of identifiers are confusable, with <code>areConfusable()</code>
- * the relevant tests are
- *
- *  <ul>
- *   <li> <code>SINGLE_SCRIPT_CONFUSABLE</code>:  All of the characters from the two identifiers are
- *      from a single script, and the two identifiers are visually confusable.</li>
- *   <li> <code>MIXED_SCRIPT_CONFUSABLE</code>:  At least one of the identifiers contains characters
- *      from more than one script, and the two identifiers are visually confusable.</li>
- *   <li> <code>WHOLE_SCRIPT_CONFUSABLE</code>: Each of the two identifiers is of a single script, but
- *      the the two identifiers are from different scripts, and they are visually confusable.</li>
- *  </ul>
- *
- * <p>The safest approach is to enable all three of these checks as a group.
- *
- * <p><code>ANY_CASE</code> is a modifier for the above tests.  If the identifiers being checked can
- * be of mixed case and are used in a case-sensitive manner, this option should be specified.
- *
- * <p>If the identifiers being checked are used in a case-insensitive manner, and if they are
- * displayed to users in lower-case form only, the <code>ANY_CASE</code> option should not be
- * specified.  Confusabality issues involving upper case letters will not be reported.
- *
- * <p>When performing tests on a single identifier, with the check() family of functions,
- * the relevant tests are:
- *
- *  <ul>
- *    <li><code>MIXED_SCRIPT_CONFUSABLE</code>: the identifier contains characters from multiple
- *       scripts, and there exists an identifier of a single script that is visually confusable.</li>
- *    <li><code>WHOLE_SCRIPT_CONFUSABLE</code>: the identifier consists of characters from a single
- *       script, and there exists a visually confusable identifier.
- *       The visually confusable identifier also consists of characters from a single script.
- *       but not the same script as the identifier being checked.</li>
- *    <li><code>ANY_CASE</code>: modifies the mixed script and whole script confusables tests.  If
- *       specified, the checks will find confusable characters of any case.
- *       If this flag is not set, the test is performed assuming case folded identifiers.</li>
- *    <li><code>SINGLE_SCRIPT</code>: check that the identifier contains only characters from a
- *       single script.  (Characters from the <em>common</em> and <em>inherited</em> scripts are ignored.)
- *       This is not a test for confusable identifiers</li>
- *    <li><code>INVISIBLE</code>: check an identifier for the presence of invisible characters,
- *       such as zero-width spaces, or character sequences that are
- *       likely not to display, such as multiple occurrences of the same
- *       non-spacing mark.  This check does not test the input string as a whole
- *       for conformance to any particular syntax for identifiers.</li>
- *    <li><code>CHAR_LIMIT</code>: check that an identifier contains only characters from a specified set
- *       of acceptable characters.  See <code>Builder.setAllowedChars()</code> and
- *       <code>Builder.setAllowedLocales()</code>.</li>
- *  </ul>
- *
- *  <p>Note on Scripts:
- *     <blockquote>Characters from the Unicode Scripts "Common" and "Inherited" are ignored when considering
- *     the script of an identifier. Common characters include digits and symbols that
- *     are normally used with text from many different scripts. </blockquote>
- *
- * @stable ICU 4.6
- */
-public class SpoofChecker {
-
-    /**
-     * Constants from UAX 31 for use in setRestrictionLevel.
-     * @stable ICU 53
-     */
-    public enum RestrictionLevel {
-        /**
-         * Only ASCII characters: U+0000..U+007F
-         *
-         * @stable ICU 53
-         */
-        ASCII,
-        /**
-         * All characters in each identifier must be from a single script.
-         * 
-         * @stable ICU 53
-         */
-        SINGLE_SCRIPT_RESTRICTIVE,
-         /**
-         * All characters in each identifier must be from a single script, or from the combinations: Latin + Han +
-         * Hiragana + Katakana; Latin + Han + Bopomofo; or Latin + Han + Hangul. Note that this level will satisfy the
-         * vast majority of Latin-script users; also that TR36 has ASCII instead of Latin.
-         *
-         * @stable ICU 53
-         */
-        HIGHLY_RESTRICTIVE,
-        /**
-         * Allow Latin with other scripts except Cyrillic, Greek, Cherokee Otherwise, the same as Highly Restrictive
-         *
-         * @stable ICU 53
-         */
-        MODERATELY_RESTRICTIVE,
-        /**
-         * Allow arbitrary mixtures of scripts, such as Ωmega, Teχ, HλLF-LIFE, Toys-Я-Us. Otherwise, the same as
-         * Moderately Restrictive
-         *
-         * @stable ICU 53
-         */
-        MINIMALLY_RESTRICTIVE,
-        /**
-         * Any valid identifiers, including characters outside of the Identifier Profile, such as I♥NY.org
-         *
-         * @stable ICU 53
-         */
-        UNRESTRICTIVE
-    }
-
-
-    /**
-     * Security Profile constant from UAX 31 for use in setAllowedChars.
-     * Will probably be replaced by UnicodeSet property.
-     * @internal
-     * @deprecated This API is ICU internal only.
-     */
-    @Deprecated
-    public static final UnicodeSet INCLUSION = new UnicodeSet("[" +
-            "\\u0027\\u002D-\\u002E\\u003A\\u00B7\\u0375\\u058A\\u05F3-\\u05F4"+
-            "\\u06FD-\\u06FE\\u0F0B\\u200C-\\u200D\\u2010\\u2019\\u2027\\u30A0\\u30FB]").freeze();
-        // Note: data from http://unicode.org/Public/security/latest/xidmodifications.txt version 6.3.0
-
-    /**
-     * Security Profile constant from UAX 31 for use in setAllowedChars.
-     * Will probably be replaced by UnicodeSet property.
-     * @internal
-     * @deprecated This API is ICU internal only.
-     */
-    @Deprecated
-    public static final UnicodeSet RECOMMENDED = new UnicodeSet(
-            "[\\u0030-\\u0039\\u0041-\\u005A\\u005F\\u0061-\\u007A\\u00C0-\\u00D6\\u00D8-\\u00F6" +
-            "\\u00F8-\\u0131\\u0134-\\u013E\\u0141-\\u0148\\u014A-\\u017E\\u018F\\u01A0-\\u01A1" +
-            "\\u01AF-\\u01B0\\u01CD-\\u01DC\\u01DE-\\u01E3\\u01E6-\\u01F0\\u01F4-\\u01F5\\u01F8-\\u021B" +
-            "\\u021E-\\u021F\\u0226-\\u0233\\u0259\\u02BB-\\u02BC\\u02EC\\u0300-\\u0304\\u0306-\\u030C" +
-            "\\u030F-\\u0311\\u0313-\\u0314\\u031B\\u0323-\\u0328\\u032D-\\u032E\\u0330-\\u0331" +
-            "\\u0335\\u0338-\\u0339\\u0342\\u0345\\u037B-\\u037D\\u0386\\u0388-\\u038A\\u038C" +
-            "\\u038E-\\u03A1\\u03A3-\\u03CE\\u03FC-\\u045F\\u048A-\\u0529\\u052E-\\u052F\\u0531-\\u0556" +
-            "\\u0559\\u0561-\\u0586\\u05B4\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0620-\\u063F\\u0641-\\u0655" +
-            "\\u0660-\\u0669\\u0670-\\u0672\\u0674\\u0679-\\u068D\\u068F-\\u06D3\\u06D5\\u06E5-\\u06E6" +
-            "\\u06EE-\\u06FC\\u06FF\\u0750-\\u07B1\\u08A0-\\u08AC\\u08B2\\u0901-\\u094D\\u094F-\\u0950" +
-            "\\u0956-\\u0957\\u0960-\\u0963\\u0966-\\u096F\\u0971-\\u0977\\u0979-\\u097F\\u0981-\\u0983" +
-            "\\u0985-\\u098C\\u098F-\\u0990\\u0993-\\u09A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9" +
-            "\\u09BC-\\u09C4\\u09C7-\\u09C8\\u09CB-\\u09CE\\u09D7\\u09E0-\\u09E3\\u09E6-\\u09F1" +
-            "\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F-\\u0A10\\u0A13-\\u0A28\\u0A2A-\\u0A30\\u0A32" +
-            "\\u0A35\\u0A38-\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47-\\u0A48\\u0A4B-\\u0A4D\\u0A5C" +
-            "\\u0A66-\\u0A74\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A93-\\u0AA8\\u0AAA-\\u0AB0" +
-            "\\u0AB2-\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0ACB-\\u0ACD\\u0AD0" +
-            "\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F-\\u0B10\\u0B13-\\u0B28" +
-            "\\u0B2A-\\u0B30\\u0B32-\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B43\\u0B47-\\u0B48\\u0B4B-\\u0B4D" +
-            "\\u0B56-\\u0B57\\u0B5F-\\u0B61\\u0B66-\\u0B6F\\u0B71\\u0B82-\\u0B83\\u0B85-\\u0B8A" +
-            "\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99-\\u0B9A\\u0B9C\\u0B9E-\\u0B9F\\u0BA3-\\u0BA4" +
-            "\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0BD0" +
-            "\\u0BD7\\u0BE6-\\u0BEF\\u0C01-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28" +
-            "\\u0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55-\\u0C56" +
-            "\\u0C60-\\u0C61\\u0C66-\\u0C6F\\u0C82-\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92-\\u0CA8" +
-            "\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0CD5-\\u0CD6" +
-            "\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1-\\u0CF2\\u0D02-\\u0D03\\u0D05-\\u0D0C\\u0D0E-\\u0D10" +
-            "\\u0D12-\\u0D3A\\u0D3D-\\u0D43\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D57\\u0D60-\\u0D61" +
-            "\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82-\\u0D83\\u0D85-\\u0D8E\\u0D91-\\u0D96\\u0D9A-\\u0DA5" +
-            "\\u0DA7-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0DD4\\u0DD6" +
-            "\\u0DD8-\\u0DDE\\u0DF2\\u0E01-\\u0E32\\u0E34-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\u0E59" +
-            "\\u0E81-\\u0E82\\u0E84\\u0E87-\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F" +
-            "\\u0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA-\\u0EAB\\u0EAD-\\u0EB2\\u0EB4-\\u0EB9\\u0EBB-\\u0EBD" +
-            "\\u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDE-\\u0EDF\\u0F00\\u0F20-\\u0F29" +
-            "\\u0F35\\u0F37\\u0F3E-\\u0F42\\u0F44-\\u0F47\\u0F49-\\u0F4C\\u0F4E-\\u0F51\\u0F53-\\u0F56" +
-            "\\u0F58-\\u0F5B\\u0F5D-\\u0F68\\u0F6A-\\u0F6C\\u0F71-\\u0F72\\u0F74\\u0F7A-\\u0F80" +
-            "\\u0F82-\\u0F84\\u0F86-\\u0F92\\u0F94-\\u0F97\\u0F99-\\u0F9C\\u0F9E-\\u0FA1\\u0FA3-\\u0FA6" +
-            "\\u0FA8-\\u0FAB\\u0FAD-\\u0FB8\\u0FBA-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D" +
-            "\\u10C7\\u10CD\\u10D0-\\u10F0\\u10F7-\\u10FA\\u10FD-\\u10FF\\u1200-\\u1248\\u124A-\\u124D" +
-            "\\u1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0" +
-            "\\u12B2-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310" +
-            "\\u1312-\\u1315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u1780-\\u17A2\\u17A5-\\u17A7" +
-            "\\u17A9-\\u17B3\\u17B6-\\u17CA\\u17D2\\u17D7\\u17DC\\u17E0-\\u17E9\\u1E00-\\u1E99" +
-            "\\u1E9E\\u1EA0-\\u1EF9\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D" +
-            "\\u1F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F70\\u1F72\\u1F74\\u1F76\\u1F78" +
-            "\\u1F7A\\u1F7C\\u1F80-\\u1FB4\\u1FB6-\\u1FBA\\u1FBC\\u1FC2-\\u1FC4\\u1FC6-\\u1FC8" +
-            "\\u1FCA\\u1FCC\\u1FD0-\\u1FD2\\u1FD6-\\u1FDA\\u1FE0-\\u1FE2\\u1FE4-\\u1FEA\\u1FEC" +
-            "\\u1FF2-\\u1FF4\\u1FF6-\\u1FF8\\u1FFA\\u1FFC\\u2D27\\u2D2D\\u2D80-\\u2D96\\u2DA0-\\u2DA6" +
-            "\\u2DA8-\\u2DAE\\u2DB0-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6" +
-            "\\u2DD8-\\u2DDE\\u3005-\\u3007\\u3041-\\u3096\\u3099-\\u309A\\u309D-\\u309E\\u30A1-\\u30FA" +
-            "\\u30FC-\\u30FE\\u3105-\\u312D\\u31A0-\\u31BA\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA660-\\uA661" +
-            "\\uA674-\\uA67B\\uA67F\\uA69F\\uA717-\\uA71F\\uA788\\uA78D-\\uA78E\\uA790-\\uA793" +
-            "\\uA7A0-\\uA7AA\\uA7FA\\uA9E7-\\uA9FE\\uAA60-\\uAA76\\uAA7A-\\uAA7F\\uAB01-\\uAB06" +
-            "\\uAB09-\\uAB0E\\uAB11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAC00-\\uD7A3\\uFA0E-\\uFA0F" +
-            "\\uFA11\\uFA13-\\uFA14\\uFA1F\\uFA21\\uFA23-\\uFA24\\uFA27-\\uFA29\\U00020000-\\U0002A6D6" +
-            "\\U0002A700-\\U0002B734\\U0002B740-\\U0002B81D\\U0002B820-\\U0002CEA1]"
-            ).freeze();
-            // Note: data from http://unicode.org/Public/security/latest/xidmodifications.txt version 8.0.0
-            //       There is no tooling to generate this from the .txt file,
-            //       copy the set contents from ICU4C source/i18n/uspoof.cpp recommendedPat.
-            //       (Add '+' for string concatenation.)
-
-    /**
-     * Constants for the kinds of checks that USpoofChecker can perform. These values are used both to select the set of
-     * checks that will be performed, and to report results from the check function.
-     *
-     */
-
-    /**
-     * Single script confusable test. When testing whether two identifiers are confusable, report that they are if both
-     * are from the same script and they are visually confusable. Note: this test is not applicable to a check of a
-     * single identifier.
-     *
-     * @stable ICU 4.6
-     */
-    public static final int SINGLE_SCRIPT_CONFUSABLE = 1;
-
-    /**
-     * Mixed script confusable test.
-     *
-     * <p>When checking a single identifier, report a problem if the identifier contains multiple scripts, and is also
-     * confusable with some other identifier in a single script.
-     *
-     * <p>When testing whether two identifiers are confusable, report that they are if the two IDs are visually confusable,
-     * and and at least one contains characters from more than one script.
-     *
-     * @stable ICU 4.6
-     */
-    public static final int MIXED_SCRIPT_CONFUSABLE = 2;
-
-    /**
-     * Whole script confusable test.
-     *
-     * <p>When checking a single identifier, report a problem if The identifier is of a single script, and there exists a
-     * confusable identifier in another script.
-     *
-     * <p>When testing whether two Identifiers are confusable, report that they are if each is of a single script, the
-     * scripts of the two identifiers are different, and the identifiers are visually confusable.
-     *
-     * @stable ICU 4.6
-     */
-    public static final int WHOLE_SCRIPT_CONFUSABLE = 4;
-
-    /**
-     * Any Case Modifier for confusable identifier tests.
-     *
-     * <p>When specified, consider all characters, of any case, when looking for confusables. If ANY_CASE is not specified,
-     * identifiers being checked are assumed to have been case folded, and upper case conusable characters will not be
-     * checked.
-     *
-     * @stable ICU 4.6
-     */
-    public static final int ANY_CASE = 8;
-
-    /**
-     * Check that an identifier is no looser than the specified RestrictionLevel.
-     * The default if this is not called is HIGHLY_RESTRICTIVE.
-     *
-     * @internal
-     * @deprecated This API is ICU internal only.
-     */
-    @Deprecated
-    public static final int RESTRICTION_LEVEL = 16;
-
-    /**
-     * Check that an identifer contains only characters from a single script (plus chars from the common and inherited
-     * scripts.) Applies to checks of a single identifier check only.
-     *
-     * @deprecated ICU 51 Use RESTRICTION_LEVEL
-     */
-    @Deprecated
-    public static final int SINGLE_SCRIPT = RESTRICTION_LEVEL;
-
-    /**
-     * Check an identifier for the presence of invisible characters, such as zero-width spaces, or character sequences
-     * that are likely not to display, such as multiple occurrences of the same non-spacing mark. This check does not
-     * test the input string as a whole for conformance to any particular syntax for identifiers.
-     *
-     * @stable ICU 4.6
-     */
-    public static final int INVISIBLE = 32;
-
-    /**
-     * Check that an identifier contains only characters from a specified set of acceptable characters. See
-     * Builder.setAllowedChars() and Builder.setAllowedLocales().
-     *
-     * @stable ICU 4.6
-     */
-    public static final int CHAR_LIMIT = 64;
-
-    /**
-     * Check that an identifier does not mix numbers.
-     *
-     * @internal
-     * @deprecated This API is ICU internal only.
-     */
-    @Deprecated
-    public static final int MIXED_NUMBERS = 128;
-
-    // Update CheckResult.toString() when a new check is added.
-
-    /**
-     * Enable all spoof checks.
-     *
-     * @stable ICU 4.6
-     */
-    public static final int ALL_CHECKS = 0xFFFFFFFF;
-
-
-    // Magic number for sanity checking spoof binary resource data.
-    static final int MAGIC = 0x3845fdef;
-
-    /**
-     * private constructor: a SpoofChecker has to be built by the builder
-     */
-    private SpoofChecker() {
-    }
-
-    /**
-     * SpoofChecker Builder. To create a SpoofChecker, first instantiate a SpoofChecker.Builder, set the desired
-     * checking options on the builder, then call the build() function to create a SpoofChecker instance.
-     *
-     * @stable ICU 4.6
-     */
-    public static class Builder {
-        int fChecks; // Bit vector of checks to perform.
-        SpoofData fSpoofData;
-        final UnicodeSet fAllowedCharsSet = new UnicodeSet(0, 0x10ffff); // The UnicodeSet of allowed characters.
-        // for this Spoof Checker. Defaults to all chars.
-        final Set<ULocale> fAllowedLocales = new LinkedHashSet<ULocale>(); // The list of allowed locales.
-        private RestrictionLevel fRestrictionLevel;
-
-        /**
-         * Constructor: Create a default Unicode Spoof Checker Builder, configured to perform all checks except for
-         * LOCALE_LIMIT and CHAR_LIMIT. Note that additional checks may be added in the future, resulting in the changes
-         * to the default checking behavior.
-         *
-         * @stable ICU 4.6
-         */
-        public Builder() {
-            fChecks = ALL_CHECKS;
-            fSpoofData = null;
-            fRestrictionLevel = RestrictionLevel.HIGHLY_RESTRICTIVE;
-        }
-
-        /**
-         * Constructor: Create a Spoof Checker Builder, and set the configuration from an existing SpoofChecker.
-         *
-         * @param src
-         *            The existing checker.
-         * @stable ICU 4.6
-         */
-        public Builder(SpoofChecker src) {
-            fChecks = src.fChecks;
-            fSpoofData = src.fSpoofData;      // For the data, we will either use the source data
-                                              //   as-is, or drop the builder's reference to it
-                                              //   and generate new data, depending on what our
-                                              //   caller does with the builder.
-            fAllowedCharsSet.set(src.fAllowedCharsSet);
-            fAllowedLocales.addAll(src.fAllowedLocales);
-            fRestrictionLevel = src.fRestrictionLevel;
-        }
-
-        /**
-         * Create a SpoofChecker with current configuration.
-         *
-         * @return SpoofChecker
-         * @stable ICU 4.6
-         */
-        public SpoofChecker build() {
-            if (fSpoofData == null) { // read binary file
-                fSpoofData = SpoofData.getDefault();
-            }
-
-            // Copy all state from the builder to the new SpoofChecker.
-            //  Make sure that everything is either cloned or copied, so
-            //  that subsequent re-use of the builder won't modify the built
-            //  SpoofChecker.
-            //
-            //  One exception to this: the SpoofData is just assigned.
-            //  If the builder subsequently needs to modify fSpoofData
-            //  it will create a new SpoofData object first.
-
-
-            SpoofChecker result = new SpoofChecker();
-            result.fChecks = this.fChecks;
-            result.fSpoofData = this.fSpoofData;
-            result.fAllowedCharsSet = (UnicodeSet) (this.fAllowedCharsSet.clone());
-            result.fAllowedCharsSet.freeze();
-            result.fAllowedLocales = new HashSet<ULocale>(this.fAllowedLocales);
-            result.fRestrictionLevel = this.fRestrictionLevel;
-            return result;
-        }
-
-        /**
-         * Specify the source form of the spoof data Spoof Checker. The inputs correspond to the Unicode data
-         * files confusables.txt and confusablesWholeScript.txt as described in Unicode UAX 39. The syntax of the source
-         * data is as described in UAX 39 for these files, and the content of these files is acceptable input.
-         *
-         * @param confusables
-         *            the Reader of confusable characters definitions, as found in file confusables.txt from
-         *            unicode.org.
-         * @param confusablesWholeScript
-         *            the Reader of whole script confusables definitions, as found in the file
-         *            xonfusablesWholeScript.txt from unicode.org.
-         * @throws ParseException
-         *             To report syntax errors in the input.
-         * @stable ICU 4.6
-         */
-        public Builder setData(Reader confusables, Reader confusablesWholeScript) throws ParseException,
-        java.io.IOException {
-
-            // Compile the binary data from the source (text) format.
-            //   Drop the builder's reference to any pre-existing data, which may
-            //   be in use in an already-built checker.
-
-            fSpoofData = new SpoofData();
-            ConfusabledataBuilder.buildConfusableData(confusables, fSpoofData);
-            WSConfusableDataBuilder.buildWSConfusableData(confusablesWholeScript, fSpoofData);
-            return this;
-        }
-
-        /**
-         * Specify the set of checks that will be performed by the check functions of this Spoof Checker.
-         *
-         * @param checks
-         *            The set of checks that this spoof checker will perform. The value is an 'or' of the desired
-         *            checks.
-         * @return self
-         * @stable ICU 4.6
-         */
-        public Builder setChecks(int checks) {
-            // Verify that the requested checks are all ones (bits) that
-            // are acceptable, known values.
-            if (0 != (checks & ~SpoofChecker.ALL_CHECKS)) {
-                throw new IllegalArgumentException("Bad Spoof Checks value.");
-            }
-            this.fChecks = (checks & SpoofChecker.ALL_CHECKS);
-            return this;
-        }
-
-        /**
-         * Limit characters that are acceptable in identifiers being checked to those normally used with the languages
-         * associated with the specified locales. Any previously specified list of locales is replaced by the new
-         * settings.
-         *
-         * A set of languages is determined from the locale(s), and from those a set of acceptable Unicode scripts is
-         * determined. Characters from this set of scripts, along with characters from the "common" and "inherited"
-         * Unicode Script categories will be permitted.
-         *
-         * Supplying an empty string removes all restrictions; characters from any script will be allowed.
-         *
-         * The CHAR_LIMIT test is automatically enabled for this SpoofChecker when calling this function with a
-         * non-empty list of locales.
-         *
-         * The Unicode Set of characters that will be allowed is accessible via the getAllowedChars() function.
-         * setAllowedLocales() will <i>replace</i> any previously applied set of allowed characters.
-         *
-         * Adjustments, such as additions or deletions of certain classes of characters, can be made to the result of
-         * setAllowedLocales() by fetching the resulting set with getAllowedChars(), manipulating it with the Unicode
-         * Set API, then resetting the spoof detectors limits with setAllowedChars()
-         *
-         * @param locales
-         *            A Set of ULocales, from which the language and associated script are extracted. If the locales Set
-         *            is null, no restrictions will be placed on the allowed characters.
-         *
-         * @return self
-         * @stable ICU 4.6
-         */
-        public Builder setAllowedLocales(Set<ULocale> locales) {
-            fAllowedCharsSet.clear();
-
-            for (ULocale locale : locales) {
-                // Add the script chars for this locale to the accumulating set
-                // of allowed chars.
-                addScriptChars(locale, fAllowedCharsSet);
-            }
-
-            // If our caller provided an empty list of locales, we disable the
-            // allowed characters checking
-            fAllowedLocales.clear();
-            if (locales.size() == 0) {
-                fAllowedCharsSet.add(0, 0x10ffff);
-                fChecks &= ~CHAR_LIMIT;
-                return this;
-            }
-
-            // Add all common and inherited characters to the set of allowed
-            // chars.
-            UnicodeSet tempSet = new UnicodeSet();
-            tempSet.applyIntPropertyValue(UProperty.SCRIPT, UScript.COMMON);
-            fAllowedCharsSet.addAll(tempSet);
-            tempSet.applyIntPropertyValue(UProperty.SCRIPT, UScript.INHERITED);
-            fAllowedCharsSet.addAll(tempSet);
-
-            // Store the updated spoof checker state.
-            fAllowedLocales.clear();
-            fAllowedLocales.addAll(locales);
-            fChecks |= CHAR_LIMIT;
-            return this;
-        }
-
-        /**
-         * Limit characters that are acceptable in identifiers being checked to those normally used with the languages
-         * associated with the specified locales. Any previously specified list of locales is replaced by the new
-         * settings.
-         * @param locales
-         *            A Set of Locales, from which the language and associated script are extracted. If the locales Set
-         *            is null, no restrictions will be placed on the allowed characters.
-         *
-         * @return self
-         * @stable ICU 54
-         */
-        public Builder setAllowedJavaLocales(Set<Locale> locales) {
-            HashSet<ULocale> ulocales = new HashSet<ULocale>(locales.size());
-            for (Locale locale : locales) {
-                ulocales.add(ULocale.forLocale(locale));
-            }
-            return setAllowedLocales(ulocales);
-        }
-
-        // Add (union) to the UnicodeSet all of the characters for the scripts
-        // used for the specified locale. Part of the implementation of
-        // setAllowedLocales.
-        private void addScriptChars(ULocale locale, UnicodeSet allowedChars) {
-            int scripts[] = UScript.getCode(locale);
-            UnicodeSet tmpSet = new UnicodeSet();
-            int i;
-            for (i = 0; i < scripts.length; i++) {
-                tmpSet.applyIntPropertyValue(UProperty.SCRIPT, scripts[i]);
-                allowedChars.addAll(tmpSet);
-            }
-        }
-
-        /**
-         * Limit the acceptable characters to those specified by a Unicode Set. Any previously specified character limit
-         * is is replaced by the new settings. This includes limits on characters that were set with the
-         * setAllowedLocales() function. Note that the RESTRICTED set is useful;
-         *
-         * The CHAR_LIMIT test is automatically enabled for this SpoofChecker by this function.
-         *
-         * @param chars
-         *            A Unicode Set containing the list of characters that are permitted. The incoming set is cloned by
-         *            this function, so there are no restrictions on modifying or deleting the UnicodeSet after calling
-         *            this function. Note that this clears the allowedLocales set.
-         * @return self
-         * @stable ICU 4.6
-         */
-        public Builder setAllowedChars(UnicodeSet chars) {
-            fAllowedCharsSet.set(chars);
-            fAllowedLocales.clear();
-            fChecks |= CHAR_LIMIT;
-            return this;
-        }
-
-
-        /**
-         * Set the loosest restriction level allowed. The default if this is not called is HIGHLY_RESTRICTIVE.
-         * This method also sets RESTRICTION_LEVEL.
-         * @param restrictionLevel The loosest restriction level allowed.
-         * @return self
-         * @internal
-         * @deprecated This API is ICU internal only.
-         */
-        @Deprecated
-        public Builder setRestrictionLevel(RestrictionLevel restrictionLevel) {
-            fRestrictionLevel = restrictionLevel;
-            fChecks |= RESTRICTION_LEVEL;
-            return this;
-        }
-
-        // Structure for the Whole Script Confusable Data
-        // See Unicode UAX-39, Unicode Security Mechanisms, for a description of the
-        // Whole Script confusable data
-        //
-        // The data provides mappings from code points to a set of scripts
-        // that contain characters that might be confused with the code point.
-        // There are two mappings, one for lower case only, and one for characters
-        // of any case.
-        //
-        // The actual data consists of a utrie2 to map from a code point to an offset,
-        // and an array of UScriptSets (essentially bit maps) that is indexed
-        // by the offsets obtained from the Trie.
-        //
-        //
-
-        /*
-         * Internal functions for compiling Whole Script confusable source data into its binary (runtime) form. The
-         * binary data format is described in uspoof_impl.h
-         */
-        private static class WSConfusableDataBuilder {
-
-            // Regular expression for parsing a line from the Unicode file confusablesWholeScript.txt
-            // Example Lines:
-            //   006F           ; Latn; Deva; A #      (o) LATIN SMALL LETTER O
-            //   0048..0049     ; Latn; Grek; A #  [2] (H..I) LATIN CAPITAL LETTER H..LATIN CAPITAL LETTER I
-            //     |               |     |    |
-            //     |               |     |    |---- Which table, Any Case or Lower Case (A or L)
-            //     |               |     |----------Target script. We need this.
-            //     |               |----------------Src script. Should match the script of the source
-            //     |                                code points. Beyond checking that, we don't keep it.
-            //     |--------------------------------Source code points or range.
-            //
-            // The expression will match _all_ lines, including erroneous lines.
-            // The result of the parse is returned via the contents of the (match) groups.
-            static String parseExp =
-                "(?m)" +                        // Multi-line mode
-                "^([ \\t]*(?:#.*?)?)$" +        // A blank or comment line. Matches Group 1.
-                "|^(?:" +                       // OR
-                "\\s*([0-9A-F]{4,})(?:..([0-9A-F]{4,}))?\\s*;" + // Code point range. Groups 2 and 3.
-                "\\s*([A-Za-z]+)\\s*;" +        // The source script. Group 4.
-                "\\s*([A-Za-z]+)\\s*;" +        // The target script. Group 5.
-                "\\s*(?:(A)|(L))" +             // The table A or L. Group 6 or 7
-                "[ \\t]*(?:#.*?)?" +            // Trailing commment
-                ")$|" +                         // OR
-                "^(.*?)$";                      // An error line. Group 8.
-                                                // Any line not matching the preceding
-                                                // parts of the expression will match
-                                                // this, and thus be flagged as an error
-
-
-            static void readWholeFileToString(Reader reader, StringBuffer buffer) throws java.io.IOException {
-                // Convert the user input data from UTF-8 to char (UTF-16)
-                LineNumberReader lnr = new LineNumberReader(reader);
-                do {
-                    String line = lnr.readLine();
-                    if (line == null) {
-                        break;
-                    }
-                    buffer.append(line);
-                    buffer.append('\n');
-                } while (true);
-            }
-
-            // Build the Whole Script Confusable data
-            //
-            static void buildWSConfusableData(Reader confusablesWS, SpoofData dest)
-                    throws ParseException, java.io.IOException {
-                Pattern parseRegexp = null;
-                StringBuffer input = new StringBuffer();
-                int lineNum = 0;
-
-                ArrayList<BuilderScriptSet> scriptSets = null;
-                int rtScriptSetsCount = 2;
-
-                Trie2Writable anyCaseTrie = new Trie2Writable(0, 0);
-                Trie2Writable lowerCaseTrie = new Trie2Writable(0, 0);
-
-                // The scriptSets vector provides a mapping from TRIE values to the set
-                // of scripts.
-                //
-                // Reserved TRIE values:
-                //   0: Code point has no whole script confusables.
-                //   1: Code point is of script Common or Inherited.
-                //
-                // These code points do not participate in whole script confusable detection.
-                // (This is logically equivalent to saying that they contain confusables
-                // in all scripts)
-                //
-                // Because Trie values are indexes into the ScriptSets vector, pre-fill
-                // vector positions 0 and 1 to avoid conflicts with the reserved values.
-
-                scriptSets = new ArrayList<BuilderScriptSet>();
-                scriptSets.add(null);
-                scriptSets.add(null);
-
-                readWholeFileToString(confusablesWS, input);
-
-                parseRegexp = Pattern.compile(parseExp);
-
-                // Zap any Byte Order Mark at the start of input. Changing it to a space
-                // is benign
-                // given the syntax of the input.
-                if (input.charAt(0) == 0xfeff) {
-                    input.setCharAt(0, (char) 0x20);
-                }
-
-                // Parse the input, one line per iteration of this loop.
-                Matcher matcher = parseRegexp.matcher(input);
-                while (matcher.find()) {
-                    lineNum++;
-                    if (matcher.start(1) >= 0) {
-                        // this was a blank or comment line.
-                        continue;
-                    }
-                    if (matcher.start(8) >= 0) {
-                        // input file syntax error.
-                        throw new ParseException("ConfusablesWholeScript, line " + lineNum + ": Unrecognized input: "
-                                + matcher.group(), matcher.start());
-                    }
-
-                    // Pick up the start and optional range end code points from the
-                    // parsed line.
-                    int startCodePoint = Integer.parseInt(matcher.group(2), 16);
-                    if (startCodePoint > 0x10ffff) {
-                        throw new ParseException("ConfusablesWholeScript, line " + lineNum
-                                + ": out of range code point: " + matcher.group(2), matcher.start(2));
-                    }
-                    int endCodePoint = startCodePoint;
-                    if (matcher.start(3) >= 0) {
-                        endCodePoint = Integer.parseInt(matcher.group(3), 16);
-                    }
-                    if (endCodePoint > 0x10ffff) {
-                        throw new ParseException("ConfusablesWholeScript, line " + lineNum
-                                + ": out of range code point: " + matcher.group(3), matcher.start(3));
-                    }
-
-                    // Extract the two script names from the source line.
-                    String srcScriptName = matcher.group(4);
-                    String targScriptName = matcher.group(5);
-                    int srcScript = UCharacter.getPropertyValueEnum(UProperty.SCRIPT, srcScriptName);
-                    int targScript = UCharacter.getPropertyValueEnum(UProperty.SCRIPT, targScriptName);
-                    if (srcScript == UScript.INVALID_CODE) {
-                        throw new ParseException("ConfusablesWholeScript, line " + lineNum
-                                + ": Invalid script code t: " + matcher.group(4), matcher.start(4));
-                    }
-                    if (targScript == UScript.INVALID_CODE) {
-                        throw new ParseException("ConfusablesWholeScript, line " + lineNum
-                                + ": Invalid script code t: " + matcher.group(5), matcher.start(5));
-                    }
-
-                    // select the table - (A) any case or (L) lower case only
-                    Trie2Writable table = anyCaseTrie;
-                    if (matcher.start(7) >= 0) {
-                        table = lowerCaseTrie;
-                    }
-
-                    // Build the set of scripts containing confusable characters for
-                    // the code point(s) specified in this input line.
-                    // Sanity check that the script of the source code point is the same
-                    // as the source script indicated in the input file. Failure of this
-                    // check is an error in the input file.
-                    //
-                    // Include the source script in the set (needed for Mixed Script
-                    // Confusable detection).
-                    //
-                    int cp;
-                    for (cp = startCodePoint; cp <= endCodePoint; cp++) {
-                        int setIndex = table.get(cp);
-                        BuilderScriptSet bsset = null;
-                        if (setIndex > 0) {
-                            assert (setIndex < scriptSets.size());
-                            bsset = scriptSets.get(setIndex);
-                        } else {
-                            bsset = new BuilderScriptSet();
-                            bsset.codePoint = cp;
-                            bsset.trie = table;
-                            bsset.sset = new ScriptSet();
-                            setIndex = scriptSets.size();
-                            bsset.index = setIndex;
-                            bsset.rindex = 0;
-                            scriptSets.add(bsset);
-                            table.set(cp, setIndex);
-                        }
-                        bsset.sset.Union(targScript);
-                        bsset.sset.Union(srcScript);
-
-                        int cpScript = UScript.getScript(cp);
-                        if (cpScript != srcScript) {
-                            // status = U_INVALID_FORMAT_ERROR;
-                            throw new ParseException("ConfusablesWholeScript, line " + lineNum
-                                    + ": Mismatch between source script and code point " + Integer.toString(cp, 16),
-                                    matcher.start(5));
-                        }
-                    }
-                }
-
-                // Eliminate duplicate script sets. At this point we have a separate
-                // script set for every code point that had data in the input file.
-                //
-                // We eliminate underlying ScriptSet objects, not the BuildScriptSets
-                // that wrap them
-                //
-                // printf("Number of scriptSets: %d\n", scriptSets.size());
-                //int duplicateCount = 0;
-                rtScriptSetsCount = 2;
-                for (int outeri = 2; outeri < scriptSets.size(); outeri++) {
-                    BuilderScriptSet outerSet = scriptSets.get(outeri);
-                    if (outerSet.index != outeri) {
-                        // This set was already identified as a duplicate.
-                        // It will not be allocated a position in the runtime array
-                        // of ScriptSets.
-                        continue;
-                    }
-                    outerSet.rindex = rtScriptSetsCount++;
-                    for (int inneri = outeri + 1; inneri < scriptSets.size(); inneri++) {
-                        BuilderScriptSet innerSet = scriptSets.get(inneri);
-                        if (outerSet.sset.equals(innerSet.sset) && outerSet.sset != innerSet.sset) {
-                            innerSet.sset = outerSet.sset;
-                            innerSet.index = outeri;
-                            innerSet.rindex = outerSet.rindex;
-                            //duplicateCount++;
-                        }
-                        // But this doesn't get all. We need to fix the TRIE.
-                    }
-                }
-                // printf("Number of distinct script sets: %d\n",
-                // rtScriptSetsCount);
-
-                // Update the Trie values to be reflect the run time script indexes (after duplicate merging).
-                // (Trie Values 0 and 1 are reserved, and the corresponding slots in scriptSets
-                // are unused, which is why the loop index starts at 2.)
-                for (int i = 2; i < scriptSets.size(); i++) {
-                    BuilderScriptSet bSet = scriptSets.get(i);
-                    if (bSet.rindex != i) {
-                        bSet.trie.set(bSet.codePoint, bSet.rindex);
-                    }
-                }
-
-                // For code points with script==Common or script==Inherited,
-                // Set the reserved value of 1 into both Tries. These characters do not participate
-                // in Whole Script Confusable detection; this reserved value is the means
-                // by which they are detected.
-                UnicodeSet ignoreSet = new UnicodeSet();
-                ignoreSet.applyIntPropertyValue(UProperty.SCRIPT, UScript.COMMON);
-                UnicodeSet inheritedSet = new UnicodeSet();
-                inheritedSet.applyIntPropertyValue(UProperty.SCRIPT, UScript.INHERITED);
-                ignoreSet.addAll(inheritedSet);
-                for (int rn = 0; rn < ignoreSet.getRangeCount(); rn++) {
-                    int rangeStart = ignoreSet.getRangeStart(rn);
-                    int rangeEnd = ignoreSet.getRangeEnd(rn);
-                    anyCaseTrie.setRange(rangeStart, rangeEnd, 1, true);
-                    lowerCaseTrie.setRange(rangeStart, rangeEnd, 1, true);
-                }
-
-                // Put the compiled data to the destination SpoofData
-                dest.fAnyCaseTrie   = anyCaseTrie.toTrie2_16();
-                dest.fLowerCaseTrie = lowerCaseTrie.toTrie2_16();
-                dest.fScriptSets = new ScriptSet[rtScriptSetsCount];
-                dest.fScriptSets[0] = new ScriptSet();
-                dest.fScriptSets[1] = new ScriptSet();
-
-                int rindex = 2;
-                for (int i = 2; i < scriptSets.size(); i++) {
-                    BuilderScriptSet bSet = scriptSets.get(i);
-                    if (bSet.rindex < rindex) {
-                        // We have already put this script set to the output data.
-                        continue;
-                    }
-                    assert (rindex == bSet.rindex);
-                    dest.fScriptSets[rindex] = bSet.sset;
-                    rindex++;
-                }
-            }
-
-            // class BuilderScriptSet. Represents the set of scripts (Script Codes)
-            // containing characters that are confusable with one specific
-            // code point.
-            static class BuilderScriptSet {
-                int codePoint;           // The source code point.
-                Trie2Writable trie;      // Any-case or Lower-case Trie.
-                                         // These Trie tables are the final result of the
-                                         // build. This flag indicates which of the two
-                                         // this set of data is for.
-
-                ScriptSet sset;          // The set of scripts itself.
-
-                int index;               // Index of this set in the Build Time vector
-                                         // of script sets.
-
-                int rindex;              // Index of this set in the final (runtime)
-                                         // array of sets.
-
-                // its underlying sset.
-
-                BuilderScriptSet() {
-                    codePoint = -1;
-                    trie = null;
-                    sset = null;
-                    index = 0;
-                    rindex = 0;
-                }
-            }
-
-        }
-
-        /*
-         * *****************************************************************************
-         * Internal classes for compililing confusable data into its binary (runtime) form.
-         * *****************************************************************************
-         */
-        // ---------------------------------------------------------------------
-        //
-        // buildConfusableData Compile the source confusable data, as defined by
-        // the Unicode data file confusables.txt, into the binary
-        // structures used by the confusable detector.
-        //
-        // The binary structures are described in uspoof_impl.h
-        //
-        // 1. parse the data, building 4 hash tables, one each for the SL, SA, ML and MA
-        // tables. Each maps from a int to a String.
-        //
-        // 2. Sort all of the strings encountered by length, since they will need to
-        // be stored in that order in the final string table.
-        //
-        // 3. Build a list of keys (UChar32s) from the four mapping tables. Sort the
-        // list because that will be the ordering of our runtime table.
-        //
-        // 4. Generate the run time string table. This is generated before the key & value
-        // tables because we need the string indexes when building those tables.
-        //
-        // 5. Build the run-time key and value tables. These are parallel tables, and
-        // are built at the same time
-
-        // class ConfusabledataBuilder
-        //     An instance of this class exists while the confusable data is being built from source.
-        //     It encapsulates the intermediate data structures that are used for building.
-        //     It exports one static function, to do a confusable data build.
-        private static class ConfusabledataBuilder {
-
-            private Hashtable<Integer, SPUString> fSLTable;
-            private Hashtable<Integer, SPUString> fSATable;
-            private Hashtable<Integer, SPUString> fMLTable;
-            private Hashtable<Integer, SPUString> fMATable;
-            private UnicodeSet fKeySet; // A set of all keys (UChar32s) that go into the
-                                        // four mapping tables.
-
-            // The compiled data is first assembled into the following four collections,
-            // then output to the builder's SpoofData object.
-            private StringBuffer fStringTable;
-            private ArrayList<Integer> fKeyVec;
-            private ArrayList<Integer> fValueVec;
-            private ArrayList<Integer> fStringLengthsTable;
-            private SPUStringPool stringPool;
-            private Pattern fParseLine;
-            private Pattern fParseHexNum;
-            private int fLineNum;
-
-            ConfusabledataBuilder() {
-                fSLTable  = new Hashtable<Integer, SPUString>();
-                fSATable  = new Hashtable<Integer, SPUString>();
-                fMLTable  = new Hashtable<Integer, SPUString>();
-                fMATable  = new Hashtable<Integer, SPUString>();
-                fKeySet   = new UnicodeSet();
-                fKeyVec   = new ArrayList<Integer>();
-                fValueVec = new ArrayList<Integer>();
-                stringPool = new SPUStringPool();
-            }
-
-            void build(Reader confusables, SpoofData dest) throws ParseException, java.io.IOException {
-                StringBuffer fInput = new StringBuffer();
-                WSConfusableDataBuilder.readWholeFileToString(confusables, fInput);
-
-                // Regular Expression to parse a line from Confusables.txt. The expression will match
-                // any line. What was matched is determined by examining which capture groups have a match.
-                //   Capture Group 1: the source char
-                //   Capture Group 2: the replacement chars
-                //   Capture Group 3-6 the table type, SL, SA, ML, or MA
-                //   Capture Group 7: A blank or comment only line.
-                //   Capture Group 8: A syntactically invalid line. Anything that didn't match before.
-                // Example Line from the confusables.txt source file:
-                //   "1D702 ; 006E 0329 ; SL # MATHEMATICAL ITALIC SMALL ETA ... "
-                fParseLine = Pattern.compile("(?m)^[ \\t]*([0-9A-Fa-f]+)[ \\t]+;" + // Match the source char
-                        "[ \\t]*([0-9A-Fa-f]+" +                     // Match the replacement char(s)
-                        "(?:[ \\t]+[0-9A-Fa-f]+)*)[ \\t]*;" +        //     (continued)
-                        "\\s*(?:(SL)|(SA)|(ML)|(MA))" +              // Match the table type
-                        "[ \\t]*(?:#.*?)?$" +                        // Match any trailing #comment
-                        "|^([ \\t]*(?:#.*?)?)$" +                    // OR match empty lines or lines with only a #comment
-                        "|^(.*?)$");                                 // OR match any line, which catches illegal lines.
-
-                // Regular expression for parsing a hex number out of a space-separated list of them.
-                // Capture group 1 gets the number, with spaces removed.
-                fParseHexNum = Pattern.compile("\\s*([0-9A-F]+)");
-
-                // Zap any Byte Order Mark at the start of input. Changing it to a space
-                // is benign given the syntax of the input.
-                if (fInput.charAt(0) == 0xfeff) {
-                    fInput.setCharAt(0, (char) 0x20);
-                }
-
-                // Parse the input, one line per iteration of this loop.
-                Matcher matcher = fParseLine.matcher(fInput);
-                while (matcher.find()) {
-                    fLineNum++;
-                    if (matcher.start(7) >= 0) {
-                        // this was a blank or comment line.
-                        continue;
-                    }
-                    if (matcher.start(8) >= 0) {
-                        // input file syntax error.
-                        // status = U_PARSE_ERROR;
-                        throw new ParseException("Confusables, line " + fLineNum + ": Unrecognized Line: "
-                                + matcher.group(8), matcher.start(8));
-                    }
-
-                    // We have a good input line. Extract the key character and mapping
-                    // string, and
-                    // put them into the appropriate mapping table.
-                    int keyChar = Integer.parseInt(matcher.group(1), 16);
-                    if (keyChar > 0x10ffff) {
-                        throw new ParseException("Confusables, line " + fLineNum + ": Bad code point: "
-                                + matcher.group(1), matcher.start(1));
-                    }
-                    Matcher m = fParseHexNum.matcher(matcher.group(2));
-
-                    StringBuilder mapString = new StringBuilder();
-                    while (m.find()) {
-                        int c = Integer.parseInt(m.group(1), 16);
-                        if (keyChar > 0x10ffff) {
-                            throw new ParseException("Confusables, line " + fLineNum + ": Bad code point: "
-                                    + Integer.toString(c, 16), matcher.start(2));
-                        }
-                        mapString.appendCodePoint(c);
-                    }
-                    assert (mapString.length() >= 1);
-
-                    // Put the map (value) string into the string pool
-                    // This a little like a Java intern() - any duplicates will be
-                    // eliminated.
-                    SPUString smapString = stringPool.addString(mapString.toString());
-
-                    // Add the char . string mapping to the appropriate table.
-                    Hashtable<Integer, SPUString> table = 
-                            matcher.start(3) >= 0 ? fSLTable :
-                            matcher.start(4) >= 0 ? fSATable :
-                            matcher.start(5) >= 0 ? fMLTable :
-                            matcher.start(6) >= 0 ? fMATable :
-                            null;
-                    assert (table != null);
-
-                    // For Unicode 8, the SL, SA and ML tables have been discontinued.
-                    //                All input data from confusables.txt is tagged MA.
-                    //                ICU spoof check functions should ignore the specified table and always
-                    //                use this MA Data.
-                    //                For now, implement by populating the MA data into all four tables, and
-                    //                keep the multiple table implementation in place, in case it comes back
-                    //                at some time in the future.
-                    //                There is no run time size penalty to keeping the four table implementation -
-                    //                the data is shared when it's the same betweeen tables.
-
-                    if (table != fMATable) {
-                        throw new ParseException("Confusables, line " + fLineNum + ": Table must be 'MA'.", 0);
-                    }
-                    // table.put(keyChar, smapString);
-                    fSLTable.put(keyChar, smapString);
-                    fSATable.put(keyChar, smapString);
-                    fMLTable.put(keyChar, smapString);
-                    fMATable.put(keyChar, smapString);
-
-                    fKeySet.add(keyChar);
-                }
-
-                // Input data is now all parsed and collected.
-                // Now create the run-time binary form of the data.
-                //
-                // This is done in two steps. First the data is assembled into vectors and strings,
-                // for ease of construction, then the contents of these collections are copied
-                // into the actual SpoofData object.
-
-                // Build up the string array, and record the index of each string therein
-                // in the (build time only) string pool.
-                // Strings of length one are not entered into the strings array.
-                // At the same time, build up the string lengths table, which records the
-                // position in the string table of the first string of each length >= 4.
-                // (Strings in the table are sorted by length)
-
-                stringPool.sort();
-                fStringTable = new StringBuffer();
-                fStringLengthsTable = new ArrayList<Integer>();
-                int previousStringLength = 0;
-                int previousStringIndex = 0;
-                int poolSize = stringPool.size();
-                int i;
-                for (i = 0; i < poolSize; i++) {
-                    SPUString s = stringPool.getByIndex(i);
-                    int strLen = s.fStr.length();
-                    int strIndex = fStringTable.length();
-                    assert (strLen >= previousStringLength);
-                    if (strLen == 1) {
-                        // strings of length one do not get an entry in the string table.
-                        // Keep the single string character itself here, which is the same
-                        // convention that is used in the final run-time string table index.
-                        s.fStrTableIndex = s.fStr.charAt(0);
-                    } else {
-                        if ((strLen > previousStringLength) && (previousStringLength >= 4)) {
-                            fStringLengthsTable.add(previousStringIndex);
-                            fStringLengthsTable.add(previousStringLength);
-                        }
-                        s.fStrTableIndex = strIndex;
-                        fStringTable.append(s.fStr);
-                    }
-                    previousStringLength = strLen;
-                    previousStringIndex = strIndex;
-                }
-                // Make the final entry to the string lengths table.
-                // (it holds an entry for the _last_ string of each length, so adding
-                // the
-                // final one doesn't happen in the main loop because no longer string
-                // was encountered.)
-                if (previousStringLength >= 4) {
-                    fStringLengthsTable.add(previousStringIndex);
-                    fStringLengthsTable.add(previousStringLength);
-                }
-
-                // Construct the compile-time Key and Value tables
-                //
-                // For each key code point, check which mapping tables it applies to,
-                // and create the final data for the key & value structures.
-                //
-                // The four logical mapping tables are conflated into one combined
-                // table.
-                // If multiple logical tables have the same mapping for some key, they
-                // share a single entry in the combined table.
-                // If more than one mapping exists for the same key code point, multiple
-                // entries will be created in the table
-
-                for (String keyCharStr: fKeySet) {
-                    int keyChar = keyCharStr.codePointAt(0);
-                    addKeyEntry(keyChar, fSLTable, SpoofChecker.SL_TABLE_FLAG);
-                    addKeyEntry(keyChar, fSATable, SpoofChecker.SA_TABLE_FLAG);
-                    addKeyEntry(keyChar, fMLTable, SpoofChecker.ML_TABLE_FLAG);
-                    addKeyEntry(keyChar, fMATable, SpoofChecker.MA_TABLE_FLAG);
-                }
-
-                // Put the assembled data into the destination SpoofData object.
-
-                // The Key Table
-                //     While copying the keys to the output array,
-                //     also sanity check that the keys are sorted.
-
-                int numKeys = fKeyVec.size();
-                dest.fCFUKeys = new int[numKeys];
-                int previousKey = 0;
-                for (i=0; i<numKeys; i++) {
-                    int key = fKeyVec.get(i);
-                    assert ((key & 0x00ffffff) >= (previousKey & 0x00ffffff));
-                    assert ((key & 0xff000000) != 0);
-                    dest.fCFUKeys[i] = key;
-                    previousKey = key;
-                }
-
-                // The Value Table, parallels the key table
-                int numValues = fValueVec.size();
-                assert (numKeys == numValues);
-                dest.fCFUValues = new short[numValues];
-                i = 0;
-                for (int value:fValueVec) {
-                    assert (value < 0xffff);
-                    dest.fCFUValues[i++] = (short)value;
-                }
-
-                // The Strings Table.
-
-                dest.fCFUStrings = fStringTable.toString();
-
-
-                // The String Lengths Table.
-
-                // While copying into the runtime array do some sanity checks on the values
-                // Each complete entry contains two fields, an index and an offset.
-                // Lengths should increase with each entry.
-                // Offsets should be less than the size of the string table.
-
-                int lengthTableLength = fStringLengthsTable.size();
-                int previousLength = 0;
-
-                // Note: StringLengthsSize in the raw data is the number of complete entries,
-                //       each consisting of a pair of 16 bit values, hence the divide by 2.
-
-                int stringLengthsSize = lengthTableLength / 2;
-                dest.fCFUStringLengths = new SpoofData.SpoofStringLengthsElement[stringLengthsSize];
-                for (i = 0; i < stringLengthsSize; i += 1) {
-                    int offset = fStringLengthsTable.get(i*2);
-                    int length = fStringLengthsTable.get(i*2 + 1);
-                    assert (offset < dest.fCFUStrings.length());
-                    assert (length < 40);
-                    assert (length > previousLength);
-                    dest.fCFUStringLengths[i] = new SpoofData.SpoofStringLengthsElement();
-                    dest.fCFUStringLengths[i].fLastString = offset;
-                    dest.fCFUStringLengths[i].fStrLength  = length;
-                    previousLength = length;
-                }
-             }
-
-            // Add an entry to the key and value tables being built
-            // input: data from SLTable, MATable, etc.
-            // outut: entry added to fKeyVec and fValueVec
-            // addKeyEntry Construction of the confusable Key and Mapping Values tables.
-            // This is an intermediate point in the building process.
-            // We already have the mappings in the hash tables fSLTable, etc.
-            // This function builds corresponding run-time style table entries into
-            // fKeyVec and fValueVec
-            void addKeyEntry(int keyChar, // The key character
-                    Hashtable<Integer, SPUString> table, // The table, one of SATable,
-                    // MATable, etc.
-                    int tableFlag) { // One of SA_TABLE_FLAG, etc.
-                SPUString targetMapping = table.get(keyChar);
-                if (targetMapping == null) {
-                    // No mapping for this key character.
-                    // (This function is called for all four tables for each key char
-                    // that
-                    // is seen anywhere, so this no entry cases are very much expected.)
-                    return;
-                }
-
-                // Check whether there is already an entry with the correct mapping.
-                // If so, simply set the flag in the keyTable saying that the existing
-                // entry
-                // applies to the table that we're doing now.
-                boolean keyHasMultipleValues = false;
-                int i;
-                for (i = fKeyVec.size() - 1; i >= 0; i--) {
-                    int key = fKeyVec.get(i);
-                    if ((key & 0x0ffffff) != keyChar) {
-                        // We have now checked all existing key entries for this key
-                        // char (if any)
-                        // without finding one with the same mapping.
-                        break;
-                    }
-                    String mapping = getMapping(i);
-                    if (mapping.equals(targetMapping.fStr)) {
-                        // The run time entry we are currently testing has the correct
-                        // mapping.
-                        // Set the flag in it indicating that it applies to the new
-                        // table also.
-                        key |= tableFlag;
-                        fKeyVec.set(i, key);
-                        return;
-                    }
-                    keyHasMultipleValues = true;
-                }
-
-                // Need to add a new entry to the binary data being built for this
-                // mapping.
-                // Includes adding entries to both the key table and the parallel values
-                // table.
-                int newKey = keyChar | tableFlag;
-                if (keyHasMultipleValues) {
-                    newKey |= SpoofChecker.KEY_MULTIPLE_VALUES;
-                }
-                int adjustedMappingLength = targetMapping.fStr.length() - 1;
-                if (adjustedMappingLength > 3) {
-                    adjustedMappingLength = 3;
-                }
-                newKey |= adjustedMappingLength << SpoofChecker.KEY_LENGTH_SHIFT;
-
-                int newData = targetMapping.fStrTableIndex;
-
-                fKeyVec.add(newKey);
-                fValueVec.add(newData);
-
-                // If the preceding key entry is for the same key character (but with a
-                // different mapping)
-                // set the multiple-values flag on it.
-                if (keyHasMultipleValues) {
-                    int previousKeyIndex = fKeyVec.size() - 2;
-                    int previousKey = fKeyVec.get(previousKeyIndex);
-                    previousKey |= SpoofChecker.KEY_MULTIPLE_VALUES;
-                    fKeyVec.set(previousKeyIndex, previousKey);
-                }
-            }
-
-            // From an index into fKeyVec & fValueVec
-            // get a String with the corresponding mapping.
-            String getMapping(int index) {
-                int key = fKeyVec.get(index);
-                int value = fValueVec.get(index);
-                int length = SpoofChecker.getKeyLength(key);
-                int lastIndexWithLen;
-                switch (length) {
-                case 0:
-                    char[] cs = { (char) value };
-                    return new String(cs);
-                case 1:
-                case 2:
-                    return fStringTable.substring(value, value + length + 1); // Note: +1 as optimization
-                case 3:
-                    length = 0;
-                    int i;
-                    for (i = 0; i < fStringLengthsTable.size(); i += 2) {
-                        lastIndexWithLen = fStringLengthsTable.get(i);
-                        if (value <= lastIndexWithLen) {
-                            length = fStringLengthsTable.get(i + 1);
-                            break;
-                        }
-                    }
-                    assert (length >= 3);
-                    return fStringTable.substring(value, value + length);
-                default:
-                    assert (false);
-                }
-                return "";
-            }
-
-
-
-
-
-            public static void buildConfusableData(Reader confusables, SpoofData dest) throws java.io.IOException,
-            ParseException {
-                ConfusabledataBuilder builder = new ConfusabledataBuilder();
-                builder.build(confusables, dest);
-            }
-
-            /*
-             * *****************************************************************************
-             * Internal classes for compiling confusable data into its binary (runtime) form.
-             * *****************************************************************************
-             */
-            // SPUString
-            // Holds a string that is the result of one of the mappings defined
-            // by the confusable mapping data (confusables.txt from Unicode.org)
-            // Instances of SPUString exist during the compilation process only.
-
-            private static class SPUString {
-                String fStr; // The actual string.
-                int fStrTableIndex; // Index into the final runtime data for this string.
-                                    // (or, for length 1, the single string char itself,
-                                    // there being no string table entry for it.)
-
-                SPUString(String s) {
-                    fStr = s;
-                    fStrTableIndex = 0;
-                }
-            }
-
-            // Comparison function for ordering strings in the string pool.
-            // Compare by length first, then, within a group of the same length,
-            // by code point order.
-
-            private static class SPUStringComparator implements Comparator<SPUString> {
-                public int compare(SPUString sL, SPUString sR) {
-                    int lenL = sL.fStr.length();
-                    int lenR = sR.fStr.length();
-                    if (lenL < lenR) {
-                        return -1;
-                    } else if (lenL > lenR) {
-                        return 1;
-                    } else {
-                        return sL.fStr.compareTo(sR.fStr);
-                    }
-                }
-            }
-
-            // String Pool A utility class for holding the strings that are the result of
-            // the spoof mappings. These strings will utimately end up in the
-            // run-time String Table.
-            // This is sort of like a sorted set of strings, except that ICU's anemic
-            // built-in collections don't support those, so it is implemented with a
-            // combination of a uhash and a Vector.
-            private static class SPUStringPool {
-                public SPUStringPool() {
-                    fVec = new Vector<SPUString>();
-                    fHash = new Hashtable<String, SPUString>();
-                }
-
-                public int size() {
-                    return fVec.size();
-                }
-
-                // Get the n-th string in the collection.
-                public SPUString getByIndex(int index) {
-                    SPUString retString = fVec.elementAt(index);
-                    return retString;
-                }
-
-                // Add a string. Return the string from the table.
-                // If the input parameter string is already in the table, delete the
-                // input parameter and return the existing string.
-                public SPUString addString(String src) {
-                    SPUString hashedString = fHash.get(src);
-                    if (hashedString == null) {
-                        hashedString = new SPUString(src);
-                        fHash.put(src, hashedString);
-                        fVec.addElement(hashedString);
-                    }
-                    return hashedString;
-                }
-
-                // Sort the contents; affects the ordering of getByIndex().
-                public void sort() {
-                    Collections.sort(fVec, new SPUStringComparator());
-                }
-
-                private Vector<SPUString> fVec; // Elements are SPUString *
-                private Hashtable<String, SPUString> fHash; // Key: Value:
-            }
-
-        }
-    }
-
-    /**
-     * Get the Restriction Level that is being tested.
-     *
-     * @return The restriction level
-     * @internal
-     * @deprecated This API is ICU internal only.
-     */
-    @Deprecated
-    public RestrictionLevel getRestrictionLevel() {
-        return fRestrictionLevel;
-    }
-
-    /**
-     * Get the set of checks that this Spoof Checker has been configured to perform.
-     *
-     * @return The set of checks that this spoof checker will perform.
-     * @stable ICU 4.6
-     */
-    public int getChecks() {
-        return fChecks;
-    }
-
-    /**
-     * Get a read-only set of locales for the scripts that are acceptable in strings to be checked. If no limitations on scripts
-     * have been specified, an empty set will be returned.
-     *
-     * setAllowedChars() will reset the list of allowed locales to be empty.
-     *
-     * The returned set may not be identical to the originally specified set that is supplied to setAllowedLocales();
-     * the information other than languages from the originally specified locales may be omitted.
-     *
-     * @return A set of locales corresponding to the acceptable scripts.
-     *
-     * @stable ICU 4.6
-     */
-    public Set<ULocale> getAllowedLocales() {
-        return Collections.unmodifiableSet(fAllowedLocales);
-    }
-
-    /**
-     * Get a set of {@link java.util.Locale} instances for the scripts that are acceptable in strings to be checked. If no
-     * limitations on scripts have been specified, an empty set will be returned.
-     *
-     * @return A set of locales corresponding to the acceptable scripts.
-     * @stable ICU 54
-     */
-    public Set<Locale> getAllowedJavaLocales() {
-        HashSet<Locale> locales = new HashSet<Locale>(fAllowedLocales.size());
-        for (ULocale uloc : fAllowedLocales) {
-            locales.add(uloc.toLocale());
-        }
-        return locales;
-    }
-
-    /**
-     * Get a UnicodeSet for the characters permitted in an identifier. This corresponds to the limits imposed by the Set
-     * Allowed Characters functions. Limitations imposed by other checks will not be reflected in the set returned by
-     * this function.
-     *
-     * The returned set will be frozen, meaning that it cannot be modified by the caller.
-     *
-     * @return A UnicodeSet containing the characters that are permitted by the CHAR_LIMIT test.
-     * @stable ICU 4.6
-     */
-    public UnicodeSet getAllowedChars() {
-        return fAllowedCharsSet;
-    }
-
-    /**
-     * A struct-like class to hold the results of a Spoof Check operation.
-     * Tells which check(s) have failed.
-     *
-     * @stable ICU 4.6
-     */
-    public static class CheckResult {
-        /**
-         * Indicate which of the spoof check(s) has failed.  The value is a bitwise OR
-         * of the constants for the tests in question, SINGLE_SCRIPT_CONFUSABLE,
-         * MIXED_SCRIPT_CONFUSABLE, WHOLE_SCRIPT_CONFUSABLE, and so on.
-         *
-         * @stable ICU 4.6
-         */
-        public int checks;
-        /**
-         * The index of the first string position that failed a check.
-         *
-         * @deprecated ICU 51. No longer supported. Always set to zero.
-         */
-        @Deprecated
-        public int position;
-        /**
-         * The numerics found in the string, if MIXED_NUMBERS was set; otherwise null;
-         *
-         * @internal
-         * @deprecated This API is ICU internal only.
-         */
-        @Deprecated
-        public UnicodeSet numerics;
-        /**
-         * The restriction level that the text meets, if RESTRICTION_LEVEL is set; otherwise null.
-         *
-         * @internal
-         * @deprecated This API is ICU internal only.
-         */
-        @Deprecated
-        public RestrictionLevel restrictionLevel;
-
-        /**
-         *  Default constructor
-         *  @stable ICU 4.6
-         */
-        public CheckResult() {
-            checks = 0;
-            position = 0;
-        }
-
-        /**
-         * {@inheritDoc}
-         * @stable ICU 4.6
-         */
-        @Override
-        public String toString() {
-            StringBuilder sb = new StringBuilder();
-            sb.append("checks:");
-            if (checks == 0) {
-                sb.append(" none");
-            } else if (checks == ALL_CHECKS) {
-                sb.append(" all");
-            } else {
-                if ((checks & SINGLE_SCRIPT_CONFUSABLE) != 0) {
-                    sb.append(" SINGLE_SCRIPT_CONFUSABLE");
-                }
-                if ((checks & MIXED_SCRIPT_CONFUSABLE) != 0) {
-                    sb.append(" MIXED_SCRIPT_CONFUSABLE");
-                }
-                if ((checks & WHOLE_SCRIPT_CONFUSABLE) != 0) {
-                    sb.append(" WHOLE_SCRIPT_CONFUSABLE");
-                }
-                if ((checks & ANY_CASE) != 0) {
-                    sb.append(" ANY_CASE");
-                }
-                if ((checks & RESTRICTION_LEVEL) != 0) {
-                    sb.append(" RESTRICTION_LEVEL");
-                }
-                if ((checks & INVISIBLE) != 0) {
-                    sb.append(" INVISIBLE");
-                }
-                if ((checks & CHAR_LIMIT) != 0) {
-                    sb.append(" CHAR_LIMIT");
-                }
-                if ((checks & MIXED_NUMBERS) != 0) {
-                    sb.append(" MIXED_NUMBERS");
-                }
-            }
-            sb.append(", numerics: ").append(numerics.toPattern(false));
-            sb.append(", position: ").append(position);
-            sb.append(", restrictionLevel: ").append(restrictionLevel);
-            return sb.toString();
-        }
-    }
-
-    /**
-     * Check the specified string for possible security issues. The text to be checked will typically be an identifier
-     * of some sort. The set of checks to be performed was specified when building the SpoofChecker.
-     *
-     * @param text
-     *            A String to be checked for possible security issues.
-     * @param checkResult
-     *            Output parameter, indicates which specific tests failed.
-     *            May be null if the information is not wanted.
-     * @return True there any issue is found with the input string.
-     * @stable ICU 4.8
-     */
-    public boolean failsChecks(String text, CheckResult checkResult) {
-        int length = text.length();
-
-        int result = 0;
-        if (checkResult != null) {
-            checkResult.position = 0;
-            checkResult.numerics = null;
-            checkResult.restrictionLevel = null;
-        }
-
-        // Allocate an identifier info if needed.
-
-        IdentifierInfo identifierInfo = null;
-        if (0 != ((this.fChecks) & (RESTRICTION_LEVEL | MIXED_NUMBERS))) {
-            identifierInfo = getIdentifierInfo().setIdentifier(text).setIdentifierProfile(fAllowedCharsSet);
-        }
-
-        if (0 != ((this.fChecks) & RESTRICTION_LEVEL)) {
-            RestrictionLevel textRestrictionLevel = identifierInfo.getRestrictionLevel();
-            if (textRestrictionLevel.compareTo(fRestrictionLevel) > 0) {
-                result |= RESTRICTION_LEVEL;
-            }
-            if (checkResult != null) {
-                checkResult.restrictionLevel = textRestrictionLevel;
-            }
-        }
-
-        if (0 != ((this.fChecks) & MIXED_NUMBERS)) {
-            UnicodeSet numerics = identifierInfo.getNumerics();
-            if (numerics.size() > 1) {
-                result |= MIXED_NUMBERS;
-            }
-            if (checkResult != null) {
-                checkResult.numerics = numerics;
-            }
-        }
-
-        if (0 != (this.fChecks & CHAR_LIMIT)) {
-            int i;
-            int c;
-            for (i = 0; i < length;) {
-                // U16_NEXT(text, i, length, c);
-                c = Character.codePointAt(text, i);
-                i = Character.offsetByCodePoints(text, i, 1);
-                if (!this.fAllowedCharsSet.contains(c)) {
-                    result |= CHAR_LIMIT;
-                    break;
-                }
-            }
-        }
-
-        if (0 != (this.fChecks & (WHOLE_SCRIPT_CONFUSABLE | MIXED_SCRIPT_CONFUSABLE | INVISIBLE))) {
-            // These are the checks that need to be done on NFD input
-            String nfdText = nfdNormalizer.normalize(text);
-
-            if (0 != (this.fChecks & INVISIBLE)) {
-
-                // scan for more than one occurence of the same non-spacing mark
-                // in a sequence of non-spacing marks.
-                int i;
-                int c;
-                int firstNonspacingMark = 0;
-                boolean haveMultipleMarks = false;
-                UnicodeSet marksSeenSoFar = new UnicodeSet(); // Set of combining marks in a
-                                                              // single combining sequence.
-                for (i = 0; i < length;) {
-                    c = Character.codePointAt(nfdText, i);
-                    i = Character.offsetByCodePoints(nfdText, i, 1);
-                    if (Character.getType(c) != UCharacterCategory.NON_SPACING_MARK) {
-                        firstNonspacingMark = 0;
-                        if (haveMultipleMarks) {
-                            marksSeenSoFar.clear();
-                            haveMultipleMarks = false;
-                        }
-                        continue;
-                    }
-                    if (firstNonspacingMark == 0) {
-                        firstNonspacingMark = c;
-                        continue;
-                    }
-                    if (!haveMultipleMarks) {
-                        marksSeenSoFar.add(firstNonspacingMark);
-                        haveMultipleMarks = true;
-                    }
-                    if (marksSeenSoFar.contains(c)) {
-                        // report the error, and stop scanning.
-                        // No need to find more than the first failure.
-                        result |= INVISIBLE;
-                        break;
-                    }
-                    marksSeenSoFar.add(c);
-                }
-            }
-
-            if (0 != (this.fChecks & (WHOLE_SCRIPT_CONFUSABLE | MIXED_SCRIPT_CONFUSABLE))) {
-                // The basic test is the same for both whole and mixed script confusables.
-                // Compute the set of scripts that every input character has a confusable in.
-                // For this computation an input character is always considered to be
-                // confusable with itself in its own script.
-                //
-                // If the number of such scripts is two or more, and the input consisted of
-                // characters all from a single script, we have a whole script confusable.
-                // (The two scripts will be the original script and the one that is confusable).
-
-                // If the number of such scripts >= one, and the original input contained characters from
-                // more than one script, we have a mixed script confusable. (We can transform
-                // some of the characters, and end up with a visually similar string all in one script.)
-
-                if (identifierInfo == null) {
-                    identifierInfo = getIdentifierInfo();
-                    identifierInfo.setIdentifier(text);
-                }
-                int scriptCount = identifierInfo.getScriptCount();
-
-                ScriptSet scripts = new ScriptSet();
-                this.wholeScriptCheck(nfdText, scripts);
-                int confusableScriptCount = scripts.countMembers();
-
-                if ((0 != (this.fChecks & WHOLE_SCRIPT_CONFUSABLE)) && confusableScriptCount >= 2 && scriptCount == 1) {
-                    result |= WHOLE_SCRIPT_CONFUSABLE;
-                }
-
-                if ((0 != (this.fChecks & MIXED_SCRIPT_CONFUSABLE)) && confusableScriptCount >= 1 && scriptCount > 1) {
-                    result |= MIXED_SCRIPT_CONFUSABLE;
-                }
-            }
-        }
-        if (checkResult != null) {
-            checkResult.checks = result;
-        }
-        releaseIdentifierInfo(identifierInfo);
-        return (0 != result);
-    }
-
-    /**
-     * Check the specified string for possible security issues. The text to be checked will typically be an identifier
-     * of some sort. The set of checks to be performed was specified when building the SpoofChecker.
-     *
-     * @param text
-     *            A String to be checked for possible security issues.
-     * @return True there any issue is found with the input string.
-     * @stable ICU 4.8
-     */
-    public boolean failsChecks(String text) {
-        return failsChecks(text, null);
-    }
-
-    /**
-     * Check the whether two specified strings are visually confusable. The types of confusability to be tested - single
-     * script, mixed script, or whole script - are determined by the check options set for the SpoofChecker.
-     *
-     * The tests to be performed are controlled by the flags SINGLE_SCRIPT_CONFUSABLE MIXED_SCRIPT_CONFUSABLE
-     * WHOLE_SCRIPT_CONFUSABLE At least one of these tests must be selected.
-     *
-     * ANY_CASE is a modifier for the tests. Select it if the identifiers may be of mixed case. If identifiers are case
-     * folded for comparison and display to the user, do not select the ANY_CASE option.
-     *
-     *
-     * @param s1
-     *            The first of the two strings to be compared for confusability.
-     * @param s2
-     *            The second of the two strings to be compared for confusability.
-     * @return Non-zero if s1 and s1 are confusable. If not 0, the value will indicate the type(s) of confusability
-     *         found, as defined by spoof check test constants.
-     * @stable ICU 4.6
-     */
-    public int areConfusable(String s1, String s2) {
-        //
-        // See section 4 of UAX 39 for the algorithm for checking whether two strings are confusable,
-        // and for definitions of the types (single, whole, mixed-script) of confusables.
-
-        // We only care about a few of the check flags. Ignore the others.
-        // If no tests relavant to this function have been specified, signal an error.
-        // TODO: is this really the right thing to do? It's probably an error on
-        // the caller's part, but logically we would just return 0 (no error).
-        if ((this.fChecks & (SINGLE_SCRIPT_CONFUSABLE | MIXED_SCRIPT_CONFUSABLE | WHOLE_SCRIPT_CONFUSABLE)) == 0) {
-            throw new IllegalArgumentException("No confusable checks are enabled.");
-        }
-        int flagsForSkeleton = this.fChecks & ANY_CASE;
-
-        int result = 0;
-        IdentifierInfo identifierInfo = getIdentifierInfo();
-        identifierInfo.setIdentifier(s1);
-        int s1ScriptCount = identifierInfo.getScriptCount();
-        int s1FirstScript = identifierInfo.getScripts().nextSetBit(0);
-        identifierInfo.setIdentifier(s2);
-        int s2ScriptCount = identifierInfo.getScriptCount();
-        int s2FirstScript = identifierInfo.getScripts().nextSetBit(0);
-        releaseIdentifierInfo(identifierInfo);
-
-        if (0 != (this.fChecks & SINGLE_SCRIPT_CONFUSABLE)) {
-            // Do the Single Script compare.
-            if (s1ScriptCount <= 1 && s2ScriptCount <= 1 && s1FirstScript == s2FirstScript) {
-                flagsForSkeleton |= SINGLE_SCRIPT_CONFUSABLE;
-                String s1Skeleton = getSkeleton(flagsForSkeleton, s1);
-                String s2Skeleton = getSkeleton(flagsForSkeleton, s2);
-                if (s1Skeleton.equals(s2Skeleton)) {
-                    result |= SINGLE_SCRIPT_CONFUSABLE;
-                }
-            }
-        }
-
-        if (0 != (result & SINGLE_SCRIPT_CONFUSABLE)) {
-            // If the two inputs are single script confusable they cannot also be
-            // mixed or whole script confusable, according to the UAX39 definitions.
-            // So we can skip those tests.
-            return result;
-        }
-
-        // Two identifiers are whole script confusable if each is of a single script
-        // and they are mixed script confusable.
-        boolean possiblyWholeScriptConfusables = s1ScriptCount <= 1 && s2ScriptCount <= 1
-                && (0 != (this.fChecks & WHOLE_SCRIPT_CONFUSABLE));
-
-        // Mixed Script Check
-        if ((0 != (this.fChecks & MIXED_SCRIPT_CONFUSABLE)) || possiblyWholeScriptConfusables) {
-            // For getSkeleton(), resetting the SINGLE_SCRIPT_CONFUSABLE flag will get us
-            // the mixed script table skeleton, which is what we want.
-            // The Any Case / Lower Case bit in the skelton flags was set at the top of the function.
-            flagsForSkeleton &= ~SINGLE_SCRIPT_CONFUSABLE;
-            String s1Skeleton = getSkeleton(flagsForSkeleton, s1);
-            String s2Skeleton = getSkeleton(flagsForSkeleton, s2);
-            if (s1Skeleton.equals(s2Skeleton)) {
-                result |= MIXED_SCRIPT_CONFUSABLE;
-                if (possiblyWholeScriptConfusables) {
-                    result |= WHOLE_SCRIPT_CONFUSABLE;
-                }
-            }
-        }
-        return result;
-    }
-
-    /**
-     * Get the "skeleton" for an identifier string. Skeletons are a transformation of the input string; Two strings are
-     * confusable if their skeletons are identical. See Unicode UAX 39 for additional information.
-     *
-     * Using skeletons directly makes it possible to quickly check whether an identifier is confusable with any of some
-     * large set of existing identifiers, by creating an efficiently searchable collection of the skeletons.
-     *
-     * Skeletons are computed using the algorithm and data describe in Unicode UAX 39.
-     * The latest proposed update, UAX 39 Version 8 draft 1, says "the tables SL, SA, and ML
-     * were still problematic, and discouraged from use in [Uniocde] 7.0.
-     * They were thus removed from version 8.0"
-     * 
-     * In light of this, the default mapping data included with ICU 55 uses the
-     * Unicode 7 MA (Multi script Any case) table data for the other type options
-     * (Single Script, Any Case), (Single Script, Lower Case) and (Multi Script, Lower Case).
-     *
-     * @param type
-     *            The type of skeleton, corresponding to which of the Unicode confusable data tables to use. The default
-     *            is Mixed-Script, Lowercase. Allowed options are SINGLE_SCRIPT_CONFUSABLE and ANY_CASE_CONFUSABLE. The
-     *            two flags may be ORed.
-     * @param id
-     *            The input identifier whose skeleton will be genereated.
-     * @return The output skeleton string.
-     *
-     * @stable ICU 4.6
-     */
-    public String getSkeleton(int type, String id) {
-        int tableMask = 0;
-        switch (type) {
-        case 0:
-            tableMask = ML_TABLE_FLAG;
-            break;
-        case SINGLE_SCRIPT_CONFUSABLE:
-            tableMask = SL_TABLE_FLAG;
-            break;
-        case ANY_CASE:
-            tableMask = MA_TABLE_FLAG;
-            break;
-        case SINGLE_SCRIPT_CONFUSABLE | ANY_CASE:
-            tableMask = SA_TABLE_FLAG;
-            break;
-        default:
-            // *status = U_ILLEGAL_ARGUMENT_ERROR;
-            throw new IllegalArgumentException("SpoofChecker.getSkeleton(), bad type value.");
-        }
-
-        // Apply the skeleton mapping to the NFD normalized input string
-        // Accumulate the skeleton, possibly unnormalized, in a String.
-
-        String nfdId = nfdNormalizer.normalize(id);
-        int normalizedLen = nfdId.length();
-        StringBuilder skelSB = new StringBuilder();
-        for (int inputIndex = 0; inputIndex < normalizedLen;) {
-            int c = Character.codePointAt(nfdId, inputIndex);
-            inputIndex += Character.charCount(c);
-            this.confusableLookup(c, tableMask, skelSB);
-        }
-        String skelStr = skelSB.toString();
-        skelStr = nfdNormalizer.normalize(skelStr);
-        return skelStr;
-    }
-
-
-    /**
-     *   Equality function. Return true if the two SpoofChecker objects
-     *   incorporate the same confusable data and have enabled the same
-     *   set of checks.
-     *
-     *   @param other the SpoofChecker being compared with.
-     *   @return true if the two SpoofCheckers are equal.
-     *   @internal
-     *   @deprecated This API is ICU internal only.
-     */
-    @Deprecated
-    @Override
-    public boolean equals(Object other) {
-        if (!(other instanceof SpoofChecker)) {return false; }
-        SpoofChecker otherSC = (SpoofChecker)other;
-        if (fSpoofData != otherSC.fSpoofData &&
-                fSpoofData != null &&
-                !fSpoofData.equals(otherSC.fSpoofData)) {
-            return false;
-        }
-        if (fChecks != otherSC.fChecks) {return false; }
-        if (fAllowedLocales != otherSC.fAllowedLocales &&
-                fAllowedLocales != null &&
-                !fAllowedLocales.equals(otherSC.fAllowedLocales)) {
-            return false;
-        }
-        if (fAllowedCharsSet != otherSC.fAllowedCharsSet &&
-                fAllowedCharsSet != null &&
-                !fAllowedCharsSet.equals(otherSC.fAllowedCharsSet)) {
-            return false;
-        }
-        if (fRestrictionLevel != otherSC.fRestrictionLevel) {
-            return false;
-        }
-        return true;
-     }
-
-    /**
-     * This is a stub implementation and not designed for generic use.
-     * @internal
-     * @deprecated This API is ICU internal only.
-     */
-    @Deprecated
-    @Override
-    public int hashCode() {
-        assert false;   // To make sure ICU implementation does not depend on this.
-        return 1234;    // Any arbitrary value - for now, using 1234.
-    }
-
-    /*
-     * Append the confusable skeleton transform for a single code point to a StringBuilder.
-     * The string to be appended will between 1 and 18 characters.
-     *
-     * This is the heart of the confusable skeleton generation implementation.
-     *
-     * @param tableMask bit flag specifying which confusable table to use. One of SL_TABLE_FLAG, MA_TABLE_FLAG, etc.
-     */
-    private void confusableLookup(int inChar, int tableMask, StringBuilder dest) {
-        // Binary search the spoof data key table for the inChar
-        int low = 0;
-        int mid = 0;
-        int limit = fSpoofData.fCFUKeys.length;
-        int midc;
-        boolean foundChar = false;
-        // [low, limit), i.e low is inclusive, limit is exclusive
-        do {
-            int delta = (limit - low) / 2;
-            mid = low + delta;
-            midc = fSpoofData.fCFUKeys[mid] & 0x1fffff;
-            if (inChar == midc) {
-                foundChar = true;
-                break;
-            } else if (inChar < midc) {
-                limit = mid; // limit is exclusive
-            } else {
-                // we have checked mid is not the char we looking for, the next char
-                // we want to check is (mid + 1)
-                low = mid + 1; // low is inclusive
-            }
-        } while (low < limit);
-        if (!foundChar) { // Char not found. It maps to itself.
-            dest.appendCodePoint(inChar);
-            return;
-        }
-
-        boolean foundKey = false;
-        int keyFlags = fSpoofData.fCFUKeys[mid] & 0xff000000;
-        if ((keyFlags & tableMask) == 0) {
-            // We found the right key char, but the entry doesn't pertain to the
-            // table we need. See if there is an adjacent key that does
-            if (0 != (keyFlags & SpoofChecker.KEY_MULTIPLE_VALUES)) {
-                int altMid;
-                for (altMid = mid - 1; (fSpoofData.fCFUKeys[altMid] & 0x00ffffff) == inChar; altMid--) {
-                    keyFlags = fSpoofData.fCFUKeys[altMid] & 0xff000000;
-                    if (0 != (keyFlags & tableMask)) {
-                        mid = altMid;
-                        foundKey = true;
-                        break;
-                    }
-                }
-                if (!foundKey) {
-                    for (altMid = mid + 1; (fSpoofData.fCFUKeys[altMid] & 0x00ffffff) == inChar; altMid++) {
-                        keyFlags = fSpoofData.fCFUKeys[altMid] & 0xff000000;
-                        if (0 != (keyFlags & tableMask)) {
-                            mid = altMid;
-                            foundKey = true;
-                            break;
-                        }
-                    }
-                }
-            }
-            if (!foundKey) {
-                // No key entry for this char & table.
-                // The input char maps to itself.
-                dest.appendCodePoint(inChar);
-                return;
-            }
-        }
-
-        int stringLen = getKeyLength(keyFlags) + 1;
-        int keyTableIndex = mid;
-
-        // Value is either a char (for strings of length 1) or
-        // an index into the string table (for longer strings)
-        short value = fSpoofData.fCFUValues[keyTableIndex];
-        if (stringLen == 1) {
-            dest.append((char) value);
-            return;
-        }
-
-        // String length of 4 from the above lookup is used for all strings of
-        // length >= 4.
-        // For these, get the real length from the string lengths table,
-        // which maps string table indexes to lengths.
-        // All strings of the same length are stored contiguously in the string table.
-        // 'value' from the lookup above is the starting index for the desired string.
-
-        if (stringLen == 4) {
-            boolean dataOK = false;
-            for (SpoofData.SpoofStringLengthsElement el: fSpoofData.fCFUStringLengths) {
-                if (el.fLastString >= value) {
-                    stringLen = el.fStrLength;
-                    dataOK = true;
-                    break;
-                }
-            }
-            assert(dataOK);
-        }
-
-        dest.append(fSpoofData.fCFUStrings, value, value + stringLen);
-        return;
-    }
-
-    // Implementation for Whole Script tests.
-    // Input text is already normalized to NFD
-    // Return the set of scripts, each of which can represent something that is
-    // confusable with the input text. The script of the input text
-    // is included; input consisting of characters from a single script will
-    // always produce a result consisting of a set containing that script.
-    private void wholeScriptCheck(CharSequence text, ScriptSet result) {
-        int inputIdx = 0;
-        int c;
-
-        Trie2 table = (0 != (fChecks & ANY_CASE)) ? fSpoofData.fAnyCaseTrie : fSpoofData.fLowerCaseTrie;
-        result.setAll();
-        while (inputIdx < text.length()) {
-            c = Character.codePointAt(text, inputIdx);
-            inputIdx = Character.offsetByCodePoints(text, inputIdx, 1);
-            int index = table.get(c);
-            if (index == 0) {
-                // No confusables in another script for this char.
-                // TODO: we should change the data to have sets with just the single script
-                // bit for the script of this char. Gets rid of this special case.
-                // Until then, grab the script from the char and intersect it with the set.
-                int cpScript = UScript.getScript(c);
-                assert (cpScript > UScript.INHERITED);
-                result.intersect(cpScript);
-            } else if (index == 1) {
-                // Script == Common or Inherited. Nothing to do.
-            } else {
-                result.intersect(fSpoofData.fScriptSets[index]);
-            }
-        }
-    }
-
-    // IdentifierInfo Cache. IdentifierInfo objects are somewhat expensive to create.
-    //  Maintain a one-element cache, which is sufficient to avoid repeatedly
-    //  creating new ones unless we get multi-thread concurrency collisions in spoof
-    //  check operations, which should be statistically uncommon.
-
-    private IdentifierInfo fCachedIdentifierInfo = null;  // Do not use this directly.
-
-    private IdentifierInfo getIdentifierInfo() {
-        IdentifierInfo returnIdInfo = null;
-        synchronized (this) {
-            returnIdInfo = fCachedIdentifierInfo;
-            fCachedIdentifierInfo = null;
-        }
-        if (returnIdInfo == null) {
-            returnIdInfo = new IdentifierInfo();
-        }
-        return returnIdInfo;
-    }
-
-
-    private void releaseIdentifierInfo(IdentifierInfo idInfo) {
-        if (idInfo != null) {
-            synchronized (this) {
-                if (fCachedIdentifierInfo == null) {
-                    fCachedIdentifierInfo = idInfo;
-                }
-            }
-        }
-    };
-
-    // Data Members
-    private int fChecks;                         // Bit vector of checks to perform.
-    private SpoofData fSpoofData;
-    private Set<ULocale> fAllowedLocales;        // The Set of allowed locales.
-    private UnicodeSet fAllowedCharsSet;         // The UnicodeSet of allowed characters.
-    private RestrictionLevel fRestrictionLevel;
-
-    private static Normalizer2 nfdNormalizer = Normalizer2.getNFDInstance();
-
-
-    // Confusable Mappings Data Structures
-    //
-    // For the confusable data, we are essentially implementing a map,
-    //    key: a code point
-    //    value: a string. Most commonly one char in length, but can be more.
-    //
-    // The keys are stored as a sorted array of 32 bit ints.
-    //          bits 0-23    a code point value
-    //          bits 24-31   flags
-    //             24:    1 if entry applies to SL table
-    //             25:    1 if entry applies to SA table
-    //             26:    1 if entry applies to ML table
-    //             27:    1 if entry applies to MA table
-    //             28:    1 if there are multiple entries for this code point.
-    //             29-30: length of value string, in UChars.
-    //                    values are (1, 2, 3, other)
-    //     The key table is sorted in ascending code point order. (not on the
-    //     32 bit int value, the flag bits do not participate in the sorting.)
-    //
-    //     Lookup is done by means of a binary search in the key table.
-    //
-    // The corresponding values are kept in a parallel array of 16 bit ints.
-    // If the value string is of length 1, it is literally in the value array.
-    // For longer strings, the value array contains an index into the strings
-    // table.
-    //
-    // String Table:
-    //     The strings table contains all of the value strings (those of length two or greater)
-    //     concatentated together into one long char (UTF-16) array.
-    //
-    //     The array is arranged by length of the strings - all strings of the same length
-    //     are stored together. The sections are ordered by length of the strings -
-    //     all two char strings first, followed by all of the three Char strings, etc.
-    //
-    //     There is no nul character or other mark between adjacent strings.
-    //
-    // String Lengths table
-    //     The length of strings from 1 to 3 is flagged in the key table.
-    //     For strings of length 4 or longer, the string length table provides a
-    //     mapping between an index into the string table and the corresponding length.
-    //     Strings of these lengths are rare, so lookup time is not an issue.
-    //     Each entry consists of
-    //        unsigned short      index of the _last_ string with this length
-    //        unsigned short      the length
-
-    // Flag bits in the Key entries
-    static final int SL_TABLE_FLAG = (1 << 24);
-    static final int SA_TABLE_FLAG = (1 << 25);
-    static final int ML_TABLE_FLAG = (1 << 26);
-    static final int MA_TABLE_FLAG = (1 << 27);
-    static final int KEY_MULTIPLE_VALUES = (1 << 28);
-    static final int KEY_LENGTH_SHIFT = 29;
-
-    static final int getKeyLength(int x) {
-        return (((x) >> 29) & 3);
-    }
-
-
-    // -------------------------------------------------------------------------------------
-    //
-    // SpoofData
-    //
-    //   This class corresonds to the ICU SpoofCheck data.
-    //
-    //   The data can originate with the Binary ICU data that is generated in ICU4C,
-    //   or it can originate from source rules that are compiled in ICU4J.
-    //
-    //   This class does not include the set of checks to be performed, but only
-    //     data that is serialized into the ICU binary data.
-    //
-    //   Because Java cannot easily wrap binaray data like ICU4C, the binary data is
-    //     copied into Java structures that are convenient for use by the run time code.
-    //
-    // ---------------------------------------------------------------------------------------
-    private static class SpoofData {
-
-        // The Confusable data, Java data structures for.
-        int[]                       fCFUKeys;
-        short[]                     fCFUValues;
-        SpoofStringLengthsElement[] fCFUStringLengths;
-        String                      fCFUStrings;
-
-        // Whole Script Confusable Data
-        Trie2                       fAnyCaseTrie;
-        Trie2                       fLowerCaseTrie;
-        ScriptSet[]                 fScriptSets;
-
-        static class SpoofStringLengthsElement {
-            int fLastString;  // index in string table of last string with this length
-            int fStrLength;   // Length of strings
-            public boolean equals(Object other) {
-                if (!(other instanceof SpoofStringLengthsElement)) {
-                    return false;
-                }
-                SpoofStringLengthsElement otherEl = (SpoofStringLengthsElement)other;
-                return fLastString == otherEl.fLastString &&
-                       fStrLength  == otherEl.fStrLength;
-            }
-        }
-
-        private static final int DATA_FORMAT = 0x43667520;  // "Cfu "
-
-        private static final class IsAcceptable implements Authenticate {
-            // @Override when we switch to Java 6
-            public boolean isDataVersionAcceptable(byte version[]) {
-                return version[0] == 1;
-            }
-        }
-        private static final IsAcceptable IS_ACCEPTABLE = new IsAcceptable();
-
-        private static final class DefaultData {
-            private static SpoofData INSTANCE = null;
-
-            static {
-                try {
-                    INSTANCE = new SpoofData(ICUBinary.getRequiredData("confusables.cfu"));
-                } catch (IOException ignored) {
-                }
-            }
-        }
-
-        /**
-         * @return instance for Unicode standard data
-         */
-        static SpoofData getDefault() {
-            return DefaultData.INSTANCE;
-        }
-
-        // SpoofChecker Data constructor for use from data builder.
-        // Initializes a new, empty data area that will be populated later.
-        SpoofData() {
-        }
-
-        // Constructor for use when creating from prebuilt default data.
-        // A ByteBuffer is what the ICU internal data loading functions provide.
-        SpoofData(ByteBuffer bytes) throws java.io.IOException {
-            ICUBinary.readHeader(bytes, DATA_FORMAT, IS_ACCEPTABLE);
-            bytes.mark();
-            readData(bytes);
-        }
-
-        public boolean equals(Object other) {
-            if (!(other instanceof SpoofData)) {
-                return false;
-            }
-            SpoofData otherData = (SpoofData)other;
-            if (!Arrays.equals(fCFUKeys, otherData.fCFUKeys)) return false;
-            if (!Arrays.equals(fCFUValues, otherData.fCFUValues)) return false;
-            if (!Arrays.deepEquals(fCFUStringLengths, otherData.fCFUStringLengths)) return false;
-            if (fCFUStrings != otherData.fCFUStrings &&
-                    fCFUStrings != null &&
-                    !fCFUStrings.equals(otherData.fCFUStrings)) return false;
-            if (fAnyCaseTrie != otherData.fAnyCaseTrie &&
-                    fAnyCaseTrie != null &&
-                    !fAnyCaseTrie.equals(otherData.fAnyCaseTrie)) return false;
-            if (fLowerCaseTrie != otherData.fLowerCaseTrie &&
-                    fLowerCaseTrie != null &&
-                    !fLowerCaseTrie.equals(otherData.fLowerCaseTrie)) return false;
-            if (!Arrays.deepEquals(fScriptSets, otherData.fScriptSets)) return false;
-            return true;
-        }
-
-        // Set the SpoofChecker data from pre-built binary data in a byte buffer.
-        // The binary data format is as described for ICU4C spoof data.
-        //
-        void readData(ByteBuffer bytes) throws java.io.IOException {
-            int magic = bytes.getInt();
-            if (magic != 0x3845fdef) {
-                throw new IllegalArgumentException("Bad Spoof Check Data.");
-            }
-            @SuppressWarnings("unused")
-            int dataFormatVersion      = bytes.getInt();
-            @SuppressWarnings("unused")
-            int dataLength             = bytes.getInt();
-
-            int CFUKeysOffset          = bytes.getInt();
-            int CFUKeysSize            = bytes.getInt();
-
-            int CFUValuesOffset        = bytes.getInt();
-            int CFUValuesSize          = bytes.getInt();
-
-            int CFUStringTableOffset   = bytes.getInt();
-            int CFUStringTableSize     = bytes.getInt();
-
-            int CFUStringLengthsOffset = bytes.getInt();
-            int CFUStringLengthsSize   = bytes.getInt();
-
-            int anyCaseTrieOffset      = bytes.getInt();
-            @SuppressWarnings("unused")
-            int anyCaseTrieSize        = bytes.getInt();
-
-            int lowerCaseTrieOffset    = bytes.getInt();
-            @SuppressWarnings("unused")
-            int lowerCaseTrieLength    = bytes.getInt();
-
-            int scriptSetsOffset       = bytes.getInt();
-            int scriptSetslength       = bytes.getInt();
-
-            int i;
-            fCFUKeys = null;
-            fCFUValues = null;
-            fCFUStringLengths = null;
-            fCFUStrings = null;
-
-            // We have now read the file header, and obtained the position for each
-            // of the data items. Now read each in turn, first seeking the
-            // input stream to the position of the data item.
-
-            bytes.reset();
-            ICUBinary.skipBytes(bytes, CFUKeysOffset);
-            fCFUKeys = ICUBinary.getInts(bytes, CFUKeysSize, 0);
-
-            bytes.reset();
-            ICUBinary.skipBytes(bytes, CFUValuesOffset);
-            fCFUValues = ICUBinary.getShorts(bytes, CFUValuesSize, 0);
-
-            bytes.reset();
-            ICUBinary.skipBytes(bytes, CFUStringTableOffset);
-            fCFUStrings = ICUBinary.getString(bytes, CFUStringTableSize, 0);
-
-            bytes.reset();
-            ICUBinary.skipBytes(bytes, CFUStringLengthsOffset);
-            fCFUStringLengths = new SpoofStringLengthsElement[CFUStringLengthsSize];
-            for (i = 0; i < CFUStringLengthsSize; i++) {
-                fCFUStringLengths[i] = new SpoofStringLengthsElement();
-                fCFUStringLengths[i].fLastString = bytes.getShort();
-                fCFUStringLengths[i].fStrLength = bytes.getShort();
-            }
-
-            bytes.reset();
-            ICUBinary.skipBytes(bytes, anyCaseTrieOffset);
-            fAnyCaseTrie = Trie2.createFromSerialized(bytes);
-
-            bytes.reset();
-            ICUBinary.skipBytes(bytes, lowerCaseTrieOffset);
-            fLowerCaseTrie = Trie2.createFromSerialized(bytes);
-
-            bytes.reset();
-            ICUBinary.skipBytes(bytes, scriptSetsOffset);
-            fScriptSets = new ScriptSet[scriptSetslength];
-            for (i = 0; i < scriptSetslength; i++) {
-                fScriptSets[i] = new ScriptSet(bytes);
-            }
-        }
-
-    }
-
-    // -------------------------------------------------------------------------------
-    //
-    // ScriptSet - Script code bit sets. Used with the whole script confusable data.
-    // Used both at data build and at run time.
-    // Could almost be a Java BitSet, except that the input and output would
-    // be awkward.
-    //
-    // -------------------------------------------------------------------------------
-    static class ScriptSet {
-        public ScriptSet() {
-        }
-
-        public ScriptSet(ByteBuffer bytes) throws java.io.IOException {
-            for (int j = 0; j < bits.length; j++) {
-                bits[j] = bytes.getInt();
-            }
-        }
-
-        public void output(DataOutputStream os) throws java.io.IOException {
-            for (int i = 0; i < bits.length; i++) {
-                os.writeInt(bits[i]);
-            }
-        }
-
-        public boolean equals(Object other) {
-            if (!(other instanceof ScriptSet)) {
-                return false;
-            }
-            ScriptSet otherSet = (ScriptSet)other;
-            return Arrays.equals(bits, otherSet.bits);
-        }
-
-        public void Union(int script) {
-            int index = script / 32;
-            int bit = 1 << (script & 31);
-            assert (index < bits.length * 4 * 4);
-            bits[index] |= bit;
-        }
-
-        @SuppressWarnings("unused")
-        public void Union(ScriptSet other) {
-            for (int i = 0; i < bits.length; i++) {
-                bits[i] |= other.bits[i];
-            }
-        }
-
-        public void intersect(ScriptSet other) {
-            for (int i = 0; i < bits.length; i++) {
-                bits[i] &= other.bits[i];
-            }
-        }
-
-        public void intersect(int script) {
-            int index = script / 32;
-            int bit = 1 << (script & 31);
-            assert (index < bits.length * 4 * 4);
-            int i;
-            for (i = 0; i < index; i++) {
-                bits[i] = 0;
-            }
-            bits[index] &= bit;
-            for (i = index + 1; i < bits.length; i++) {
-                bits[i] = 0;
-            }
-        }
-
-        public void setAll() {
-            for (int i = 0; i < bits.length; i++) {
-                bits[i] = 0xffffffff;
-            }
-        }
-
-        @SuppressWarnings("unused")
-        public void resetAll() {
-            for (int i = 0; i < bits.length; i++) {
-                bits[i] = 0;
-            }
-        }
-
-        public int countMembers() {
-            // This bit counter is good for sparse numbers of '1's, which is
-            // very much the case that we will usually have.
-            int count = 0;
-            for (int i = 0; i < bits.length; i++) {
-                int x = bits[i];
-                while (x != 0) {
-                    count++;
-                    x &= (x - 1); // AND off the least significant one bit.
-                                  // Note - Java integer over/underflow behavior is well defined.
-                                  //        0x80000000 - 1 = 0x7fffffff
-                }
-            }
-            return count;
-        }
-
-        private int[] bits = new int[6];
-    }
-}
-
diff --git a/app/src/main/java/com/ibm/icu/text/UCharacterIterator.java b/app/src/main/java/com/ibm/icu/text/UCharacterIterator.java
deleted file mode 100644
index 35ab68f..0000000
--- a/app/src/main/java/com/ibm/icu/text/UCharacterIterator.java
+++ /dev/null
@@ -1,402 +0,0 @@
-/*
- *******************************************************************************
- * Copyright (C) 1996-2016, International Business Machines Corporation and
- * others. All Rights Reserved.
- *******************************************************************************
- */
-package com.ibm.icu.text;
-
-
-import java.text.CharacterIterator;
-
-import com.ibm.icu.impl.CharacterIteratorWrapper;
-import com.ibm.icu.impl.ReplaceableUCharacterIterator;
-import com.ibm.icu.impl.UCharArrayIterator;
-import com.ibm.icu.impl.UCharacterIteratorWrapper;
-
-
-/**
- * Abstract class that defines an API for iteration on text objects.This is an 
- * interface for forward and backward iteration and random access into a text 
- * object. Forward iteration is done with post-increment and backward iteration 
- * is done with pre-decrement semantics, while the 
- * <code>java.text.CharacterIterator</code> interface methods provided forward 
- * iteration with "pre-increment" and backward iteration with pre-decrement 
- * semantics. This API is more efficient for forward iteration over code points.
- * The other major difference is that this API can do both code unit and code point 
- * iteration, <code>java.text.CharacterIterator</code> can only iterate over 
- * code units and is limited to BMP (0 - 0xFFFF)
- * @author Ram
- * @stable ICU 2.4
- */
-public abstract class UCharacterIterator 
-                      implements Cloneable,UForwardCharacterIterator {
-
-    /**
-     * Protected default constructor for the subclasses
-     * @stable ICU 2.4
-     */
-    protected UCharacterIterator(){
-    }
-    
-    // static final methods ----------------------------------------------------
-    
-    /**
-     * Returns a <code>UCharacterIterator</code> object given a 
-     * <code>Replaceable</code> object.
-     * @param source a valid source as a <code>Replaceable</code> object
-     * @return UCharacterIterator object
-     * @exception IllegalArgumentException if the argument is null
-     * @stable ICU 2.4
-     */
-    public static final UCharacterIterator getInstance(Replaceable source){
-        return new ReplaceableUCharacterIterator(source);
-    }
-    
-    /**
-     * Returns a <code>UCharacterIterator</code> object given a 
-     * source string.
-     * @param source a string
-     * @return UCharacterIterator object
-     * @exception IllegalArgumentException if the argument is null
-     * @stable ICU 2.4
-     */
-    public static final UCharacterIterator getInstance(String source){
-        return new ReplaceableUCharacterIterator(source);
-    }
-    
-    /**
-     * Returns a <code>UCharacterIterator</code> object given a 
-     * source character array.
-     * @param source an array of UTF-16 code units
-     * @return UCharacterIterator object
-     * @exception IllegalArgumentException if the argument is null
-     * @stable ICU 2.4
-     */
-    public static final UCharacterIterator getInstance(char[] source){
-        return getInstance(source,0,source.length);
-    }
-    
-    /**
-     * Returns a <code>UCharacterIterator</code> object given a 
-     * source character array.
-     * @param source an array of UTF-16 code units
-     * @return UCharacterIterator object
-     * @exception IllegalArgumentException if the argument is null
-     * @stable ICU 2.4
-     */
-    public static final UCharacterIterator getInstance(char[] source, int start, int limit){
-        return new UCharArrayIterator(source,start,limit);
-    }
-    /**
-     * Returns a <code>UCharacterIterator</code> object given a 
-     * source StringBuffer.
-     * @param source an string buffer of UTF-16 code units
-     * @return UCharacterIterator object
-     * @exception IllegalArgumentException if the argument is null
-     * @stable ICU 2.4
-     */
-    public static final UCharacterIterator getInstance(StringBuffer source){
-        return new ReplaceableUCharacterIterator(source);
-    }
-
-    /**
-     * Returns a <code>UCharacterIterator</code> object given a 
-     * CharacterIterator.
-     * @param source a valid CharacterIterator object.
-     * @return UCharacterIterator object
-     * @exception IllegalArgumentException if the argument is null
-     * @stable ICU 2.4
-     */    
-    public static final UCharacterIterator getInstance(CharacterIterator source){
-        return new CharacterIteratorWrapper(source);
-    }
-       
-    // public methods ----------------------------------------------------------
-    /**
-     * Returns a <code>java.text.CharacterIterator</code> object for
-     * the underlying text of this iterator.  The returned iterator is
-     * independent of this iterator.
-     * @return java.text.CharacterIterator object
-     * @stable ICU 2.4 
-     */
-    public CharacterIterator getCharacterIterator(){
-        return new UCharacterIteratorWrapper(this);
-    }    
-   
-    /**
-     * Returns the code unit at the current index.  If index is out
-     * of range, returns DONE.  Index is not changed.
-     * @return current code unit
-     * @stable ICU 2.4
-     */
-    public abstract int current();
-    
-    /**
-     * Returns the codepoint at the current index.
-     * If the current index is invalid, DONE is returned.
-     * If the current index points to a lead surrogate, and there is a following
-     * trail surrogate, then the code point is returned.  Otherwise, the code
-     * unit at index is returned.  Index is not changed. 
-     * @return current codepoint
-     * @stable ICU 2.4
-     */
-    public int currentCodePoint(){
-        int ch = current();
-        if(UTF16.isLeadSurrogate((char)ch)){
-            // advance the index to get the
-            // next code point
-            next();
-            // due to post increment semantics
-            // current() after next() actually
-            // returns the char we want
-            int ch2 = current();
-            // current should never change
-            // the current index so back off
-            previous();
-            
-            if(UTF16.isTrailSurrogate((char)ch2)){
-                // we found a surrogate pair 
-                // return the codepoint
-                return Character.toCodePoint((char)ch, (char)ch2);
-            }
-        }
-        return ch;
-    }
-    
-    /**
-     * Returns the length of the text
-     * @return length of the text
-     * @stable ICU 2.4
-     */
-    public abstract int getLength();
-
-    
-    /**
-     * Gets the current index in text.
-     * @return current index in text.
-     * @stable ICU 2.4
-     */
-    public abstract int getIndex();
-
-
-    /**
-     * Returns the UTF16 code unit at index, and increments to the next
-     * code unit (post-increment semantics).  If index is out of
-     * range, DONE is returned, and the iterator is reset to the limit
-     * of the text.
-     * @return the next UTF16 code unit, or DONE if the index is at the limit
-     *         of the text.
-     * @stable ICU 2.4  
-     */
-    public abstract int next();
-
-    /**
-     * Returns the code point at index, and increments to the next code
-     * point (post-increment semantics).  If index does not point to a
-     * valid surrogate pair, the behavior is the same as
-     * <code>next()</code>.  Otherwise the iterator is incremented past
-     * the surrogate pair, and the code point represented by the pair
-     * is returned.
-     * @return the next codepoint in text, or DONE if the index is at
-     *         the limit of the text.
-     * @stable ICU 2.4  
-     */
-    public int nextCodePoint(){
-        int ch1 = next();
-        if(UTF16.isLeadSurrogate((char)ch1)){
-            int ch2 = next();
-            if(UTF16.isTrailSurrogate((char)ch2)){
-                return Character.toCodePoint((char)ch1, (char)ch2);
-            }else if (ch2 != DONE) {
-                // unmatched surrogate so back out
-                previous();
-            }
-        }
-        return ch1;
-    }
-
-    /**
-     * Decrement to the position of the previous code unit in the
-     * text, and return it (pre-decrement semantics).  If the
-     * resulting index is less than 0, the index is reset to 0 and
-     * DONE is returned.
-     * @return the previous code unit in the text, or DONE if the new
-     *         index is before the start of the text.
-     * @stable ICU 2.4  
-     */
-    public abstract int previous();
-
-    
-    /**
-     * Retreat to the start of the previous code point in the text,
-     * and return it (pre-decrement semantics).  If the index is not
-     * preceeded by a valid surrogate pair, the behavior is the same
-     * as <code>previous()</code>.  Otherwise the iterator is
-     * decremented to the start of the surrogate pair, and the code
-     * point represented by the pair is returned.
-     * @return the previous code point in the text, or DONE if the new
-     *         index is before the start of the text.
-     * @stable ICU 2.4  
-     */
-    public int previousCodePoint(){
-        int ch1 = previous();
-        if(UTF16.isTrailSurrogate((char)ch1)){
-            int ch2 = previous();
-            if(UTF16.isLeadSurrogate((char)ch2)){
-                return Character.toCodePoint((char)ch2, (char)ch1);
-            }else if (ch2 != DONE) {
-                //unmatched trail surrogate so back out
-                next();
-            }   
-        }
-        return ch1;
-    }
-
-    /**
-     * Sets the index to the specified index in the text.
-     * @param index the index within the text. 
-     * @exception IndexOutOfBoundsException is thrown if an invalid index is 
-     *            supplied
-     * @stable ICU 2.4
-     */
-    public abstract void setIndex(int index);
-
-    /**
-     * Sets the current index to the limit.
-     * @stable ICU 2.4
-     */
-    public void setToLimit() {
-        setIndex(getLength());
-    }
-    
-    /**
-     * Sets the current index to the start.
-     * @stable ICU 2.4
-     */
-    public void setToStart() {
-        setIndex(0);
-    }
-
-    /**
-     * Fills the buffer with the underlying text storage of the iterator
-     * If the buffer capacity is not enough a exception is thrown. The capacity
-     * of the fill in buffer should at least be equal to length of text in the 
-     * iterator obtained by calling <code>getLength()</code>).
-     * <b>Usage:</b>
-     * 
-     * <pre>
-     *         UChacterIterator iter = new UCharacterIterator.getInstance(text);
-     *         char[] buf = new char[iter.getLength()];
-     *         iter.getText(buf);
-     *         
-     *         OR
-     *         char[] buf= new char[1];
-     *         int len = 0;
-     *         for(;;){
-     *             try{
-     *                 len = iter.getText(buf);
-     *                 break;
-     *             }catch(IndexOutOfBoundsException e){
-     *                 buf = new char[iter.getLength()];
-     *             }
-     *         }
-     * </pre>
-     *
-     * @param fillIn an array of chars to fill with the underlying UTF-16 code 
-     *         units.
-     * @param offset the position within the array to start putting the data.
-     * @return the number of code units added to fillIn, as a convenience
-     * @exception IndexOutOfBoundsException exception if there is not enough
-     *            room after offset in the array, or if offset &lt; 0.
-     * @stable ICU 2.4  
-     */
-    public abstract int getText(char[] fillIn, int offset); 
-
-    /**
-     * Convenience override for <code>getText(char[], int)</code> that provides
-     * an offset of 0.
-     * @param fillIn an array of chars to fill with the underlying UTF-16 code 
-     *         units.
-     * @return the number of code units added to fillIn, as a convenience
-     * @exception IndexOutOfBoundsException exception if there is not enough
-     *            room in the array.
-     * @stable ICU 2.4  
-     */
-    public final int getText(char[] fillIn) {
-        return getText(fillIn, 0);
-    }
-         
-    /**
-     * Convenience method for returning the underlying text storage as as string
-     * @return the underlying text storage in the iterator as a string
-     * @stable ICU 2.4
-     */
-    public String getText() {
-        char[] text = new char[getLength()];
-        getText(text);
-        return new String(text);
-    }
-       
-    /**
-     * Moves the current position by the number of code units
-     * specified, either forward or backward depending on the sign
-     * of delta (positive or negative respectively).  If the resulting
-     * index would be less than zero, the index is set to zero, and if
-     * the resulting index would be greater than limit, the index is
-     * set to limit.
-     *
-     * @param delta the number of code units to move the current
-     *              index.
-     * @return the new index.
-     * @exception IndexOutOfBoundsException is thrown if an invalid index is 
-     *            supplied 
-     * @stable ICU 2.4 
-     * 
-     */
-    public int moveIndex(int delta) {
-        int x = Math.max(0, Math.min(getIndex() + delta, getLength()));
-        setIndex(x);
-        return x;
-    }
-
-    /**
-     * Moves the current position by the number of code points
-     * specified, either forward or backward depending on the sign of
-     * delta (positive or negative respectively). If the current index
-     * is at a trail surrogate then the first adjustment is by code
-     * unit, and the remaining adjustments are by code points.  If the
-     * resulting index would be less than zero, the index is set to
-     * zero, and if the resulting index would be greater than limit,
-     * the index is set to limit.
-     * @param delta the number of code units to move the current index.
-     * @return the new index  
-     * @exception IndexOutOfBoundsException is thrown if an invalid delta is 
-     *            supplied
-     * @stable ICU 2.4
-     */
-    public int moveCodePointIndex(int delta){
-        if(delta>0){
-            while(delta>0 && nextCodePoint() != DONE){delta--;}
-        }else{
-            while(delta<0 && previousCodePoint() != DONE){delta++;}
-        }
-        if(delta!=0){
-            throw new IndexOutOfBoundsException();
-        }
-          
-        return getIndex();
-    }
-
-    /**
-     * Creates a copy of this iterator, independent from other iterators.
-     * If it is not possible to clone the iterator, returns null.
-     * @return copy of this iterator
-     * @stable ICU 2.4
-     */
-    public Object clone() throws CloneNotSupportedException{
-        return super.clone();
-    }   
-    
-}
-
diff --git a/app/src/test/java/com/abhijitvalluri/android/fitnotifications/TransliterationTest.java b/app/src/test/java/com/abhijitvalluri/android/fitnotifications/TransliterationTest.java
new file mode 100644
index 0000000..443db96
--- /dev/null
+++ b/app/src/test/java/com/abhijitvalluri/android/fitnotifications/TransliterationTest.java
@@ -0,0 +1,48 @@
+package com.abhijitvalluri.android.fitnotifications;
+
+import com.ibm.icu.text.Transliterator;
+
+import org.junit.Ignore;
+import org.junit.Test;
+
+import static org.junit.Assert.*;
+
+
+public class TransliterationTest {
+
+    @Test
+    public void transliterateRussian() throws Exception {
+        assertEquals("alfavit", Transliterator.getInstance("Any-Latin").transform("алфавит"));
+    }
+
+    @Test
+    public void transliterateJapanese() throws Exception {
+        assertEquals("arufabetto", Transliterator.getInstance("Any-Latin").transform("アルファベット"));
+    }
+
+    @Test
+    public void transliterateGreek() throws Exception {
+        assertEquals("Alphabētikós", Transliterator.getInstance("Any-Latin").transform("Αλφαβητικός"));
+    }
+
+    @Test
+    @Ignore(value = "Transliterating Thai is not supported")
+    public void transliterateThai() throws Exception {
+        assertEquals("tạw xạks̄ʹr", Transliterator.getInstance("Any-Latin").transform("ตัวอักษร"));
+    }
+
+    @Test
+    public void transliterateArabic() throws Exception {
+        assertEquals("ạlạ̉bjdyẗ", Transliterator.getInstance("Any-Latin").transform("الأبجدية"));
+    }
+
+    @Test
+    public void transliterateKorean() throws Exception {
+        assertEquals("alpabes", Transliterator.getInstance("Any-Latin").transform("알파벳"));
+    }
+
+    @Test
+    public void transliterateChinese() throws Exception {
+        assertEquals("zì mǔ", Transliterator.getInstance("Any-Latin").transform("字母"));
+    }
+}
\ No newline at end of file
diff --git a/app/src/main/java/com/ibm/icu/impl/Assert.java b/icu4j/src/main/java/com/ibm/icu/impl/Assert.java
similarity index 87%
rename from app/src/main/java/com/ibm/icu/impl/Assert.java
rename to icu4j/src/main/java/com/ibm/icu/impl/Assert.java
index 7d8b113..d419cda 100644
--- a/app/src/main/java/com/ibm/icu/impl/Assert.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/Assert.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 *   Copyright (C) 2005-2006, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/BMPSet.java b/icu4j/src/main/java/com/ibm/icu/impl/BMPSet.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/BMPSet.java
rename to icu4j/src/main/java/com/ibm/icu/impl/BMPSet.java
index fc7daad..879d230 100644
--- a/app/src/main/java/com/ibm/icu/impl/BMPSet.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/BMPSet.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ******************************************************************************
  *
diff --git a/app/src/main/java/com/ibm/icu/impl/CacheBase.java b/icu4j/src/main/java/com/ibm/icu/impl/CacheBase.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/impl/CacheBase.java
rename to icu4j/src/main/java/com/ibm/icu/impl/CacheBase.java
index 11738a1..a003f84 100644
--- a/app/src/main/java/com/ibm/icu/impl/CacheBase.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/CacheBase.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 *   Copyright (C) 2010, International Business Machines
diff --git a/icu4j/src/main/java/com/ibm/icu/impl/CacheValue.java b/icu4j/src/main/java/com/ibm/icu/impl/CacheValue.java
new file mode 100644
index 0000000..340b4de
--- /dev/null
+++ b/icu4j/src/main/java/com/ibm/icu/impl/CacheValue.java
@@ -0,0 +1,150 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
+/*
+ *******************************************************************************
+ * Copyright (C) 2016, International Business Machines Corporation and
+ * others. All Rights Reserved.
+ *******************************************************************************
+ */
+package com.ibm.icu.impl;
+
+import java.lang.ref.Reference;
+import java.lang.ref.SoftReference;
+
+import com.ibm.icu.util.ICUException;
+
+/**
+ * Value type for cache items:
+ * Holds a value either via a direct reference or via a {@link Reference},
+ * depending on the current "strength" when {@code getInstance()} was called.
+ *
+ * <p>The value is <i>conceptually<i> immutable.
+ * If it is held via a direct reference, then it is actually immutable.
+ *
+ * <p>A {@code Reference} may be cleared (garbage-collected),
+ * after which {@code get()} returns null.
+ * It can then be reset via {@code resetIfAbsent()}.
+ * The new value should be the same as, or equivalent to, the old value.
+ *
+ * <p>Null values are supported. They can be distinguished from cleared values
+ * via {@code isNull()}.
+ *
+ * @param <V> Cache instance value type
+ */
+public abstract class CacheValue<V> {
+    /**
+     * "Strength" of holding a value in CacheValue instances.
+     * The default strength is {@code SOFT}.
+     */
+    public enum Strength {
+        /**
+         * Subsequent {@code getInstance()}-created objects
+         * will hold direct references to their values.
+         */
+        STRONG,
+        /**
+         * Subsequent {@code getInstance()}-created objects
+         * will hold {@link SoftReference}s to their values.
+         */
+        SOFT
+    };
+    private static volatile Strength strength = Strength.SOFT;
+
+    @SuppressWarnings("rawtypes")
+    private static final CacheValue NULL_VALUE = new NullValue();
+
+    /**
+     * Changes the "strength" of value references for subsequent {@code getInstance()} calls.
+     */
+    public static void setStrength(Strength strength) { CacheValue.strength = strength; }
+
+    /**
+     * Returns true if the "strength" is set to {@code STRONG}.
+     */
+    public static boolean futureInstancesWillBeStrong() { return strength == Strength.STRONG; }
+
+    /**
+     * Returns a CacheValue instance that holds the value.
+     * It holds it directly if the value is null or if the current "strength" is {@code STRONG}.
+     * Otherwise, it holds it via a {@link Reference}.
+     */
+    @SuppressWarnings("unchecked")
+    public static <V> CacheValue<V> getInstance(V value) {
+        if (value == null) {
+            return NULL_VALUE;
+        }
+        return strength == Strength.STRONG ? new StrongValue<V>(value) : new SoftValue<V>(value);
+    }
+
+    /**
+     * Distinguishes a null value from a Reference value that has been cleared.
+     *
+     * @return true if this object represents a null value.
+     */
+    public boolean isNull() { return false; }
+    /**
+     * Returns the value (which can be null),
+     * or null if it was held in a Reference and has been cleared.
+     */
+    public abstract V get();
+    /**
+     * If the value was held via a {@link Reference} which has been cleared,
+     * then it is replaced with a new {@link Reference} to the new value,
+     * and the new value is returned.
+     * The old and new values should be the same or equivalent.
+     *
+     * <p>Otherwise the old value is returned.
+     *
+     * @param value Replacement value, for when the current {@link Reference} has been cleared.
+     * @return The old or new value.
+     */
+    public abstract V resetIfCleared(V value);
+
+    private static final class NullValue<V> extends CacheValue<V> {
+        @Override
+        public boolean isNull() { return true; }
+        @Override
+        public V get() { return null; }
+        @Override
+        public V resetIfCleared(V value) {
+            if (value != null) {
+                throw new ICUException("resetting a null value to a non-null value");
+            }
+            return null;
+        }
+    }
+
+    private static final class StrongValue<V> extends CacheValue<V> {
+        private V value;
+
+        StrongValue(V value) { this.value = value; }
+        @Override
+        public V get() { return value; }
+        @Override
+        public V resetIfCleared(V value) {
+            // value and this.value should be equivalent, but
+            // we do not require equals() to be implemented appropriately.
+            return this.value;
+        }
+    }
+
+    private static final class SoftValue<V> extends CacheValue<V> {
+        private Reference<V> ref;
+
+        SoftValue(V value) { ref = new SoftReference<V>(value); }
+        @Override
+        public V get() { return ref.get(); }
+        @Override
+        public synchronized V resetIfCleared(V value) {
+            V oldValue = ref.get();
+            if (oldValue == null) {
+                ref = new SoftReference<V>(value);
+                return value;
+            } else {
+                // value and oldValue should be equivalent, but
+                // we do not require equals() to be implemented appropriately.
+                return oldValue;
+            }
+        }
+    }
+}
diff --git a/app/src/main/java/com/ibm/icu/impl/CalendarAstronomer.java b/icu4j/src/main/java/com/ibm/icu/impl/CalendarAstronomer.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/impl/CalendarAstronomer.java
rename to icu4j/src/main/java/com/ibm/icu/impl/CalendarAstronomer.java
index be1c29f..fdcaf20 100644
--- a/app/src/main/java/com/ibm/icu/impl/CalendarAstronomer.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/CalendarAstronomer.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2011, International Business Machines Corporation and    *
@@ -45,7 +47,7 @@ import java.util.TimeZone;
  * @internal
  */
 public class CalendarAstronomer {
-    
+
     //-------------------------------------------------------------------------
     // Astronomical constants
     //-------------------------------------------------------------------------
@@ -56,14 +58,14 @@ public class CalendarAstronomer {
      * @internal
      */
     public static final double SIDEREAL_DAY = 23.93446960027;
-    
+
     /**
      * The number of sidereal hours in one mean solar day.
      * Approximately 24.07.
      * @internal
      */
     public static final double SOLAR_DAY =  24.065709816;
-    
+
     /**
      * The average number of solar days from one new moon to the next.  This is the time
      * it takes for the moon to return the same ecliptic longitude as the sun.
@@ -75,7 +77,7 @@ public class CalendarAstronomer {
      * @internal
      */
     public static final double SYNODIC_MONTH = 29.530588853;
-    
+
     /**
      * The average number of days it takes
      * for the moon to return to the same ecliptic longitude relative to the
@@ -88,7 +90,7 @@ public class CalendarAstronomer {
      * @internal
      */
     public static final double SIDEREAL_MONTH = 27.32166;
-    
+
     /**
      * The average number number of days between successive vernal equinoxes.
      * Due to the precession of the earth's
@@ -99,7 +101,7 @@ public class CalendarAstronomer {
      * @internal
      */
     public static final double TROPICAL_YEAR = 365.242191;
-    
+
     /**
      * The average number of days it takes
      * for the sun to return to the same position against the fixed stellar
@@ -118,26 +120,26 @@ public class CalendarAstronomer {
     // Time-related constants
     //-------------------------------------------------------------------------
 
-    /** 
-     * The number of milliseconds in one second. 
+    /**
+     * The number of milliseconds in one second.
      * @internal
      */
     public static final int  SECOND_MS = 1000;
 
-    /** 
-     * The number of milliseconds in one minute. 
+    /**
+     * The number of milliseconds in one minute.
      * @internal
      */
     public static final int  MINUTE_MS = 60*SECOND_MS;
 
-    /** 
-     * The number of milliseconds in one hour. 
+    /**
+     * The number of milliseconds in one hour.
      * @internal
      */
     public static final int  HOUR_MS   = 60*MINUTE_MS;
 
-    /** 
-     * The number of milliseconds in one day. 
+    /**
+     * The number of milliseconds in one day.
      * @internal
      */
     public static final long DAY_MS    = 24*HOUR_MS;
@@ -152,7 +154,7 @@ public class CalendarAstronomer {
      * @internal
      */
     public static final long JULIAN_EPOCH_MS = -210866760000000L;
-    
+
 //  static {
 //      Calendar cal = new GregorianCalendar(TimeZone.getTimeZone("GMT"));
 //      cal.clear();
@@ -170,7 +172,7 @@ public class CalendarAstronomer {
 //      cal.add(cal.DATE, -1);
 //      System.out.println("0.0 Jan 2000 = " + cal.getTime().getTime());
 //  }
-    
+
     /**
      * Milliseconds value for 0.0 January 2000 AD.
      */
@@ -187,7 +189,7 @@ public class CalendarAstronomer {
     static private final double RAD_HOUR = 12 / PI;        // radians -> hours
     static private final double DEG_RAD  = PI / 180;        // degrees -> radians
     static private final double RAD_DEG  = 180 / PI;        // radians -> degrees
-    
+
     //-------------------------------------------------------------------------
     // Constructors
     //-------------------------------------------------------------------------
@@ -200,7 +202,7 @@ public class CalendarAstronomer {
     public CalendarAstronomer() {
         this(System.currentTimeMillis());
     }
-    
+
     /**
      * Construct a new <code>CalendarAstronomer</code> object that is initialized to
      * the specified date and time.
@@ -209,7 +211,7 @@ public class CalendarAstronomer {
     public CalendarAstronomer(Date d) {
         this(d.getTime());
     }
-    
+
     /**
      * Construct a new <code>CalendarAstronomer</code> object that is initialized to
      * the specified time.  The time is expressed as a number of milliseconds since
@@ -221,7 +223,7 @@ public class CalendarAstronomer {
     public CalendarAstronomer(long aTime) {
         time = aTime;
     }
-    
+
     /**
      * Construct a new <code>CalendarAstronomer</code> object with the given
      * latitude and longitude.  The object's time is set to the current
@@ -242,12 +244,12 @@ public class CalendarAstronomer {
         fLatitude  = normPI(latitude  * DEG_RAD);
         fGmtOffset = (long)(fLongitude * 24 * HOUR_MS / PI2);
     }
-    
-    
+
+
     //-------------------------------------------------------------------------
     // Time and date getters and setters
     //-------------------------------------------------------------------------
-    
+
     /**
      * Set the current date and time of this <code>CalendarAstronomer</code> object.  All
      * astronomical calculations are performed based on this time setting.
@@ -263,7 +265,7 @@ public class CalendarAstronomer {
         time = aTime;
         clearCache();
     }
-    
+
     /**
      * Set the current date and time of this <code>CalendarAstronomer</code> object.  All
      * astronomical calculations are performed based on this time setting.
@@ -277,13 +279,13 @@ public class CalendarAstronomer {
     public void setDate(Date date) {
         setTime(date.getTime());
     }
-    
+
     /**
      * Set the current date and time of this <code>CalendarAstronomer</code> object.  All
      * astronomical calculations are performed based on this time setting.
      *
      * @param jdn   the desired time, expressed as a "julian day number",
-     *              which is the number of elapsed days since 
+     *              which is the number of elapsed days since
      *              1/1/4713 BC (Julian), 12:00 GMT.  Note that julian day
      *              numbers start at <em>noon</em>.  To get the jdn for
      *              the corresponding midnight, subtract 0.5.
@@ -297,7 +299,7 @@ public class CalendarAstronomer {
         clearCache();
         julianDay = jdn;
     }
-    
+
     /**
      * Get the current time of this <code>CalendarAstronomer</code> object,
      * represented as the number of milliseconds since
@@ -310,7 +312,7 @@ public class CalendarAstronomer {
     public long getTime() {
         return time;
     }
-    
+
     /**
      * Get the current time of this <code>CalendarAstronomer</code> object,
      * represented as a <code>Date</code> object.
@@ -322,7 +324,7 @@ public class CalendarAstronomer {
     public Date getDate() {
         return new Date(time);
     }
-    
+
     /**
      * Get the current time of this <code>CalendarAstronomer</code> object,
      * expressed as a "julian day number", which is the number of elapsed
@@ -338,7 +340,7 @@ public class CalendarAstronomer {
         }
         return julianDay;
     }
-    
+
     /**
      * Return this object's time expressed in julian centuries:
      * the number of centuries after 1/1/1900 AD, 12:00 GMT
@@ -361,14 +363,14 @@ public class CalendarAstronomer {
         if (siderealTime == INVALID) {
             // See page 86 of "Practial Astronomy with your Calculator",
             // by Peter Duffet-Smith, for details on the algorithm.
-                
+
             double UT = normalize((double)time/HOUR_MS, 24);
-        
+
             siderealTime = normalize(getSiderealOffset() + UT*1.002737909, 24);
         }
         return siderealTime;
     }
-    
+
     private double getSiderealOffset() {
         if (siderealT0 == INVALID) {
             double JD  = Math.floor(getJulianDay() - 0.5) + 0.5;
@@ -378,7 +380,7 @@ public class CalendarAstronomer {
         }
         return siderealT0;
     }
-    
+
     /**
      * Returns the current local sidereal time, measured in hours
      * @internal
@@ -386,7 +388,7 @@ public class CalendarAstronomer {
     public double getLocalSidereal() {
         return normalize(getGreenwichSidereal() + (double)fGmtOffset/HOUR_MS, 24);
     }
-    
+
     /**
      * Converts local sidereal time to Universal Time.
      *
@@ -394,22 +396,22 @@ public class CalendarAstronomer {
      *              on this object's current date.
      *
      * @return      The corresponding Universal Time, in milliseconds since
-     *              1 Jan 1970, GMT.  
+     *              1 Jan 1970, GMT.
      */
     private long lstToUT(double lst) {
         // Convert to local mean time
         double lt = normalize((lst - getSiderealOffset()) * 0.9972695663, 24);
-        
+
         // Then find local midnight on this day
         long base = DAY_MS * ((time + fGmtOffset)/DAY_MS) - fGmtOffset;
-        
+
         //out("    lt  =" + lt + " hours");
         //out("    base=" + new Date(base));
-        
+
         return base + (long)(lt * HOUR_MS);
     }
-    
-    
+
+
     //-------------------------------------------------------------------------
     // Coordinate transformations, all based on the current time of this object
     //-------------------------------------------------------------------------
@@ -443,14 +445,14 @@ public class CalendarAstronomer {
         double obliq = eclipticObliquity();
         double sinE = Math.sin(obliq);
         double cosE = Math.cos(obliq);
-        
+
         double sinL = Math.sin(eclipLong);
         double cosL = Math.cos(eclipLong);
-        
+
         double sinB = Math.sin(eclipLat);
         double cosB = Math.cos(eclipLat);
         double tanB = Math.tan(eclipLat);
-        
+
         return new Equatorial(Math.atan2(sinL*cosE - tanB*sinE, cosL),
                                Math.asin(sinB*cosE + cosB*sinE*sinL) );
     }
@@ -474,23 +476,23 @@ public class CalendarAstronomer {
     public Horizon eclipticToHorizon(double eclipLong)
     {
         Equatorial equatorial = eclipticToEquatorial(eclipLong);
-        
+
         double H = getLocalSidereal()*PI/12 - equatorial.ascension;     // Hour-angle
-        
+
         double sinH = Math.sin(H);
         double cosH = Math.cos(H);
         double sinD = Math.sin(equatorial.declination);
         double cosD = Math.cos(equatorial.declination);
         double sinL = Math.sin(fLatitude);
         double cosL = Math.cos(fLatitude);
-        
+
         double altitude = Math.asin(sinD*sinL + cosD*cosL*cosH);
         double azimuth  = Math.atan2(-cosD*cosL*sinH, sinD - sinL * Math.sin(altitude));
 
         return new Horizon(azimuth, altitude);
     }
 
-    
+
     //-------------------------------------------------------------------------
     // The Sun
     //-------------------------------------------------------------------------
@@ -567,7 +569,7 @@ public class CalendarAstronomer {
     {
         // See page 86 of "Practial Astronomy with your Calculator",
         // by Peter Duffet-Smith, for details on the algorithm.
-        
+
         if (sunLongitude == INVALID) {
             double[] result = getSunLongitude(getJulianDay());
             sunLongitude = result[0];
@@ -575,7 +577,7 @@ public class CalendarAstronomer {
         }
         return sunLongitude;
     }
-  
+
     /**
      * TODO Make this public when the entire class is package-private.
      */
@@ -583,17 +585,17 @@ public class CalendarAstronomer {
     {
         // See page 86 of "Practial Astronomy with your Calculator",
         // by Peter Duffet-Smith, for details on the algorithm.
-        
+
         double day = julian - JD_EPOCH;       // Days since epoch
-        
+
         // Find the angular distance the sun in a fictitious
         // circular orbit has travelled since the epoch.
         double epochAngle = norm2PI(PI2/TROPICAL_YEAR*day);
-        
+
         // The epoch wasn't at the sun's perigee; find the angular distance
         // since perigee, which is called the "mean anomaly"
         double meanAnomaly = norm2PI(epochAngle + SUN_ETA_G - SUN_OMEGA_G);
-        
+
         // Now find the "true anomaly", e.g. the real solar longitude
         // by solving Kepler's equation for an elliptical orbit
         // NOTE: The 3rd ed. of the book lists omega_g and eta_g in different
@@ -612,20 +614,20 @@ public class CalendarAstronomer {
     public Equatorial getSunPosition() {
         return eclipticToEquatorial(getSunLongitude(), 0);
     }
-    
+
     private static class SolarLongitude {
         double value;
         SolarLongitude(double val) { value = val; }
     }
-    
+
     /**
      * Constant representing the vernal equinox.
-     * For use with {@link #getSunTime(SolarLongitude, boolean) getSunTime}. 
+     * For use with {@link #getSunTime(SolarLongitude, boolean) getSunTime}.
      * Note: In this case, "vernal" refers to the northern hemisphere's seasons.
      * @internal
      */
     public static final SolarLongitude VERNAL_EQUINOX  = new SolarLongitude(0);
-    
+
     /**
      * Constant representing the summer solstice.
      * For use with {@link #getSunTime(SolarLongitude, boolean) getSunTime}.
@@ -633,7 +635,7 @@ public class CalendarAstronomer {
      * @internal
      */
     public static final SolarLongitude SUMMER_SOLSTICE = new SolarLongitude(PI/2);
-    
+
     /**
      * Constant representing the autumnal equinox.
      * For use with {@link #getSunTime(SolarLongitude, boolean) getSunTime}.
@@ -641,7 +643,7 @@ public class CalendarAstronomer {
      * @internal
      */
     public static final SolarLongitude AUTUMN_EQUINOX  = new SolarLongitude(PI);
-    
+
     /**
      * Constant representing the winter solstice.
      * For use with {@link #getSunTime(SolarLongitude, boolean) getSunTime}.
@@ -649,30 +651,31 @@ public class CalendarAstronomer {
      * @internal
      */
     public static final SolarLongitude WINTER_SOLSTICE = new SolarLongitude((PI*3)/2);
-    
+
     /**
      * Find the next time at which the sun's ecliptic longitude will have
-     * the desired value.  
+     * the desired value.
      * @internal
      */
     public long getSunTime(double desired, boolean next)
     {
-        return timeOfAngle( new AngleFunc() { public double eval() { return getSunLongitude(); } },
+        return timeOfAngle( new AngleFunc() { @Override
+        public double eval() { return getSunLongitude(); } },
                             desired,
                             TROPICAL_YEAR,
                             MINUTE_MS,
                             next);
     }
-    
+
     /**
      * Find the next time at which the sun's ecliptic longitude will have
-     * the desired value.  
+     * the desired value.
      * @internal
      */
     public long getSunTime(SolarLongitude desired, boolean next) {
         return getSunTime(desired.value, next);
     }
-    
+
     /**
      * Returns the time (GMT) of sunrise or sunset on the local date to which
      * this calendar is currently set.
@@ -682,29 +685,29 @@ public class CalendarAstronomer {
      * official time zone and the geographic longitude, the
      * computation can flop over into an adjacent day if this object
      * is set to a time near local midnight.
-     * 
+     *
      * @internal
      */
-    public long getSunRiseSet(boolean rise)
-    {
+    public long getSunRiseSet(boolean rise) {
         long t0 = time;
 
         // Make a rough guess: 6am or 6pm local time on the current day
         long noon = ((time + fGmtOffset)/DAY_MS)*DAY_MS - fGmtOffset + 12*HOUR_MS;
-        
+
         setTime(noon + (rise ? -6L : 6L) * HOUR_MS);
-        
+
         long t = riseOrSet(new CoordFunc() {
-                            public Equatorial eval() { return getSunPosition(); }
-                         },
-                         rise,
-                         .533 * DEG_RAD,        // Angular Diameter
-                         34 /60.0 * DEG_RAD,    // Refraction correction
-                         MINUTE_MS / 12);       // Desired accuracy
+            @Override
+            public Equatorial eval() { return getSunPosition(); }
+            },
+                rise,
+                .533 * DEG_RAD,        // Angular Diameter
+                34 /60.0 * DEG_RAD,    // Refraction correction
+                MINUTE_MS / 12);       // Desired accuracy
 
-        setTime(t0);
-        return t;
-    }
+            setTime(t0);
+            return t;
+        }
 
 // Commented out - currently unused. ICU 2.6, Alan
 //    //-------------------------------------------------------------------------
@@ -739,7 +742,7 @@ public class CalendarAstronomer {
 //        if (lst1s > 24) lst1s -= 24;
 //        if (lst2r > 24) lst2r -= 24;
 //        if (lst2s > 24) lst2s -= 24;
-//        
+//
 //        // 4. Convert LSTs to GSTs.  If GST1 > GST2, add 24 to GST2.
 //        double gst1r = lstToGst(lst1r);
 //        double gst1s = lstToGst(lst1s);
@@ -750,12 +753,12 @@ public class CalendarAstronomer {
 //
 //        // 5. Calculate GST at 0h UT of this date
 //        double t00 = utToGst(0);
-//        
+//
 //        // 6. Calculate GST at 0h on the observer's longitude
 //        double offset = Math.round(fLongitude*12/PI); // p.95 step 6; he _rounds_ to nearest 15 deg.
 //        double t00p = t00 - offset*1.002737909;
 //        if (t00p < 0) t00p += 24; // do NOT normalize
-//        
+//
 //        // 7. Adjust
 //        if (gst1r < t00p) {
 //            gst1r += 24;
@@ -799,7 +802,7 @@ public class CalendarAstronomer {
 //        double delta = fLongitude * 24 / PI2;
 //        return normalize(lst - delta, 24);
 //    }
- 
+
 // Commented out - currently unused. ICU 2.6, Alan
 //    /**
 //     * Convert UT to GST on this date.
@@ -843,7 +846,7 @@ public class CalendarAstronomer {
 //    //-------------------------------------------------------------------------
 //
 //    // Note: This method appears to produce inferior accuracy as
-//    // compared to getSunRiseSet(). 
+//    // compared to getSunRiseSet().
 //
 //    /**
 //     * TODO Make this public when the entire class is package-private.
@@ -854,62 +857,62 @@ public class CalendarAstronomer {
 //        double d = (double)(time - EPOCH_2000_MS) / DAY_MS;
 //
 //        // Now compute the Local Sidereal Time, LST:
-//        // 
+//        //
 //        double LST  =  98.9818  +  0.985647352 * d  +  /*UT*15  +  long*/
 //            fLongitude*RAD_DEG;
-//        // 
+//        //
 //        // (east long. positive).  Note that LST is here expressed in degrees,
 //        // where 15 degrees corresponds to one hour.  Since LST really is an angle,
 //        // it's convenient to use one unit---degrees---throughout.
 //
 //        //     COMPUTING THE SUN'S POSITION
 //        //     ----------------------------
-//        // 
+//        //
 //        // To be able to compute the Sun's rise/set times, you need to be able to
 //        // compute the Sun's position at any time.  First compute the "day
 //        // number" d as outlined above, for the desired moment.  Next compute:
-//        // 
+//        //
 //        double oblecl = 23.4393 - 3.563E-7 * d;
-//        // 
+//        //
 //        double w  =  282.9404  +  4.70935E-5   * d;
 //        double M  =  356.0470  +  0.9856002585 * d;
 //        double e  =  0.016709  -  1.151E-9     * d;
-//        // 
+//        //
 //        // This is the obliquity of the ecliptic, plus some of the elements of
 //        // the Sun's apparent orbit (i.e., really the Earth's orbit): w =
 //        // argument of perihelion, M = mean anomaly, e = eccentricity.
 //        // Semi-major axis is here assumed to be exactly 1.0 (while not strictly
 //        // true, this is still an accurate approximation).  Next compute E, the
 //        // eccentric anomaly:
-//        // 
+//        //
 //        double E = M + e*(180/PI) * Math.sin(M*DEG_RAD) * ( 1.0 + e*Math.cos(M*DEG_RAD) );
-//        // 
+//        //
 //        // where E and M are in degrees.  This is it---no further iterations are
 //        // needed because we know e has a sufficiently small value.  Next compute
 //        // the true anomaly, v, and the distance, r:
-//        // 
+//        //
 //        /*      r * cos(v)  =  */ double A  =  Math.cos(E*DEG_RAD) - e;
 //        /*      r * sin(v)  =  */ double B  =  Math.sqrt(1 - e*e) * Math.sin(E*DEG_RAD);
-//        // 
+//        //
 //        // and
-//        // 
+//        //
 //        //      r  =  sqrt( A*A + B*B )
 //        double v  =  Math.atan2( B, A )*RAD_DEG;
-//        // 
+//        //
 //        // The Sun's true longitude, slon, can now be computed:
-//        // 
+//        //
 //        double slon  =  v + w;
-//        // 
+//        //
 //        // Since the Sun is always at the ecliptic (or at least very very close to
 //        // it), we can use simplified formulae to convert slon (the Sun's ecliptic
 //        // longitude) to sRA and sDec (the Sun's RA and Dec):
-//        // 
+//        //
 //        //                   sin(slon) * cos(oblecl)
 //        //     tan(sRA)  =  -------------------------
 //        //             cos(slon)
-//        // 
+//        //
 //        //     sin(sDec) =  sin(oblecl) * sin(slon)
-//        // 
+//        //
 //        // As was the case when computing az, the Azimuth, if possible use an
 //        // atan2() function to compute sRA.
 //
@@ -920,38 +923,38 @@ public class CalendarAstronomer {
 //
 //        //     COMPUTING RISE AND SET TIMES
 //        //     ----------------------------
-//        // 
+//        //
 //        // To compute when an object rises or sets, you must compute when it
 //        // passes the meridian and the HA of rise/set.  Then the rise time is
 //        // the meridian time minus HA for rise/set, and the set time is the
 //        // meridian time plus the HA for rise/set.
-//        // 
+//        //
 //        // To find the meridian time, compute the Local Sidereal Time at 0h local
 //        // time (or 0h UT if you prefer to work in UT) as outlined above---name
 //        // that quantity LST0.  The Meridian Time, MT, will now be:
-//        // 
+//        //
 //        //     MT  =  RA - LST0
 //        double MT = normalize(sRA - LST, 360);
-//        // 
+//        //
 //        // where "RA" is the object's Right Ascension (in degrees!).  If negative,
 //        // add 360 deg to MT.  If the object is the Sun, leave the time as it is,
 //        // but if it's stellar, multiply MT by 365.2422/366.2422, to convert from
 //        // sidereal to solar time.  Now, compute HA for rise/set, name that
 //        // quantity HA0:
-//        // 
+//        //
 //        //                 sin(h0)  -  sin(lat) * sin(Dec)
 //        // cos(HA0)  =  ---------------------------------
 //        //                      cos(lat) * cos(Dec)
-//        // 
+//        //
 //        // where h0 is the altitude selected to represent rise/set.  For a purely
 //        // mathematical horizon, set h0 = 0 and simplify to:
-//        // 
+//        //
 //        //     cos(HA0)  =  - tan(lat) * tan(Dec)
-//        // 
+//        //
 //        // If you want to account for refraction on the atmosphere, set h0 = -35/60
 //        // degrees (-35 arc minutes), and if you want to compute the rise/set times
 //        // for the Sun's upper limb, set h0 = -50/60 (-50 arc minutes).
-//        // 
+//        //
 //        double h0 = -50/60 * DEG_RAD;
 //
 //        double HA0 = Math.acos(
@@ -961,12 +964,12 @@ public class CalendarAstronomer {
 //        // When HA0 has been computed, leave it as it is for the Sun but multiply
 //        // by 365.2422/366.2422 for stellar objects, to convert from sidereal to
 //        // solar time.  Finally compute:
-//        // 
+//        //
 //        //    Rise time  =  MT - HA0
 //        //    Set  time  =  MT + HA0
-//        // 
+//        //
 //        // convert the times from degrees to hours by dividing by 15.
-//        // 
+//        //
 //        // If you'd like to check that your calculations are accurate or just
 //        // need a quick result, check the USNO's Sun or Moon Rise/Set Table,
 //        // <URL:http://aa.usno.navy.mil/AA/data/docs/RS_OneYear.html>.
@@ -982,18 +985,18 @@ public class CalendarAstronomer {
     //-------------------------------------------------------------------------
     // The Moon
     //-------------------------------------------------------------------------
-    
+
     static final double moonL0 = 318.351648 * PI/180;   // Mean long. at epoch
     static final double moonP0 =  36.340410 * PI/180;   // Mean long. of perigee
     static final double moonN0 = 318.510107 * PI/180;   // Mean long. of node
     static final double moonI  =   5.145366 * PI/180;   // Inclination of orbit
     static final double moonE  =   0.054900;            // Eccentricity of orbit
-    
+
     // These aren't used right now
     static final double moonA  =   3.84401e5;           // semi-major axis (km)
     static final double moonT0 =   0.5181 * PI/180;     // Angular size at distance A
     static final double moonPi =   0.9507 * PI/180;     // Parallax at distance A
-    
+
     /**
      * The position of the moon at the time set on this
      * object, in equatorial coordinates.
@@ -1009,18 +1012,18 @@ public class CalendarAstronomer {
             // Calculate the solar longitude.  Has the side effect of
             // filling in "meanAnomalySun" as well.
             double sunLong = getSunLongitude();
-            
+
             //
             // Find the # of days since the epoch of our orbital parameters.
             // TODO: Convert the time of day portion into ephemeris time
             //
             double day = getJulianDay() - JD_EPOCH;       // Days since epoch
-            
+
             // Calculate the mean longitude and anomaly of the moon, based on
             // a circular orbit.  Similar to the corresponding solar calculation.
             double meanLongitude = norm2PI(13.1763966*PI/180*day + moonL0);
             double meanAnomalyMoon = norm2PI(meanLongitude - 0.1114041*PI/180 * day - moonP0);
-            
+
             //
             // Calculate the following corrections:
             //  Evection:   the sun's gravity affects the moon's eccentricity
@@ -1033,7 +1036,7 @@ public class CalendarAstronomer {
             double a3       = 0.3700*PI/180 * Math.sin(meanAnomalySun);
 
             meanAnomalyMoon += evection - annual - a3;
-            
+
             //
             // More correction factors:
             //  center  equation of the center correction
@@ -1043,7 +1046,7 @@ public class CalendarAstronomer {
             //
             double center = 6.2886*PI/180 * Math.sin(meanAnomalyMoon);
             double a4 =     0.2140*PI/180 * Math.sin(2 * meanAnomalyMoon);
-            
+
             // Now find the moon's corrected longitude
             moonLongitude = meanLongitude + evection + center - annual + a4;
 
@@ -1053,9 +1056,9 @@ public class CalendarAstronomer {
             // the earth the moon is on
             //
             double variation = 0.6583*PI/180 * Math.sin(2*(moonLongitude - sunLong));
-            
+
             moonLongitude += variation;
-            
+
             //
             // What we've calculated so far is the moon's longitude in the plane
             // of its own orbit.  Now map to the ecliptic to get the latitude
@@ -1069,7 +1072,7 @@ public class CalendarAstronomer {
 
             double y = Math.sin(moonLongitude - nodeLongitude);
             double x = Math.cos(moonLongitude - nodeLongitude);
-            
+
             moonEclipLong = Math.atan2(y*Math.cos(moonI), x) + nodeLongitude;
             double moonEclipLat = Math.asin(y * Math.sin(moonI));
 
@@ -1077,7 +1080,7 @@ public class CalendarAstronomer {
         }
         return moonPosition;
     }
-    
+
     /**
      * The "age" of the moon at the time specified in this object.
      * This is really the angle between the
@@ -1095,10 +1098,10 @@ public class CalendarAstronomer {
         // some the intermediate results cached during that calculation.
         //
         getMoonPosition();
-        
+
         return norm2PI(moonEclipLong - sunLongitude);
     }
-    
+
     /**
      * Calculate the phase of the moon at the time set in this object.
      * The returned phase is a <code>double</code> in the range
@@ -1118,12 +1121,12 @@ public class CalendarAstronomer {
         // by Peter Duffet-Smith, for details on the algorithm.
         return 0.5 * (1 - Math.cos(getMoonAge()));
     }
-    
+
     private static class MoonAge {
         double value;
         MoonAge(double val) { value = val; }
     }
-    
+
     /**
      * Constant representing a new moon.
      * For use with {@link #getMoonTime(MoonAge, boolean) getMoonTime}
@@ -1137,53 +1140,54 @@ public class CalendarAstronomer {
      * @internal
      */
     public static final MoonAge FIRST_QUARTER = new MoonAge(PI/2);
-    
+
     /**
      * Constant representing a full moon.
      * For use with {@link #getMoonTime(MoonAge, boolean) getMoonTime}
      * @internal
      */
     public static final MoonAge FULL_MOON     = new MoonAge(PI);
-    
+
     /**
      * Constant representing the moon's last quarter.
      * For use with {@link #getMoonTime(MoonAge, boolean) getMoonTime}
      * @internal
      */
     public static final MoonAge LAST_QUARTER  = new MoonAge((PI*3)/2);
-    
+
     /**
      * Find the next or previous time at which the Moon's ecliptic
-     * longitude will have the desired value.  
+     * longitude will have the desired value.
      * <p>
      * @param desired   The desired longitude.
      * @param next      <tt>true</tt> if the next occurrance of the phase
-     *                  is desired, <tt>false</tt> for the previous occurrance. 
+     *                  is desired, <tt>false</tt> for the previous occurrance.
      * @internal
      */
     public long getMoonTime(double desired, boolean next)
     {
         return timeOfAngle( new AngleFunc() {
+                            @Override
                             public double eval() { return getMoonAge(); } },
                             desired,
                             SYNODIC_MONTH,
                             MINUTE_MS,
                             next);
     }
-    
+
     /**
      * Find the next or previous time at which the moon will be in the
      * desired phase.
      * <p>
      * @param desired   The desired phase of the moon.
      * @param next      <tt>true</tt> if the next occurrance of the phase
-     *                  is desired, <tt>false</tt> for the previous occurrance. 
+     *                  is desired, <tt>false</tt> for the previous occurrance.
      * @internal
      */
     public long getMoonTime(MoonAge desired, boolean next) {
         return getMoonTime(desired.value, next);
     }
-    
+
     /**
      * Returns the time (GMT) of sunrise or sunset on the local date to which
      * this calendar is currently set.
@@ -1192,6 +1196,7 @@ public class CalendarAstronomer {
     public long getMoonRiseSet(boolean rise)
     {
         return riseOrSet(new CoordFunc() {
+                            @Override
                             public Equatorial eval() { return getMoonPosition(); }
                          },
                          rise,
@@ -1203,27 +1208,27 @@ public class CalendarAstronomer {
     //-------------------------------------------------------------------------
     // Interpolation methods for finding the time at which a given event occurs
     //-------------------------------------------------------------------------
-    
+
     private interface AngleFunc {
         public double eval();
     }
-    
+
     private long timeOfAngle(AngleFunc func, double desired,
                              double periodDays, long epsilon, boolean next)
     {
         // Find the value of the function at the current time
         double lastAngle = func.eval();
-        
+
         // Find out how far we are from the desired angle
         double deltaAngle = norm2PI(desired - lastAngle) ;
-        
+
         // Using the average period, estimate the next (or previous) time at
         // which the desired angle occurs.
         double deltaT =  (deltaAngle + (next ? 0 : -PI2)) * (periodDays*DAY_MS) / PI2;
-        
+
         double lastDeltaT = deltaT; // Liu
         long startTime = time; // Liu
-        
+
         setTime(time + (long)deltaT);
 
         // Now iterate until we get the error below epsilon.  Throughout
@@ -1238,17 +1243,17 @@ public class CalendarAstronomer {
 
             // Correct the time estimate based on how far off the angle is
             deltaT = normPI(desired - angle) * factor;
-            
+
             // HACK:
-            // 
+            //
             // If abs(deltaT) begins to diverge we need to quit this loop.
             // This only appears to happen when attempting to locate, for
             // example, a new moon on the day of the new moon.  E.g.:
-            // 
+            //
             // This result is correct:
             // newMoon(7508(Mon Jul 23 00:00:00 CST 1990,false))=
             //   Sun Jul 22 10:57:41 CST 1990
-            // 
+            //
             // But attempting to make the same call a day earlier causes deltaT
             // to diverge:
             // CalendarAstronomer.timeOfAngle() diverging: 1.348508727575625E9 ->
@@ -1272,23 +1277,23 @@ public class CalendarAstronomer {
             setTime(time + (long)deltaT);
         }
         while (Math.abs(deltaT) > epsilon);
-        
+
         return time;
     }
-    
+
     private interface CoordFunc {
         public Equatorial eval();
     }
-    
+
     private long riseOrSet(CoordFunc func, boolean rise,
-                           double diameter, double refraction, 
+                           double diameter, double refraction,
                            long epsilon)
-    {        
+    {
         Equatorial  pos = null;
         double      tanL   = Math.tan(fLatitude);
         long        deltaT = Long.MAX_VALUE;
         int         count = 0;
-        
+
         //
         // Calculate the object's position at the current time, then use that
         // position to calculate the time of rising or setting.  The position
@@ -1299,10 +1304,10 @@ public class CalendarAstronomer {
             pos = func.eval();
             double angle = Math.acos(-tanL * Math.tan(pos.declination));
             double lst = ((rise ? PI2-angle : angle) + pos.ascension ) * 24 / PI2;
-                         
+
             // Convert from LST to Universal Time.
             long newTime = lstToUT( lst );
-            
+
             deltaT = newTime - time;
             setTime(newTime);
         }
@@ -1314,10 +1319,10 @@ public class CalendarAstronomer {
         double x     = diameter / 2 + refraction;
         double y     = Math.asin(Math.sin(x) / Math.sin(psi));
         long  delta  = (long)((240 * y * RAD_DEG / cosD)*SECOND_MS);
-        
+
         return time + (rise ? -delta : delta);
     }
-    
+
     //-------------------------------------------------------------------------
     // Other utility methods
     //-------------------------------------------------------------------------
@@ -1329,7 +1334,7 @@ public class CalendarAstronomer {
     private static final double normalize(double value, double range) {
         return value - range * Math.floor(value / range);
     }
-    
+
     /**
      * Normalize an angle so that it's in the range 0 - 2pi.
      * For positive angles this is just (angle % 2pi), but the Java
@@ -1338,14 +1343,14 @@ public class CalendarAstronomer {
     private static final double norm2PI(double angle) {
         return normalize(angle, PI2);
     }
-    
+
     /**
      * Normalize an angle into the range -PI - PI
      */
     private static final double normPI(double angle) {
         return normalize(angle + PI, PI2) - PI;
     }
-    
+
     /**
      * Find the "true anomaly" (longitude) of an object from
      * its mean anomaly and the eccentricity of its orbit.  This uses
@@ -1353,7 +1358,7 @@ public class CalendarAstronomer {
      *
      * @param meanAnomaly   The object's longitude calculated as if it were in
      *                      a regular, circular orbit, measured in radians
-     *                      from the point of perigee.  
+     *                      from the point of perigee.
      *
      * @param eccentricity  The eccentricity of the orbit
      *
@@ -1368,13 +1373,13 @@ public class CalendarAstronomer {
         do {
             delta = E - eccentricity * Math.sin(E) - meanAnomaly;
             E = E - delta / (1 - eccentricity * Math.cos(E));
-        } 
+        }
         while (Math.abs(delta) > 1e-5); // epsilon = 1e-5 rad
 
         return 2.0 * Math.atan( Math.tan(E/2) * Math.sqrt( (1+eccentricity)
                                                           /(1-eccentricity) ) );
     }
-    
+
     /**
      * Return the obliquity of the ecliptic (the angle between the ecliptic
      * and the earth's equator) at the current time.  This varies due to
@@ -1388,42 +1393,42 @@ public class CalendarAstronomer {
             final double epoch = 2451545.0;     // 2000 AD, January 1.5
 
             double T = (getJulianDay() - epoch) / 36525;
-            
+
             eclipObliquity = 23.439292
                            - 46.815/3600 * T
                            - 0.0006/3600 * T*T
                            + 0.00181/3600 * T*T*T;
-                           
+
             eclipObliquity *= DEG_RAD;
         }
         return eclipObliquity;
     }
-    
-     
+
+
     //-------------------------------------------------------------------------
     // Private data
     //-------------------------------------------------------------------------
-    
+
     /**
      * Current time in milliseconds since 1/1/1970 AD
      * @see java.util.Date#getTime
      */
     private long time;
-    
+
     /* These aren't used yet, but they'll be needed for sunset calculations
      * and equatorial to horizon coordinate conversions
      */
     private double fLongitude = 0.0;
     private double fLatitude  = 0.0;
     private long   fGmtOffset = 0;
-    
+
     //
     // The following fields are used to cache calculated results for improved
     // performance.  These values all depend on the current time setting
     // of this object, so the clearCache method is provided.
     //
     static final private double INVALID = Double.MIN_VALUE;
-    
+
     private transient double    julianDay       = INVALID;
     private transient double    julianCentury   = INVALID;
     private transient double    sunLongitude    = INVALID;
@@ -1434,7 +1439,7 @@ public class CalendarAstronomer {
     private transient double    eclipObliquity  = INVALID;
     private transient double    siderealT0      = INVALID;
     private transient double    siderealTime    = INVALID;
-    
+
     private transient Equatorial  moonPosition = null;
 
     private void clearCache() {
@@ -1450,15 +1455,15 @@ public class CalendarAstronomer {
         siderealT0      = INVALID;
         moonPosition    = null;
     }
-    
+
     //private static void out(String s) {
     //    System.out.println(s);
     //}
-    
+
     //private static String deg(double rad) {
     //    return Double.toString(rad * RAD_DEG);
     //}
-    
+
     //private static String hours(long ms) {
     //    return Double.toString((double)ms / HOUR_MS) + " hours";
     //}
@@ -1469,11 +1474,11 @@ public class CalendarAstronomer {
     public String local(long localMillis) {
         return new Date(localMillis - TimeZone.getDefault().getRawOffset()).toString();
     }
-    
-    
+
+
     /**
      * Represents the position of an object in the sky relative to the ecliptic,
-     * the plane of the earth's orbit around the Sun. 
+     * the plane of the earth's orbit around the Sun.
      * This is a spherical coordinate system in which the latitude
      * specifies the position north or south of the plane of the ecliptic.
      * The longitude specifies the position along the ecliptic plane
@@ -1505,10 +1510,11 @@ public class CalendarAstronomer {
          * Return a string representation of this object
          * @internal
          */
+        @Override
         public String toString() {
             return Double.toString(longitude*RAD_DEG) + "," + (latitude*RAD_DEG);
         }
-        
+
         /**
          * The ecliptic latitude, in radians.  This specifies an object's
          * position north or south of the plane of the ecliptic,
@@ -1516,7 +1522,7 @@ public class CalendarAstronomer {
          * @internal
          */
         public final double latitude;
-        
+
         /**
          * The ecliptic longitude, in radians.
          * This specifies an object's position along the ecliptic plane
@@ -1532,8 +1538,8 @@ public class CalendarAstronomer {
     }
 
     /**
-     * Represents the position of an 
-     * object in the sky relative to the plane of the earth's equator. 
+     * Represents the position of an
+     * object in the sky relative to the plane of the earth's equator.
      * The <i>Right Ascension</i> specifies the position east or west
      * along the equator, relative to the sun's position at the vernal
      * equinox.  The <i>Declination</i> is the position north or south
@@ -1565,10 +1571,11 @@ public class CalendarAstronomer {
          * angles measured in degrees.
          * @internal
          */
+        @Override
         public String toString() {
             return Double.toString(ascension*RAD_DEG) + "," + (declination*RAD_DEG);
         }
-        
+
         /**
          * Return a string representation of this object with the right ascension
          * measured in hours, minutes, and seconds.
@@ -1577,16 +1584,16 @@ public class CalendarAstronomer {
         public String toHmsString() {
             return radToHms(ascension) + "," + radToDms(declination);
         }
-        
+
         /**
-         * The right ascension, in radians. 
+         * The right ascension, in radians.
          * This is the position east or west along the equator
          * relative to the sun's position at the vernal equinox,
          * with positive angles representing East.
          * @internal
          */
         public final double ascension;
-        
+
         /**
          * The declination, in radians.
          * This is the position north or south of the equatorial plane,
@@ -1597,7 +1604,7 @@ public class CalendarAstronomer {
     }
 
     /**
-     * Represents the position of an  object in the sky relative to 
+     * Represents the position of an  object in the sky relative to
      * the local horizon.
      * The <i>Altitude</i> represents the object's elevation above the horizon,
      * with objects below the horizon having a negative altitude.
@@ -1631,18 +1638,19 @@ public class CalendarAstronomer {
          * angles measured in degrees.
          * @internal
          */
+        @Override
         public String toString() {
             return Double.toString(altitude*RAD_DEG) + "," + (azimuth*RAD_DEG);
         }
-        
-        /** 
-         * The object's altitude above the horizon, in radians. 
+
+        /**
+         * The object's altitude above the horizon, in radians.
          * @internal
          */
         public final double altitude;
-        
-        /** 
-         * The object's direction, in radians clockwise from north. 
+
+        /**
+         * The object's direction, in radians clockwise from north.
          * @internal
          */
         public final double azimuth;
@@ -1652,15 +1660,15 @@ public class CalendarAstronomer {
         int hrs = (int) (angle*RAD_HOUR);
         int min = (int)((angle*RAD_HOUR - hrs) * 60);
         int sec = (int)((angle*RAD_HOUR - hrs - min/60.0) * 3600);
-        
+
         return Integer.toString(hrs) + "h" + min + "m" + sec + "s";
     }
-    
+
     static private String radToDms(double angle) {
         int deg = (int) (angle*RAD_DEG);
         int min = (int)((angle*RAD_DEG - deg) * 60);
         int sec = (int)((angle*RAD_DEG - deg - min/60.0) * 3600);
-        
+
         return Integer.toString(deg) + "\u00b0" + min + "'" + sec + "\"";
     }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/CalendarCache.java b/icu4j/src/main/java/com/ibm/icu/impl/CalendarCache.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/impl/CalendarCache.java
rename to icu4j/src/main/java/com/ibm/icu/impl/CalendarCache.java
index ed1a3d5..d401bad 100644
--- a/app/src/main/java/com/ibm/icu/impl/CalendarCache.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/CalendarCache.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2011, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/impl/CalendarData.java b/icu4j/src/main/java/com/ibm/icu/impl/CalendarData.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/CalendarData.java
rename to icu4j/src/main/java/com/ibm/icu/impl/CalendarData.java
index f87703e..9ebce0b 100644
--- a/app/src/main/java/com/ibm/icu/impl/CalendarData.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/CalendarData.java
@@ -25,7 +25,7 @@ public class CalendarData {
      * No default lookup is done.
      */
     public CalendarData(ULocale loc, String type) {
-        this((ICUResourceBundle)UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, loc), type);
+        this((ICUResourceBundle)UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, loc), type);
     }
     
     public CalendarData(ICUResourceBundle b, String type) {
diff --git a/app/src/main/java/com/ibm/icu/impl/CalendarUtil.java b/icu4j/src/main/java/com/ibm/icu/impl/CalendarUtil.java
similarity index 51%
rename from app/src/main/java/com/ibm/icu/impl/CalendarUtil.java
rename to icu4j/src/main/java/com/ibm/icu/impl/CalendarUtil.java
index ba46800..a463278 100644
--- a/app/src/main/java/com/ibm/icu/impl/CalendarUtil.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/CalendarUtil.java
@@ -1,12 +1,16 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2009,2016 International Business Machines Corporation and         *
- * others. All Rights Reserved.                                                *
+ * Copyright (C) 2009,2016 International Business Machines Corporation and
+ * others. All Rights Reserved.
  *******************************************************************************
  */
 package com.ibm.icu.impl;
 
+import java.util.Map;
 import java.util.MissingResourceException;
+import java.util.TreeMap;
 
 import com.ibm.icu.util.ULocale;
 import com.ibm.icu.util.UResourceBundle;
@@ -21,10 +25,7 @@ import com.ibm.icu.util.UResourceBundle;
  * package for sharing some calendar internal code for calendar
  * and date format.
  */
-public class CalendarUtil {
-
-    private static ICUCache<String, String> CALTYPE_CACHE = new SimpleCache<String, String>();
-
+public final class CalendarUtil {
     private static final String CALKEY = "calendar";
     private static final String DEFCAL = "gregorian";
 
@@ -37,9 +38,7 @@ public class CalendarUtil {
      * @return Calendar type string, such as "gregorian"
      */
     public static String getCalendarType(ULocale loc) {
-        String calType = null;
-
-        calType = loc.getKeywordValue(CALKEY);
+        String calType = loc.getKeywordValue(CALKEY);
         if (calType != null) {
             return calType;
         }
@@ -54,42 +53,42 @@ public class CalendarUtil {
         // When calendar keyword is not available, use the locale's
         // region to get the default calendar type
         String region = ULocale.getRegionForSupplementalData(canonical, true);
+        return CalendarPreferences.INSTANCE.getCalendarTypeForRegion(region);
+    }
 
-        // Check the cache (now we cache by region, not base locale)
-        calType = CALTYPE_CACHE.get(region);
-        if (calType != null) {
-            return calType;
-        }
+    private static final class CalendarPreferences extends UResource.Sink {
+        private static final CalendarPreferences INSTANCE = new CalendarPreferences();
+        // A TreeMap should be good because we expect very few entries.
+        Map<String, String> prefs = new TreeMap<String, String>();
 
-        // Read supplementalData to get the default calendar type for
-        // the locale's region
-        try {
-            UResourceBundle rb = UResourceBundle.getBundleInstance(
-                                    ICUResourceBundle.ICU_BASE_NAME,
-                                    "supplementalData",
-                                    ICUResourceBundle.ICU_DATA_CLASS_LOADER);
-            UResourceBundle calPref = rb.get("calendarPreferenceData");
-            UResourceBundle order = null;
+        CalendarPreferences() {
             try {
-                order = calPref.get(region);
+                ICUResourceBundle rb = (ICUResourceBundle)UResourceBundle.getBundleInstance(
+                        ICUData.ICU_BASE_NAME, "supplementalData");
+                rb.getAllItemsWithFallback("calendarPreferenceData", this);
             } catch (MissingResourceException mre) {
-                // use "001" as fallback
-                order = calPref.get("001");
+                // Always use "gregorian".
             }
-            // the first calendar type is the default for the region
-            calType = order.getString(0);
-        } catch (MissingResourceException mre) {
-            // fall through
         }
 
-        if (calType == null) {
-            // Use "gregorian" as the last resort fallback.
-            calType = DEFCAL;
+        String getCalendarTypeForRegion(String region) {
+            String type = prefs.get(region);
+            return type == null ? DEFCAL : type;
         }
 
-        // Cache the resolved value for the next time
-        CALTYPE_CACHE.put(region, calType);
-
-        return calType;
+        @Override
+        public void put(UResource.Key key, UResource.Value value, boolean noFallback) {
+            UResource.Table calendarPreferenceData = value.getTable();
+            for (int i = 0; calendarPreferenceData.getKeyAndValue(i, key, value); ++i) {
+                UResource.Array types = value.getArray();
+                // The first calendar type is the default for the region.
+                if (types.getValue(0, value)) {
+                    String type = value.getString();
+                    if (!type.equals(DEFCAL)) {
+                        prefs.put(key.toString(), type);
+                    }
+                }
+            }
+        }
     }
 }
diff --git a/icu4j/src/main/java/com/ibm/icu/impl/CaseMap.java b/icu4j/src/main/java/com/ibm/icu/impl/CaseMap.java
new file mode 100644
index 0000000..0d1c259
--- /dev/null
+++ b/icu4j/src/main/java/com/ibm/icu/impl/CaseMap.java
@@ -0,0 +1,758 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
+package com.ibm.icu.impl;
+
+import com.ibm.icu.util.ULocale;
+
+public final class CaseMap {
+    /**
+     * Implementation of UCaseProps.ContextIterator, iterates over a String.
+     * See ustrcase.c/utf16_caseContextIterator().
+     */
+    public static final class StringContextIterator implements UCaseProps.ContextIterator {
+        /**
+         * Constructor.
+         * @param s String to iterate over.
+         */
+        public StringContextIterator(String s) {
+            this.s=s;
+            limit=s.length();
+            cpStart=cpLimit=index=0;
+            dir=0;
+        }
+
+        /**
+         * Set the iteration limit for nextCaseMapCP() to an index within the string.
+         * If the limit parameter is negative or past the string, then the
+         * string length is restored as the iteration limit.
+         *
+         * <p>This limit does not affect the next() function which always
+         * iterates to the very end of the string.
+         *
+         * @param lim The iteration limit.
+         */
+        public void setLimit(int lim) {
+            if(0<=lim && lim<=s.length()) {
+                limit=lim;
+            } else {
+                limit=s.length();
+            }
+        }
+
+        /**
+         * Move to the iteration limit without fetching code points up to there.
+         */
+        public void moveToLimit() {
+            cpStart=cpLimit=limit;
+        }
+
+        /**
+         * Iterate forward through the string to fetch the next code point
+         * to be case-mapped, and set the context indexes for it.
+         *
+         * <p>When the iteration limit is reached (and -1 is returned),
+         * getCPStart() will be at the iteration limit.
+         *
+         * <p>Iteration with next() does not affect the position for nextCaseMapCP().
+         *
+         * @return The next code point to be case-mapped, or <0 when the iteration is done.
+         */
+        public int nextCaseMapCP() {
+            cpStart=cpLimit;
+            if(cpLimit<limit) {
+                int c=s.codePointAt(cpLimit);
+                cpLimit+=Character.charCount(c);
+                return c;
+            } else {
+                return -1;
+            }
+        }
+
+        /**
+         * Returns the start of the code point that was last returned
+         * by nextCaseMapCP().
+         */
+        public int getCPStart() {
+            return cpStart;
+        }
+
+        /**
+         * Returns the limit of the code point that was last returned
+         * by nextCaseMapCP().
+         */
+        public int getCPLimit() {
+            return cpLimit;
+        }
+
+        // implement UCaseProps.ContextIterator
+        // The following code is not used anywhere in this private class
+        @Override
+        public void reset(int direction) {
+            if(direction>0) {
+                /* reset for forward iteration */
+                dir=1;
+                index=cpLimit;
+            } else if(direction<0) {
+                /* reset for backward iteration */
+                dir=-1;
+                index=cpStart;
+            } else {
+                // not a valid direction
+                dir=0;
+                index=0;
+            }
+        }
+
+        @Override
+        public int next() {
+            int c;
+
+            if(dir>0 && index<s.length()) {
+                c=s.codePointAt(index);
+                index+=Character.charCount(c);
+                return c;
+            } else if(dir<0 && index>0) {
+                c=s.codePointBefore(index);
+                index-=Character.charCount(c);
+                return c;
+            }
+            return -1;
+        }
+
+        // variables
+        protected String s;
+        protected int index, limit, cpStart, cpLimit;
+        protected int dir; // 0=initial state  >0=forward  <0=backward
+    }
+
+    /** Appends a full case mapping result, see {@link UCaseProps#MAX_STRING_LENGTH}. */
+    private static final void appendResult(int c, StringBuilder result) {
+        // Decode the result.
+        if (c < 0) {
+            // (not) original code point
+            result.appendCodePoint(~c);
+        } else if (c <= UCaseProps.MAX_STRING_LENGTH) {
+            // The mapping has already been appended to result.
+        } else {
+            // Append the single-code point mapping.
+            result.appendCodePoint(c);
+        }
+    }
+
+    // TODO: Move the other string case mapping functions from UCharacter to here, too.
+
+    public static String toUpper(ULocale locale, String str) {
+        if (locale == null) {
+            locale = ULocale.getDefault();
+        }
+        int[] locCache = new int[] { UCaseProps.getCaseLocale(locale, null) };
+        if (locCache[0] == UCaseProps.LOC_GREEK) {
+            return GreekUpper.toUpper(str, locCache);
+        }
+
+        StringContextIterator iter = new StringContextIterator(str);
+        StringBuilder result = new StringBuilder(str.length());
+        int c;
+        while((c=iter.nextCaseMapCP())>=0) {
+            c = UCaseProps.INSTANCE.toFullUpper(c, iter, result, locale, locCache);
+            appendResult(c, result);
+        }
+        return result.toString();
+    }
+
+    private static final class GreekUpper {
+        // Data bits.
+        private static final int UPPER_MASK = 0x3ff;
+        private static final int HAS_VOWEL = 0x1000;
+        private static final int HAS_YPOGEGRAMMENI = 0x2000;
+        private static final int HAS_ACCENT = 0x4000;
+        private static final int HAS_DIALYTIKA = 0x8000;
+        // Further bits during data building and processing, not stored in the data map.
+        private static final int HAS_COMBINING_DIALYTIKA = 0x10000;
+        private static final int HAS_OTHER_GREEK_DIACRITIC = 0x20000;
+
+        private static final int HAS_VOWEL_AND_ACCENT = HAS_VOWEL | HAS_ACCENT;
+        private static final int HAS_VOWEL_AND_ACCENT_AND_DIALYTIKA =
+                HAS_VOWEL_AND_ACCENT | HAS_DIALYTIKA;
+        private static final int HAS_EITHER_DIALYTIKA = HAS_DIALYTIKA | HAS_COMBINING_DIALYTIKA;
+
+        // State bits.
+        private static final int AFTER_CASED = 1;
+        private static final int AFTER_VOWEL_WITH_ACCENT = 2;
+
+        // Data generated by prototype code, see
+        // http://site.icu-project.org/design/case/greek-upper
+        // TODO: Move this data into ucase.icu.
+        private static final char[] data0370 = {
+            // U+0370..03FF
+            0x0370,  // Ͱ
+            0x0370,  // ͱ
+            0x0372,  // Ͳ
+            0x0372,  // ͳ
+            0,
+            0,
+            0x0376,  // Ͷ
+            0x0376,  // ͷ
+            0,
+            0,
+            0x037A,  // ͺ
+            0x03FD,  // ͻ
+            0x03FE,  // ͼ
+            0x03FF,  // ͽ
+            0,
+            0x037F,  // Ϳ
+            0,
+            0,
+            0,
+            0,
+            0,
+            0,
+            0x0391 | HAS_VOWEL | HAS_ACCENT,  // Ά
+            0,
+            0x0395 | HAS_VOWEL | HAS_ACCENT,  // Έ
+            0x0397 | HAS_VOWEL | HAS_ACCENT,  // Ή
+            0x0399 | HAS_VOWEL | HAS_ACCENT,  // Ί
+            0,
+            0x039F | HAS_VOWEL | HAS_ACCENT,  // Ό
+            0,
+            0x03A5 | HAS_VOWEL | HAS_ACCENT,  // Ύ
+            0x03A9 | HAS_VOWEL | HAS_ACCENT,  // Ώ
+            0x0399 | HAS_VOWEL | HAS_ACCENT | HAS_DIALYTIKA,  // ΐ
+            0x0391 | HAS_VOWEL,  // Α
+            0x0392,  // Β
+            0x0393,  // Γ
+            0x0394,  // Δ
+            0x0395 | HAS_VOWEL,  // Ε
+            0x0396,  // Ζ
+            0x0397 | HAS_VOWEL,  // Η
+            0x0398,  // Θ
+            0x0399 | HAS_VOWEL,  // Ι
+            0x039A,  // Κ
+            0x039B,  // Λ
+            0x039C,  // Μ
+            0x039D,  // Ν
+            0x039E,  // Ξ
+            0x039F | HAS_VOWEL,  // Ο
+            0x03A0,  // Π
+            0x03A1,  // Ρ
+            0,
+            0x03A3,  // Σ
+            0x03A4,  // Τ
+            0x03A5 | HAS_VOWEL,  // Υ
+            0x03A6,  // Φ
+            0x03A7,  // Χ
+            0x03A8,  // Ψ
+            0x03A9 | HAS_VOWEL,  // Ω
+            0x0399 | HAS_VOWEL | HAS_DIALYTIKA,  // Ϊ
+            0x03A5 | HAS_VOWEL | HAS_DIALYTIKA,  // Ϋ
+            0x0391 | HAS_VOWEL | HAS_ACCENT,  // ά
+            0x0395 | HAS_VOWEL | HAS_ACCENT,  // έ
+            0x0397 | HAS_VOWEL | HAS_ACCENT,  // ή
+            0x0399 | HAS_VOWEL | HAS_ACCENT,  // ί
+            0x03A5 | HAS_VOWEL | HAS_ACCENT | HAS_DIALYTIKA,  // ΰ
+            0x0391 | HAS_VOWEL,  // α
+            0x0392,  // β
+            0x0393,  // γ
+            0x0394,  // δ
+            0x0395 | HAS_VOWEL,  // ε
+            0x0396,  // ζ
+            0x0397 | HAS_VOWEL,  // η
+            0x0398,  // θ
+            0x0399 | HAS_VOWEL,  // ι
+            0x039A,  // κ
+            0x039B,  // λ
+            0x039C,  // μ
+            0x039D,  // ν
+            0x039E,  // ξ
+            0x039F | HAS_VOWEL,  // ο
+            0x03A0,  // π
+            0x03A1,  // ρ
+            0x03A3,  // ς
+            0x03A3,  // σ
+            0x03A4,  // τ
+            0x03A5 | HAS_VOWEL,  // υ
+            0x03A6,  // φ
+            0x03A7,  // χ
+            0x03A8,  // ψ
+            0x03A9 | HAS_VOWEL,  // ω
+            0x0399 | HAS_VOWEL | HAS_DIALYTIKA,  // ϊ
+            0x03A5 | HAS_VOWEL | HAS_DIALYTIKA,  // ϋ
+            0x039F | HAS_VOWEL | HAS_ACCENT,  // ό
+            0x03A5 | HAS_VOWEL | HAS_ACCENT,  // ύ
+            0x03A9 | HAS_VOWEL | HAS_ACCENT,  // ώ
+            0x03CF,  // Ϗ
+            0x0392,  // ϐ
+            0x0398,  // ϑ
+            0x03D2,  // ϒ
+            0x03D2 | HAS_ACCENT,  // ϓ
+            0x03D2 | HAS_DIALYTIKA,  // ϔ
+            0x03A6,  // ϕ
+            0x03A0,  // ϖ
+            0x03CF,  // ϗ
+            0x03D8,  // Ϙ
+            0x03D8,  // ϙ
+            0x03DA,  // Ϛ
+            0x03DA,  // ϛ
+            0x03DC,  // Ϝ
+            0x03DC,  // ϝ
+            0x03DE,  // Ϟ
+            0x03DE,  // ϟ
+            0x03E0,  // Ϡ
+            0x03E0,  // ϡ
+            0,
+            0,
+            0,
+            0,
+            0,
+            0,
+            0,
+            0,
+            0,
+            0,
+            0,
+            0,
+            0,
+            0,
+            0x039A,  // ϰ
+            0x03A1,  // ϱ
+            0x03F9,  // ϲ
+            0x037F,  // ϳ
+            0x03F4,  // ϴ
+            0x0395 | HAS_VOWEL,  // ϵ
+            0,
+            0x03F7,  // Ϸ
+            0x03F7,  // ϸ
+            0x03F9,  // Ϲ
+            0x03FA,  // Ϻ
+            0x03FA,  // ϻ
+            0x03FC,  // ϼ
+            0x03FD,  // Ͻ
+            0x03FE,  // Ͼ
+            0x03FF,  // Ͽ
+        };
+
+        private static final char[] data1F00 = {
+            // U+1F00..1FFF
+            0x0391 | HAS_VOWEL,  // ἀ
+            0x0391 | HAS_VOWEL,  // ἁ
+            0x0391 | HAS_VOWEL | HAS_ACCENT,  // ἂ
+            0x0391 | HAS_VOWEL | HAS_ACCENT,  // ἃ
+            0x0391 | HAS_VOWEL | HAS_ACCENT,  // ἄ
+            0x0391 | HAS_VOWEL | HAS_ACCENT,  // ἅ
+            0x0391 | HAS_VOWEL | HAS_ACCENT,  // ἆ
+            0x0391 | HAS_VOWEL | HAS_ACCENT,  // ἇ
+            0x0391 | HAS_VOWEL,  // Ἀ
+            0x0391 | HAS_VOWEL,  // Ἁ
+            0x0391 | HAS_VOWEL | HAS_ACCENT,  // Ἂ
+            0x0391 | HAS_VOWEL | HAS_ACCENT,  // Ἃ
+            0x0391 | HAS_VOWEL | HAS_ACCENT,  // Ἄ
+            0x0391 | HAS_VOWEL | HAS_ACCENT,  // Ἅ
+            0x0391 | HAS_VOWEL | HAS_ACCENT,  // Ἆ
+            0x0391 | HAS_VOWEL | HAS_ACCENT,  // Ἇ
+            0x0395 | HAS_VOWEL,  // ἐ
+            0x0395 | HAS_VOWEL,  // ἑ
+            0x0395 | HAS_VOWEL | HAS_ACCENT,  // ἒ
+            0x0395 | HAS_VOWEL | HAS_ACCENT,  // ἓ
+            0x0395 | HAS_VOWEL | HAS_ACCENT,  // ἔ
+            0x0395 | HAS_VOWEL | HAS_ACCENT,  // ἕ
+            0,
+            0,
+            0x0395 | HAS_VOWEL,  // Ἐ
+            0x0395 | HAS_VOWEL,  // Ἑ
+            0x0395 | HAS_VOWEL | HAS_ACCENT,  // Ἒ
+            0x0395 | HAS_VOWEL | HAS_ACCENT,  // Ἓ
+            0x0395 | HAS_VOWEL | HAS_ACCENT,  // Ἔ
+            0x0395 | HAS_VOWEL | HAS_ACCENT,  // Ἕ
+            0,
+            0,
+            0x0397 | HAS_VOWEL,  // ἠ
+            0x0397 | HAS_VOWEL,  // ἡ
+            0x0397 | HAS_VOWEL | HAS_ACCENT,  // ἢ
+            0x0397 | HAS_VOWEL | HAS_ACCENT,  // ἣ
+            0x0397 | HAS_VOWEL | HAS_ACCENT,  // ἤ
+            0x0397 | HAS_VOWEL | HAS_ACCENT,  // ἥ
+            0x0397 | HAS_VOWEL | HAS_ACCENT,  // ἦ
+            0x0397 | HAS_VOWEL | HAS_ACCENT,  // ἧ
+            0x0397 | HAS_VOWEL,  // Ἠ
+            0x0397 | HAS_VOWEL,  // Ἡ
+            0x0397 | HAS_VOWEL | HAS_ACCENT,  // Ἢ
+            0x0397 | HAS_VOWEL | HAS_ACCENT,  // Ἣ
+            0x0397 | HAS_VOWEL | HAS_ACCENT,  // Ἤ
+            0x0397 | HAS_VOWEL | HAS_ACCENT,  // Ἥ
+            0x0397 | HAS_VOWEL | HAS_ACCENT,  // Ἦ
+            0x0397 | HAS_VOWEL | HAS_ACCENT,  // Ἧ
+            0x0399 | HAS_VOWEL,  // ἰ
+            0x0399 | HAS_VOWEL,  // ἱ
+            0x0399 | HAS_VOWEL | HAS_ACCENT,  // ἲ
+            0x0399 | HAS_VOWEL | HAS_ACCENT,  // ἳ
+            0x0399 | HAS_VOWEL | HAS_ACCENT,  // ἴ
+            0x0399 | HAS_VOWEL | HAS_ACCENT,  // ἵ
+            0x0399 | HAS_VOWEL | HAS_ACCENT,  // ἶ
+            0x0399 | HAS_VOWEL | HAS_ACCENT,  // ἷ
+            0x0399 | HAS_VOWEL,  // Ἰ
+            0x0399 | HAS_VOWEL,  // Ἱ
+            0x0399 | HAS_VOWEL | HAS_ACCENT,  // Ἲ
+            0x0399 | HAS_VOWEL | HAS_ACCENT,  // Ἳ
+            0x0399 | HAS_VOWEL | HAS_ACCENT,  // Ἴ
+            0x0399 | HAS_VOWEL | HAS_ACCENT,  // Ἵ
+            0x0399 | HAS_VOWEL | HAS_ACCENT,  // Ἶ
+            0x0399 | HAS_VOWEL | HAS_ACCENT,  // Ἷ
+            0x039F | HAS_VOWEL,  // ὀ
+            0x039F | HAS_VOWEL,  // ὁ
+            0x039F | HAS_VOWEL | HAS_ACCENT,  // ὂ
+            0x039F | HAS_VOWEL | HAS_ACCENT,  // ὃ
+            0x039F | HAS_VOWEL | HAS_ACCENT,  // ὄ
+            0x039F | HAS_VOWEL | HAS_ACCENT,  // ὅ
+            0,
+            0,
+            0x039F | HAS_VOWEL,  // Ὀ
+            0x039F | HAS_VOWEL,  // Ὁ
+            0x039F | HAS_VOWEL | HAS_ACCENT,  // Ὂ
+            0x039F | HAS_VOWEL | HAS_ACCENT,  // Ὃ
+            0x039F | HAS_VOWEL | HAS_ACCENT,  // Ὄ
+            0x039F | HAS_VOWEL | HAS_ACCENT,  // Ὅ
+            0,
+            0,
+            0x03A5 | HAS_VOWEL,  // ὐ
+            0x03A5 | HAS_VOWEL,  // ὑ
+            0x03A5 | HAS_VOWEL | HAS_ACCENT,  // ὒ
+            0x03A5 | HAS_VOWEL | HAS_ACCENT,  // ὓ
+            0x03A5 | HAS_VOWEL | HAS_ACCENT,  // ὔ
+            0x03A5 | HAS_VOWEL | HAS_ACCENT,  // ὕ
+            0x03A5 | HAS_VOWEL | HAS_ACCENT,  // ὖ
+            0x03A5 | HAS_VOWEL | HAS_ACCENT,  // ὗ
+            0,
+            0x03A5 | HAS_VOWEL,  // Ὑ
+            0,
+            0x03A5 | HAS_VOWEL | HAS_ACCENT,  // Ὓ
+            0,
+            0x03A5 | HAS_VOWEL | HAS_ACCENT,  // Ὕ
+            0,
+            0x03A5 | HAS_VOWEL | HAS_ACCENT,  // Ὗ
+            0x03A9 | HAS_VOWEL,  // ὠ
+            0x03A9 | HAS_VOWEL,  // ὡ
+            0x03A9 | HAS_VOWEL | HAS_ACCENT,  // ὢ
+            0x03A9 | HAS_VOWEL | HAS_ACCENT,  // ὣ
+            0x03A9 | HAS_VOWEL | HAS_ACCENT,  // ὤ
+            0x03A9 | HAS_VOWEL | HAS_ACCENT,  // ὥ
+            0x03A9 | HAS_VOWEL | HAS_ACCENT,  // ὦ
+            0x03A9 | HAS_VOWEL | HAS_ACCENT,  // ὧ
+            0x03A9 | HAS_VOWEL,  // Ὠ
+            0x03A9 | HAS_VOWEL,  // Ὡ
+            0x03A9 | HAS_VOWEL | HAS_ACCENT,  // Ὢ
+            0x03A9 | HAS_VOWEL | HAS_ACCENT,  // Ὣ
+            0x03A9 | HAS_VOWEL | HAS_ACCENT,  // Ὤ
+            0x03A9 | HAS_VOWEL | HAS_ACCENT,  // Ὥ
+            0x03A9 | HAS_VOWEL | HAS_ACCENT,  // Ὦ
+            0x03A9 | HAS_VOWEL | HAS_ACCENT,  // Ὧ
+            0x0391 | HAS_VOWEL | HAS_ACCENT,  // ὰ
+            0x0391 | HAS_VOWEL | HAS_ACCENT,  // ά
+            0x0395 | HAS_VOWEL | HAS_ACCENT,  // ὲ
+            0x0395 | HAS_VOWEL | HAS_ACCENT,  // έ
+            0x0397 | HAS_VOWEL | HAS_ACCENT,  // ὴ
+            0x0397 | HAS_VOWEL | HAS_ACCENT,  // ή
+            0x0399 | HAS_VOWEL | HAS_ACCENT,  // ὶ
+            0x0399 | HAS_VOWEL | HAS_ACCENT,  // ί
+            0x039F | HAS_VOWEL | HAS_ACCENT,  // ὸ
+            0x039F | HAS_VOWEL | HAS_ACCENT,  // ό
+            0x03A5 | HAS_VOWEL | HAS_ACCENT,  // ὺ
+            0x03A5 | HAS_VOWEL | HAS_ACCENT,  // ύ
+            0x03A9 | HAS_VOWEL | HAS_ACCENT,  // ὼ
+            0x03A9 | HAS_VOWEL | HAS_ACCENT,  // ώ
+            0,
+            0,
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI,  // ᾀ
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI,  // ᾁ
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾂ
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾃ
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾄ
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾅ
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾆ
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾇ
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI,  // ᾈ
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI,  // ᾉ
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾊ
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾋ
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾌ
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾍ
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾎ
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾏ
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI,  // ᾐ
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI,  // ᾑ
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾒ
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾓ
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾔ
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾕ
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾖ
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾗ
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI,  // ᾘ
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI,  // ᾙ
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾚ
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾛ
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾜ
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾝ
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾞ
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾟ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI,  // ᾠ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI,  // ᾡ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾢ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾣ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾤ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾥ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾦ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾧ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI,  // ᾨ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI,  // ᾩ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾪ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾫ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾬ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾭ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾮ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾯ
+            0x0391 | HAS_VOWEL,  // ᾰ
+            0x0391 | HAS_VOWEL,  // ᾱ
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾲ
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI,  // ᾳ
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾴ
+            0,
+            0x0391 | HAS_VOWEL | HAS_ACCENT,  // ᾶ
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ᾷ
+            0x0391 | HAS_VOWEL,  // Ᾰ
+            0x0391 | HAS_VOWEL,  // Ᾱ
+            0x0391 | HAS_VOWEL | HAS_ACCENT,  // Ὰ
+            0x0391 | HAS_VOWEL | HAS_ACCENT,  // Ά
+            0x0391 | HAS_VOWEL | HAS_YPOGEGRAMMENI,  // ᾼ
+            0,
+            0x0399 | HAS_VOWEL,  // ι
+            0,
+            0,
+            0,
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ῂ
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI,  // ῃ
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ῄ
+            0,
+            0x0397 | HAS_VOWEL | HAS_ACCENT,  // ῆ
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ῇ
+            0x0395 | HAS_VOWEL | HAS_ACCENT,  // Ὲ
+            0x0395 | HAS_VOWEL | HAS_ACCENT,  // Έ
+            0x0397 | HAS_VOWEL | HAS_ACCENT,  // Ὴ
+            0x0397 | HAS_VOWEL | HAS_ACCENT,  // Ή
+            0x0397 | HAS_VOWEL | HAS_YPOGEGRAMMENI,  // ῌ
+            0,
+            0,
+            0,
+            0x0399 | HAS_VOWEL,  // ῐ
+            0x0399 | HAS_VOWEL,  // ῑ
+            0x0399 | HAS_VOWEL | HAS_ACCENT | HAS_DIALYTIKA,  // ῒ
+            0x0399 | HAS_VOWEL | HAS_ACCENT | HAS_DIALYTIKA,  // ΐ
+            0,
+            0,
+            0x0399 | HAS_VOWEL | HAS_ACCENT,  // ῖ
+            0x0399 | HAS_VOWEL | HAS_ACCENT | HAS_DIALYTIKA,  // ῗ
+            0x0399 | HAS_VOWEL,  // Ῐ
+            0x0399 | HAS_VOWEL,  // Ῑ
+            0x0399 | HAS_VOWEL | HAS_ACCENT,  // Ὶ
+            0x0399 | HAS_VOWEL | HAS_ACCENT,  // Ί
+            0,
+            0,
+            0,
+            0,
+            0x03A5 | HAS_VOWEL,  // ῠ
+            0x03A5 | HAS_VOWEL,  // ῡ
+            0x03A5 | HAS_VOWEL | HAS_ACCENT | HAS_DIALYTIKA,  // ῢ
+            0x03A5 | HAS_VOWEL | HAS_ACCENT | HAS_DIALYTIKA,  // ΰ
+            0x03A1,  // ῤ
+            0x03A1,  // ῥ
+            0x03A5 | HAS_VOWEL | HAS_ACCENT,  // ῦ
+            0x03A5 | HAS_VOWEL | HAS_ACCENT | HAS_DIALYTIKA,  // ῧ
+            0x03A5 | HAS_VOWEL,  // Ῠ
+            0x03A5 | HAS_VOWEL,  // Ῡ
+            0x03A5 | HAS_VOWEL | HAS_ACCENT,  // Ὺ
+            0x03A5 | HAS_VOWEL | HAS_ACCENT,  // Ύ
+            0x03A1,  // Ῥ
+            0,
+            0,
+            0,
+            0,
+            0,
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ῲ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI,  // ῳ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ῴ
+            0,
+            0x03A9 | HAS_VOWEL | HAS_ACCENT,  // ῶ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI | HAS_ACCENT,  // ῷ
+            0x039F | HAS_VOWEL | HAS_ACCENT,  // Ὸ
+            0x039F | HAS_VOWEL | HAS_ACCENT,  // Ό
+            0x03A9 | HAS_VOWEL | HAS_ACCENT,  // Ὼ
+            0x03A9 | HAS_VOWEL | HAS_ACCENT,  // Ώ
+            0x03A9 | HAS_VOWEL | HAS_YPOGEGRAMMENI,  // ῼ
+            0,
+            0,
+            0,
+        };
+
+        // U+2126 Ohm sign
+        private static final char data2126 = 0x03A9 | HAS_VOWEL;  // Ω
+
+        private static final int getLetterData(int c) {
+            if (c < 0x370 || 0x2126 < c || (0x3ff < c && c < 0x1f00)) {
+                return 0;
+            } else if (c <= 0x3ff) {
+                return data0370[c - 0x370];
+            } else if (c <= 0x1fff) {
+                return data1F00[c - 0x1f00];
+            } else if (c == 0x2126) {
+                return data2126;
+            } else {
+                return 0;
+            }
+        }
+
+        /**
+         * Returns a non-zero value for each of the Greek combining diacritics
+         * listed in The Unicode Standard, version 8, chapter 7.2 Greek,
+         * plus some perispomeni look-alikes.
+         */
+        private static final int getDiacriticData(int c) {
+            switch (c) {
+            case '\u0300':  // varia
+            case '\u0301':  // tonos = oxia
+            case '\u0342':  // perispomeni
+            case '\u0302':  // circumflex can look like perispomeni
+            case '\u0303':  // tilde can look like perispomeni
+            case '\u0311':  // inverted breve can look like perispomeni
+                return HAS_ACCENT;
+            case '\u0308':  // dialytika = diaeresis
+                return HAS_COMBINING_DIALYTIKA;
+            case '\u0344':  // dialytika tonos
+                return HAS_COMBINING_DIALYTIKA | HAS_ACCENT;
+            case '\u0345':  // ypogegrammeni = iota subscript
+                return HAS_YPOGEGRAMMENI;
+            case '\u0304':  // macron
+            case '\u0306':  // breve
+            case '\u0313':  // comma above
+            case '\u0314':  // reversed comma above
+            case '\u0343':  // koronis
+                return HAS_OTHER_GREEK_DIACRITIC;
+            default:
+                return 0;
+            }
+        }
+
+        private static boolean isFollowedByCasedLetter(CharSequence s, int i) {
+            while (i < s.length()) {
+                int c = Character.codePointAt(s, i);
+                int type = UCaseProps.INSTANCE.getTypeOrIgnorable(c);
+                if ((type & UCaseProps.IGNORABLE) != 0) {
+                    // Case-ignorable, continue with the loop.
+                } else if (type != UCaseProps.NONE) {
+                    return true;  // Followed by cased letter.
+                } else {
+                    return false;  // Uncased and not case-ignorable.
+                }
+            }
+            return false;  // Not followed by cased letter.
+        }
+
+        /**
+         * Greek string uppercasing with a state machine.
+         * Probably simpler than a stateless function that has to figure out complex context-before
+         * for each character.
+         * TODO: Try to re-consolidate one way or another with the non-Greek function.
+         *
+         * <p>Keep this consistent with the C++ versions in ustrcase.cpp (UTF-16) and ucasemap.cpp (UTF-8).
+         */
+        private static String toUpper(CharSequence s, int[] locCache) {
+            StringBuilder result = new StringBuilder(s.length());
+            int state = 0;
+            for (int i = 0; i < s.length();) {
+                int c = Character.codePointAt(s, i);
+                int nextIndex = i + Character.charCount(c);
+                int nextState = 0;
+                int type = UCaseProps.INSTANCE.getTypeOrIgnorable(c);
+                if ((type & UCaseProps.IGNORABLE) != 0) {
+                    // c is case-ignorable
+                    nextState |= (state & AFTER_CASED);
+                } else if (type != UCaseProps.NONE) {
+                    // c is cased
+                    nextState |= AFTER_CASED;
+                }
+                int data = getLetterData(c);
+                if (data > 0) {
+                    int upper = data & UPPER_MASK;
+                    // Add a dialytika to this iota or ypsilon vowel
+                    // if we removed a tonos from the previous vowel,
+                    // and that previous vowel did not also have (or gain) a dialytika.
+                    // Adding one only to the final vowel in a longer sequence
+                    // (which does not occur in normal writing) would require lookahead.
+                    // Set the same flag as for preserving an existing dialytika.
+                    if ((data & HAS_VOWEL) != 0 && (state & AFTER_VOWEL_WITH_ACCENT) != 0 &&
+                            (upper == 'Ι' || upper == 'Υ')) {
+                        data |= HAS_DIALYTIKA;
+                    }
+                    int numYpogegrammeni = 0;  // Map each one to a trailing, spacing, capital iota.
+                    if ((data & HAS_YPOGEGRAMMENI) != 0) {
+                        numYpogegrammeni = 1;
+                    }
+                    // Skip combining diacritics after this Greek letter.
+                    while (nextIndex < s.length()) {
+                        int diacriticData = getDiacriticData(s.charAt(nextIndex));
+                        if (diacriticData != 0) {
+                            data |= diacriticData;
+                            if ((diacriticData & HAS_YPOGEGRAMMENI) != 0) {
+                                ++numYpogegrammeni;
+                            }
+                            ++nextIndex;
+                        } else {
+                            break;  // not a Greek diacritic
+                        }
+                    }
+                    if ((data & HAS_VOWEL_AND_ACCENT_AND_DIALYTIKA) == HAS_VOWEL_AND_ACCENT) {
+                        nextState |= AFTER_VOWEL_WITH_ACCENT;
+                    }
+                    // Map according to Greek rules.
+                    boolean addTonos = false;
+                    if (upper == 'Η' &&
+                            (data & HAS_ACCENT) != 0 &&
+                            numYpogegrammeni == 0 &&
+                            (state & AFTER_CASED) == 0 &&
+                            !isFollowedByCasedLetter(s, nextIndex)) {
+                        // Keep disjunctive "or" with (only) a tonos.
+                        // We use the same "word boundary" conditions as for the Final_Sigma test.
+                        if (i == nextIndex) {
+                            upper = 'Ή';  // Preserve the precomposed form.
+                        } else {
+                            addTonos = true;
+                        }
+                    } else if ((data & HAS_DIALYTIKA) != 0) {
+                        // Preserve a vowel with dialytika in precomposed form if it exists.
+                        if (upper == 'Ι') {
+                            upper = 'Ϊ';
+                            data &= ~HAS_EITHER_DIALYTIKA;
+                        } else if (upper == 'Υ') {
+                            upper = 'Ϋ';
+                            data &= ~HAS_EITHER_DIALYTIKA;
+                        }
+                    }
+                    result.appendCodePoint(upper);
+                    if ((data & HAS_EITHER_DIALYTIKA) != 0) {
+                        result.append('\u0308');  // restore or add a dialytika
+                    }
+                    if (addTonos) {
+                        result.append('\u0301');
+                    }
+                    while (numYpogegrammeni > 0) {
+                        result.append('Ι');
+                        --numYpogegrammeni;
+                    }
+                } else {
+                    c = UCaseProps.INSTANCE.toFullUpper(c, null, result, null, locCache);
+                    appendResult(c, result);
+                }
+                i = nextIndex;
+                state = nextState;
+            }
+            return result.toString();
+        }
+    }
+}
diff --git a/app/src/main/java/com/ibm/icu/impl/CharTrie.java b/icu4j/src/main/java/com/ibm/icu/impl/CharTrie.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/impl/CharTrie.java
rename to icu4j/src/main/java/com/ibm/icu/impl/CharTrie.java
index 6d8a1b1..688b620 100644
--- a/app/src/main/java/com/ibm/icu/impl/CharTrie.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/CharTrie.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ******************************************************************************
  * Copyright (C) 1996-2015, International Business Machines Corporation and
@@ -101,7 +103,7 @@ public class CharTrie extends Trie
     }
 
     // public methods --------------------------------------------------
-    
+
     /**
     * Gets the value associated with the codepoint.
     * If no value is associated with the codepoint, a default value will be
@@ -116,14 +118,14 @@ public class CharTrie extends Trie
         // fastpath for U+0000..U+D7FF
         if(0 <= ch && ch < UTF16.LEAD_SURROGATE_MIN_VALUE) {
             // copy of getRawOffset()
-            offset = (m_index_[ch >> INDEX_STAGE_1_SHIFT_] << INDEX_STAGE_2_SHIFT_) 
+            offset = (m_index_[ch >> INDEX_STAGE_1_SHIFT_] << INDEX_STAGE_2_SHIFT_)
                     + (ch & INDEX_STAGE_3_MASK_);
             return m_data_[offset];
         }
 
         // handle U+D800..U+10FFFF
         offset = getCodePointOffset(ch);
-        
+
         // return -1 if there is an error, in this case we return the default
         // value: m_initialValue_
         return (offset >= 0) ? m_data_[offset] : m_initialValue_;
@@ -172,7 +174,7 @@ public class CharTrie extends Trie
     /**
     * <p>Get a value from a folding offset (from the value of a lead surrogate)
     * and a trail surrogate.</p>
-    * <p>If the 
+    * <p>If the
     * @param leadvalue value associated with the lead surrogate which contains
     *        the folding offset
     * @param trail surrogate
@@ -186,24 +188,24 @@ public class CharTrie extends Trie
         }
         int offset = m_dataManipulate_.getFoldingOffset(leadvalue);
         if (offset > 0) {
-            return m_data_[getRawOffset(offset, 
+            return m_data_[getRawOffset(offset,
                                         (char)(trail & SURROGATE_MASK_))];
         }
         return m_initialValue_;
     }
-    
+
     /**
      * <p>Gets the latin 1 fast path value.</p>
-     * <p>Note this only works if latin 1 characters have their own linear 
+     * <p>Note this only works if latin 1 characters have their own linear
      * array.</p>
      * @param ch latin 1 characters
      * @return value associated with latin character
      */
-    public final char getLatin1LinearValue(char ch) 
+    public final char getLatin1LinearValue(char ch)
     {
         return m_data_[INDEX_STAGE_3_MASK_ + 1 + m_dataOffset_ + ch];
     }
-    
+
     /**
      * Checks if the argument Trie has the same data as this Trie
      * @param other Trie to check
@@ -211,7 +213,8 @@ public class CharTrie extends Trie
      *         otherwise
      */
     ///CLOVER:OFF
-    public boolean equals(Object other) 
+    @Override
+    public boolean equals(Object other)
     {
         boolean result = super.equals(other);
         if (result && other instanceof CharTrie) {
@@ -220,7 +223,8 @@ public class CharTrie extends Trie
         }
         return false;
     }
-    
+
+    @Override
     public int hashCode() {
         assert false : "hashCode not designed";
         return 42;
@@ -234,6 +238,7 @@ public class CharTrie extends Trie
      * data array</p>
      * @param bytes buffer containing trie data
      */
+    @Override
     protected final void unserialize(ByteBuffer bytes)
     {
         int indexDataLength = m_dataOffset_ + m_dataLength_;
@@ -248,13 +253,14 @@ public class CharTrie extends Trie
     * @param trail trailing surrogate
     * @return offset to data
     */
+    @Override
     protected final int getSurrogateOffset(char lead, char trail)
     {
         if (m_dataManipulate_ == null) {
             throw new NullPointerException(
                              "The field DataManipulate in this Trie is null");
         }
-        
+
         // get fold position for the next trail surrogate
         int offset = m_dataManipulate_.getFoldingOffset(getLeadValue(lead));
 
@@ -267,7 +273,7 @@ public class CharTrie extends Trie
         // value: m_initialValue_
         return -1;
     }
-    
+
     /**
     * Gets the value at the argument index.
     * For use internally in TrieIterator.
@@ -275,6 +281,7 @@ public class CharTrie extends Trie
     * @return 32 bit value
     * @see com.ibm.icu.impl.TrieIterator
     */
+    @Override
     protected final int getValue(int index)
     {
         return m_data_[index];
@@ -282,13 +289,14 @@ public class CharTrie extends Trie
 
     /**
     * Gets the default initial value
-    * @return 32 bit value 
+    * @return 32 bit value
     */
+    @Override
     protected final int getInitialValue()
     {
         return m_initialValue_;
     }
-  
+
     // private data members --------------------------------------------
 
     /**
diff --git a/app/src/main/java/com/ibm/icu/impl/CharacterIteration.java b/icu4j/src/main/java/com/ibm/icu/impl/CharacterIteration.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/impl/CharacterIteration.java
rename to icu4j/src/main/java/com/ibm/icu/impl/CharacterIteration.java
index 202f738..a26b81a 100644
--- a/app/src/main/java/com/ibm/icu/impl/CharacterIteration.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/CharacterIteration.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2013, International Business Machines Corporation and         *
@@ -29,11 +31,11 @@ public final class CharacterIteration {
     public static int next32(CharacterIterator ci) {
         // If the current position is at a surrogate pair, move to the trail surrogate
         //   which leaves it in position for underlying iterator's next() to work.
-        int c= ci.current();
+        int c = ci.current();
         if (c >= UTF16.LEAD_SURROGATE_MIN_VALUE && c<=UTF16.LEAD_SURROGATE_MAX_VALUE) {
             c = ci.next();   
             if (c<UTF16.TRAIL_SURROGATE_MIN_VALUE || c>UTF16.TRAIL_SURROGATE_MAX_VALUE) {
-               c = ci.previous();   
+                ci.previous();   
             }
         }
 
diff --git a/app/src/main/java/com/ibm/icu/impl/CharacterIteratorWrapper.java b/icu4j/src/main/java/com/ibm/icu/impl/CharacterIteratorWrapper.java
similarity index 89%
rename from app/src/main/java/com/ibm/icu/impl/CharacterIteratorWrapper.java
rename to icu4j/src/main/java/com/ibm/icu/impl/CharacterIteratorWrapper.java
index 3e0dcd0..d657f77 100644
--- a/app/src/main/java/com/ibm/icu/impl/CharacterIteratorWrapper.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/CharacterIteratorWrapper.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
@@ -11,26 +13,27 @@ import java.text.CharacterIterator;
 import com.ibm.icu.text.UCharacterIterator;
 
 /**
- * This class is a wrapper around CharacterIterator and implements the 
+ * This class is a wrapper around CharacterIterator and implements the
  * UCharacterIterator protocol
  * @author ram
  */
 
 public class CharacterIteratorWrapper extends UCharacterIterator {
-    
+
     private CharacterIterator iterator;
-    
-    
+
+
     public CharacterIteratorWrapper(CharacterIterator iter){
         if(iter==null){
             throw new IllegalArgumentException();
         }
-        iterator     = iter;   
+        iterator     = iter;
     }
 
     /**
      * @see UCharacterIterator#current()
      */
+    @Override
     public int current() {
         int c = iterator.current();
         if(c==CharacterIterator.DONE){
@@ -42,6 +45,7 @@ public class CharacterIteratorWrapper extends UCharacterIterator {
     /**
      * @see UCharacterIterator#getLength()
      */
+    @Override
     public int getLength() {
         return (iterator.getEndIndex() - iterator.getBeginIndex());
     }
@@ -49,6 +53,7 @@ public class CharacterIteratorWrapper extends UCharacterIterator {
     /**
      * @see UCharacterIterator#getIndex()
      */
+    @Override
     public int getIndex() {
         return iterator.getIndex();
     }
@@ -56,10 +61,11 @@ public class CharacterIteratorWrapper extends UCharacterIterator {
     /**
      * @see UCharacterIterator#next()
      */
+    @Override
     public int next() {
         int i = iterator.current();
         iterator.next();
-        if(i==CharacterIterator.DONE){  
+        if(i==CharacterIterator.DONE){
           return DONE;
         }
         return i;
@@ -68,6 +74,7 @@ public class CharacterIteratorWrapper extends UCharacterIterator {
     /**
      * @see UCharacterIterator#previous()
      */
+    @Override
     public int previous() {
         int i = iterator.previous();
         if(i==CharacterIterator.DONE){
@@ -79,6 +86,7 @@ public class CharacterIteratorWrapper extends UCharacterIterator {
     /**
      * @see UCharacterIterator#setIndex(int)
      */
+    @Override
     public void setIndex(int index) {
         try{
             iterator.setIndex(index);
@@ -90,6 +98,7 @@ public class CharacterIteratorWrapper extends UCharacterIterator {
     /**
      * @see UCharacterIterator#setToLimit()
      */
+    @Override
     public void setToLimit() {
         iterator.setIndex(iterator.getEndIndex());
     }
@@ -97,13 +106,14 @@ public class CharacterIteratorWrapper extends UCharacterIterator {
     /**
      * @see UCharacterIterator#getText(char[])
      */
+    @Override
     public int getText(char[] fillIn, int offset){
-        int length =iterator.getEndIndex() - iterator.getBeginIndex(); 
+        int length =iterator.getEndIndex() - iterator.getBeginIndex();
         int currentIndex = iterator.getIndex();
         if(offset < 0 || offset + length > fillIn.length){
             throw new IndexOutOfBoundsException(Integer.toString(length));
         }
-    
+
         for (char ch = iterator.first(); ch != CharacterIterator.DONE; ch = iterator.next()) {
             fillIn[offset++] = ch;
         }
@@ -116,21 +126,23 @@ public class CharacterIteratorWrapper extends UCharacterIterator {
      * Creates a clone of this iterator.  Clones the underlying character iterator.
      * @see UCharacterIterator#clone()
      */
+    @Override
     public Object clone(){
         try {
             CharacterIteratorWrapper result = (CharacterIteratorWrapper) super.clone();
             result.iterator = (CharacterIterator)this.iterator.clone();
             return result;
-        } catch (CloneNotSupportedException e) {      
+        } catch (CloneNotSupportedException e) {
             return null; // only invoked if bad underlying character iterator
         }
     }
-    
 
+
+    @Override
     public int moveIndex(int delta){
-        int length = iterator.getEndIndex() - iterator.getBeginIndex(); 
+        int length = iterator.getEndIndex() - iterator.getBeginIndex();
         int idx = iterator.getIndex()+delta;
-        
+
         if(idx < 0) {
             idx = 0;
         } else if(idx > length) {
@@ -138,11 +150,12 @@ public class CharacterIteratorWrapper extends UCharacterIterator {
         }
         return iterator.setIndex(idx);
     }
-    
+
     /**
      * @see UCharacterIterator#getCharacterIterator()
      */
+    @Override
     public CharacterIterator getCharacterIterator(){
         return (CharacterIterator)iterator.clone();
-    } 
+    }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/ClassLoaderUtil.java b/icu4j/src/main/java/com/ibm/icu/impl/ClassLoaderUtil.java
similarity index 90%
rename from app/src/main/java/com/ibm/icu/impl/ClassLoaderUtil.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ClassLoaderUtil.java
index b67735c..e7389a1 100644
--- a/app/src/main/java/com/ibm/icu/impl/ClassLoaderUtil.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ClassLoaderUtil.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2015, International Business Machines Corporation and
@@ -27,7 +29,7 @@ public class ClassLoaderUtil {
             // this constructor on Android, because ClassLoaderUtil.getClassLoader()
             // should get non-null ClassLoader before calling
             // ClassLoaderUtil.getBootstrapClassLoader().
-            // 
+            //
             // On other common JREs (such as Oracle, OpenJDK),
             // Object.class.getClassLoader() returns null, but
             // super(null) is commonly used for accessing the bootstrap
@@ -42,7 +44,7 @@ public class ClassLoaderUtil {
      * Lazily create a singleton BootstrapClassLoader.
      * This class loader might be necessary when ICU4J classes are
      * initialized by bootstrap class loader.
-     * 
+     *
      * @return The BootStrapClassLoader singleton instance
      */
     private static ClassLoader getBootstrapClassLoader() {
@@ -52,10 +54,11 @@ public class ClassLoaderUtil {
                     ClassLoader cl = null;
                     if (System.getSecurityManager() != null) {
                         cl = AccessController.doPrivileged(new PrivilegedAction<ClassLoader>() {
-                                public BootstrapClassLoader run() {
-                                    return new BootstrapClassLoader();
-                                }
-                            });
+                            @Override
+                            public BootstrapClassLoader run() {
+                                return new BootstrapClassLoader();
+                            }
+                        });
                     } else {
                         cl = new BootstrapClassLoader();
                     }
diff --git a/app/src/main/java/com/ibm/icu/impl/CurrencyData.java b/icu4j/src/main/java/com/ibm/icu/impl/CurrencyData.java
similarity index 66%
rename from app/src/main/java/com/ibm/icu/impl/CurrencyData.java
rename to icu4j/src/main/java/com/ibm/icu/impl/CurrencyData.java
index 343a45c..09fbdd9 100644
--- a/app/src/main/java/com/ibm/icu/impl/CurrencyData.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/CurrencyData.java
@@ -1,7 +1,9 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2009-2012, International Business Machines Corporation and    *
- * others. All Rights Reserved.                                                *
+ * Copyright (C) 2009-2016, International Business Machines Corporation and
+ * others. All Rights Reserved.
  *******************************************************************************
  */
 package com.ibm.icu.impl;
@@ -10,11 +12,14 @@ import java.util.Collections;
 import java.util.Map;
 
 import com.ibm.icu.text.CurrencyDisplayNames;
+import com.ibm.icu.text.DecimalFormatSymbols;
 import com.ibm.icu.util.ULocale;
 
 public class CurrencyData {
     public static final CurrencyDisplayInfoProvider provider;
 
+    private CurrencyData() {}
+
     public static interface CurrencyDisplayInfoProvider {
         CurrencyDisplayInfo getInstance(ULocale locale, boolean withFallback);
         boolean hasData();
@@ -28,11 +33,11 @@ public class CurrencyData {
 
     public static final class CurrencyFormatInfo {
         public final String currencyPattern;
-        public final char monetarySeparator;
-        public final char monetaryGroupingSeparator;
+        public final String monetarySeparator;
+        public final String monetaryGroupingSeparator;
 
-        public CurrencyFormatInfo(String currencyPattern, char monetarySeparator,
-                char monetaryGroupingSeparator) {
+        public CurrencyFormatInfo(String currencyPattern, String monetarySeparator,
+                String monetaryGroupingSeparator) {
             this.currencyPattern = currencyPattern;
             this.monetarySeparator = monetarySeparator;
             this.monetaryGroupingSeparator = monetaryGroupingSeparator;
@@ -40,24 +45,48 @@ public class CurrencyData {
     }
 
     public static final class CurrencySpacingInfo {
-        public final String beforeCurrencyMatch;
-        public final String beforeContextMatch;
-        public final String beforeInsert;
-        public final String afterCurrencyMatch;
-        public final String afterContextMatch;
-        public final String afterInsert;
+        private final String[][] symbols = new String[SpacingType.COUNT.ordinal()][SpacingPattern.COUNT.ordinal()];
+
+        public static enum SpacingType { BEFORE, AFTER, COUNT };
+        public static enum SpacingPattern {
+            CURRENCY_MATCH(DecimalFormatSymbols.CURRENCY_SPC_CURRENCY_MATCH),
+            SURROUNDING_MATCH(DecimalFormatSymbols.CURRENCY_SPC_SURROUNDING_MATCH),
+            INSERT_BETWEEN(DecimalFormatSymbols.CURRENCY_SPC_INSERT),
+            COUNT;
+
+            SpacingPattern() {}
+            SpacingPattern(int value) { assert value == ordinal(); }
+        };
+
+        public CurrencySpacingInfo() {}
 
-        public CurrencySpacingInfo(
-                String beforeCurrencyMatch, String beforeContextMatch, String beforeInsert,
-                String afterCurrencyMatch, String afterContextMatch, String afterInsert) {
-            this.beforeCurrencyMatch = beforeCurrencyMatch;
-            this.beforeContextMatch = beforeContextMatch;
-            this.beforeInsert = beforeInsert;
-            this.afterCurrencyMatch = afterCurrencyMatch;
-            this.afterContextMatch = afterContextMatch;
-            this.afterInsert = afterInsert;
+        public CurrencySpacingInfo(String... strings) {
+            assert strings.length == 6;
+
+            int k = 0;
+            for (int i=0; i<SpacingType.COUNT.ordinal(); i++) {
+                for (int j=0; j<SpacingPattern.COUNT.ordinal(); j++) {
+                    symbols[i][j] = strings[k];
+                    k++;
+                }
+            }
         }
 
+        public void setSymbolIfNull(SpacingType type, SpacingPattern pattern, String value) {
+            int i = type.ordinal();
+            int j = pattern.ordinal();
+            if (symbols[i][j] == null) {
+                symbols[i][j] = value;
+            }
+        }
+
+        public String[] getBeforeSymbols() {
+            return symbols[SpacingType.BEFORE.ordinal()];
+        }
+
+        public String[] getAfterSymbols() {
+            return symbols[SpacingType.AFTER.ordinal()];
+        }
 
         private static final String DEFAULT_CUR_MATCH = "[:letter:]";
         private static final String DEFAULT_CTX_MATCH = "[:digit:]";
@@ -75,10 +104,12 @@ public class CurrencyData {
             temp = (CurrencyDisplayInfoProvider) clzz.newInstance();
         } catch (Throwable t) {
             temp = new CurrencyDisplayInfoProvider() {
+                @Override
                 public CurrencyDisplayInfo getInstance(ULocale locale, boolean withFallback) {
                     return DefaultInfo.getWithFallback(withFallback);
                 }
 
+                @Override
                 public boolean hasData() {
                     return false;
                 }
diff --git a/app/src/main/java/com/ibm/icu/impl/DateNumberFormat.java b/icu4j/src/main/java/com/ibm/icu/impl/DateNumberFormat.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/impl/DateNumberFormat.java
rename to icu4j/src/main/java/com/ibm/icu/impl/DateNumberFormat.java
index 7f75bfa..af077d5 100644
--- a/app/src/main/java/com/ibm/icu/impl/DateNumberFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/DateNumberFormat.java
@@ -1,6 +1,8 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
-*   Copyright (C) 2007-2014, International Business Machines
+*   Copyright (C) 2007-2016, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 *******************************************************************************
 */
@@ -59,13 +61,13 @@ public final class DateNumberFormat extends NumberFormat {
         if (elems == null) {
             // Missed cache
             String minusString;
-            ICUResourceBundle rb = (ICUResourceBundle)UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, loc);
+            ICUResourceBundle rb = (ICUResourceBundle)UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, loc);
             try {
                 minusString = rb.getStringWithFallback("NumberElements/"+nsName+"/symbols/minusSign");
             } catch (MissingResourceException ex) {
                 if ( !nsName.equals("latn") ) {
                     try {
-                       minusString = rb.getStringWithFallback("NumberElements/latn/symbols/minusSign");                 
+                       minusString = rb.getStringWithFallback("NumberElements/latn/symbols/minusSign");
                     } catch (MissingResourceException ex1) {
                         minusString = "-";
                     }
@@ -88,18 +90,22 @@ public final class DateNumberFormat extends NumberFormat {
         minusSign = elems[10];
     }
 
+    @Override
     public void setMaximumIntegerDigits(int newValue) {
         maxIntDigits = newValue;
     }
 
+    @Override
     public int getMaximumIntegerDigits() {
         return maxIntDigits;
     }
 
+    @Override
     public void setMinimumIntegerDigits(int newValue) {
         minIntDigits = newValue;
     }
 
+    @Override
     public int getMinimumIntegerDigits() {
         return minIntDigits;
     }
@@ -128,11 +134,13 @@ public final class DateNumberFormat extends NumberFormat {
         return digits.clone();
     }
 
+    @Override
     public StringBuffer format(double number, StringBuffer toAppendTo,
             FieldPosition pos) {
         throw new UnsupportedOperationException("StringBuffer format(double, StringBuffer, FieldPostion) is not implemented");
     }
 
+    @Override
     public StringBuffer format(long numberL, StringBuffer toAppendTo,
             FieldPosition pos) {
 
@@ -171,17 +179,20 @@ public final class DateNumberFormat extends NumberFormat {
         }
         return toAppendTo;
     }
-    
+
+    @Override
     public StringBuffer format(BigInteger number, StringBuffer toAppendTo,
             FieldPosition pos) {
         throw new UnsupportedOperationException("StringBuffer format(BigInteger, StringBuffer, FieldPostion) is not implemented");
     }
 
+    @Override
     public StringBuffer format(java.math.BigDecimal number, StringBuffer toAppendTo,
             FieldPosition pos) {
         throw new UnsupportedOperationException("StringBuffer format(BigDecimal, StringBuffer, FieldPostion) is not implemented");
     }
 
+    @Override
     public StringBuffer format(BigDecimal number,
             StringBuffer toAppendTo, FieldPosition pos) {
         throw new UnsupportedOperationException("StringBuffer format(BigDecimal, StringBuffer, FieldPostion) is not implemented");
@@ -192,6 +203,7 @@ public final class DateNumberFormat extends NumberFormat {
      */
     private static final long PARSE_THRESHOLD = 922337203685477579L; // (Long.MAX_VALUE / 10) - 1
 
+    @Override
     public Number parse(String text, ParsePosition parsePosition) {
         long num = 0;
         boolean sawNumber = false;
@@ -234,6 +246,7 @@ public final class DateNumberFormat extends NumberFormat {
         return result;
     }
 
+    @Override
     public boolean equals(Object obj) {
         if (obj == null || !super.equals(obj) || !(obj instanceof DateNumberFormat)) {
             return false;
@@ -245,7 +258,8 @@ public final class DateNumberFormat extends NumberFormat {
                 && this.positiveOnly == other.positiveOnly
                 && Arrays.equals(this.digits, other.digits));
     }
-    
+
+    @Override
     public int hashCode() {
         return super.hashCode();
     }
diff --git a/app/src/main/java/com/ibm/icu/impl/DayPeriodRules.java b/icu4j/src/main/java/com/ibm/icu/impl/DayPeriodRules.java
similarity index 76%
rename from app/src/main/java/com/ibm/icu/impl/DayPeriodRules.java
rename to icu4j/src/main/java/com/ibm/icu/impl/DayPeriodRules.java
index 0209d32..dc60c60 100644
--- a/app/src/main/java/com/ibm/icu/impl/DayPeriodRules.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/DayPeriodRules.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2016, International Business Machines Corporation and
@@ -11,6 +13,7 @@ import java.util.Map;
 
 import com.ibm.icu.util.ICUException;
 import com.ibm.icu.util.ULocale;
+import com.ibm.icu.util.UResourceBundle;
 
 public final class DayPeriodRules {
     public enum DayPeriod {
@@ -67,57 +70,62 @@ public final class DayPeriodRules {
         int maxRuleSetNum = -1;
     }
 
-    private static final class DayPeriodRulesDataSink extends UResource.TableSink {
+    private static final class DayPeriodRulesDataSink extends UResource.Sink {
         private DayPeriodRulesData data;
 
         private DayPeriodRulesDataSink(DayPeriodRulesData data) {
             this.data = data;
         }
 
-        // Entry point.
         @Override
-        public UResource.TableSink getOrCreateTableSink(UResource.Key key, int initialSize) {
-            if (key.contentEquals("locales")) {
-                return localesSink;
-            } else if (key.contentEquals("rules")) {
-                return rulesSink;
-            }
-            return null;
-        }
-
-        // Locales.
-        private class LocalesSink extends UResource.TableSink {
-            @Override
-            public void put(UResource.Key key, UResource.Value value) {
-                int setNum = parseSetNum(value.getString());
-                data.localesToRuleSetNumMap.put(key.toString(), setNum);
+        public void put(UResource.Key key, UResource.Value value, boolean noFallback) {
+            UResource.Table dayPeriodData = value.getTable();
+            for (int i = 0; dayPeriodData.getKeyAndValue(i, key, value); ++i) {
+                if (key.contentEquals("locales")) {
+                    UResource.Table locales = value.getTable();
+                    for (int j = 0; locales.getKeyAndValue(j, key, value); ++j) {
+                        int setNum = parseSetNum(value.getString());
+                        data.localesToRuleSetNumMap.put(key.toString(), setNum);
+                    }
+                } else if (key.contentEquals("rules")) {
+                    UResource.Table rules = value.getTable();
+                    processRules(rules, key, value);
+                }
             }
         }
 
-        private LocalesSink localesSink = new LocalesSink();
-
-        // Rules.
-        private class RulesSink extends UResource.TableSink {
-            @Override
-            public UResource.TableSink getOrCreateTableSink(UResource.Key key, int initialSize) {
+        private void processRules(UResource.Table rules, UResource.Key key, UResource.Value value) {
+            for (int i = 0; rules.getKeyAndValue(i, key, value); ++i) {
                 ruleSetNum = parseSetNum(key.toString());
                 data.rules[ruleSetNum] = new DayPeriodRules();
-                return ruleSetSink;
-            }
-        }
-        private RulesSink rulesSink = new RulesSink();
-
-        // Rules -> "set10", e.g.
-        private class RuleSetSink extends UResource.TableSink {
-            @Override
-            public UResource.TableSink getOrCreateTableSink(UResource.Key key, int initialSize) {
-                period = DayPeriod.fromStringOrNull(key);
-                if (period == null) { throw new ICUException("Unknown day period in data."); }
-                return periodSink;
-            }
 
-            @Override
-            public void leave() {
+                UResource.Table ruleSet = value.getTable();
+                for (int j = 0; ruleSet.getKeyAndValue(j, key, value); ++j) {
+                    period = DayPeriod.fromStringOrNull(key);
+                    if (period == null) { throw new ICUException("Unknown day period in data."); }
+
+                    UResource.Table periodDefinition = value.getTable();
+                    for (int k = 0; periodDefinition.getKeyAndValue(k, key, value); ++k) {
+                        if (value.getType() == UResourceBundle.STRING) {
+                            // Key-value pairs (e.g. before{6:00})
+                            CutoffType type = CutoffType.fromStringOrNull(key);
+                            addCutoff(type, value.getString());
+                        } else {
+                            // Arrays (e.g. before{6:00, 24:00}
+                            cutoffType = CutoffType.fromStringOrNull(key);
+                            UResource.Array cutoffArray = value.getArray();
+                            int length = cutoffArray.getSize();
+                            for (int l = 0; l < length; ++l) {
+                                cutoffArray.getValue(l, value);
+                                addCutoff(cutoffType, value.getString());
+                            }
+                        }
+                    }
+                    setDayPeriodForHoursFromCutoffs();
+                    for (int k = 0; k < cutoffs.length; ++k) {
+                        cutoffs[k] = 0;
+                    }
+                }
                 for (DayPeriod period : data.rules[ruleSetNum].dayPeriodForHour) {
                     if (period == null) {
                         throw new ICUException("Rules in data don't cover all 24 hours (they should).");
@@ -125,43 +133,6 @@ public final class DayPeriodRules {
                 }
             }
         }
-        private RuleSetSink ruleSetSink = new RuleSetSink();
-
-        // Rules -> "set10" -> "morning1", e.g.
-        // If multiple times exist in a cutoff (such as before{6:00, 24:00})
-        // they'll be sent to the next sink.
-        private class PeriodSink extends UResource.TableSink {
-            @Override
-            public void put(UResource.Key key, UResource.Value value) {
-                cutoffType = CutoffType.fromStringOrNull(key);
-                addCutoff(cutoffType, value.getString());
-            }
-
-            @Override
-            public UResource.ArraySink getOrCreateArraySink(UResource.Key key, int initialSize) {
-                cutoffType = CutoffType.fromStringOrNull(key);
-                return cutoffSink;
-            }
-
-            @Override
-            public void leave() {
-                setDayPeriodForHoursFromCutoffs();
-                for (int i = 0; i < cutoffs.length; ++i) {
-                    cutoffs[i] = 0;
-                }
-            }
-        }
-        private PeriodSink periodSink = new PeriodSink();
-
-        // Rules -> "set10" -> "morning1" -> "before", e.g.
-        // Will only enter this sink if more than one time is present for this cutoff.
-        private class CutoffSink extends UResource.ArraySink {
-            @Override
-            public void put(int index, UResource.Value value) {
-                addCutoff(cutoffType, value.getString());
-            }
-        }
-        private CutoffSink cutoffSink = new CutoffSink();
 
         // Members.
         private int cutoffs[] = new int[25];  // [0] thru [24]; 24 is allowed is "before 24".
@@ -233,7 +204,7 @@ public final class DayPeriodRules {
         }
     }  // DayPeriodRulesDataSink
 
-    private static class DayPeriodRulesCountSink extends UResource.TableSink {
+    private static class DayPeriodRulesCountSink extends UResource.Sink {
         private DayPeriodRulesData data;
 
         private DayPeriodRulesCountSink(DayPeriodRulesData data) {
@@ -241,13 +212,14 @@ public final class DayPeriodRules {
         }
 
         @Override
-        public UResource.TableSink getOrCreateTableSink(UResource.Key key, int initialSize) {
-            int setNum = parseSetNum(key.toString());
-            if (setNum > data.maxRuleSetNum) {
-                data.maxRuleSetNum = setNum;
+        public void put(UResource.Key key, UResource.Value value, boolean noFallback) {
+            UResource.Table rules = value.getTable();
+            for (int i = 0; rules.getKeyAndValue(i, key, value); ++i) {
+                int setNum = parseSetNum(key.toString());
+                if (setNum > data.maxRuleSetNum) {
+                    data.maxRuleSetNum = setNum;
+                }
             }
-
-            return null;
         }
     }
 
@@ -315,18 +287,18 @@ public final class DayPeriodRules {
 
     private static DayPeriodRulesData loadData() {
         DayPeriodRulesData data = new DayPeriodRulesData();
-        ICUResourceBundle rb = (ICUResourceBundle)ICUResourceBundle.getBundleInstance(
-                ICUResourceBundle.ICU_BASE_NAME,
+        ICUResourceBundle rb = ICUResourceBundle.getBundleInstance(
+                ICUData.ICU_BASE_NAME,
                 "dayPeriods",
                 ICUResourceBundle.ICU_DATA_CLASS_LOADER,
                 true);
 
         DayPeriodRulesCountSink countSink = new DayPeriodRulesCountSink(data);
-        rb.getAllTableItemsWithFallback("rules", countSink);
+        rb.getAllItemsWithFallback("rules", countSink);
 
         data.rules = new DayPeriodRules[data.maxRuleSetNum + 1];
         DayPeriodRulesDataSink sink = new DayPeriodRulesDataSink(data);
-        rb.getAllTableItemsWithFallback("", sink);
+        rb.getAllItemsWithFallback("", sink);
 
         return data;
     }
diff --git a/app/src/main/java/com/ibm/icu/impl/Differ.java b/icu4j/src/main/java/com/ibm/icu/impl/Differ.java
similarity index 100%
rename from app/src/main/java/com/ibm/icu/impl/Differ.java
rename to icu4j/src/main/java/com/ibm/icu/impl/Differ.java
diff --git a/app/src/main/java/com/ibm/icu/impl/DontCareFieldPosition.java b/icu4j/src/main/java/com/ibm/icu/impl/DontCareFieldPosition.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/impl/DontCareFieldPosition.java
rename to icu4j/src/main/java/com/ibm/icu/impl/DontCareFieldPosition.java
index d69bbb0..3ec92e0 100644
--- a/app/src/main/java/com/ibm/icu/impl/DontCareFieldPosition.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/DontCareFieldPosition.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 **********************************************************************
 * Copyright (c) 2013-2014, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/Grego.java b/icu4j/src/main/java/com/ibm/icu/impl/Grego.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/impl/Grego.java
rename to icu4j/src/main/java/com/ibm/icu/impl/Grego.java
index cd38d9d..774c5d0 100644
--- a/app/src/main/java/com/ibm/icu/impl/Grego.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/Grego.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
  *******************************************************************************
  * Copyright (C) 2003-2014, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/impl/ICUBinary.java b/icu4j/src/main/java/com/ibm/icu/impl/ICUBinary.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/impl/ICUBinary.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ICUBinary.java
index c72241c..98a1d0b 100644
--- a/app/src/main/java/com/ibm/icu/impl/ICUBinary.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ICUBinary.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2015, International Business Machines Corporation and
@@ -37,7 +39,7 @@ public final class ICUBinary {
         private static final int DATA_FORMAT = 0x436d6e44;
 
         private static final class IsAcceptable implements Authenticate {
-            // @Override when we switch to Java 6
+            @Override
             public boolean isDataVersionAcceptable(byte version[]) {
                 return version[0] == 1;
             }
@@ -365,7 +367,7 @@ public final class ICUBinary {
             } else if (i == key.length()) {
                 return -1;  // key < table key because key is shorter.
             }
-            int diff = (int)key.charAt(i) - c2;
+            int diff = key.charAt(i) - c2;
             if (diff != 0) {
                 return diff;
             }
@@ -384,7 +386,7 @@ public final class ICUBinary {
             } else if (i == key.length()) {
                 return -1;  // key < table key because key is shorter.
             }
-            int diff = (int)key.charAt(i) - c2;
+            int diff = key.charAt(i) - c2;
             if (diff != 0) {
                 return diff;
             }
@@ -400,13 +402,13 @@ public final class ICUBinary {
     {
         /**
          * Method used in ICUBinary.readHeader() to provide data format
-         * authentication. 
+         * authentication.
          * @param version version of the current data
          * @return true if dataformat is an acceptable version, false otherwise
          */
         public boolean isDataVersionAcceptable(byte version[]);
     }
-    
+
     // public methods --------------------------------------------------------
 
     /**
@@ -568,7 +570,7 @@ public final class ICUBinary {
      */
     public static int readHeader(ByteBuffer bytes, int dataFormat, Authenticate authenticate)
             throws IOException {
-        assert bytes.position() == 0;
+        assert bytes != null && bytes.position() == 0;
         byte magic1 = bytes.get(2);
         byte magic2 = bytes.get(3);
         if (magic1 != MAGIC1 || magic2 != MAGIC2) {
@@ -608,7 +610,7 @@ public final class ICUBinary {
 
         bytes.position(headerSize);
         return  // dataVersion
-                ((int)bytes.get(20) << 24) |
+                (bytes.get(20) << 24) |
                 ((bytes.get(21) & 0xff) << 16) |
                 ((bytes.get(22) & 0xff) << 8) |
                 (bytes.get(23) & 0xff);
@@ -765,23 +767,23 @@ public final class ICUBinary {
     }
 
     // private variables -------------------------------------------------
-  
+
     /**
     * Magic numbers to authenticate the data file
     */
     private static final byte MAGIC1 = (byte)0xda;
     private static final byte MAGIC2 = (byte)0x27;
-      
+
     /**
     * File format authentication values
     */
     private static final byte CHAR_SET_ = 0;
     private static final byte CHAR_SIZE_ = 2;
-                                                    
+
     /**
     * Error messages
     */
-    private static final String MAGIC_NUMBER_AUTHENTICATION_FAILED_ = 
+    private static final String MAGIC_NUMBER_AUTHENTICATION_FAILED_ =
                        "ICU data file error: Not an ICU data file";
     private static final String HEADER_AUTHENTICATION_FAILED_ =
         "ICU data file error: Header authentication failed, please check if you have a valid ICU data file";
diff --git a/app/src/main/java/com/ibm/icu/impl/ICUCache.java b/icu4j/src/main/java/com/ibm/icu/impl/ICUCache.java
similarity index 85%
rename from app/src/main/java/com/ibm/icu/impl/ICUCache.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ICUCache.java
index 5e8a08c..8161559 100644
--- a/app/src/main/java/com/ibm/icu/impl/ICUCache.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ICUCache.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ***************************************************************************
  * Copyright (c) 2007-2009 International Business Machines Corporation and *
diff --git a/app/src/main/java/com/ibm/icu/impl/ICUConfig.java b/icu4j/src/main/java/com/ibm/icu/impl/ICUConfig.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/impl/ICUConfig.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ICUConfig.java
index f13df78..2989e85 100644
--- a/app/src/main/java/com/ibm/icu/impl/ICUConfig.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ICUConfig.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2008-2015, International Business Machines Corporation and
@@ -61,6 +63,7 @@ public class ICUConfig {
         if (System.getSecurityManager() != null) {
             try {
                 val = AccessController.doPrivileged(new PrivilegedAction<String>() {
+                    @Override
                     public String run() {
                         return System.getProperty(fname);
                     }
diff --git a/app/src/main/java/com/ibm/icu/impl/ICUCurrencyDisplayInfoProvider.java b/icu4j/src/main/java/com/ibm/icu/impl/ICUCurrencyDisplayInfoProvider.java
similarity index 69%
rename from app/src/main/java/com/ibm/icu/impl/ICUCurrencyDisplayInfoProvider.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ICUCurrencyDisplayInfoProvider.java
index fbda76c..ceabeea 100644
--- a/app/src/main/java/com/ibm/icu/impl/ICUCurrencyDisplayInfoProvider.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ICUCurrencyDisplayInfoProvider.java
@@ -1,6 +1,8 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2009-2014, International Business Machines Corporation and
+ * Copyright (C) 2009-2016, International Business Machines Corporation and
  * others. All Rights Reserved.
  *******************************************************************************
  */
@@ -11,6 +13,7 @@ import java.util.Collections;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
+import java.util.MissingResourceException;
 import java.util.Set;
 import java.util.TreeMap;
 
@@ -18,6 +21,7 @@ import com.ibm.icu.impl.CurrencyData.CurrencyDisplayInfo;
 import com.ibm.icu.impl.CurrencyData.CurrencyDisplayInfoProvider;
 import com.ibm.icu.impl.CurrencyData.CurrencyFormatInfo;
 import com.ibm.icu.impl.CurrencyData.CurrencySpacingInfo;
+import com.ibm.icu.impl.ICUResourceBundle.OpenType;
 import com.ibm.icu.util.ULocale;
 import com.ibm.icu.util.UResourceBundle;
 
@@ -25,18 +29,24 @@ public class ICUCurrencyDisplayInfoProvider implements CurrencyDisplayInfoProvid
     public ICUCurrencyDisplayInfoProvider() {
     }
 
+    @Override
     public CurrencyDisplayInfo getInstance(ULocale locale, boolean withFallback) {
-        ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(
-                ICUResourceBundle.ICU_CURR_BASE_NAME, locale);
-        if (!withFallback) {
-            int status = rb.getLoadingStatus();
-            if (status == ICUResourceBundle.FROM_DEFAULT || status == ICUResourceBundle.FROM_ROOT) {
+        ICUResourceBundle rb;
+        if (withFallback) {
+            rb = ICUResourceBundle.getBundleInstance(
+                    ICUData.ICU_CURR_BASE_NAME, locale, OpenType.LOCALE_DEFAULT_ROOT);
+        } else {
+            try {
+                rb = ICUResourceBundle.getBundleInstance(
+                        ICUData.ICU_CURR_BASE_NAME, locale, OpenType.LOCALE_ONLY);
+            } catch (MissingResourceException e) {
                 return null;
             }
         }
         return new ICUCurrencyDisplayInfo(rb, withFallback);
     }
 
+    @Override
     public boolean hasData() {
         return true;
     }
@@ -75,12 +85,8 @@ public class ICUCurrencyDisplayInfoProvider implements CurrencyDisplayInfoProvid
             if (currencies != null) {
                 ICUResourceBundle result = currencies.findWithFallback(isoCode);
                 if (result != null) {
-                    if (!fallback) {
-                        int status = result.getLoadingStatus();
-                        if (status == ICUResourceBundle.FROM_DEFAULT ||
-                                status == ICUResourceBundle.FROM_ROOT) {
-                            return null;
-                        }
+                    if (!fallback && !rb.isRoot() && result.isRoot()) {
+                        return null;
                     }
                     return result.getString(symbolName ? 0 : 1);
                 }
@@ -134,14 +140,14 @@ public class ICUCurrencyDisplayInfoProvider implements CurrencyDisplayInfoProvid
             return map;
         }
 
-       @Override
+        @Override
         public Map<String, String> getUnitPatterns() {
             Map<String, String> result = new HashMap<String, String>();
 
             ULocale locale = rb.getULocale();
             for (;locale != null; locale = locale.getFallback()) {
                 ICUResourceBundle r = (ICUResourceBundle) UResourceBundle.getBundleInstance(
-                        ICUResourceBundle.ICU_CURR_BASE_NAME, locale);
+                        ICUData.ICU_CURR_BASE_NAME, locale);
                 if (r == null) {
                     continue;
                 }
@@ -171,8 +177,8 @@ public class ICUCurrencyDisplayInfoProvider implements CurrencyDisplayInfoProvid
                 crb = crb.at(2);
                 if (crb != null) {
                   String pattern = crb.getString(0);
-                  char separator = crb.getString(1).charAt(0);
-                  char groupingSeparator = crb.getString(2).charAt(0);
+                  String separator = crb.getString(1);
+                  String groupingSeparator = crb.getString(2);
                   return new CurrencyFormatInfo(pattern, separator, groupingSeparator);
                 }
             }
@@ -181,24 +187,72 @@ public class ICUCurrencyDisplayInfoProvider implements CurrencyDisplayInfoProvid
 
         @Override
         public CurrencySpacingInfo getSpacingInfo() {
-            ICUResourceBundle srb = rb.findWithFallback("currencySpacing");
-            if (srb != null) {
-                ICUResourceBundle brb = srb.findWithFallback("beforeCurrency");
-                ICUResourceBundle arb = srb.findWithFallback("afterCurrency");
-                if (arb != null && brb != null) {
-                    String beforeCurrencyMatch = brb.findStringWithFallback("currencyMatch");
-                    String beforeContextMatch = brb.findStringWithFallback("surroundingMatch");
-                    String beforeInsert = brb.findStringWithFallback("insertBetween");
-                    String afterCurrencyMatch = arb.findStringWithFallback("currencyMatch");
-                    String afterContextMatch = arb.findStringWithFallback("surroundingMatch");
-                    String afterInsert = arb.findStringWithFallback("insertBetween");
-
-                    return new CurrencySpacingInfo(
-                            beforeCurrencyMatch, beforeContextMatch, beforeInsert,
-                            afterCurrencyMatch, afterContextMatch, afterInsert);
+            SpacingInfoSink sink = new SpacingInfoSink();
+            rb.getAllItemsWithFallback("currencySpacing", sink);
+            return sink.getSpacingInfo(fallback);
+        }
+
+        private final class SpacingInfoSink extends UResource.Sink {
+            CurrencySpacingInfo spacingInfo = new CurrencySpacingInfo();
+            boolean hasBeforeCurrency = false;
+            boolean hasAfterCurrency = false;
+
+            /*
+             *  currencySpacing{
+             *      afterCurrency{
+             *          currencyMatch{"[:^S:]"}
+             *          insertBetween{" "}
+             *          surroundingMatch{"[:digit:]"}
+             *      }
+             *      beforeCurrency{
+             *          currencyMatch{"[:^S:]"}
+             *          insertBetween{" "}
+             *          surroundingMatch{"[:digit:]"}
+             *      }
+             *  }
+             */
+            @Override
+            public void put(UResource.Key key, UResource.Value value, boolean noFallback) {
+                UResource.Table spacingTypesTable = value.getTable();
+                for (int i = 0; spacingTypesTable.getKeyAndValue(i, key, value); ++i) {
+                    CurrencySpacingInfo.SpacingType type;
+                    if (key.contentEquals("beforeCurrency")) {
+                        type = CurrencySpacingInfo.SpacingType.BEFORE;
+                        hasBeforeCurrency = true;
+                    } else if (key.contentEquals("afterCurrency")) {
+                        type = CurrencySpacingInfo.SpacingType.AFTER;
+                        hasAfterCurrency = true;
+                    } else {
+                        continue;
+                    }
+
+                    UResource.Table patternsTable = value.getTable();
+                    for (int j = 0; patternsTable.getKeyAndValue(j, key, value); ++j) {
+                        CurrencySpacingInfo.SpacingPattern pattern;
+                        if (key.contentEquals("currencyMatch")) {
+                            pattern = CurrencySpacingInfo.SpacingPattern.CURRENCY_MATCH;
+                        } else if (key.contentEquals("surroundingMatch")) {
+                            pattern = CurrencySpacingInfo.SpacingPattern.SURROUNDING_MATCH;
+                        } else if (key.contentEquals("insertBetween")) {
+                            pattern = CurrencySpacingInfo.SpacingPattern.INSERT_BETWEEN;
+                        } else {
+                            continue;
+                        }
+
+                        spacingInfo.setSymbolIfNull(type, pattern, value.getString());
+                    }
+                }
+            }
+
+            CurrencySpacingInfo getSpacingInfo(boolean fallback) {
+                if (hasBeforeCurrency && hasAfterCurrency) {
+                    return spacingInfo;
+                } else if (fallback) {
+                    return CurrencySpacingInfo.DEFAULT;
+                } else {
+                    return null;
                 }
             }
-            return fallback ? CurrencySpacingInfo.DEFAULT : null;
         }
 
         private Map<String, String> _createSymbolMap() {
@@ -206,7 +260,7 @@ public class ICUCurrencyDisplayInfoProvider implements CurrencyDisplayInfoProvid
 
             for (ULocale locale = rb.getULocale(); locale != null; locale = locale.getFallback()) {
                 ICUResourceBundle bundle = (ICUResourceBundle)
-                    UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_CURR_BASE_NAME, locale);
+                    UResourceBundle.getBundleInstance(ICUData.ICU_CURR_BASE_NAME, locale);
                 ICUResourceBundle curr = bundle.findTopLevel("Currencies");
                 if (curr == null) {
                     continue;
@@ -235,7 +289,7 @@ public class ICUCurrencyDisplayInfoProvider implements CurrencyDisplayInfoProvid
             Map<String, Set<String>> visitedPlurals = new HashMap<String, Set<String>>();
             for (ULocale locale = rb.getULocale(); locale != null; locale = locale.getFallback()) {
                 ICUResourceBundle bundle = (ICUResourceBundle)
-                    UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_CURR_BASE_NAME, locale);
+                    UResourceBundle.getBundleInstance(ICUData.ICU_CURR_BASE_NAME, locale);
                 ICUResourceBundle curr = bundle.findTopLevel("Currencies");
                 if (curr != null) {
                     for (int i = 0; i < curr.getSize(); ++i) {
diff --git a/app/src/main/java/com/ibm/icu/impl/ICUCurrencyMetaInfo.java b/icu4j/src/main/java/com/ibm/icu/impl/ICUCurrencyMetaInfo.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/impl/ICUCurrencyMetaInfo.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ICUCurrencyMetaInfo.java
index b2329bd..0bb4620 100644
--- a/app/src/main/java/com/ibm/icu/impl/ICUCurrencyMetaInfo.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ICUCurrencyMetaInfo.java
@@ -1,7 +1,9 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2009-2014, International Business Machines Corporation and    *
- * others. All Rights Reserved.                                                *
+ * Copyright (C) 2009-2016, International Business Machines Corporation and
+ * others. All Rights Reserved.
  *******************************************************************************
  */
 package com.ibm.icu.impl;
@@ -24,7 +26,7 @@ public class ICUCurrencyMetaInfo extends CurrencyMetaInfo {
 
     public ICUCurrencyMetaInfo() {
         ICUResourceBundle bundle = (ICUResourceBundle) ICUResourceBundle.getBundleInstance(
-            ICUResourceBundle.ICU_CURR_BASE_NAME, "supplementalData",
+            ICUData.ICU_CURR_BASE_NAME, "supplementalData",
             ICUResourceBundle.ICU_DATA_CLASS_LOADER);
         regionInfo = bundle.findTopLevel("CurrencyMap");
         digitInfo = bundle.findTopLevel("CurrencyMeta");
@@ -65,7 +67,7 @@ public class ICUCurrencyMetaInfo extends CurrencyMetaInfo {
             return new CurrencyDigits(data[0], data[1]);
         }
     }
-    
+
     private <T> List<T> collect(Collector<T> collector, CurrencyFilter filter) {
         // We rely on the fact that the data lists the regions in order, and the
         // priorities in order within region.  This means we don't need
@@ -167,7 +169,7 @@ public class ICUCurrencyMetaInfo extends CurrencyMetaInfo {
             return defaultValue;
         }
         int[] values = b.getIntVector();
-        return ((long) values[0] << 32) | (((long) values[1]) & MASK);
+        return ((long) values[0] << 32) | ((values[1]) & MASK);
     }
 
     // Utility, just because I don't like the n^2 behavior of using list.contains to build a
@@ -197,14 +199,17 @@ public class ICUCurrencyMetaInfo extends CurrencyMetaInfo {
         // about duplicates.
         private List<CurrencyInfo> result = new ArrayList<CurrencyInfo>();
 
+        @Override
         public void collect(String region, String currency, long from, long to, int priority, boolean tender) {
             result.add(new CurrencyInfo(region, currency, from, to, priority, tender));
         }
 
+        @Override
         public List<CurrencyInfo> getList() {
             return Collections.unmodifiableList(result);
         }
 
+        @Override
         public int collects() {
             return Everything;
         }
@@ -213,15 +218,18 @@ public class ICUCurrencyMetaInfo extends CurrencyMetaInfo {
     private static class RegionCollector implements Collector<String> {
         private final UniqueList<String> result = UniqueList.create();
 
+        @Override
         public void collect(
                 String region, String currency, long from, long to, int priority, boolean tender) {
             result.add(region);
         }
 
+        @Override
         public int collects() {
             return Region;
         }
 
+        @Override
         public List<String> getList() {
             return result.list();
         }
@@ -230,15 +238,18 @@ public class ICUCurrencyMetaInfo extends CurrencyMetaInfo {
     private static class CurrencyCollector implements Collector<String> {
         private final UniqueList<String> result = UniqueList.create();
 
+        @Override
         public void collect(
                 String region, String currency, long from, long to, int priority, boolean tender) {
             result.add(currency);
         }
 
+        @Override
         public int collects() {
             return Currency;
         }
 
+        @Override
         public List<String> getList() {
             return result.list();
         }
diff --git a/app/src/main/java/com/ibm/icu/impl/ICUData.java b/icu4j/src/main/java/com/ibm/icu/impl/ICUData.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/ICUData.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ICUData.java
index ab43d1b..cf20dbf 100644
--- a/app/src/main/java/com/ibm/icu/impl/ICUData.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ICUData.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2004-2014, International Business Machines Corporation and
@@ -91,6 +93,7 @@ public final class ICUData {
         URL i = null;
         if (System.getSecurityManager() != null) {
             i = AccessController.doPrivileged(new PrivilegedAction<URL>() {
+                    @Override
                     public URL run() {
                         return ICUData.class.getResource(resourceName);
                     }
@@ -105,6 +108,7 @@ public final class ICUData {
         InputStream i = null;
         if (System.getSecurityManager() != null) {
             i = AccessController.doPrivileged(new PrivilegedAction<InputStream>() {
+                    @Override
                     public InputStream run() {
                         return root.getResourceAsStream(resourceName);
                     }
@@ -127,6 +131,7 @@ public final class ICUData {
         InputStream i = null;
         if (System.getSecurityManager() != null) {
             i = AccessController.doPrivileged(new PrivilegedAction<InputStream>() {
+                    @Override
                     public InputStream run() {
                         return loader.getResourceAsStream(resourceName);
                     }
diff --git a/app/src/main/java/com/ibm/icu/impl/ICUDataVersion.java b/icu4j/src/main/java/com/ibm/icu/impl/ICUDataVersion.java
similarity index 72%
rename from app/src/main/java/com/ibm/icu/impl/ICUDataVersion.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ICUDataVersion.java
index 7a1e32a..473f30d 100644
--- a/app/src/main/java/com/ibm/icu/impl/ICUDataVersion.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ICUDataVersion.java
@@ -1,6 +1,8 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
-*   Copyright (C) 2009-2012, International Business Machines
+*   Copyright (C) 2009-2016, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 *******************************************************************************
 */
@@ -25,7 +27,10 @@ public final class ICUDataVersion {
     public static VersionInfo getDataVersion() {
         UResourceBundle icudatares = null;
         try {
-            icudatares = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, ICUDataVersion.U_ICU_VERSION_BUNDLE, ICUResourceBundle.ICU_DATA_CLASS_LOADER);
+            icudatares = UResourceBundle.getBundleInstance(
+                    ICUData.ICU_BASE_NAME,
+                    ICUDataVersion.U_ICU_VERSION_BUNDLE,
+                    ICUResourceBundle.ICU_DATA_CLASS_LOADER);
             icudatares = icudatares.get(ICUDataVersion.U_ICU_DATA_KEY);
         } catch (MissingResourceException ex) {
             return null;
diff --git a/app/src/main/java/com/ibm/icu/impl/ICUDebug.java b/icu4j/src/main/java/com/ibm/icu/impl/ICUDebug.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/ICUDebug.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ICUDebug.java
index 0076ee7..641b6b5 100644
--- a/app/src/main/java/com/ibm/icu/impl/ICUDebug.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ICUDebug.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
  *******************************************************************************
  * Copyright (C) 2001-2010, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/impl/ICULangDataTables.java b/icu4j/src/main/java/com/ibm/icu/impl/ICULangDataTables.java
similarity index 53%
rename from app/src/main/java/com/ibm/icu/impl/ICULangDataTables.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ICULangDataTables.java
index 4cb94b3..6cacd57 100644
--- a/app/src/main/java/com/ibm/icu/impl/ICULangDataTables.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ICULangDataTables.java
@@ -1,13 +1,15 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2009, International Business Machines Corporation and         *
- * others. All Rights Reserved.                                                *
+ * Copyright (C) 2009-2016, International Business Machines Corporation and
+ * others. All Rights Reserved.
  *******************************************************************************
  */
 package com.ibm.icu.impl;
 
 public class ICULangDataTables extends LocaleDisplayNamesImpl.ICUDataTables {
     public ICULangDataTables() {
-        super(ICUResourceBundle.ICU_LANG_BASE_NAME);
+        super(ICUData.ICU_LANG_BASE_NAME);
     }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/ICULocaleService.java b/icu4j/src/main/java/com/ibm/icu/impl/ICULocaleService.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/impl/ICULocaleService.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ICULocaleService.java
index d122389..9f9ba53 100644
--- a/app/src/main/java/com/ibm/icu/impl/ICULocaleService.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ICULocaleService.java
@@ -1,7 +1,9 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
  *******************************************************************************
- * Copyright (C) 2001-2015, International Business Machines Corporation and    *
- * others. All Rights Reserved.                                                *
+ * Copyright (C) 2001-2016, International Business Machines Corporation and
+ * others. All Rights Reserved.
  *******************************************************************************
  */
 package com.ibm.icu.impl;
@@ -59,7 +61,7 @@ public class ICULocaleService extends ICUService {
      * Convenience override for callers using locales.  This uses
      * createKey(ULocale.toString(), kind) to create a key, calls getKey, and then
      * if actualReturn is not null, returns the actualResult from
-     * getKey (stripping any prefix) into a ULocale.  
+     * getKey (stripping any prefix) into a ULocale.
      */
     public Object get(ULocale locale, int kind, ULocale[] actualReturn) {
         Key key = createKey(locale, kind);
@@ -144,7 +146,7 @@ public class ICULocaleService extends ICUService {
         }
         return locales;
     }
-        
+
     /**
      * A subclass of Key that implements a locale fallback mechanism.
      * The first locale to search for is the locale provided by the
@@ -155,7 +157,7 @@ public class ICULocaleService extends ICUService {
      *
      * <p>Canonicalization adjusts the locale string so that the
      * section before the first understore is in lower case, and the rest
-     * is in upper case, with no trailing underscores.</p> 
+     * is in upper case, with no trailing underscores.</p>
      */
     public static class LocaleKey extends ICUService.Key {
         private int kind;
@@ -172,7 +174,7 @@ public class ICULocaleService extends ICUService {
         public static LocaleKey createWithCanonicalFallback(String primaryID, String canonicalFallbackID) {
             return createWithCanonicalFallback(primaryID, canonicalFallbackID, KIND_ANY);
         }
-            
+
         /**
          * Create a LocaleKey with canonical primary and fallback IDs.
          */
@@ -183,7 +185,7 @@ public class ICULocaleService extends ICUService {
             String canonicalPrimaryID = ULocale.getName(primaryID);
             return new LocaleKey(primaryID, canonicalPrimaryID, canonicalFallbackID, kind);
         }
-            
+
         /**
          * Create a LocaleKey with canonical primary and fallback IDs.
          */
@@ -194,7 +196,7 @@ public class ICULocaleService extends ICUService {
             String canonicalPrimaryID = locale.getName();
             return new LocaleKey(canonicalPrimaryID, canonicalPrimaryID, canonicalFallbackID, kind);
         }
-            
+
         /**
          * PrimaryID is the user's requested locale string,
          * canonicalPrimaryID is this string in canonical form,
@@ -246,6 +248,7 @@ public class ICULocaleService extends ICUService {
         /**
          * Return the (canonical) original ID.
          */
+        @Override
         public String canonicalID() {
             return primaryID;
         }
@@ -253,6 +256,7 @@ public class ICULocaleService extends ICUService {
         /**
          * Return the (canonical) current ID, or null if no current id.
          */
+        @Override
         public String currentID() {
             return currentID;
         }
@@ -261,6 +265,7 @@ public class ICULocaleService extends ICUService {
          * Return the (canonical) current descriptor, or null if no current id.
          * Includes the keywords, whereas the ID does not include keywords.
          */
+        @Override
         public String currentDescriptor() {
             String result = currentID();
             if (result != null) {
@@ -303,8 +308,9 @@ public class ICULocaleService extends ICUService {
          * <p>First falls back through the primary ID, then through
          * the fallbackID.  The final fallback is "" (root)
          * unless the primary id was "" (root), in which case
-         * there is no fallback.  
+         * there is no fallback.
          */
+        @Override
         public boolean fallback() {
             int x = currentID.lastIndexOf('_');
             if (x != -1) {
@@ -327,9 +333,10 @@ public class ICULocaleService extends ICUService {
         }
 
         /**
-         * If a key created from id would eventually fallback to match the 
+         * If a key created from id would eventually fallback to match the
          * canonical ID of this key, return true.
          */
+        @Override
         public boolean isFallbackOf(String id) {
             return LocaleUtility.isFallbackOf(canonicalID(), id);
         }
@@ -367,11 +374,12 @@ public class ICULocaleService extends ICUService {
          * the key against the supported IDs, and passes the canonicalLocale and
          * kind off to handleCreate (which subclasses must implement).
          */
+        @Override
         public Object create(Key key, ICUService service) {
             if (handlesKey(key)) {
                 LocaleKey lkey = (LocaleKey)key;
                 int kind = lkey.kind();
-                
+
                 ULocale uloc = lkey.currentLocale();
                 return handleCreate(uloc, kind, service);
             } else {
@@ -393,6 +401,7 @@ public class ICULocaleService extends ICUService {
         /**
          * Override of superclass method.
          */
+        @Override
         public void updateVisibleIDs(Map<String, Factory> result) {
             Set<String> cache = getSupportedIDs();
             for (String id : cache) {
@@ -407,6 +416,7 @@ public class ICULocaleService extends ICUService {
         /**
          * Return a localized name for the locale represented by id.
          */
+        @Override
         public String getDisplayName(String id, ULocale locale) {
             // assume if the user called this on us, we must have handled some fallback of this id
             //          if (isSupportedID(id)) {
@@ -430,15 +440,15 @@ public class ICULocaleService extends ICUService {
         ///CLOVER:ON
 
         /**
-         * Return true if this id is one the factory supports (visible or 
+         * Return true if this id is one the factory supports (visible or
          * otherwise).
          */
         protected boolean isSupportedID(String id) {
             return getSupportedIDs().contains(id);
         }
-        
+
         /**
-         * Return the set of ids that this factory supports (visible or 
+         * Return the set of ids that this factory supports (visible or
          * otherwise).  This can be called often and might need to be
          * cached if it is expensive to create.
          */
@@ -449,6 +459,7 @@ public class ICULocaleService extends ICUService {
         /**
          * For debugging.
          */
+        @Override
         public String toString() {
             StringBuilder buf = new StringBuilder(super.toString());
             if (name != null) {
@@ -476,7 +487,7 @@ public class ICULocaleService extends ICUService {
 
         public SimpleLocaleKeyFactory(Object obj, ULocale locale, int kind, boolean visible, String name) {
             super(visible, name);
-            
+
             this.obj = obj;
             this.id = locale.getBaseName();
             this.kind = kind;
@@ -485,11 +496,12 @@ public class ICULocaleService extends ICUService {
         /**
          * Returns the service object if kind/locale match.  Service is not used.
          */
+        @Override
         public Object create(Key key, ICUService service) {
             if (!(key instanceof LocaleKey)) {
                 return null;
             }
-            
+
             LocaleKey lkey = (LocaleKey)key;
             if (kind != LocaleKey.KIND_ANY && kind != lkey.kind()) {
                 return null;
@@ -497,14 +509,16 @@ public class ICULocaleService extends ICUService {
             if (!id.equals(lkey.currentID())) {
                 return null;
             }
-            
+
             return obj;
         }
 
+        @Override
         protected boolean isSupportedID(String idToCheck) {
             return this.id.equals(idToCheck);
         }
 
+        @Override
         public void updateVisibleIDs(Map<String, Factory> result) {
             if (visible) {
                 result.put(id, this);
@@ -513,6 +527,7 @@ public class ICULocaleService extends ICUService {
             }
         }
 
+        @Override
         public String toString() {
             StringBuilder buf = new StringBuilder(super.toString());
             buf.append(", id: ");
@@ -537,7 +552,7 @@ public class ICULocaleService extends ICUService {
          * Convenience constructor that uses the main ICU bundle name.
          */
         public ICUResourceBundleFactory() {
-            this(ICUResourceBundle.ICU_BASE_NAME);
+            this(ICUData.ICU_BASE_NAME);
         }
 
         /**
@@ -553,13 +568,15 @@ public class ICULocaleService extends ICUService {
         /**
          * Return the supported IDs.  This is the set of all locale names for the bundleName.
          */
+        @Override
         protected Set<String> getSupportedIDs() {
-            return ICUResourceBundle.getFullLocaleNameSet(bundleName, loader()); 
+            return ICUResourceBundle.getFullLocaleNameSet(bundleName, loader());
         }
 
         /**
          * Override of superclass method.
          */
+        @Override
         public void updateVisibleIDs(Map<String, Factory> result) {
           Set<String> visibleIDs = ICUResourceBundle.getAvailableLocaleNameSet(bundleName, loader()); // only visible ids
             for (String id : visibleIDs) {
@@ -571,6 +588,7 @@ public class ICULocaleService extends ICUService {
          * Create the service.  The default implementation returns the resource bundle
          * for the locale, ignoring kind, and service.
          */
+        @Override
         protected Object handleCreate(ULocale loc, int kind, ICUService service) {
             return ICUResourceBundle.getBundleInstance(bundleName, loc, loader());
         }
@@ -579,6 +597,7 @@ public class ICULocaleService extends ICUService {
             return ClassLoaderUtil.getClassLoader(getClass());
         }
 
+        @Override
         public String toString() {
             return super.toString() + ", bundle: " + bundleName;
         }
@@ -602,6 +621,7 @@ public class ICULocaleService extends ICUService {
         return fallbackLocaleName;
     }
 
+    @Override
     public Key createKey(String id) {
         return LocaleKey.createWithCanonicalFallback(id, validateFallbackLocale());
     }
diff --git a/app/src/main/java/com/ibm/icu/impl/ICUNotifier.java b/icu4j/src/main/java/com/ibm/icu/impl/ICUNotifier.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/impl/ICUNotifier.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ICUNotifier.java
index 90c9206..9e83372 100644
--- a/app/src/main/java/com/ibm/icu/impl/ICUNotifier.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ICUNotifier.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
  *******************************************************************************
  * Copyright (C) 2001-2009, International Business Machines Corporation and    *
@@ -19,12 +21,12 @@ import java.util.List;
  * eventually dequeues the list and calls notifyListener on each
  * listener in the list.</p>
  *
- * <p>Subclasses override acceptsListener and notifyListener 
+ * <p>Subclasses override acceptsListener and notifyListener
  * to add type-safe notification.  AcceptsListener should return
  * true if the listener is of the appropriate type; ICUNotifier
  * itself will ensure the listener is non-null and that the
  * identical listener is not already registered with the Notifier.
- * NotifyListener should cast the listener to the appropriate 
+ * NotifyListener should cast the listener to the appropriate
  * type and call the appropriate method on the listener.
  */
 public abstract class ICUNotifier {
@@ -37,7 +39,7 @@ public abstract class ICUNotifier {
      * The listener must not be null. AcceptsListener must return
      * true for the listener.  Attempts to concurrently
      * register the identical listener more than once will be
-     * silently ignored.  
+     * silently ignored.
      */
     public void addListener(EventListener l) {
         if (l == null) {
@@ -135,6 +137,7 @@ public abstract class ICUNotifier {
          * Wait for a notification to be queued, then notify all
          * listeners listed in the notification.
          */
+        @Override
         public void run() {
             EventListener[] list;
             while (true) {
diff --git a/app/src/main/java/com/ibm/icu/impl/ICURWLock.java b/icu4j/src/main/java/com/ibm/icu/impl/ICURWLock.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/impl/ICURWLock.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ICURWLock.java
index 9f2e79d..6cc93a5 100644
--- a/app/src/main/java/com/ibm/icu/impl/ICURWLock.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ICURWLock.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
  *******************************************************************************
  * Copyright (C) 2001-2013, International Business Machines Corporation and    *
@@ -86,9 +88,10 @@ public class ICURWLock {
         /**
          * Return a string listing all the stats.
          */
+        @Override
         public String toString() {
             return " rc: " + _rc +
-                " mrc: " + _mrc + 
+                " mrc: " + _mrc +
                 " wrc: " + _wrc +
                 " wc: " + _wc +
                 " wwc: " + _wwc;
@@ -112,7 +115,7 @@ public class ICURWLock {
         stats = null;
         return result;
     }
-    
+
     /**
      * Return a snapshot of the current stats.  This does not reset the stats.
      */
@@ -128,7 +131,7 @@ public class ICURWLock {
      * <p>If there's a writer, or a waiting writer, increment the
      * waiting reader count and block on this.  Otherwise
      * increment the active reader count and return.  Caller must call
-     * releaseRead when done (for example, in a finally block).</p> 
+     * releaseRead when done (for example, in a finally block).</p>
      */
     public void acquireRead() {
         if (stats != null) {    // stats is null by default
@@ -166,7 +169,7 @@ public class ICURWLock {
      * having an active writer and return.  Otherwise, add a lock to the
      * end of the waiting writer list, and block on it.  Caller
      * must call releaseWrite when done (for example, in a finally
-     * block).<p> 
+     * block).<p>
      */
     public void acquireWrite() {
         if (stats != null) {    // stats is null by default
@@ -187,7 +190,7 @@ public class ICURWLock {
      * <p>If there are waiting readers, make them all active and
      * notify all of them.  Otherwise, notify the oldest waiting
      * writer, if any.  Call when finished with work controlled by
-     * acquireWrite.</p> 
+     * acquireWrite.</p>
      */
     public void releaseWrite() {
         rwl.writeLock().unlock();
diff --git a/app/src/main/java/com/ibm/icu/impl/ICURegionDataTables.java b/icu4j/src/main/java/com/ibm/icu/impl/ICURegionDataTables.java
similarity index 53%
rename from app/src/main/java/com/ibm/icu/impl/ICURegionDataTables.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ICURegionDataTables.java
index b146f83..94964f2 100644
--- a/app/src/main/java/com/ibm/icu/impl/ICURegionDataTables.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ICURegionDataTables.java
@@ -1,13 +1,15 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2009, International Business Machines Corporation and         *
- * others. All Rights Reserved.                                                *
+ * Copyright (C) 2009-2016, International Business Machines Corporation and
+ * others. All Rights Reserved.
  *******************************************************************************
  */
 package com.ibm.icu.impl;
 
 public class ICURegionDataTables extends LocaleDisplayNamesImpl.ICUDataTables {
     public ICURegionDataTables() {
-        super(ICUResourceBundle.ICU_REGION_BASE_NAME);
+        super(ICUData.ICU_REGION_BASE_NAME);
     }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/ICUResourceBundle.java b/icu4j/src/main/java/com/ibm/icu/impl/ICUResourceBundle.java
similarity index 82%
rename from app/src/main/java/com/ibm/icu/impl/ICUResourceBundle.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ICUResourceBundle.java
index d36a802..9c6558b 100644
--- a/app/src/main/java/com/ibm/icu/impl/ICUResourceBundle.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ICUResourceBundle.java
@@ -1,6 +1,8 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  * *****************************************************************************
- * Copyright (C) 2005-2015, International Business Machines Corporation and
+ * Copyright (C) 2005-2016, International Business Machines Corporation and
  * others. All Rights Reserved.
  * *****************************************************************************
  */
@@ -31,79 +33,10 @@ import com.ibm.icu.util.UResourceBundleIterator;
 import com.ibm.icu.util.UResourceTypeMismatchException;
 
 public  class ICUResourceBundle extends UResourceBundle {
-    /**
-     * The data path to be used with getBundleInstance API
-     * @deprecated because not specific to resource bundles; use the ICUData constants instead
-     */
-    @Deprecated
-    protected static final String ICU_DATA_PATH = ICUData.ICU_DATA_PATH;
-    /**
-     * The data path to be used with getBundleInstance API
-     * @deprecated because not specific to resource bundles; use the ICUData constants instead
-     */
-    @Deprecated
-    public static final String ICU_BUNDLE = ICUData.ICU_BUNDLE;
-
-    /**
-     * The base name of ICU data to be used with getBundleInstance API
-     * @deprecated because not specific to resource bundles; use the ICUData constants instead
-     */
-    @Deprecated
-    public static final String ICU_BASE_NAME = ICUData.ICU_BASE_NAME;
-
-    /**
-     * The base name of collation data to be used with getBundleInstance API
-     * @deprecated because not specific to resource bundles; use the ICUData constants instead
-     */
-    @Deprecated
-    public static final String ICU_COLLATION_BASE_NAME = ICUData.ICU_COLLATION_BASE_NAME;
-
-    /**
-     * The base name of rbbi data to be used with getBundleInstance API
-     * @deprecated because not specific to resource bundles; use the ICUData constants instead
-     */
-    @Deprecated
-    public static final String ICU_BRKITR_BASE_NAME = ICUData.ICU_BRKITR_BASE_NAME;
-
-    /**
-     * The base name of rbnf data to be used with getBundleInstance API
-     * @deprecated because not specific to resource bundles; use the ICUData constants instead
-     */
-    @Deprecated
-    public static final String ICU_RBNF_BASE_NAME = ICUData.ICU_RBNF_BASE_NAME;
-
-    /**
-     * The base name of transliterator data to be used with getBundleInstance API
-     * @deprecated because not specific to resource bundles; use the ICUData constants instead
-     */
-    @Deprecated
-    public static final String ICU_TRANSLIT_BASE_NAME = ICUData.ICU_TRANSLIT_BASE_NAME;
-
-    /**
-     * @deprecated because not specific to resource bundles; use the ICUData constants instead
-     */
-    @Deprecated
-    public static final String ICU_LANG_BASE_NAME = ICUData.ICU_LANG_BASE_NAME;
-    /**
-     * @deprecated because not specific to resource bundles; use the ICUData constants instead
-     */
-    @Deprecated
-    public static final String ICU_CURR_BASE_NAME = ICUData.ICU_CURR_BASE_NAME;
-    /**
-     * @deprecated because not specific to resource bundles; use the ICUData constants instead
-     */
-    @Deprecated
-    public static final String ICU_REGION_BASE_NAME = ICUData.ICU_REGION_BASE_NAME;
-    /**
-     * @deprecated because not specific to resource bundles; use the ICUData constants instead
-     */
-    @Deprecated
-    public static final String ICU_ZONE_BASE_NAME = ICUData.ICU_ZONE_BASE_NAME;
-
     /**
      * CLDR string value "∅∅∅" prevents fallback to the parent bundle.
      */
-    private static final String NO_INHERITANCE_MARKER = "\u2205\u2205\u2205";
+    public static final String NO_INHERITANCE_MARKER = "\u2205\u2205\u2205";
 
     /**
      * The class loader constant to be used with getBundleInstance API
@@ -115,35 +48,6 @@ public  class ICUResourceBundle extends UResourceBundle {
      */
     protected static final String INSTALLED_LOCALES = "InstalledLocales";
 
-    public static final int FROM_FALLBACK = 1, FROM_ROOT = 2, FROM_DEFAULT = 3, FROM_LOCALE = 4;
-
-    private int loadingStatus = -1;
-
-    public void setLoadingStatus(int newStatus) {
-        loadingStatus = newStatus;
-    }
-    /**
-     * Returns the loading status of a particular resource.
-     *
-     * @return FROM_FALLBACK if the resource is fetched from fallback bundle
-     *         FROM_ROOT if the resource is fetched from root bundle.
-     *         FROM_DEFAULT if the resource is fetched from the default locale.
-     */
-    public int getLoadingStatus() {
-        return loadingStatus;
-    }
-
-    public void setLoadingStatus(String requestedLocale){
-        String locale = getLocaleID();
-        if(locale.equals("root")) {
-            setLoadingStatus(FROM_ROOT);
-        } else if(locale.equals(requestedLocale)) {
-            setLoadingStatus(FROM_LOCALE);
-        } else {
-            setLoadingStatus(FROM_FALLBACK);
-        }
-     }
-
     /**
      * Fields for a whole bundle, rather than any specific resource in the bundle.
      * Corresponds roughly to ICU4C/source/common/uresimp.h struct UResourceDataEntry.
@@ -176,6 +80,19 @@ public  class ICUResourceBundle extends UResourceBundle {
     WholeBundle wholeBundle;
     private ICUResourceBundle container;
 
+    /** Loader for bundle instances, for caching. */
+    private static abstract class Loader {
+        abstract ICUResourceBundle load();
+    }
+
+    private static CacheBase<String, ICUResourceBundle, Loader> BUNDLE_CACHE =
+            new SoftCache<String, ICUResourceBundle, Loader>() {
+        @Override
+        protected ICUResourceBundle createInstance(String unusedKey, Loader loader) {
+            return loader.load();
+        }
+    };
+
     /**
      * Returns a functionally equivalent locale, considering keywords as well, for the specified keyword.
      * @param baseName resource specifier
@@ -237,7 +154,7 @@ public  class ICUResourceBundle extends UResourceBundle {
                 // Ignore error and continue search.
             }
             if (defLoc == null) {
-                r = (ICUResourceBundle) r.getParent();
+                r = r.getParent();
                 defDepth++;
             }
         } while ((r != null) && (defLoc == null));
@@ -263,7 +180,7 @@ public  class ICUResourceBundle extends UResourceBundle {
                 // Ignore error,
             }
             if (fullBase == null) {
-                r = (ICUResourceBundle) r.getParent();
+                r = r.getParent();
                 resDepth++;
             }
         } while ((r != null) && (fullBase == null));
@@ -280,14 +197,14 @@ public  class ICUResourceBundle extends UResourceBundle {
             do {
                 try {
                     ICUResourceBundle irb = (ICUResourceBundle)r.get(resName);
-                    UResourceBundle urb = irb.get(kwVal);
+                    ICUResourceBundle urb = (ICUResourceBundle)irb.get(kwVal);
 
                     // if we didn't fail before this..
                     fullBase = r.getULocale();
 
                     // If the fetched item (urb) is in a different locale than our outer locale (r/fullBase)
                     // then we are in a 'fallback' situation. treat as a missing resource situation.
-                    if(!fullBase.toString().equals(urb.getLocale().toString())) {
+                    if(!fullBase.getBaseName().equals(urb.getULocale().getBaseName())) {
                         fullBase = null; // fallback condition. Loop and try again.
                     }
 
@@ -302,7 +219,7 @@ public  class ICUResourceBundle extends UResourceBundle {
                     // Ignore error, continue search.
                 }
                 if (fullBase == null) {
-                    r = (ICUResourceBundle) r.getParent();
+                    r = r.getParent();
                     resDepth++;
                 }
             } while ((r != null) && (fullBase == null));
@@ -319,7 +236,7 @@ public  class ICUResourceBundle extends UResourceBundle {
             && resDepth <= defDepth) { // default was set in same locale or child
             return fullBase; // Keyword value is default - no keyword needed in locale
         } else {
-            return new ULocale(fullBase.toString() + "@" + keyword + "=" + kwVal);
+            return new ULocale(fullBase.getBaseName() + "@" + keyword + "=" + kwVal);
         }
     }
 
@@ -392,11 +309,11 @@ public  class ICUResourceBundle extends UResourceBundle {
 
         return result;
     }
-    
+
     public ICUResourceBundle at(int index) {
         return (ICUResourceBundle) handleGet(index, null, this);
     }
-    
+
     public ICUResourceBundle at(String key) {
         // don't ever presume the key is an int in disguise, like ResourceArray does.
         if (this instanceof ICUResourceBundleImpl.ResourceTable) {
@@ -404,17 +321,17 @@ public  class ICUResourceBundle extends UResourceBundle {
         }
         return null;
     }
-    
+
     @Override
     public ICUResourceBundle findTopLevel(int index) {
         return (ICUResourceBundle) super.findTopLevel(index);
     }
-    
+
     @Override
     public ICUResourceBundle findTopLevel(String aKey) {
         return (ICUResourceBundle) super.findTopLevel(aKey);
     }
-    
+
     /**
      * Like getWithFallback, but returns null if the resource is not found instead of
      * throwing an exception.
@@ -447,18 +364,7 @@ public  class ICUResourceBundle extends UResourceBundle {
         return result;
     }
 
-    public void getAllArrayItemsWithFallback(String path, UResource.ArraySink sink)
-            throws MissingResourceException {
-        getAllContainerItemsWithFallback(path, sink, null);
-    }
-
-    public void getAllTableItemsWithFallback(String path, UResource.TableSink sink)
-            throws MissingResourceException {
-        getAllContainerItemsWithFallback(path, null, sink);
-    }
-
-    private void getAllContainerItemsWithFallback(
-            String path, UResource.ArraySink arraySink, UResource.TableSink tableSink)
+    public void getAllItemsWithFallback(String path, UResource.Sink sink)
             throws MissingResourceException {
         // Collect existing and parsed key objects into an array of keys,
         // rather than assembling and parsing paths.
@@ -479,37 +385,28 @@ public  class ICUResourceBundle extends UResourceBundle {
                     path, getKey());
             }
         }
-        int expectedType = arraySink != null ? ARRAY : TABLE;
-        if (rb.getType() != expectedType) {
-            throw new UResourceTypeMismatchException("");
-        }
-        // Get all table items with fallback.
         UResource.Key key = new UResource.Key();
         ReaderValue readerValue = new ReaderValue();
-        rb.getAllContainerItemsWithFallback(key, readerValue, arraySink, tableSink);
+        rb.getAllItemsWithFallback(key, readerValue, sink);
     }
 
-    private void getAllContainerItemsWithFallback(
-            UResource.Key key, ReaderValue readerValue,
-            UResource.ArraySink arraySink, UResource.TableSink tableSink) {
+    private void getAllItemsWithFallback(
+            UResource.Key key, ReaderValue readerValue, UResource.Sink sink) {
         // We recursively enumerate child-first,
         // only storing parent items in the absence of child items.
-        // We store a placeholder value for the no-fallback/no-inheritance marker
+        // The sink needs to store a placeholder value for the no-fallback/no-inheritance marker
         // to prevent a parent item from being stored.
         //
         // It would be possible to recursively enumerate parent-first,
         // overriding parent items with child items.
-        // When we see the no-fallback/no-inheritance marker,
-        // then we would remove the parent's item.
+        // When the sink sees the no-fallback/no-inheritance marker,
+        // then it would remove the parent's item.
         // We would deserialize parent values even though they are overridden in a child bundle.
-        int expectedType = arraySink != null ? ARRAY : TABLE;
-        if (getType() == expectedType) {
-            if (arraySink != null) {
-                ((ICUResourceBundleImpl.ResourceArray)this).getAllItems(key, readerValue, arraySink);
-            } else /* tableSink != null */ {
-                ((ICUResourceBundleImpl.ResourceTable)this).getAllItems(key, readerValue, tableSink);
-            }
-        }
+        ICUResourceBundleImpl impl = (ICUResourceBundleImpl)this;
+        readerValue.reader = impl.wholeBundle.reader;
+        readerValue.res = impl.getResource();
+        key.setString(this.key != null ? this.key : "");
+        sink.put(key, readerValue, parent == null);
         if (parent != null) {
             // We might try to query the sink whether
             // any fallback from the parent bundle is still possible.
@@ -525,8 +422,8 @@ public  class ICUResourceBundle extends UResourceBundle {
                 getResPathKeys(pathKeys, depth);
                 rb = findResourceWithFallback(pathKeys, 0, parentBundle, null);
             }
-            if (rb != null && rb.getType() == expectedType) {
-                rb.getAllContainerItemsWithFallback(key, readerValue, arraySink, tableSink);
+            if (rb != null) {
+                rb.getAllItemsWithFallback(key, readerValue, sink);
             }
         }
     }
@@ -546,7 +443,7 @@ public  class ICUResourceBundle extends UResourceBundle {
      * resource bundles.
      */
     public static Set<String> getFullLocaleNameSet() {
-        return getFullLocaleNameSet(ICU_BASE_NAME, ICU_DATA_CLASS_LOADER);
+        return getFullLocaleNameSet(ICUData.ICU_BASE_NAME, ICU_DATA_CLASS_LOADER);
     }
 
     /**
@@ -564,7 +461,7 @@ public  class ICUResourceBundle extends UResourceBundle {
      * bundles.
      */
     public static Set<String> getAvailableLocaleNameSet() {
-        return getAvailableLocaleNameSet(ICU_BASE_NAME, ICU_DATA_CLASS_LOADER);
+        return getAvailableLocaleNameSet(ICUData.ICU_BASE_NAME, ICU_DATA_CLASS_LOADER);
     }
 
     /**
@@ -580,7 +477,7 @@ public  class ICUResourceBundle extends UResourceBundle {
      * @return the list of available locales
      */
     public static final ULocale[] getAvailableULocales() {
-        return getAvailableULocales(ICU_BASE_NAME, ICU_DATA_CLASS_LOADER);
+        return getAvailableULocales(ICUData.ICU_BASE_NAME, ICU_DATA_CLASS_LOADER);
     }
 
     /**
@@ -596,7 +493,7 @@ public  class ICUResourceBundle extends UResourceBundle {
      * @return the list of available locales
      */
     public static final Locale[] getAvailableLocales() {
-        return getAvailEntry(ICU_BASE_NAME, ICU_DATA_CLASS_LOADER).getLocaleList();
+        return getAvailEntry(ICUData.ICU_BASE_NAME, ICU_DATA_CLASS_LOADER).getLocaleList();
     }
 
     /**
@@ -626,6 +523,7 @@ public  class ICUResourceBundle extends UResourceBundle {
      *
      * @return the locale of this resource bundle
      */
+    @Override
     public Locale getLocale() {
         return getULocale().toLocale();
     }
@@ -697,6 +595,7 @@ public  class ICUResourceBundle extends UResourceBundle {
             final String bn, final ClassLoader root, final Set<String> names) {
         java.security.AccessController
             .doPrivileged(new java.security.PrivilegedAction<Void>() {
+                @Override
                 public Void run() {
                     try {
                         // bn has a trailing slash: The WebSphere class loader would return null
@@ -706,6 +605,7 @@ public  class ICUResourceBundle extends UResourceBundle {
                             return null;
                         }
                         URLVisitor v = new URLVisitor() {
+                            @Override
                             public void visit(String s) {
                                 if (s.endsWith(".res")) {
                                     String locstr = s.substring(0, s.length() - 4);
@@ -735,15 +635,19 @@ public  class ICUResourceBundle extends UResourceBundle {
             InputStream s = root.getResourceAsStream(bn + FULL_LOCALE_NAMES_LIST);
             if (s != null) {
                 BufferedReader br = new BufferedReader(new InputStreamReader(s, "ASCII"));
-                String line;
-                while ((line = br.readLine()) != null) {
-                    if (line.length() != 0 && !line.startsWith("#")) {
-                        locales.add(line);
+                try {
+                    String line;
+                    while ((line = br.readLine()) != null) {
+                        if (line.length() != 0 && !line.startsWith("#")) {
+                            locales.add(line);
+                        }
                     }
                 }
-                br.close();
+                finally {
+                    br.close();
+                }
             }
-        } catch (IOException e) {
+        } catch (IOException ignored) {
             // swallow it
         }
     }
@@ -872,10 +776,11 @@ public  class ICUResourceBundle extends UResourceBundle {
 
 
     /*
-     * Cache used for AvailableEntry 
+     * Cache used for AvailableEntry
      */
     private static CacheBase<String, AvailEntry, ClassLoader> GET_AVAILABLE_CACHE =
         new SoftCache<String, AvailEntry, ClassLoader>()  {
+            @Override
             protected AvailEntry createInstance(String key, ClassLoader loader) {
                 return new AvailEntry(key, loader);
             }
@@ -923,13 +828,12 @@ public  class ICUResourceBundle extends UResourceBundle {
                 }
                 if (depth == keys.length) {
                     // We found it.
-                    sub.setLoadingStatus(((ICUResourceBundle)requested).getLocaleID());
                     return sub;
                 }
                 base = sub;
             }
             // Try the parent bundle of the last-found resource.
-            ICUResourceBundle nextBase = (ICUResourceBundle)base.getParent();
+            ICUResourceBundle nextBase = base.getParent();
             if (nextBase == null) {
                 return null;
             }
@@ -1042,7 +946,7 @@ public  class ICUResourceBundle extends UResourceBundle {
                 }
             }
             // Try the parent bundle of the last-found resource.
-            ICUResourceBundle nextBase = (ICUResourceBundle)base.getParent();
+            ICUResourceBundle nextBase = base.getParent();
             if (nextBase == null) {
                 return null;
             }
@@ -1075,7 +979,7 @@ public  class ICUResourceBundle extends UResourceBundle {
     }
 
     private static int countPathKeys(String path) {
-        if (path.length() == 0) {
+        if (path.isEmpty()) {
             return 0;
         }
         int num = 1;
@@ -1119,6 +1023,7 @@ public  class ICUResourceBundle extends UResourceBundle {
         }
     }
 
+    @Override
     public boolean equals(Object other) {
         if (this == other) {
             return true;
@@ -1132,7 +1037,8 @@ public  class ICUResourceBundle extends UResourceBundle {
         }
         return false;
     }
-    
+
+    @Override
     public int hashCode() {
         assert false : "hashCode not designed";
         return 42;
@@ -1160,6 +1066,17 @@ public  class ICUResourceBundle extends UResourceBundle {
          * such as case mappings, collation, and segmentation (BreakIterator).
          */
         LOCALE_ROOT,
+        /**
+         * Open a resource bundle for the locale;
+         * if there is not even a base language bundle, then fail;
+         * never fall back to the default locale nor to the root locale.
+         *
+         * <p>This is used when fallback to another language is not desired
+         * and the root locale is not generally useful.
+         * For example, {@link com.ibm.icu.util.LocaleData#setNoSubstitute(boolean)}
+         * or currency display names for {@link com.ibm.icu.text.LocaleDisplayNames}.
+         */
+        LOCALE_ONLY,
         /**
          * Open a resource bundle for the exact bundle name as requested;
          * no fallbacks, do not load parent bundles.
@@ -1170,37 +1087,34 @@ public  class ICUResourceBundle extends UResourceBundle {
     };
 
     // This method is for super class's instantiateBundle method
-    public static UResourceBundle getBundleInstance(String baseName, String localeID,
-                                                    ClassLoader root, boolean disableFallback){
-        UResourceBundle b = instantiateBundle(baseName, localeID, root,
+    public static ICUResourceBundle getBundleInstance(String baseName, String localeID,
+            ClassLoader root, boolean disableFallback) {
+        return getBundleInstance(baseName, localeID, root,
                 disableFallback ? OpenType.DIRECT : OpenType.LOCALE_DEFAULT_ROOT);
-        if(b==null){
-            throw new MissingResourceException("Could not find the bundle "+ baseName+"/"+ localeID+".res","","");
-        }
-        return b;
     }
 
-    protected static UResourceBundle instantiateBundle(String baseName, String localeID,
-            ClassLoader root, boolean disableFallback){
-        return instantiateBundle(baseName, localeID, root,
-                disableFallback ? OpenType.DIRECT : OpenType.LOCALE_DEFAULT_ROOT);
-    }
-
-    public static UResourceBundle getBundleInstance(
+    public static ICUResourceBundle getBundleInstance(
             String baseName, ULocale locale, OpenType openType) {
         if (locale == null) {
             locale = ULocale.getDefault();
         }
-        return getBundleInstance(baseName, locale.toString(),
+        return getBundleInstance(baseName, locale.getBaseName(),
                 ICUResourceBundle.ICU_DATA_CLASS_LOADER, openType);
     }
 
-    public static UResourceBundle getBundleInstance(String baseName, String localeID,
+    public static ICUResourceBundle getBundleInstance(String baseName, String localeID,
             ClassLoader root, OpenType openType) {
         if (baseName == null) {
             baseName = ICUData.ICU_BASE_NAME;
         }
-        UResourceBundle b = instantiateBundle(baseName, localeID, root, openType);
+        localeID = ULocale.getBaseName(localeID);
+        ICUResourceBundle b;
+        if (openType == OpenType.LOCALE_DEFAULT_ROOT) {
+            b = instantiateBundle(baseName, localeID, ULocale.getDefault().getBaseName(),
+                    root, openType);
+        } else {
+            b = instantiateBundle(baseName, localeID, null, root, openType);
+        }
         if(b==null){
             throw new MissingResourceException(
                     "Could not find the bundle "+ baseName+"/"+ localeID+".res","","");
@@ -1208,33 +1122,35 @@ public  class ICUResourceBundle extends UResourceBundle {
         return b;
     }
 
-    //  recursively build bundle
-    private synchronized static UResourceBundle instantiateBundle(String baseName, String localeID,
-            ClassLoader root, OpenType openType) {
-        ULocale defaultLocale = ULocale.getDefault();
-        String localeName = localeID;
-        if(localeName.indexOf('@')>=0){
-            localeName = ULocale.getBaseName(localeID);
-        }
-        String fullName = ICUResourceBundleReader.getFullName(baseName, localeName);
-        ICUResourceBundle b = (ICUResourceBundle)loadFromCache(fullName, defaultLocale);
-
-        // here we assume that java type resource bundle organization
-        // is required then the base name contains '.' else
-        // the resource organization is of ICU type
-        // so clients can instantiate resources of the type
-        // com.mycompany.data.MyLocaleElements_en.res and
-        // com.mycompany.data.MyLocaleElements.res
-        //
-        final String rootLocale = (baseName.indexOf('.')==-1) ? "root" : "";
-        final String defaultID = defaultLocale.getBaseName();
-
-        if(localeName.equals("")){
-            localeName = rootLocale;
-        }
-        if(DEBUG) System.out.println("Creating "+fullName+ " currently b is "+b);
-        if (b == null) {
-            b = ICUResourceBundle.createBundle(baseName, localeName, root);
+    private static boolean localeIDStartsWithLangSubtag(String localeID, String lang) {
+        return localeID.startsWith(lang) &&
+                (localeID.length() == lang.length() || localeID.charAt(lang.length()) == '_');
+    }
+
+    private static ICUResourceBundle instantiateBundle(
+            final String baseName, final String localeID, final String defaultID,
+            final ClassLoader root, final OpenType openType) {
+        assert localeID.indexOf('@') < 0;
+        assert defaultID == null || defaultID.indexOf('@') < 0;
+        final String fullName = ICUResourceBundleReader.getFullName(baseName, localeID);
+        char openTypeChar = (char)('0' + openType.ordinal());
+        String cacheKey = openType != OpenType.LOCALE_DEFAULT_ROOT ?
+                fullName + '#' + openTypeChar :
+                    fullName + '#' + openTypeChar + '#' + defaultID;
+        return BUNDLE_CACHE.getInstance(cacheKey, new Loader() {
+                @Override
+                public ICUResourceBundle load() {
+            if(DEBUG) System.out.println("Creating "+fullName);
+            // here we assume that java type resource bundle organization
+            // is required then the base name contains '.' else
+            // the resource organization is of ICU type
+            // so clients can instantiate resources of the type
+            // com.mycompany.data.MyLocaleElements_en.res and
+            // com.mycompany.data.MyLocaleElements.res
+            //
+            final String rootLocale = (baseName.indexOf('.')==-1) ? "root" : "";
+            String localeName = localeID.isEmpty() ? rootLocale : localeID;
+            ICUResourceBundle b = ICUResourceBundle.createBundle(baseName, localeName, root);
 
             if(DEBUG)System.out.println("The bundle created is: "+b+" and openType="+openType+" and bundle.getNoFallback="+(b!=null && b.getNoFallback()));
             if (openType == OpenType.DIRECT || (b != null && b.getNoFallback())) {
@@ -1249,30 +1165,25 @@ public  class ICUResourceBundle extends UResourceBundle {
                 // for a bundle that does not have nofallback.
                 // Are the relevant test cases just disabled?
                 // Do item aliases not get followed via "direct" loading?
-                return addToCache(fullName, defaultLocale, b);
+                return b;
             }
 
             // fallback to locale ID parent
             if(b == null){
                 int i = localeName.lastIndexOf('_');
                 if (i != -1) {
+                    // Chop off the last underscore and the subtag after that.
                     String temp = localeName.substring(0, i);
-                    b = (ICUResourceBundle)instantiateBundle(baseName, temp, root, openType);
-                    if(b!=null && b.getULocale().getName().equals(temp)){
-                        b.setLoadingStatus(ICUResourceBundle.FROM_FALLBACK);
-                    }
+                    b = instantiateBundle(baseName, temp, defaultID, root, openType);
                 }else{
+                    // No underscore, only a base language subtag.
                     if(openType == OpenType.LOCALE_DEFAULT_ROOT &&
-                            !defaultLocale.getLanguage().equals(localeName)) {
-                        b = (ICUResourceBundle)instantiateBundle(baseName, defaultID, root, openType);
-                        if(b!=null){
-                            b.setLoadingStatus(ICUResourceBundle.FROM_DEFAULT);
-                        }
-                    }else if(rootLocale.length()!=0){
+                            !localeIDStartsWithLangSubtag(defaultID, localeName)) {
+                        // Go to the default locale before root.
+                        b = instantiateBundle(baseName, defaultID, defaultID, root, openType);
+                    } else if(openType != OpenType.LOCALE_ONLY && !rootLocale.isEmpty()) {
+                        // Ultimately go to root.
                         b = ICUResourceBundle.createBundle(baseName, rootLocale, root);
-                        if(b!=null){
-                            b.setLoadingStatus(ICUResourceBundle.FROM_ROOT);
-                        }
                     }
                 }
             }else{
@@ -1280,32 +1191,31 @@ public  class ICUResourceBundle extends UResourceBundle {
                 localeName = b.getLocaleID();
                 int i = localeName.lastIndexOf('_');
 
-                b = (ICUResourceBundle)addToCache(fullName, defaultLocale, b);
-
                 // TODO: C++ uresbund.cpp also checks for %%ParentIsRoot. Why not Java?
                 String parentLocaleName = ((ICUResourceBundleImpl.ResourceTable)b).findString("%%Parent");
                 if (parentLocaleName != null) {
-                    parent = instantiateBundle(baseName, parentLocaleName, root, openType);
+                    parent = instantiateBundle(baseName, parentLocaleName, defaultID, root, openType);
                 } else if (i != -1) {
-                    parent = instantiateBundle(baseName, localeName.substring(0, i), root, openType);
+                    parent = instantiateBundle(baseName, localeName.substring(0, i), defaultID, root, openType);
                 } else if (!localeName.equals(rootLocale)){
-                    parent = instantiateBundle(baseName, rootLocale, root, true);
+                    parent = instantiateBundle(baseName, rootLocale, defaultID, root, openType);
                 }
 
                 if (!b.equals(parent)){
                     b.setParent(parent);
                 }
             }
-        }
-        return b;
+            return b;
+        }});
     }
-    UResourceBundle get(String aKey, HashMap<String, String> aliasesVisited, UResourceBundle requested) {
+
+    ICUResourceBundle get(String aKey, HashMap<String, String> aliasesVisited, UResourceBundle requested) {
         ICUResourceBundle obj = (ICUResourceBundle)handleGet(aKey, aliasesVisited, requested);
         if (obj == null) {
-            obj = (ICUResourceBundle)getParent();
+            obj = getParent();
             if (obj != null) {
                 //call the get method to recursively fetch the resource
-                obj = (ICUResourceBundle)obj.get(aKey, aliasesVisited, requested);
+                obj = obj.get(aKey, aliasesVisited, requested);
             }
             if (obj == null) {
                 String fullName = ICUResourceBundleReader.getFullName(getBaseName(), getLocaleID());
@@ -1314,7 +1224,6 @@ public  class ICUResourceBundle extends UResourceBundle {
                                 + aKey, this.getClass().getName(), aKey);
             }
         }
-        obj.setLoadingStatus(((ICUResourceBundle)requested).getLocaleID());
         return obj;
     }
 
@@ -1376,26 +1285,39 @@ public  class ICUResourceBundle extends UResourceBundle {
         return getBundle(reader, baseName, localeID, root);
     }
 
+    @Override
     protected String getLocaleID() {
         return wholeBundle.localeID;
     }
 
+    @Override
     protected String getBaseName() {
         return wholeBundle.baseName;
     }
 
+    @Override
     public ULocale getULocale() {
         return wholeBundle.ulocale;
     }
 
-    public UResourceBundle getParent() {
-        return (UResourceBundle) parent;
+    /**
+     * Returns true if this is the root bundle, or an item in the root bundle.
+     */
+    public boolean isRoot() {
+        return wholeBundle.localeID.isEmpty() || wholeBundle.localeID.equals("root");
     }
 
+    @Override
+    public ICUResourceBundle getParent() {
+        return (ICUResourceBundle) parent;
+    }
+
+    @Override
     protected void setParent(ResourceBundle parent) {
         this.parent = parent;
     }
 
+    @Override
     public String getKey() {
         return key;
     }
@@ -1436,7 +1358,7 @@ public  class ICUResourceBundle extends UResourceBundle {
     protected ICUResourceBundle(ICUResourceBundle container, String key) {
         this.key = key;
         wholeBundle = container.wholeBundle;
-        this.container = (ICUResourceBundleImpl.ResourceContainer) container;
+        this.container = container;
         parent = container.parent;
     }
 
@@ -1473,7 +1395,8 @@ public  class ICUResourceBundle extends UResourceBundle {
             UResourceBundle requested) {
         WholeBundle wholeBundle = base.wholeBundle;
         ClassLoader loaderToUse = wholeBundle.loader;
-        String locale = null, keyPath = null;
+        String locale;
+        String keyPath = null;
         String bundleName;
         String rpath = wholeBundle.reader.getAlias(_resource);
         if (aliasesVisited == null) {
@@ -1496,12 +1419,12 @@ public  class ICUResourceBundle extends UResourceBundle {
             }
             //there is a path included
             if (bundleName.equals(ICUDATA)) {
-                bundleName = ICU_BASE_NAME;
+                bundleName = ICUData.ICU_BASE_NAME;
                 loaderToUse = ICU_DATA_CLASS_LOADER;
             }else if(bundleName.indexOf(ICUDATA)>-1){
                 int idx = bundleName.indexOf(HYPHEN);
                 if(idx>-1){
-                    bundleName = ICU_BASE_NAME+RES_PATH_SEP_STR+bundleName.substring(idx+1,bundleName.length());
+                    bundleName = ICUData.ICU_BASE_NAME+RES_PATH_SEP_STR+bundleName.substring(idx+1,bundleName.length());
                     loaderToUse = ICU_DATA_CLASS_LOADER;
                 }
             }
@@ -1529,14 +1452,7 @@ public  class ICUResourceBundle extends UResourceBundle {
             }
             sub = ICUResourceBundle.findResourceWithFallback(keyPath, bundle, null);
         }else{
-            if (locale == null) {
-                // {dlf} must use requestor's class loader to get resources from same jar
-                bundle = (ICUResourceBundle) getBundleInstance(bundleName, "",
-                         loaderToUse, false);
-            } else {
-                bundle = (ICUResourceBundle) getBundleInstance(bundleName, locale,
-                         loaderToUse, false);
-            }
+            bundle = getBundleInstance(bundleName, locale, loaderToUse, false);
 
             int numKeys;
             if (keyPath != null) {
@@ -1557,7 +1473,7 @@ public  class ICUResourceBundle extends UResourceBundle {
             if (numKeys > 0) {
                 sub = bundle;
                 for (int i = 0; sub != null && i < numKeys; ++i) {
-                    sub = (ICUResourceBundle)sub.get(keys[i], aliasesVisited, requested);
+                    sub = sub.get(keys[i], aliasesVisited, requested);
                 }
             }
         }
@@ -1576,6 +1492,7 @@ public  class ICUResourceBundle extends UResourceBundle {
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Deprecated
     public final Set<String> getTopLevelKeySet() {
         return wholeBundle.topLevelKeys;
     }
@@ -1584,6 +1501,7 @@ public  class ICUResourceBundle extends UResourceBundle {
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Deprecated
     public final void setTopLevelKeySet(Set<String> keySet) {
         wholeBundle.topLevelKeys = keySet;
     }
@@ -1594,10 +1512,12 @@ public  class ICUResourceBundle extends UResourceBundle {
     // by ResourceBundleWrapper despite its documentation requiring all subclasses to
     // implement it.
     // Consider deprecating UResourceBundle.handleGetKeys(), and consider making it always return null.
+    @Override
     protected Enumeration<String> handleGetKeys() {
         return Collections.enumeration(handleKeySet());
     }
 
+    @Override
     protected boolean isTopLevelResource() {
         return container == null;
     }
diff --git a/app/src/main/java/com/ibm/icu/impl/ICUResourceBundleImpl.java b/icu4j/src/main/java/com/ibm/icu/impl/ICUResourceBundleImpl.java
similarity index 86%
rename from app/src/main/java/com/ibm/icu/impl/ICUResourceBundleImpl.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ICUResourceBundleImpl.java
index 5d3f12c..a5cbe26 100644
--- a/app/src/main/java/com/ibm/icu/impl/ICUResourceBundleImpl.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ICUResourceBundleImpl.java
@@ -1,6 +1,8 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2004-2015, International Business Machines Corporation and
+ * Copyright (C) 2004-2016, International Business Machines Corporation and
  * others. All Rights Reserved.
  *******************************************************************************
  */
@@ -11,16 +13,22 @@ import java.util.HashMap;
 import java.util.Set;
 import java.util.TreeSet;
 
-import com.ibm.icu.impl.ICUResourceBundleReader.ReaderValue;
 import com.ibm.icu.util.UResourceBundle;
 import com.ibm.icu.util.UResourceTypeMismatchException;
 
 class ICUResourceBundleImpl extends ICUResourceBundle {
-    protected ICUResourceBundleImpl(ICUResourceBundleImpl container, String key) {
+    protected int resource;
+
+    protected ICUResourceBundleImpl(ICUResourceBundleImpl container, String key, int resource) {
         super(container, key);
+        this.resource = resource;
     }
     ICUResourceBundleImpl(WholeBundle wholeBundle) {
         super(wholeBundle);
+        resource = wholeBundle.reader.getRootResource();
+    }
+    public int getResource() {
+        return resource;
     }
     protected final ICUResourceBundle createBundleObject(String _key,
                                                          int _resource,
@@ -53,43 +61,46 @@ class ICUResourceBundleImpl extends ICUResourceBundle {
     // Scalar values ------------------------------------------------------- ***
 
     private static final class ResourceBinary extends ICUResourceBundleImpl {
-        private int resource;
+        @Override
         public int getType() {
             return BINARY;
         }
+        @Override
         public ByteBuffer getBinary() {
             return wholeBundle.reader.getBinary(resource);
         }
+        @Override
         public byte [] getBinary(byte []ba) {
             return wholeBundle.reader.getBinary(resource, ba);
         }
         ResourceBinary(ICUResourceBundleImpl container, String key, int resource) {
-            super(container, key);
-            this.resource = resource;
+            super(container, key, resource);
         }
     }
     private static final class ResourceInt extends ICUResourceBundleImpl {
-        private int resource;
+        @Override
         public int getType() {
             return INT;
         }
+        @Override
         public int getInt() {
             return ICUResourceBundleReader.RES_GET_INT(resource);
         }
+        @Override
         public int getUInt() {
             return ICUResourceBundleReader.RES_GET_UINT(resource);
         }
         ResourceInt(ICUResourceBundleImpl container, String key, int resource) {
-            super(container, key);
-            this.resource = resource;
+            super(container, key, resource);
         }
     }
     private static final class ResourceString extends ICUResourceBundleImpl {
-        private int resource;
         private String value;
+        @Override
         public int getType() {
             return STRING;
         }
+        @Override
         public String getString() {
             if (value != null) {
                 return value;
@@ -97,26 +108,26 @@ class ICUResourceBundleImpl extends ICUResourceBundle {
             return wholeBundle.reader.getString(resource);
         }
         ResourceString(ICUResourceBundleImpl container, String key, int resource) {
-            super(container, key);
-            this.resource = resource;
+            super(container, key, resource);
             String s = wholeBundle.reader.getString(resource);
             // Allow the reader cache's SoftReference to do its job.
-            if (s.length() < ICUResourceBundleReader.LARGE_SIZE / 2) {
+            if (s.length() < ICUResourceBundleReader.LARGE_SIZE / 2 ||
+                    CacheValue.futureInstancesWillBeStrong()) {
                 value = s;
             }
         }
     }
     private static final class ResourceIntVector extends ICUResourceBundleImpl {
-        private int resource;
+        @Override
         public int getType() {
             return INT_VECTOR;
         }
+        @Override
         public int[] getIntVector() {
             return wholeBundle.reader.getIntVector(resource);
         }
         ResourceIntVector(ICUResourceBundleImpl container, String key, int resource) {
-            super(container, key);
-            this.resource = resource;
+            super(container, key, resource);
         }
     }
 
@@ -125,6 +136,7 @@ class ICUResourceBundleImpl extends ICUResourceBundle {
     static abstract class ResourceContainer extends ICUResourceBundleImpl {
         protected ICUResourceBundleReader.Container value;
 
+        @Override
         public int getSize() {
             return value.getSize();
         }
@@ -152,17 +164,19 @@ class ICUResourceBundleImpl extends ICUResourceBundle {
             return createBundleObject(resKey, item, aliasesVisited, requested);
         }
 
-        ResourceContainer(ICUResourceBundleImpl container, String key) {
-            super(container, key);
+        ResourceContainer(ICUResourceBundleImpl container, String key, int resource) {
+            super(container, key, resource);
         }
         ResourceContainer(WholeBundle wholeBundle) {
             super(wholeBundle);
         }
     }
     static class ResourceArray extends ResourceContainer {
+        @Override
         public int getType() {
             return ARRAY;
         }
+        @Override
         protected String[] handleGetStringArray() {
             ICUResourceBundleReader reader = wholeBundle.reader;
             int length = value.getSize();
@@ -176,6 +190,7 @@ class ICUResourceBundleImpl extends ICUResourceBundle {
             }
             return strings;
         }
+        @Override
         public String[] getStringArray() {
             return handleGetStringArray();
         }
@@ -190,28 +205,20 @@ class ICUResourceBundleImpl extends ICUResourceBundle {
                                             UResourceBundle requested) {
             return createBundleObject(index, Integer.toString(index), aliasesVisited, requested);
         }
-        /**
-         * @param key will be set during enumeration; input contents is ignored
-         * @param readerValue will be set during enumeration; input contents is ignored
-         * @param sink receives all array item values
-         */
-        void getAllItems(UResource.Key key, ReaderValue readerValue, UResource.ArraySink sink) {
-            ICUResourceBundleReader reader = wholeBundle.reader;
-            readerValue.reader = reader;
-            ((ICUResourceBundleReader.Array)value).getAllItems(reader, key, readerValue, sink);
-        }
         ResourceArray(ICUResourceBundleImpl container, String key, int resource) {
-            super(container, key);
+            super(container, key, resource);
             value = wholeBundle.reader.getArray(resource);
         }
     }
     static class ResourceTable extends ResourceContainer {
+        @Override
         public int getType() {
             return TABLE;
         }
         protected String getKey(int index) {
             return ((ICUResourceBundleReader.Table)value).getKey(wholeBundle.reader, index);
         }
+        @Override
         protected Set<String> handleKeySet() {
             ICUResourceBundleReader reader = wholeBundle.reader;
             TreeSet<String> keySet = new TreeSet<String>();
@@ -287,18 +294,8 @@ class ICUResourceBundleImpl extends ICUResourceBundle {
             }
             return reader.getString(value.getContainerResource(reader, index));
         }
-        /**
-         * @param key will be set during enumeration; input contents is ignored
-         * @param readerValue will be set during enumeration; input contents is ignored
-         * @param sink receives all table item key-value pairs
-         */
-        void getAllItems(UResource.Key key, ReaderValue readerValue, UResource.TableSink sink) {
-            ICUResourceBundleReader reader = wholeBundle.reader;
-            readerValue.reader = reader;
-            ((ICUResourceBundleReader.Table)value).getAllItems(reader, key, readerValue, sink);
-        }
         ResourceTable(ICUResourceBundleImpl container, String key, int resource) {
-            super(container, key);
+            super(container, key, resource);
             value = wholeBundle.reader.getTable(resource);
         }
         /**
diff --git a/app/src/main/java/com/ibm/icu/impl/ICUResourceBundleReader.java b/icu4j/src/main/java/com/ibm/icu/impl/ICUResourceBundleReader.java
similarity index 90%
rename from app/src/main/java/com/ibm/icu/impl/ICUResourceBundleReader.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ICUResourceBundleReader.java
index 0083150..e4b30ec 100644
--- a/app/src/main/java/com/ibm/icu/impl/ICUResourceBundleReader.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ICUResourceBundleReader.java
@@ -1,6 +1,8 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2004-2015, International Business Machines Corporation and
+ * Copyright (C) 2004-2016, International Business Machines Corporation and
  * others. All Rights Reserved.
  *******************************************************************************
  */
@@ -13,8 +15,6 @@ import java.nio.ByteBuffer;
 import java.nio.CharBuffer;
 import java.nio.IntBuffer;
 
-import com.ibm.icu.impl.UResource.ArraySink;
-import com.ibm.icu.impl.UResource.TableSink;
 import com.ibm.icu.util.ICUException;
 import com.ibm.icu.util.ICUUncheckedIOException;
 import com.ibm.icu.util.ULocale;
@@ -34,7 +34,7 @@ public final class ICUResourceBundleReader {
      */
     private static final int DATA_FORMAT = 0x52657342;
     private static final class IsAcceptable implements ICUBinary.Authenticate {
-        // @Override when we switch to Java 6
+        @Override
         public boolean isDataVersionAcceptable(byte formatVersion[]) {
             return
                     (formatVersion[0] == 1 && (formatVersion[1] & 0xff) >= 1) ||
@@ -155,6 +155,7 @@ public final class ICUResourceBundleReader {
             this.localeID = (localeID == null) ? "" : localeID;
         }
 
+        @Override
         public boolean equals(Object obj) {
             if (this == obj) {
                 return true;
@@ -167,6 +168,7 @@ public final class ICUResourceBundleReader {
                     && this.localeID.equals(info.localeID);
         }
 
+        @Override
         public int hashCode() {
             return baseName.hashCode() ^ localeID.hashCode();
         }
@@ -216,7 +218,7 @@ public final class ICUResourceBundleReader {
         // set pool bundle if necessary
         if (usesPoolBundle) {
             poolBundleReader = getReader(baseName, "pool", loader);
-            if (!poolBundleReader.isPoolBundle) {
+            if (poolBundleReader == null || !poolBundleReader.isPoolBundle) {
                 throw new IllegalStateException("pool.res is not a pool bundle");
             }
             if (poolBundleReader.poolCheckSum != poolCheckSum) {
@@ -530,7 +532,7 @@ public final class ICUResourceBundleReader {
                 length=((first-0xdfef)<<16)|b16BitUnits.charAt(offset+1);
                 offset+=2;
             } else {
-                length=((int)b16BitUnits.charAt(offset+1)<<16)|b16BitUnits.charAt(offset+2);
+                length=(b16BitUnits.charAt(offset+1)<<16)|b16BitUnits.charAt(offset+2);
                 offset+=3;
             }
             // Cast up to CharSequence to insulate against the CharBuffer.subSequence() return type change
@@ -723,22 +725,6 @@ public final class ICUResourceBundleReader {
         }
     }
 
-    private int getArrayLength(int res) {
-        int offset = RES_GET_OFFSET(res);
-        if(offset == 0) {
-            return 0;
-        }
-        int type = RES_GET_TYPE(res);
-        if(type == UResourceBundle.ARRAY) {
-            offset = getResourceByteOffset(offset);
-            return getInt(offset);
-        } else if(type == ICUResourceBundle.ARRAY16) {
-            return b16BitUnits.charAt(offset);
-        } else {
-            return 0;
-        }
-    }
-
     Array getArray(int res) {
         int type=RES_GET_TYPE(res);
         if(!URES_IS_ARRAY(type)) {
@@ -757,25 +743,6 @@ public final class ICUResourceBundleReader {
         return (Array)resourceCache.putIfAbsent(res, array, 0);
     }
 
-    private int getTableLength(int res) {
-        int offset = RES_GET_OFFSET(res);
-        if(offset == 0) {
-            return 0;
-        }
-        int type = RES_GET_TYPE(res);
-        if(type == UResourceBundle.TABLE) {
-            offset = getResourceByteOffset(offset);
-            return bytes.getChar(offset);
-        } else if(type == ICUResourceBundle.TABLE16) {
-            return b16BitUnits.charAt(offset);
-        } else if(type == ICUResourceBundle.TABLE32) {
-            offset = getResourceByteOffset(offset);
-            return getInt(offset);
-        } else {
-            return 0;
-        }
-    }
-
     Table getTable(int res) {
         int type = RES_GET_TYPE(res);
         if(!URES_IS_TABLE(type)) {
@@ -833,7 +800,7 @@ public final class ICUResourceBundleReader {
 
     static class ReaderValue extends UResource.Value {
         ICUResourceBundleReader reader;
-        private int res;
+        int res;
 
         @Override
         public int getType() {
@@ -891,6 +858,81 @@ public final class ICUResourceBundleReader {
             }
             return bb;
         }
+
+        @Override
+        public com.ibm.icu.impl.UResource.Array getArray() {
+            Array array = reader.getArray(res);
+            if (array == null) {
+                throw new UResourceTypeMismatchException("");
+            }
+            return array;
+        }
+
+        @Override
+        public com.ibm.icu.impl.UResource.Table getTable() {
+            Table table = reader.getTable(res);
+            if (table == null) {
+                throw new UResourceTypeMismatchException("");
+            }
+            return table;
+        }
+
+        @Override
+        public boolean isNoInheritanceMarker() {
+            return reader.isNoInheritanceMarker(res);
+        }
+
+        @Override
+        public String[] getStringArray() {
+            Array array = reader.getArray(res);
+            if (array == null) {
+                throw new UResourceTypeMismatchException("");
+            }
+            return getStringArray(array);
+        }
+
+        @Override
+        public String[] getStringArrayOrStringAsArray() {
+            Array array = reader.getArray(res);
+            if (array != null) {
+                return getStringArray(array);
+            }
+            String s = reader.getString(res);
+            if (s != null) {
+                return new String[] { s };
+            }
+            throw new UResourceTypeMismatchException("");
+        }
+
+        @Override
+        public String getStringOrFirstOfArray() {
+            String s = reader.getString(res);
+            if (s != null) {
+                return s;
+            }
+            Array array = reader.getArray(res);
+            if (array != null && array.size > 0) {
+                int r = array.getContainerResource(reader, 0);
+                s = reader.getString(r);
+                if (s != null) {
+                    return s;
+                }
+            }
+            throw new UResourceTypeMismatchException("");
+        }
+
+        private String[] getStringArray(Array array) {
+            String[] result = new String[array.size];
+            for (int i = 0; i < array.size; ++i) {
+                int r = array.getContainerResource(reader, i);
+                String s = reader.getString(r);
+                if (s == null) {
+                    throw new UResourceTypeMismatchException("");
+                }
+                result[i] = s;
+            }
+            return result;
+        }
     }
 
     // Container value classes --------------------------------------------- ***
@@ -899,7 +941,7 @@ public final class ICUResourceBundleReader {
         protected int size;
         protected int itemsOffset;
 
-        final int getSize() {
+        public final int getSize() {
             return size;
         }
         int getContainerResource(ICUResourceBundleReader reader, int index) {
@@ -931,39 +973,16 @@ public final class ICUResourceBundleReader {
         Container() {
         }
     }
-    static class Array extends Container {
+    static class Array extends Container implements UResource.Array {
         Array() {}
-        void getAllItems(ICUResourceBundleReader reader,
-                UResource.Key key, ReaderValue value, ArraySink sink) {
-            for (int i = 0; i < size; ++i) {
-                int res = getContainerResource(reader, i);
-                int type = RES_GET_TYPE(res);
-                if (URES_IS_ARRAY(type)) {
-                    int numItems = reader.getArrayLength(res);
-                    ArraySink subSink = sink.getOrCreateArraySink(i, numItems);
-                    if (subSink != null) {
-                        Array array = reader.getArray(res);
-                        assert(array.size == numItems);
-                        array.getAllItems(reader, key, value, subSink);
-                    }
-                } else if (URES_IS_TABLE(type)) {
-                    int numItems = reader.getTableLength(res);
-                    TableSink subSink = sink.getOrCreateTableSink(i, numItems);
-                    if (subSink != null) {
-                        Table table = reader.getTable(res);
-                        assert(table.size == numItems);
-                        table.getAllItems(reader, key, value, subSink);
-                    }
-                /* TODO: settle on how to deal with aliases, port to C++
-                } else if (type == ICUResourceBundle.ALIAS) {
-                    throw new UnsupportedOperationException(
-                            "aliases not handled in resource enumeration"); */
-                } else {
-                    value.res = res;
-                    sink.put(i, value);
-                }
+        @Override
+        public boolean getValue(int i, UResource.Value value) {
+            if (0 <= i && i < size) {
+                ReaderValue readerValue = (ReaderValue)value;
+                readerValue.res = getContainerResource(readerValue.reader, i);
+                return true;
             }
-            sink.leave();
+            return false;
         }
     }
     private static final class Array32 extends Array {
@@ -987,10 +1006,12 @@ public final class ICUResourceBundleReader {
             itemsOffset = offset + 1;
         }
     }
-    static class Table extends Container {
+    static class Table extends Container implements UResource.Table {
         protected char[] keyOffsets;
         protected int[] key32Offsets;
 
+        Table() {
+        }
         String getKey(ICUResourceBundleReader reader, int index) {
             if (index < 0 || size <= index) {
                 return null;
@@ -1029,46 +1050,19 @@ public final class ICUResourceBundleReader {
         int getResource(ICUResourceBundleReader reader, String resKey) {
             return getContainerResource(reader, findTableItem(reader, resKey));
         }
-        void getAllItems(ICUResourceBundleReader reader,
-                UResource.Key key, ReaderValue value, TableSink sink) {
-            for (int i = 0; i < size; ++i) {
+        @Override
+        public boolean getKeyAndValue(int i, UResource.Key key, UResource.Value value) {
+            if (0 <= i && i < size) {
+                ReaderValue readerValue = (ReaderValue)value;
                 if (keyOffsets != null) {
-                    reader.setKeyFromKey16(keyOffsets[i], key);
+                    readerValue.reader.setKeyFromKey16(keyOffsets[i], key);
                 } else {
-                    reader.setKeyFromKey32(key32Offsets[i], key);
-                }
-                int res = getContainerResource(reader, i);
-                int type = RES_GET_TYPE(res);
-                if (URES_IS_ARRAY(type)) {
-                    int numItems = reader.getArrayLength(res);
-                    ArraySink subSink = sink.getOrCreateArraySink(key, numItems);
-                    if (subSink != null) {
-                        Array array = reader.getArray(res);
-                        assert(array.size == numItems);
-                        array.getAllItems(reader, key, value, subSink);
-                    }
-                } else if (URES_IS_TABLE(type)) {
-                    int numItems = reader.getTableLength(res);
-                    TableSink subSink = sink.getOrCreateTableSink(key, numItems);
-                    if (subSink != null) {
-                        Table table = reader.getTable(res);
-                        assert(table.size == numItems);
-                        table.getAllItems(reader, key, value, subSink);
-                    }
-                /* TODO: settle on how to deal with aliases, port to C++
-                } else if (type == ICUResourceBundle.ALIAS) {
-                    throw new UnsupportedOperationException(
-                            "aliases not handled in resource enumeration"); */
-                } else if (reader.isNoInheritanceMarker(res)) {
-                    sink.putNoFallback(key);
-                } else {
-                    value.res = res;
-                    sink.put(key, value);
+                    readerValue.reader.setKeyFromKey32(key32Offsets[i], key);
                 }
+                readerValue.res = getContainerResource(readerValue.reader, i);
+                return true;
             }
-            sink.leave();
-        }
-        Table() {
+            return false;
         }
     }
     private static final class Table1632 extends Table {
@@ -1125,7 +1119,7 @@ public final class ICUResourceBundleReader {
      * <p>This cache uses int[] and Object[] arrays to minimize object creation
      * and avoid auto-boxing.
      *
-     * <p>Large resource objects are stored in SoftReferences.
+     * <p>Large resource objects are usually stored in SoftReferences.
      *
      * <p>For few resources, a small table is used with binary search.
      * When more resources are cached, then the data structure changes to be faster
@@ -1153,11 +1147,18 @@ public final class ICUResourceBundleReader {
         private int levelBitsList;
         private Level rootLevel;
 
+        private static boolean storeDirectly(int size) {
+            return size < LARGE_SIZE || CacheValue.futureInstancesWillBeStrong();
+        }
+
         @SuppressWarnings("unchecked")
         private static final Object putIfCleared(Object[] values, int index, Object item, int size) {
             Object value = values[index];
             if(!(value instanceof SoftReference)) {
-                assert size < LARGE_SIZE;  // Caller should be consistent for each resource.
+                // The caller should be consistent for each resource,
+                // that is, create equivalent objects of equal size every time,
+                // but the CacheValue "strength" may change over time.
+                // assert size < LARGE_SIZE;
                 return value;
             }
             assert size >= LARGE_SIZE;
@@ -1165,7 +1166,8 @@ public final class ICUResourceBundleReader {
             if(value != null) {
                 return value;
             }
-            values[index] = new SoftReference<Object>(item);
+            values[index] = CacheValue.futureInstancesWillBeStrong() ?
+                    item : new SoftReference<Object>(item);
             return item;
         }
 
@@ -1214,7 +1216,7 @@ public final class ICUResourceBundleReader {
                         return level.putIfAbsent(key, item, size);
                     }
                     keys[index] = key;
-                    values[index] = (size >= LARGE_SIZE) ? new SoftReference<Object>(item) : item;
+                    values[index] = storeDirectly(size) ? item : new SoftReference<Object>(item);
                     return item;
                 }
                 // Collision: Add a child level, move the old item there,
@@ -1346,7 +1348,7 @@ public final class ICUResourceBundleReader {
                     }
                     ++length;
                     keys[index] = res;
-                    values[index] = (size >= LARGE_SIZE) ? new SoftReference<Object>(item) : item;
+                    values[index] = storeDirectly(size) ? item : new SoftReference<Object>(item);
                     return item;
                 } else /* not found && length == SIMPLE_LENGTH */ {
                     // Grow to become trie-like.
diff --git a/app/src/main/java/com/ibm/icu/impl/ICUResourceTableAccess.java b/icu4j/src/main/java/com/ibm/icu/impl/ICUResourceTableAccess.java
similarity index 87%
rename from app/src/main/java/com/ibm/icu/impl/ICUResourceTableAccess.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ICUResourceTableAccess.java
index f91f85e..a69b3b4 100644
--- a/app/src/main/java/com/ibm/icu/impl/ICUResourceTableAccess.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ICUResourceTableAccess.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2014, International Business Machines Corporation and
@@ -16,13 +18,13 @@ import com.ibm.icu.util.UResourceBundle;
 public class ICUResourceTableAccess {
     /**
      * Utility to fetch locale display data from resource bundle tables.  Convenience
-     * wrapper for {@link #getTableString(ICUResourceBundle, String, String, String)}.
+     * wrapper for {@link #getTableString(ICUResourceBundle, String, String, String, String)}.
      */
     public static String getTableString(String path, ULocale locale, String tableName,
-            String itemName) {
+            String itemName, String defaultValue) {
         ICUResourceBundle bundle = (ICUResourceBundle) UResourceBundle.
             getBundleInstance(path, locale.getBaseName());
-        return getTableString(bundle, tableName, null, itemName);
+        return getTableString(bundle, tableName, null, itemName, defaultValue);
     }
 
     /**
@@ -30,13 +32,13 @@ public class ICUResourceTableAccess {
      * through the "Fallback" resource if available.
      */
     public static String getTableString(ICUResourceBundle bundle, String tableName,
-            String subtableName, String item) {
+            String subtableName, String item, String defaultValue) {
         String result = null;
         try {
             for (;;) {
                 ICUResourceBundle table = bundle.findWithFallback(tableName);
                 if (table == null) {
-                    return item;
+                    return defaultValue;
                 }
                 ICUResourceBundle stable = table;
                 if (subtableName != null) {
@@ -69,7 +71,7 @@ public class ICUResourceTableAccess {
                 // still can't figure it out? try the fallback mechanism
                 String fallbackLocale = table.findStringWithFallback("Fallback"); // again, possible exception
                 if (fallbackLocale == null) {
-                    return item;
+                    return defaultValue;
                 }
 
                 if (fallbackLocale.length() == 0) {
@@ -77,7 +79,7 @@ public class ICUResourceTableAccess {
                 }
 
                 if (fallbackLocale.equals(table.getULocale().getName())) {
-                    return item;
+                    return defaultValue;
                 }
 
                 bundle = (ICUResourceBundle) UResourceBundle.getBundleInstance(
@@ -89,6 +91,6 @@ public class ICUResourceTableAccess {
         }
 
         // If the result is empty return item instead
-        return ((result != null && result.length() > 0) ? result : item);
+        return ((result != null && result.length() > 0) ? result : defaultValue);
     }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/ICUService.java b/icu4j/src/main/java/com/ibm/icu/impl/ICUService.java
similarity index 92%
rename from app/src/main/java/com/ibm/icu/impl/ICUService.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ICUService.java
index 99fc928..4db16b3 100644
--- a/app/src/main/java/com/ibm/icu/impl/ICUService.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ICUService.java
@@ -1,12 +1,13 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
  *******************************************************************************
- * Copyright (C) 2001-2013, International Business Machines Corporation and    *
- * others. All Rights Reserved.                                                *
+ * Copyright (C) 2001-2016, International Business Machines Corporation and
+ * others. All Rights Reserved.
  *******************************************************************************
  */
 package com.ibm.icu.impl;
 
-import java.lang.ref.SoftReference;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
@@ -21,6 +22,7 @@ import java.util.Map.Entry;
 import java.util.Set;
 import java.util.SortedMap;
 import java.util.TreeMap;
+import java.util.concurrent.ConcurrentHashMap;
 
 import com.ibm.icu.util.ULocale;
 import com.ibm.icu.util.ULocale.Category;
@@ -295,6 +297,7 @@ public class ICUService extends ICUNotifier {
          * Return the service instance if the factory's id is equal to
          * the key's currentID.  Service is ignored.
          */
+        @Override
         public Object create(Key key, ICUService service) {
             if (id.equals(key.currentID())) {
                 return instance;
@@ -306,6 +309,7 @@ public class ICUService extends ICUNotifier {
          * If visible, adds a mapping from id -> this to the result,
          * otherwise removes id from result.
          */
+        @Override
         public void updateVisibleIDs(Map<String, Factory> result) {
             if (visible) {
                 result.put(id, this);
@@ -319,6 +323,7 @@ public class ICUService extends ICUNotifier {
          * otherwise returns null.  (This default implementation has
          * no localized id information.)
          */
+        @Override
         public String getDisplayName(String identifier, ULocale locale) {
             return (visible && id.equals(identifier)) ? identifier : null;
         }
@@ -326,6 +331,7 @@ public class ICUService extends ICUNotifier {
         /**
          * For debugging.
          */
+        @Override
         public String toString() {
             StringBuilder buf = new StringBuilder(super.toString());
             buf.append(", id: ");
@@ -399,19 +405,12 @@ public class ICUService extends ICUNotifier {
                 // The cache has to stay in synch with the factory list.
                 factoryLock.acquireRead();
 
-                Map<String, CacheEntry> cache = null;
-                SoftReference<Map<String, CacheEntry>> cref = cacheref; // copy so we don't need to sync on this
-                if (cref != null) {
-                    if (DEBUG) System.out.println("Service " + name + " ref exists");
-                    cache = cref.get();
-                }
+                Map<String, CacheEntry> cache = this.cache; // copy so we don't need to sync on this
                 if (cache == null) {
                     if (DEBUG) System.out.println("Service " + name + " cache was empty");
                     // synchronized since additions and queries on the cache must be atomic
                     // they can be interleaved, though
-                    cache = Collections.synchronizedMap(new HashMap<String, CacheEntry>());
-//                  hardRef = cache; // debug
-                    cref = new SoftReference<Map<String, CacheEntry>>(cache);
+                    cache = new ConcurrentHashMap<String, CacheEntry>();
                 }
 
                 String currentDescriptor = null;
@@ -495,7 +494,7 @@ public class ICUService extends ICUNotifier {
                         // so we know our cache is consistent with the factory list.
                         // We might stomp over a cache that some other thread
                         // rebuilt, but that's the breaks.  They're both good.
-                        cacheref = cref;
+                        this.cache = cache;
                     }
 
                     if (actualReturn != null) {
@@ -521,7 +520,7 @@ public class ICUService extends ICUNotifier {
 
         return handleDefault(key, actualReturn);
     }
-    private SoftReference<Map<String, CacheEntry>> cacheref;
+    private Map<String, CacheEntry> cache;
 
     // Record the actual id for this service in the cache, so we can return it
     // even if we succeed later with a different id.
@@ -583,43 +582,25 @@ public class ICUService extends ICUNotifier {
      * Return a map from visible ids to factories.
      */
     private Map<String, Factory> getVisibleIDMap() {
-        Map<String, Factory> idcache = null;
-        SoftReference<Map<String, Factory>> ref = idref;
-        if (ref != null) {
-            idcache = ref.get();
-        }
-        while (idcache == null) {
-            synchronized (this) { // or idref-only lock?
-                if (ref == idref || idref == null) {
-                    // no other thread updated idref before we got the lock, so
-                    // grab the factory list and update it ourselves
-                    try {
-                        factoryLock.acquireRead();
-                        idcache = new HashMap<String, Factory>();
-                        ListIterator<Factory> lIter = factories.listIterator(factories.size());
-                        while (lIter.hasPrevious()) {
-                            Factory f = lIter.previous();
-                            f.updateVisibleIDs(idcache);
-                        }
-                        idcache = Collections.unmodifiableMap(idcache);
-                        idref = new SoftReference<Map<String, Factory>>(idcache);
+        synchronized (this) { // or idcache-only lock?
+            if (idcache == null) {
+                try {
+                    factoryLock.acquireRead();
+                    Map<String, Factory> mutableMap = new HashMap<String, Factory>();
+                    ListIterator<Factory> lIter = factories.listIterator(factories.size());
+                    while (lIter.hasPrevious()) {
+                        Factory f = lIter.previous();
+                        f.updateVisibleIDs(mutableMap);
                     }
-                    finally {
-                        factoryLock.releaseRead();
-                    }
-                } else {
-                    // another thread updated idref, but gc may have stepped
-                    // in and undone its work, leaving idcache null.  If so,
-                    // retry.
-                    ref = idref;
-                    idcache = ref.get();
+                    this.idcache = Collections.unmodifiableMap(mutableMap);
+                } finally {
+                    factoryLock.releaseRead();
                 }
             }
         }
-
         return idcache;
     }
-    private SoftReference<Map<String, Factory>> idref;
+    private Map<String, Factory> idcache;
 
     /**
      * Convenience override for getDisplayName(String, ULocale) that
@@ -648,12 +629,12 @@ public class ICUService extends ICUNotifier {
                 return f.getDisplayName(id, locale);
             }
         }
-        
+
         return null;
     }
 
     /**
-     * Convenience override of getDisplayNames(ULocale, Comparator, String) that 
+     * Convenience override of getDisplayNames(ULocale, Comparator, String) that
      * uses the current default Locale as the locale, null as
      * the comparator, and null for the matchID.
      */
@@ -708,7 +689,7 @@ public class ICUService extends ICUNotifier {
             synchronized (this) {
                 if (ref == dnref || dnref == null) {
                     dncache = new TreeMap<String, String>(com); // sorted
-                    
+
                     Map<String, Factory> m = getVisibleIDMap();
                     Iterator<Entry<String, Factory>> ei = m.entrySet().iterator();
                     while (ei.hasNext()) {
@@ -747,18 +728,18 @@ public class ICUService extends ICUNotifier {
     // locale, comparator, and corresponding map.
     private static class LocaleRef {
         private final ULocale locale;
-        private SoftReference<SortedMap<String, String>> ref;
+        private SortedMap<String, String> dnCache;
         private Comparator<Object> com;
 
         LocaleRef(SortedMap<String, String> dnCache, ULocale locale, Comparator<Object> com) {
             this.locale = locale;
             this.com = com;
-            this.ref = new SoftReference<SortedMap<String, String>>(dnCache);
+            this.dnCache = dnCache;
         }
 
 
         SortedMap<String, String> get(ULocale loc, Comparator<Object> comp) {
-            SortedMap<String, String> m = ref.get();
+            SortedMap<String, String> m = dnCache;
             if (m != null &&
                 this.locale.equals(loc) &&
                 (this.com == comp || (this.com != null && this.com.equals(comp)))) {
@@ -915,8 +896,8 @@ public class ICUService extends ICUNotifier {
         // we don't synchronize on these because methods that use them
         // copy before use, and check for changes if they modify the
         // caches.
-        cacheref = null;
-        idref = null;
+        cache = null;
+        idcache = null;
         dnref = null;
     }
 
@@ -927,7 +908,7 @@ public class ICUService extends ICUNotifier {
      * the resolution of ids changes, but not the visible ids themselves.
      */
     protected void clearServiceCache() {
-        cacheref = null;
+        cache = null;
     }
 
     /**
@@ -946,6 +927,7 @@ public class ICUService extends ICUNotifier {
      * requires a ServiceListener.  Subclasses can override to accept
      * different listeners.
      */
+    @Override
     protected boolean acceptsListener(EventListener l) {
         return l instanceof ServiceListener;
     }
@@ -954,6 +936,7 @@ public class ICUService extends ICUNotifier {
      * Notify the listener, which by default is a ServiceListener.
      * Subclasses can override to use a different listener.
      */
+    @Override
     protected void notifyListener(EventListener l) {
         ((ServiceListener)l).serviceChanged(this);
     }
@@ -982,6 +965,7 @@ public class ICUService extends ICUNotifier {
     /**
      * Returns the result of super.toString, appending the name in curly braces.
      */
+    @Override
     public String toString() {
         return super.toString() + "{" + name + "}";
     }
diff --git a/app/src/main/java/com/ibm/icu/impl/IDNA2003.java b/icu4j/src/main/java/com/ibm/icu/impl/IDNA2003.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/IDNA2003.java
rename to icu4j/src/main/java/com/ibm/icu/impl/IDNA2003.java
index 106a233..e3503b8 100644
--- a/app/src/main/java/com/ibm/icu/impl/IDNA2003.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/IDNA2003.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2003-2010, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/IllegalIcuArgumentException.java b/icu4j/src/main/java/com/ibm/icu/impl/IllegalIcuArgumentException.java
similarity index 87%
rename from app/src/main/java/com/ibm/icu/impl/IllegalIcuArgumentException.java
rename to icu4j/src/main/java/com/ibm/icu/impl/IllegalIcuArgumentException.java
index 204a264..b9902a6 100644
--- a/app/src/main/java/com/ibm/icu/impl/IllegalIcuArgumentException.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/IllegalIcuArgumentException.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009, Google, International Business Machines Corporation and         *
@@ -16,17 +18,18 @@ public class IllegalIcuArgumentException extends IllegalArgumentException {
     public IllegalIcuArgumentException(String errorMessage) {
         super(errorMessage);
     }
-    
+
     public IllegalIcuArgumentException(Throwable cause) {
         super(cause);
     }
-    
+
     public IllegalIcuArgumentException(String errorMessage, Throwable cause) {
         super(errorMessage, cause);
     }
-    
+
+    @Override
     public synchronized IllegalIcuArgumentException initCause(Throwable cause) {
         return (IllegalIcuArgumentException) super.initCause(cause);
     }
-    
+
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/IntTrie.java b/icu4j/src/main/java/com/ibm/icu/impl/IntTrie.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/impl/IntTrie.java
rename to icu4j/src/main/java/com/ibm/icu/impl/IntTrie.java
index ec08abf..ca45ded 100644
--- a/app/src/main/java/com/ibm/icu/impl/IntTrie.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/IntTrie.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ******************************************************************************
  * Copyright (C) 1996-2015, International Business Machines Corporation and
@@ -28,10 +30,10 @@ public class IntTrie extends Trie
 
     /**
     * <p>Creates a new Trie with the settings for the trie data.</p>
-    * <p>Unserialize the 32-bit-aligned input stream and use the data for the 
+    * <p>Unserialize the 32-bit-aligned input stream and use the data for the
     * trie.</p>
     * @param bytes file buffer to a ICU data file, containing the trie
-    * @param dataManipulate object which provides methods to parse the char 
+    * @param dataManipulate object which provides methods to parse the char
     *                        data
     * @throws IOException thrown when data reading fails
     */
@@ -120,7 +122,7 @@ public class IntTrie extends Trie
         // fastpath for U+0000..U+D7FF
         if(0 <= ch && ch < UTF16.LEAD_SURROGATE_MIN_VALUE) {
             // copy of getRawOffset()
-            offset = (m_index_[ch >> INDEX_STAGE_1_SHIFT_] << INDEX_STAGE_2_SHIFT_) 
+            offset = (m_index_[ch >> INDEX_STAGE_1_SHIFT_] << INDEX_STAGE_2_SHIFT_)
                     + (ch & INDEX_STAGE_3_MASK_);
             return m_data_[offset];
         }
@@ -200,15 +202,15 @@ public class IntTrie extends Trie
         }
         return m_initialValue_;
     }
-    
+
     /**
      * <p>Gets the latin 1 fast path value.</p>
-     * <p>Note this only works if latin 1 characters have their own linear 
+     * <p>Note this only works if latin 1 characters have their own linear
      * array.</p>
      * @param ch latin 1 characters
      * @return value associated with latin character
      */
-    public final int getLatin1LinearValue(char ch) 
+    public final int getLatin1LinearValue(char ch)
     {
         return m_data_[INDEX_STAGE_3_MASK_ + 1 + ch];
     }
@@ -220,7 +222,8 @@ public class IntTrie extends Trie
      *         otherwise
      */
     ///CLOVER:OFF
-    public boolean equals(Object other) 
+    @Override
+    public boolean equals(Object other)
     {
         boolean result = super.equals(other);
         if (result && other instanceof IntTrie) {
@@ -233,13 +236,14 @@ public class IntTrie extends Trie
         }
         return false;
     }
-    
+
+    @Override
     public int hashCode() {
         assert false : "hashCode not designed";
         return 42;
     }
     ///CLOVER:ON
-    
+
     // protected methods -----------------------------------------------
 
     /**
@@ -247,6 +251,7 @@ public class IntTrie extends Trie
     * data array</p>
     * @param bytes data buffer containing trie data
     */
+    @Override
     protected final void unserialize(ByteBuffer bytes)
     {
         super.unserialize(bytes);
@@ -261,6 +266,7 @@ public class IntTrie extends Trie
     * @param trail trailing surrogate
     * @return offset to data
     */
+    @Override
     protected final int getSurrogateOffset(char lead, char trail)
     {
         if (m_dataManipulate_ == null) {
@@ -279,7 +285,7 @@ public class IntTrie extends Trie
         // value: m_initialValue_
         return -1;
     }
-    
+
     /**
     * Gets the value at the argument index.
     * For use internally in TrieIterator
@@ -287,22 +293,24 @@ public class IntTrie extends Trie
     * @return 32 bit value
     * @see com.ibm.icu.impl.TrieIterator
     */
+    @Override
     protected final int getValue(int index)
     {
       return m_data_[index];
     }
-    
+
     /**
     * Gets the default initial value
-    * @return 32 bit value 
+    * @return 32 bit value
     */
+    @Override
     protected final int getInitialValue()
     {
         return m_initialValue_;
     }
 
     // package private methods -----------------------------------------
-    
+
     /**
      * Internal constructor for builder use
      * @param index the index array to be slotted into this trie
@@ -319,7 +327,7 @@ public class IntTrie extends Trie
         m_dataLength_ = m_data_.length;
         m_initialValue_ = initialvalue;
     }
-    
+
     // private data members --------------------------------------------
 
     /**
diff --git a/app/src/main/java/com/ibm/icu/impl/IntTrieBuilder.java b/icu4j/src/main/java/com/ibm/icu/impl/IntTrieBuilder.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/IntTrieBuilder.java
rename to icu4j/src/main/java/com/ibm/icu/impl/IntTrieBuilder.java
index ad5a774..15941a2 100644
--- a/app/src/main/java/com/ibm/icu/impl/IntTrieBuilder.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/IntTrieBuilder.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 1996-2010, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/impl/InvalidFormatException.java b/icu4j/src/main/java/com/ibm/icu/impl/InvalidFormatException.java
similarity index 86%
rename from app/src/main/java/com/ibm/icu/impl/InvalidFormatException.java
rename to icu4j/src/main/java/com/ibm/icu/impl/InvalidFormatException.java
index 9e26f3a..6ee6e16 100644
--- a/app/src/main/java/com/ibm/icu/impl/InvalidFormatException.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/InvalidFormatException.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
 *******************************************************************************
 * Copyright (C) 2006-2015, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/impl/IterableComparator.java b/icu4j/src/main/java/com/ibm/icu/impl/IterableComparator.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/impl/IterableComparator.java
rename to icu4j/src/main/java/com/ibm/icu/impl/IterableComparator.java
index adcb5d6..38c1983 100644
--- a/app/src/main/java/com/ibm/icu/impl/IterableComparator.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/IterableComparator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ************************************************************************************
  * Copyright (C) 2007-2015, Google Inc, International Business Machines Corporation
@@ -30,6 +32,7 @@ public class IterableComparator<T> implements Comparator<Iterable<T>> {
         this.shorterFirst = shorterFirst ? 1 : -1;
     }
 
+    @Override
     public int compare(Iterable<T> a, Iterable<T> b) {
         if (a == null) {
             return b == null ? 0 : -shorterFirst;
diff --git a/app/src/main/java/com/ibm/icu/impl/JavaTimeZone.java b/icu4j/src/main/java/com/ibm/icu/impl/JavaTimeZone.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/impl/JavaTimeZone.java
rename to icu4j/src/main/java/com/ibm/icu/impl/JavaTimeZone.java
index d7647a4..a43d3f5 100644
--- a/app/src/main/java/com/ibm/icu/impl/JavaTimeZone.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/JavaTimeZone.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2008-2014, International Business Machines Corporation and    *
@@ -105,6 +107,7 @@ public class JavaTimeZone extends TimeZone {
     /* (non-Javadoc)
      * @see com.ibm.icu.util.TimeZone#getOffset(int, int, int, int, int, int)
      */
+    @Override
     public int getOffset(int era, int year, int month, int day, int dayOfWeek, int milliseconds) {
         return javatz.getOffset(era, year, month, day, dayOfWeek, milliseconds);
     }
@@ -112,6 +115,7 @@ public class JavaTimeZone extends TimeZone {
     /* (non-Javadoc)
      * @see com.ibm.icu.util.TimeZone#getOffset(long, boolean, int[])
      */
+    @Override
     public void getOffset(long date, boolean local, int[] offsets) {
         synchronized (javacal) {
             if (local) {
@@ -157,6 +161,7 @@ public class JavaTimeZone extends TimeZone {
     /* (non-Javadoc)
      * @see com.ibm.icu.util.TimeZone#getRawOffset()
      */
+    @Override
     public int getRawOffset() {
         return javatz.getRawOffset();
     }
@@ -164,6 +169,7 @@ public class JavaTimeZone extends TimeZone {
     /* (non-Javadoc)
      * @see com.ibm.icu.util.TimeZone#inDaylightTime(java.util.Date)
      */
+    @Override
     public boolean inDaylightTime(Date date) {
         return javatz.inDaylightTime(date);
     }
@@ -171,6 +177,7 @@ public class JavaTimeZone extends TimeZone {
     /* (non-Javadoc)
      * @see com.ibm.icu.util.TimeZone#setRawOffset(int)
      */
+    @Override
     public void setRawOffset(int offsetMillis) {
         if (isFrozen()) {
             throw new UnsupportedOperationException("Attempt to modify a frozen JavaTimeZone instance.");
@@ -181,6 +188,7 @@ public class JavaTimeZone extends TimeZone {
     /* (non-Javadoc)
      * @see com.ibm.icu.util.TimeZone#useDaylightTime()
      */
+    @Override
     public boolean useDaylightTime() {
         return javatz.useDaylightTime();
     }
@@ -188,6 +196,7 @@ public class JavaTimeZone extends TimeZone {
     /* (non-Javadoc)
      * @see com.ibm.icu.util.TimeZone#observesDaylightTime()
      */
+    @Override
     public boolean observesDaylightTime() {
         if (mObservesDaylightTime != null) {
             // Java 7+
@@ -204,6 +213,7 @@ public class JavaTimeZone extends TimeZone {
     /* (non-Javadoc)
      * @see com.ibm.icu.util.TimeZone#getDSTSavings()
      */
+    @Override
     public int getDSTSavings() {
         return javatz.getDSTSavings();
     }
@@ -215,6 +225,7 @@ public class JavaTimeZone extends TimeZone {
     /* (non-Javadoc)
      * @see com.ibm.icu.util.TimeZone#clone()
      */
+    @Override
     public Object clone() {
         if (isFrozen()) {
             return this;
@@ -225,6 +236,7 @@ public class JavaTimeZone extends TimeZone {
     /* (non-Javadoc)
      * @see com.ibm.icu.util.TimeZone#hashCode()
      */
+    @Override
     public int hashCode() {
         return super.hashCode() + javatz.hashCode();
     }
@@ -240,6 +252,7 @@ public class JavaTimeZone extends TimeZone {
     /* (non-Javadoc)
      * @see com.ibm.icu.util.TimeZone#isFrozen()
      */
+    @Override
     public boolean isFrozen() {
         return isFrozen;
     }
@@ -247,6 +260,7 @@ public class JavaTimeZone extends TimeZone {
     /* (non-Javadoc)
      * @see com.ibm.icu.util.TimeZone#freeze()
      */
+    @Override
     public TimeZone freeze() {
         isFrozen = true;
         return this;
@@ -255,10 +269,11 @@ public class JavaTimeZone extends TimeZone {
     /* (non-Javadoc)
      * @see com.ibm.icu.util.TimeZone#cloneAsThawed()
      */
+    @Override
     public TimeZone cloneAsThawed() {
         JavaTimeZone tz = (JavaTimeZone)super.cloneAsThawed();
         tz.javatz = (java.util.TimeZone)javatz.clone();
-        tz.javacal = (java.util.GregorianCalendar)javacal.clone();
+        tz.javacal = new java.util.GregorianCalendar(javatz);  // easier than synchronized javacal.clone()
         tz.isFrozen = false;
         return tz;
     }
diff --git a/app/src/main/java/com/ibm/icu/impl/LocaleDisplayNamesImpl.java b/icu4j/src/main/java/com/ibm/icu/impl/LocaleDisplayNamesImpl.java
similarity index 83%
rename from app/src/main/java/com/ibm/icu/impl/LocaleDisplayNamesImpl.java
rename to icu4j/src/main/java/com/ibm/icu/impl/LocaleDisplayNamesImpl.java
index 50cec65..03ff19e 100644
--- a/app/src/main/java/com/ibm/icu/impl/LocaleDisplayNamesImpl.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/LocaleDisplayNamesImpl.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2016, International Business Machines Corporation and
@@ -29,13 +31,13 @@ import com.ibm.icu.text.DisplayContext.Type;
 import com.ibm.icu.text.LocaleDisplayNames;
 import com.ibm.icu.util.ULocale;
 import com.ibm.icu.util.UResourceBundle;
-import com.ibm.icu.util.UResourceBundleIterator;
 
 public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
     private final ULocale locale;
     private final DialectHandling dialectHandling;
     private final DisplayContext capitalization;
     private final DisplayContext nameLength;
+    private final DisplayContext substituteHandling;
     private final DataTable langData;
     private final DataTable regionData;
     // Compiled SimpleFormatter patterns.
@@ -97,6 +99,30 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
         }
     }
 
+    private final class CapitalizationContextSink extends UResource.Sink {
+        boolean hasCapitalizationUsage = false;
+
+        @Override
+        public void put(UResource.Key key, UResource.Value value, boolean noFallback) {
+            UResource.Table contextsTable = value.getTable();
+            for (int i = 0; contextsTable.getKeyAndValue(i, key, value); ++i) {
+
+                CapitalizationContextUsage usage = contextUsageTypeMap.get(key.toString());
+                if (usage == null) { continue; };
+
+                int[] intVector = value.getIntVector();
+                if (intVector.length < 2) { continue; }
+
+                int titlecaseInt = (capitalization == DisplayContext.CAPITALIZATION_FOR_UI_LIST_OR_MENU)
+                        ? intVector[0] : intVector[1];
+                if (titlecaseInt == 0) { continue; }
+
+                capitalizationUsage[usage.ordinal()] = true;
+                hasCapitalizationUsage = true;
+            }
+        }
+    }
+
     public LocaleDisplayNamesImpl(ULocale locale, DialectHandling dialectHandling) {
         this(locale, (dialectHandling==DialectHandling.STANDARD_NAMES)? DisplayContext.STANDARD_NAMES: DisplayContext.DIALECT_NAMES,
                 DisplayContext.CAPITALIZATION_NONE);
@@ -106,6 +132,7 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
         DialectHandling dialectHandling = DialectHandling.STANDARD_NAMES;
         DisplayContext capitalization = DisplayContext.CAPITALIZATION_NONE;
         DisplayContext nameLength = DisplayContext.LENGTH_FULL;
+        DisplayContext substituteHandling = DisplayContext.SUBSTITUTE;
         for (DisplayContext contextItem : contexts) {
             switch (contextItem.type()) {
             case DIALECT_HANDLING:
@@ -118,6 +145,9 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
             case DISPLAY_LENGTH:
                 nameLength = contextItem;
                 break;
+            case SUBSTITUTE_HANDLING:
+                substituteHandling = contextItem;
+                break;
             default:
                 break;
             }
@@ -126,8 +156,9 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
         this.dialectHandling = dialectHandling;
         this.capitalization = capitalization;
         this.nameLength = nameLength;
-        this.langData = LangDataTables.impl.get(locale);
-        this.regionData = RegionDataTables.impl.get(locale);
+        this.substituteHandling = substituteHandling;
+        this.langData = LangDataTables.impl.get(locale, substituteHandling == DisplayContext.NO_SUBSTITUTE);
+        this.regionData = RegionDataTables.impl.get(locale, substituteHandling == DisplayContext.NO_SUBSTITUTE);
         this.locale = ULocale.ROOT.equals(langData.getLocale()) ? regionData.getLocale() :
             langData.getLocale();
 
@@ -136,14 +167,14 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
         // load the bundle again.  Using direct lookup didn't seem to make an appreciable
         // difference in performance.
         String sep = langData.get("localeDisplayPattern", "separator");
-        if ("separator".equals(sep)) {
+        if (sep == null || "separator".equals(sep)) {
             sep = "{0}, {1}";
         }
         StringBuilder sb = new StringBuilder();
         this.separatorFormat = SimpleFormatterImpl.compileToStringMinMaxArguments(sep, sb, 2, 2);
 
         String pattern = langData.get("localeDisplayPattern", "pattern");
-        if ("pattern".equals(pattern)) {
+        if (pattern == null || "pattern".equals(pattern)) {
             pattern = "{0} ({1})";
         }
         this.format = SimpleFormatterImpl.compileToStringMinMaxArguments(pattern, sb, 2, 2);
@@ -160,7 +191,7 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
         }
 
         String keyTypePattern = langData.get("localeDisplayPattern", "keyTypePattern");
-        if ("keyTypePattern".equals(keyTypePattern)) {
+        if (keyTypePattern == null || "keyTypePattern".equals(keyTypePattern)) {
             keyTypePattern = "{0}={1}";
         }
         this.keyTypeFormat = SimpleFormatterImpl.compileToStringMinMaxArguments(
@@ -172,33 +203,15 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
         if (capitalization == DisplayContext.CAPITALIZATION_FOR_UI_LIST_OR_MENU ||
                 capitalization == DisplayContext.CAPITALIZATION_FOR_STANDALONE) {
             capitalizationUsage = new boolean[CapitalizationContextUsage.values().length]; // initialized to all false
-            ICUResourceBundle rb = (ICUResourceBundle)UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, locale);
-            UResourceBundle contextTransformsBundle = null;
+            ICUResourceBundle rb = (ICUResourceBundle)UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, locale);
+            CapitalizationContextSink sink = new CapitalizationContextSink();
             try {
-                contextTransformsBundle = (UResourceBundle)rb.getWithFallback("contextTransforms");
+                rb.getAllItemsWithFallback("contextTransforms", sink);
             }
             catch (MissingResourceException e) {
-                contextTransformsBundle = null; // probably redundant
-            }
-            if (contextTransformsBundle != null) {
-                UResourceBundleIterator ctIterator = contextTransformsBundle.getIterator();
-                while ( ctIterator.hasNext() ) {
-                    UResourceBundle contextTransformUsage = ctIterator.next();
-                    int[] intVector = contextTransformUsage.getIntVector();
-                    if (intVector.length >= 2) {
-                        String usageKey = contextTransformUsage.getKey();
-                        CapitalizationContextUsage usage = contextUsageTypeMap.get(usageKey);
-                        if (usage != null) {
-                            int titlecaseInt = (capitalization == DisplayContext.CAPITALIZATION_FOR_UI_LIST_OR_MENU)?
-                                    intVector[0]: intVector[1];
-                                    if (titlecaseInt != 0) {
-                                        capitalizationUsage[usage.ordinal()] = true;
-                                        needBrkIter = true;
-                                    }
-                        }
-                    }
-                }
+                // Silently ignore.  Not every locale has contextTransforms.
             }
+            needBrkIter = sink.hasCapitalizationUsage;
         }
         // Get a sentence break iterator if we will need it
         if (needBrkIter || capitalization == DisplayContext.CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE) {
@@ -231,6 +244,9 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
         case DISPLAY_LENGTH:
             result = nameLength;
             break;
+        case SUBSTITUTE_HANDLING:
+            result = substituteHandling;
+            break;
         default:
             result = DisplayContext.STANDARD_NAMES; // hmm, we should do something else here
             break;
@@ -271,7 +287,7 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
         return localeDisplayNameInternal(new ULocale(localeId));
     }
 
-    // TOTO: implement use of capitalization
+    // TODO: implement use of capitalization
     private String localeDisplayNameInternal(ULocale locale) {
         // lang
         // lang (script, country, variant, keyword=value, ...)
@@ -301,7 +317,7 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
                 if (hasScript && hasCountry) {
                     String langScriptCountry = lang + '_' + script + '_' + country;
                     String result = localeIdName(langScriptCountry);
-                    if (!result.equals(langScriptCountry)) {
+                    if (result != null && !result.equals(langScriptCountry)) {
                         resultName = result;
                         hasScript = false;
                         hasCountry = false;
@@ -311,7 +327,7 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
                 if (hasScript) {
                     String langScript = lang + '_' + script;
                     String result = localeIdName(langScript);
-                    if (!result.equals(langScript)) {
+                    if (result != null && !result.equals(langScript)) {
                         resultName = result;
                         hasScript = false;
                         break;
@@ -320,7 +336,7 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
                 if (hasCountry) {
                     String langCountry = lang + '_' + country;
                     String result = localeIdName(langCountry);
-                    if (!result.equals(langCountry)) {
+                    if (result != null && !result.equals(langCountry)) {
                         resultName = result;
                         hasCountry = false;
                         break;
@@ -330,7 +346,9 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
         }
 
         if (resultName == null) {
-            resultName = localeIdName(lang)
+            String result = localeIdName(lang);
+            if (result == null) { return null; }
+            resultName = result
                     .replace(formatOpenParen, formatReplaceOpenParen)
                     .replace(formatCloseParen, formatReplaceCloseParen);
         }
@@ -338,17 +356,23 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
         StringBuilder buf = new StringBuilder();
         if (hasScript) {
             // first element, don't need appendWithSep
-            buf.append(scriptDisplayNameInContext(script, true)
+            String result = scriptDisplayNameInContext(script, true);
+            if (result == null) { return null; }
+            buf.append(result
                     .replace(formatOpenParen, formatReplaceOpenParen)
                     .replace(formatCloseParen, formatReplaceCloseParen));
         }
         if (hasCountry) {
-            appendWithSep(regionDisplayName(country, true)
+            String result = regionDisplayName(country, true);
+            if (result == null) { return null; }
+            appendWithSep(result
                     .replace(formatOpenParen, formatReplaceOpenParen)
                     .replace(formatCloseParen, formatReplaceCloseParen), buf);
         }
         if (hasVariant) {
-            appendWithSep(variantDisplayName(variant, true)
+            String result = variantDisplayName(variant, true);
+            if (result == null) { return null; }
+            appendWithSep(result
                     .replace(formatOpenParen, formatReplaceOpenParen)
                     .replace(formatCloseParen, formatReplaceCloseParen), buf);
         }
@@ -358,10 +382,14 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
             while (keys.hasNext()) {
                 String key = keys.next();
                 String value = locale.getKeywordValue(key);
-                String keyDisplayName = keyDisplayName(key, true)
+                String keyDisplayName = keyDisplayName(key, true);
+                if (keyDisplayName == null) { return null; }
+                keyDisplayName = keyDisplayName
                         .replace(formatOpenParen, formatReplaceOpenParen)
                         .replace(formatCloseParen, formatReplaceCloseParen);
-                String valueDisplayName = keyValueDisplayName(key, value, true)
+                String valueDisplayName = keyValueDisplayName(key, value, true);
+                if (valueDisplayName == null) { return null; }
+                valueDisplayName = valueDisplayName
                         .replace(formatOpenParen, formatReplaceOpenParen)
                         .replace(formatCloseParen, formatReplaceCloseParen);
                 if (!valueDisplayName.equals(value)) {
@@ -394,7 +422,7 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
     private String localeIdName(String localeId) {
         if (nameLength == DisplayContext.LENGTH_SHORT) {
             String locIdName = langData.get("Languages%short", localeId);
-            if (!locIdName.equals(localeId)) {
+            if (locIdName != null && !locIdName.equals(localeId)) {
                 return locIdName;
             }
         }
@@ -405,11 +433,11 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
     public String languageDisplayName(String lang) {
         // Special case to eliminate non-languages, which pollute our data.
         if (lang.equals("root") || lang.indexOf('_') != -1) {
-            return lang;
+            return substituteHandling == DisplayContext.SUBSTITUTE ? lang : null;
         }
         if (nameLength == DisplayContext.LENGTH_SHORT) {
             String langName = langData.get("Languages%short", lang);
-            if (!langName.equals(lang)) {
+            if (langName != null && !langName.equals(lang)) {
                 return adjustForUsageAndContext(CapitalizationContextUsage.LANGUAGE, langName);
             }
         }
@@ -419,10 +447,10 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
     @Override
     public String scriptDisplayName(String script) {
         String str = langData.get("Scripts%stand-alone", script);
-        if (str.equals(script)) {
+        if (str == null || str.equals(script)) {
             if (nameLength == DisplayContext.LENGTH_SHORT) {
                 str = langData.get("Scripts%short", script);
-                if (!str.equals(script)) {
+                if (str != null && !str.equals(script)) {
                     return adjustForUsageAndContext(CapitalizationContextUsage.SCRIPT, str);
                 }
             }
@@ -434,7 +462,7 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
     private String scriptDisplayNameInContext(String script, boolean skipAdjust) {
         if (nameLength == DisplayContext.LENGTH_SHORT) {
             String scriptName = langData.get("Scripts%short", script);
-            if (!scriptName.equals(script)) {
+            if (scriptName != null && !scriptName.equals(script)) {
                 return skipAdjust? scriptName: adjustForUsageAndContext(CapitalizationContextUsage.SCRIPT, scriptName);
             }
         }
@@ -455,7 +483,7 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
     private String regionDisplayName(String region, boolean skipAdjust) {
         if (nameLength == DisplayContext.LENGTH_SHORT) {
             String regionName = regionData.get("Countries%short", region);
-            if (!regionName.equals(region)) {
+            if (regionName != null && !regionName.equals(region)) {
                 return skipAdjust? regionName: adjustForUsageAndContext(CapitalizationContextUsage.TERRITORY, regionName);
             }
         }
@@ -501,7 +529,7 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
         } else {
             if (nameLength == DisplayContext.LENGTH_SHORT) {
                 String tmp = langData.get("Types%short", key, value);
-                if (!tmp.equals(value)) {
+                if (tmp != null && !tmp.equals(value)) {
                     keyValueName = tmp;
                 }
             }
@@ -581,6 +609,12 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
     }
 
     public static class DataTable {
+        final boolean nullIfNotFound;
+
+        DataTable(boolean nullIfNotFound) {
+            this.nullIfNotFound = nullIfNotFound;
+        }
+
         ULocale getLocale() {
             return ULocale.ROOT;
         }
@@ -590,38 +624,41 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
         }
 
         String get(String tableName, String subTableName, String code) {
-            return code;
+            return nullIfNotFound ? null : code;
         }
     }
 
     static class ICUDataTable extends DataTable {
         private final ICUResourceBundle bundle;
 
-        public ICUDataTable(String path, ULocale locale) {
+        public ICUDataTable(String path, ULocale locale, boolean nullIfNotFound) {
+            super(nullIfNotFound);
             this.bundle = (ICUResourceBundle) UResourceBundle.getBundleInstance(
                     path, locale.getBaseName());
         }
 
+        @Override
         public ULocale getLocale() {
             return bundle.getULocale();
         }
 
+        @Override
         public String get(String tableName, String subTableName, String code) {
             return ICUResourceTableAccess.getTableString(bundle, tableName, subTableName,
-                    code);
+                    code, nullIfNotFound ? null : code);
         }
     }
 
     static abstract class DataTables {
-        public abstract DataTable get(ULocale locale);
+        public abstract DataTable get(ULocale locale, boolean nullIfNotFound);
         public static DataTables load(String className) {
             try {
                 return (DataTables) Class.forName(className).newInstance();
             } catch (Throwable t) {
-                final DataTable NO_OP = new DataTable();
                 return new DataTables() {
-                    public DataTable get(ULocale locale) {
-                        return NO_OP;
+                    @Override
+                    public DataTable get(ULocale locale, boolean nullIfNotFound) {
+                        return new DataTable(nullIfNotFound);
                     }
                 };
             }
@@ -636,8 +673,8 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
         }
 
         @Override
-        public DataTable get(ULocale locale) {
-            return new ICUDataTable(path, locale);
+        public DataTable get(ULocale locale, boolean nullIfNotFound) {
+            return new ICUDataTable(path, locale, nullIfNotFound);
         }
     }
 
@@ -676,14 +713,17 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
         private DialectHandling dialectHandling;
         private DisplayContext capitalization;
         private DisplayContext nameLength;
+        private DisplayContext substituteHandling;
         private LocaleDisplayNames cache;
         public LocaleDisplayNames get(ULocale locale, DialectHandling dialectHandling) {
             if (!(dialectHandling == this.dialectHandling && DisplayContext.CAPITALIZATION_NONE == this.capitalization &&
-                    DisplayContext.LENGTH_FULL == this.nameLength && locale.equals(this.locale))) {
+                    DisplayContext.LENGTH_FULL == this.nameLength && DisplayContext.SUBSTITUTE == this.substituteHandling &&
+                    locale.equals(this.locale))) {
                 this.locale = locale;
                 this.dialectHandling = dialectHandling;
                 this.capitalization = DisplayContext.CAPITALIZATION_NONE;
                 this.nameLength = DisplayContext.LENGTH_FULL;
+                this.substituteHandling = DisplayContext.SUBSTITUTE;
                 this.cache = new LocaleDisplayNamesImpl(locale, dialectHandling);
             }
             return cache;
@@ -692,6 +732,7 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
             DialectHandling dialectHandlingIn = DialectHandling.STANDARD_NAMES;
             DisplayContext capitalizationIn = DisplayContext.CAPITALIZATION_NONE;
             DisplayContext nameLengthIn = DisplayContext.LENGTH_FULL;
+            DisplayContext substituteHandling = DisplayContext.SUBSTITUTE;
             for (DisplayContext contextItem : contexts) {
                 switch (contextItem.type()) {
                 case DIALECT_HANDLING:
@@ -704,16 +745,21 @@ public class LocaleDisplayNamesImpl extends LocaleDisplayNames {
                 case DISPLAY_LENGTH:
                     nameLengthIn = contextItem;
                     break;
+                case SUBSTITUTE_HANDLING:
+                    substituteHandling = contextItem;
+                    break;
                 default:
                     break;
                 }
             }
             if (!(dialectHandlingIn == this.dialectHandling && capitalizationIn == this.capitalization &&
-                    nameLengthIn == this.nameLength && locale.equals(this.locale))) {
+                    nameLengthIn == this.nameLength && substituteHandling == this.substituteHandling &&
+                    locale.equals(this.locale))) {
                 this.locale = locale;
                 this.dialectHandling = dialectHandlingIn;
                 this.capitalization = capitalizationIn;
                 this.nameLength = nameLengthIn;
+                this.substituteHandling = substituteHandling;
                 this.cache = new LocaleDisplayNamesImpl(locale, contexts);
             }
             return cache;
diff --git a/app/src/main/java/com/ibm/icu/impl/LocaleIDParser.java b/icu4j/src/main/java/com/ibm/icu/impl/LocaleIDParser.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/LocaleIDParser.java
rename to icu4j/src/main/java/com/ibm/icu/impl/LocaleIDParser.java
index c3b36e5..3d1144f 100644
--- a/app/src/main/java/com/ibm/icu/impl/LocaleIDParser.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/LocaleIDParser.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2003-2011, International Business Machines Corporation and   *
@@ -19,22 +21,22 @@ import com.ibm.icu.impl.locale.AsciiUtil;
  * Utility class to parse and normalize locale ids (including POSIX style)
  */
 public final class LocaleIDParser {
-    
+
     /**
      * Char array representing the locale ID.
      */
     private char[] id;
-    
+
     /**
      * Current position in {@link #id} (while parsing).
      */
     private int index;
-    
+
     /**
      * Temporary buffer for parsed sections of data.
      */
     private StringBuilder buffer;
-    
+
     // um, don't handle POSIX ids unless we request it.  why not?  well... because.
     private boolean canonicalize;
     private boolean hadCountry;
@@ -71,14 +73,14 @@ public final class LocaleIDParser {
     }
 
     // utilities for working on text in the buffer
-    
+
     /**
      * Append c to the buffer.
      */
     private void append(char c) {
         buffer.append(c);
     }
-    
+
     private void addSeparator() {
         append(UNDERSCORE);
     }
@@ -192,7 +194,7 @@ public final class LocaleIDParser {
      */
     private int parseLanguage() {
         int startLength = buffer.length();
-        
+
         if (haveExperimentalLanguagePrefix()) {
             append(AsciiUtil.toLower(id[0]));
             append(HYPHEN);
@@ -278,7 +280,7 @@ public final class LocaleIDParser {
         if (!atTerminator()) {
             int oldIndex = index;
             ++index;
-            
+
             char c;
             while (!isTerminatorOrIDSeparator(c = next()) && AsciiUtil.isAlpha(c));
             --index;
@@ -395,7 +397,7 @@ public final class LocaleIDParser {
         boolean skipping = false;
         char c;
         boolean firstPass = true;
-        
+
         while ((c = next()) != DONE) {
             if (c == DOT) {
                 start = false;
@@ -589,6 +591,7 @@ public final class LocaleIDParser {
 
     private Comparator<String> getKeyComparator() {
         final Comparator<String> comp = new Comparator<String>() {
+            @Override
             public int compare(String lhs, String rhs) {
                 return lhs.compareTo(rhs);
             }
diff --git a/app/src/main/java/com/ibm/icu/impl/LocaleIDs.java b/icu4j/src/main/java/com/ibm/icu/impl/LocaleIDs.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/LocaleIDs.java
rename to icu4j/src/main/java/com/ibm/icu/impl/LocaleIDs.java
index 3167d79..b4f608d 100644
--- a/app/src/main/java/com/ibm/icu/impl/LocaleIDs.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/LocaleIDs.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2013, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/impl/LocaleUtility.java b/icu4j/src/main/java/com/ibm/icu/impl/LocaleUtility.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/LocaleUtility.java
rename to icu4j/src/main/java/com/ibm/icu/impl/LocaleUtility.java
index 0633738..3fe28bf 100644
--- a/app/src/main/java/com/ibm/icu/impl/LocaleUtility.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/LocaleUtility.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ******************************************************************************
  * Copyright (C) 1996-2007, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/impl/MultiComparator.java b/icu4j/src/main/java/com/ibm/icu/impl/MultiComparator.java
similarity index 100%
rename from app/src/main/java/com/ibm/icu/impl/MultiComparator.java
rename to icu4j/src/main/java/com/ibm/icu/impl/MultiComparator.java
diff --git a/app/src/main/java/com/ibm/icu/impl/Norm2AllModes.java b/icu4j/src/main/java/com/ibm/icu/impl/Norm2AllModes.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/impl/Norm2AllModes.java
rename to icu4j/src/main/java/com/ibm/icu/impl/Norm2AllModes.java
index cc3ee52..a3ac7a3 100644
--- a/app/src/main/java/com/ibm/icu/impl/Norm2AllModes.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/Norm2AllModes.java
@@ -1,6 +1,8 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- *   Copyright (C) 2009-2014, International Business Machines
+ *   Copyright (C) 2009-2016, International Business Machines
  *   Corporation and others.  All Rights Reserved.
  *******************************************************************************
  */
@@ -155,9 +157,7 @@ public final class Norm2AllModes {
             return isNormalized(s) ? Normalizer.YES : Normalizer.NO;
         }
 
-        public int getQuickCheck(int c) {
-            return 1;
-        }
+        public abstract int getQuickCheck(int c);
 
         public final Normalizer2Impl impl;
     }
@@ -342,6 +342,7 @@ public final class Norm2AllModes {
     }
     private static CacheBase<String, Norm2AllModes, ByteBuffer> cache =
         new SoftCache<String, Norm2AllModes, ByteBuffer>() {
+            @Override
             protected Norm2AllModes createInstance(String key, ByteBuffer bytes) {
                 Normalizer2Impl impl;
                 if(bytes==null) {
diff --git a/app/src/main/java/com/ibm/icu/impl/Normalizer2Impl.java b/icu4j/src/main/java/com/ibm/icu/impl/Normalizer2Impl.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/Normalizer2Impl.java
rename to icu4j/src/main/java/com/ibm/icu/impl/Normalizer2Impl.java
index d1af978..86a0247 100644
--- a/app/src/main/java/com/ibm/icu/impl/Normalizer2Impl.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/Normalizer2Impl.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  *   Copyright (C) 2009-2015, International Business Machines
@@ -204,6 +206,7 @@ public final class Normalizer2Impl {
         // They assume that the cc or trailCC of their input is 0.
         // Most of them implement Appendable interface methods.
         // @Override when we switch to Java 6
+        @Override
         public ReorderingBuffer append(char c) {
             str.append(c);
             lastCC=0;
@@ -216,6 +219,7 @@ public final class Normalizer2Impl {
             reorderStart=str.length();
         }
         // @Override when we switch to Java 6
+        @Override
         public ReorderingBuffer append(CharSequence s) {
             if(s.length()!=0) {
                 str.append(s);
@@ -225,6 +229,7 @@ public final class Normalizer2Impl {
             return this;
         }
         // @Override when we switch to Java 6
+        @Override
         public ReorderingBuffer append(CharSequence s, int start, int limit) {
             if(start!=limit) {
                 str.append(s, start, limit);
@@ -411,6 +416,7 @@ public final class Normalizer2Impl {
 
     private static final class IsAcceptable implements ICUBinary.Authenticate {
         // @Override when we switch to Java 6
+        @Override
         public boolean isDataVersionAcceptable(byte version[]) {
             return version[0]==2;
         }
@@ -558,6 +564,7 @@ public final class Normalizer2Impl {
         }
     }
     private static final Trie2.ValueMapper segmentStarterMapper=new Trie2.ValueMapper() {
+        @Override
         public int map(int in) {
             return in&CANON_NOT_SEGMENT_STARTER;
         }
@@ -1827,7 +1834,7 @@ public final class Normalizer2Impl {
             }
             if(key1==(firstUnit&COMP_1_TRAIL_MASK)) {
                 if((firstUnit&COMP_1_TRIPLE)!=0) {
-                    return ((int)compositions.charAt(list+1)<<16)|compositions.charAt(list+2);
+                    return (compositions.charAt(list+1)<<16)|compositions.charAt(list+2);
                 } else {
                     return compositions.charAt(list+1);
                 }
@@ -1872,7 +1879,7 @@ public final class Normalizer2Impl {
                 compositeAndFwd=maybeYesCompositions.charAt(list+1);
                 list+=2;
             } else {
-                compositeAndFwd=(((int)maybeYesCompositions.charAt(list+1)&~COMP_2_TRAIL_MASK)<<16)|
+                compositeAndFwd=((maybeYesCompositions.charAt(list+1)&~COMP_2_TRAIL_MASK)<<16)|
                                 maybeYesCompositions.charAt(list+2);
                 list+=3;
             }
diff --git a/app/src/main/java/com/ibm/icu/impl/OlsonTimeZone.java b/icu4j/src/main/java/com/ibm/icu/impl/OlsonTimeZone.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/OlsonTimeZone.java
rename to icu4j/src/main/java/com/ibm/icu/impl/OlsonTimeZone.java
index 8c5a0e8..44e9787 100644
--- a/app/src/main/java/com/ibm/icu/impl/OlsonTimeZone.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/OlsonTimeZone.java
@@ -1,7 +1,9 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
  /*
   *******************************************************************************
-  * Copyright (C) 2005-2014, International Business Machines Corporation and    *
-  * others. All Rights Reserved.                                                *
+  * Copyright (C) 2005-2016, International Business Machines Corporation and
+  * others. All Rights Reserved.
   *******************************************************************************
   */
 package com.ibm.icu.impl;
@@ -43,52 +45,52 @@ import com.ibm.icu.util.UResourceBundle;
  *
  *   a. Zone (table).  A zone is a table resource contains several
  *   type of resources below:
- *  
+ *
  *   - typeOffsets:intvector (Required)
- *  
+ *
  *   Sets of UTC raw/dst offset pairs in seconds.  Entries at
  *   2n represents raw offset and 2n+1 represents dst offset
  *   paired with the raw offset at 2n.  The very first pair represents
  *   the initial zone offset (before the first transition) always.
  *
- *   - trans:intvector (Optional) 
- *  
+ *   - trans:intvector (Optional)
+ *
  *   List of transition times represented by 32bit seconds from the
  *   epoch (1970-01-01T00:00Z) in ascending order.
- *  
+ *
  *   - transPre32/transPost32:intvector (Optional)
- *  
+ *
  *   List of transition times before/after 32bit minimum seconds.
  *   Each time is represented by a pair of 32bit integer.
- * 
+ *
  *   - typeMap:bin (Optional)
- *  
+ *
  *   Array of bytes representing the mapping between each transition
  *   time (transPre32/trans/transPost32) and its corresponding offset
  *   data (typeOffsets).
- *  
+ *
  *   - finalRule:string (Optional)
- *  
+ *
  *   If a recurrent transition rule is applicable to a zone forever
  *   after the final transition time, finalRule represents the rule
  *   in Rules data.
- *  
+ *
  *   - finalRaw:int (Optional)
- *   
+ *
  *   When finalRule is available, finalRaw is required and specifies
  *   the raw (base) offset of the rule.
- *   
+ *
  *   - finalYear:int (Optional)
- *   
+ *
  *   When finalRule is available, finalYear is required and specifies
  *   the start year of the rule.
- *   
+ *
  *   - links:intvector (Optional)
- *   
+ *
  *   When this zone data is shared with other zones, links specifies
  *   all zones including the zone itself.  Each zone is referenced by
  *   integer index.
- * 
+ *
  *  b. Link (int, length 1).  A link zone is an int resource.  The
  *  integer is the zone number of the target zone.  The key of this
  *  resource is an alternate name for the target zone.  This data
@@ -315,8 +317,8 @@ public class OlsonTimeZone extends BasicTimeZone {
         int[] fields = Grego.timeToFields(current, null);
 
         // Find start of this year, and start of next year
-        long start = Grego.fieldsToDay(fields[0], 0, 1) * SECONDS_PER_DAY;    
-        long limit = Grego.fieldsToDay(fields[0] + 1, 0, 1) * SECONDS_PER_DAY;    
+        long start = Grego.fieldsToDay(fields[0], 0, 1) * SECONDS_PER_DAY;
+        long limit = Grego.fieldsToDay(fields[0] + 1, 0, 1) * SECONDS_PER_DAY;
 
         // Return TRUE if DST is observed at any time during the current
         // year.
@@ -483,7 +485,7 @@ public class OlsonTimeZone extends BasicTimeZone {
     }
 
     private void construct(UResourceBundle top, UResourceBundle res){
-        
+
         if ((top == null || res == null)) {
             throw new IllegalArgumentException();
         }
@@ -535,21 +537,21 @@ public class OlsonTimeZone extends BasicTimeZone {
             int idx = 0;
             if (transPre32 != null) {
                 for (int i = 0; i < transPre32.length / 2; i++, idx++) {
-                    transitionTimes64[idx] = 
-                        (((long)transPre32[i * 2]) & 0x00000000FFFFFFFFL) << 32
-                        | (((long)transPre32[i * 2 + 1]) & 0x00000000FFFFFFFFL);
+                    transitionTimes64[idx] =
+                        ((transPre32[i * 2]) & 0x00000000FFFFFFFFL) << 32
+                        | ((transPre32[i * 2 + 1]) & 0x00000000FFFFFFFFL);
                 }
             }
             if (trans32 != null) {
                 for (int i = 0; i < trans32.length; i++, idx++) {
-                    transitionTimes64[idx] = (long)trans32[i];
+                    transitionTimes64[idx] = trans32[i];
                 }
             }
             if (transPost32 != null) {
                 for (int i = 0; i < transPost32.length / 2; i++, idx++) {
-                    transitionTimes64[idx] = 
-                        (((long)transPost32[i * 2]) & 0x00000000FFFFFFFFL) << 32
-                        | (((long)transPost32[i * 2 + 1]) & 0x00000000FFFFFFFFL);
+                    transitionTimes64[idx] =
+                        ((transPost32[i * 2]) & 0x00000000FFFFFFFFL) << 32
+                        | ((transPost32[i * 2 + 1]) & 0x00000000FFFFFFFFL);
                 }
             }
         } else {
@@ -568,7 +570,7 @@ public class OlsonTimeZone extends BasicTimeZone {
         if (transitionCount > 0) {
             r = res.get("typeMap");
             typeMapData = r.getBinary(null);
-            if (typeMapData.length != transitionCount) {
+            if (typeMapData == null || typeMapData.length != transitionCount) {
                 throw new IllegalArgumentException("Invalid Format");
             }
         } else {
@@ -605,7 +607,7 @@ public class OlsonTimeZone extends BasicTimeZone {
             finalStartYear = r.getInt();
 
             // Note: Setting finalStartYear to the finalZone is problematic.  When a date is around
-            // year boundary, SimpleTimeZone may return false result when DST is observed at the 
+            // year boundary, SimpleTimeZone may return false result when DST is observed at the
             // beginning of year.  We could apply safe margin (day or two), but when one of recurrent
             // rules falls around year boundary, it could return false result.  Without setting the
             // start year, finalZone works fine around the year boundary of the start year.
@@ -633,7 +635,7 @@ public class OlsonTimeZone extends BasicTimeZone {
     // This constructor is used for testing purpose only
     public OlsonTimeZone(String id){
         super(id);
-        UResourceBundle top = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME,
+        UResourceBundle top = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME,
                 ZONEINFORES, ICUResourceBundle.ICU_DATA_CLASS_LOADER);
         UResourceBundle res = ZoneMeta.openOlsonResource(top, id);
         construct(top, res);
@@ -745,7 +747,7 @@ public class OlsonTimeZone extends BasicTimeZone {
     }
 
     private int getInt(byte val){
-        return val & 0xFF; 
+        return val & 0xFF;
     }
 
     /*
@@ -825,7 +827,7 @@ public class OlsonTimeZone extends BasicTimeZone {
         buf.append(",finalStartMillis=" + finalStartMillis);
         buf.append(",finalZone=" + finalZone);
         buf.append(']');
-        
+
         return buf.toString();
     }
 
@@ -872,7 +874,7 @@ public class OlsonTimeZone extends BasicTimeZone {
      * If and only if finalYear == INT32_MAX then finalZone == 0.
      */
     private SimpleTimeZone finalZone = null; // owned, may be NULL
- 
+
     /**
      * The canonical ID of this zone. Initialized when {@link #getCanonicalID()}
      * is invoked first time, or {@link #setID(String)} is called.
@@ -883,7 +885,7 @@ public class OlsonTimeZone extends BasicTimeZone {
 
     private static final boolean DEBUG = ICUDebug.enabled("olson");
     private static final int SECONDS_PER_DAY = 24*60*60;
-    
+
     private static UResourceBundle loadRule(UResourceBundle top, String ruleid) {
         UResourceBundle r = top.get("Rules");
         r = r.get(ruleid);
@@ -917,9 +919,9 @@ public class OlsonTimeZone extends BasicTimeZone {
     public int hashCode(){
         int ret =   (int)  (finalStartYear ^ (finalStartYear>>>4) +
                    transitionCount ^ (transitionCount>>>6) +
-                   typeCount ^ (typeCount>>>8) + 
+                   typeCount ^ (typeCount>>>8) +
                    Double.doubleToLongBits(finalStartMillis)+
-                   (finalZone == null ? 0 : finalZone.hashCode()) + 
+                   (finalZone == null ? 0 : finalZone.hashCode()) +
                    super.hashCode());
         if (transitionTimes64 != null) {
             for(int i=0; i<transitionTimes64.length; i++){
@@ -932,7 +934,7 @@ public class OlsonTimeZone extends BasicTimeZone {
         if (typeMapData != null) {
             for(int i=0; i<typeMapData.length; i++){
                 ret+=typeMapData[i] & 0xFF;
-            } 
+            }
         }
         return ret;
     }
@@ -1008,7 +1010,7 @@ public class OlsonTimeZone extends BasicTimeZone {
                     return finalZoneWithStartYear.getPreviousTransition(base, inclusive);
                 } else {
                     return firstFinalTZTransition;
-                }                
+                }
             }
         }
 
@@ -1089,7 +1091,7 @@ public class OlsonTimeZone extends BasicTimeZone {
             } else {
                 // Create a TimeArrayTimeZoneRule at finalMillis
                 rules[idx++] = new TimeArrayTimeZoneRule(getID() + "(STD)", finalZone.getRawOffset(), 0,
-                        new long[] {(long)finalStartMillis}, DateTimeRule.UTC_TIME);                
+                        new long[] {(long)finalStartMillis}, DateTimeRule.UTC_TIME);
             }
         }
         return rules;
@@ -1173,7 +1175,7 @@ public class OlsonTimeZone extends BasicTimeZone {
                 typeIdx = getInt(typeMapData[firstTZTransitionIdx]);
                 firstTZTransition = new TimeZoneTransition(transitionTimes64[firstTZTransitionIdx] * Grego.MILLIS_PER_SECOND,
                         initialRule, historicRules[typeIdx]);
-                
+
             }
         }
 
@@ -1238,7 +1240,7 @@ public class OlsonTimeZone extends BasicTimeZone {
             String tzid = getID();
             if (tzid != null) {
                 try {
-                    UResourceBundle top = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME,
+                    UResourceBundle top = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME,
                             ZONEINFORES, ICUResourceBundle.ICU_DATA_CLASS_LOADER);
                     UResourceBundle res = ZoneMeta.openOlsonResource(top, tzid);
                     construct(top, res);
@@ -1246,7 +1248,7 @@ public class OlsonTimeZone extends BasicTimeZone {
                         finalZone.setID(tzid);
                     }
                     initialized = true;
-                } catch (Exception e) {
+                } catch (Exception ignored) {
                     // throw away
                 }
             }
@@ -1266,6 +1268,7 @@ public class OlsonTimeZone extends BasicTimeZone {
     /* (non-Javadoc)
      * @see com.ibm.icu.util.TimeZone#isFrozen()
      */
+    @Override
     public boolean isFrozen() {
         return isFrozen;
     }
@@ -1273,6 +1276,7 @@ public class OlsonTimeZone extends BasicTimeZone {
     /* (non-Javadoc)
      * @see com.ibm.icu.util.TimeZone#freeze()
      */
+    @Override
     public TimeZone freeze() {
         isFrozen = true;
         return this;
@@ -1281,6 +1285,7 @@ public class OlsonTimeZone extends BasicTimeZone {
     /* (non-Javadoc)
      * @see com.ibm.icu.util.TimeZone#cloneAsThawed()
      */
+    @Override
     public TimeZone cloneAsThawed() {
         OlsonTimeZone tz = (OlsonTimeZone)super.cloneAsThawed();
         if (finalZone != null) {
diff --git a/app/src/main/java/com/ibm/icu/impl/PVecToTrieCompactHandler.java b/icu4j/src/main/java/com/ibm/icu/impl/PVecToTrieCompactHandler.java
similarity index 86%
rename from app/src/main/java/com/ibm/icu/impl/PVecToTrieCompactHandler.java
rename to icu4j/src/main/java/com/ibm/icu/impl/PVecToTrieCompactHandler.java
index 3fb6049..1050c00 100644
--- a/app/src/main/java/com/ibm/icu/impl/PVecToTrieCompactHandler.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/PVecToTrieCompactHandler.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ******************************************************************************
  * Copyright (C) 1996-2009, International Business Machines Corporation and   *
@@ -17,17 +19,21 @@ public class PVecToTrieCompactHandler implements CompactHandler {
     public IntTrieBuilder builder;
     public int initialValue;
 
+    @Override
     public void setRowIndexForErrorValue(int rowIndex) {
     }
 
+    @Override
     public void setRowIndexForInitialValue(int rowIndex) {
         initialValue = rowIndex;
     }
 
+    @Override
     public void setRowIndexForRange(int start, int end, int rowIndex) {
         builder.setRange(start, end + 1, rowIndex, true);
     }
 
+    @Override
     public void startRealValues(int rowIndex) {
         if (rowIndex > 0xffff) {
             // too many rows for a 16-bit trie
@@ -35,6 +41,6 @@ public class PVecToTrieCompactHandler implements CompactHandler {
         } else {
             builder = new IntTrieBuilder(null, 100000, initialValue,
                     initialValue, false);
-        } 
+        }
     }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/Pair.java b/icu4j/src/main/java/com/ibm/icu/impl/Pair.java
similarity index 92%
rename from app/src/main/java/com/ibm/icu/impl/Pair.java
rename to icu4j/src/main/java/com/ibm/icu/impl/Pair.java
index 1b79d10..882f7c2 100644
--- a/app/src/main/java/com/ibm/icu/impl/Pair.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/Pair.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/impl/PatternProps.java b/icu4j/src/main/java/com/ibm/icu/impl/PatternProps.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/impl/PatternProps.java
rename to icu4j/src/main/java/com/ibm/icu/impl/PatternProps.java
index 7da0f4c..50aa5e8 100644
--- a/app/src/main/java/com/ibm/icu/impl/PatternProps.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/PatternProps.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 *   Copyright (C) 2011, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/PatternTokenizer.java b/icu4j/src/main/java/com/ibm/icu/impl/PatternTokenizer.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/PatternTokenizer.java
rename to icu4j/src/main/java/com/ibm/icu/impl/PatternTokenizer.java
index 3f576b5..849cb74 100644
--- a/app/src/main/java/com/ibm/icu/impl/PatternTokenizer.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/PatternTokenizer.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2006-2009, Google, International Business Machines Corporation *
diff --git a/app/src/main/java/com/ibm/icu/impl/PluralRulesLoader.java b/icu4j/src/main/java/com/ibm/icu/impl/PluralRulesLoader.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/impl/PluralRulesLoader.java
rename to icu4j/src/main/java/com/ibm/icu/impl/PluralRulesLoader.java
index f2097fc..8caff7c 100644
--- a/app/src/main/java/com/ibm/icu/impl/PluralRulesLoader.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/PluralRulesLoader.java
@@ -1,6 +1,8 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2008-2015, International Business Machines Corporation and
+ * Copyright (C) 2008-2016, International Business Machines Corporation and
  * others. All Rights Reserved.
  *******************************************************************************
  */
@@ -224,7 +226,7 @@ public class PluralRulesLoader extends PluralRules.Factory {
      */
     public UResourceBundle getPluralBundle() throws MissingResourceException {
         return ICUResourceBundle.getBundleInstance(
-                ICUResourceBundle.ICU_BASE_NAME, "plurals",
+                ICUData.ICU_BASE_NAME, "plurals",
                 ICUResourceBundle.ICU_DATA_CLASS_LOADER, true);
     }
 
diff --git a/app/src/main/java/com/ibm/icu/impl/PropsVectors.java b/icu4j/src/main/java/com/ibm/icu/impl/PropsVectors.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/PropsVectors.java
rename to icu4j/src/main/java/com/ibm/icu/impl/PropsVectors.java
index 9f8b676..0df6063 100644
--- a/app/src/main/java/com/ibm/icu/impl/PropsVectors.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/PropsVectors.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ******************************************************************************
  * Copyright (C) 1996-2011, International Business Machines Corporation and   *
@@ -7,9 +9,9 @@
 
 /**
  * Store bits (Unicode character properties) in bit set vectors.
- * 
+ *
  * This is a port of the C++ class UPropsVectors from ICU4C
- * 
+ *
  * @author Shaopeng Jia
  * @internal
  */
@@ -21,15 +23,15 @@ import java.util.Comparator;
 
 /**
  * Unicode Properties Vectors associated with code point ranges.
- * 
+ *
  * Rows of primitive integers in a contiguous array store the range limits and
  * the properties vectors.
- * 
+ *
  * In each row, row[0] contains the start code point and row[1] contains the
  * limit code point, which is the start of the next range.
- * 
+ *
  * Initially, there is only one range [0..0x110000] with values 0.
- * 
+ *
  * It would be possible to store only one range boundary per row, but
  * self-contained rows allow to later sort them by contents.
  */
@@ -43,10 +45,10 @@ public class PropsVectors {
     private boolean isCompacted;
 
     // internal function to compare elements in v and target. Return true iff
-    // elements in v starting from index1 to index1 + length - 1 
+    // elements in v starting from index1 to index1 + length - 1
     // are exactly the same as elements in target
     // starting from index2 to index2 + length - 1
-    private boolean areElementsSame(int index1, int[] target, int index2, 
+    private boolean areElementsSame(int index1, int[] target, int index2,
             int length) {
         for (int i = 0; i < length; ++i) {
             if (v[index1 + i] != target[index2 + i]) {
@@ -55,7 +57,7 @@ public class PropsVectors {
         }
         return true;
     }
-    
+
     // internal function which given rangeStart, returns
     // index where v[index]<=rangeStart<v[index+1].
     // The returned index is a multiple of columns, and therefore
@@ -163,11 +165,11 @@ public class PropsVectors {
     /*
      * In rows for code points [start..end], select the column, reset the mask
      * bits and set the value bits (ANDed with the mask).
-     * 
+     *
      * @throws IllegalArgumentException
-     * 
+     *
      * @throws IllegalStateException
-     * 
+     *
      * @throws IndexOutOfBoundsException
      */
     public void setValue(int start, int end, int column, int value, int mask) {
@@ -288,7 +290,7 @@ public class PropsVectors {
 
     /*
      * Returns an array which contains value elements
-     * in row rowIndex. 
+     * in row rowIndex.
      *
      * @throws IllegalStateException
      * @throws IllegalArgumentException
@@ -310,9 +312,9 @@ public class PropsVectors {
     /*
      * Returns an int which is the start codepoint
      * in row rowIndex.
-     * 
+     *
      * @throws IllegalStateException
-     * 
+     *
      * @throws IllegalArgumentException
      */
     public int getRowStart(int rowIndex) {
@@ -327,11 +329,11 @@ public class PropsVectors {
     }
 
     /*
-     * Returns an int which is the limit codepoint 
+     * Returns an int which is the limit codepoint
      * minus 1 in row rowIndex.
-     * 
+     *
      * @throws IllegalStateException
-     * 
+     *
      * @throws IllegalArgumentException
      */
     public int getRowEnd(int rowIndex) {
@@ -344,23 +346,23 @@ public class PropsVectors {
         }
         return v[rowIndex * columns + 1] - 1;
     }
-    
+
     /*
      * Compact the vectors:
      * - modify the memory
      * - keep only unique vectors
      * - store them contiguously from the beginning of the memory
-     * - for each (non-unique) row, call the respective function in 
+     * - for each (non-unique) row, call the respective function in
      *   CompactHandler
      *
      * The handler's rowIndex is the index of the row in the compacted
-     * memory block. Therefore, it starts at 0 increases in increments of the 
+     * memory block. Therefore, it starts at 0 increases in increments of the
      * columns value.
      *
      * In a first phase, only special values are delivered (each exactly once).
      * Then CompactHandler::startRealValues() is called
      * where rowIndex is the length of the compacted array.
-     * Then, in the second phase, the CompactHandler::setRowIndexForRange() is 
+     * Then, in the second phase, the CompactHandler::setRowIndexForRange() is
      * called for each row of real values.
      */
     public void compact(CompactHandler compactor) {
@@ -380,6 +382,7 @@ public class PropsVectors {
         }
 
         Arrays.sort(indexArray, new Comparator<Integer>() {
+            @Override
             public int compare(Integer o1, Integer o2) {
                 int indexOfRow1 = o1.intValue();
                 int indexOfRow2 = o2.intValue();
@@ -434,10 +437,10 @@ public class PropsVectors {
         compactor.startRealValues(count);
 
         /*
-         * Move vector contents up to a contiguous array with only unique 
+         * Move vector contents up to a contiguous array with only unique
          * vector values, and call the handler function for each vector.
-         * 
-         * This destroys the Properties Vector structure and replaces it 
+         *
+         * This destroys the Properties Vector structure and replaces it
          * with an array of just vector values.
          */
         int[] temp = new int[count];
@@ -448,7 +451,7 @@ public class PropsVectors {
 
             // count a new values vector if it is different
             // from the current one
-            if (count < 0 || !areElementsSame(indexArray[i].intValue() + 2, 
+            if (count < 0 || !areElementsSame(indexArray[i].intValue() + 2,
                     temp, count, valueColumns)) {
                 count += valueColumns;
                 System.arraycopy(v, indexArray[i].intValue() + 2, temp, count,
@@ -460,7 +463,7 @@ public class PropsVectors {
             }
         }
         v = temp;
-        
+
         // count is at the beginning of the last vector,
         // add one to include that last vector
         rows = count / valueColumns + 1;
@@ -468,7 +471,7 @@ public class PropsVectors {
 
     /*
      * Get the vectors array after calling compact().
-     * 
+     *
      * @throws IllegalStateException
      */
     public int[] getCompactedArray() {
@@ -481,7 +484,7 @@ public class PropsVectors {
 
     /*
      * Get the number of rows for the compacted array.
-     * 
+     *
      * @throws IllegalStateException
      */
     public int getCompactedRows() {
@@ -494,7 +497,7 @@ public class PropsVectors {
 
     /*
      * Get the number of columns for the compacted array.
-     * 
+     *
      * @throws IllegalStateException
      */
     public int getCompactedColumns() {
@@ -518,6 +521,7 @@ public class PropsVectors {
 
     // inner class implementation of Trie.DataManipulate
     private static class DefaultGetFoldingOffset implements Trie.DataManipulate {
+        @Override
         public int getFoldingOffset(int value) {
             return value;
         }
@@ -532,8 +536,9 @@ public class PropsVectors {
             builder = inBuilder;
         }
 
+        @Override
         public int getFoldedValue(int start, int offset) {
-            int initialValue = builder.m_initialValue_; 
+            int initialValue = builder.m_initialValue_;
             int limit = start + 0x400;
             while (start < limit) {
                 boolean[] inBlockZero = new boolean[1];
@@ -549,7 +554,7 @@ public class PropsVectors {
             return 0;
         }
     }
-    
+
     public static interface CompactHandler {
         public void setRowIndexForRange(int start, int end, int rowIndex);
         public void setRowIndexForInitialValue(int rowIndex);
diff --git a/app/src/main/java/com/ibm/icu/impl/Punycode.java b/icu4j/src/main/java/com/ibm/icu/impl/Punycode.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/Punycode.java
rename to icu4j/src/main/java/com/ibm/icu/impl/Punycode.java
index 410ece9..5cdcdb8 100644
--- a/app/src/main/java/com/ibm/icu/impl/Punycode.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/Punycode.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2003-2014, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/impl/Relation.java b/icu4j/src/main/java/com/ibm/icu/impl/Relation.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/impl/Relation.java
rename to icu4j/src/main/java/com/ibm/icu/impl/Relation.java
index b12446e..2f2f184 100644
--- a/app/src/main/java/com/ibm/icu/impl/Relation.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/Relation.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  **********************************************************************
  * Copyright (c) 2002-2015, International Business Machines
@@ -55,7 +57,7 @@ public class Relation<K, V> implements Freezable<Relation<K,V>> { // TODO: add ,
                 this.setCreator.newInstance(setComparatorParam); // check to make sure compiles
             } else {
                 this.setCreator = ((Class<? extends Set<V>>)setCreator).getConstructor(Comparator.class);
-                this.setCreator.newInstance(setComparatorParam); // check to make sure compiles        
+                this.setCreator.newInstance(setComparatorParam); // check to make sure compiles
             }
             data = map == null ? new HashMap<K, Set<V>>() : map;
         } catch (Exception e) {
@@ -83,11 +85,11 @@ public class Relation<K, V> implements Freezable<Relation<K,V>> { // TODO: add ,
     public final Set<Entry<K, V>> entrySet() {
         return keyValueSet();
     }
-    
+
     public Set<Entry<K, Set<V>>> keyValuesSet() {
         return data.entrySet();
     }
-    
+
     public Set<Entry<K, V>> keyValueSet() {
         Set<Entry<K, V>> result = new LinkedHashSet<Entry<K, V>>();
         for (K key : data.keySet()) {
@@ -98,6 +100,7 @@ public class Relation<K, V> implements Freezable<Relation<K,V>> { // TODO: add ,
         return result;
     }
 
+    @Override
     public boolean equals(Object o) {
         if (o == null)
             return false;
@@ -121,6 +124,7 @@ public class Relation<K, V> implements Freezable<Relation<K,V>> { // TODO: add ,
         return data.get(key);
     }
 
+    @Override
     public int hashCode() {
         return data.hashCode();
     }
@@ -161,15 +165,15 @@ public class Relation<K, V> implements Freezable<Relation<K,V>> { // TODO: add ,
 
     private Set<V> newSet() {
         try {
-            return (Set<V>) setCreator.newInstance(setComparatorParam);
+            return setCreator.newInstance(setComparatorParam);
         } catch (Exception e) {
             throw (RuntimeException) new IllegalArgumentException("Can't create new set").initCause(e);
         }
     }
 
     public void putAll(Map<? extends K, ? extends V> t) {
-        for (K key : t.keySet()) {
-            put(key, t.get(key));
+        for (Map.Entry<? extends K, ? extends V> entry : t.entrySet()) {
+            put(entry.getKey(), entry.getValue());
         }
     }
 
@@ -220,6 +224,7 @@ public class Relation<K, V> implements Freezable<Relation<K,V>> { // TODO: add ,
         return result;
     }
 
+    @Override
     public String toString() {
         return data.toString();
     }
@@ -239,14 +244,17 @@ public class Relation<K, V> implements Freezable<Relation<K,V>> { // TODO: add ,
             this.value = e.getValue();
         }
 
+        @Override
         public K getKey() {
             return key;
         }
 
+        @Override
         public V getValue() {
             return value;
         }
 
+        @Override
         public V setValue(V value) {
             V oldValue = this.value;
             this.value = value;
@@ -264,18 +272,20 @@ public class Relation<K, V> implements Freezable<Relation<K,V>> { // TODO: add ,
     }
 
     public Relation<K,V> addAllInverted(Map<V,K> source) {
-        for (V value : source.keySet()) {
-            put(source.get(value), value);
+        for (Map.Entry<V,K> entry : source.entrySet()) {
+            put(entry.getValue(), entry.getKey());
         }
         return this;
     }
 
     volatile boolean frozen = false;
 
+    @Override
     public boolean isFrozen() {
         return frozen;
     }
 
+    @Override
     public Relation<K, V> freeze() {
         if (!frozen) {
             // does not handle one level down, so we do that on a case-by-case basis
@@ -289,6 +299,7 @@ public class Relation<K, V> implements Freezable<Relation<K,V>> { // TODO: add ,
         return this;
     }
 
+    @Override
     public Relation<K, V> cloneAsThawed() {
         // TODO do later
         throw new UnsupportedOperationException();
@@ -335,4 +346,4 @@ public class Relation<K, V> implements Freezable<Relation<K,V>> { // TODO: add ,
         }
         return result;
     }
-}
\ No newline at end of file
+}
diff --git a/app/src/main/java/com/ibm/icu/impl/RelativeDateFormat.java b/icu4j/src/main/java/com/ibm/icu/impl/RelativeDateFormat.java
similarity index 77%
rename from app/src/main/java/com/ibm/icu/impl/RelativeDateFormat.java
rename to icu4j/src/main/java/com/ibm/icu/impl/RelativeDateFormat.java
index c2e7287..b564394 100644
--- a/app/src/main/java/com/ibm/icu/impl/RelativeDateFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/RelativeDateFormat.java
@@ -1,18 +1,19 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2007-2014, International Business Machines Corporation and    *
- * others. All Rights Reserved.                                                *
+ * Copyright (C) 2007-2016, International Business Machines Corporation and
+ * others. All Rights Reserved.
  *******************************************************************************
  */
 package com.ibm.icu.impl;
 
 import java.text.FieldPosition;
 import java.text.ParsePosition;
-import java.util.Comparator;
+import java.util.ArrayList;
 import java.util.Date;
+import java.util.List;
 import java.util.MissingResourceException;
-import java.util.Set;
-import java.util.TreeSet;
 
 import com.ibm.icu.lang.UCharacter;
 import com.ibm.icu.text.BreakIterator;
@@ -24,7 +25,6 @@ import com.ibm.icu.util.Calendar;
 import com.ibm.icu.util.TimeZone;
 import com.ibm.icu.util.ULocale;
 import com.ibm.icu.util.UResourceBundle;
-import com.ibm.icu.util.UResourceBundleIterator;
 
 /**
  * @author srl
@@ -49,7 +49,7 @@ public class RelativeDateFormat extends DateFormat {
     }
 
     // copy c'tor?
-    
+
     /**
      * @param timeStyle The time style for the date and time.
      * @param dateStyle The date style for the date and time.
@@ -104,6 +104,7 @@ public class RelativeDateFormat extends DateFormat {
     /* (non-Javadoc)
      * @see com.ibm.icu.text.DateFormat#format(com.ibm.icu.util.Calendar, java.lang.StringBuffer, java.text.FieldPosition)
      */
+    @Override
     public StringBuffer format(Calendar cal, StringBuffer toAppendTo,
             FieldPosition fieldPosition) {
 
@@ -181,6 +182,7 @@ public class RelativeDateFormat extends DateFormat {
     /* (non-Javadoc)
      * @see com.ibm.icu.text.DateFormat#parse(java.lang.String, com.ibm.icu.util.Calendar, java.text.ParsePosition)
      */
+    @Override
     public void parse(String text, Calendar cal, ParsePosition pos) {
         throw new UnsupportedOperationException("Relative Date parse is not implemented yet");
     }
@@ -188,8 +190,9 @@ public class RelativeDateFormat extends DateFormat {
     /* (non-Javadoc)
      * @see com.ibm.icu.text.DateFormat#setContext(com.ibm.icu.text.DisplayContext)
      * Here we override the DateFormat implementation in order to
-     * lazily initialize relevant items 
+     * lazily initialize relevant items
      */
+    @Override
     public void setContext(DisplayContext context) {
         super.setContext(context);
         if (!capitalizationInfoIsSet &&
@@ -207,7 +210,7 @@ public class RelativeDateFormat extends DateFormat {
     private DateFormat fDateFormat; // keep for serialization compatibility
     @SuppressWarnings("unused")
     private DateFormat fTimeFormat; // now unused, keep for serialization compatibility
-    private MessageFormat fCombinedFormat; //  the {0} {1} format. 
+    private MessageFormat fCombinedFormat; //  the {0} {1} format.
     private SimpleDateFormat fDateTimeFormat = null; // the held date/time formatter
     private String fDatePattern = null;
     private String fTimePattern = null;
@@ -215,69 +218,78 @@ public class RelativeDateFormat extends DateFormat {
     int fDateStyle;
     int fTimeStyle;
     ULocale  fLocale;
-    
-    private transient URelativeString fDates[] = null; // array of strings
-    
+
+    private transient List<URelativeString> fDates = null;
+
     private boolean combinedFormatHasDateAtStart = false;
     private boolean capitalizationInfoIsSet = false;
     private boolean capitalizationOfRelativeUnitsForListOrMenu = false;
     private boolean capitalizationOfRelativeUnitsForStandAlone = false;
     private transient BreakIterator capitalizationBrkIter = null;
-   
-    
+
     /**
      * Get the string at a specific offset.
-     * @param day day offset ( -1, 0, 1, etc.. )
+     * @param day day offset ( -1, 0, 1, etc.. ). Does not require sorting by offset.
      * @return the string, or NULL if none at that location.
      */
     private String getStringForDay(int day) {
         if(fDates == null) {
             loadDates();
         }
-        for(int i=0;i<fDates.length;i++) {
-            if(fDates[i].offset == day) {
-                return fDates[i].string;
+        for(URelativeString dayItem : fDates) {
+            if(dayItem.offset == day) {
+                return dayItem.string;
             }
         }
         return null;
     }
-    
-    /** 
-     * Load the Date string array
-     */
-    private synchronized void loadDates() {
-        ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, fLocale);
-        ICUResourceBundle rdb = rb.getWithFallback("fields/day/relative");
-        
-        Set<URelativeString> datesSet = new TreeSet<URelativeString>(new Comparator<URelativeString>() { 
-            public int compare(URelativeString r1, URelativeString r2) {
-                
-                if(r1.offset == r2.offset) {
-                    return 0;
-                } else if(r1.offset < r2.offset) {
-                    return -1;
-                } else {
-                    return 1;
+
+    // Sink to get "fields/day/relative".
+    private final class RelDateFmtDataSink extends UResource.Sink {
+
+        @Override
+        public void put(UResource.Key key, UResource.Value value, boolean noFallback) {
+            if (value.getType() == ICUResourceBundle.ALIAS) {
+                return;
+            }
+
+            UResource.Table table = value.getTable();
+            for (int i = 0; table.getKeyAndValue(i, key, value); ++i) {
+
+                int keyOffset;
+                try {
+                    keyOffset = Integer.parseInt(key.toString());
+                }
+                catch (NumberFormatException nfe) {
+                    // Flag the error?
+                    return;
+                }
+                // Check if already set.
+                if (getStringForDay(keyOffset) == null) {
+                    URelativeString newDayInfo = new URelativeString(keyOffset, value.getString());
+                    fDates.add(newDayInfo);
                 }
             }
-        }) ;
-        
-        for(UResourceBundleIterator i = rdb.getIterator();i.hasNext();) {
-            UResourceBundle line = i.next();
-            
-            String k = line.getKey();
-            String v = line.getString();
-            URelativeString rs = new URelativeString(k,v);
-            datesSet.add(rs);
         }
-        fDates = datesSet.toArray(new URelativeString[0]);
     }
-    
+
+    /**
+     * Load the Date string array
+     */
+    private synchronized void loadDates() {
+        ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, fLocale);
+
+        // Use sink mechanism to traverse data structure.
+        fDates = new ArrayList<URelativeString>();
+        RelDateFmtDataSink sink = new RelDateFmtDataSink();
+        rb.getAllItemsWithFallback("fields/day/relative", sink);
+    }
+
     /**
-     * Set capitalizationOfRelativeUnitsForListOrMenu, capitalizationOfRelativeUnitsForStandAlone 
+     * Set capitalizationOfRelativeUnitsForListOrMenu, capitalizationOfRelativeUnitsForStandAlone
      */
     private void initCapitalizationContextInfo(ULocale locale) {
-        ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, locale);
+        ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, locale);
         try {
             ICUResourceBundle rdb = rb.getWithFallback("contextTransforms/relative");
             int[] intVector = rdb.getIntVector();
@@ -301,7 +313,7 @@ public class RelativeDateFormat extends DateFormat {
         int dayDiff = until.get(Calendar.JULIAN_DAY) - nowCal.get(Calendar.JULIAN_DAY);
         return dayDiff;
     }
-    
+
     /**
      * initializes fCalendar from parameters.  Returns fCalendar as a convenience.
      * @param zone  Zone to be adopted, or NULL for TimeZone::createDefault().
@@ -321,40 +333,36 @@ public class RelativeDateFormat extends DateFormat {
     }
 
     private MessageFormat initializeCombinedFormat(Calendar cal, ULocale locale) {
-        String pattern = "{1} {0}";
-        try {
-            CalendarData calData = new CalendarData(locale, cal.getType());
-            String[] patterns = calData.getDateTimePatterns();
-            if (patterns != null && patterns.length >= 9) {
-                int glueIndex = 8;
-                if (patterns.length >= 13)
-                {
-                    switch (fDateStyle)
-                    {
-                        case DateFormat.RELATIVE_FULL:
-                        case DateFormat.FULL:
-                            glueIndex += (DateFormat.FULL + 1);
-                            break;
-                        case DateFormat.RELATIVE_LONG:
-                        case DateFormat.LONG:
-                            glueIndex += (DateFormat.LONG +1);
-                            break;
-                        case DateFormat.RELATIVE_MEDIUM:
-                        case DateFormat.MEDIUM:
-                            glueIndex += (DateFormat.MEDIUM +1);
-                            break;
-                        case DateFormat.RELATIVE_SHORT:
-                        case DateFormat.SHORT:
-                            glueIndex += (DateFormat.SHORT + 1);
-                            break;
-                        default:
-                            break;
-                    }
-                }
-                pattern = patterns[glueIndex];
+        String pattern;
+        ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(
+            ICUData.ICU_BASE_NAME, locale);
+        String resourcePath = "calendar/" + cal.getType() + "/DateTimePatterns";
+        ICUResourceBundle patternsRb= rb.findWithFallback(resourcePath);
+        if (patternsRb == null && !cal.getType().equals("gregorian")) {
+            // Try again with gregorian, if not already attempted.
+            patternsRb = rb.findWithFallback("calendar/gregorian/DateTimePatterns");
+        }
+
+        if (patternsRb == null || patternsRb.getSize() < 9) {
+            // Undefined or too few elements.
+            pattern = "{1} {0}";
+        } else {
+            int glueIndex = 8;
+            if (patternsRb.getSize() >= 13) {
+              if (fDateStyle >= DateFormat.FULL && fDateStyle <= DateFormat.SHORT) {
+                  glueIndex += fDateStyle + 1;
+              } else
+                  if (fDateStyle >= DateFormat.RELATIVE_FULL &&
+                      fDateStyle <= DateFormat.RELATIVE_SHORT) {
+                      glueIndex += fDateStyle + 1 - DateFormat.RELATIVE;
+                  }
+            }
+            int elementType = patternsRb.get(glueIndex).getType();
+            if (elementType == UResourceBundle.ARRAY) {
+                pattern = patternsRb.get(glueIndex).getString(0);
+            } else {
+                pattern = patternsRb.getString(glueIndex);
             }
-        } catch (MissingResourceException e) {
-            // use default
         }
         combinedFormatHasDateAtStart = pattern.startsWith("{1}");
         fCombinedFormat = new MessageFormat(pattern, locale);
diff --git a/app/src/main/java/com/ibm/icu/impl/ReplaceableUCharacterIterator.java b/icu4j/src/main/java/com/ibm/icu/impl/ReplaceableUCharacterIterator.java
similarity index 89%
rename from app/src/main/java/com/ibm/icu/impl/ReplaceableUCharacterIterator.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ReplaceableUCharacterIterator.java
index acc0a99..aa914e0 100644
--- a/app/src/main/java/com/ibm/icu/impl/ReplaceableUCharacterIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ReplaceableUCharacterIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2015, International Business Machines Corporation and
@@ -24,7 +26,7 @@ import com.ibm.icu.text.UTF16;
 public class ReplaceableUCharacterIterator extends UCharacterIterator {
 
     // public constructor ------------------------------------------------------
-    
+
     /**
      * Public constructor
      * @param replaceable text which the iterator will be based on
@@ -36,7 +38,7 @@ public class ReplaceableUCharacterIterator extends UCharacterIterator {
         this.replaceable  = replaceable;
         this.currentIndex = 0;
     }
-    
+
     /**
      * Public constructor
      * @param str text which the iterator will be based on
@@ -48,7 +50,7 @@ public class ReplaceableUCharacterIterator extends UCharacterIterator {
         this.replaceable  = new ReplaceableString(str);
         this.currentIndex = 0;
     }
-    
+
     /**
      * Public constructor
      * @param buf buffer of text on which the iterator will be based
@@ -60,14 +62,15 @@ public class ReplaceableUCharacterIterator extends UCharacterIterator {
         this.replaceable  = new ReplaceableString(buf);
         this.currentIndex = 0;
     }
-    
+
     // public methods ----------------------------------------------------------
-    
+
     /**
-     * Creates a copy of this iterator, does not clone the underlying 
+     * Creates a copy of this iterator, does not clone the underlying
      * <code>Replaceable</code>object
      * @return copy of this iterator
      */
+    @Override
     public Object clone(){
         try {
           return super.clone();
@@ -75,37 +78,39 @@ public class ReplaceableUCharacterIterator extends UCharacterIterator {
             return null; // never invoked
         }
     }
-    
+
     /**
      * Returns the current UTF16 character.
      * @return current UTF16 character
      */
+    @Override
     public int current(){
         if (currentIndex < replaceable.length()) {
             return replaceable.charAt(currentIndex);
         }
         return DONE;
     }
-    
+
     /**
      * Returns the current codepoint
      * @return current codepoint
      */
+    @Override
     public int currentCodePoint(){
-        // cannot use charAt due to it different 
+        // cannot use charAt due to it different
         // behaviour when index is pointing at a
         // trail surrogate, check for surrogates
-         
+
         int ch = current();
         if(UTF16.isLeadSurrogate((char)ch)){
             // advance the index to get the next code point
             next();
-            // due to post increment semantics current() after next() 
+            // due to post increment semantics current() after next()
             // actually returns the next char which is what we want
             int ch2 = current();
             // current should never change the current index so back off
             previous();
-            
+
             if(UTF16.isTrailSurrogate((char)ch2)){
                 // we found a surrogate pair
                 return Character.toCodePoint((char)ch, (char)ch2);
@@ -113,47 +118,51 @@ public class ReplaceableUCharacterIterator extends UCharacterIterator {
         }
         return ch;
     }
-    
+
     /**
      * Returns the length of the text
      * @return length of the text
      */
+    @Override
     public int getLength(){
         return replaceable.length();
     }
-    
+
     /**
      * Gets the current currentIndex in text.
      * @return current currentIndex in text.
      */
+    @Override
     public int getIndex(){
         return currentIndex;
     }
-        
+
     /**
-     * Returns next UTF16 character and increments the iterator's currentIndex by 1. 
-     * If the resulting currentIndex is greater or equal to the text length, the 
-     * currentIndex is reset to the text length and a value of DONECODEPOINT is 
-     * returned. 
-     * @return next UTF16 character in text or DONE if the new currentIndex is off the 
+     * Returns next UTF16 character and increments the iterator's currentIndex by 1.
+     * If the resulting currentIndex is greater or equal to the text length, the
+     * currentIndex is reset to the text length and a value of DONECODEPOINT is
+     * returned.
+     * @return next UTF16 character in text or DONE if the new currentIndex is off the
      *         end of the text range.
      */
+    @Override
     public int next(){
         if (currentIndex < replaceable.length()) {
             return replaceable.charAt(currentIndex++);
         }
         return DONE;
     }
-    
-                
+
+
     /**
-     * Returns previous UTF16 character and decrements the iterator's currentIndex by 
-     * 1. 
-     * If the resulting currentIndex is less than 0, the currentIndex is reset to 0 and a 
-     * value of DONECODEPOINT is returned. 
-     * @return next UTF16 character in text or DONE if the new currentIndex is off the 
+     * Returns previous UTF16 character and decrements the iterator's currentIndex by
+     * 1.
+     * If the resulting currentIndex is less than 0, the currentIndex is reset to 0 and a
+     * value of DONECODEPOINT is returned.
+     * @return next UTF16 character in text or DONE if the new currentIndex is off the
      *         start of the text range.
      */
+    @Override
     public int previous(){
         if (currentIndex > 0) {
             return replaceable.charAt(--currentIndex);
@@ -162,22 +171,24 @@ public class ReplaceableUCharacterIterator extends UCharacterIterator {
     }
 
     /**
-     * <p>Sets the currentIndex to the specified currentIndex in the text and returns that 
-     * single UTF16 character at currentIndex. 
+     * <p>Sets the currentIndex to the specified currentIndex in the text and returns that
+     * single UTF16 character at currentIndex.
      * This assumes the text is stored as 16-bit code units.</p>
-     * @param currentIndex the currentIndex within the text. 
-     * @exception IllegalArgumentException is thrown if an invalid currentIndex is 
+     * @param currentIndex the currentIndex within the text.
+     * @exception IllegalArgumentException is thrown if an invalid currentIndex is
      *            supplied. i.e. currentIndex is out of bounds.
-     * @returns the character at the specified currentIndex or DONE if the specified 
+     * @returns the character at the specified currentIndex or DONE if the specified
      *         currentIndex is equal to the end of the text.
      */
+    @Override
     public void setIndex(int currentIndex) throws IndexOutOfBoundsException{
         if (currentIndex < 0 || currentIndex > replaceable.length()) {
             throw new IndexOutOfBoundsException();
         }
         this.currentIndex = currentIndex;
     }
-    
+
+    @Override
     public int getText(char[] fillIn, int offset){
         int length = replaceable.length();
         if(offset < 0 || offset + length > fillIn.length){
@@ -185,10 +196,10 @@ public class ReplaceableUCharacterIterator extends UCharacterIterator {
         }
         replaceable.getChars(0,length,fillIn,offset);
         return length;
-    }       
-        
+    }
+
     // private data members ----------------------------------------------------
-    
+
     /**
      * Replacable object
      */
diff --git a/app/src/main/java/com/ibm/icu/impl/ResourceBundleWrapper.java b/icu4j/src/main/java/com/ibm/icu/impl/ResourceBundleWrapper.java
similarity index 61%
rename from app/src/main/java/com/ibm/icu/impl/ResourceBundleWrapper.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ResourceBundleWrapper.java
index 3ec4b8c..50869e7 100644
--- a/app/src/main/java/com/ibm/icu/impl/ResourceBundleWrapper.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ResourceBundleWrapper.java
@@ -1,7 +1,9 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
-* Copyright (C) 2004-2015, International Business Machines Corporation and   *
-* others. All Rights Reserved.                                               *
+* Copyright (C) 2004-2016, International Business Machines Corporation and
+* others. All Rights Reserved.
 ******************************************************************************
 */
 
@@ -20,25 +22,34 @@ import com.ibm.icu.util.ULocale;
 import com.ibm.icu.util.UResourceBundle;
 
 /**
- * just a wrapper for Java ListResourceBundles and 
+ * just a wrapper for Java ListResourceBundles and
  * @author ram
  *
  */
-public class ResourceBundleWrapper extends UResourceBundle {
+public final class ResourceBundleWrapper extends UResourceBundle {
     private ResourceBundle bundle = null;
     private String localeID = null;
     private String baseName = null;
     private List<String> keys = null;
-//    private int loadingStatus = -1;    
-    
+
+    /** Loader for bundle instances, for caching. */
+    private static abstract class Loader {
+        abstract ResourceBundleWrapper load();
+    }
+
+    private static CacheBase<String, ResourceBundleWrapper, Loader> BUNDLE_CACHE =
+            new SoftCache<String, ResourceBundleWrapper, Loader>() {
+        @Override
+        protected ResourceBundleWrapper createInstance(String unusedKey, Loader loader) {
+            return loader.load();
+        }
+    };
+
     private ResourceBundleWrapper(ResourceBundle bundle){
         this.bundle=bundle;
     }
 
-    protected void setLoadingStatus(int newStatus){
-//        loadingStatus = newStatus;
-    }
-    
+    @Override
     protected Object handleGetObject(String aKey){
         ResourceBundleWrapper current = this;
         Object obj = null;
@@ -59,11 +70,12 @@ public class ResourceBundleWrapper extends UResourceBundle {
         }
         return obj;
     }
-    
+
+    @Override
     public Enumeration<String> getKeys(){
         return Collections.enumeration(keys);
     }
-    
+
     private void initKeysVector(){
         ResourceBundleWrapper current = this;
         keys = new ArrayList<String>();
@@ -78,29 +90,42 @@ public class ResourceBundleWrapper extends UResourceBundle {
             current = (ResourceBundleWrapper)current.getParent();
         }
     }
+    @Override
     protected String getLocaleID(){
-        return localeID;   
+        return localeID;
     }
- 
+
+    @Override
     protected String getBaseName(){
-        return bundle.getClass().getName().replace('.','/');   
+        return bundle.getClass().getName().replace('.','/');
     }
-    
+
+    @Override
     public ULocale getULocale(){
-        return new ULocale(localeID);   
+        return new ULocale(localeID);
     }
-    
+
+    @Override
     public UResourceBundle getParent(){
-        return (UResourceBundle)parent;   
+        return (UResourceBundle)parent;
     }
 
     // Flag for enabling/disabling debugging code
     private static final boolean DEBUG = ICUDebug.enabled("resourceBundleWrapper");
-    
+
     // This method is for super class's instantiateBundle method
-    public static UResourceBundle getBundleInstance(String baseName, String localeID, 
-                                                    ClassLoader root, boolean disableFallback){
-        UResourceBundle b = instantiateBundle(baseName, localeID, root, disableFallback);
+    public static ResourceBundleWrapper getBundleInstance(String baseName, String localeID,
+            ClassLoader root, boolean disableFallback) {
+        if (root == null) {
+            root = ClassLoaderUtil.getClassLoader();
+        }
+        ResourceBundleWrapper b;
+        if (disableFallback) {
+            b = instantiateBundle(baseName, localeID, null, root, disableFallback);
+        } else {
+            b = instantiateBundle(baseName, localeID, ULocale.getDefault().getBaseName(),
+                    root, disableFallback);
+        }
         if(b==null){
             String separator ="_";
             if(baseName.indexOf('/')>=0){
@@ -110,47 +135,43 @@ public class ResourceBundleWrapper extends UResourceBundle {
         }
         return b;
     }
-    // recursively build bundle and override the super-class method
-     protected static synchronized UResourceBundle instantiateBundle(String baseName, String localeID,
-                                                                    ClassLoader root, boolean disableFallback) {
-        if (root == null) {
-            root = ClassLoaderUtil.getClassLoader();
-        }
-        final ClassLoader cl = root;
-        String name = baseName;
-        ULocale defaultLocale = ULocale.getDefault();
-        if (localeID.length() != 0) {
-            name = name + "_" + localeID;
-        }
 
-        ResourceBundleWrapper b = (ResourceBundleWrapper)loadFromCache(name, defaultLocale);
-        if(b==null){
+    private static boolean localeIDStartsWithLangSubtag(String localeID, String lang) {
+        return localeID.startsWith(lang) &&
+                (localeID.length() == lang.length() || localeID.charAt(lang.length()) == '_');
+    }
+
+    private static ResourceBundleWrapper instantiateBundle(
+             final String baseName, final String localeID, final String defaultID,
+             final ClassLoader root, final boolean disableFallback) {
+        final String name = localeID.isEmpty() ? baseName : baseName + '_' + localeID;
+        String cacheKey = disableFallback ? name : name + '#' + defaultID;
+        return BUNDLE_CACHE.getInstance(cacheKey, new Loader() {
+                @Override
+                public ResourceBundleWrapper load() {
             ResourceBundleWrapper parent = null;
             int i = localeID.lastIndexOf('_');
-    
+
             boolean loadFromProperties = false;
+            boolean parentIsRoot = false;
             if (i != -1) {
                 String locName = localeID.substring(0, i);
-                parent = (ResourceBundleWrapper)loadFromCache(baseName+"_"+locName,defaultLocale);
-                if(parent == null){
-                    parent = (ResourceBundleWrapper)instantiateBundle(baseName, locName , cl, disableFallback);
-                }
-            }else if(localeID.length()>0){
-                parent = (ResourceBundleWrapper)loadFromCache(baseName,defaultLocale);
-                if(parent==null){
-                    parent = (ResourceBundleWrapper)instantiateBundle(baseName, "", cl, disableFallback);
-                }
+                parent = instantiateBundle(baseName, locName, defaultID, root, disableFallback);
+            }else if(!localeID.isEmpty()){
+                parent = instantiateBundle(baseName, "", defaultID, root, disableFallback);
+                parentIsRoot = true;
             }
+            ResourceBundleWrapper b = null;
             try {
-                Class<? extends ResourceBundle> cls = cl.loadClass(name).asSubclass(ResourceBundle.class);
+                Class<? extends ResourceBundle> cls =
+                        root.loadClass(name).asSubclass(ResourceBundle.class);
                 ResourceBundle bx = cls.newInstance();
                 b = new ResourceBundleWrapper(bx);
                 if (parent != null) {
                     b.setParent(parent);
                 }
                 b.baseName=baseName;
-                b.localeID = localeID;            
-    
+                b.localeID = localeID;
             } catch (ClassNotFoundException e) {
                 loadFromProperties = true;
             } catch (NoClassDefFoundError e) {
@@ -167,12 +188,9 @@ public class ResourceBundleWrapper extends UResourceBundle {
                     final String resName = name.replace('.', '/') + ".properties";
                     InputStream stream = java.security.AccessController.doPrivileged(
                         new java.security.PrivilegedAction<InputStream>() {
+                            @Override
                             public InputStream run() {
-                                if (cl != null) {
-                                    return cl.getResourceAsStream(resName);
-                                } else {
-                                    return ClassLoader.getSystemResourceAsStream(resName);
-                                }
+                                return root.getResourceAsStream(resName);
                             }
                         }
                     );
@@ -196,22 +214,19 @@ public class ResourceBundleWrapper extends UResourceBundle {
                             }
                         }
                     }
-        
+
                     // if a bogus locale is passed then the parent should be
                     // the default locale not the root locale!
-                    if (b==null) {
-                        String defaultName = defaultLocale.toString();
-                        if (localeID.length()>0 && localeID.indexOf('_')< 0 && defaultName.indexOf(localeID) == -1) {
-                            b = (ResourceBundleWrapper)loadFromCache(baseName+"_"+defaultName, defaultLocale);
-                            if(b==null){
-                                b = (ResourceBundleWrapper)instantiateBundle(baseName , defaultName, cl, disableFallback);
-                            }
-                        }
+                    if (b == null && !disableFallback &&
+                            !localeID.isEmpty() && localeID.indexOf('_') < 0 &&
+                            !localeIDStartsWithLangSubtag(defaultID, localeID)) {
+                        // localeID is only a language subtag, different from the default language.
+                        b = instantiateBundle(baseName, defaultID, defaultID, root, disableFallback);
                     }
                     // if still could not find the bundle then return the parent
-                    if(b==null){
+                    if(b==null && (!parentIsRoot || !disableFallback)){
                         b=parent;
-                    }                
+                    }
                 } catch (Exception e) {
                     if (DEBUG)
                         System.out.println("failure");
@@ -219,15 +234,12 @@ public class ResourceBundleWrapper extends UResourceBundle {
                         System.out.println(e);
                 }
             }
-            b = (ResourceBundleWrapper)addToCache(name, defaultLocale, b);
-        }
-
-        if(b!=null){
-            b.initKeysVector();
-        }else{
-            if(DEBUG)System.out.println("Returning null for "+baseName+"_"+localeID);
-        }
-        
-        return b;
+            if(b!=null){
+                b.initKeysVector();
+            }else{
+                if(DEBUG)System.out.println("Returning null for "+baseName+"_"+localeID);
+            }
+            return b;
+        }});
     }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/Row.java b/icu4j/src/main/java/com/ibm/icu/impl/Row.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/impl/Row.java
rename to icu4j/src/main/java/com/ibm/icu/impl/Row.java
index 66e27cf..55667a8 100644
--- a/app/src/main/java/com/ibm/icu/impl/Row.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/Row.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  **********************************************************************
  * Copyright (c) 2002-2014, Google, International Business Machines
@@ -93,6 +95,7 @@ public class Row<C0, C1, C2, C3, C4> implements java.lang.Comparable, Cloneable,
         return this;
     }
 
+    @Override
     public int hashCode() {
         int sum = items.length;
         for (Object item : items) {
@@ -101,6 +104,7 @@ public class Row<C0, C1, C2, C3, C4> implements java.lang.Comparable, Cloneable,
         return sum;
     }
 
+    @Override
     public boolean equals(Object other) {
         if (other == null) {
             return false;
@@ -125,6 +129,7 @@ public class Row<C0, C1, C2, C3, C4> implements java.lang.Comparable, Cloneable,
         }
     }
 
+    @Override
     public int compareTo(Object other) {
         int result;
         Row<C0, C1, C2, C3, C4> that = (Row<C0, C1, C2, C3, C4>)other;
@@ -142,6 +147,7 @@ public class Row<C0, C1, C2, C3, C4> implements java.lang.Comparable, Cloneable,
         return 0;
     }
 
+    @Override
     public String toString() {
         StringBuilder result = new StringBuilder("[");
         boolean first = true;
@@ -156,15 +162,18 @@ public class Row<C0, C1, C2, C3, C4> implements java.lang.Comparable, Cloneable,
         return result.append("]").toString();
     }
 
+    @Override
     public boolean isFrozen() {
         return frozen;
     }
 
+    @Override
     public Row<C0, C1, C2, C3, C4> freeze() {
         frozen = true;
         return this;
     }
 
+    @Override
     public Object clone() {
         if (frozen) return this;
         try {
@@ -176,6 +185,7 @@ public class Row<C0, C1, C2, C3, C4> implements java.lang.Comparable, Cloneable,
         }
     }
 
+    @Override
     public Row<C0, C1, C2, C3, C4> cloneAsThawed() {
         try {
             Row<C0, C1, C2, C3, C4> result = (Row<C0, C1, C2, C3, C4>) super.clone();
diff --git a/app/src/main/java/com/ibm/icu/impl/RuleCharacterIterator.java b/icu4j/src/main/java/com/ibm/icu/impl/RuleCharacterIterator.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/impl/RuleCharacterIterator.java
rename to icu4j/src/main/java/com/ibm/icu/impl/RuleCharacterIterator.java
index d8781c5..a72261c 100644
--- a/app/src/main/java/com/ibm/icu/impl/RuleCharacterIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/RuleCharacterIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 **********************************************************************
 * Copyright (c) 2003-2011, International Business Machines
@@ -34,7 +36,7 @@ public class RuleCharacterIterator {
 
     /**
      * Text being iterated.
-     */    
+     */
     private String text;
 
     /**
@@ -79,7 +81,7 @@ public class RuleCharacterIterator {
      * PARSE_ESCAPES) != 0, then an embedded escape sequence will be expanded
      * to its value.  Escapes are parsed using Utility.unescapeAt().
      */
-    public static final int PARSE_ESCAPES   = 2;    
+    public static final int PARSE_ESCAPES   = 2;
 
     /**
      * Bitmask option to enable skipping of whitespace.  If (options &
@@ -109,7 +111,7 @@ public class RuleCharacterIterator {
         this.pos = pos;
         buf = null;
     }
-    
+
     /**
      * Returns true if this iterator has no more characters to return.
      */
@@ -306,6 +308,7 @@ public class RuleCharacterIterator {
      * Position within an expanded variable is <em>not</em> indicated.
      * @return a string representation of this object
      */
+    @Override
     public String toString() {
         int b = pos.getIndex();
         return text.substring(0, b) + '|' + text.substring(b);
@@ -324,7 +327,7 @@ public class RuleCharacterIterator {
             return (i < text.length()) ? UTF16.charAt(text, i) : DONE;
         }
     }
-    
+
     /**
      * Advances the position by the given amount.
      * @param count the number of 16-bit code units to advance past
diff --git a/app/src/main/java/com/ibm/icu/impl/SimpleCache.java b/icu4j/src/main/java/com/ibm/icu/impl/SimpleCache.java
similarity index 92%
rename from app/src/main/java/com/ibm/icu/impl/SimpleCache.java
rename to icu4j/src/main/java/com/ibm/icu/impl/SimpleCache.java
index 8402360..d0a1264 100644
--- a/app/src/main/java/com/ibm/icu/impl/SimpleCache.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/SimpleCache.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ****************************************************************************
  * Copyright (c) 2007-2015 International Business Machines Corporation and  *
@@ -37,6 +39,7 @@ public class SimpleCache<K, V> implements ICUCache<K, V> {
         }
     }
 
+    @Override
     public V get(Object key) {
         Reference<Map<K, V>> ref = cacheRef;
         if (ref != null) {
@@ -48,6 +51,7 @@ public class SimpleCache<K, V> implements ICUCache<K, V> {
         return null;
     }
 
+    @Override
     public void put(K key, V value) {
         Reference<Map<K, V>> ref = cacheRef;
         Map<K, V> map = null;
@@ -66,6 +70,7 @@ public class SimpleCache<K, V> implements ICUCache<K, V> {
         map.put(key, value);
     }
 
+    @Override
     public void clear() {
         cacheRef = null;
     }
diff --git a/app/src/main/java/com/ibm/icu/impl/SimpleFilteredSentenceBreakIterator.java b/icu4j/src/main/java/com/ibm/icu/impl/SimpleFilteredSentenceBreakIterator.java
similarity index 60%
rename from app/src/main/java/com/ibm/icu/impl/SimpleFilteredSentenceBreakIterator.java
rename to icu4j/src/main/java/com/ibm/icu/impl/SimpleFilteredSentenceBreakIterator.java
index 5d04eb8..5254936 100644
--- a/app/src/main/java/com/ibm/icu/impl/SimpleFilteredSentenceBreakIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/SimpleFilteredSentenceBreakIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014-2016, International Business Machines Corporation and
@@ -9,6 +11,7 @@ package com.ibm.icu.impl;
 import java.text.CharacterIterator;
 import java.util.HashSet;
 
+import com.ibm.icu.impl.ICUResourceBundle.OpenType;
 import com.ibm.icu.text.BreakIterator;
 import com.ibm.icu.text.FilteredBreakIteratorBuilder;
 import com.ibm.icu.text.UCharacterIterator;
@@ -17,7 +20,6 @@ import com.ibm.icu.util.CharsTrie;
 import com.ibm.icu.util.CharsTrieBuilder;
 import com.ibm.icu.util.StringTrieBuilder;
 import com.ibm.icu.util.ULocale;
-import com.ibm.icu.util.UResourceBundle;
 
 /**
  * @author tomzhang
@@ -44,82 +46,132 @@ public class SimpleFilteredSentenceBreakIterator extends BreakIterator {
         this.backwardsTrie = backwardsTrie;
     }
 
-    @Override
-    public int next() {
-        int n = delegate.next();
+
+    /**
+     * Reset the filter from the delegate.
+     */
+    private final void resetState() {
+        text = UCharacterIterator.getInstance((CharacterIterator) delegate.getText().clone());
+    }
+
+    /**
+     * Is there an exception at this point?
+     *
+     * @param n
+     * @return
+     */
+    private final boolean breakExceptionAt(int n) {
+        // Note: the C++ version of this function is SimpleFilteredSentenceBreakIterator::breakExceptionAt()
+
+        int bestPosn = -1;
+        int bestValue = -1;
+
+        // loops while 'n' points to an exception
+        text.setIndex(n);
+        backwardsTrie.reset();
+        int uch;
+
+        // Assume a space is following the '.' (so we handle the case: "Mr. /Brown")
+        if ((uch = text.previousCodePoint()) == ' ') { // TODO: skip a class of chars here??
+            // TODO only do this the 1st time?
+        } else {
+            uch = text.nextCodePoint();
+        }
+
+        BytesTrie.Result r = BytesTrie.Result.INTERMEDIATE_VALUE;
+
+        while ((uch = text.previousCodePoint()) != UCharacterIterator.DONE && // more to consume backwards and..
+                ((r = backwardsTrie.nextForCodePoint(uch)).hasNext())) {// more in the trie
+            if (r.hasValue()) { // remember the best match so far
+                bestPosn = text.getIndex();
+                bestValue = backwardsTrie.getValue();
+            }
+        }
+
+        if (r.matches()) { // exact match?
+            bestValue = backwardsTrie.getValue();
+            bestPosn = text.getIndex();
+        }
+
+        if (bestPosn >= 0) {
+            if (bestValue == Builder.MATCH) { // exact match!
+                return true; // Exception here.
+            } else if (bestValue == Builder.PARTIAL && forwardsPartialTrie != null) {
+                // make sure there's a forward trie
+                // We matched the "Ph." in "Ph.D." - now we need to run everything through the forwards trie
+                // to see if it matches something going forward.
+                forwardsPartialTrie.reset();
+
+                BytesTrie.Result rfwd = BytesTrie.Result.INTERMEDIATE_VALUE;
+                text.setIndex(bestPosn); // hope that's close ..
+                while ((uch = text.nextCodePoint()) != BreakIterator.DONE
+                        && ((rfwd = forwardsPartialTrie.nextForCodePoint(uch)).hasNext())) {
+                }
+                if (rfwd.matches()) {
+                    // Exception here
+                    return true;
+                } // else fall through
+            } // else fall through
+        } // else fall through
+        return false; // No exception here.
+    }
+
+    /**
+     * Given that the delegate has already given its "initial" answer,
+     * find the NEXT actual (non-suppressed) break.
+     * @param n initial position from delegate
+     * @return new break position or BreakIterator.DONE
+     */
+    private final int internalNext(int n) {
         if (n == BreakIterator.DONE || // at end or
                 backwardsTrie == null) { // .. no backwards table loaded == no exceptions
             return n;
         }
-        // UCharacterIterator text;
-        text = UCharacterIterator.getInstance((CharacterIterator) delegate.getText().clone());
-        do { // outer loop runs once per underlying break (from fDelegate).
-             // loops while 'n' points to an exception.
-            text.setIndex(n);
-            backwardsTrie.reset();
-            int uch;
-
-            // Assume a space is following the '.' (so we handle the case: "Mr. /Brown")
-            if ((uch = text.previousCodePoint()) == ' ') { // TODO: skip a class of chars here??
-                // TODO only do this the 1st time?
-            } else {
-                uch = text.nextCodePoint();
-            }
+        resetState();
 
-            BytesTrie.Result r = BytesTrie.Result.INTERMEDIATE_VALUE;
+        final int textLen = text.getLength();
 
-            int bestPosn = -1;
-            int bestValue = -1;
+        while (n != BreakIterator.DONE && n != textLen) {
+            // outer loop runs once per underlying break (from fDelegate).
+            // loops while 'n' points to an exception.
 
-            while ((uch = text.previousCodePoint()) != BreakIterator.DONE && // more to consume backwards and..
-                    ((r = backwardsTrie.nextForCodePoint(uch)).hasNext())) {// more in the trie
-                if (r.hasValue()) { // remember the best match so far
-                    bestPosn = text.getIndex();
-                    bestValue = backwardsTrie.getValue();
-                }
+            if (breakExceptionAt(n)) {
+                // n points to a break exception
+                n = delegate.next();
+            } else {
+                // no exception at this spot
+                return n;
             }
+        }
+        return n; //hit underlying DONE or break at end of text
+    }
 
-            if (r.matches()) { // exact match?
-                bestValue = backwardsTrie.getValue();
-                bestPosn = text.getIndex();
-            }
+    /**
+     * Given that the delegate has already given its "initial" answer,
+     * find the PREV actual (non-suppressed) break.
+     * @param n initial position from delegate
+     * @return new break position or BreakIterator.DONE
+     */
+    private final int internalPrev(int n) {
+        if (n == 0 || n == BreakIterator.DONE || // at end or
+                backwardsTrie == null) { // .. no backwards table loaded == no exceptions
+            return n;
+        }
+        resetState();
 
-            if (bestPosn >= 0) {
-                if (bestValue == Builder.MATCH) { // exact match!
-                    n = delegate.next(); // skip this one. Find the next lowerlevel break.
-                    if (n == BreakIterator.DONE)
-                        return n;
-                    continue; // See if the next is another exception.
-                } else if (bestValue == Builder.PARTIAL && forwardsPartialTrie != null) {
-                    // make sure there's a forward trie
-                    // We matched the "Ph." in "Ph.D." - now we need to run everything through the forwards trie
-                    // to see if it matches something going forward.
-                    forwardsPartialTrie.reset();
-
-                    BytesTrie.Result rfwd = BytesTrie.Result.INTERMEDIATE_VALUE;
-                    text.setIndex(bestPosn); // hope that's close ..
-                    while ((uch = text.nextCodePoint()) != BreakIterator.DONE
-                            && ((rfwd = forwardsPartialTrie.nextForCodePoint(uch)).hasNext())) {
-                    }
-                    if (rfwd.matches()) {
-                        // only full matches here, nothing to check
-                        // skip the next:
-                        n = delegate.next();
-                        if (n == BreakIterator.DONE)
-                            return n;
-                        continue;
-                    } else {
-                        // no match (no exception) -return the 'underlying' break
-                        return n;
-                    }
-                } else {
-                    return n; // internal error and/or no forwards trie
-                }
+        while (n != BreakIterator.DONE && n != 0) {
+            // outer loop runs once per underlying break (from fDelegate).
+            // loops while 'n' points to an exception.
+
+            if (breakExceptionAt(n)) {
+                // n points to a break exception
+                n = delegate.previous();
             } else {
-                return n; // No match - so exit. Not an exception.
+                // no exception at this spot
+                return n;
             }
-        } while (n != BreakIterator.DONE);
-        return n;
+        }
+        return n; //hit underlying DONE or break at end of text
     }
 
     @Override
@@ -146,43 +198,62 @@ public class SimpleFilteredSentenceBreakIterator extends BreakIterator {
         return other;
     }
 
+
     @Override
     public int first() {
+        // Don't suppress a break opportunity at the beginning of text.
         return delegate.first();
     }
 
     @Override
-    public int last() {
-        return delegate.last();
+    public int preceding(int offset) {
+        return internalPrev(delegate.preceding(offset));
     }
 
     @Override
-    public int next(int n) {
-        // TODO
-        throw new UnsupportedOperationException("next(int) is not yet implemented");
+    public int previous() {
+        return internalPrev(delegate.previous());
     }
 
     @Override
-    public int previous() {
-        // TODO
-        throw new UnsupportedOperationException("previous() is not yet implemented");
+    public int current() {
+        return delegate.current();
     }
 
     @Override
-    public int following(int offset) {
-        // TODO
-        throw new UnsupportedOperationException("following(int) is not yet implemented");
+    public boolean isBoundary(int offset) {
+        if(!delegate.isBoundary(offset)) {
+            return false; // No underlying break to suppress?
+        }
+
+        // delegate thinks there's a break…
+        if(backwardsTrie == null) {
+            return true; // no data
+        }
+
+        resetState();
+        return !breakExceptionAt(offset); // if there's an exception: no break.
     }
 
     @Override
-    public int current() {
-        return delegate.current();
+    public int next() {
+        return internalNext(delegate.next());
     }
 
     @Override
-    public int preceding(int offset) {
-        // TODO
-        throw new UnsupportedOperationException("preceding(int) is not yet implemented");
+    public int next(int n) {
+        return internalNext(delegate.next(n));
+    }
+
+    @Override
+    public int following(int offset) {
+        return internalNext(delegate.following(offset));
+    }
+
+    @Override
+    public int last() {
+        // Don't suppress a break opportunity at the end of text.
+        return delegate.last();
     }
 
     @Override
@@ -211,20 +282,18 @@ public class SimpleFilteredSentenceBreakIterator extends BreakIterator {
          * @param loc the locale to get filtered iterators
          */
         public Builder(ULocale loc) {
-            ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(
-                    ICUResourceBundle.ICU_BRKITR_BASE_NAME, loc);
-            ICUResourceBundle exceptions = rb.findWithFallback("exceptions");
-            if (exceptions != null) {
-                ICUResourceBundle breaks = exceptions.findWithFallback("SentenceBreak");
-    
-                if (breaks != null) {
-                    for (int index = 0, size = breaks.getSize(); index < size; ++index) {
-                        ICUResourceBundle b = (ICUResourceBundle) breaks.get(index);
-                        String br = b.getString();
-                        filterSet.add(br);
-                    }
+            ICUResourceBundle rb = ICUResourceBundle.getBundleInstance(
+                    ICUData.ICU_BRKITR_BASE_NAME, loc, OpenType.LOCALE_ROOT);
+
+            ICUResourceBundle breaks = rb.findWithFallback("exceptions/SentenceBreak");
+
+            if (breaks != null) {
+                for (int index = 0, size = breaks.getSize(); index < size; ++index) {
+                    ICUResourceBundle b = (ICUResourceBundle) breaks.get(index);
+                    String br = b.getString();
+                    filterSet.add(br);
                 }
-            } // else - no exceptions.
+            }
         }
 
         /**
@@ -257,7 +326,7 @@ public class SimpleFilteredSentenceBreakIterator extends BreakIterator {
                 // Short circuit - nothing to except.
                 return adoptBreakIterator;
             }
-            
+
             CharsTrieBuilder builder = new CharsTrieBuilder();
             CharsTrieBuilder builder2 = new CharsTrieBuilder();
 
diff --git a/app/src/main/java/com/ibm/icu/impl/SimpleFormatterImpl.java b/icu4j/src/main/java/com/ibm/icu/impl/SimpleFormatterImpl.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/SimpleFormatterImpl.java
rename to icu4j/src/main/java/com/ibm/icu/impl/SimpleFormatterImpl.java
index 4ce5419..d361b34 100644
--- a/app/src/main/java/com/ibm/icu/impl/SimpleFormatterImpl.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/SimpleFormatterImpl.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014-2016, International Business Machines Corporation and
diff --git a/icu4j/src/main/java/com/ibm/icu/impl/SoftCache.java b/icu4j/src/main/java/com/ibm/icu/impl/SoftCache.java
new file mode 100644
index 0000000..737dc60
--- /dev/null
+++ b/icu4j/src/main/java/com/ibm/icu/impl/SoftCache.java
@@ -0,0 +1,88 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
+/*
+*******************************************************************************
+*   Copyright (C) 2010-2016, International Business Machines
+*   Corporation and others.  All Rights Reserved.
+*******************************************************************************
+*/
+package com.ibm.icu.impl;
+
+import java.util.concurrent.ConcurrentHashMap;
+
+/**
+ * Generic, thread-safe cache implementation, usually storing cached instances
+ * in {@link java.lang.ref.Reference}s via {@link CacheValue}s.
+ * To use, instantiate a subclass which implements the createInstance() method,
+ * and call get() with the key and the data. The get() call will use the data
+ * only if it needs to call createInstance(), otherwise the data is ignored.
+ *
+ * <p>When caching instances while the CacheValue "strength" is {@code SOFT},
+ * the Java runtime can later release these instances once they are not used any more at all.
+ * If such an instance is then requested again,
+ * the getInstance() method will call createInstance() again and reset the CacheValue.
+ * The cache holds on to its map of keys to CacheValues forever.
+ *
+ * <p>A value can be null if createInstance() returns null.
+ * In this case, it must do so consistently for the same key and data.
+ *
+ * @param <K> Cache lookup key type
+ * @param <V> Cache instance value type (must not be a CacheValue)
+ * @param <D> Data type for creating a new instance value
+ *
+ * @author Markus Scherer, Mark Davis
+ */
+public abstract class SoftCache<K, V, D> extends CacheBase<K, V, D> {
+    private ConcurrentHashMap<K, Object> map = new ConcurrentHashMap<K, Object>();
+
+    @SuppressWarnings("unchecked")
+    @Override
+    public final V getInstance(K key, D data) {
+        // We synchronize twice, once in the ConcurrentHashMap and
+        // once in valueRef.resetIfCleared(value),
+        // because we prefer the fine-granularity locking of the ConcurrentHashMap
+        // over coarser locking on the whole cache instance.
+        // We use a CacheValue (a second level of indirection) because
+        // ConcurrentHashMap.putIfAbsent() never replaces the key's value, and if it were
+        // a simple Reference we would not be able to reset its value after it has been cleared.
+        // (And ConcurrentHashMap.put() always replaces the value, which we don't want either.)
+        Object mapValue = map.get(key);
+        if(mapValue != null) {
+            if(!(mapValue instanceof CacheValue)) {
+                // The value was stored directly.
+                return (V)mapValue;
+            }
+            CacheValue<V> cv = (CacheValue<V>)mapValue;
+            if(cv.isNull()) {
+                return null;
+            }
+            V value = cv.get();
+            if(value != null) {
+                return value;
+            }
+            // The instance has been evicted, its Reference cleared.
+            // Create and set a new instance.
+            value = createInstance(key, data);
+            return cv.resetIfCleared(value);
+        } else /* valueRef == null */ {
+            // We had never cached an instance for this key.
+            V value = createInstance(key, data);
+            mapValue = (value != null && CacheValue.futureInstancesWillBeStrong()) ?
+                    value : CacheValue.getInstance(value);
+            mapValue = map.putIfAbsent(key, mapValue);
+            if(mapValue == null) {
+                // Normal "put": Our new value is now cached.
+                return value;
+            }
+            // Race condition: Another thread beat us to putting a CacheValue
+            // into the map. Return its value, but just in case the garbage collector
+            // was aggressive, we also offer our new instance for caching.
+            if(!(mapValue instanceof CacheValue)) {
+                // The value was stored directly.
+                return (V)mapValue;
+            }
+            CacheValue<V> cv = (CacheValue<V>)mapValue;
+            return cv.resetIfCleared(value);
+        }
+    }
+}
diff --git a/app/src/main/java/com/ibm/icu/impl/SortedSetRelation.java b/icu4j/src/main/java/com/ibm/icu/impl/SortedSetRelation.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/impl/SortedSetRelation.java
rename to icu4j/src/main/java/com/ibm/icu/impl/SortedSetRelation.java
index 7051fa6..2d023bc 100644
--- a/app/src/main/java/com/ibm/icu/impl/SortedSetRelation.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/SortedSetRelation.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 **********************************************************************
 * Copyright (c) 2002-2010, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/StandardPlural.java b/icu4j/src/main/java/com/ibm/icu/impl/StandardPlural.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/StandardPlural.java
rename to icu4j/src/main/java/com/ibm/icu/impl/StandardPlural.java
index a6d606f..c9a7fe5 100644
--- a/app/src/main/java/com/ibm/icu/impl/StandardPlural.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/StandardPlural.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2015, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/impl/StringPrepDataReader.java b/icu4j/src/main/java/com/ibm/icu/impl/StringPrepDataReader.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/impl/StringPrepDataReader.java
rename to icu4j/src/main/java/com/ibm/icu/impl/StringPrepDataReader.java
index ff4cb81..667522f 100644
--- a/app/src/main/java/com/ibm/icu/impl/StringPrepDataReader.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/StringPrepDataReader.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ******************************************************************************
  * Copyright (C) 2003-2015, International Business Machines Corporation and
@@ -45,13 +47,10 @@ public final class StringPrepDataReader implements ICUBinary.Authenticate {
         return ICUBinary.getChars(byteBuffer, length, 0);
     }
 
-    public byte[] getDataFormatVersion(){
-        return DATA_FORMAT_VERSION;
-    }
-    
+    @Override
     public boolean isDataVersionAcceptable(byte version[]){
-        return version[0] == DATA_FORMAT_VERSION[0] 
-               && version[2] == DATA_FORMAT_VERSION[2] 
+        return version[0] == DATA_FORMAT_VERSION[0]
+               && version[2] == DATA_FORMAT_VERSION[2]
                && version[3] == DATA_FORMAT_VERSION[3];
     }
     public int[] readIndexes(int length)throws IOException{
@@ -61,7 +60,7 @@ public final class StringPrepDataReader implements ICUBinary.Authenticate {
              indexes[i] = byteBuffer.getInt();
         }
         return indexes;
-    } 
+    }
 
     public byte[] getUnicodeVersion(){
         return ICUBinary.getVersionByteArrayFromCompactInt(unicodeVersion);
diff --git a/app/src/main/java/com/ibm/icu/impl/StringRange.java b/icu4j/src/main/java/com/ibm/icu/impl/StringRange.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/impl/StringRange.java
rename to icu4j/src/main/java/com/ibm/icu/impl/StringRange.java
index f66f44c..fae69eb 100644
--- a/app/src/main/java/com/ibm/icu/impl/StringRange.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/StringRange.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2015, Google, Inc., International Business Machines Corporation and
@@ -31,6 +33,7 @@ public class StringRange {
     }
 
     public static final Comparator<int[]> COMPARE_INT_ARRAYS = new Comparator<int[]>() {
+        @Override
         public int compare(int[] o1, int[] o2) {
             int minIndex = Math.min(o1.length, o2.length);
             for (int i = 0; i < minIndex; ++i) {
@@ -67,8 +70,8 @@ public class StringRange {
                         }
                     }
                     // We failed to find continuation. Add what we have and restart
-                    adder.add(start, end == null ? null 
-                        : !shorterPairs ? end 
+                    adder.add(start, end == null ? null
+                        : !shorterPairs ? end
                             : end.substring(prefixLen, end.length()));
                 }
                 // new possible range
@@ -77,8 +80,8 @@ public class StringRange {
                 lastCp = s.codePointBefore(s.length());
                 prefixLen = s.length() - Character.charCount(lastCp);
             }
-            adder.add(start, end == null ? null 
-                : !shorterPairs ? end 
+            adder.add(start, end == null ? null
+                : !shorterPairs ? end
                     : end.substring(prefixLen, end.length()));
         } else {
             // not a fast algorithm, but ok for now
@@ -86,19 +89,19 @@ public class StringRange {
             // first sort by lengths
             Relation<Integer,Ranges> lengthToArrays = Relation.of(new TreeMap<Integer,Set<Ranges>>(), TreeSet.class);
             for (String s : source) {
-                Ranges item = new Ranges(s); 
+                Ranges item = new Ranges(s);
                 lengthToArrays.put(item.size(), item);
             }
             // then compact items of each length and emit compacted sets
             for (Entry<Integer, Set<Ranges>> entry : lengthToArrays.keyValuesSet()) {
                 LinkedList<Ranges> compacted = compact(entry.getKey(), entry.getValue());
-                for (Ranges ranges : compacted) {   
+                for (Ranges ranges : compacted) {
                     adder.add(ranges.start(), ranges.end(shorterPairs));
                 }
             }
         }
     }
-    
+
     /**
      * Faster but not as good compaction. Only looks at final codepoint.
      * @param source set of strings
@@ -136,8 +139,9 @@ public class StringRange {
         }
         @Override
         public boolean equals(Object obj) {
-            return compareTo((Range)obj) == 0;
+            return this == obj || (obj != null && obj instanceof Range && compareTo((Range)obj) == 0);
         }
+        @Override
         public int compareTo(Range that) {
             int diff = min - that.min;
             if (diff != 0) {
@@ -183,7 +187,7 @@ public class StringRange {
            if (DEBUG) System.out.println(" => " + this);
            return true;
         }
-        
+
         public String start() {
             StringBuilder result = new StringBuilder();
             for (int i = 0; i < ranges.length; ++i) {
@@ -213,6 +217,7 @@ public class StringRange {
         public Integer size() {
             return ranges.length;
         }
+        @Override
         public int compareTo(Ranges other) {
             int diff = ranges.length - other.ranges.length;
             if (diff != 0) {
@@ -257,7 +262,7 @@ public class StringRange {
         add(0, startOffset, startCps, endCps, builder, output);
         return output;
     }
-    
+
     private static void add(int endIndex, int startOffset, int[] starts, int[] ends, StringBuilder builder, Collection<String> output) {
         int start = starts[endIndex+startOffset];
         int end = ends[endIndex];
diff --git a/app/src/main/java/com/ibm/icu/impl/StringUCharacterIterator.java b/icu4j/src/main/java/com/ibm/icu/impl/StringUCharacterIterator.java
similarity index 100%
rename from app/src/main/java/com/ibm/icu/impl/StringUCharacterIterator.java
rename to icu4j/src/main/java/com/ibm/icu/impl/StringUCharacterIterator.java
diff --git a/app/src/main/java/com/ibm/icu/impl/TZDBTimeZoneNames.java b/icu4j/src/main/java/com/ibm/icu/impl/TZDBTimeZoneNames.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/impl/TZDBTimeZoneNames.java
rename to icu4j/src/main/java/com/ibm/icu/impl/TZDBTimeZoneNames.java
index 4e5e983..9676af3 100644
--- a/app/src/main/java/com/ibm/icu/impl/TZDBTimeZoneNames.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/TZDBTimeZoneNames.java
@@ -1,6 +1,8 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2014-2015, International Business Machines Corporation and
+ * Copyright (C) 2014-2016, International Business Machines Corporation and
  * others. All Rights Reserved.
  *******************************************************************************
  */
@@ -24,10 +26,10 @@ import com.ibm.icu.util.UResourceBundle;
  * Yet another TimeZoneNames implementation based on the tz database.
  * This implementation contains only tz abbreviations (short standard
  * and daylight names) for each metazone.
- * 
+ *
  * The data file $ICU4C_ROOT/source/data/zone/tzdbNames.txt contains
  * the metazone - abbreviations mapping data (manually edited).
- * 
+ *
  * Note: The abbreviations in the tz database are not necessarily
  * unique. For example, parsing abbreviation "IST" is ambiguous
  * (can be parsed as India Standard Time or Israel Standard Time).
@@ -38,7 +40,7 @@ import com.ibm.icu.util.UResourceBundle;
 public class TZDBTimeZoneNames extends TimeZoneNames {
     private static final long serialVersionUID = 1L;
 
-    private static final ConcurrentHashMap<String, TZDBNames> TZDB_NAMES_MAP = 
+    private static final ConcurrentHashMap<String, TZDBNames> TZDB_NAMES_MAP =
             new ConcurrentHashMap<String, TZDBNames>();
 
     private static volatile TextTrieMap<TZDBNameInfo> TZDB_NAMES_TRIE = null;
@@ -46,7 +48,7 @@ public class TZDBTimeZoneNames extends TimeZoneNames {
     private static final ICUResourceBundle ZONESTRINGS;
     static {
         UResourceBundle bundle = ICUResourceBundle
-                .getBundleInstance(ICUResourceBundle.ICU_ZONE_BASE_NAME, "tzdbNames");
+                .getBundleInstance(ICUData.ICU_ZONE_BASE_NAME, "tzdbNames");
         ZONESTRINGS = (ICUResourceBundle)bundle.get("zoneStrings");
     }
 
@@ -95,7 +97,7 @@ public class TZDBTimeZoneNames extends TimeZoneNames {
      */
     @Override
     public String getMetaZoneDisplayName(String mzID, NameType type) {
-        if (mzID == null || mzID.length() == 0 || 
+        if (mzID == null || mzID.length() == 0 ||
                 (type != NameType.SHORT_STANDARD && type != NameType.SHORT_DAYLIGHT)) {
             return null;
         }
@@ -212,10 +214,17 @@ public class TZDBTimeZoneNames extends TimeZoneNames {
     }
 
     private static class TZDBNameInfo {
-        String mzID;
-        NameType type;
-        boolean ambiguousType;
-        String[] parseRegions;
+        final String mzID;
+        final NameType type;
+        final boolean ambiguousType;
+        final String[] parseRegions;
+
+        TZDBNameInfo(String mzID, NameType type, boolean ambiguousType, String[] parseRegions) {
+            this.mzID = mzID;
+            this.type = type;
+            this.ambiguousType = ambiguousType;
+            this.parseRegions = parseRegions;
+        }
     }
 
     private static class TZDBNameSearchHandler implements ResultHandler<TZDBNameInfo> {
@@ -233,6 +242,7 @@ public class TZDBTimeZoneNames extends TimeZoneNames {
          * @see com.ibm.icu.impl.TextTrieMap.ResultHandler#handlePrefixMatch(int,
          *      java.util.Iterator)
          */
+        @Override
         public boolean handlePrefixMatch(int matchLength, Iterator<TZDBNameInfo> values) {
             TZDBNameInfo match = null;
             TZDBNameInfo defaultRegionMatch = null;
@@ -358,19 +368,17 @@ public class TZDBTimeZoneNames extends TimeZoneNames {
                         boolean ambiguousType = (std != null && dst != null && std.equals(dst));
 
                         if (std != null) {
-                            TZDBNameInfo stdInf = new TZDBNameInfo();
-                            stdInf.mzID = mzID;
-                            stdInf.type = NameType.SHORT_STANDARD;
-                            stdInf.ambiguousType = ambiguousType;
-                            stdInf.parseRegions = parseRegions;
+                            TZDBNameInfo stdInf = new TZDBNameInfo(mzID,
+                                    NameType.SHORT_STANDARD,
+                                    ambiguousType,
+                                    parseRegions);
                             trie.put(std, stdInf);
                         }
                         if (dst != null) {
-                            TZDBNameInfo dstInf = new TZDBNameInfo();
-                            dstInf.mzID = mzID;
-                            dstInf.type = NameType.SHORT_DAYLIGHT;
-                            dstInf.ambiguousType = ambiguousType;
-                            dstInf.parseRegions = parseRegions;
+                            TZDBNameInfo dstInf = new TZDBNameInfo(mzID,
+                                    NameType.SHORT_DAYLIGHT,
+                                    ambiguousType,
+                                    parseRegions);
                             trie.put(dst, dstInf);
                         }
                     }
diff --git a/app/src/main/java/com/ibm/icu/impl/TextTrieMap.java b/icu4j/src/main/java/com/ibm/icu/impl/TextTrieMap.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/TextTrieMap.java
rename to icu4j/src/main/java/com/ibm/icu/impl/TextTrieMap.java
index 2838b6f..6688d47 100644
--- a/app/src/main/java/com/ibm/icu/impl/TextTrieMap.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/TextTrieMap.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  * ********************************************************************************
  * Copyright (C) 2007-2011, International Business Machines Corporation and others.
@@ -24,7 +26,7 @@ public class TextTrieMap<V> {
 
     /**
      * Constructs a TextTrieMap object.
-     * 
+     *
      * @param ignoreCase true to use simple case insensitive match
      */
     public TextTrieMap(boolean ignoreCase) {
@@ -33,7 +35,7 @@ public class TextTrieMap<V> {
 
     /**
      * Adds the text key and its associated object in this object.
-     * 
+     *
      * @param text The text.
      * @param val The value object associated with the text.
      */
@@ -46,7 +48,7 @@ public class TextTrieMap<V> {
     /**
      * Gets an iterator of the objects associated with the
      * longest prefix matching string key.
-     * 
+     *
      * @param text The text to be matched with prefixes.
      * @return An iterator of the objects associated with
      * the longest prefix matching matching key, or null
@@ -58,13 +60,13 @@ public class TextTrieMap<V> {
 
     /**
      * Gets an iterator of the objects associated with the
-     * longest prefix matching string key starting at the 
+     * longest prefix matching string key starting at the
      * specified position.
-     * 
+     *
      * @param text The text to be matched with prefixes.
      * @param start The start index of of the text
      * @return An iterator of the objects associated with the
-     * longest prefix matching matching key, or null if no 
+     * longest prefix matching matching key, or null if no
      * matching entry is found.
      */
     public Iterator<V> get(CharSequence text, int start) {
@@ -83,7 +85,7 @@ public class TextTrieMap<V> {
     public void find(CharSequence text, ResultHandler<V> handler) {
         find(text, 0, handler);
     }
-    
+
     public void find(CharSequence text, int offset, ResultHandler<V> handler) {
         CharIterator chitr = new CharIterator(text, offset, _ignoreCase);
         find(_root, chitr, handler);
@@ -120,6 +122,7 @@ public class TextTrieMap<V> {
         /* (non-Javadoc)
          * @see java.util.Iterator#hasNext()
          */
+        @Override
         public boolean hasNext() {
             if (_nextIdx == _text.length() && _remainingChar == null) {
                 return false;
@@ -130,6 +133,7 @@ public class TextTrieMap<V> {
         /* (non-Javadoc)
          * @see java.util.Iterator#next()
          */
+        @Override
         public Character next() {
             if (_nextIdx == _text.length() && _remainingChar == null) {
                 return null;
@@ -159,6 +163,7 @@ public class TextTrieMap<V> {
         /* (non-Javadoc)
          * @see java.util.Iterator#remove()
          */
+        @Override
         public void remove() {
             throw new UnsupportedOperationException("remove() not supproted");
         }
@@ -182,7 +187,7 @@ public class TextTrieMap<V> {
     public interface ResultHandler<V> {
         /**
          * Handles a prefix key match
-         * 
+         *
          * @param matchLength Matched key's length
          * @param values An iterator of the objects associated with the matched key
          * @return Return true to continue the search in the trie, false to quit.
@@ -194,6 +199,7 @@ public class TextTrieMap<V> {
         private Iterator<V> matches = null;
         private int length = 0;
 
+        @Override
         public boolean handlePrefixMatch(int matchLength, Iterator<V> values) {
             if (matchLength > length) {
                 length = matchLength;
diff --git a/app/src/main/java/com/ibm/icu/impl/TimeZoneAdapter.java b/icu4j/src/main/java/com/ibm/icu/impl/TimeZoneAdapter.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/impl/TimeZoneAdapter.java
rename to icu4j/src/main/java/com/ibm/icu/impl/TimeZoneAdapter.java
index a7e0fdb..7e0c18f 100644
--- a/app/src/main/java/com/ibm/icu/impl/TimeZoneAdapter.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/TimeZoneAdapter.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  **********************************************************************
  * Copyright (c) 2003-2010, International Business Machines
@@ -28,16 +30,16 @@ import com.ibm.icu.util.TimeZone;
  * @since ICU 2.8
  */
 public class TimeZoneAdapter extends java.util.TimeZone {
- 
+
     // Generated by serialver from JDK 1.4.1_01
     static final long serialVersionUID = -2040072218820018557L;
-    
+
     /**
      * The contained com.ibm.icu.util.TimeZone object.  Must not be null.
      * We delegate all methods to this object.
      */
     private TimeZone zone;
-    
+
     /**
      * Given a java.util.TimeZone, wrap it in the appropriate adapter
      * subclass of com.ibm.icu.util.TimeZone and return the adapter.
@@ -64,14 +66,16 @@ public class TimeZoneAdapter extends java.util.TimeZone {
     /**
      * TimeZone API; calls through to wrapped time zone.
      */
+    @Override
     public void setID(String ID) {
         super.setID(ID);
         zone.setID(ID);
-    }    
+    }
 
     /**
      * TimeZone API; calls through to wrapped time zone.
      */
+    @Override
     public boolean hasSameRules(java.util.TimeZone other) {
         return other instanceof TimeZoneAdapter &&
             zone.hasSameRules(((TimeZoneAdapter)other).zone);
@@ -80,6 +84,7 @@ public class TimeZoneAdapter extends java.util.TimeZone {
     /**
      * TimeZone API; calls through to wrapped time zone.
      */
+    @Override
     public int getOffset(int era, int year, int month, int day, int dayOfWeek,
                          int millis) {
         return zone.getOffset(era, year, month, day, dayOfWeek, millis);
@@ -88,6 +93,7 @@ public class TimeZoneAdapter extends java.util.TimeZone {
     /**
      * TimeZone API; calls through to wrapped time zone.
      */
+    @Override
     public int getRawOffset() {
         return zone.getRawOffset();
     }
@@ -95,6 +101,7 @@ public class TimeZoneAdapter extends java.util.TimeZone {
     /**
      * TimeZone API; calls through to wrapped time zone.
      */
+    @Override
     public void setRawOffset(int offsetMillis) {
         zone.setRawOffset(offsetMillis);
     }
@@ -102,6 +109,7 @@ public class TimeZoneAdapter extends java.util.TimeZone {
     /**
      * TimeZone API; calls through to wrapped time zone.
      */
+    @Override
     public boolean useDaylightTime() {
         return zone.useDaylightTime();
     }
@@ -109,6 +117,7 @@ public class TimeZoneAdapter extends java.util.TimeZone {
     /**
      * TimeZone API; calls through to wrapped time zone.
      */
+    @Override
     public boolean inDaylightTime(Date date) {
         return zone.inDaylightTime(date);
     }
@@ -116,6 +125,7 @@ public class TimeZoneAdapter extends java.util.TimeZone {
     /**
      * Boilerplate API; calls through to wrapped object.
      */
+    @Override
     public Object clone() {
         return new TimeZoneAdapter((TimeZone)zone.clone());
     }
@@ -123,6 +133,7 @@ public class TimeZoneAdapter extends java.util.TimeZone {
     /**
      * Boilerplate API; calls through to wrapped object.
      */
+    @Override
     public synchronized int hashCode() {
         return zone.hashCode();
     }
@@ -130,6 +141,7 @@ public class TimeZoneAdapter extends java.util.TimeZone {
     /**
      * Boilerplate API; calls through to wrapped object.
      */
+    @Override
     public boolean equals(Object obj) {
         if (obj instanceof TimeZoneAdapter) {
             obj = ((TimeZoneAdapter) obj).zone;
@@ -141,6 +153,7 @@ public class TimeZoneAdapter extends java.util.TimeZone {
      * Returns a string representation of this object.
      * @return  a string representation of this object.
      */
+    @Override
     public String toString() {
         return "TimeZoneAdapter: " + zone.toString();
     }
diff --git a/app/src/main/java/com/ibm/icu/impl/TimeZoneGenericNames.java b/icu4j/src/main/java/com/ibm/icu/impl/TimeZoneGenericNames.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/impl/TimeZoneGenericNames.java
rename to icu4j/src/main/java/com/ibm/icu/impl/TimeZoneGenericNames.java
index 7ddf1b0..689905b 100644
--- a/app/src/main/java/com/ibm/icu/impl/TimeZoneGenericNames.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/TimeZoneGenericNames.java
@@ -1,7 +1,9 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2011-2014, International Business Machines Corporation and    *
- * others. All Rights Reserved.                                                *
+ * Copyright (C) 2011-2016, International Business Machines Corporation and
+ * others. All Rights Reserved.
  *******************************************************************************
  */
 package com.ibm.icu.impl;
@@ -77,7 +79,7 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
      * Format pattern enum used for composing location and partial location names
      */
     public enum Pattern {
-        // The format pattern such as "{0} Time", where {0} is the country or city. 
+        // The format pattern such as "{0} Time", where {0} is the country or city.
         REGION_FORMAT("regionFormat", "({0})"),
 
         // Note: FALLBACK_REGION_FORMAT is no longer used since ICU 50/CLDR 22.1
@@ -104,7 +106,7 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
         }
     }
 
-    private ULocale _locale;
+    private final ULocale _locale;
     private TimeZoneNames _tznames;
 
     private transient volatile boolean _frozen;
@@ -183,7 +185,7 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
     /**
      * Returns the display name of the time zone for the given name type
      * at the given date, or null if the display name is not available.
-     * 
+     *
      * @param tz the time zone
      * @param type the generic name type - see {@link GenericNameType}
      * @param date the date
@@ -216,7 +218,7 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
 
     /**
      * Returns the generic location name for the given canonical time zone ID.
-     * 
+     *
      * @param canonicalTzID the canonical time zone ID
      * @return the generic location name for the given canonical time zone ID.
      */
@@ -259,9 +261,7 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
                 String tmp = _genericLocationNamesMap.putIfAbsent(canonicalTzID, name.intern());
                 if (tmp == null) {
                     // Also put the name info the to trie
-                    NameInfo info = new NameInfo();
-                    info.tzID = canonicalTzID;
-                    info.type = GenericNameType.LOCATION;
+                    NameInfo info = new NameInfo(canonicalTzID, GenericNameType.LOCATION);
                     _gnamesTrie.put(name, info);
                 } else {
                     name = tmp;
@@ -303,9 +303,9 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
     /**
      * Private method to get a generic string, with fallback logics involved,
      * that is,
-     * 
+     *
      * 1. If a generic non-location string is available for the zone, return it.
-     * 2. If a generic non-location string is associated with a meta zone and 
+     * 2. If a generic non-location string is associated with a meta zone and
      *    the zone never use daylight time around the given date, use the standard
      *    string (if available).
      * 3. If a generic non-location string is associated with a meta zone and
@@ -313,7 +313,7 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
      *    current locale, then return the generic partial location string (if available)
      * 4. If a generic non-location string is not available, use generic location
      *    string.
-     * 
+     *
      * @param tz the requested time zone
      * @param date the date
      * @param type the generic name type, either LONG or SHORT
@@ -433,7 +433,7 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
      * Private simple pattern formatter used for formatting generic location names
      * and partial location names. We intentionally use JDK MessageFormat
      * for performance reason.
-     * 
+     *
      * @param pat the message pattern enum
      * @param args the format argument(s)
      * @return the formatted string
@@ -448,7 +448,7 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
             String patText;
             try {
                 ICUResourceBundle bundle = (ICUResourceBundle) ICUResourceBundle.getBundleInstance(
-                    ICUResourceBundle.ICU_ZONE_BASE_NAME, _locale);
+                    ICUData.ICU_ZONE_BASE_NAME, _locale);
                 patText = bundle.getStringWithFallback("zoneStrings/" + pat.key());
             } catch (MissingResourceException e) {
                 patText = pat.defaultValue();
@@ -464,7 +464,7 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
      * instance. Because LocaleDisplayNames is only used for generic
      * location formant and partial location format, the LocaleDisplayNames
      * is instantiated lazily.
-     * 
+     *
      * @return the instance of LocaleDisplayNames for the locale of this object.
      */
     private synchronized LocaleDisplayNames getLocaleDisplayNames() {
@@ -484,7 +484,7 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
             return;
         }
         // getGenericLocationName() formats a name and put it into the trie
-        getGenericLocationName(tzCanonicalID); 
+        getGenericLocationName(tzCanonicalID);
 
         // Generic partial location format
         Set<String> mzIDs = _tznames.getAvailableMetaZoneIDs(tzCanonicalID);
@@ -510,7 +510,7 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
      * the locale of this instance. When a generic name is coming from
      * a meta zone, this region is used for checking if the time zone
      * is a reference zone of the meta zone.
-     * 
+     *
      * @return the target region
      */
     private synchronized String getTargetRegion() {
@@ -531,7 +531,7 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
      * Private method for formatting partial location names. This format
      * is used when a generic name of a meta zone is available, but the given
      * time zone is not a reference zone (golden zone) of the meta zone.
-     * 
+     *
      * @param tzID the canonical time zone ID
      * @param mzID the meta zone ID
      * @param isLong true when long generic name
@@ -570,9 +570,8 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
         synchronized (this) {   // we have to sync the name map and the trie
             String tmp = _genericPartialLocationNamesMap.putIfAbsent(key.intern(), name.intern());
             if (tmp == null) {
-                NameInfo info = new NameInfo();
-                info.tzID = tzID.intern();
-                info.type = isLong ? GenericNameType.LONG : GenericNameType.SHORT;
+                NameInfo info = new NameInfo(tzID.intern(),
+                        isLong ? GenericNameType.LONG : GenericNameType.SHORT);
                 _gnamesTrie.put(name, info);
             } else {
                 name = tmp;
@@ -585,8 +584,13 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
      * A private class used for storing the name information in the local trie.
      */
     private static class NameInfo {
-        String tzID;
-        GenericNameType type;
+        final String tzID;
+        final GenericNameType type;
+
+        NameInfo(String tzID, GenericNameType type) {
+            this.tzID = tzID;
+            this.type = type;
+        }
     }
 
     /**
@@ -594,10 +598,21 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
      * {@link TimeZoneGenericNames#find(String, int, EnumSet)}.
      */
     public static class GenericMatchInfo {
-        GenericNameType nameType;
-        String tzID;
-        int matchLength;
-        TimeType timeType = TimeType.UNKNOWN;
+        final GenericNameType nameType;
+        final String tzID;
+        final int matchLength;
+        final TimeType timeType;
+
+        private GenericMatchInfo(GenericNameType nameType, String tzID, int matchLength) {
+            this(nameType, tzID, matchLength, TimeType.UNKNOWN);
+        }
+
+        private GenericMatchInfo(GenericNameType nameType, String tzID, int matchLength, TimeType timeType) {
+            this.nameType = nameType;
+            this.tzID = tzID;
+            this.matchLength = matchLength;
+            this.timeType = timeType;
+        }
 
         public GenericNameType nameType() {
             return nameType;
@@ -632,17 +647,14 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
         /* (non-Javadoc)
          * @see com.ibm.icu.impl.TextTrieMap.ResultHandler#handlePrefixMatch(int, java.util.Iterator)
          */
+        @Override
         public boolean handlePrefixMatch(int matchLength, Iterator<NameInfo> values) {
             while (values.hasNext()) {
                 NameInfo info = values.next();
                 if (_types != null && !_types.contains(info.type)) {
                     continue;
                 }
-                GenericMatchInfo matchInfo = new GenericMatchInfo();
-                matchInfo.tzID = info.tzID;
-                matchInfo.nameType = info.type;
-                matchInfo.matchLength = matchLength;
-                //matchInfo.timeType = TimeType.UNKNOWN;
+                GenericMatchInfo matchInfo = new GenericMatchInfo(info.type, info.tzID, matchLength);
                 if (_matches == null) {
                     _matches = new LinkedList<GenericMatchInfo>();
                 }
@@ -809,11 +821,7 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
         }
         assert(tzID != null);
 
-        GenericMatchInfo gmatch = new GenericMatchInfo();
-        gmatch.nameType = nameType;
-        gmatch.tzID = tzID;
-        gmatch.matchLength = matchInfo.matchLength();
-        gmatch.timeType = timeType;
+        GenericMatchInfo gmatch = new GenericMatchInfo(nameType, tzID, matchInfo.matchLength(), timeType);
 
         return gmatch;
     }
@@ -840,7 +848,7 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
             nameTypes.add(NameType.SHORT_GENERIC);
             nameTypes.add(NameType.SHORT_STANDARD);
         }
-        
+
         if (!nameTypes.isEmpty()) {
             // Find matches in the TimeZoneNames
             tznamesMatches = _tznames.find(text, start, nameTypes);
@@ -893,7 +901,7 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
         protected TimeZoneGenericNames createInstance(String key, ULocale data) {
             return new TimeZoneGenericNames(data).freeze();
         }
-        
+
     }
 
     /*
@@ -908,6 +916,7 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
     /**
      * {@inheritDoc}
      */
+    @Override
     public boolean isFrozen() {
         return _frozen;
     }
@@ -915,6 +924,7 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
     /**
      * {@inheritDoc}
      */
+    @Override
     public TimeZoneGenericNames freeze() {
         _frozen = true;
         return this;
@@ -923,6 +933,7 @@ public class TimeZoneGenericNames implements Serializable, Freezable<TimeZoneGen
     /**
      * {@inheritDoc}
      */
+    @Override
     public TimeZoneGenericNames cloneAsThawed() {
         TimeZoneGenericNames copy = null;
         try {
diff --git a/app/src/main/java/com/ibm/icu/impl/TimeZoneNamesFactoryImpl.java b/icu4j/src/main/java/com/ibm/icu/impl/TimeZoneNamesFactoryImpl.java
similarity index 87%
rename from app/src/main/java/com/ibm/icu/impl/TimeZoneNamesFactoryImpl.java
rename to icu4j/src/main/java/com/ibm/icu/impl/TimeZoneNamesFactoryImpl.java
index 3b426b9..b38d769 100644
--- a/app/src/main/java/com/ibm/icu/impl/TimeZoneNamesFactoryImpl.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/TimeZoneNamesFactoryImpl.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2011, International Business Machines Corporation and         *
diff --git a/app/src/main/java/com/ibm/icu/impl/TimeZoneNamesImpl.java b/icu4j/src/main/java/com/ibm/icu/impl/TimeZoneNamesImpl.java
similarity index 67%
rename from app/src/main/java/com/ibm/icu/impl/TimeZoneNamesImpl.java
rename to icu4j/src/main/java/com/ibm/icu/impl/TimeZoneNamesImpl.java
index 1e8d1cf..10cc8c2 100644
--- a/app/src/main/java/com/ibm/icu/impl/TimeZoneNamesImpl.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/TimeZoneNamesImpl.java
@@ -1,6 +1,8 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2011-2015, International Business Machines Corporation and
+ * Copyright (C) 2011-2016, International Business Machines Corporation and
  * others. All Rights Reserved.
  *******************************************************************************
  */
@@ -10,6 +12,7 @@ import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.ObjectOutputStream;
 import java.util.ArrayList;
+import java.util.Arrays;
 import java.util.Collection;
 import java.util.Collections;
 import java.util.EnumSet;
@@ -25,7 +28,6 @@ import java.util.concurrent.ConcurrentHashMap;
 import java.util.regex.Pattern;
 
 import com.ibm.icu.impl.TextTrieMap.ResultHandler;
-import com.ibm.icu.impl.UResource.TableSink;
 import com.ibm.icu.text.TimeZoneNames;
 import com.ibm.icu.util.TimeZone;
 import com.ibm.icu.util.TimeZone.SystemTimeZoneType;
@@ -41,7 +43,6 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
 
     private static final String ZONE_STRINGS_BUNDLE = "zoneStrings";
     private static final String MZ_PREFIX = "meta:";
-    private static final NameType[] NAME_TYPE_VALUES = NameType.values();
 
     private static volatile Set<String> METAZONE_IDS;
     private static final TZ2MZsCache TZ_TO_MZS_CACHE = new TZ2MZsCache();
@@ -76,7 +77,7 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
         if (METAZONE_IDS == null) {
             synchronized (TimeZoneNamesImpl.class) {
                 if (METAZONE_IDS == null) {
-                    UResourceBundle bundle = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, "metaZones");
+                    UResourceBundle bundle = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, "metaZones");
                     UResourceBundle mapTimezones = bundle.get("mapTimezones");
                     Set<String> keys = mapTimezones.keySet();
                     METAZONE_IDS = Collections.unmodifiableSet(keys);
@@ -165,7 +166,7 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
         if (mzID == null || mzID.length() == 0) {
             return null;
         }
-        return loadMetaZoneNames(null, mzID).getName(type);
+        return loadMetaZoneNames(mzID).getName(type);
     }
 
     /*
@@ -177,7 +178,7 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
         if (tzID == null || tzID.length() == 0) {
             return null;
         }
-        return loadTimeZoneNames(null, tzID).getName(type);
+        return loadTimeZoneNames(tzID).getName(type);
     }
 
     /* (non-Javadoc)
@@ -188,7 +189,7 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
         if (tzID == null || tzID.length() == 0) {
             return null;
         }
-        String locName = loadTimeZoneNames(null, tzID).getName(NameType.EXEMPLAR_LOCATION);
+        String locName = loadTimeZoneNames(tzID).getName(NameType.EXEMPLAR_LOCATION);
         return locName;
     }
 
@@ -201,10 +202,12 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
             throw new IllegalArgumentException("bad input text or range");
         }
         NameSearchHandler handler = new NameSearchHandler(nameTypes);
-        _namesTrie.find(text, start, handler);
-        if (handler.getMaxMatchLen() == (text.length() - start) || _namesTrieFullyLoaded) {
-            // perfect match, or no more names available
-            return handler.getMatches();
+        Collection<MatchInfo> matches;
+
+        // First try of lookup.
+        matches = doFind(handler, text, start);
+        if (matches != null) {
+            return matches;
         }
 
         // All names are not yet loaded into the trie.
@@ -212,34 +215,40 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
         // and might be parsing one of those.
         // Populate the parsing trie from all of the already-loaded names.
         addAllNamesIntoTrie();
-        handler.resetResults();
-        _namesTrie.find(text, start, handler);
-        if (handler.getMaxMatchLen() == (text.length() - start)) {
-            // perfect match
-            return handler.getMatches();
+
+        // Second try of lookup.
+        matches = doFind(handler, text, start);
+        if (matches != null) {
+            return matches;
         }
 
-        // Still no match, load all names.
+        // There are still some names we haven't loaded into the trie yet.
+        // Load everything now.
         internalLoadAllDisplayNames();
-        addAllNamesIntoTrie();
 
         // Set default time zone location names
         // for time zones without explicit display names.
+        // TODO: Should this logic be moved into internalLoadAllDisplayNames?
         Set<String> tzIDs = TimeZone.getAvailableIDs(SystemTimeZoneType.CANONICAL, null, null);
         for (String tzID : tzIDs) {
             if (!_tzNamesMap.containsKey(tzID)) {
-                tzID = tzID.intern();
-                ZNames tznames = ZNames.getInstance(null, tzID);
-                tznames.addNamesIntoTrie(null, tzID, _namesTrie);
-                _tzNamesMap.put(tzID, tznames);
+                ZNames.createTimeZoneAndPutInCache(_tzNamesMap, null, tzID);
             }
         }
+        addAllNamesIntoTrie();
         _namesTrieFullyLoaded = true;
 
-        // now, try it again
+        // Third try: we must return this one.
+        return doFind(handler, text, start);
+    }
+
+    private Collection<MatchInfo> doFind(NameSearchHandler handler, CharSequence text, int start) {
         handler.resetResults();
         _namesTrie.find(text, start, handler);
-        return handler.getMatches();
+        if (handler.getMaxMatchLen() == (text.length() - start) || _namesTrieFullyLoaded) {
+            return handler.getMatches();
+        }
+        return null;
     }
 
     @Override
@@ -253,7 +262,7 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
         if (tzID == null || tzID.length() == 0) {
             return;
         }
-        ZNames tzNames = loadTimeZoneNames(null, tzID);
+        ZNames tzNames = loadTimeZoneNames(tzID);
         ZNames mzNames = null;
         for (int i = 0; i < types.length; ++i) {
             NameType type = types[i];
@@ -264,7 +273,7 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
                     if (mzID == null || mzID.length() == 0) {
                         mzNames = ZNames.EMPTY_ZNAMES;
                     } else {
-                        mzNames = loadMetaZoneNames(null, mzID);
+                        mzNames = loadMetaZoneNames(mzID);
                     }
                 }
                 name = mzNames.getName(type);
@@ -276,25 +285,25 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
     /** Caller must synchronize. */
     private void internalLoadAllDisplayNames() {
         if (!_namesFullyLoaded) {
-            new ZoneStringsLoader().load();
             _namesFullyLoaded = true;
+            new ZoneStringsLoader().load();
         }
     }
 
     /** Caller must synchronize. */
     private void addAllNamesIntoTrie() {
         for (Map.Entry<String, ZNames> entry : _tzNamesMap.entrySet()) {
-            entry.getValue().addNamesIntoTrie(null, entry.getKey(), _namesTrie);
+            entry.getValue().addAsTimeZoneIntoTrie(entry.getKey(), _namesTrie);
         }
         for (Map.Entry<String, ZNames> entry : _mzNamesMap.entrySet()) {
-            entry.getValue().addNamesIntoTrie(entry.getKey(), null, _namesTrie);
+            entry.getValue().addAsMetaZoneIntoTrie(entry.getKey(), _namesTrie);
         }
     }
 
     /**
      * Loads all meta zone and time zone names for this TimeZoneNames' locale.
      */
-    private final class ZoneStringsLoader extends UResource.TableSink {
+    private final class ZoneStringsLoader extends UResource.Sink {
         /**
          * Prepare for several hundred time zones and meta zones.
          * _zoneStrings.getSize() is ineffective in a sparsely populated locale like en-GB.
@@ -306,62 +315,75 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
 
         /** Caller must synchronize. */
         void load() {
-            _zoneStrings.getAllTableItemsWithFallback("", this);
+            _zoneStrings.getAllItemsWithFallback("", this);
             for (Map.Entry<UResource.Key, ZNamesLoader> entry : keyToLoader.entrySet()) {
-                UResource.Key key = entry.getKey();
                 ZNamesLoader loader = entry.getValue();
-                if (loader == ZNamesLoader.DUMMY_LOADER) {
-                    // skip
-                } else if (key.startsWith(MZ_PREFIX)) {
-                    String mzID = mzIDFromKey(key).intern();
-                    ZNames mzNames = ZNames.getInstance(loader.getNames(), null);
-                    _mzNamesMap.put(mzID, mzNames);
+                if (loader == ZNamesLoader.DUMMY_LOADER) { continue; }
+                UResource.Key key = entry.getKey();
+
+                if (isMetaZone(key)) {
+                    String mzID = mzIDFromKey(key);
+                    ZNames.createMetaZoneAndPutInCache(_mzNamesMap, loader.getNames(), mzID);
                 } else {
-                    String tzID = tzIDFromKey(key).intern();
-                    ZNames tzNames = ZNames.getInstance(loader.getNames(), tzID);
-                    _tzNamesMap.put(tzID, tzNames);
+                    String tzID = tzIDFromKey(key);
+                    ZNames.createTimeZoneAndPutInCache(_tzNamesMap, loader.getNames(), tzID);
                 }
             }
         }
 
         @Override
-        public TableSink getOrCreateTableSink(UResource.Key key, int initialSize) {
-            ZNamesLoader loader = keyToLoader.get(key);
-            if (loader != null) {
-                if (loader == ZNamesLoader.DUMMY_LOADER) {
-                    return null;
-                }
-                return loader;
-            }
-            ZNamesLoader result = null;
-            if (key.startsWith(MZ_PREFIX)) {
-                String mzID = mzIDFromKey(key);
-                if (_mzNamesMap.containsKey(mzID)) {
-                    // We have already loaded the names for this meta zone.
-                    loader = ZNamesLoader.DUMMY_LOADER;
+        public void put(UResource.Key key, UResource.Value value, boolean noFallback) {
+            UResource.Table timeZonesTable = value.getTable();
+            for (int j = 0; timeZonesTable.getKeyAndValue(j, key, value); ++j) {
+                assert !value.isNoInheritanceMarker();
+                if (value.getType() == UResourceBundle.TABLE) {
+                    consumeNamesTable(key, value, noFallback);
                 } else {
-                    result = loader = ZNamesLoader.forMetaZoneNames();
+                    // Ignore fields that aren't tables (e.g., fallbackFormat and regionFormatStandard).
+                    // All time zone fields are tables.
                 }
-            } else {
-                String tzID = tzIDFromKey(key);
-                if (_tzNamesMap.containsKey(tzID)) {
-                    // We have already loaded the names for this time zone.
-                    loader = ZNamesLoader.DUMMY_LOADER;
+            }
+        }
+
+        private void consumeNamesTable(UResource.Key key, UResource.Value value, boolean noFallback) {
+            ZNamesLoader loader = keyToLoader.get(key);
+            if (loader == null) {
+                if (isMetaZone(key)) {
+                    String mzID = mzIDFromKey(key);
+                    if (_mzNamesMap.containsKey(mzID)) {
+                        // We have already loaded the names for this meta zone.
+                        loader = ZNamesLoader.DUMMY_LOADER;
+                    } else {
+                        loader = new ZNamesLoader();
+                    }
                 } else {
-                    result = loader = ZNamesLoader.forTimeZoneNames();
+                    String tzID = tzIDFromKey(key);
+                    if (_tzNamesMap.containsKey(tzID)) {
+                        // We have already loaded the names for this time zone.
+                        loader = ZNamesLoader.DUMMY_LOADER;
+                    } else {
+                        loader = new ZNamesLoader();
+                    }
                 }
+
+                UResource.Key newKey = createKey(key);
+                keyToLoader.put(newKey, loader);
             }
-            keyToLoader.put(key.clone(), loader);
-            return result;
-        }
 
-        @Override
-        public void putNoFallback(UResource.Key key) {
-            if (!keyToLoader.containsKey(key)) {
-                keyToLoader.put(key.clone(), ZNamesLoader.DUMMY_LOADER);
+            if (loader != ZNamesLoader.DUMMY_LOADER) {
+                // Let the ZNamesLoader consume the names table.
+                loader.put(key, value, noFallback);
             }
         }
 
+        UResource.Key createKey(UResource.Key key) {
+            return key.clone();
+        }
+
+        boolean isMetaZone(UResource.Key key) {
+            return key.startsWith(MZ_PREFIX);
+        }
+
         /**
          * Equivalent to key.substring(MZ_PREFIX.length())
          * except reuses our StringBuilder.
@@ -390,12 +412,12 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
     /**
      * Initialize the transient fields, called from the constructor and
      * readObject.
-     * 
+     *
      * @param locale The locale
      */
     private void initialize(ULocale locale) {
         ICUResourceBundle bundle = (ICUResourceBundle)ICUResourceBundle.getBundleInstance(
-                ICUResourceBundle.ICU_ZONE_BASE_NAME, locale);
+                ICUData.ICU_ZONE_BASE_NAME, locale);
         _zoneStrings = (ICUResourceBundle)bundle.get(ZONE_STRINGS_BUNDLE);
 
         // TODO: Access is synchronized, can we use a non-concurrent map?
@@ -424,14 +446,12 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
         if (tzCanonicalID == null || tzCanonicalID.length() == 0) {
             return;
         }
-        loadTimeZoneNames(null, tzCanonicalID);
+        loadTimeZoneNames(tzCanonicalID);
 
-        ZNamesLoader loader = ZNamesLoader.forMetaZoneNames();
         Set<String> mzIDs = getAvailableMetaZoneIDs(tzCanonicalID);
         for (String mzID : mzIDs) {
-            loadMetaZoneNames(loader, mzID);
+            loadMetaZoneNames(mzID);
         }
-        addAllNamesIntoTrie();
     }
 
     /*
@@ -458,40 +478,28 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
      * @param mzID the meta zone ID
      * @return An instance of ZNames that includes a set of meta zone display names.
      */
-    private synchronized ZNames loadMetaZoneNames(ZNamesLoader loader, String mzID) {
-        ZNames znames = _mzNamesMap.get(mzID);
-        if (znames == null) {
-            if (loader == null) {
-                loader = ZNamesLoader.forMetaZoneNames();
-            }
-            znames = ZNames.getInstance(loader, _zoneStrings, MZ_PREFIX + mzID, null);
-            mzID = mzID.intern();
-            if (_namesTrieFullyLoaded) {
-                znames.addNamesIntoTrie(mzID, null, _namesTrie);
-            }
-            _mzNamesMap.put(mzID, znames);
+    private synchronized ZNames loadMetaZoneNames(String mzID) {
+        ZNames mznames = _mzNamesMap.get(mzID);
+        if (mznames == null) {
+            ZNamesLoader loader = new ZNamesLoader();
+            loader.loadMetaZone(_zoneStrings, mzID);
+            mznames = ZNames.createMetaZoneAndPutInCache(_mzNamesMap, loader.getNames(), mzID);
         }
-        return znames;
+        return mznames;
     }
 
     /**
      * Returns a set of names for the given time zone ID. This method loads
      * the set of names into the internal map and trie for future references.
      * @param tzID the canonical time zone ID
-     * @return An instance of TZNames that includes a set of time zone display names.
+     * @return An instance of ZNames that includes a set of time zone display names.
      */
-    private synchronized ZNames loadTimeZoneNames(ZNamesLoader loader, String tzID) {
+    private synchronized ZNames loadTimeZoneNames(String tzID) {
         ZNames tznames = _tzNamesMap.get(tzID);
         if (tznames == null) {
-            if (loader == null) {
-                loader = ZNamesLoader.forTimeZoneNames();
-            }
-            tznames = ZNames.getInstance(loader, _zoneStrings, tzID.replace('/', ':'), tzID);
-            tzID = tzID.intern();
-            if (_namesTrieFullyLoaded) {
-                tznames.addNamesIntoTrie(null, tzID, _namesTrie);
-            }
-            _tzNamesMap.put(tzID, tznames);
+            ZNamesLoader loader = new ZNamesLoader();
+            loader.loadTimeZone(_zoneStrings, tzID);
+            tznames = ZNames.createTimeZoneAndPutInCache(_tzNamesMap, loader.getNames(), tzID);
         }
         return tznames;
     }
@@ -520,6 +528,7 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
         /* (non-Javadoc)
          * @see com.ibm.icu.impl.TextTrieMap.ResultHandler#handlePrefixMatch(int, java.util.Iterator)
          */
+        @Override
         public boolean handlePrefixMatch(int matchLength, Iterator<NameInfo> values) {
             while (values.hasNext()) {
                 NameInfo ninfo = values.next();
@@ -572,47 +581,38 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
         }
     }
 
-    private static final class ZNamesLoader extends UResource.TableSink {
-        private static int NUM_META_ZONE_NAMES = 6;
-        private static int NUM_TIME_ZONE_NAMES = 7;  // incl. EXEMPLAR_LOCATION
-
-        private static String NO_NAME = "";
+    private static final class ZNamesLoader extends UResource.Sink {
+        private String[] names;
 
         /**
          * Does not load any names, for no-fallback handling.
          */
-        private static ZNamesLoader DUMMY_LOADER = new ZNamesLoader(0);
+        private static ZNamesLoader DUMMY_LOADER = new ZNamesLoader();
 
-        private String[] names;
-        private int numNames;
-
-        private ZNamesLoader(int numNames) {
-            this.numNames = numNames;
-        }
-
-        static ZNamesLoader forMetaZoneNames() {
-            return new ZNamesLoader(NUM_META_ZONE_NAMES);
+        void loadMetaZone(ICUResourceBundle zoneStrings, String mzID) {
+            String key = MZ_PREFIX + mzID;
+            loadNames(zoneStrings, key);
         }
 
-        static ZNamesLoader forTimeZoneNames() {
-            return new ZNamesLoader(NUM_TIME_ZONE_NAMES);
+        void loadTimeZone(ICUResourceBundle zoneStrings, String tzID) {
+            String key = tzID.replace('/', ':');
+            loadNames(zoneStrings, key);
         }
 
-        String[] load(ICUResourceBundle zoneStrings, String key) {
-            if (zoneStrings == null || key == null || key.length() == 0) {
-                return null;
-            }
+        void loadNames(ICUResourceBundle zoneStrings, String key) {
+            assert zoneStrings != null;
+            assert key != null;
+            assert key.length() > 0;
 
+            // Reset names so that this instance can be used to load data multiple times.
+            names = null;
             try {
-                zoneStrings.getAllTableItemsWithFallback(key, this);
+                zoneStrings.getAllItemsWithFallback(key, this);
             } catch (MissingResourceException e) {
-                return null;
             }
-
-            return getNames();
         }
 
-        private static NameType nameTypeFromKey(UResource.Key key) {
+        private static ZNames.NameTypeIndex nameTypeIndexFromKey(UResource.Key key) {
             // Avoid key.toString() object creation.
             if (key.length() != 2) {
                 return null;
@@ -620,77 +620,68 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
             char c0 = key.charAt(0);
             char c1 = key.charAt(1);
             if (c0 == 'l') {
-                return c1 == 'g' ? NameType.LONG_GENERIC :
-                        c1 == 's' ? NameType.LONG_STANDARD :
-                            c1 == 'd' ? NameType.LONG_DAYLIGHT : null;
+                return c1 == 'g' ? ZNames.NameTypeIndex.LONG_GENERIC :
+                        c1 == 's' ? ZNames.NameTypeIndex.LONG_STANDARD :
+                            c1 == 'd' ? ZNames.NameTypeIndex.LONG_DAYLIGHT : null;
             } else if (c0 == 's') {
-                return c1 == 'g' ? NameType.SHORT_GENERIC :
-                        c1 == 's' ? NameType.SHORT_STANDARD :
-                            c1 == 'd' ? NameType.SHORT_DAYLIGHT : null;
+                return c1 == 'g' ? ZNames.NameTypeIndex.SHORT_GENERIC :
+                        c1 == 's' ? ZNames.NameTypeIndex.SHORT_STANDARD :
+                            c1 == 'd' ? ZNames.NameTypeIndex.SHORT_DAYLIGHT : null;
             } else if (c0 == 'e' && c1 == 'c') {
-                return NameType.EXEMPLAR_LOCATION;
+                return ZNames.NameTypeIndex.EXEMPLAR_LOCATION;
             }
             return null;
         }
 
-        @Override
-        public void put(UResource.Key key, UResource.Value value) {
-            if (value.getType() == UResourceBundle.STRING) {
-                if (names == null) {
-                    names = new String[numNames];
-                }
-                NameType type = nameTypeFromKey(key);
-                if (type != null && type.ordinal() < numNames && names[type.ordinal()] == null) {
-                    names[type.ordinal()] = value.getString();
-                }
+        private void setNameIfEmpty(UResource.Key key, UResource.Value value) {
+            if (names == null) {
+                names = new String[ZNames.NUM_NAME_TYPES];
+            }
+            ZNames.NameTypeIndex index = nameTypeIndexFromKey(key);
+            if (index == null) { return; }
+            assert index.ordinal() < ZNames.NUM_NAME_TYPES;
+            if (names[index.ordinal()] == null) {
+                names[index.ordinal()] = value.getString();
             }
         }
 
         @Override
-        public void putNoFallback(UResource.Key key) {
-            if (names == null) {
-                names = new String[numNames];
-            }
-            NameType type = nameTypeFromKey(key);
-            if (type != null && type.ordinal() < numNames && names[type.ordinal()] == null) {
-                names[type.ordinal()] = NO_NAME;
+        public void put(UResource.Key key, UResource.Value value, boolean noFallback) {
+            UResource.Table namesTable = value.getTable();
+            for (int i = 0; namesTable.getKeyAndValue(i, key, value); ++i) {
+                assert value.getType() == UResourceBundle.STRING;
+                setNameIfEmpty(key, value);  // could be value.isNoInheritanceMarker()
             }
         }
 
         private String[] getNames() {
-            if (names == null) {
+            if (Utility.sameObjects(names, null)) {
                 return null;
             }
             int length = 0;
-            for (int i = 0; i < numNames; ++i) {
+            for (int i = 0; i < ZNames.NUM_NAME_TYPES; ++i) {
                 String name = names[i];
                 if (name != null) {
-                    if (name == NO_NAME) {
+                    if (name.equals(ICUResourceBundle.NO_INHERITANCE_MARKER)) {
                         names[i] = null;
                     } else {
                         length = i + 1;
                     }
                 }
             }
-            if (length == 0) {
-                return null;
-            }
-            if (length == numNames || numNames == NUM_TIME_ZONE_NAMES) {
+
+            String[] result;
+            if (length == ZNames.NUM_NAME_TYPES) {
                 // Return the full array if the last name is set.
-                // Also return the full *time* zone names array,
-                // so that the exemplar location can be set.
-                String[] result = names;
-                names = null;
-                return result;
-            }
-            // Return a shorter array for permanent storage.
-            // *Move* all names into a minimal array.
-            String[] result = new String[length];
-            do {
-                --length;
-                result[length] = names[length];
-                names[length] = null;  // Reset for loading another set of names.
-            } while (length > 0);
+                result = names;
+            } else if (length == 0) {
+                // Return null instead of a zero-length array.
+                result = null;
+            } else {
+                // Return a shorter array for permanent storage.
+                // Copy all names into the minimal array.
+                result = Arrays.copyOfRange(names, 0, length);
+            }
             return result;
         }
     }
@@ -699,9 +690,63 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
      * This class stores name data for a meta zone or time zone.
      */
     private static class ZNames {
-        private static final ZNames EMPTY_ZNAMES = new ZNames(null);
+        /**
+         * Private enum corresponding to the public TimeZoneNames::NameType for the order in
+         * which fields are stored in a ZNames instance.  EXEMPLAR_LOCATION is stored first
+         * for efficiency.
+         */
+        private static enum NameTypeIndex {
+            EXEMPLAR_LOCATION, LONG_GENERIC, LONG_STANDARD, LONG_DAYLIGHT, SHORT_GENERIC, SHORT_STANDARD, SHORT_DAYLIGHT;
+            static final NameTypeIndex values[] = values();
+        };
+
+        public static final int NUM_NAME_TYPES = 7;
+
+        private static int getNameTypeIndex(NameType type) {
+            switch (type) {
+            case EXEMPLAR_LOCATION:
+                return NameTypeIndex.EXEMPLAR_LOCATION.ordinal();
+            case LONG_GENERIC:
+                return NameTypeIndex.LONG_GENERIC.ordinal();
+            case LONG_STANDARD:
+                return NameTypeIndex.LONG_STANDARD.ordinal();
+            case LONG_DAYLIGHT:
+                return NameTypeIndex.LONG_DAYLIGHT.ordinal();
+            case SHORT_GENERIC:
+                return NameTypeIndex.SHORT_GENERIC.ordinal();
+            case SHORT_STANDARD:
+                return NameTypeIndex.SHORT_STANDARD.ordinal();
+            case SHORT_DAYLIGHT:
+                return NameTypeIndex.SHORT_DAYLIGHT.ordinal();
+            default:
+                throw new AssertionError("No NameTypeIndex match for " + type);
+            }
+        }
+
+        private static NameType getNameType(int index) {
+            switch (NameTypeIndex.values[index]) {
+            case EXEMPLAR_LOCATION:
+                return NameType.EXEMPLAR_LOCATION;
+            case LONG_GENERIC:
+                return NameType.LONG_GENERIC;
+            case LONG_STANDARD:
+                return NameType.LONG_STANDARD;
+            case LONG_DAYLIGHT:
+                return NameType.LONG_DAYLIGHT;
+            case SHORT_GENERIC:
+                return NameType.SHORT_GENERIC;
+            case SHORT_STANDARD:
+                return NameType.SHORT_STANDARD;
+            case SHORT_DAYLIGHT:
+                return NameType.SHORT_DAYLIGHT;
+            default:
+                throw new AssertionError("No NameType match for " + index);
+            }
+        }
+
+        static final ZNames EMPTY_ZNAMES = new ZNames(null);
         // A meta zone names instance never has an exemplar location string.
-        private static final int EX_LOC_INDEX = NameType.EXEMPLAR_LOCATION.ordinal();
+        private static final int EX_LOC_INDEX = NameTypeIndex.EXEMPLAR_LOCATION.ordinal();
 
         private String[] _names;
         private boolean didAddIntoTrie;
@@ -711,51 +756,67 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
             didAddIntoTrie = names == null;
         }
 
-        public static ZNames getInstance(String[] names, String tzID) {
-            if (tzID != null && (names == null || names[EX_LOC_INDEX] == null)) {
-                String locationName = getDefaultExemplarLocationName(tzID);
-                if (locationName != null) {
-                    if (names == null) {
-                        names = new String[EX_LOC_INDEX + 1];
-                    }
-                    names[EX_LOC_INDEX] = locationName;
-                }
-            }
-
+        public static ZNames createMetaZoneAndPutInCache(Map<String, ZNames> cache,
+                String[] names, String mzID) {
+            String key = mzID.intern();
+            ZNames value;
             if (names == null) {
-                return EMPTY_ZNAMES;
+                value = EMPTY_ZNAMES;
+            } else {
+                value = new ZNames(names);
             }
-            return new ZNames(names);
+            cache.put(key, value);
+            return value;
         }
 
-        public static ZNames getInstance(ZNamesLoader loader,
-                ICUResourceBundle zoneStrings, String key, String tzID) {
-            return getInstance(loader.load(zoneStrings, key), tzID);
+        public static ZNames createTimeZoneAndPutInCache(Map<String, ZNames> cache,
+                String[] names, String tzID) {
+            // For time zones, check that the exemplar city name is populated.  If necessary, use
+            // "getDefaultExemplarLocationName" to extract it from the time zone name.
+            names = (names == null) ? new String[EX_LOC_INDEX + 1] : names;
+            if (names[EX_LOC_INDEX] == null) {
+                names[EX_LOC_INDEX] = getDefaultExemplarLocationName(tzID);
+            }
+
+            String key = tzID.intern();
+            ZNames value = new ZNames(names);
+            cache.put(key, value);
+            return value;
         }
 
         public String getName(NameType type) {
-            if (_names != null && type.ordinal() < _names.length) {
-                return _names[type.ordinal()];
+            int index = getNameTypeIndex(type);
+            if (_names != null && index < _names.length) {
+                return _names[index];
             } else {
                 return null;
             }
         }
 
-        public void addNamesIntoTrie(String mzID, String tzID, TextTrieMap<NameInfo> trie) {
+        public void addAsMetaZoneIntoTrie(String mzID, TextTrieMap<NameInfo> trie) {
+            addNamesIntoTrie(mzID, null, trie);
+        }
+
+        public void addAsTimeZoneIntoTrie(String tzID, TextTrieMap<NameInfo> trie) {
+            addNamesIntoTrie(null, tzID, trie);
+        }
+
+        private void addNamesIntoTrie(String mzID, String tzID, TextTrieMap<NameInfo> trie) {
             if (_names == null || didAddIntoTrie) {
                 return;
             }
-            for (int i = 0; i < _names.length; ++ i) {
+            didAddIntoTrie = true;
+
+            for (int i = 0; i < _names.length; ++i) {
                 String name = _names[i];
                 if (name != null) {
                     NameInfo info = new NameInfo();
                     info.mzID = mzID;
                     info.tzID = tzID;
-                    info.type = NAME_TYPE_VALUES[i];
+                    info.type = getNameType(i);
                     trie.put(name, info);
                 }
             }
-            didAddIntoTrie = true;
         }
     }
 
@@ -795,7 +856,7 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
         protected List<MZMapEntry> createInstance(String key, String data) {
             List<MZMapEntry> mzMaps = null;
 
-            UResourceBundle bundle = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, "metaZones");
+            UResourceBundle bundle = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, "metaZones");
             UResourceBundle metazoneInfoBundle = bundle.get("metazoneInfo");
 
             String tzkey = data.replace('/', ':');
@@ -827,7 +888,7 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
         /**
          * Private static method parsing the date text used by meta zone to
          * time zone mapping data in locale resource.
-         * 
+         *
          * @param text the UTC date text in the format of "yyyy-MM-dd HH:mm",
          * for example - "1970-01-01 00:00"
          * @return the date
@@ -902,7 +963,7 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
         protected Map<String, String> createInstance(String key, String data) {
             Map<String, String> map = null;
 
-            UResourceBundle bundle = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, "metaZones");
+            UResourceBundle bundle = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, "metaZones");
             UResourceBundle mapTimezones = bundle.get("mapTimezones");
 
             try {
@@ -925,7 +986,8 @@ public class TimeZoneNamesImpl extends TimeZoneNames {
     private static final Pattern LOC_EXCLUSION_PATTERN = Pattern.compile("Etc/.*|SystemV/.*|.*/Riyadh8[7-9]");
 
     /**
-     * Default exemplar location name based on time zone ID
+     * Default exemplar location name based on time zone ID.
+     * For example, "America/New_York" -> "New York"
      * @param tzID the time zone ID
      * @return the exemplar location name or null if location is not available.
      */
diff --git a/app/src/main/java/com/ibm/icu/impl/Trie.java b/icu4j/src/main/java/com/ibm/icu/impl/Trie.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/impl/Trie.java
rename to icu4j/src/main/java/com/ibm/icu/impl/Trie.java
index 5c62a88..ee18cc3 100644
--- a/app/src/main/java/com/ibm/icu/impl/Trie.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/Trie.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ******************************************************************************
  * Copyright (C) 1996-2015, International Business Machines Corporation and
@@ -14,9 +16,9 @@ import com.ibm.icu.lang.UCharacter;
 import com.ibm.icu.text.UTF16;
 
 /**
- * <p>A trie is a kind of compressed, serializable table of values 
+ * <p>A trie is a kind of compressed, serializable table of values
  * associated with Unicode code points (0..0x10ffff).</p>
- * <p>This class defines the basic structure of a trie and provides methods 
+ * <p>This class defines the basic structure of a trie and provides methods
  * to <b>retrieve the offsets to the actual data</b>.</p>
  * <p>Data will be the form of an array of basic types, char or int.</p>
  * <p>The actual data format will have to be specified by the user in the
@@ -33,9 +35,9 @@ import com.ibm.icu.text.UTF16;
  * to the fromOffsetTrail() methods.
  * To handle such supplementary codepoints, some offset information are kept
  * in the data.</p>
- * <p>Methods in com.ibm.icu.impl.Trie.DataManipulate are called to retrieve 
+ * <p>Methods in com.ibm.icu.impl.Trie.DataManipulate are called to retrieve
  * that offset from the folded value for the lead surrogate unit.</p>
- * <p>For examples of use, see com.ibm.icu.impl.CharTrie or 
+ * <p>For examples of use, see com.ibm.icu.impl.CharTrie or
  * com.ibm.icu.impl.IntTrie.</p>
  * @author synwee
  * @see com.ibm.icu.impl.CharTrie
@@ -45,36 +47,37 @@ import com.ibm.icu.text.UTF16;
 public abstract class Trie
 {
     // public class declaration ----------------------------------------
-    
+
     /**
     * Character data in com.ibm.impl.Trie have different user-specified format
     * for different purposes.
     * This interface specifies methods to be implemented in order for
-    * com.ibm.impl.Trie, to surrogate offset information encapsulated within 
+    * com.ibm.impl.Trie, to surrogate offset information encapsulated within
     * the data.
     */
     public static interface DataManipulate
     {
         /**
-        * Called by com.ibm.icu.impl.Trie to extract from a lead surrogate's 
+        * Called by com.ibm.icu.impl.Trie to extract from a lead surrogate's
         * data
         * the index array offset of the indexes for that lead surrogate.
         * @param value data value for a surrogate from the trie, including the
         *        folding offset
         * @return data offset or 0 if there is no data for the lead surrogate
         */
-        public int getFoldingOffset(int value); 
+        public int getFoldingOffset(int value);
     }
 
     // default implementation
     private static class DefaultGetFoldingOffset implements DataManipulate {
+        @Override
         public int getFoldingOffset(int value) {
-            return value; 
+            return value;
         }
     }
 
     // public methods --------------------------------------------------
-    
+
     /**
      * Determines if this trie has a linear latin 1 array
      * @return true if this trie has a linear latin 1 array, false otherwise
@@ -83,7 +86,7 @@ public abstract class Trie
     {
         return m_isLatin1Linear_;
     }
-    
+
     /**
      * Checks if the argument Trie has the same data as this Trie.
      * Attributes are checked but not the index data.
@@ -92,7 +95,8 @@ public abstract class Trie
      *         otherwise
      */
     ///CLOVER:OFF
-    public boolean equals(Object other) 
+    @Override
+    public boolean equals(Object other)
     {
         if (other == this) {
             return true;
@@ -106,16 +110,17 @@ public abstract class Trie
                && m_dataLength_ == othertrie.m_dataLength_
                && Arrays.equals(m_index_, othertrie.m_index_);
     }
-    
+
+    @Override
     public int hashCode() {
         assert false : "hashCode not designed";
         return 42;
     }
     ///CLOVER:ON
-    
+
     /**
-     * Gets the serialized data file size of the Trie. This is used during 
-     * trie data reading for size checking purposes. 
+     * Gets the serialized data file size of the Trie. This is used during
+     * trie data reading for size checking purposes.
      * @return size size of serialized trie data file in terms of the number
      *              of bytes
      */
@@ -167,7 +172,7 @@ public abstract class Trie
     * Trie constructor
     * @param index array to be used for index
     * @param options used by the trie
-    * @param dataManipulate object containing the information to parse the 
+    * @param dataManipulate object containing the information to parse the
     *                       trie data
     */
     protected Trie(char index[], int options, DataManipulate dataManipulate)
@@ -229,7 +234,7 @@ public abstract class Trie
     * Surrogate mask to use when shifting offset to retrieve supplementary
     * values
     */
-    protected static final int SURROGATE_MASK_ = 0x3FF;                                              
+    protected static final int SURROGATE_MASK_ = 0x3FF;
     /**
     * Index or UTF16 characters
     */
@@ -240,17 +245,17 @@ public abstract class Trie
     */
     protected DataManipulate m_dataManipulate_;
     /**
-    * Start index of the data portion of the trie. CharTrie combines 
-    * index and data into a char array, so this is used to indicate the 
+    * Start index of the data portion of the trie. CharTrie combines
+    * index and data into a char array, so this is used to indicate the
     * initial offset to the data portion.
     * Note this index always points to the initial value.
     */
     protected int m_dataOffset_;
     /**
-    * Length of the data array 
+    * Length of the data array
     */
     protected int m_dataLength_;
-     
+
     // protected methods -----------------------------------------------
 
     /**
@@ -260,20 +265,20 @@ public abstract class Trie
     * @return offset to data
     */
     protected abstract int getSurrogateOffset(char lead, char trail);
-    
+
     /**
     * Gets the value at the argument index
     * @param index value at index will be retrieved
-    * @return 32 bit value 
+    * @return 32 bit value
     */
     protected abstract int getValue(int index);
 
     /**
     * Gets the default initial value
-    * @return 32 bit value 
+    * @return 32 bit value
     */
     protected abstract int getInitialValue();
-    
+
     /**
     * Gets the offset to the data which the index ch after variable offset
     * points to.
@@ -290,11 +295,11 @@ public abstract class Trie
     */
     protected final int getRawOffset(int offset, char ch)
     {
-        return (m_index_[offset + (ch >> INDEX_STAGE_1_SHIFT_)] 
-                << INDEX_STAGE_2_SHIFT_) 
+        return (m_index_[offset + (ch >> INDEX_STAGE_1_SHIFT_)]
+                << INDEX_STAGE_2_SHIFT_)
                 + (ch & INDEX_STAGE_3_MASK_);
     }
-    
+
     /**
     * Gets the offset to data which the BMP character points to
     * Treats a lead surrogate as a normal code point.
@@ -303,10 +308,10 @@ public abstract class Trie
     */
     protected final int getBMPOffset(char ch)
     {
-        return (ch >= UTF16.LEAD_SURROGATE_MIN_VALUE 
-                && ch <= UTF16.LEAD_SURROGATE_MAX_VALUE) 
+        return (ch >= UTF16.LEAD_SURROGATE_MIN_VALUE
+                && ch <= UTF16.LEAD_SURROGATE_MAX_VALUE)
                 ? getRawOffset(LEAD_INDEX_OFFSET_, ch)
-                : getRawOffset(0, ch); 
+                : getRawOffset(0, ch);
                 // using a getRawOffset(ch) makes no diff
     }
 
@@ -341,14 +346,14 @@ public abstract class Trie
             return getRawOffset(0, (char)ch);
         } else if (ch < UTF16.SUPPLEMENTARY_MIN_VALUE) {
             // BMP codepoint
-            return getBMPOffset((char)ch); 
+            return getBMPOffset((char)ch);
         } else if (ch <= UCharacter.MAX_VALUE) {
             // look at the construction of supplementary characters
             // trail forms the ends of it.
-            return getSurrogateOffset(UTF16.getLeadSurrogate(ch), 
+            return getSurrogateOffset(UTF16.getLeadSurrogate(ch),
                                       (char)(ch & SURROGATE_MASK_));
         } else {
-            // return -1 if there is an error, in this case we return 
+            // return -1 if there is an error, in this case we return
             return -1;
         }
     }
@@ -408,12 +413,12 @@ public abstract class Trie
     private static final int HEADER_OPTIONS_SHIFT_MASK_ = 0xF;
     protected static final int HEADER_OPTIONS_INDEX_SHIFT_ = 4;
     protected static final int HEADER_OPTIONS_DATA_IS_32_BIT_ = 0x100;
-    
+
     /**
     * Flag indicator for Latin quick access data block
     */
     private boolean m_isLatin1Linear_;
-    
+
     /**
     * <p>Trie options field.</p>
     * <p>options bit field:<br>
@@ -423,9 +428,9 @@ public abstract class Trie
     * 3..0  INDEX_STAGE_2_SHIFT   // 1..9<br>
     */
     private int m_options_;
-    
+
     // private methods ---------------------------------------------------
-    
+
     /**
     * Authenticates raw data header.
     * Checking the header information, signature and options.
@@ -441,7 +446,7 @@ public abstract class Trie
             return false;
         }
 
-        if ((m_options_ & HEADER_OPTIONS_SHIFT_MASK_) != 
+        if ((m_options_ & HEADER_OPTIONS_SHIFT_MASK_) !=
                                                     INDEX_STAGE_1_SHIFT_ ||
             ((m_options_ >> HEADER_OPTIONS_INDEX_SHIFT_) &
                                                 HEADER_OPTIONS_SHIFT_MASK_)
diff --git a/app/src/main/java/com/ibm/icu/impl/Trie2.java b/icu4j/src/main/java/com/ibm/icu/impl/Trie2.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/impl/Trie2.java
rename to icu4j/src/main/java/com/ibm/icu/impl/Trie2.java
index 90b2c72..d892409 100644
--- a/app/src/main/java/com/ibm/icu/impl/Trie2.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/Trie2.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2015, International Business Machines Corporation and
@@ -24,7 +26,7 @@ import java.util.NoSuchElementException;
  * character properties.
  *
  * This is the second common version of a Unicode trie (hence the name Trie2).
- * 
+ *
  */
 public abstract class Trie2 implements Iterable<Trie2.Range> {
 
@@ -206,11 +208,11 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
         byte sig[] = new byte[4];
         int read = is.read(sig);
         is.reset();
-        
+
         if (read != sig.length) {
             return 0;
         }
-        
+
         if (sig[0]=='T' && sig[1]=='r' && sig[2]=='i' && sig[3]=='e') {
             return 1;
         }
@@ -236,7 +238,7 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
      */
     abstract public int get(int codePoint);
 
-    
+
     /**
      * Get the trie value for a UTF-16 code unit.
      *
@@ -244,15 +246,15 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
      * range, one for lead surrogates, which is the value that will be
      * returned by this function, and a second value that is returned
      * by Trie2.get().
-     * 
+     *
      * For code units outside of the lead surrogate range, this function
      * returns the same result as Trie2.get().
-     * 
+     *
      * This function, together with the alternate value for lead surrogates,
      * makes possible very efficient processing of UTF-16 strings without
      * first converting surrogate pairs to their corresponding 32 bit code point
      * values.
-     * 
+     *
      * At build-time, enumerate the contents of the Trie2 to see if there
      * is non-trivial (non-initialValue) data for any of the supplementary
      * code points associated with a lead surrogate.
@@ -261,33 +263,34 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
      *
      * At runtime, use Trie2.getFromU16SingleLead(). If there is non-trivial
      * data and the code unit is a lead surrogate, then check if a trail surrogate
-     * follows. If so, assemble the supplementary code point and look up its value 
+     * follows. If so, assemble the supplementary code point and look up its value
      * with Trie2.get(); otherwise reset the lead
      * surrogate's value or do a code point lookup for it.
      *
      * If there is only trivial data for lead and trail surrogates, then processing
      * can often skip them. For example, in normalization or case mapping
      * all characters that do not have any mappings are simply copied as is.
-     * 
+     *
      * @param c the code point or lead surrogate value.
      * @return the value
      */
     abstract public int getFromU16SingleLead(char c);
-   
+
 
     /**
      * Equals function.  Two Tries are equal if their contents are equal.
-     * The type need not be the same, so a Trie2Writable will be equal to 
+     * The type need not be the same, so a Trie2Writable will be equal to
      * (read-only) Trie2_16 or Trie2_32 so long as they are storing the same values.
-     * 
+     *
      */
+    @Override
     public final boolean equals(Object other) {
         if(!(other instanceof Trie2)) {
             return false;
         }
         Trie2 OtherTrie = (Trie2)other;
         Range  rangeFromOther;
-        
+
         Iterator<Trie2.Range> otherIter = OtherTrie.iterator();
         for (Trie2.Range rangeFromThis: this) {
             if (otherIter.hasNext() == false) {
@@ -301,16 +304,17 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
         if (otherIter.hasNext()) {
             return false;
         }
-        
+
         if (errorValue   != OtherTrie.errorValue ||
             initialValue != OtherTrie.initialValue) {
             return false;
         }
-       
+
         return true;
     }
-    
-    
+
+
+    @Override
     public int hashCode() {
         if (fHash == 0) {
             int hash = initHash();
@@ -324,11 +328,11 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
         }
         return fHash;
     }
-    
+
     /**
      * When iterating over the contents of a Trie2, Elements of this type are produced.
-     * The iterator will return one item for each contiguous range of codepoints  having the same value.  
-     * 
+     * The iterator will return one item for each contiguous range of codepoints  having the same value.
+     *
      * When iterating, the same Trie2EnumRange object will be reused and returned for each range.
      * If you need to retain complete iteration results, clone each returned Trie2EnumRange,
      * or save the range in some other way, before advancing to the next iteration step.
@@ -338,7 +342,8 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
         public int     endCodePoint;     // Inclusive.
         public int     value;
         public boolean leadSurrogate;
-        
+
+        @Override
         public boolean equals(Object other) {
             if (other == null || !(other.getClass().equals(getClass()))) {
                 return false;
@@ -346,11 +351,12 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
             Range tother = (Range)other;
             return this.startCodePoint == tother.startCodePoint &&
                    this.endCodePoint   == tother.endCodePoint   &&
-                   this.value          == tother.value          && 
+                   this.value          == tother.value          &&
                    this.leadSurrogate  == tother.leadSurrogate;
         }
-        
-        
+
+
+        @Override
         public int hashCode() {
             int h = initHash();
             h = hashUChar32(h, startCodePoint);
@@ -360,32 +366,34 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
             return h;
         }
     }
-    
-    
+
+
     /**
      *  Create an iterator over the value ranges in this Trie2.
      *  Values from the Trie2 are not remapped or filtered, but are returned as they
      *  are stored in the Trie2.
-     *  
+     *
      * @return an Iterator
      */
+    @Override
     public Iterator<Range> iterator() {
         return iterator(defaultValueMapper);
     }
-    
+
     private static ValueMapper defaultValueMapper = new ValueMapper() {
-        public int map(int in) { 
+        @Override
+        public int map(int in) {
             return in;
         }
     };
-    
+
     /**
      * Create an iterator over the value ranges from this Trie2.
      * Values from the Trie2 are passed through a caller-supplied remapping function,
      * and it is the remapped values that determine the ranges that
      * will be produced by the iterator.
-     * 
-     * 
+     *
+     *
      * @param mapper provides a function to remap values obtained from the Trie2.
      * @return an Iterator
      */
@@ -393,7 +401,7 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
         return new Trie2Iterator(mapper);
     }
 
-    
+
     /**
      * Create an iterator over the Trie2 values for the 1024=0x400 code points
      * corresponding to a given lead surrogate.
@@ -433,10 +441,10 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
      * be used to remap the values from the Trie2.  The remapped values will be used
      * both in determining the ranges of codepoints and as the value to be returned
      * for each range.
-     * 
+     *
      * Example of use, with an anonymous subclass of TrieValueMapper:
-     * 
-     * 
+     *
+     *
      * ValueMapper m = new ValueMapper() {
      *    int map(int in) {return in & 0x1f;};
      * }
@@ -444,12 +452,12 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
      *     Trie2EnumRange r = i.next();
      *     ...  // Do something with the range r.
      * }
-     *    
+     *
      */
     public interface ValueMapper {
         public int  map(int originalVal);
     }
-       
+
 
    /**
      * Serialize a trie2 Header and Index onto an OutputStream.  This is
@@ -457,12 +465,12 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
      * @param dos the stream to which the serialized Trie2 data will be written.
      * @return the number of bytes written.
      */
-    protected int serializeHeader(DataOutputStream dos) throws IOException {        
+    protected int serializeHeader(DataOutputStream dos) throws IOException {
         // Write the header.  It is already set and ready to use, having been
         //  created when the Trie2 was unserialized or when it was frozen.
         int  bytesWritten = 0;
-        
-        dos.writeInt(header.signature);  
+
+        dos.writeInt(header.signature);
         dos.writeShort(header.options);
         dos.writeShort(header.indexLength);
         dos.writeShort(header.shiftedDataLength);
@@ -470,36 +478,36 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
         dos.writeShort(header.dataNullOffset);
         dos.writeShort(header.shiftedHighStart);
         bytesWritten += 16;
-        
+
         // Write the index
         int i;
         for (i=0; i< header.indexLength; i++) {
             dos.writeChar(index[i]);
         }
-        bytesWritten += header.indexLength;       
-        return bytesWritten;        
+        bytesWritten += header.indexLength;
+        return bytesWritten;
     }
-    
-        
+
+
     /**
      * Struct-like class for holding the results returned by a UTrie2 CharSequence iterator.
      * The iteration walks over a CharSequence, and for each Unicode code point therein
      * returns the character and its associated Trie2 value.
      */
-    public static class CharSequenceValues {        
+    public static class CharSequenceValues {
         /** string index of the current code point. */
-        public int index;        
+        public int index;
         /** The code point at index.  */
-        public int codePoint;        
+        public int codePoint;
         /** The Trie2 value for the current code point */
-        public int value;          
+        public int value;
     }
-    
+
 
     /**
      *  Create an iterator that will produce the values from the Trie2 for
      *  the sequence of code points in an input text.
-     *  
+     *
      * @param text A text string to be iterated over.
      * @param index The starting iteration position within the input text.
      * @return the CharSequenceIterator
@@ -507,17 +515,17 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
     public CharSequenceIterator charSequenceIterator(CharSequence text, int index) {
         return new CharSequenceIterator(text, index);
     }
-    
+
     // TODO:  Survey usage of the equivalent of CharSequenceIterator in ICU4C
     //        and if there is none, remove it from here.
     //        Don't waste time testing and maintaining unused code.
-    
+
     /**
      * An iterator that operates over an input CharSequence, and for each Unicode code point
      * in the input returns the associated value from the Trie2.
-     * 
+     *
      * The iterator can move forwards or backwards, and can be reset to an arbitrary index.
-     * 
+     *
      * Note that Trie2_16 and Trie2_32 subclass Trie2.CharSequenceIterator.  This is done
      * only for performance reasons.  It does require that any changes made here be propagated
      * into the corresponding code in the subclasses.
@@ -526,36 +534,38 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
         /**
          * Internal constructor.
          */
-        CharSequenceIterator(CharSequence t, int index) { 
+        CharSequenceIterator(CharSequence t, int index) {
             text = t;
             textLength = text.length();
             set(index);
         }
-            
+
         private CharSequence text;
         private int textLength;
         private int index;
         private Trie2.CharSequenceValues fResults = new Trie2.CharSequenceValues();
-        
-        
+
+
         public void set(int i) {
             if (i < 0 || i > textLength) {
                 throw new IndexOutOfBoundsException();
             }
             index = i;
         }
-        
-        
+
+
+        @Override
         public final boolean hasNext() {
             return index<textLength;
         }
-        
-        
+
+
         public final boolean hasPrevious() {
             return index>0;
         }
-        
 
+
+        @Override
         public Trie2.CharSequenceValues next() {
             int c = Character.codePointAt(text, index);
             int val = get(c);
@@ -566,11 +576,11 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
             index++;
             if (c >= 0x10000) {
                 index++;
-            }            
+            }
             return fResults;
         }
 
-        
+
         public Trie2.CharSequenceValues previous() {
             int c = Character.codePointBefore(text, index);
             int val = get(c);
@@ -583,49 +593,50 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
             fResults.value = val;
             return fResults;
         }
-            
-        /** 
+
+        /**
          * Iterator.remove() is not supported by Trie2.CharSequenceIterator.
          * @throws UnsupportedOperationException Always thrown because this operation is not supported
          * @see java.util.Iterator#remove()
          */
+        @Override
         public void remove() {
-            throw new UnsupportedOperationException("Trie2.CharSequenceIterator does not support remove().");            
+            throw new UnsupportedOperationException("Trie2.CharSequenceIterator does not support remove().");
         }
     }
-     
-   
+
+
     //--------------------------------------------------------------------------------
     //
     // Below this point are internal implementation items.  No further public API.
     //
     //--------------------------------------------------------------------------------
-    
-    
+
+
     /**
      * Selectors for the width of a UTrie2 data value.
-     */   
+     */
      enum ValueWidth {
          BITS_16,
          BITS_32
      }
-  
+
      /**
      * Trie2 data structure in serialized form:
      *
      * UTrie2Header header;
      * uint16_t index[header.index2Length];
      * uint16_t data[header.shiftedDataLength<<2];  -- or uint32_t data[...]
-     * 
+     *
      * For Java, this is read from the stream into an instance of UTrie2Header.
      * (The C version just places a struct over the raw serialized data.)
-     * 
+     *
      * @internal
      */
     static class UTrie2Header {
         /** "Tri2" in big-endian US-ASCII (0x54726932) */
         int signature;
-        
+
         /**
          * options bit field (uint16_t):
          * 15.. 4   reserved (0)
@@ -635,7 +646,7 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
 
         /** UTRIE2_INDEX_1_OFFSET..UTRIE2_MAX_INDEX_LENGTH  (uint16_t) */
         int  indexLength;
-        
+
         /** (UTRIE2_DATA_START_OFFSET..UTRIE2_MAX_DATA_LENGTH)>>UTRIE2_INDEX_SHIFT  (uint16_t) */
         int  shiftedDataLength;
 
@@ -648,7 +659,7 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
          */
         int shiftedHighStart;
     }
-    
+
     //
     //  Data members of UTrie2.
     //
@@ -656,7 +667,7 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
     char          index[];           // Index array.  Includes data for 16 bit Tries.
     int           data16;            // Offset to data portion of the index array, if 16 bit data.
                                      //    zero if 32 bit data.
-    int           data32[];          // NULL if 16b data is used via index 
+    int           data32[];          // NULL if 16b data is used via index
 
     int           indexLength;
     int           dataLength;
@@ -669,25 +680,25 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
     /* Start of the last range which ends at U+10ffff, and its value. */
     int           highStart;
     int           highValueIndex;
-    
+
     int           dataNullOffset;
-    
+
     int           fHash;              // Zero if not yet computed.
                                       //  Shared by Trie2Writable, Trie2_16, Trie2_32.
                                       //  Thread safety:  if two racing threads compute
                                       //     the same hash on a frozen Trie2, no damage is done.
 
-        
+
     /**
      * Trie2 constants, defining shift widths, index array lengths, etc.
      *
      * These are needed for the runtime macros but users can treat these as
      * implementation details and skip to the actual public API further below.
      */
-    
+
     static final int UTRIE2_OPTIONS_VALUE_BITS_MASK=0x000f;
-    
-    
+
+
     /** Shift size for getting the index-1 table offset. */
     static final int UTRIE2_SHIFT_1=6+5;
 
@@ -708,19 +719,19 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
 
     /** Number of code points per index-1 table entry. 2048=0x800 */
     static final int UTRIE2_CP_PER_INDEX_1_ENTRY=1<<UTRIE2_SHIFT_1;
-    
+
     /** Number of entries in an index-2 block. 64=0x40 */
     static final int UTRIE2_INDEX_2_BLOCK_LENGTH=1<<UTRIE2_SHIFT_1_2;
-    
+
     /** Mask for getting the lower bits for the in-index-2-block offset. */
     static final int UTRIE2_INDEX_2_MASK=UTRIE2_INDEX_2_BLOCK_LENGTH-1;
-    
+
     /** Number of entries in a data block. 32=0x20 */
     static final int UTRIE2_DATA_BLOCK_LENGTH=1<<UTRIE2_SHIFT_2;
-    
+
     /** Mask for getting the lower bits for the in-data-block offset. */
     static final int UTRIE2_DATA_MASK=UTRIE2_DATA_BLOCK_LENGTH-1;
-    
+
     /**
      * Shift size for shifting left the index array values.
      * Increases possible data size with 16-bit index values at the cost
@@ -728,18 +739,18 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
      * This requires data blocks to be aligned by UTRIE2_DATA_GRANULARITY.
      */
     static final int UTRIE2_INDEX_SHIFT=2;
-    
+
     /** The alignment size of a data block. Also the granularity for compaction. */
     static final int UTRIE2_DATA_GRANULARITY=1<<UTRIE2_INDEX_SHIFT;
-    
+
     /* Fixed layout of the first part of the index array. ------------------- */
-    
+
     /**
      * The BMP part of the index-2 table is fixed and linear and starts at offset 0.
      * Length=2048=0x800=0x10000>>UTRIE2_SHIFT_2.
      */
     static final int UTRIE2_INDEX_2_OFFSET=0;
-    
+
     /**
      * The part of the index-2 table for U+D800..U+DBFF stores values for
      * lead surrogate code _units_ not code _points_.
@@ -748,17 +759,17 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
      */
     static final int UTRIE2_LSCP_INDEX_2_OFFSET=0x10000>>UTRIE2_SHIFT_2;
     static final int UTRIE2_LSCP_INDEX_2_LENGTH=0x400>>UTRIE2_SHIFT_2;
-    
+
     /** Count the lengths of both BMP pieces. 2080=0x820 */
     static final int UTRIE2_INDEX_2_BMP_LENGTH=UTRIE2_LSCP_INDEX_2_OFFSET+UTRIE2_LSCP_INDEX_2_LENGTH;
-    
+
     /**
      * The 2-byte UTF-8 version of the index-2 table follows at offset 2080=0x820.
      * Length 32=0x20 for lead bytes C0..DF, regardless of UTRIE2_SHIFT_2.
      */
     static final int UTRIE2_UTF8_2B_INDEX_2_OFFSET=UTRIE2_INDEX_2_BMP_LENGTH;
     static final int UTRIE2_UTF8_2B_INDEX_2_LENGTH=0x800>>6;  /* U+0800 is the first code point after 2-byte UTF-8 */
-    
+
     /**
      * The index-1 table, only used for supplementary code points, at offset 2112=0x840.
      * Variable length, for code points up to highStart, where the last single-value range starts.
@@ -773,22 +784,22 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
      */
     static final int UTRIE2_INDEX_1_OFFSET=UTRIE2_UTF8_2B_INDEX_2_OFFSET+UTRIE2_UTF8_2B_INDEX_2_LENGTH;
     static final int UTRIE2_MAX_INDEX_1_LENGTH=0x100000>>UTRIE2_SHIFT_1;
-    
+
     /*
      * Fixed layout of the first part of the data array. -----------------------
      * Starts with 4 blocks (128=0x80 entries) for ASCII.
      */
-    
+
     /**
      * The illegal-UTF-8 data block follows the ASCII block, at offset 128=0x80.
      * Used with linear access for single bytes 0..0xbf for simple error handling.
      * Length 64=0x40, not UTRIE2_DATA_BLOCK_LENGTH.
      */
     static final int UTRIE2_BAD_UTF8_DATA_OFFSET=0x80;
-    
+
     /** The start of non-linear-ASCII data blocks, at offset 192=0xc0. */
     static final int UTRIE2_DATA_START_OFFSET=0xc0;
-    
+
     /* Building a Trie2 ---------------------------------------------------------- */
 
     /*
@@ -829,14 +840,14 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
      */
     static final int  UNEWTRIE2_MAX_DATA_LENGTH = (0x110000+0x40+0x40+0x400);
 
- 
-   
-    /** 
+
+
+    /**
      * Implementation class for an iterator over a Trie2.
-     * 
+     *
      *   Iteration over a Trie2 first returns all of the ranges that are indexed by code points,
      *   then returns the special alternate values for the lead surrogates
-     *     
+     *
      * @internal
      */
     class Trie2Iterator implements Iterator<Range> {
@@ -848,7 +859,7 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
             limitCP   = 0x110000;
             doLeadSurrogates = true;
         }
-        
+
         // An alternate constructor that configures the iterator to cover only the
         //   code points corresponding to a particular Lead Surrogate value.
         Trie2Iterator(char leadSurrogate, ValueMapper vm) {
@@ -861,11 +872,12 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
             doLeadSurrogates = false;   // Do not iterate over lead the special lead surrogate
                                         //   values after completing iteration over code points.
         }
-        
+
         /**
          *  The main next() function for Trie2 iterators
-         *  
+         *
          */
+        @Override
         public Range next() {
             if (!hasNext()) {
                 throw new NoSuchElementException();
@@ -879,7 +891,7 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
             int   endOfRange = 0;
             int   val = 0;
             int   mappedVal = 0;
-            
+
             if (doingCodePoints) {
                 // Iteration over code point values.
                 val = get(nextStart);
@@ -899,7 +911,7 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
                 }
             } else {
                 // Iteration over the alternate lead surrogate values.
-                val = getFromU16SingleLead((char)nextStart); 
+                val = getFromU16SingleLead((char)nextStart);
                 mappedVal = mapper.map(val);
                 endOfRange = rangeEndLS((char)nextStart);
                 // Loop once for each range in the Trie2 with the same raw (unmapped) value.
@@ -919,34 +931,36 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
             returnValue.endCodePoint   = endOfRange;
             returnValue.value          = mappedVal;
             returnValue.leadSurrogate  = !doingCodePoints;
-            nextStart                  = endOfRange+1;            
+            nextStart                  = endOfRange+1;
             return returnValue;
         }
-        
+
         /**
-         * 
+         *
          */
+        @Override
         public boolean hasNext() {
             return doingCodePoints && (doLeadSurrogates || nextStart < limitCP) || nextStart < 0xdc00;
         }
-        
+
+        @Override
         public void remove() {
             throw new UnsupportedOperationException();
         }
-        
-                 
+
+
         /**
          * Find the last lead surrogate in a contiguous range  with the
          * same Trie2 value as the input character.
-         * 
+         *
          * Use the alternate Lead Surrogate values from the Trie2,
          * not the code-point values.
-         * 
+         *
          * Note: Trie2_16 and Trie2_32 override this implementation with optimized versions,
          *       meaning that the implementation here is only being used with
          *       Trie2Writable.  The code here is logically correct with any type
          *       of Trie2, however.
-         * 
+         *
          * @param c  The character to begin with.
          * @return   The last contiguous character with the same value.
          */
@@ -954,7 +968,7 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
             if (startingLS >= 0xdbff) {
                 return 0xdbff;
             }
-            
+
             int c;
             int val = getFromU16SingleLead(startingLS);
             for (c = startingLS+1; c <= 0x0dbff; c++) {
@@ -964,7 +978,7 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
             }
             return c-1;
         }
-        
+
         //
         //   Iteration State Variables
         //
@@ -975,27 +989,27 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
         // The upper limit for the last normal range to be returned.  Normally 0x110000, but
         //   may be lower when iterating over the code points for a single lead surrogate.
         private int            limitCP;
-        
+
         // True while iterating over the the Trie2 values for code points.
         // False while iterating over the alternate values for lead surrogates.
         private boolean        doingCodePoints = true;
-        
+
         // True if the iterator should iterate the special values for lead surrogates in
         //   addition to the normal values for code points.
         private boolean        doLeadSurrogates = true;
     }
-    
+
     /**
      * Find the last character in a contiguous range of characters with the
      * same Trie2 value as the input character.
-     * 
+     *
      * @param c  The character to begin with.
      * @return   The last contiguous character with the same value.
      */
     int rangeEnd(int start, int limitp, int val) {
         int c;
         int limit = Math.min(highStart, limitp);
-        
+
         for (c = start+1; c < limit; c++) {
             if (get(c) != val) {
                 break;
@@ -1006,28 +1020,28 @@ public abstract class Trie2 implements Iterable<Trie2.Range> {
         }
         return c - 1;
     }
-            
-    
+
+
     //
     //  Hashing implementation functions.  FNV hash.  Respected public domain algorithm.
     //
     private static int initHash() {
         return 0x811c9DC5;  // unsigned 2166136261
     }
-    
+
     private static int hashByte(int h, int b) {
         h = h * 16777619;
         h = h ^ b;
         return h;
     }
-    
+
     private static int hashUChar32(int h, int c) {
         h = Trie2.hashByte(h, c & 255);
         h = Trie2.hashByte(h, (c>>8) & 255);
         h = Trie2.hashByte(h, c>>16);
         return h;
     }
-    
+
     private static int hashInt(int h, int i) {
         h = Trie2.hashByte(h, i & 255);
         h = Trie2.hashByte(h, (i>>8) & 255);
diff --git a/app/src/main/java/com/ibm/icu/impl/Trie2Writable.java b/icu4j/src/main/java/com/ibm/icu/impl/Trie2Writable.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/Trie2Writable.java
rename to icu4j/src/main/java/com/ibm/icu/impl/Trie2Writable.java
index 989c907..de0aeb7 100644
--- a/app/src/main/java/com/ibm/icu/impl/Trie2Writable.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/Trie2Writable.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009, International Business Machines Corporation and         *
@@ -832,7 +834,7 @@ public class Trie2Writable extends Trie2 {
 
         if  (UTRIE2_DEBUG) {
             /* we saved some space */
-            System.out.printf("compacting UTrie2: count of 32-bit data words %d->%d\n",
+            System.out.printf("compacting UTrie2: count of 32-bit data words %d->%d%n",
                 dataLength, newStart);
         }
 
@@ -913,7 +915,7 @@ public class Trie2Writable extends Trie2 {
 
         if (UTRIE2_DEBUG) {
             /* we saved some space */
-            System.out.printf("compacting UTrie2: count of 16-bit index-2 words %d->%d\n",
+            System.out.printf("compacting UTrie2: count of 16-bit index-2 words %d->%d%n",
                     index2Length, newStart);
         }
 
@@ -940,7 +942,7 @@ public class Trie2Writable extends Trie2 {
         this.highStart=localHighStart;
 
         if (UTRIE2_DEBUG) {
-            System.out.printf("UTrie2: highStart U+%04x  highValue 0x%x  initialValue 0x%x\n",
+            System.out.printf("UTrie2: highStart U+%04x  highValue 0x%x  initialValue 0x%x%n",
                 highStart, highValue, initialValue);
         }
 
@@ -955,7 +957,7 @@ public class Trie2Writable extends Trie2 {
             compactIndex2();
         } else {
             if (UTRIE2_DEBUG) {
-                 System.out.printf("UTrie2: highStart U+%04x  count of 16-bit index-2 words %d->%d\n",
+                 System.out.printf("UTrie2: highStart U+%04x  count of 16-bit index-2 words %d->%d%n",
                          highStart, index2Length, UTRIE2_INDEX_1_OFFSET);
             }
         }
diff --git a/app/src/main/java/com/ibm/icu/impl/Trie2_16.java b/icu4j/src/main/java/com/ibm/icu/impl/Trie2_16.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/impl/Trie2_16.java
rename to icu4j/src/main/java/com/ibm/icu/impl/Trie2_16.java
index a12e700..506ecd8 100644
--- a/app/src/main/java/com/ibm/icu/impl/Trie2_16.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/Trie2_16.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2014, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/impl/Trie2_32.java b/icu4j/src/main/java/com/ibm/icu/impl/Trie2_32.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/impl/Trie2_32.java
rename to icu4j/src/main/java/com/ibm/icu/impl/Trie2_32.java
index da15626..faf0ec9 100644
--- a/app/src/main/java/com/ibm/icu/impl/Trie2_32.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/Trie2_32.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2014, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/impl/TrieBuilder.java b/icu4j/src/main/java/com/ibm/icu/impl/TrieBuilder.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/impl/TrieBuilder.java
rename to icu4j/src/main/java/com/ibm/icu/impl/TrieBuilder.java
index f5f5c07..4ebe52d 100644
--- a/app/src/main/java/com/ibm/icu/impl/TrieBuilder.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/TrieBuilder.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 1996-2010, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/impl/TrieIterator.java b/icu4j/src/main/java/com/ibm/icu/impl/TrieIterator.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/impl/TrieIterator.java
rename to icu4j/src/main/java/com/ibm/icu/impl/TrieIterator.java
index a891a02..5b4bd4c 100644
--- a/app/src/main/java/com/ibm/icu/impl/TrieIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/TrieIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 1996-2015, International Business Machines Corporation and
@@ -21,38 +23,38 @@ import com.ibm.icu.util.RangeValueIterator;
  * <p>Result of each iteration contains the interval of codepoints that have
  * the same value type and the value type itself.</p>
  * <p>The comparison of each codepoint value is done via extract(), which the
- * default implementation is to return the value as it is.</p> 
- * <p>Method extract() can be overwritten to perform manipulations on 
+ * default implementation is to return the value as it is.</p>
+ * <p>Method extract() can be overwritten to perform manipulations on
  * codepoint values in order to perform specialized comparison.</p>
  * <p>TrieIterator is designed to be a generic iterator for the CharTrie
- * and the IntTrie, hence to accommodate both types of data, the return 
+ * and the IntTrie, hence to accommodate both types of data, the return
  * result will be in terms of int (32 bit) values.</p>
  * <p>See com.ibm.icu.text.UCharacterTypeIterator for examples of use.</p>
  * <p>Notes for porting utrie_enum from icu4c to icu4j:<br>
  * Internally, icu4c's utrie_enum performs all iterations in its body. In Java
- * sense, the caller will have to pass a object with a callback function 
- * UTrieEnumRange(const void *context, UChar32 start, UChar32 limit, 
- * uint32_t value) into utrie_enum. utrie_enum will then find ranges of 
- * codepoints with the same value as determined by 
- * UTrieEnumValue(const void *context, uint32_t value). for each range, 
+ * sense, the caller will have to pass a object with a callback function
+ * UTrieEnumRange(const void *context, UChar32 start, UChar32 limit,
+ * uint32_t value) into utrie_enum. utrie_enum will then find ranges of
+ * codepoints with the same value as determined by
+ * UTrieEnumValue(const void *context, uint32_t value). for each range,
  * utrie_enum calls the callback function to perform a task. In this way,
  * icu4c performs the iteration within utrie_enum.
  * To follow the JDK model, icu4j is slightly different from icu4c.
  * Instead of requesting the caller to implement an object for a callback.
  * The caller will have to implement a subclass of TrieIterator, fleshing out
- * the method extract(int) (equivalent to UTrieEnumValue). Independent of icu4j, 
- * the caller will have to code his own iteration and flesh out the task 
+ * the method extract(int) (equivalent to UTrieEnumValue). Independent of icu4j,
+ * the caller will have to code his own iteration and flesh out the task
  * (equivalent to UTrieEnumRange) to be performed in the iteration loop.
  * </p>
  * <p>There are basically 3 usage scenarios for porting:</p>
- * <p>1) UTrieEnumValue is the only implemented callback then just implement a 
- * subclass of TrieIterator and override the extract(int) method. The 
+ * <p>1) UTrieEnumValue is the only implemented callback then just implement a
+ * subclass of TrieIterator and override the extract(int) method. The
  * extract(int) method is analogus to UTrieEnumValue callback.
  * </p>
- * <p>2) UTrieEnumValue and UTrieEnumRange both are implemented then implement 
+ * <p>2) UTrieEnumValue and UTrieEnumRange both are implemented then implement
  * a subclass of TrieIterator, override the extract method and iterate, e.g
  * </p>
- * <p>utrie_enum(&normTrie, _enumPropertyStartsValue, _enumPropertyStartsRange, 
+ * <p>utrie_enum(&normTrie, _enumPropertyStartsValue, _enumPropertyStartsRange,
  *               set);<br>
  * In Java :<br>
  * <pre>
@@ -64,14 +66,14 @@ import com.ibm.icu.util.RangeValueIterator;
  *         // port the implementation of _enumPropertyStartsValue here
  *     }
  * }
- * .... 
+ * ....
  * TrieIterator fcdIter  = new TrieIteratorImpl(fcdTrieImpl.fcdTrie);
  * while(fcdIter.next(result)) {
  *     // port the implementation of _enumPropertyStartsRange
  * }
  * </pre>
  * </p>
- * <p>3) UTrieEnumRange is the only implemented callback then just implement 
+ * <p>3) UTrieEnumRange is the only implemented callback then just implement
  * the while loop, when utrie_enum is called
  * <pre>
  * // utrie_enum(&fcdTrie, NULL, _enumPropertyStartsRange, set);
@@ -88,7 +90,7 @@ public class TrieIterator implements RangeValueIterator
 
 {
     // public constructor ---------------------------------------------
-    
+
     /**
     * TrieEnumeration constructor
     * @param trie to be used
@@ -105,19 +107,20 @@ public class TrieIterator implements RangeValueIterator
         m_initialValue_     = extract(m_trie_.getInitialValue());
         reset();
     }
-    
+
     // public methods -------------------------------------------------
-    
+
     /**
-    * <p>Returns true if we are not at the end of the iteration, false 
+    * <p>Returns true if we are not at the end of the iteration, false
     * otherwise.</p>
-    * <p>The next set of codepoints with the same value type will be 
+    * <p>The next set of codepoints with the same value type will be
     * calculated during this call and returned in the arguement element.</p>
-    * @param element return result 
+    * @param element return result
     * @return true if we are not at the end of the iteration, false otherwise.
     * @exception NoSuchElementException - if no more elements exist.
     * @see com.ibm.icu.util.RangeValueIterator.Element
     */
+    @Override
     public final boolean next(Element element)
     {
         if (m_nextCodepoint_ > UCharacter.MAX_VALUE) {
@@ -126,14 +129,15 @@ public class TrieIterator implements RangeValueIterator
         if (m_nextCodepoint_ < UCharacter.SUPPLEMENTARY_MIN_VALUE &&
             calculateNextBMPElement(element)) {
             return true;
-        }    
+        }
         calculateNextSupplementaryElement(element);
         return true;
     }
-     
+
     /**
     * Resets the iterator to the beginning of the iteration
     */
+    @Override
     public final void reset()
     {
         m_currentCodepoint_ = 0;
@@ -149,9 +153,9 @@ public class TrieIterator implements RangeValueIterator
         m_nextBlockIndex_ = 0;
         m_nextTrailIndexOffset_ = TRAIL_SURROGATE_INDEX_BLOCK_LENGTH_;
     }
-    
+
     // protected methods ----------------------------------------------
-    
+
     /**
     * Called by next() to extracts a 32 bit value from a trie value
     * used for comparison.
@@ -165,30 +169,30 @@ public class TrieIterator implements RangeValueIterator
     {
         return value;
     }
-    
+
     // private methods ------------------------------------------------
-    
+
     /**
     * Set the result values
     * @param element return result object
-    * @param start codepoint of range 
+    * @param start codepoint of range
     * @param limit (end + 1) codepoint of range
     * @param value common value of range
     */
-    private final void setResult(Element element, int start, int limit, 
+    private final void setResult(Element element, int start, int limit,
                                  int value)
     {
         element.start = start;
         element.limit = limit;
         element.value = value;
     }
-    
+
     /**
     * Finding the next element.
-    * This method is called just before returning the result of 
+    * This method is called just before returning the result of
     * next().
     * We always store the next element before it is requested.
-    * In the case that we have to continue calculations into the 
+    * In the case that we have to continue calculations into the
     * supplementary planes, a false will be returned.
     * @param element return result object
     * @return true if the next range is found, false if we have to proceed to
@@ -201,11 +205,11 @@ public class TrieIterator implements RangeValueIterator
         m_nextCodepoint_ ++;
         m_nextBlockIndex_ ++;
         if (!checkBlockDetail(currentValue)) {
-            setResult(element, m_currentCodepoint_, m_nextCodepoint_, 
+            setResult(element, m_currentCodepoint_, m_nextCodepoint_,
                       currentValue);
             return true;
         }
-        // synwee check that next block index == 0 here 
+        // synwee check that next block index == 0 here
         // enumerate BMP - the main loop enumerates data blocks
         while (m_nextCodepoint_ < UCharacter.SUPPLEMENTARY_MIN_VALUE) {
             // because of the way the character is split to form the index
@@ -222,10 +226,10 @@ public class TrieIterator implements RangeValueIterator
             } else {
                 m_nextIndex_ ++;
             }
-            
+
             m_nextBlockIndex_ = 0;
             if (!checkBlock(currentValue)) {
-                setResult(element, m_currentCodepoint_, m_nextCodepoint_, 
+                setResult(element, m_currentCodepoint_, m_nextCodepoint_,
                           currentValue);
                 return true;
             }
@@ -246,9 +250,9 @@ public class TrieIterator implements RangeValueIterator
     * lower bound of the next element, in calculateNextBMP() it gets set
     * at the start of any loop, where-else, in calculateNextSupplementary()
     * since m_currentCodepoint_ already contains the lower bound of the
-    * next element (passed down from calculateNextBMP()), we keep it till 
+    * next element (passed down from calculateNextBMP()), we keep it till
     * the end before resetting it to the new value.
-    * Note, if there are no more iterations, it will never get to here. 
+    * Note, if there are no more iterations, it will never get to here.
     * Blocked out by next().
     * @param element return result object
     */
@@ -257,13 +261,13 @@ public class TrieIterator implements RangeValueIterator
         int currentValue = m_nextValue_;
         m_nextCodepoint_ ++;
         m_nextBlockIndex_ ++;
-        
-        if (UTF16.getTrailSurrogate(m_nextCodepoint_) 
-                                        != UTF16.TRAIL_SURROGATE_MIN_VALUE) { 
+
+        if (UTF16.getTrailSurrogate(m_nextCodepoint_)
+                                        != UTF16.TRAIL_SURROGATE_MIN_VALUE) {
             // this piece is only called when we are in the middle of a lead
             // surrogate block
             if (!checkNullNextTrailIndex() && !checkBlockDetail(currentValue)) {
-                setResult(element, m_currentCodepoint_, m_nextCodepoint_, 
+                setResult(element, m_currentCodepoint_, m_nextCodepoint_,
                           currentValue);
                 m_currentCodepoint_ = m_nextCodepoint_;
                 return;
@@ -272,7 +276,7 @@ public class TrieIterator implements RangeValueIterator
             m_nextIndex_ ++;
             m_nextTrailIndexOffset_ ++;
             if (!checkTrailBlock(currentValue)) {
-                setResult(element, m_currentCodepoint_, m_nextCodepoint_, 
+                setResult(element, m_currentCodepoint_, m_nextCodepoint_,
                           currentValue);
                 m_currentCodepoint_ = m_nextCodepoint_;
                 return;
@@ -282,8 +286,8 @@ public class TrieIterator implements RangeValueIterator
         // enumerate supplementary code points
         while (nextLead < TRAIL_SURROGATE_MIN_VALUE_) {
             // lead surrogate access
-            final int leadBlock = 
-                   m_trie_.m_index_[nextLead >> Trie.INDEX_STAGE_1_SHIFT_] << 
+            final int leadBlock =
+                   m_trie_.m_index_[nextLead >> Trie.INDEX_STAGE_1_SHIFT_] <<
                                                    Trie.INDEX_STAGE_2_SHIFT_;
             if (leadBlock == m_trie_.m_dataOffset_) {
                 // no entries for a whole block of lead surrogates
@@ -291,7 +295,7 @@ public class TrieIterator implements RangeValueIterator
                     m_nextValue_      = m_initialValue_;
                     m_nextBlock_      = leadBlock;  // == m_trie_.m_dataOffset_
                     m_nextBlockIndex_ = 0;
-                    setResult(element, m_currentCodepoint_, m_nextCodepoint_, 
+                    setResult(element, m_currentCodepoint_, m_nextCodepoint_,
                               currentValue);
                     m_currentCodepoint_ = m_nextCodepoint_;
                     return;
@@ -300,7 +304,7 @@ public class TrieIterator implements RangeValueIterator
                 nextLead += DATA_BLOCK_LENGTH_;
                 // number of total affected supplementary codepoints in one
                 // block
-                // this is not a simple addition of 
+                // this is not a simple addition of
                 // DATA_BLOCK_SUPPLEMENTARY_LENGTH since we need to consider
                 // that we might have moved some of the codepoints
                 m_nextCodepoint_ = Character.toCodePoint((char)nextLead, (char)UTF16.TRAIL_SURROGATE_MIN_VALUE);
@@ -312,7 +316,7 @@ public class TrieIterator implements RangeValueIterator
             }
             // enumerate trail surrogates for this lead surrogate
             m_nextIndex_ = m_trie_.m_dataManipulate_.getFoldingOffset(
-                               m_trie_.getValue(leadBlock + 
+                               m_trie_.getValue(leadBlock +
                                    (nextLead & Trie.INDEX_STAGE_3_MASK_)));
             if (m_nextIndex_ <= 0) {
                 // no data for this lead surrogate
@@ -320,7 +324,7 @@ public class TrieIterator implements RangeValueIterator
                     m_nextValue_      = m_initialValue_;
                     m_nextBlock_      = m_trie_.m_dataOffset_;
                     m_nextBlockIndex_ = 0;
-                    setResult(element, m_currentCodepoint_, m_nextCodepoint_, 
+                    setResult(element, m_currentCodepoint_, m_nextCodepoint_,
                               currentValue);
                     m_currentCodepoint_ = m_nextCodepoint_;
                     return;
@@ -329,20 +333,20 @@ public class TrieIterator implements RangeValueIterator
             } else {
                 m_nextTrailIndexOffset_ = 0;
                 if (!checkTrailBlock(currentValue)) {
-                    setResult(element, m_currentCodepoint_, m_nextCodepoint_, 
+                    setResult(element, m_currentCodepoint_, m_nextCodepoint_,
                               currentValue);
                     m_currentCodepoint_ = m_nextCodepoint_;
                     return;
                 }
-            }    
+            }
             nextLead ++;
          }
 
          // deliver last range
-         setResult(element, m_currentCodepoint_, UCharacter.MAX_VALUE + 1, 
+         setResult(element, m_currentCodepoint_, UCharacter.MAX_VALUE + 1,
                    currentValue);
-    }    
-    
+    }
+
     /**
     * Internal block value calculations
     * Performs calculations on a data block to find codepoints in m_nextBlock_
@@ -358,7 +362,7 @@ public class TrieIterator implements RangeValueIterator
     private final boolean checkBlockDetail(int currentValue)
     {
         while (m_nextBlockIndex_ < DATA_BLOCK_LENGTH_) {
-            m_nextValue_ = extract(m_trie_.getValue(m_nextBlock_ + 
+            m_nextValue_ = extract(m_trie_.getValue(m_nextBlock_ +
                                                     m_nextBlockIndex_));
             if (m_nextValue_ != currentValue) {
                 return false;
@@ -368,11 +372,11 @@ public class TrieIterator implements RangeValueIterator
         }
         return true;
     }
-    
+
     /**
     * Internal block value calculations
     * Performs calculations on a data block to find codepoints in m_nextBlock_
-    * that has the same value. 
+    * that has the same value.
     * Will call checkBlockDetail() if highlevel check fails.
     * Note m_*_ variables at this point is the next codepoint whose value
     * has not been calculated.
@@ -381,14 +385,14 @@ public class TrieIterator implements RangeValueIterator
     * @return true if the whole block has the same value as currentValue or if
     *              the whole block has been calculated, false otherwise.
     */
-    private final boolean checkBlock(int currentValue) 
+    private final boolean checkBlock(int currentValue)
     {
         int currentBlock = m_nextBlock_;
-        m_nextBlock_ = m_trie_.m_index_[m_nextIndex_] << 
+        m_nextBlock_ = m_trie_.m_index_[m_nextIndex_] <<
                                                   Trie.INDEX_STAGE_2_SHIFT_;
         if (m_nextBlock_ == currentBlock &&
             (m_nextCodepoint_ - m_currentCodepoint_) >= DATA_BLOCK_LENGTH_) {
-            // the block is the same as the previous one, filled with 
+            // the block is the same as the previous one, filled with
             // currentValue
             m_nextCodepoint_ += DATA_BLOCK_LENGTH_;
         }
@@ -408,11 +412,11 @@ public class TrieIterator implements RangeValueIterator
         }
         return true;
     }
-    
+
     /**
     * Internal block value calculations
-    * Performs calculations on multiple data blocks for a set of trail 
-    * surrogates to find codepoints in m_nextBlock_ that has the same value. 
+    * Performs calculations on multiple data blocks for a set of trail
+    * surrogates to find codepoints in m_nextBlock_ that has the same value.
     * Will call checkBlock() for internal block checks.
     * Note m_*_ variables at this point is the next codepoint whose value
     * has not been calculated.
@@ -423,7 +427,7 @@ public class TrieIterator implements RangeValueIterator
     private final boolean checkTrailBlock(int currentValue)
     {
         // enumerate code points for this lead surrogate
-        while (m_nextTrailIndexOffset_ < TRAIL_SURROGATE_INDEX_BLOCK_LENGTH_) 
+        while (m_nextTrailIndexOffset_ < TRAIL_SURROGATE_INDEX_BLOCK_LENGTH_)
         {
             // if we ever reach here, we are at the start of a new block
             m_nextBlockIndex_ = 0;
@@ -436,7 +440,7 @@ public class TrieIterator implements RangeValueIterator
         }
         return true;
     }
-    
+
     /**
     * Checks if we are beginning at the start of a initial block.
     * If we are then the rest of the codepoints in this initial block
@@ -451,15 +455,15 @@ public class TrieIterator implements RangeValueIterator
         if (m_nextIndex_ <= 0) {
             m_nextCodepoint_ += TRAIL_SURROGATE_COUNT_ - 1;
             int nextLead  = UTF16.getLeadSurrogate(m_nextCodepoint_);
-            int leadBlock = 
-                   m_trie_.m_index_[nextLead >> Trie.INDEX_STAGE_1_SHIFT_] << 
+            int leadBlock =
+                   m_trie_.m_index_[nextLead >> Trie.INDEX_STAGE_1_SHIFT_] <<
                                                    Trie.INDEX_STAGE_2_SHIFT_;
             if (m_trie_.m_dataManipulate_ == null) {
                 throw new NullPointerException(
                             "The field DataManipulate in this Trie is null");
             }
             m_nextIndex_ = m_trie_.m_dataManipulate_.getFoldingOffset(
-                               m_trie_.getValue(leadBlock + 
+                               m_trie_.getValue(leadBlock +
                                    (nextLead & Trie.INDEX_STAGE_3_MASK_)));
             m_nextIndex_ --;
             m_nextBlockIndex_ =  DATA_BLOCK_LENGTH_;
@@ -503,7 +507,7 @@ public class TrieIterator implements RangeValueIterator
     /**
     * Number of data values in a stage 2 (data array) block.
     */
-    private static final int DATA_BLOCK_LENGTH_ = 
+    private static final int DATA_BLOCK_LENGTH_ =
                                               1 << Trie.INDEX_STAGE_1_SHIFT_;
 //    /**
 //    * Number of codepoints in a stage 2 block
diff --git a/app/src/main/java/com/ibm/icu/impl/UBiDiProps.java b/icu4j/src/main/java/com/ibm/icu/impl/UBiDiProps.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/UBiDiProps.java
rename to icu4j/src/main/java/com/ibm/icu/impl/UBiDiProps.java
index 0265974..4c5963d 100644
--- a/app/src/main/java/com/ibm/icu/impl/UBiDiProps.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/UBiDiProps.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  *
@@ -83,6 +85,7 @@ public final class UBiDiProps {
 
     // implement ICUBinary.Authenticate
     private final static class IsAcceptable implements ICUBinary.Authenticate {
+        @Override
         public boolean isDataVersionAcceptable(byte version[]) {
             return version[0]==2;
         }
@@ -224,12 +227,12 @@ public final class UBiDiProps {
         start=indexes[IX_JG_START];
         limit=indexes[IX_JG_LIMIT];
         if(start<=c && c<limit) {
-            return (int)jgArray[c-start]&0xff;
+            return jgArray[c-start]&0xff;
         }
         start=indexes[IX_JG_START2];
         limit=indexes[IX_JG_LIMIT2];
         if(start<=c && c<limit) {
-            return (int)jgArray2[c-start]&0xff;
+            return jgArray2[c-start]&0xff;
         }
         return UCharacter.JoiningGroup.NO_JOINING_GROUP;
     }
diff --git a/app/src/main/java/com/ibm/icu/impl/UCaseProps.java b/icu4j/src/main/java/com/ibm/icu/impl/UCaseProps.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/impl/UCaseProps.java
rename to icu4j/src/main/java/com/ibm/icu/impl/UCaseProps.java
index 6d3d977..927cdc0 100644
--- a/app/src/main/java/com/ibm/icu/impl/UCaseProps.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/UCaseProps.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  *
@@ -81,7 +83,7 @@ public final class UCaseProps {
 
     // implement ICUBinary.Authenticate
     private final static class IsAcceptable implements ICUBinary.Authenticate {
-        // @Override when we switch to Java 6
+        @Override
         public boolean isDataVersionAcceptable(byte version[]) {
             return version[0]==3;
         }
@@ -150,7 +152,7 @@ public final class UCaseProps {
      * @param index (in) desired slot index
      * @param excOffset (in) offset into exceptions[] after excWord=exceptions[excOffset++];
      * @return bits 31..0: slot value
-     *             63..32: modified excOffset, moved to the last char of the value, use +1 for beginning of next slot 
+     *             63..32: modified excOffset, moved to the last char of the value, use +1 for beginning of next slot
      */
     private final long getSlotValueAndOffset(int excWord, int index, int excOffset) {
         long value;
@@ -455,7 +457,7 @@ public final class UCaseProps {
         return getTypeFromProps(trie.get(c));
     }
 
-    /** @return same as ucase_getType() and set bit 2 if c is case-ignorable */
+    /** @return like getType() but also sets IGNORABLE if c is case-ignorable */
     public final int getTypeOrIgnorable(int c) {
         return getTypeAndIgnorableFromProps(trie.get(c));
     }
@@ -548,7 +550,7 @@ public final class UCaseProps {
      *   - The general category of C is
      *     Nonspacing Mark (Mn), or Enclosing Mark (Me), or Format Control (Cf), or
      *     Letter Modifier (Lm), or Symbol Modifier (Sk)
-     *   - C is one of the following characters 
+     *   - C is one of the following characters
      *     U+0027 APOSTROPHE
      *     U+00AD SOFT HYPHEN (SHY)
      *     U+2019 RIGHT SINGLE QUOTATION MARK
@@ -576,13 +578,13 @@ public final class UCaseProps {
          * @param dir >0: Begin iterating forward from the first code point
          * after the one that is being case-mapped.
          *            <0: Begin iterating backward from the first code point
-         * before the one that is being case-mapped.   
+         * before the one that is being case-mapped.
          */
         public void reset(int dir);
         /**
          * Iterate and return the next code point, moving in the direction
          * determined by the reset() call.
-         * @return Next code point, or <0 when the iteration is done. 
+         * @return Next code point, or <0 when the iteration is done.
          */
         public int next();
     }
@@ -607,12 +609,13 @@ public final class UCaseProps {
     private static final int LOC_ROOT=1;
     private static final int LOC_TURKISH=2;
     private static final int LOC_LITHUANIAN=3;
+    static final int LOC_GREEK=4;
 
     /*
      * Checks and caches the type of locale ID as it is relevant for case mapping.
      * If the locCache is not null, then it must be initialized with locCache[0]=0 .
      */
-    private static final int getCaseLocale(ULocale locale, int[] locCache) {
+    static final int getCaseLocale(ULocale locale, int[] locCache) {
         int result;
 
         if(locCache!=null && (result=locCache[0])!=LOC_UNKNOWN) {
@@ -624,6 +627,8 @@ public final class UCaseProps {
         String language=locale.getLanguage();
         if(language.equals("tr") || language.equals("tur") || language.equals("az") || language.equals("aze")) {
             result=LOC_TURKISH;
+        } else if(language.equals("el") || language.equals("ell")) {
+            result=LOC_GREEK;
         } else if(language.equals("lt") || language.equals("lit")) {
             result=LOC_LITHUANIAN;
         }
@@ -1102,7 +1107,7 @@ public final class UCaseProps {
      * @internal
      */
     private static final int FOLD_CASE_OPTIONS_MASK = 0xff;
-    
+
     /* return the simple case folding mapping for c */
     public final int fold(int c, int options) {
         int props=trie.get(c);
@@ -1330,15 +1335,17 @@ public final class UCaseProps {
     public static final int UPPER=2;
     public static final int TITLE=3;
 
+    /** @return NONE, LOWER, UPPER, TITLE */
     private static final int getTypeFromProps(int props) {
         return props&TYPE_MASK;
     }
 
+    /** @return like getTypeFromProps() but also sets IGNORABLE if props indicate case-ignorable */
     private static final int getTypeAndIgnorableFromProps(int props) {
         return props&7;
     }
 
-    //private static final int IGNORABLE=   4;
+    static final int IGNORABLE=4;
     private static final int SENSITIVE=     8;
     private static final int EXCEPTION=     0x10;
 
diff --git a/app/src/main/java/com/ibm/icu/impl/UCharArrayIterator.java b/icu4j/src/main/java/com/ibm/icu/impl/UCharArrayIterator.java
similarity index 89%
rename from app/src/main/java/com/ibm/icu/impl/UCharArrayIterator.java
rename to icu4j/src/main/java/com/ibm/icu/impl/UCharArrayIterator.java
index 5556fbb..443f187 100644
--- a/app/src/main/java/com/ibm/icu/impl/UCharArrayIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/UCharArrayIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
 *******************************************************************************
 * Copyright (C) 1996-2010, International Business Machines Corporation and    *
@@ -24,7 +26,7 @@ public final class UCharArrayIterator extends UCharacterIterator {
     public UCharArrayIterator(char[] text, int start, int limit) {
         if (start < 0 || limit > text.length || start > limit) {
             throw new IllegalArgumentException("start: " + start + " or limit: "
-                                               + limit + " out of range [0, " 
+                                               + limit + " out of range [0, "
                                                + text.length + ")");
         }
         this.text = text;
@@ -34,35 +36,42 @@ public final class UCharArrayIterator extends UCharacterIterator {
         this.pos = start;
     }
 
+    @Override
     public int current() {
         return pos < limit ? text[pos] : DONE;
     }
 
+    @Override
     public int getLength() {
         return limit - start;
     }
 
+    @Override
     public int getIndex() {
         return pos - start;
     }
 
+    @Override
     public int next() {
         return pos < limit ? text[pos++] : DONE;
     }
 
+    @Override
     public int previous() {
         return pos > start ? text[--pos] : DONE;
     }
 
+    @Override
     public void setIndex(int index) {
         if (index < 0 || index > limit - start) {
-            throw new IndexOutOfBoundsException("index: " + index + 
-                                                " out of range [0, " 
+            throw new IndexOutOfBoundsException("index: " + index +
+                                                " out of range [0, "
                                                 + (limit - start) + ")");
         }
         pos = start + index;
     }
 
+    @Override
     public int getText(char[] fillIn, int offset) {
         int len = limit - start;
         System.arraycopy(text, start, fillIn, offset, len);
@@ -70,10 +79,11 @@ public final class UCharArrayIterator extends UCharacterIterator {
     }
 
     /**
-     * Creates a copy of this iterator, does not clone the underlying 
+     * Creates a copy of this iterator, does not clone the underlying
      * <code>Replaceable</code>object
      * @return copy of this iterator
      */
+    @Override
     public Object clone(){
         try {
           return super.clone();
diff --git a/app/src/main/java/com/ibm/icu/impl/UCharacterIteratorWrapper.java b/icu4j/src/main/java/com/ibm/icu/impl/UCharacterIteratorWrapper.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/impl/UCharacterIteratorWrapper.java
rename to icu4j/src/main/java/com/ibm/icu/impl/UCharacterIteratorWrapper.java
index 914edda..315560b 100644
--- a/app/src/main/java/com/ibm/icu/impl/UCharacterIteratorWrapper.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/UCharacterIteratorWrapper.java
@@ -1,10 +1,12 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
  * others. All Rights Reserved.                                                *
  *******************************************************************************
  */
- 
+
 package com.ibm.icu.impl;
 
 import java.text.CharacterIterator;
@@ -12,16 +14,16 @@ import java.text.CharacterIterator;
 import com.ibm.icu.text.UCharacterIterator;
 
 /**
- * This class is a wrapper around UCharacterIterator and implements the 
+ * This class is a wrapper around UCharacterIterator and implements the
  * CharacterIterator protocol
  * @author ram
  */
 public class UCharacterIteratorWrapper implements CharacterIterator{
-    
+
     public UCharacterIteratorWrapper(UCharacterIterator iter){
         this.iterator = iter;
     }
-    
+
     private UCharacterIterator iterator;
 
 
@@ -31,6 +33,7 @@ public class UCharacterIteratorWrapper implements CharacterIterator{
      * @return the first character in the text, or DONE if the text is empty
      * @see #getBeginIndex()
      */
+    @Override
     public char first(){
         //UCharacterIterator always iterates from 0 to length
         iterator.setToStart();
@@ -43,6 +46,7 @@ public class UCharacterIteratorWrapper implements CharacterIterator{
      * @return the last character in the text, or DONE if the text is empty
      * @see #getEndIndex()
      */
+    @Override
     public char last(){
         iterator.setToLimit();
         return (char)iterator.previous();
@@ -54,6 +58,7 @@ public class UCharacterIteratorWrapper implements CharacterIterator{
      * position is off the end of the text.
      * @see #getIndex()
      */
+    @Override
     public char current(){
         return (char) iterator.current();
     }
@@ -66,6 +71,7 @@ public class UCharacterIteratorWrapper implements CharacterIterator{
      * @return the character at the new position or DONE if the new
      * position is off the end of the text range.
      */
+    @Override
     public char next(){
         //pre-increment
         iterator.next();
@@ -79,6 +85,7 @@ public class UCharacterIteratorWrapper implements CharacterIterator{
      * @return the character at the new position or DONE if the current
      * position is equal to getBeginIndex().
      */
+    @Override
     public char previous(){
         //pre-decrement
         return (char) iterator.previous();
@@ -92,6 +99,7 @@ public class UCharacterIteratorWrapper implements CharacterIterator{
      * if an invalid value is supplied.
      * @return the character at the specified position or DONE if the specified position is equal to getEndIndex()
      */
+    @Override
     public char setIndex(int position){
         iterator.setIndex(position);
         return (char) iterator.current();
@@ -101,6 +109,7 @@ public class UCharacterIteratorWrapper implements CharacterIterator{
      * Returns the start index of the text.
      * @return the index at which the text begins.
      */
+    @Override
     public int getBeginIndex(){
         //UCharacterIterator always starts from 0
         return 0;
@@ -111,6 +120,7 @@ public class UCharacterIteratorWrapper implements CharacterIterator{
      * character following the end of the text.
      * @return the index after the last character in the text
      */
+    @Override
     public int getEndIndex(){
         return iterator.getLength();
     }
@@ -119,6 +129,7 @@ public class UCharacterIteratorWrapper implements CharacterIterator{
      * Returns the current index.
      * @return the current index.
      */
+    @Override
     public int getIndex(){
         return iterator.getIndex();
     }
@@ -127,15 +138,16 @@ public class UCharacterIteratorWrapper implements CharacterIterator{
      * Create a copy of this iterator
      * @return A copy of this
      */
+    @Override
     public Object clone(){
         try {
             UCharacterIteratorWrapper result = (UCharacterIteratorWrapper) super.clone();
             result.iterator = (UCharacterIterator)this.iterator.clone();
             return result;
-        } catch (CloneNotSupportedException e) {      
+        } catch (CloneNotSupportedException e) {
             return null; // only invoked if bad underlying character iterator
         }
-    }   
+    }
 
 }
 
diff --git a/app/src/main/java/com/ibm/icu/impl/UCharacterName.java b/icu4j/src/main/java/com/ibm/icu/impl/UCharacterName.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/impl/UCharacterName.java
rename to icu4j/src/main/java/com/ibm/icu/impl/UCharacterName.java
index 053d1b7..6f27a15 100644
--- a/app/src/main/java/com/ibm/icu/impl/UCharacterName.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/UCharacterName.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2014, International Business Machines Corporation and
@@ -259,7 +261,7 @@ public final class UCharacterName
         }
 
         synchronized (m_utilStringBuffer_) {
-            m_utilStringBuffer_.delete(0, m_utilStringBuffer_.length());
+            m_utilStringBuffer_.setLength(0);
             byte b;
             char token;
             for (int i = 0; i < length;) {
@@ -367,7 +369,7 @@ public final class UCharacterName
                 result = TYPE_NAMES_[type];
             }
             synchronized (m_utilStringBuffer_) {
-                m_utilStringBuffer_.delete(0, m_utilStringBuffer_.length());
+                m_utilStringBuffer_.setLength(0);
                 m_utilStringBuffer_.append('<');
                 m_utilStringBuffer_.append(result);
                 m_utilStringBuffer_.append('-');
@@ -489,7 +491,7 @@ public final class UCharacterName
     {
         String result = null;
         synchronized (m_utilStringBuffer_) {
-            m_utilStringBuffer_.delete(0, m_utilStringBuffer_.length());
+            m_utilStringBuffer_.setLength(0);
             m_algorithm_[index].appendName(codepoint, m_utilStringBuffer_);
             result = m_utilStringBuffer_.toString();
         }
@@ -818,8 +820,7 @@ public final class UCharacterName
                         int count = 0;
                         for (int factor = m_factor_[i]; factor > 0; -- factor) {
                             synchronized (m_utilStringBuffer_) {
-                                m_utilStringBuffer_.delete(0,
-                                                m_utilStringBuffer_.length());
+                                m_utilStringBuffer_.setLength(0);
                                 count
                                   = UCharacterUtility.getNullTermByteSubString(
                                                 m_utilStringBuffer_,
@@ -881,7 +882,7 @@ public final class UCharacterName
             }
 
             synchronized (m_utilStringBuffer_) {
-                m_utilStringBuffer_.delete(0, m_utilStringBuffer_.length());
+                m_utilStringBuffer_.setLength(0);
                 int count = 0;
                 int factor;
                 size --;
@@ -1188,7 +1189,7 @@ public final class UCharacterName
         ) {
             // index in terms integer index
             synchronized (m_utilStringBuffer_) {
-                m_utilStringBuffer_.delete(0, m_utilStringBuffer_.length());
+                m_utilStringBuffer_.setLength(0);
 
                 for (int index = m_algorithm_.length - 1; index >= 0; index --)
                 {
@@ -1521,8 +1522,7 @@ public final class UCharacterName
                     byte tlength = tokenlength[b];
                     if (tlength == 0) {
                         synchronized (m_utilStringBuffer_) {
-                            m_utilStringBuffer_.delete(0,
-                                                 m_utilStringBuffer_.length());
+                            m_utilStringBuffer_.setLength(0);
                             UCharacterUtility.getNullTermByteSubString(
                                            m_utilStringBuffer_, m_tokenstring_,
                                            token);
diff --git a/app/src/main/java/com/ibm/icu/impl/UCharacterNameChoice.java b/icu4j/src/main/java/com/ibm/icu/impl/UCharacterNameChoice.java
similarity index 90%
rename from app/src/main/java/com/ibm/icu/impl/UCharacterNameChoice.java
rename to icu4j/src/main/java/com/ibm/icu/impl/UCharacterNameChoice.java
index 5c4fc03..849b04c 100644
--- a/app/src/main/java/com/ibm/icu/impl/UCharacterNameChoice.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/UCharacterNameChoice.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
 *******************************************************************************
 * Copyright (C) 1996-2011, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/impl/UCharacterNameReader.java b/icu4j/src/main/java/com/ibm/icu/impl/UCharacterNameReader.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/impl/UCharacterNameReader.java
rename to icu4j/src/main/java/com/ibm/icu/impl/UCharacterNameReader.java
index 2779ac1..a44d1d6 100644
--- a/app/src/main/java/com/ibm/icu/impl/UCharacterNameReader.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/UCharacterNameReader.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2015, International Business Machines Corporation and
@@ -12,22 +14,23 @@ import java.nio.ByteBuffer;
 import java.util.Arrays;
 
 /**
-* <p>Internal reader class for ICU data file uname.dat containing 
-* Unicode codepoint name data.</p> 
+* <p>Internal reader class for ICU data file uname.dat containing
+* Unicode codepoint name data.</p>
 * <p>This class simply reads unames.icu, authenticates that it is a valid
 * ICU data file and split its contents up into blocks of data for use in
 * <a href=UCharacterName.html>com.ibm.icu.impl.UCharacterName</a>.
-* </p> 
-* <p>unames.icu which is in big-endian format is jared together with this 
+* </p>
+* <p>unames.icu which is in big-endian format is jared together with this
 * package.</p>
 * @author Syn Wee Quek
 * @since release 2.1, February 1st 2002
 */
 
 final class UCharacterNameReader implements ICUBinary.Authenticate
-{      
+{
     // public methods ----------------------------------------------------
-    
+
+    @Override
     public boolean isDataVersionAcceptable(byte version[])
     {
         return version[0] == 1;
@@ -62,7 +65,7 @@ final class UCharacterNameReader implements ICUBinary.Authenticate
         m_groupindex_       = m_byteBuffer_.getInt();
         m_groupstringindex_ = m_byteBuffer_.getInt();
         m_algnamesindex_    = m_byteBuffer_.getInt();
-        
+
         // reading tokens
         int count = m_byteBuffer_.getChar();
         char token[] = ICUBinary.getChars(m_byteBuffer_, count, 0);
@@ -70,7 +73,7 @@ final class UCharacterNameReader implements ICUBinary.Authenticate
         byte tokenstr[] = new byte[size];
         m_byteBuffer_.get(tokenstr);
         data.setToken(token, tokenstr);
-        
+
         // reading the group information records
         count = m_byteBuffer_.getChar();
         data.setGroupCountSize(count, GROUP_INFO_SIZE_);
@@ -80,13 +83,13 @@ final class UCharacterNameReader implements ICUBinary.Authenticate
         size = m_algnamesindex_ - m_groupstringindex_;
         byte groupstring[] = new byte[size];
         m_byteBuffer_.get(groupstring);
-    
+
         data.setGroup(group, groupstring);
-        
+
         count = m_byteBuffer_.getInt();
-        UCharacterName.AlgorithmName alg[] = 
+        UCharacterName.AlgorithmName alg[] =
                                  new UCharacterName.AlgorithmName[count];
-     
+
         for (int i = 0; i < count; i ++)
         {
             UCharacterName.AlgorithmName an = readAlg();
@@ -97,7 +100,7 @@ final class UCharacterNameReader implements ICUBinary.Authenticate
         }
         data.setAlgorithm(alg);
     }
-    
+
     /**
     * <p>Checking the file for the correct format.</p>
     * @param dataformatid
@@ -114,7 +117,7 @@ final class UCharacterNameReader implements ICUBinary.Authenticate
                isDataVersionAcceptable(dataformatversion);
     }
     ///CLOVER:ON
-    
+
     // private variables -------------------------------------------------
 
     /**
@@ -133,10 +136,10 @@ final class UCharacterNameReader implements ICUBinary.Authenticate
     private int m_groupindex_;
     private int m_groupstringindex_;
     private int m_algnamesindex_;
-      
+
     /**
     * Size of an algorithmic name information group
-    * start code point size + end code point size + type size + variant size + 
+    * start code point size + end code point size + type size + variant size +
     * size of data size
     */
     private static final int ALG_INFO_SIZE_ = 12;
@@ -147,7 +150,7 @@ final class UCharacterNameReader implements ICUBinary.Authenticate
     private static final int DATA_FORMAT_ID_ = 0x756E616D;
 
     // private methods ---------------------------------------------------
-      
+
     /**
     * Reads an individual record of AlgorithmNames
     * @return an instance of AlgorithNames if read is successful otherwise null
@@ -155,7 +158,7 @@ final class UCharacterNameReader implements ICUBinary.Authenticate
     */
     private UCharacterName.AlgorithmName readAlg() throws IOException
     {
-        UCharacterName.AlgorithmName result = 
+        UCharacterName.AlgorithmName result =
                                        new UCharacterName.AlgorithmName();
         int rangestart = m_byteBuffer_.getInt();
         int rangeend   = m_byteBuffer_.getInt();
@@ -164,7 +167,7 @@ final class UCharacterNameReader implements ICUBinary.Authenticate
         if (!result.setInfo(rangestart, rangeend, type, variant)) {
             return null;
         }
-                         
+
         int size = m_byteBuffer_.getChar();
         if (type == UCharacterName.AlgorithmName.TYPE_1_)
         {
@@ -173,7 +176,7 @@ final class UCharacterNameReader implements ICUBinary.Authenticate
             result.setFactor(factor);
             size -= (variant << 1);
         }
-          
+
         StringBuilder prefix = new StringBuilder();
         char c = (char)(m_byteBuffer_.get() & 0x00FF);
         while (c != 0)
@@ -181,11 +184,11 @@ final class UCharacterNameReader implements ICUBinary.Authenticate
             prefix.append(c);
             c = (char)(m_byteBuffer_.get() & 0x00FF);
         }
-        
+
         result.setPrefix(prefix.toString());
-        
+
         size -= (ALG_INFO_SIZE_ + prefix.length() + 1);
-        
+
         if (size > 0)
         {
             byte string[] = new byte[size];
diff --git a/app/src/main/java/com/ibm/icu/impl/UCharacterProperty.java b/icu4j/src/main/java/com/ibm/icu/impl/UCharacterProperty.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/UCharacterProperty.java
rename to icu4j/src/main/java/com/ibm/icu/impl/UCharacterProperty.java
index 0af9f5c..6eae051 100644
--- a/app/src/main/java/com/ibm/icu/impl/UCharacterProperty.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/UCharacterProperty.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and
@@ -210,6 +212,7 @@ public final class UCharacterProperty
             super(SRC_CASE);
             this.which=which;
         }
+        @Override
         boolean contains(int c) {
             return UCaseProps.INSTANCE.hasBinaryProperty(c, which);
         }
@@ -221,6 +224,7 @@ public final class UCharacterProperty
             super(source);
             this.which=which;
         }
+        @Override
         boolean contains(int c) {
             return Norm2AllModes.getN2WithImpl(which-UProperty.NFD_INERT).isInert(c);
         }
@@ -234,11 +238,13 @@ public final class UCharacterProperty
         new BinaryProperty(1, (1<<ALPHABETIC_PROPERTY_)),
         new BinaryProperty(1, (1<<ASCII_HEX_DIGIT_PROPERTY_)),
         new BinaryProperty(SRC_BIDI) {  // UCHAR_BIDI_CONTROL
+            @Override
             boolean contains(int c) {
                 return UBiDiProps.INSTANCE.isBidiControl(c);
             }
         },
         new BinaryProperty(SRC_BIDI) {  // UCHAR_BIDI_MIRRORED
+            @Override
             boolean contains(int c) {
                 return UBiDiProps.INSTANCE.isMirrored(c);
             }
@@ -249,6 +255,7 @@ public final class UCharacterProperty
         new BinaryProperty(1, (1<<DIACRITIC_PROPERTY_)),
         new BinaryProperty(1, (1<<EXTENDER_PROPERTY_)),
         new BinaryProperty(SRC_NFC) {  // UCHAR_FULL_COMPOSITION_EXCLUSION
+            @Override
             boolean contains(int c) {
                 // By definition, Full_Composition_Exclusion is the same as NFC_QC=No.
                 Normalizer2Impl impl=Norm2AllModes.getNFCInstance().impl;
@@ -266,6 +273,7 @@ public final class UCharacterProperty
         new BinaryProperty(1, (1<<IDS_BINARY_OPERATOR_PROPERTY_)),
         new BinaryProperty(1, (1<<IDS_TRINARY_OPERATOR_PROPERTY_)),
         new BinaryProperty(SRC_BIDI) {  // UCHAR_JOIN_CONTROL
+            @Override
             boolean contains(int c) {
                 return UBiDiProps.INSTANCE.isJoinControl(c);
             }
@@ -291,6 +299,7 @@ public final class UCharacterProperty
         new NormInertBinaryProperty(SRC_NFC, UProperty.NFC_INERT),
         new NormInertBinaryProperty(SRC_NFKC, UProperty.NFKC_INERT),
         new BinaryProperty(SRC_NFC_CANON_ITER) {  // UCHAR_SEGMENT_STARTER
+            @Override
             boolean contains(int c) {
                 return Norm2AllModes.getNFCInstance().impl.
                     ensureCanonIterData().isCanonSegmentStarter(c);
@@ -299,11 +308,13 @@ public final class UCharacterProperty
         new BinaryProperty(1, (1<<PATTERN_SYNTAX)),
         new BinaryProperty(1, (1<<PATTERN_WHITE_SPACE)),
         new BinaryProperty(SRC_CHAR_AND_PROPSVEC) {  // UCHAR_POSIX_ALNUM
+            @Override
             boolean contains(int c) {
                 return UCharacter.isUAlphabetic(c) || UCharacter.isDigit(c);
             }
         },
         new BinaryProperty(SRC_CHAR) {  // UCHAR_POSIX_BLANK
+            @Override
             boolean contains(int c) {
                 // "horizontal space"
                 if(c<=0x9f) {
@@ -315,11 +326,13 @@ public final class UCharacterProperty
             }
         },
         new BinaryProperty(SRC_CHAR) {  // UCHAR_POSIX_GRAPH
+            @Override
             boolean contains(int c) {
                 return isgraphPOSIX(c);
             }
         },
         new BinaryProperty(SRC_CHAR) {  // UCHAR_POSIX_PRINT
+            @Override
             boolean contains(int c) {
                 /*
                  * Checks if codepoint is in \p{graph}\p{blank} - \p{cntrl}.
@@ -331,6 +344,7 @@ public final class UCharacterProperty
             }
         },
         new BinaryProperty(SRC_CHAR) {  // UCHAR_POSIX_XDIGIT
+            @Override
             boolean contains(int c) {
                 /* check ASCII and Fullwidth ASCII a-fA-F */
                 if(
@@ -348,6 +362,7 @@ public final class UCharacterProperty
         new CaseBinaryProperty(UProperty.CHANGES_WHEN_UPPERCASED),
         new CaseBinaryProperty(UProperty.CHANGES_WHEN_TITLECASED),
         new BinaryProperty(SRC_CASE_AND_NORM) {  // UCHAR_CHANGES_WHEN_CASEFOLDED
+            @Override
             boolean contains(int c) {
                 String nfd=Norm2AllModes.getNFCInstance().impl.getDecomposition(c);
                 if(nfd!=null) {
@@ -374,6 +389,7 @@ public final class UCharacterProperty
         },
         new CaseBinaryProperty(UProperty.CHANGES_WHEN_CASEMAPPED),
         new BinaryProperty(SRC_NFKC_CF) {  // UCHAR_CHANGES_WHEN_NFKC_CASEFOLDED
+            @Override
             boolean contains(int c) {
                 Normalizer2Impl kcf=Norm2AllModes.getNFKC_CFInstance().impl;
                 String src=UTF16.valueOf(c);
@@ -455,6 +471,7 @@ public final class UCharacterProperty
         BiDiIntProperty() {
             super(SRC_BIDI);
         }
+        @Override
         int getMaxValue(int which) {
             return UBiDiProps.INSTANCE.getMaxValue(which);
         }
@@ -464,6 +481,7 @@ public final class UCharacterProperty
         CombiningClassIntProperty(int source) {
             super(source);
         }
+        @Override
         int getMaxValue(int which) {
             return 0xff;
         }
@@ -477,9 +495,11 @@ public final class UCharacterProperty
             this.which=which;
             this.max=max;
         }
+        @Override
         int getValue(int c) {
             return Norm2AllModes.getN2WithImpl(which-UProperty.NFD_QUICK_CHECK).getQuickCheck(c);
         }
+        @Override
         int getMaxValue(int which) {
             return max;
         }
@@ -487,12 +507,14 @@ public final class UCharacterProperty
 
     IntProperty intProps[]={
         new BiDiIntProperty() {  // BIDI_CLASS
+            @Override
             int getValue(int c) {
                 return UBiDiProps.INSTANCE.getClass(c);
             }
         },
         new IntProperty(0, BLOCK_MASK_, BLOCK_SHIFT_),
         new CombiningClassIntProperty(SRC_NFC) {  // CANONICAL_COMBINING_CLASS
+            @Override
             int getValue(int c) {
                 return Normalizer2.getNFDInstance().getCombiningClass(c);
             }
@@ -500,38 +522,46 @@ public final class UCharacterProperty
         new IntProperty(2, DECOMPOSITION_TYPE_MASK_, 0),
         new IntProperty(0, EAST_ASIAN_MASK_, EAST_ASIAN_SHIFT_),
         new IntProperty(SRC_CHAR) {  // GENERAL_CATEGORY
+            @Override
             int getValue(int c) {
                 return getType(c);
             }
+            @Override
             int getMaxValue(int which) {
                 return UCharacterCategory.CHAR_CATEGORY_COUNT-1;
             }
         },
         new BiDiIntProperty() {  // JOINING_GROUP
+            @Override
             int getValue(int c) {
                 return UBiDiProps.INSTANCE.getJoiningGroup(c);
             }
         },
         new BiDiIntProperty() {  // JOINING_TYPE
+            @Override
             int getValue(int c) {
                 return UBiDiProps.INSTANCE.getJoiningType(c);
             }
         },
         new IntProperty(2, LB_MASK, LB_SHIFT),  // LINE_BREAK
         new IntProperty(SRC_CHAR) {  // NUMERIC_TYPE
+            @Override
             int getValue(int c) {
                 return ntvGetType(getNumericTypeValue(getProperty(c)));
             }
+            @Override
             int getMaxValue(int which) {
                 return NumericType.COUNT-1;
             }
         },
         new IntProperty(0, SCRIPT_MASK_, 0) {
+            @Override
             int getValue(int c) {
                 return UScript.getScript(c);
             }
         },
         new IntProperty(SRC_PROPSVEC) {  // HANGUL_SYLLABLE_TYPE
+            @Override
             int getValue(int c) {
                 /* see comments on gcbToHst[] above */
                 int gcb=(getAdditional(c, 2)&GCB_MASK)>>>GCB_SHIFT;
@@ -541,6 +571,7 @@ public final class UCharacterProperty
                     return HangulSyllableType.NOT_APPLICABLE;
                 }
             }
+            @Override
             int getMaxValue(int which) {
                 return HangulSyllableType.COUNT-1;
             }
@@ -552,11 +583,13 @@ public final class UCharacterProperty
         new NormQuickCheckIntProperty(SRC_NFC, UProperty.NFC_QUICK_CHECK, 2),
         new NormQuickCheckIntProperty(SRC_NFKC, UProperty.NFKC_QUICK_CHECK, 2),
         new CombiningClassIntProperty(SRC_NFC) {  // LEAD_CANONICAL_COMBINING_CLASS
+            @Override
             int getValue(int c) {
                 return Norm2AllModes.getNFCInstance().impl.getFCD16(c)>>8;
             }
         },
         new CombiningClassIntProperty(SRC_NFC) {  // TRAIL_CANONICAL_COMBINING_CLASS
+            @Override
             int getValue(int c) {
                 return Norm2AllModes.getNFCInstance().impl.getFCD16(c)&0xff;
             }
@@ -565,6 +598,7 @@ public final class UCharacterProperty
         new IntProperty(2, SB_MASK, SB_SHIFT),  // SENTENCE_BREAK
         new IntProperty(2, WB_MASK, WB_SHIFT),  // WORD_BREAK
         new BiDiIntProperty() {  // BIDI_PAIRED_BRACKET_TYPE
+            @Override
             int getValue(int c) {
                 return UBiDiProps.INSTANCE.getPairedBracketType(c);
             }
@@ -817,7 +851,7 @@ public final class UCharacterProperty
             } else {
                 return -2;
             }
-        } else if(ntv<NTV_RESERVED_START_) {
+        } else if(ntv<NTV_FRACTION20_START_) {
             /* sexagesimal (base 60) integer */
             int numValue=(ntv>>2)-0xbf;
             int exp=(ntv&3)+1;
@@ -841,6 +875,9 @@ public final class UCharacterProperty
             }
 
             return numValue;
+        } else if(ntv<NTV_RESERVED_START_) {
+            // fraction-20 e.g. 3/80
+            return -2;
         } else {
             /* reserved */
             return -2;
@@ -895,7 +932,7 @@ public final class UCharacterProperty
             }
 
             return numValue;
-        } else if(ntv<NTV_RESERVED_START_) {
+        } else if(ntv<NTV_FRACTION20_START_) {
             /* sexagesimal (base 60) integer */
             int numValue=(ntv>>2)-0xbf;
             int exp=(ntv&3)+1;
@@ -919,6 +956,12 @@ public final class UCharacterProperty
             }
 
             return numValue;
+        } else if(ntv<NTV_RESERVED_START_) {
+            // fraction-20 e.g. 3/80
+            int frac20=ntv-NTV_FRACTION20_START_;  // 0..0x17
+            int numerator=2*(frac20&3)+1;
+            int denominator=20<<(frac20>>2);
+            return (double)numerator/denominator;
         } else {
             /* reserved */
             return UCharacter.NO_NUMERIC_VALUE;
@@ -994,8 +1037,15 @@ public final class UCharacterProperty
      * ((ntv>>2)-0xbf) * 60^((ntv&3)+1) = (1..9)*(60^1..60^4)
      */
     private static final int NTV_BASE60_START_=0x300;
+    /**
+     * Fraction-20 values:
+     * frac20 = ntv-0x324 = 0..0x17 -> 1|3|5|7 / 20|40|80|160|320|640
+     * numerator: num = 2*(frac20&3)+1
+     * denominator: den = 20<<(frac20>>2)
+     */
+    private static final int NTV_FRACTION20_START_ = NTV_BASE60_START_ + 36;  // 0x300+9*4=0x324
     /** No numeric value (yet). */
-    private static final int NTV_RESERVED_START_ = NTV_BASE60_START_ + 36;  // 0x300+9*4=0x324
+    private static final int NTV_RESERVED_START_ = NTV_FRACTION20_START_ + 24;  // 0x324+6*4=0x34c
 
     private static final int ntvGetType(int ntv) {
         return
@@ -1222,6 +1272,7 @@ public final class UCharacterProperty
 
     private static final class IsAcceptable implements ICUBinary.Authenticate {
         // @Override when we switch to Java 6
+        @Override
         public boolean isDataVersionAcceptable(byte version[]) {
             return version[0] == 7;
         }
@@ -1314,7 +1365,7 @@ public final class UCharacterProperty
 
         /* add for u_charDigitValue() */
         // TODO remove when UCharacter.getHanNumericValue() is changed to just return
-        // Unicode numeric values 
+        // Unicode numeric values
         set.add(0x3007);
         set.add(0x3008);
         set.add(0x4e00);
diff --git a/app/src/main/java/com/ibm/icu/impl/UCharacterUtility.java b/icu4j/src/main/java/com/ibm/icu/impl/UCharacterUtility.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/impl/UCharacterUtility.java
rename to icu4j/src/main/java/com/ibm/icu/impl/UCharacterUtility.java
index dc10e06..7d550fe 100644
--- a/app/src/main/java/com/ibm/icu/impl/UCharacterUtility.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/UCharacterUtility.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
 *******************************************************************************
 * Copyright (C) 1996-2004, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/impl/UPropertyAliases.java b/icu4j/src/main/java/com/ibm/icu/impl/UPropertyAliases.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/impl/UPropertyAliases.java
rename to icu4j/src/main/java/com/ibm/icu/impl/UPropertyAliases.java
index b4cff0c..16e930c 100644
--- a/app/src/main/java/com/ibm/icu/impl/UPropertyAliases.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/UPropertyAliases.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  **********************************************************************
  * Copyright (c) 2002-2015, International Business Machines
@@ -67,6 +69,7 @@ public final class UPropertyAliases {
 
     private static final class IsAcceptable implements ICUBinary.Authenticate {
         // @Override when we switch to Java 6
+        @Override
         public boolean isDataVersionAcceptable(byte version[]) {
             return version[0]==2;
         }
@@ -184,7 +187,7 @@ public final class UPropertyAliases {
         // Find the end of this name.
         int nameStart=nameGroupsIndex;
         while(0!=nameGroups.charAt(nameGroupsIndex)) {
-            ++nameGroupsIndex;            
+            ++nameGroupsIndex;
         }
         if(nameStart==nameGroupsIndex) {
             return null;  // no name (Property[Value]Aliases.txt has "n/a")
diff --git a/app/src/main/java/com/ibm/icu/impl/URLHandler.java b/icu4j/src/main/java/com/ibm/icu/impl/URLHandler.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/impl/URLHandler.java
rename to icu4j/src/main/java/com/ibm/icu/impl/URLHandler.java
index af4f700..7e03874 100644
--- a/app/src/main/java/com/ibm/icu/impl/URLHandler.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/URLHandler.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ******************************************************************************
  * Copyright (C) 2005-2015, International Business Machines Corporation and
@@ -25,14 +27,14 @@ import java.util.jar.JarFile;
 
 public abstract class URLHandler {
     public static final String PROPNAME = "urlhandler.props";
-    
+
     private static final Map<String, Method> handlers;
-    
+
     private static final boolean DEBUG = ICUDebug.enabled("URLHandler");
-    
+
     static {
         Map<String, Method> h = null;
-        
+
         BufferedReader br = null;
         try {
             @SuppressWarnings("resource")  // Closed by BufferedReader.
@@ -42,32 +44,32 @@ public abstract class URLHandler {
             if (is != null) {
                 Class<?>[] params = { URL.class };
                 br = new BufferedReader(new InputStreamReader(is));
-                
+
                 for (String line = br.readLine(); line != null; line = br.readLine()) {
                     line = line.trim();
-                    
+
                     if (line.length() == 0 || line.charAt(0) == '#') {
                         continue;
                     }
-                    
+
                     int ix = line.indexOf('=');
-                    
+
                     if (ix == -1) {
                         if (DEBUG) System.err.println("bad urlhandler line: '" + line + "'");
                         break;
                     }
-                    
+
                     String key = line.substring(0, ix).trim();
                     String value = line.substring(ix+1).trim();
-                    
+
                     try {
                         Class<?> cl = Class.forName(value);
                         Method m = cl.getDeclaredMethod("get", params);
-                        
+
                         if (h == null) {
                             h = new HashMap<String, Method>();
                         }
-                        
+
                         h.put(key, m);
                     }
                     catch (ClassNotFoundException e) {
@@ -100,16 +102,16 @@ public abstract class URLHandler {
         if (url == null) {
             return null;
         }
-        
+
         String protocol = url.getProtocol();
-        
+
         if (handlers != null) {
             Method m = handlers.get(protocol);
-            
+
             if (m != null) {
                 try {
                     URLHandler handler = (URLHandler)m.invoke(null, new Object[] { url });
-                    
+
                     if (handler != null) {
                         return handler;
                     }
@@ -125,10 +127,10 @@ public abstract class URLHandler {
                 }
             }
         }
-        
+
         return getDefault(url);
     }
-    
+
     protected static URLHandler getDefault(URL url) {
         URLHandler handler = null;
 
@@ -144,7 +146,7 @@ public abstract class URLHandler {
         }
         return handler;
     }
-    
+
     private static class FileURLHandler extends URLHandler {
         File file;
 
@@ -159,7 +161,8 @@ public abstract class URLHandler {
                 throw new IllegalArgumentException();
             }
         }
-        
+
+        @Override
         public void guide(URLVisitor v, boolean recurse, boolean strip) {
             if (file.isDirectory()) {
                 process(v, recurse, strip, "/", file.listFiles());
@@ -167,22 +170,24 @@ public abstract class URLHandler {
                 v.visit(file.getName());
             }
         }
-        
+
         private void process(URLVisitor v, boolean recurse, boolean strip, String path, File[] files) {
-            for (int i = 0; i < files.length; i++) {
-                File f = files[i];
-                
-                if (f.isDirectory()) {
-                    if (recurse) {
-                        process(v, recurse, strip, path + f.getName()+ '/', f.listFiles());
+            if (files != null) {
+                for (int i = 0; i < files.length; i++) {
+                    File f = files[i];
+
+                    if (f.isDirectory()) {
+                        if (recurse) {
+                            process(v, recurse, strip, path + f.getName()+ '/', f.listFiles());
+                        }
+                    } else {
+                        v.visit(strip? f.getName() : path + f.getName());
                     }
-                } else {
-                    v.visit(strip? f.getName() : path + f.getName());
                 }
             }
         }
     }
-    
+
     private static class JarURLHandler extends URLHandler {
         JarFile jarFile;
         String prefix;
@@ -190,9 +195,9 @@ public abstract class URLHandler {
         JarURLHandler(URL url) {
             try {
                 prefix = url.getPath();
-                
+
                 int ix = prefix.lastIndexOf("!/");
-                
+
                 if (ix >= 0) {
                     prefix = prefix.substring(ix + 2); // truncate after "!/"
                 }
@@ -216,17 +221,18 @@ public abstract class URLHandler {
                 throw new IllegalArgumentException("jar error: " + e.getMessage());
             }
         }
-        
+
+        @Override
         public void guide(URLVisitor v, boolean recurse, boolean strip) {
             try {
                 Enumeration<JarEntry> entries = jarFile.entries();
-                
+
                 while (entries.hasMoreElements()) {
                     JarEntry entry = entries.nextElement();
-                    
+
                     if (!entry.isDirectory()) { // skip just directory paths
                         String name = entry.getName();
-                        
+
                         if (name.startsWith(prefix)) {
                             name = name.substring(prefix.length());
                             int ix = name.lastIndexOf('/');
@@ -251,9 +257,9 @@ public abstract class URLHandler {
     {
         guide(visitor, recurse, true);
     }
-    
+
     public abstract void guide(URLVisitor visitor, boolean recurse, boolean strip);
-    
+
     public interface URLVisitor {
         void visit(String str);
     }
diff --git a/app/src/main/java/com/ibm/icu/impl/UResource.java b/icu4j/src/main/java/com/ibm/icu/impl/UResource.java
similarity index 65%
rename from app/src/main/java/com/ibm/icu/impl/UResource.java
rename to icu4j/src/main/java/com/ibm/icu/impl/UResource.java
index c8f1d79..04574f4 100644
--- a/app/src/main/java/com/ibm/icu/impl/UResource.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/UResource.java
@@ -1,6 +1,8 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2015, International Business Machines Corporation and
+ * Copyright (C) 2015-2016, International Business Machines Corporation and
  * others. All Rights Reserved.
  *******************************************************************************
  */
@@ -38,7 +40,16 @@ public final class UResource {
         /**
          * Constructs an empty resource key string object.
          */
-        public Key() {}
+        public Key() {
+            s = "";
+        }
+
+        /**
+         * Constructs a resource key object equal to the given string.
+         */
+        public Key(String s) {
+            setString(s);
+        }
 
         private Key(byte[] keyBytes, int keyOffset, int keyLength) {
             bytes = keyBytes;
@@ -56,20 +67,45 @@ public final class UResource {
          * @param keyBytes new key string byte array
          * @param keyOffset new key string offset
          */
-        public void setBytes(byte[] keyBytes, int keyOffset) {
+        public Key setBytes(byte[] keyBytes, int keyOffset) {
             bytes = keyBytes;
             offset = keyOffset;
             for (length = 0; keyBytes[keyOffset + length] != 0; ++length) {}
             s = null;
+            return this;
         }
 
         /**
          * Mutates this key to an empty resource key string.
          */
-        public void setToEmpty() {
+        public Key setToEmpty() {
             bytes = null;
             offset = length = 0;
-            s = null;
+            s = "";
+            return this;
+        }
+
+        /**
+         * Mutates this key to be equal to the given string.
+         */
+        public Key setString(String s) {
+            if (s.isEmpty()) {
+                setToEmpty();
+            } else {
+                bytes = new byte[s.length()];
+                offset = 0;
+                length = s.length();
+                for (int i = 0; i < length; ++i) {
+                    char c = s.charAt(i);
+                    if (c <= 0x7f) {
+                        bytes[i] = (byte)c;
+                    } else {
+                        throw new IllegalArgumentException('\"' + s + "\" is not an ASCII string");
+                    }
+                }
+                this.s = s;
+            }
+            return this;
         }
 
         /**
@@ -85,18 +121,18 @@ public final class UResource {
             }
         }
 
-        // TODO: Java 6: @Override
+        @Override
         public char charAt(int i) {
             assert(0 <= i && i < length);
             return (char)bytes[offset + i];
         }
 
-        // TODO: Java 6: @Override
+        @Override
         public int length() {
             return length;
         }
 
-        // TODO: Java 6: @Override
+        @Override
         public Key subSequence(int start, int end) {
             assert(0 <= start && start < length);
             assert(start <= end && end <= length);
@@ -106,6 +142,7 @@ public final class UResource {
         /**
          * Creates/caches/returns this resource key string as a Java String.
          */
+        @Override
         public String toString() {
             if (s == null) {
                 s = internalSubString(0, length);
@@ -212,7 +249,7 @@ public final class UResource {
             return h;
         }
 
-        // TODO: Java 6: @Override
+        @Override
         public int compareTo(Key other) {
             return compareTo((CharSequence)other);
         }
@@ -221,7 +258,7 @@ public final class UResource {
             int csLength = cs.length();
             int minLength = length <= csLength ? length : csLength;
             for (int i = 0; i < minLength; ++i) {
-                int diff = (int)charAt(i) - (int)cs.charAt(i);
+                int diff = charAt(i) - cs.charAt(i);
                 if (diff != 0) {
                     return diff;
                 }
@@ -230,6 +267,41 @@ public final class UResource {
         }
     }
 
+    /**
+     * Interface for iterating over a resource bundle array resource.
+     * Does not use Java Iterator to reduce object creations.
+     */
+    public interface Array {
+        /**
+         * @return The number of items in the array resource.
+         */
+        public int getSize();
+        /**
+         * @param i Array item index.
+         * @param value Output-only, receives the value of the i'th item.
+         * @return true if i is non-negative and less than getSize().
+         */
+        public boolean getValue(int i, Value value);
+    }
+
+    /**
+     * Interface for iterating over a resource bundle table resource.
+     * Does not use Java Iterator to reduce object creations.
+     */
+    public interface Table {
+        /**
+         * @return The number of items in the array resource.
+         */
+        public int getSize();
+        /**
+         * @param i Array item index.
+         * @param key Output-only, receives the key of the i'th item.
+         * @param value Output-only, receives the value of the i'th item.
+         * @return true if i is non-negative and less than getSize().
+         */
+        public boolean getKeyAndValue(int i, Key key, Value value);
+    }
+
     /**
      * Represents a resource bundle item's value.
      * Avoids object creations as much as possible.
@@ -279,6 +351,67 @@ public final class UResource {
          */
         public abstract ByteBuffer getBinary();
 
+        /**
+         * @throws UResourceTypeMismatchException if this is not an array resource
+         */
+        public abstract Array getArray();
+
+        /**
+         * @throws UResourceTypeMismatchException if this is not a table resource
+         */
+        public abstract Table getTable();
+
+        /**
+         * Is this a no-fallback/no-inheritance marker string?
+         * Such a marker is used for CLDR no-fallback data values of "∅∅∅"
+         * when enumerating tables with fallback from the specific resource bundle to root.
+         *
+         * @return true if this is a no-inheritance marker string
+         */
+        public abstract boolean isNoInheritanceMarker();
+
+        /**
+         * @return the array of strings in this array resource.
+         * @see UResourceBundle#getStringArray()
+         * @throws UResourceTypeMismatchException if this is not an array resource
+         *     or if any of the array items is not a string
+         */
+        public abstract String[] getStringArray();
+
+        /**
+         * Same as
+         * <pre>
+         * if (getType() == STRING) {
+         *     return new String[] { getString(); }
+         * } else {
+         *     return getStringArray();
+         * }
+         * </pre>
+         *
+         * @see #getString()
+         * @see #getStringArray()
+         * @throws UResourceTypeMismatchException if this is
+         *     neither a string resource nor an array resource containing strings
+         */
+        public abstract String[] getStringArrayOrStringAsArray();
+
+        /**
+         * Same as
+         * <pre>
+         * if (getType() == STRING) {
+         *     return getString();
+         * } else {
+         *     return getStringArray()[0];
+         * }
+         * </pre>
+         *
+         * @see #getString()
+         * @see #getStringArray()
+         * @throws UResourceTypeMismatchException if this is
+         *     neither a string resource nor an array resource containing strings
+         */
+        public abstract String getStringOrFirstOfArray();
+
         /**
          * Only for debugging.
          */
@@ -302,9 +435,9 @@ public final class UResource {
                 return sb.append('}').toString();
             case UResourceBundle.BINARY:
                 return "(binary blob)";
-            case UResourceBundle.ARRAY:  // should not occur
+            case UResourceBundle.ARRAY:
                 return "(array)";
-            case UResourceBundle.TABLE:  // should not occur
+            case UResourceBundle.TABLE:
                 return "(table)";
             default:  // should not occur
                 return "???";
@@ -313,117 +446,24 @@ public final class UResource {
     }
 
     /**
-     * Sink for ICU resource array contents.
-     * The base class does nothing.
-     *
-     * <p>Nested arrays and tables are stored as nested sinks,
-     * never put() as {@link Value} items.
-     */
-    public static class ArraySink {
-        /**
-         * Adds a value from a resource array.
-         *
-         * @param index of the resource array item
-         * @param value resource value
-         */
-        public void put(int index, Value value) {}
-
-        /**
-         * Returns a nested resource array at the array index as another sink.
-         * Creates the sink if none exists for the key.
-         * Returns null if nested arrays are not supported.
-         * The default implementation always returns null.
-         *
-         * @param index of the resource array item
-         * @param size number of array items
-         * @return nested-array sink, or null
-         */
-        public ArraySink getOrCreateArraySink(int index, int size) {
-            return null;
-        }
-
-        /**
-         * Returns a nested resource table at the array index as another sink.
-         * Creates the sink if none exists for the key.
-         * Returns null if nested tables are not supported.
-         * The default implementation always returns null.
-         *
-         * @param index of the resource array item
-         * @param initialSize size hint for creating the sink if necessary
-         * @return nested-table sink, or null
-         */
-        public TableSink getOrCreateTableSink(int index, int initialSize) {
-            return null;
-        }
-
-        /**
-         * "Leaves" the array.
-         * Indicates that all of the resources and sub-resources of the current array
-         * have been enumerated.
-         */
-        public void leave() {}
-    }
-
-    /**
-     * Sink for ICU resource table contents.
-     * The base class does nothing.
-     *
-     * <p>Nested arrays and tables are stored as nested sinks,
-     * never put() as {@link Value} items.
+     * Sink for ICU resource bundle contents.
      */
-    public static class TableSink {
-        /**
-         * Adds a key-value pair from a resource table.
-         *
-         * @param key resource key string
-         * @param value resource value
-         */
-        public void put(Key key, Value value) {}
-
-        /**
-         * Adds a no-fallback/no-inheritance marker for this key.
-         * Used for CLDR no-fallback data values of "∅∅∅"
-         * when enumerating tables with fallback from the specific resource bundle to root.
-         *
-         * <p>The default implementation does nothing.
-         *
-         * @param key to be removed
-         */
-        public void putNoFallback(Key key) {}
-
-        /**
-         * Returns a nested resource array for the key as another sink.
-         * Creates the sink if none exists for the key.
-         * Returns null if nested arrays are not supported.
-         * The default implementation always returns null.
-         *
-         * @param key resource key string
-         * @param size number of array items
-         * @return nested-array sink, or null
-         */
-        public ArraySink getOrCreateArraySink(Key key, int size) {
-            return null;
-        }
-
+    public static abstract class Sink {
         /**
-         * Returns a nested resource table for the key as another sink.
-         * Creates the sink if none exists for the key.
-         * Returns null if nested tables are not supported.
-         * The default implementation always returns null.
+         * Called once for each bundle (child-parent-...-root).
+         * The value is normally an array or table resource,
+         * and implementations of this method normally iterate over the
+         * tree of resource items stored there.
          *
-         * @param key resource key string
-         * @param initialSize size hint for creating the sink if necessary
-         * @return nested-table sink, or null
-         */
-        public TableSink getOrCreateTableSink(Key key, int initialSize) {
-            return null;
-        }
-
-        /**
-         * "Leaves" the table.
-         * Indicates that all of the resources and sub-resources of the current table
-         * have been enumerated.
+         * @param key Initially the key string of the enumeration-start resource.
+         *     Empty if the enumeration starts at the top level of the bundle.
+         *     Reuse for output values from Array and Table getters.
+         * @param value Call getArray() or getTable() as appropriate.
+         *     Then reuse for output values from Array and Table getters.
+         * @param noFallback true if the bundle has no parent;
+         *     that is, its top-level table has the nofallback attribute,
+         *     or it is the root bundle of a locale tree.
          */
-        public void leave() {}
+        public abstract void put(Key key, Value value, boolean noFallback);
     }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/USerializedSet.java b/icu4j/src/main/java/com/ibm/icu/impl/USerializedSet.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/USerializedSet.java
rename to icu4j/src/main/java/com/ibm/icu/impl/USerializedSet.java
index 4e2a874..9023cec 100644
--- a/app/src/main/java/com/ibm/icu/impl/USerializedSet.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/USerializedSet.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  *   Copyright (C) 2002-2010, International Business Machines
@@ -32,8 +34,7 @@ public final class USerializedSet {
 
         length=src[srcStart++];
         
-        
-        if((length&0x8000) >0) {
+        if ((length&0x8000) != 0) {
             /* there are supplementary values */
             length&=0x7fff;
             if(src.length<(srcStart+1+length)) {
diff --git a/app/src/main/java/com/ibm/icu/impl/UTS46.java b/icu4j/src/main/java/com/ibm/icu/impl/UTS46.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/UTS46.java
rename to icu4j/src/main/java/com/ibm/icu/impl/UTS46.java
index f582553..118f72d 100644
--- a/app/src/main/java/com/ibm/icu/impl/UTS46.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/UTS46.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2010-2014, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/UnicodeRegex.java b/icu4j/src/main/java/com/ibm/icu/impl/UnicodeRegex.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/impl/UnicodeRegex.java
rename to icu4j/src/main/java/com/ibm/icu/impl/UnicodeRegex.java
index 17689c4..fb7a0c0 100644
--- a/app/src/main/java/com/ibm/icu/impl/UnicodeRegex.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/UnicodeRegex.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2015, Google, International Business Machines Corporation
@@ -72,7 +74,7 @@ public class UnicodeRegex implements Cloneable, Freezable<UnicodeRegex>, StringT
      * consistent with Java regex, so be careful of the differences.
      * <p>Not thread-safe; create a separate copy for different threads.
      * <p>In the future, we may extend this to support other regex packages.
-     * 
+     *
      * @regex A modified Java regex pattern, as in the input to
      *        Pattern.compile(), except that all "character classes" are
      *        processed as if they were UnicodeSet patterns. Example:
@@ -80,6 +82,7 @@ public class UnicodeRegex implements Cloneable, Freezable<UnicodeRegex>, StringT
      * @return A processed Java regex pattern, suitable for input to
      *         Pattern.compile().
      */
+    @Override
     public String transform(String regex) {
         StringBuilder result = new StringBuilder();
         UnicodeSet temp = new UnicodeSet();
@@ -148,7 +151,7 @@ public class UnicodeRegex implements Cloneable, Freezable<UnicodeRegex>, StringT
 
     /**
      * Compile a regex string, after processing by fix(...).
-     * 
+     *
      * @param regex Raw regex pattern, as in fix(...).
      * @return Pattern
      */
@@ -158,7 +161,7 @@ public class UnicodeRegex implements Cloneable, Freezable<UnicodeRegex>, StringT
 
     /**
      * Compile a regex string, after processing by fix(...).
-     * 
+     *
      * @param regex Raw regex pattern, as in fix(...).
      * @return Pattern
      */
@@ -168,7 +171,7 @@ public class UnicodeRegex implements Cloneable, Freezable<UnicodeRegex>, StringT
 
     /**
      * Compile a composed string from a set of BNF lines; see the List version for more information.
-     * 
+     *
      * @param bnfLines Series of BNF lines.
      * @return Pattern
      */
@@ -192,10 +195,10 @@ public class UnicodeRegex implements Cloneable, Freezable<UnicodeRegex>, StringT
      * </pre>
      * <p>
      * Caveats: at this point the parsing is simple; for example, # cannot be
-     * quoted (use \\u0023); you can set it to null to disable. 
+     * quoted (use \\u0023); you can set it to null to disable.
      * The equality sign and a few others can be reset with
      * setBnfX().
-     * 
+     *
      * @param lines Series of lines that represent a BNF expression. The lines contain
      *          a series of statements that of the form x=y;. A statement can take
      *          multiple lines, but there can't be multiple statements on a line.
@@ -211,7 +214,7 @@ public class UnicodeRegex implements Cloneable, Freezable<UnicodeRegex>, StringT
             for (Entry<String, String> entry : variables.entrySet()) {
                 String variable   = entry.getKey(),
                        definition = entry.getValue();
-                
+
                 for (Entry<String, String> entry2 : variables.entrySet()) {
                     String variable2 = entry2.getKey(),
                            definition2 = entry2.getValue();
@@ -222,13 +225,13 @@ public class UnicodeRegex implements Cloneable, Freezable<UnicodeRegex>, StringT
                     if (!altered2.equals(definition2)) {
                         unused.remove(variable);
                         variables.put(variable2, altered2);
-                        if (log != null) {
-                            try {
-                                log.append(variable2 + "=" + altered2 + ";");
-                            } catch (IOException e) {
-                                throw (IllegalArgumentException) new IllegalArgumentException().initCause(e);
-                            }
-                        }
+//                        if (log != null) {
+//                            try {
+//                                log.append(variable2 + "=" + altered2 + ";");
+//                            } catch (IOException e) {
+//                                throw (IllegalArgumentException) new IllegalArgumentException().initCause(e);
+//                            }
+//                        }
                     }
                 }
             }
@@ -298,12 +301,13 @@ public class UnicodeRegex implements Cloneable, Freezable<UnicodeRegex>, StringT
         }
         return result;
     }
-    
-    
+
+
 
     /* (non-Javadoc)
      * @see com.ibm.icu.util.Freezable#cloneAsThawed()
      */
+    @Override
     public UnicodeRegex cloneAsThawed() {
         // TODO Auto-generated method stub
         try {
@@ -316,6 +320,7 @@ public class UnicodeRegex implements Cloneable, Freezable<UnicodeRegex>, StringT
     /* (non-Javadoc)
      * @see com.ibm.icu.util.Freezable#freeze()
      */
+    @Override
     public UnicodeRegex freeze() {
         // no action needed now.
         return this;
@@ -324,6 +329,7 @@ public class UnicodeRegex implements Cloneable, Freezable<UnicodeRegex>, StringT
     /* (non-Javadoc)
      * @see com.ibm.icu.util.Freezable#isFrozen()
      */
+    @Override
     public boolean isFrozen() {
         // at this point, always true
         return true;
@@ -344,13 +350,14 @@ public class UnicodeRegex implements Cloneable, Freezable<UnicodeRegex>, StringT
         }
     }
 
-    private static UnicodeRegex STANDARD = new UnicodeRegex();
+    private static final UnicodeRegex STANDARD = new UnicodeRegex();
     private String bnfCommentString = "#";
     private String bnfVariableInfix = "=";
     private String bnfLineSeparator = "\n";
-    private Appendable log = null;
+//    private Appendable log = null;
 
     private Comparator<Object> LongestFirst = new Comparator<Object>() {
+        @Override
         public int compare(Object obj0, Object obj1) {
             String arg0 = obj0.toString();
             String arg1 = obj1.toString();
diff --git a/app/src/main/java/com/ibm/icu/impl/UnicodeSetStringSpan.java b/icu4j/src/main/java/com/ibm/icu/impl/UnicodeSetStringSpan.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/UnicodeSetStringSpan.java
rename to icu4j/src/main/java/com/ibm/icu/impl/UnicodeSetStringSpan.java
index ead5fc9..b18eef0 100644
--- a/app/src/main/java/com/ibm/icu/impl/UnicodeSetStringSpan.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/UnicodeSetStringSpan.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ******************************************************************************
  *
@@ -64,7 +66,7 @@ public class UnicodeSetStringSpan {
     private short[] spanLengths;
 
     /** Maximum lengths of relevant strings. */
-    private int maxLength16;
+    private final int maxLength16;
 
     /** Are there strings that are not fully contained in the code point set? */
     private boolean someRelevant;
@@ -106,6 +108,7 @@ public class UnicodeSetStringSpan {
         int stringsLength = strings.size();
 
         int i, spanLength;
+        int maxLength16 = 0;
         someRelevant = false;
         for (i = 0; i < stringsLength; ++i) {
             String string = strings.get(i);
@@ -118,6 +121,7 @@ public class UnicodeSetStringSpan {
                 maxLength16 = length16;
             }
         }
+        this.maxLength16 = maxLength16;
         if (!someRelevant && (which & WITH_COUNT) == 0) {
             return;
         }
@@ -210,7 +214,7 @@ public class UnicodeSetStringSpan {
         maxLength16 = otherStringSpan.maxLength16;
         someRelevant = otherStringSpan.someRelevant;
         all = true;
-        if (otherStringSpan.spanNotSet == otherStringSpan.spanSet) {
+        if (Utility.sameObjects(otherStringSpan.spanNotSet, otherStringSpan.spanSet)) {
             spanNotSet = spanSet;
         } else {
             spanNotSet = (UnicodeSet) otherStringSpan.spanNotSet.clone();
@@ -222,7 +226,7 @@ public class UnicodeSetStringSpan {
 
     /**
      * Do the strings need to be checked in span() etc.?
-     * 
+     *
      * @return true if strings need to be checked (call span() here),
      *         false if not (use a BMPSet for best performance).
      */
@@ -240,7 +244,7 @@ public class UnicodeSetStringSpan {
      * so that a character span ends before any string.
      */
     private void addToSpanNotSet(int c) {
-        if (spanNotSet == null || spanNotSet == spanSet) {
+        if (Utility.sameObjects(spanNotSet, null) || Utility.sameObjects(spanNotSet, spanSet)) {
             if (spanSet.contains(c)) {
                 return; // Nothing to do.
             }
@@ -265,7 +269,7 @@ public class UnicodeSetStringSpan {
 
     /*
      * Algorithm for span(SpanCondition.CONTAINED)
-     * 
+     *
      * Theoretical algorithm:
      * - Iterate through the string, and at each code point boundary:
      *   + If the code point there is in the set, then remember to continue after it.
@@ -318,7 +322,7 @@ public class UnicodeSetStringSpan {
 
     /*
      * Algorithm for span(SIMPLE)
-     * 
+     *
      * Theoretical algorithm:
      * - Iterate through the string, and at each code point boundary:
      *   + If the code point there is in the set, then remember to continue after it.
@@ -354,7 +358,7 @@ public class UnicodeSetStringSpan {
      */
     /**
      * Spans a string.
-     * 
+     *
      * @param s The string to be spanned
      * @param start The start index that the span begins
      * @param spanCondition The span condition
@@ -633,7 +637,7 @@ public class UnicodeSetStringSpan {
 
     /**
      * Span a string backwards.
-     * 
+     *
      * @param s The string to be spanned
      * @param spanCondition The span condition
      * @return The string index which starts the span (i.e. inclusive).
@@ -802,7 +806,7 @@ public class UnicodeSetStringSpan {
 
     /**
      * Algorithm for spanNot()==span(SpanCondition.NOT_CONTAINED)
-     * 
+     *
      * Theoretical algorithm:
      * - Iterate through the string, and at each code point boundary:
      *   + If the code point there is in the set, then return with the current position.
diff --git a/app/src/main/java/com/ibm/icu/impl/Utility.java b/icu4j/src/main/java/com/ibm/icu/impl/Utility.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/Utility.java
rename to icu4j/src/main/java/com/ibm/icu/impl/Utility.java
index bc8df25..c1790a5 100644
--- a/app/src/main/java/com/ibm/icu/impl/Utility.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/Utility.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2015, International Business Machines Corporation and    *
@@ -122,7 +124,7 @@ public final class Utility {
         return true;
     }
 
-    /** 
+    /**
      * Convenience utility to compare two int[]s.
      * @param len the length to compare.
      * The start indices and start+len must be valid.
@@ -170,21 +172,30 @@ public final class Utility {
         return true;
     }
 
+    /**
+     * Trivial reference equality.
+     * This method should help document that we really want == not equals(),
+     * and to have a single place to suppress warnings from static analysis tools.
+     */
+    public static final boolean sameObjects(Object a, Object b) {
+        return a == b;
+    }
+
     /**
      * Convenience utility. Does null checks on objects, then calls equals.
      */
     public final static boolean objectEquals(Object a, Object b) {
-        return a == null ? 
-                b == null ? true : false : 
+        return a == null ?
+                b == null ? true : false :
                     b == null ? false : a.equals(b);
     }
-    
+
     /**
      * Convenience utility. Does null checks on objects, then calls compare.
      */
     public static <T extends Comparable<T>> int checkCompare(T a, T b) {
-        return a == null ? 
-                b == null ? 0 : -1 : 
+        return a == null ?
+                b == null ? 0 : -1 :
                     b == null ? 1 : a.compareTo(b);
       }
 
@@ -194,7 +205,7 @@ public final class Utility {
     public static int checkHash(Object a) {
         return a == null ? 0 : a.hashCode();
       }
-    
+
     /**
      * The ESCAPE character is used during run-length encoding.  It signals
      * a run of identical chars.
@@ -358,8 +369,8 @@ public final class Utility {
             }
         }
         else {
-            if (length == (int) ESCAPE) {
-                if (value == (int) ESCAPE) {
+            if (length == ESCAPE) {
+                if (value == ESCAPE) {
                     appendInt(buffer, ESCAPE);
                 }
                 appendInt(buffer, value);
@@ -386,22 +397,26 @@ public final class Utility {
      */
     private static final <T extends Appendable> void encodeRun(T buffer, short value, int length) {
         try {
+            char valueChar = (char) value;
             if (length < 4) {
                 for (int j=0; j<length; ++j) {
-                    if (value == (int) ESCAPE)
+                    if (valueChar == ESCAPE) {
                         buffer.append(ESCAPE);
-                    buffer.append((char) value);
+                    }
+                    buffer.append(valueChar);
                 }
             }
             else {
-                if (length == (int) ESCAPE) {
-                    if (value == (int) ESCAPE) buffer.append(ESCAPE);
-                    buffer.append((char) value);
+                if (length == ESCAPE) {
+                    if (valueChar == ESCAPE) {
+                        buffer.append(ESCAPE);
+                    }
+                    buffer.append(valueChar);
                     --length;
                 }
                 buffer.append(ESCAPE);
                 buffer.append((char) length);
-                buffer.append((char) value); // Don't need to escape this value
+                buffer.append(valueChar); // Don't need to escape this value
             }
         } catch (IOException e) {
             throw new IllegalIcuArgumentException(e);
@@ -421,7 +436,7 @@ public final class Utility {
             }
         }
         else {
-            if (length == ESCAPE_BYTE) {
+            if ((byte)length == ESCAPE_BYTE) {
                 if (value == ESCAPE_BYTE) appendEncodedByte(buffer, ESCAPE_BYTE, state);
                 appendEncodedByte(buffer, value, state);
                 --length;
@@ -444,7 +459,7 @@ public final class Utility {
             byte[] state) {
         try {
             if (state[0] != 0) {
-                char c = (char) ((state[1] << 8) | (((int) value) & 0xFF));
+                char c = (char) ((state[1] << 8) | ((value) & 0xFF));
                 buffer.append(c);
                 state[0] = 0;
             }
@@ -493,14 +508,14 @@ public final class Utility {
         return array;
     }
     static final int getInt(String s, int i) {
-        return (((int) s.charAt(2*i)) << 16) | (int) s.charAt(2*i+1);
+        return ((s.charAt(2*i)) << 16) | s.charAt(2*i+1);
     }
 
     /**
      * Construct an array of shorts from a run-length encoded string.
      */
     static public final short[] RLEStringToShortArray(String s) {
-        int length = (((int) s.charAt(0)) << 16) | ((int) s.charAt(1));
+        int length = ((s.charAt(0)) << 16) | (s.charAt(1));
         short[] array = new short[length];
         int ai = 0;
         for (int i=2; i<s.length(); ++i) {
@@ -510,7 +525,7 @@ public final class Utility {
                 if (c == ESCAPE) {
                     array[ai++] = (short) c;
                 } else {
-                    int runLength = (int) c;
+                    int runLength = c;
                     short runValue = (short) s.charAt(++i);
                     for (int j=0; j<runLength; ++j) array[ai++] = runValue;
                 }
@@ -530,7 +545,7 @@ public final class Utility {
      * Construct an array of shorts from a run-length encoded string.
      */
     static public final char[] RLEStringToCharArray(String s) {
-        int length = (((int) s.charAt(0)) << 16) | ((int) s.charAt(1));
+        int length = ((s.charAt(0)) << 16) | (s.charAt(1));
         char[] array = new char[length];
         int ai = 0;
         for (int i=2; i<s.length(); ++i) {
@@ -540,7 +555,7 @@ public final class Utility {
                 if (c == ESCAPE) {
                     array[ai++] = c;
                 } else {
-                    int runLength = (int) c;
+                    int runLength = c;
                     char runValue = s.charAt(++i);
                     for (int j=0; j<runLength; ++j) array[ai++] = runValue;
                 }
@@ -560,7 +575,7 @@ public final class Utility {
      * Construct an array of bytes from a run-length encoded string.
      */
     static public final byte[] RLEStringToByteArray(String s) {
-        int length = (((int) s.charAt(0)) << 16) | ((int) s.charAt(1));
+        int length = ((s.charAt(0)) << 16) | (s.charAt(1));
         byte[] array = new byte[length];
         boolean nextChar = true;
         char c = 0;
@@ -1028,7 +1043,7 @@ public final class Utility {
      */
     public static <S extends CharSequence> String hex(S s, int width, S separator) {
         return hex(s, width, separator, true, new StringBuilder()).toString();
-    }   
+    }
 
     /**
      * Split a string into pieces based on the given divider character
@@ -1671,7 +1686,7 @@ public final class Utility {
         target += MAGIC_UNSIGNED;
         if (source < target) {
             return -1;
-        } 
+        }
         else if (source > target) {
             return 1;
         }
@@ -1724,7 +1739,7 @@ public final class Utility {
     }
     /**
      * Utility method to take a int[] containing codepoints and return
-     * a string representation with code units. 
+     * a string representation with code units.
      */
     public static String valueOf(int[]source){
         // TODO: Investigate why this method is not on UTF16 class
@@ -1750,7 +1765,7 @@ public final class Utility {
         }
         return result.toString();
     }
-    
+
     public static String[] splitString(String src, String target) {
         return src.split("\\Q" + target + "\\E");
     }
@@ -1772,7 +1787,7 @@ public final class Utility {
     public static String fromHex(String string, int minLength, String separator) {
         return fromHex(string, minLength, Pattern.compile(separator != null ? separator : "\\s+"));
     }
-    
+
     /**
      * Parse a list of hex numbers and return a string
      * @param string String of hex numbers.
diff --git a/app/src/main/java/com/ibm/icu/impl/UtilityExtensions.java b/icu4j/src/main/java/com/ibm/icu/impl/UtilityExtensions.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/UtilityExtensions.java
rename to icu4j/src/main/java/com/ibm/icu/impl/UtilityExtensions.java
index 074c3e7..511fdd5 100644
--- a/app/src/main/java/com/ibm/icu/impl/UtilityExtensions.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/UtilityExtensions.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2002-2010, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/impl/ValidIdentifiers.java b/icu4j/src/main/java/com/ibm/icu/impl/ValidIdentifiers.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/ValidIdentifiers.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ValidIdentifiers.java
index 712a167..035e60a 100644
--- a/app/src/main/java/com/ibm/icu/impl/ValidIdentifiers.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ValidIdentifiers.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2015-2016, International Business Machines Corporation and
@@ -117,7 +119,7 @@ public class ValidIdentifiers {
         static {
             Map<Datatype, Map<Datasubtype, ValiditySet>> _data = new EnumMap<Datatype,Map<Datasubtype,ValiditySet>>(Datatype.class);
             UResourceBundle suppData = UResourceBundle.getBundleInstance(
-                    ICUResourceBundle.ICU_BASE_NAME,
+                    ICUData.ICU_BASE_NAME,
                     "supplementalData",
                     ICUResourceBundle.ICU_DATA_CLASS_LOADER);
             UResourceBundle validityInfo = suppData.get("idValidity");
diff --git a/app/src/main/java/com/ibm/icu/impl/ZoneMeta.java b/icu4j/src/main/java/com/ibm/icu/impl/ZoneMeta.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/ZoneMeta.java
rename to icu4j/src/main/java/com/ibm/icu/impl/ZoneMeta.java
index b89bbf9..807a228 100644
--- a/app/src/main/java/com/ibm/icu/impl/ZoneMeta.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/ZoneMeta.java
@@ -1,6 +1,8 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 **********************************************************************
-* Copyright (c) 2003-2015 International Business Machines
+* Copyright (c) 2003-2016 International Business Machines
 * Corporation and others.  All Rights Reserved.
 **********************************************************************
 * Author: Alan Liu
@@ -285,7 +287,7 @@ public final class ZoneMeta {
         if (ZONEIDS == null) {
             try {
                 UResourceBundle top = UResourceBundle.getBundleInstance(
-                        ICUResourceBundle.ICU_BASE_NAME, ZONEINFORESNAME, ICUResourceBundle.ICU_DATA_CLASS_LOADER);
+                        ICUData.ICU_BASE_NAME, ZONEINFORESNAME, ICUResourceBundle.ICU_DATA_CLASS_LOADER);
                 ZONEIDS = top.getStringArray(kNAMES);
             } catch (MissingResourceException ex) {
                 // throw away..
@@ -364,7 +366,7 @@ public final class ZoneMeta {
                 try {
                     int zoneIdx = getZoneIndex(tzid);
                     if (zoneIdx >= 0) {
-                        UResourceBundle top = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME,
+                        UResourceBundle top = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME,
                                 ZONEINFORESNAME, ICUResourceBundle.ICU_DATA_CLASS_LOADER);
                         UResourceBundle zones = top.get(kZONES);
                         UResourceBundle zone = zones.get(zoneIdx);
@@ -394,7 +396,7 @@ public final class ZoneMeta {
 
         try {
             // First, try check if the given ID is canonical
-            UResourceBundle keyTypeData = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME,
+            UResourceBundle keyTypeData = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME,
                     "keyTypeData", ICUResourceBundle.ICU_DATA_CLASS_LOADER);
             UResourceBundle typeMap = keyTypeData.get("typeMap");
             UResourceBundle typeKeys = typeMap.get("timezone");
@@ -428,7 +430,7 @@ public final class ZoneMeta {
             if (zoneIdx >= 0) {
                 try {
                     UResourceBundle top = UResourceBundle.getBundleInstance(
-                            ICUResourceBundle.ICU_BASE_NAME, ZONEINFORESNAME, ICUResourceBundle.ICU_DATA_CLASS_LOADER);
+                            ICUData.ICU_BASE_NAME, ZONEINFORESNAME, ICUResourceBundle.ICU_DATA_CLASS_LOADER);
                     UResourceBundle regions = top.get(kREGIONS);
                     if (zoneIdx < regions.getSize()) {
                         region = regions.getString(zoneIdx);
@@ -486,7 +488,7 @@ public final class ZoneMeta {
             // Even a country has multiple zones, one of them might be
             // dominant and treated as a primary zone.
             try {
-                UResourceBundle bundle = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, "metaZones");
+                UResourceBundle bundle = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, "metaZones");
                 UResourceBundle primaryZones = bundle.get("primaryZones");
                 String primaryZone = primaryZones.getString(country);
                 if (tzid.equals(primaryZone)) {
@@ -522,7 +524,7 @@ public final class ZoneMeta {
             try {
                 if (top == null) {
                     top = UResourceBundle.getBundleInstance(
-                            ICUResourceBundle.ICU_BASE_NAME, ZONEINFORESNAME, ICUResourceBundle.ICU_DATA_CLASS_LOADER);
+                            ICUData.ICU_BASE_NAME, ZONEINFORESNAME, ICUResourceBundle.ICU_DATA_CLASS_LOADER);
                 }
                 UResourceBundle zones = top.get(kZONES);
                 UResourceBundle zone = zones.get(zoneIdx);
@@ -551,7 +553,7 @@ public final class ZoneMeta {
         protected OlsonTimeZone createInstance(String key, String data) {
             OlsonTimeZone tz = null;
             try {
-                UResourceBundle top = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME,
+                UResourceBundle top = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME,
                         ZONEINFORESNAME, ICUResourceBundle.ICU_DATA_CLASS_LOADER);
                 UResourceBundle res = openOlsonResource(top, data);
                 if (res != null) {
@@ -841,7 +843,9 @@ public final class ZoneMeta {
         if (tz instanceof OlsonTimeZone) {
             canonicalID = ((OlsonTimeZone)tz).getCanonicalID();
         }
-        canonicalID = getCanonicalCLDRID(tz.getID());
+        else {
+            canonicalID = getCanonicalCLDRID(tz.getID());
+        }
         if (canonicalID == null) {
             return null;
         }
@@ -868,7 +872,7 @@ public final class ZoneMeta {
 
         try {
             // First, try check if the given ID is canonical
-            UResourceBundle keyTypeData = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME,
+            UResourceBundle keyTypeData = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME,
                     "keyTypeData", ICUResourceBundle.ICU_DATA_CLASS_LOADER);
             UResourceBundle typeMap = keyTypeData.get("typeMap");
             UResourceBundle typeKeys = typeMap.get("timezone");
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/BOCSU.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/BOCSU.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/coll/BOCSU.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/BOCSU.java
index cf477eb..cc99ee9 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/BOCSU.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/BOCSU.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
 *******************************************************************************
 * Copyright (C) 1996-2014, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/Collation.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/Collation.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/coll/Collation.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/Collation.java
index 7d16cad..3546862 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/Collation.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/Collation.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2010-2015, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/CollationBuilder.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationBuilder.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/coll/CollationBuilder.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/CollationBuilder.java
index fc99d73..abc7109 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/CollationBuilder.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationBuilder.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2013-2015, International Business Machines
@@ -28,6 +30,7 @@ public final class CollationBuilder extends CollationRuleParser.Sink {
     private static final boolean DEBUG = false;
     private static final class BundleImporter implements CollationRuleParser.Importer {
         BundleImporter() {}
+        @Override
         public String getRules(String localeID, String collationType) {
             return CollationLoader.loadRules(new ULocale(localeID), collationType);
         }
@@ -431,7 +434,7 @@ public final class CollationBuilder extends CollationRuleParser.Sink {
     }
 
     /** Implements CollationRuleParser.Sink. */
-    // Java 6: @Override
+    @Override
     void addRelation(int strength, CharSequence prefix, CharSequence str, CharSequence extension) {
         String nfdPrefix;
         if(prefix.length() == 0) {
@@ -585,7 +588,7 @@ public final class CollationBuilder extends CollationRuleParser.Sink {
         int start = 0;
         int limit = length;
         for (;;) {
-            int i = (start + limit) / 2;
+            int i = (int)(((long)start + (long)limit) / 2);
             long node = nodes[rootPrimaryIndexes[i]];
             long nodePrimary = node >>> 32;  // weight32FromNode(node)
             if (p == nodePrimary) {
@@ -1320,6 +1323,7 @@ public final class CollationBuilder extends CollationRuleParser.Sink {
         CEFinalizer(long[] ces) {
             finalCEs = ces;
         }
+        @Override
         public long modifyCE32(int ce32) {
             assert(!Collation.isSpecialCE32(ce32));
             if(CollationBuilder.isTempCE32(ce32)) {
@@ -1329,6 +1333,7 @@ public final class CollationBuilder extends CollationRuleParser.Sink {
                 return Collation.NO_CE;
             }
         }
+        @Override
         public long modifyCE(long ce) {
             if(CollationBuilder.isTempCE(ce)) {
                 // retain case bits
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/CollationCompare.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationCompare.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/coll/CollationCompare.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/CollationCompare.java
index a3a9d2d..5bad642 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/CollationCompare.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationCompare.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2015, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/CollationData.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationData.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/coll/CollationData.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/CollationData.java
index dd21883..b846b07 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/CollationData.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationData.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2010-2015, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/CollationDataBuilder.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationDataBuilder.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/coll/CollationDataBuilder.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/CollationDataBuilder.java
index 6bc792d..d29512a 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/CollationDataBuilder.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationDataBuilder.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2012-2015, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/CollationDataReader.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationDataReader.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/coll/CollationDataReader.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/CollationDataReader.java
index f90e9aa..d4c41d7 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/CollationDataReader.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationDataReader.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2013-2015, International Business Machines
@@ -489,7 +491,7 @@ final class CollationDataReader /* all static */ {
     }
 
     private static final class IsAcceptable implements ICUBinary.Authenticate {
-        // @Override when we switch to Java 6
+        @Override
         public boolean isDataVersionAcceptable(byte version[]) {
             return version[0] == 5;
         }
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/CollationFCD.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationFCD.java
similarity index 79%
rename from app/src/main/java/com/ibm/icu/impl/coll/CollationFCD.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/CollationFCD.java
index 616ed69..55305c7 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/CollationFCD.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationFCD.java
@@ -1,6 +1,8 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
-* Copyright (C) 2012-2015, International Business Machines
+* Copyright (C) 2012-2016, International Business Machines
 * Corporation and others.  All Rights Reserved.
 *******************************************************************************
 * CollationFCD.java, ported from collationfcd.h/.cpp
@@ -121,27 +123,27 @@ public final class CollationFCD {
 0,0,0,0,0,0,0,0,1,1,2,3,0,0,0,0,
 0,0,0,0,4,0,0,0,0,0,0,0,5,6,7,0,
 8,0,9,0xa,0,0,0xb,0xc,0xd,0xe,0xf,0,0,0,0,0x10,
-0x11,0x12,0x13,0,0,0,0,0x14,0,0x15,0x16,0,0,0x15,0x17,0,
-0,0x15,0x17,0,0,0x15,0x17,0,0,0x15,0x17,0,0,0,0x17,0,
-0,0,0x18,0,0,0x15,0x17,0,0,0,0x17,0,0,0,0x19,0,
-0,0x1a,0x1b,0,0,0x1c,0x1b,0,0x1c,0x1d,0,0x1e,0x1f,0,0x20,0,
-0,0x21,0,0,0x17,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0x22,0,0,0,0,0,
+0x11,0x12,0x13,0,0,0,0x14,0x15,0,0x16,0x17,0,0,0x16,0x18,0,
+0,0x16,0x18,0,0,0x16,0x18,0,0,0x16,0x18,0,0,0,0x18,0,
+0,0,0x19,0,0,0x16,0x18,0,0,0,0x18,0,0,0,0x1a,0,
+0,0x1b,0x1c,0,0,0x1d,0x1c,0,0x1d,0x1e,0,0x1f,0x20,0,0x21,0,
+0,0x22,0,0,0x18,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0x23,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0x23,0x23,0,0,0,0,0x24,0,
-0,0,0,0,0,0x25,0,0,0,0x13,0,0,0,0,0,0,
-0x26,0,0,0x27,0,0x28,0,0,0,0x23,0x29,0x10,0,0x2a,0,0x2b,
-0,0x2c,0,0,0,0,0x2d,0x2e,0,0,0,0,0,0,1,0x2f,
+0,0,0,0,0,0,0,0,0x24,0x24,0,0,0,0,0x25,0,
+0,0,0,0,0,0x26,0,0,0,0x13,0,0,0,0,0,0,
+0x27,0,0,0x28,0,0x29,0,0,0,0x24,0x2a,0x10,0,0x2b,0,0x2c,
+0,0x2d,0,0,0,0,0x2e,0x2f,0,0,0,0,0,0,1,0x30,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0x30,0x31,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0x31,0x32,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0x32,0,0,0,0x33,0,0,0,1,
+0,0,0,0,0,0,0,0x33,0,0,0,0x34,0,0,0,1,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0x34,0,0,0x35,0,0,0,0,0,0,0,0,0,0,0,
+0,0x35,0,0,0x36,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
@@ -200,9 +202,9 @@ public final class CollationFCD {
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0x36,0x37,0,0,0x38,0,0,0,0,0,0,0,0,
-0x20,0,0,0,0,0,0x29,0x39,0,0x3a,0x3b,0,0,0x3b,0x3c,0,
-0,0,0,0,0,0x3d,0x3e,0x3f,0,0,0,0,0,0,0,0x17,
+0,0,0,0x37,0x38,0,0,0x39,0,0,0,0,0,0,0,0,
+0x21,0,0,0,0,0,0x2a,0x3a,0,0x3b,0x3c,0,0,0x3c,0x3d,0,
+0,0,0,0,0,0x3e,0x3f,0x40,0,0,0,0,0,0,0,0x18,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
@@ -225,7 +227,7 @@ public final class CollationFCD {
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0x40,0x41,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0x41,0x42,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
 1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,
@@ -242,7 +244,7 @@ public final class CollationFCD {
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0x42,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0x43,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 };
@@ -252,27 +254,27 @@ public final class CollationFCD {
 0xb,0xc,0,0,0,0,0,0,1,1,0xd,0xe,0xf,0x10,0x11,0,
 0x12,0x13,0x14,0x15,0x16,0,0x17,0x18,0,0,0,0,0x19,0x1a,0x1b,0,
 0x1c,0x1d,0x1e,0x1f,0,0,0x20,0x21,0x22,0x23,0x24,0,0,0,0,0x25,
-0x26,0x27,0x28,0,0,0,0,0x29,0,0x2a,0x2b,0,0,0x2c,0x2d,0,
-0,0x2e,0x2f,0,0,0x2c,0x30,0,0,0x2c,0x31,0,0,0,0x30,0,
-0,0,0x32,0,0,0x2c,0x30,0,0,0,0x30,0,0,0,0x33,0,
-0,0x34,0x35,0,0,0x36,0x35,0,0x36,0x37,0,0x38,0x39,0,0x3a,0,
-0,0x3b,0,0,0x30,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0,0,0x3c,0,0,0,0,0,
+0x26,0x27,0x28,0,0,0,0x29,0x2a,0,0x2b,0x2c,0,0,0x2d,0x2e,0,
+0,0x2f,0x30,0,0,0x2d,0x31,0,0,0x2d,0x32,0,0,0,0x31,0,
+0,0,0x33,0,0,0x2d,0x31,0,0,0,0x31,0,0,0,0x34,0,
+0,0x35,0x36,0,0,0x37,0x36,0,0x37,0x38,0,0x39,0x3a,0,0x3b,0,
+0,0x3c,0,0,0x31,0,0,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0,0,0x3d,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0x3d,0x3d,0,0,0,0,0x3e,0,
-0,0,0,0,0,0x3f,0,0,0,0x28,0,0,0,0,0,0,
-0x40,0,0,0x41,0,0x42,0,0,0,0x3d,0x43,0x25,0,0x44,0,0x45,
-0,0x46,0,0,0,0,0x47,0x48,0,0,0,0,0,0,1,0x49,
-1,1,1,1,0x4a,1,1,0x4b,0x4c,1,0x4d,0x4e,1,0x4f,0x50,0x51,
-0,0,0,0,0,0,0x52,0x53,0,0x54,0,0,0x55,0x56,0x57,0,
-0x58,0x59,0x5a,0x5b,0x5c,0x5d,0,0x5e,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0x3e,0x3e,0,0,0,0,0x3f,0,
+0,0,0,0,0,0x40,0,0,0,0x28,0,0,0,0,0,0,
+0x41,0,0,0x42,0,0x43,0,0,0,0x3e,0x44,0x25,0,0x45,0,0x46,
+0,0x47,0,0,0,0,0x48,0x49,0,0,0,0,0,0,1,0x4a,
+1,1,1,1,0x4b,1,1,0x4c,0x4d,1,0x4e,0x4f,1,0x50,0x51,0x52,
+0,0,0,0,0,0,0x53,0x54,0,0x55,0,0,0x56,0x57,0x58,0,
+0x59,0x5a,0x5b,0x5c,0x5d,0x5e,0,0x5f,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0x2c,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0x5f,0,0,0,0x60,0,0,0,1,
+0,0,0,0,0,0,0x2d,0,0,0,0,0,0,0,0,0,
+0,0,0,0,0,0,0,0x60,0,0,0,0x61,0,0,0,1,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0x61,0x62,0x63,0x64,0x62,0x63,0x65,0,0,0,0,0,0,0,0,
+0,0x62,0x63,0x64,0x65,0x63,0x64,0x66,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
@@ -331,9 +333,9 @@ public final class CollationFCD {
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0x66,0x67,0,0,0x68,0,0,0,0,0,0,0,0,
-0x3a,0,0,0,0,0,0x43,0x69,0,0x6a,0x6b,0,0,0x6b,0x6c,0,
-0,0,0,0,0,0x6d,0x6e,0x6f,0,0,0,0,0,0,0,0x30,
+0,0,0,0x67,0x68,0,0,0x69,0,0,0,0,0,0,0,0,
+0x3b,0,0,0,0,0,0x44,0x6a,0,0x6b,0x6c,0,0,0x6c,0x6d,0,
+0,0,0,0,0,0x6e,0x6f,0x70,0,0,0,0,0,0,0,0x31,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
@@ -356,7 +358,7 @@ public final class CollationFCD {
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0x70,0x71,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
+0x71,0x72,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
@@ -373,27 +375,27 @@ public final class CollationFCD {
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
-0,0,0,0,0,0,0,0,0x3c,0x72,0x73,0,0,0,0,0,
+0,0,0,0,0,0,0,0,0x3d,0x73,0x74,0,0,0,0,0,
 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
 0,0xe,0,0,0,0,0,0,0,0,0,0,0,0,0,0
 };
 
     private static final int[] lcccBits={
 0,0xffffffff,0xffff7fff,0xffff,0xf8,0xfffe0000,0xbfffffff,0xb6,0x7ff0000,0xfffff800,0x10000,0x9fc00000,0x3d9f,0x20000,0xffff0000,0x7ff,
-0xff800,0xfbc00000,0x3eef,0xe000000,0xfffffff8,0x10000000,0x1e2000,0x2000,0x602000,0x400,0x7000000,0xf00,0x3000000,0x2a00000,0x3c3e0000,0xdf,
-0x40,0x6800000,0xe0000000,0x100000,0x20040000,0x200,0x1800000,0x9fe00001,0x3fff0000,0x10,0xc00,0xc0040,0x800000,0xfff70000,0x31021fd,0xf03fffff,
-0x1fff0000,0x1ffe2,0x38000,0x80000000,0xfc00,0x6000000,0x3ff08000,0xc0000000,0x30000,0x3ffff,0x3800,0x80000,1,0xc19d0000,2,0x400000,
-0x4000035,0x4108000,0x40000000
+0xff800,0xfbc00000,0x3eef,0xe000000,0xfff00000,0xfffffffb,0x10000000,0x1e2000,0x2000,0x602000,0x400,0x7000000,0xf00,0x3000000,0x2a00000,0x3c3e0000,
+0xdf,0x40,0x6800000,0xe0000000,0x100000,0x20040000,0x200,0x1800000,0x9fe00001,0x3fff0000,0x10,0xc00,0xc0040,0x800000,0xfff70000,0x31021fd,
+0xf83fffff,0x1fff0000,0x1ffe2,0x38000,0x80000000,0xfc00,0x6000000,0x3ff08000,0xc0000000,0x30000,0x3ffff,0x3800,0x80000,1,0xc19d0000,2,
+0x400000,0x40000b5,0x5108000,0x40000000
 };
     private static final int[] tcccBits={
 0,0xffffffff,0x3e7effbf,0xbe7effbf,0xfffcffff,0x7ef1ff3f,0xfff3f1f8,0x7fffff3f,0x18003,0xdfffe000,0xff31ffcf,0xcfffffff,0xfffc0,0xffff7fff,0xffff,0x1d760,
 0x1fc00,0x187c00,0x200708b,0x2000000,0x708b0000,0xc00000,0xf8,0xfccf0006,0x33ffcfc,0xfffe0000,0xbfffffff,0xb6,0x7ff0000,0x7c,0xfffff800,0x10000,
-0x9fc80005,0x3d9f,0x20000,0xffff0000,0x7ff,0xff800,0xfbc00000,0x3eef,0xe000000,0xfffffff8,0x10120200,0xff1e2000,0x10000000,0xb0002000,0x10480000,0x4e002000,
-0x2000,0x30002000,0x602100,0x24000400,0x7000000,0xf00,0x3000000,0x2a00000,0x3d7e0000,0xdf,0x40,0x6800000,0xe0000000,0x100000,0x20040000,0x200,
-0x1800000,0x9fe00001,0x3fff0000,0x10,0xc00,0xc0040,0x800000,0xfff70000,0x31021fd,0xf03fffff,0xbffffff,0x3ffffff,0x3f3fffff,0xaaff3f3f,0x3fffffff,0x1fdfffff,
-0xefcfffde,0x1fdc7fff,0x1fff0000,0x1ffe2,0x800,0xc000000,0x4000,0xe000,0x1210,0x50,0x292,0x333e005,0x333,0xf000,0x3c0f,0x38000,
-0x80000000,0xfc00,0x55555000,0x36db02a5,0x46100000,0x47900000,0x3ff08000,0xc0000000,0x30000,0x3ffff,0x3800,0x80000,1,0xc19d0000,2,0x400000,
-0x4000035,0x4108000,0x5f7ffc00,0x7fdb
+0x9fc80005,0x3d9f,0x20000,0xffff0000,0x7ff,0xff800,0xfbc00000,0x3eef,0xe000000,0xfff00000,0xfffffffb,0x10120200,0xff1e2000,0x10000000,0xb0002000,0x10480000,
+0x4e002000,0x2000,0x30002000,0x602100,0x24000400,0x7000000,0xf00,0x3000000,0x2a00000,0x3d7e0000,0xdf,0x40,0x6800000,0xe0000000,0x100000,0x20040000,
+0x200,0x1800000,0x9fe00001,0x3fff0000,0x10,0xc00,0xc0040,0x800000,0xfff70000,0x31021fd,0xf83fffff,0xbffffff,0x3ffffff,0x3f3fffff,0xaaff3f3f,0x3fffffff,
+0x1fdfffff,0xefcfffde,0x1fdc7fff,0x1fff0000,0x1ffe2,0x800,0xc000000,0x4000,0xe000,0x1210,0x50,0x292,0x333e005,0x333,0xf000,0x3c0f,
+0x38000,0x80000000,0xfc00,0x55555000,0x36db02a5,0x46100000,0x47900000,0x3ff08000,0xc0000000,0x30000,0x3ffff,0x3800,0x80000,1,0xc19d0000,2,
+0x400000,0x40000b5,0x5108000,0x5f7ffc00,0x7fdb
 };
 
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/CollationFastLatin.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationFastLatin.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/coll/CollationFastLatin.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/CollationFastLatin.java
index 1481c63..1c5033e 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/CollationFastLatin.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationFastLatin.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2013-2015, International Business Machines
@@ -202,8 +204,10 @@ public final class CollationFastLatin /* all static */ {
         char[] header = data.fastLatinTableHeader;
         if(header == null) { return -1; }
         assert((header[0] >> 8) == VERSION);
-        assert(primaries.length == LATIN_LIMIT);
-        if(primaries.length != LATIN_LIMIT) { return -1; }
+        if(primaries.length != LATIN_LIMIT) {
+            assert false;
+            return -1;
+        }
 
         int miniVarTop;
         if((settings.options & CollationSettings.ALTERNATE_MASK) == 0) {
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/CollationFastLatinBuilder.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationFastLatinBuilder.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/coll/CollationFastLatinBuilder.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/CollationFastLatinBuilder.java
index 2a62475..08642f0 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/CollationFastLatinBuilder.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationFastLatinBuilder.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2013-2015, International Business Machines
@@ -43,7 +45,7 @@ final class CollationFastLatinBuilder {
         if (limit == 0) { return ~0; }
         int start = 0;
         for (;;) {
-            int i = (start + limit) / 2;
+            int i = (int)(((long)start + (long)limit) / 2);
             int cmp = compareInt64AsUnsigned(ce, list[i]);
             if (cmp == 0) {
                 return i;
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/CollationIterator.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationIterator.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/coll/CollationIterator.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/CollationIterator.java
index 8295382..91051fe 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/CollationIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2010-2014, International Business Machines
@@ -217,6 +219,12 @@ public abstract class CollationIterator {
         return true;
     }
 
+    @Override
+    public int hashCode() {
+        // Dummy return to prevent compile warnings.
+        return 0;
+    }
+
     /**
      * Resets the iterator state and sets the position to the specified offset.
      * Subclasses must implement, and must call the parent class method,
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/CollationKeys.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationKeys.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/coll/CollationKeys.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/CollationKeys.java
index 9f1cb92..ea833d9 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/CollationKeys.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationKeys.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2012-2015, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/CollationLoader.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationLoader.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/impl/coll/CollationLoader.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/CollationLoader.java
index af28dcd..f3b3430 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/CollationLoader.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationLoader.java
@@ -1,7 +1,9 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 *
-*   Copyright (C) 1996-2015, International Business Machines
+*   Copyright (C) 1996-2016, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 *
 *******************************************************************************
@@ -17,6 +19,7 @@ import java.io.IOException;
 import java.nio.ByteBuffer;
 import java.util.MissingResourceException;
 
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.util.ICUUncheckedIOException;
 import com.ibm.icu.util.Output;
@@ -41,7 +44,7 @@ public final class CollationLoader {
         synchronized(CollationLoader.class) {
             if (rootRules == null) {
                 UResourceBundle rootBundle = UResourceBundle.getBundleInstance(
-                        ICUResourceBundle.ICU_COLLATION_BASE_NAME, ULocale.ROOT);
+                        ICUData.ICU_COLLATION_BASE_NAME, ULocale.ROOT);
                 rootRules = rootBundle.getString("UCARules");
             }
         }
@@ -78,7 +81,7 @@ public final class CollationLoader {
 
     static String loadRules(ULocale locale, String collationType) {
         UResourceBundle bundle = UResourceBundle.getBundleInstance(
-                ICUResourceBundle.ICU_COLLATION_BASE_NAME, locale);
+                ICUData.ICU_COLLATION_BASE_NAME, locale);
         UResourceBundle data = ((ICUResourceBundle)bundle).getWithFallback(
                 "collations/" + ASCII.toLowerCase(collationType));
         String rules = data.getString("Sequence");
@@ -105,7 +108,7 @@ public final class CollationLoader {
         UResourceBundle bundle = null;
         try {
             bundle = ICUResourceBundle.getBundleInstance(
-                    ICUResourceBundle.ICU_COLLATION_BASE_NAME, locale,
+                    ICUData.ICU_COLLATION_BASE_NAME, locale,
                     ICUResourceBundle.OpenType.LOCALE_ROOT);
         } catch (MissingResourceException e) {
             outValidLocale.value = ULocale.ROOT;
@@ -226,7 +229,7 @@ public final class CollationLoader {
         if (!actualLocale.equals(validLocale)) {
             // Opening a bundle for the actual locale should always succeed.
             UResourceBundle actualBundle = UResourceBundle.getBundleInstance(
-                    ICUResourceBundle.ICU_COLLATION_BASE_NAME, actualLocale);
+                    ICUData.ICU_COLLATION_BASE_NAME, actualLocale);
             defT = ((ICUResourceBundle)actualBundle).findStringWithFallback("collations/default");
             if (defT != null) {
                 defaultType = defT;
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/CollationRoot.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationRoot.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/impl/coll/CollationRoot.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/CollationRoot.java
index 185fe55..645c1f3 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/CollationRoot.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationRoot.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2012-2014, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/CollationRootElements.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationRootElements.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/coll/CollationRootElements.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/CollationRootElements.java
index cf2ce93..d804fb6 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/CollationRootElements.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationRootElements.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2013-2014, International Business Machines
@@ -451,7 +453,7 @@ public final class CollationRootElements {
         while((start + 1) < limit) {
             // Invariant: elements[start] and elements[limit] are primaries,
             // and elements[start]<=p<=elements[limit].
-            int i = (start + limit) / 2;
+            int i = (int)(((long)start + (long)limit) / 2);
             long q = elements[i];
             if((q & SEC_TER_DELTA_FLAG) != 0) {
                 // Find the next primary.
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/CollationRuleParser.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationRuleParser.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/coll/CollationRuleParser.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/CollationRuleParser.java
index 826a215..5a3bcb2 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/CollationRuleParser.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationRuleParser.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2013-2015, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/CollationSettings.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationSettings.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/coll/CollationSettings.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/CollationSettings.java
index 76f22b2..34865c0 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/CollationSettings.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationSettings.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2013-2015, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/CollationTailoring.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationTailoring.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/coll/CollationTailoring.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/CollationTailoring.java
index b46b519..303ff2d 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/CollationTailoring.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationTailoring.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2013-2015, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/CollationWeights.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationWeights.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/coll/CollationWeights.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/CollationWeights.java
index 0ef521e..80a1d23 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/CollationWeights.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/CollationWeights.java
@@ -1,4 +1,6 @@
-/*  
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
+/*
 *******************************************************************************
 *
 *   Copyright (C) 1999-2015, International Business Machines
@@ -158,7 +160,7 @@ public final class CollationWeights {
         long start, end;
         int length, count;
 
-        // Java 6: @Override
+        @Override
         public int compareTo(WeightRange other) {
             long l=start;
             long r=other.start;
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/ContractionsAndExpansions.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/ContractionsAndExpansions.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/coll/ContractionsAndExpansions.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/ContractionsAndExpansions.java
index 152cf49..bd0e817 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/ContractionsAndExpansions.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/ContractionsAndExpansions.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2013-2014, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/FCDIterCollationIterator.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/FCDIterCollationIterator.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/coll/FCDIterCollationIterator.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/FCDIterCollationIterator.java
index 862994d..95024b9 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/FCDIterCollationIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/FCDIterCollationIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2012-2014, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/FCDUTF16CollationIterator.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/FCDUTF16CollationIterator.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/impl/coll/FCDUTF16CollationIterator.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/FCDUTF16CollationIterator.java
index 40b7d39..9463ef2 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/FCDUTF16CollationIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/FCDUTF16CollationIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2010-2014, International Business Machines
@@ -37,14 +39,24 @@ public final class FCDUTF16CollationIterator extends UTF16CollationIterator {
     @Override
     public boolean equals(Object other) {
         // Skip the UTF16CollationIterator and call its parent.
-        if(!((CollationIterator)this).equals(other)) { return false; }
+        if (!(other instanceof CollationIterator)
+            || !((CollationIterator)this).equals(other)
+            || !(other instanceof FCDUTF16CollationIterator))
+        {
+            return false;
+        }
         FCDUTF16CollationIterator o = (FCDUTF16CollationIterator)other;
         // Compare the iterator state but not the text: Assume that the caller does that.
-        if(checkDir != o.checkDir) { return false; }
-        if(checkDir == 0 && (seq == rawSeq) != (o.seq == o.rawSeq)) { return false; }
-        if(checkDir != 0 || seq == rawSeq) {
+        if (checkDir != o.checkDir) {
+            return false;
+        }
+        if (checkDir == 0 && (seq == rawSeq) != (o.seq == o.rawSeq)) {
+            return false;
+        }
+        if (checkDir != 0 || seq == rawSeq) {
             return (pos - rawStart) == (o.pos - /*o.*/ rawStart);
-        } else {
+        }
+        else {
             return (segmentStart - rawStart) == (o.segmentStart - /*o.*/ rawStart) &&
                     (pos - start) == (o.pos - o.start);
         }
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/IterCollationIterator.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/IterCollationIterator.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/impl/coll/IterCollationIterator.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/IterCollationIterator.java
index 378c91e..6a23647 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/IterCollationIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/IterCollationIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2012-2014, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/SharedObject.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/SharedObject.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/coll/SharedObject.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/SharedObject.java
index 7f42c0d..234e108 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/SharedObject.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/SharedObject.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2013-2014, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/TailoredSet.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/TailoredSet.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/coll/TailoredSet.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/TailoredSet.java
index c9cd039..26ce864 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/TailoredSet.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/TailoredSet.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2013-2014, International Business Machines
@@ -15,6 +17,7 @@ import java.util.Iterator;
 
 import com.ibm.icu.impl.Normalizer2Impl.Hangul;
 import com.ibm.icu.impl.Trie2;
+import com.ibm.icu.impl.Utility;
 import com.ibm.icu.text.UnicodeSet;
 import com.ibm.icu.util.CharsTrie;
 import com.ibm.icu.util.CharsTrie.Entry;
@@ -256,7 +259,7 @@ public final class TailoredSet {
                     bp = none;
                 }
             }
-            if (tp == none && bp == none) {
+            if (Utility.sameObjects(tp, none) && Utility.sameObjects(bp, none)) {
                 break;
             }
             int cmp = tp.compareTo(bp);
@@ -313,7 +316,7 @@ public final class TailoredSet {
                     bs = none;
                 }
             }
-            if (ts == none && bs == none) {
+            if (Utility.sameObjects(ts, none) && Utility.sameObjects(bs, none)) {
                 break;
             }
             int cmp = ts.compareTo(bs);
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/UTF16CollationIterator.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/UTF16CollationIterator.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/coll/UTF16CollationIterator.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/UTF16CollationIterator.java
index 938b049..02dae66 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/UTF16CollationIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/UTF16CollationIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2010-2014, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/UVector32.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/UVector32.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/impl/coll/UVector32.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/UVector32.java
index 8813268..ff617e1 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/UVector32.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/UVector32.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/impl/coll/UVector64.java b/icu4j/src/main/java/com/ibm/icu/impl/coll/UVector64.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/impl/coll/UVector64.java
rename to icu4j/src/main/java/com/ibm/icu/impl/coll/UVector64.java
index 409808a..3d4e3e4 100644
--- a/app/src/main/java/com/ibm/icu/impl/coll/UVector64.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/coll/UVector64.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle.java
similarity index 67%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle.java
index b6ae0e5..10fdfea 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2005, International Business Machines Corporation and    *
@@ -12,17 +14,19 @@ import java.util.ListResourceBundle;
 public class HolidayBundle extends ListResourceBundle {
 
     // Normally, each HolidayBundle uses the holiday's US English name
-    // as the string key for looking up the localized name.  This means
+    // as the string key for looking up the localized name. This means
     // that the key itself can be used if no name is found for the requested
     // locale.
     //
     // For holidays where the key is _not_ the English name, e.g. in the
     // case of conflicts, the English name must be given here.
     //
-    static private final Object[][] fContents = {
-        {   "", ""  },      // Can't be empty!
+    static private final Object[][] fContents = { { "", "" }, // Can't be empty!
     };
 
-    public synchronized Object[][] getContents() { return fContents; }
+    @Override
+    public synchronized Object[][] getContents() {
+        return fContents;
+    }
 
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_da.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_da.java
similarity index 90%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_da.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_da.java
index b4ce7f5..61f7896 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_da.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_da.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2005, International Business Machines Corporation and    *
@@ -26,5 +28,6 @@ public class HolidayBundle_da extends ListResourceBundle
         {   "Pentecost",            "pinse" },
         {   "Shrove Tuesday",       "hvidetirsdag" },
     };
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 }
diff --git a/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_da_DK.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_da_DK.java
new file mode 100644
index 0000000..7b151de
--- /dev/null
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_da_DK.java
@@ -0,0 +1,35 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
+/*
+ *******************************************************************************
+ * Copyright (C) 1996-2010, International Business Machines Corporation and    *
+ * others. All Rights Reserved.                                                *
+ *******************************************************************************
+ */
+
+package com.ibm.icu.impl.data;
+
+import java.util.Calendar;
+import java.util.ListResourceBundle;
+
+import com.ibm.icu.util.EasterHoliday;
+import com.ibm.icu.util.Holiday;
+import com.ibm.icu.util.SimpleHoliday;
+
+public class HolidayBundle_da_DK extends ListResourceBundle {
+    static private final Holiday[] fHolidays = { SimpleHoliday.NEW_YEARS_DAY,
+            new SimpleHoliday(Calendar.APRIL, 30, -Calendar.FRIDAY, "General Prayer Day"),
+            new SimpleHoliday(Calendar.JUNE, 5, "Constitution Day"), SimpleHoliday.CHRISTMAS_EVE,
+            SimpleHoliday.CHRISTMAS, SimpleHoliday.BOXING_DAY, SimpleHoliday.NEW_YEARS_EVE,
+
+            // Easter and related holidays
+            EasterHoliday.MAUNDY_THURSDAY, EasterHoliday.GOOD_FRIDAY, EasterHoliday.EASTER_SUNDAY,
+            EasterHoliday.EASTER_MONDAY, EasterHoliday.ASCENSION, EasterHoliday.WHIT_MONDAY, };
+
+    static private final Object[][] fContents = { { "holidays", fHolidays }, };
+
+    @Override
+    public synchronized Object[][] getContents() {
+        return fContents;
+    }
+}
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_de.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_de.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_de.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_de.java
index 35b10f2..bef264c 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_de.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_de.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2005, International Business Machines Corporation and    *
@@ -63,5 +65,6 @@ public class HolidayBundle_de extends ListResourceBundle {
         {   "Whit Sunday",                  "Pfingstsonntag" },
     };
 
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_de_AT.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_de_AT.java
similarity index 92%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_de_AT.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_de_AT.java
index 9bbb5cc..2728e89 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_de_AT.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_de_AT.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
@@ -42,5 +44,6 @@ public class HolidayBundle_de_AT extends ListResourceBundle {
         {   "Christmas",        "Christtag" },
         {   "New Year's Day",   "Neujahrstag" },
     };
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_de_DE.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_de_DE.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_de_DE.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_de_DE.java
index ddbc4f6..d92a5e8 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_de_DE.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_de_DE.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
@@ -37,5 +39,6 @@ public class HolidayBundle_de_DE extends ListResourceBundle {
     static private final Object[][] fContents = {
         { "holidays",   fHolidays },
     };
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_el.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_el.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_el.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_el.java
index f9d76ba..9a9e05b 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_el.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_el.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2005, International Business Machines Corporation and    *
@@ -25,5 +27,6 @@ public class HolidayBundle_el extends ListResourceBundle {
         {   "Whit Monday",          "\u0394\u03b5\u03cd\u03c4\u03b5\u03c1\u03b7 \u03bc\u03ad\u03c1\u03b1 \u03c4\u03bf\u03cd \u03a0\u03b5\u03bd\u03c4\u03b7\u03ba\u03bf\u03c3\u03c4\u03ae" },
 
     };
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_el_GR.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_el_GR.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_el_GR.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_el_GR.java
index 779cb7e..4f5225a 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_el_GR.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_el_GR.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
@@ -38,5 +40,6 @@ public class HolidayBundle_el_GR extends ListResourceBundle {
     static private final Object[][] fContents = {
         {   "holidays",         fHolidays   },
     };
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en.java
similarity index 88%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en.java
index abc51e7..004ec2b 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2005, International Business Machines Corporation and    *
@@ -23,6 +25,7 @@ public class HolidayBundle_en extends ListResourceBundle {
         {   "", ""  },      // Can't be empty!
     };
 
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en_CA.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en_CA.java
similarity index 92%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en_CA.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en_CA.java
index 8ec3a22..3b44c81 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en_CA.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en_CA.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
@@ -38,5 +40,6 @@ public class HolidayBundle_en_CA extends ListResourceBundle {
 
         { "Labor Day",  "Labour Day" },
     };
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en_GB.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en_GB.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en_GB.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en_GB.java
index 0c9cb4c..92f7270 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en_GB.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en_GB.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
@@ -35,5 +37,6 @@ public class HolidayBundle_en_GB extends ListResourceBundle
 
         { "Labor Day",  "Labour Day" },
     };
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en_US.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en_US.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en_US.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en_US.java
index ca36adb..5a672ca 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en_US.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_en_US.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
@@ -45,5 +47,6 @@ public class HolidayBundle_en_US extends ListResourceBundle
     static private final Object[][] fContents = {
         { "holidays",   fHolidays },
     };
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_es.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_es.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_es.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_es.java
index 1492564..df9293c 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_es.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_es.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2005, International Business Machines Corporation and    *
@@ -46,5 +48,6 @@ public class HolidayBundle_es extends ListResourceBundle {
         {   "Whit Sunday",              "Pentecost\u00e9s" },
     };
 
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_es_MX.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_es_MX.java
similarity index 92%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_es_MX.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_es_MX.java
index 65eacac..c2a02d0 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_es_MX.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_es_MX.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
@@ -32,5 +34,6 @@ public class HolidayBundle_es_MX extends ListResourceBundle {
     static private final Object[][] fContents = {
         { "holidays",   fHolidays },
     };
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_fr.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_fr.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_fr.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_fr.java
index 4564778..ee3d0ea 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_fr.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_fr.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2005, International Business Machines Corporation and    *
@@ -39,5 +41,6 @@ public class HolidayBundle_fr extends ListResourceBundle {
         {   "Victory Day",          "F\u00EAte de la Victoire" },
     };
 
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_fr_CA.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_fr_CA.java
similarity index 92%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_fr_CA.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_fr_CA.java
index a004c9e..edd28a1 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_fr_CA.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_fr_CA.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
@@ -36,5 +38,6 @@ public class HolidayBundle_fr_CA extends ListResourceBundle {
     static private final Object[][] fContents = {
         { "holidays",   fHolidays },
     };
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_fr_FR.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_fr_FR.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_fr_FR.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_fr_FR.java
index 3023424..d3212ff 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_fr_FR.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_fr_FR.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
@@ -35,5 +37,6 @@ public class HolidayBundle_fr_FR extends ListResourceBundle {
     static private final Object[][] fContents = {
         { "holidays",   fHolidays },
     };
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_it.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_it.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_it.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_it.java
index c12bdc7..3446201 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_it.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_it.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2005, International Business Machines Corporation and    *
@@ -31,5 +33,6 @@ public class HolidayBundle_it extends ListResourceBundle {
         {   "Thanksgiving",         "Giorno del Ringraziamento" },
 
     };
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_it_IT.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_it_IT.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_it_IT.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_it_IT.java
index 85fa1db..b0c2511 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_it_IT.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_it_IT.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
@@ -34,5 +36,6 @@ public class HolidayBundle_it_IT extends ListResourceBundle {
     static private final Object[][] fContents = {
         { "holidays",           fHolidays },
     };
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_iw.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_iw.java
similarity index 82%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_iw.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_iw.java
index 53ab7f6..3fc72e0 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_iw.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_iw.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2005, International Business Machines Corporation and    *
@@ -15,6 +17,7 @@ public class HolidayBundle_iw extends ListResourceBundle {
         {   "", ""  },      // Can't be empty!
     };
 
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_iw_IL.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_iw_IL.java
similarity index 87%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_iw_IL.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_iw_IL.java
index fb053e3..5245619 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_iw_IL.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_iw_IL.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
@@ -26,5 +28,6 @@ public class HolidayBundle_iw_IL extends ListResourceBundle {
     static private final Object[][] fContents = {
         { "holidays",   fHolidays },
     };
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_ja_JP.java b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_ja_JP.java
similarity index 86%
rename from app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_ja_JP.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_ja_JP.java
index 9318153..779b469 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/HolidayBundle_ja_JP.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/HolidayBundle_ja_JP.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
@@ -20,5 +22,6 @@ public class HolidayBundle_ja_JP extends ListResourceBundle {
     static private final Object[][] fContents = {
         {   "holidays",         fHolidays   },
     };
+    @Override
     public synchronized Object[][] getContents() { return fContents; }
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/data/ResourceReader.java b/icu4j/src/main/java/com/ibm/icu/impl/data/ResourceReader.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/data/ResourceReader.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/ResourceReader.java
index b79142f..d2b63fb 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/ResourceReader.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/ResourceReader.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
  *******************************************************************************
  * Copyright (C) 2001-2015, International Business Machines Corporation and
@@ -36,7 +38,7 @@ public class ResourceReader implements Closeable {
     private String resourceName;
     private String encoding; // null for default encoding
     private Class<?> root;
-    
+
     /**
      * The one-based line number. Has the special value -1 before the
      * object is initialized. Has the special value 0 after initialization
@@ -101,7 +103,7 @@ public class ResourceReader implements Closeable {
 
          this.lineNo = -1;
          try {
-             InputStreamReader isr = (encoding == null) 
+             InputStreamReader isr = (encoding == null)
                  ? new InputStreamReader(is)
                  : new InputStreamReader(is, encoding);
 
@@ -198,7 +200,7 @@ public class ResourceReader implements Closeable {
     public int getLineNumber() {
         return lineNo;
     }
-    
+
     /**
      * Return a string description of the position of the last line
      * returned by readLine() or readLineSkippingComments().
@@ -206,7 +208,7 @@ public class ResourceReader implements Closeable {
     public String describePosition() {
         return resourceName + ':' + lineNo;
     }
-    
+
     /**
      * Reset this reader so that the next call to
      * <code>readLine()</code> returns the first line of the file
@@ -242,7 +244,7 @@ public class ResourceReader implements Closeable {
         if (is == null) {
             throw new IllegalArgumentException("Can't open " + resourceName);
         }
-        
+
         InputStreamReader isr =
             (encoding == null) ? new InputStreamReader(is) :
                                  new InputStreamReader(is, encoding);
@@ -255,6 +257,7 @@ public class ResourceReader implements Closeable {
      * associated with it. If the stream is already closed then invoking
      * this method has no effect.
      */
+    @Override
     public void close() throws IOException {
         if (reader != null) {
             reader.close();
diff --git a/app/src/main/java/com/ibm/icu/impl/data/TokenIterator.java b/icu4j/src/main/java/com/ibm/icu/impl/data/TokenIterator.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/data/TokenIterator.java
rename to icu4j/src/main/java/com/ibm/icu/impl/data/TokenIterator.java
index bbd4255..9ca94a8 100644
--- a/app/src/main/java/com/ibm/icu/impl/data/TokenIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/data/TokenIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 **********************************************************************
 * Copyright (c) 2004-2015, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/BasicDurationFormat.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/BasicDurationFormat.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/impl/duration/BasicDurationFormat.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/BasicDurationFormat.java
index ebe656a..b8cadea 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/BasicDurationFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/BasicDurationFormat.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2007-2013, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/BasicDurationFormatter.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/BasicDurationFormatter.java
similarity index 83%
rename from app/src/main/java/com/ibm/icu/impl/duration/BasicDurationFormatter.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/BasicDurationFormatter.java
index 5da9595..e0adf54 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/BasicDurationFormatter.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/BasicDurationFormatter.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2007-2014, International Business Machines Corporation and   *
@@ -27,7 +29,7 @@ class BasicDurationFormatter implements DurationFormatter {
    * the locales and timezones of these are in sync.
    */
   public BasicDurationFormatter(PeriodFormatter formatter,
-                                PeriodBuilder builder, 
+                                PeriodBuilder builder,
                                 DateFormatter fallback,
                                 long fallbackLimit) {
     this.formatter = formatter;
@@ -37,7 +39,7 @@ class BasicDurationFormatter implements DurationFormatter {
   }
 
   protected BasicDurationFormatter(PeriodFormatter formatter,
-                                   PeriodBuilder builder, 
+                                   PeriodBuilder builder,
                                    DateFormatter fallback,
                                    long fallbackLimit,
                                    String localeName,
@@ -50,17 +52,20 @@ class BasicDurationFormatter implements DurationFormatter {
     this.timeZone = timeZone;
   }
 
+  @Override
   public String formatDurationFromNowTo(Date targetDate) {
     long now = System.currentTimeMillis();
     long duration = targetDate.getTime() - now;
     return formatDurationFrom(duration, now);
   }
 
-  public String formatDurationFromNow(long duration) {
+  @Override
+public String formatDurationFromNow(long duration) {
     return formatDurationFrom(duration, System.currentTimeMillis());
   }
 
-  public String formatDurationFrom(long duration, long referenceDate) {
+  @Override
+public String formatDurationFrom(long duration, long referenceDate) {
     String s = doFallback(duration, referenceDate);
     if (s == null) {
       Period p = doBuild(duration, referenceDate);
@@ -69,12 +74,13 @@ class BasicDurationFormatter implements DurationFormatter {
     return s;
   }
 
-  public DurationFormatter withLocale(String locName) {
+  @Override
+public DurationFormatter withLocale(String locName) {
     if (!locName.equals(localeName)) {
       PeriodFormatter newFormatter = formatter.withLocale(locName);
       PeriodBuilder newBuilder = builder.withLocale(locName);
-      DateFormatter newFallback = fallback == null 
-          ? null 
+      DateFormatter newFallback = fallback == null
+          ? null
           : fallback.withLocale(locName);
       return new BasicDurationFormatter(newFormatter, newBuilder,
                                         newFallback, fallbackLimit,
@@ -83,11 +89,12 @@ class BasicDurationFormatter implements DurationFormatter {
     return this;
   }
 
-  public DurationFormatter withTimeZone(TimeZone tz) {
+  @Override
+public DurationFormatter withTimeZone(TimeZone tz) {
     if (!tz.equals(timeZone)) {
       PeriodBuilder newBuilder = builder.withTimeZone(tz);
-      DateFormatter newFallback = fallback == null 
-          ? null 
+      DateFormatter newFallback = fallback == null
+          ? null
           : fallback.withTimeZone(tz);
       return new BasicDurationFormatter(formatter, newBuilder,
                                         newFallback, fallbackLimit,
@@ -97,7 +104,7 @@ class BasicDurationFormatter implements DurationFormatter {
   }
 
   protected String doFallback(long duration, long referenceDate) {
-    if (fallback != null 
+    if (fallback != null
         && fallbackLimit > 0
         && Math.abs(duration) >= fallbackLimit) {
       return fallback.format(referenceDate + duration);
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/BasicDurationFormatterFactory.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/BasicDurationFormatterFactory.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/impl/duration/BasicDurationFormatterFactory.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/BasicDurationFormatterFactory.java
index 2a95be7..4fbeb64 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/BasicDurationFormatterFactory.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/BasicDurationFormatterFactory.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2007-2009, International Business Machines Corporation and   *
@@ -45,6 +47,7 @@ class BasicDurationFormatterFactory implements DurationFormatterFactory {
    *
    * @return this BasicDurationFormatterFactory
    */
+  @Override
   public DurationFormatterFactory setPeriodFormatter(
       PeriodFormatter formatter) {
     if (formatter != this.formatter) {
@@ -61,6 +64,7 @@ class BasicDurationFormatterFactory implements DurationFormatterFactory {
    * @param builder the builder to use
    * @return this BasicDurationFormatterFactory
    */
+  @Override
   public DurationFormatterFactory setPeriodBuilder(PeriodBuilder builder) {
     if (builder != this.builder) {
       this.builder = builder;
@@ -75,6 +79,7 @@ class BasicDurationFormatterFactory implements DurationFormatterFactory {
    * @param fallback the fallback formatter to use, or null
    * @return this BasicDurationFormatterFactory
    */
+  @Override
   public DurationFormatterFactory setFallback(DateFormatter fallback) {
     boolean doReset = fallback == null
         ? this.fallback != null
@@ -92,6 +97,7 @@ class BasicDurationFormatterFactory implements DurationFormatterFactory {
    * @param fallbackLimit the fallback limit to use, or 0 if none is desired.
    * @return this BasicDurationFormatterFactory
    */
+  @Override
   public DurationFormatterFactory setFallbackLimit(long fallbackLimit) {
     if (fallbackLimit < 0) {
       fallbackLimit = 0;
@@ -104,12 +110,13 @@ class BasicDurationFormatterFactory implements DurationFormatterFactory {
   }
 
   /**
-   * Set the name of the locale that will be used when 
+   * Set the name of the locale that will be used when
    * creating new formatters.
    *
    * @param localeName the name of the Locale
    * @return this BasicDurationFormatterFactory
    */
+  @Override
   public DurationFormatterFactory setLocale(String localeName) {
     if (!localeName.equals(this.localeName)) {
       this.localeName = localeName;
@@ -125,12 +132,13 @@ class BasicDurationFormatterFactory implements DurationFormatterFactory {
   }
 
   /**
-   * Set the name of the locale that will be used when 
+   * Set the name of the locale that will be used when
    * creating new formatters.
    *
    * @param timeZone The time zone to use.
    * @return this BasicDurationFormatterFactory
    */
+  @Override
   public DurationFormatterFactory setTimeZone(TimeZone timeZone) {
     if (!timeZone.equals(this.timeZone)) {
       this.timeZone = timeZone;
@@ -147,6 +155,7 @@ class BasicDurationFormatterFactory implements DurationFormatterFactory {
    *
    * @return a BasicDurationFormatter
    */
+  @Override
   public DurationFormatter getFormatter() {
     if (f == null) {
       if (fallback != null) {
@@ -230,7 +239,7 @@ class BasicDurationFormatterFactory implements DurationFormatterFactory {
    * Create the formatter.  All local fields are already initialized.
    */
   protected BasicDurationFormatter createFormatter() {
-    return new BasicDurationFormatter(formatter, builder, fallback, 
+    return new BasicDurationFormatter(formatter, builder, fallback,
                                       fallbackLimit, localeName,
                                       timeZone);
   }
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/BasicPeriodBuilderFactory.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/BasicPeriodBuilderFactory.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/impl/duration/BasicPeriodBuilderFactory.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/BasicPeriodBuilderFactory.java
index ba00bd0..ade665e 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/BasicPeriodBuilderFactory.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/BasicPeriodBuilderFactory.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2007-2011, International Business Machines Corporation and   *
@@ -20,9 +22,9 @@ import com.ibm.icu.impl.duration.impl.PeriodFormatterDataService;
 class BasicPeriodBuilderFactory implements PeriodBuilderFactory {
   private PeriodFormatterDataService ds;
   private Settings settings;
-  
+
   private static final short allBits = 0xff;
-  
+
   BasicPeriodBuilderFactory(PeriodFormatterDataService ds) {
     this.ds = ds;
     this.settings = new Settings();
@@ -48,7 +50,7 @@ class BasicPeriodBuilderFactory implements PeriodBuilderFactory {
         return this;
       }
       Settings result = inUse ? copy() : this;
-        
+
       result.uset = (short)uset;
 
       if ((uset & allBits) == allBits) {
@@ -65,7 +67,7 @@ class BasicPeriodBuilderFactory implements PeriodBuilderFactory {
             lastUnit = i;
           }
         }
-        if (lastUnit == -1) { 
+        if (lastUnit == -1) {
             // currently empty, but this might be transient so no fail
             result.minUnit = result.maxUnit = null;
         } else {
@@ -82,7 +84,7 @@ class BasicPeriodBuilderFactory implements PeriodBuilderFactory {
       }
       return (short)(uset & ~(1 << TimeUnit.MILLISECOND.ordinal));
     }
-    
+
     TimeUnit effectiveMinUnit() {
         if (allowMillis || minUnit != TimeUnit.MILLISECOND) {
             return minUnit;
@@ -95,7 +97,7 @@ class BasicPeriodBuilderFactory implements PeriodBuilderFactory {
         }
         return TimeUnit.SECOND; // default for pathological case
     }
-    
+
     Settings setMaxLimit(float maxLimit) {
       int val = maxLimit <= 0 ? 0 : (int)(maxLimit*1000);
       if (maxLimit == val) {
@@ -148,7 +150,7 @@ class BasicPeriodBuilderFactory implements PeriodBuilderFactory {
       return this
         .setAllowZero(data.allowZero())
         .setWeeksAloneOnly(data.weeksAloneOnly())
-        .setAllowMilliseconds(data.useMilliseconds() != DataRecord.EMilliSupport.NO);  
+        .setAllowMilliseconds(data.useMilliseconds() != DataRecord.EMilliSupport.NO);
     }
 
     Settings setInUse() {
@@ -163,7 +165,7 @@ class BasicPeriodBuilderFactory implements PeriodBuilderFactory {
               return Period.moreThan(maxLimit/1000f, maxUnit).inPast(inPast);
           }
       }
-      
+
       if (minLimit > 0) {
           TimeUnit emu = effectiveMinUnit();
           long emud = approximateDurationOf(emu);
@@ -191,6 +193,7 @@ class BasicPeriodBuilderFactory implements PeriodBuilderFactory {
     }
   }
 
+  @Override
   public PeriodBuilderFactory setAvailableUnitRange(TimeUnit minUnit,
                                                     TimeUnit maxUnit) {
     int uset = 0;
@@ -204,7 +207,8 @@ class BasicPeriodBuilderFactory implements PeriodBuilderFactory {
     return this;
   }
 
-  public PeriodBuilderFactory setUnitIsAvailable(TimeUnit unit, 
+  @Override
+  public PeriodBuilderFactory setUnitIsAvailable(TimeUnit unit,
                                                       boolean available) {
     int uset = settings.uset;
     if (available) {
@@ -216,36 +220,43 @@ class BasicPeriodBuilderFactory implements PeriodBuilderFactory {
     return this;
   }
 
+  @Override
   public PeriodBuilderFactory setMaxLimit(float maxLimit) {
     settings = settings.setMaxLimit(maxLimit);
     return this;
   }
 
+  @Override
   public PeriodBuilderFactory setMinLimit(float minLimit) {
     settings = settings.setMinLimit(minLimit);
     return this;
   }
 
+  @Override
   public PeriodBuilderFactory setAllowZero(boolean allow) {
     settings = settings.setAllowZero(allow);
     return this;
   }
 
+  @Override
   public PeriodBuilderFactory setWeeksAloneOnly(boolean aloneOnly) {
     settings = settings.setWeeksAloneOnly(aloneOnly);
     return this;
   }
 
+  @Override
   public PeriodBuilderFactory setAllowMilliseconds(boolean allow) {
     settings = settings.setAllowMilliseconds(allow);
     return this;
   }
 
+  @Override
   public PeriodBuilderFactory setLocale(String localeName) {
     settings = settings.setLocale(localeName);
     return this;
   }
-  
+
+  @Override
   public PeriodBuilderFactory setTimeZone(TimeZone timeZone) {
       // ignore this
       return this;
@@ -265,6 +276,7 @@ class BasicPeriodBuilderFactory implements PeriodBuilderFactory {
    * @param unit the single TimeUnit with which to represent times
    * @return a builder
    */
+  @Override
   public PeriodBuilder getFixedUnitBuilder(TimeUnit unit) {
     return FixedUnitBuilder.get(unit, getSettings());
   }
@@ -275,6 +287,7 @@ class BasicPeriodBuilderFactory implements PeriodBuilderFactory {
    *
    * @return a builder
    */
+  @Override
   public PeriodBuilder getSingleUnitBuilder() {
     return SingleUnitBuilder.get(getSettings());
   }
@@ -287,6 +300,7 @@ class BasicPeriodBuilderFactory implements PeriodBuilderFactory {
    *
    * @return a builder
    */
+  @Override
   public PeriodBuilder getOneOrTwoUnitBuilder() {
     return OneOrTwoUnitBuilder.get(getSettings());
   }
@@ -298,6 +312,7 @@ class BasicPeriodBuilderFactory implements PeriodBuilderFactory {
    *
    * @return a builder
    */
+  @Override
   public PeriodBuilder getMultiUnitBuilder(int periodCount) {
     return MultiUnitBuilder.get(periodCount, getSettings());
   }
@@ -306,7 +321,8 @@ class BasicPeriodBuilderFactory implements PeriodBuilderFactory {
 abstract class PeriodBuilderImpl implements PeriodBuilder {
 
   protected BasicPeriodBuilderFactory.Settings settings;
- 
+
+  @Override
   public Period create(long duration) {
     return createWithReferenceDate(duration, System.currentTimeMillis());
   }
@@ -315,6 +331,7 @@ abstract class PeriodBuilderImpl implements PeriodBuilder {
     return BasicPeriodBuilderFactory.approximateDurationOf(unit);
   }
 
+  @Override
   public Period createWithReferenceDate(long duration, long referenceDate) {
     boolean inPast = duration < 0;
     if (inPast) {
@@ -330,11 +347,13 @@ abstract class PeriodBuilderImpl implements PeriodBuilder {
     return ts;
   }
 
+  @Override
   public PeriodBuilder withTimeZone(TimeZone timeZone) {
       // ignore the time zone
       return this;
   }
 
+  @Override
   public PeriodBuilder withLocale(String localeName) {
     BasicPeriodBuilderFactory.Settings newSettings = settings.setLocale(localeName);
     if (newSettings != settings) {
@@ -345,7 +364,7 @@ abstract class PeriodBuilderImpl implements PeriodBuilder {
 
   protected abstract PeriodBuilder withSettings(BasicPeriodBuilderFactory.Settings settingsToUse);
 
-  protected abstract Period handleCreate(long duration, long referenceDate, 
+  protected abstract Period handleCreate(long duration, long referenceDate,
                                          boolean inPast);
 
   protected PeriodBuilderImpl(BasicPeriodBuilderFactory.Settings settings) {
@@ -355,7 +374,7 @@ abstract class PeriodBuilderImpl implements PeriodBuilder {
 
 class FixedUnitBuilder extends PeriodBuilderImpl {
   private TimeUnit unit;
-  
+
   public static FixedUnitBuilder get(TimeUnit unit, BasicPeriodBuilderFactory.Settings settingsToUse) {
     if (settingsToUse != null && (settingsToUse.effectiveSet() & (1 << unit.ordinal)) != 0) {
       return new FixedUnitBuilder(unit, settingsToUse);
@@ -368,11 +387,13 @@ class FixedUnitBuilder extends PeriodBuilderImpl {
     this.unit = unit;
   }
 
+  @Override
   protected PeriodBuilder withSettings(BasicPeriodBuilderFactory.Settings settingsToUse) {
     return get(unit, settingsToUse);
   }
 
-  protected Period handleCreate(long duration, long referenceDate, 
+  @Override
+  protected Period handleCreate(long duration, long referenceDate,
                                 boolean inPast) {
     if (unit == null) {
       return null;
@@ -395,11 +416,13 @@ class SingleUnitBuilder extends PeriodBuilderImpl {
     return new SingleUnitBuilder(settings);
   }
 
+  @Override
   protected PeriodBuilder withSettings(BasicPeriodBuilderFactory.Settings settingsToUse) {
     return SingleUnitBuilder.get(settingsToUse);
   }
 
-  protected Period handleCreate(long duration, long referenceDate, 
+  @Override
+  protected Period handleCreate(long duration, long referenceDate,
                                 boolean inPast) {
     short uset = settings.effectiveSet();
     for (int i = 0; i < TimeUnit.units.length; ++i) {
@@ -428,11 +451,13 @@ class OneOrTwoUnitBuilder extends PeriodBuilderImpl {
     return new OneOrTwoUnitBuilder(settings);
   }
 
+  @Override
   protected PeriodBuilder withSettings(BasicPeriodBuilderFactory.Settings settingsToUse) {
     return OneOrTwoUnitBuilder.get(settingsToUse);
   }
 
-  protected Period handleCreate(long duration, long referenceDate, 
+  @Override
+  protected Period handleCreate(long duration, long referenceDate,
                                 boolean inPast) {
     Period period = null;
     short uset = settings.effectiveSet();
@@ -477,11 +502,13 @@ class MultiUnitBuilder extends PeriodBuilderImpl {
     return null;
   }
 
+  @Override
   protected PeriodBuilder withSettings(BasicPeriodBuilderFactory.Settings settingsToUse) {
     return MultiUnitBuilder.get(nPeriods, settingsToUse);
   }
 
-  protected Period handleCreate(long duration, long referenceDate, 
+  @Override
+  protected Period handleCreate(long duration, long referenceDate,
                                 boolean inPast) {
     Period period = null;
     int n = 0;
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/BasicPeriodFormatter.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/BasicPeriodFormatter.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/impl/duration/BasicPeriodFormatter.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/BasicPeriodFormatter.java
index a5f4a03..887752f 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/BasicPeriodFormatter.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/BasicPeriodFormatter.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2007-2010, International Business Machines Corporation and   *
@@ -24,9 +26,9 @@ class BasicPeriodFormatter implements PeriodFormatter {
   private PeriodFormatterData data;
   private Customizations customs;
 
-  BasicPeriodFormatter(BasicPeriodFormatterFactory factory, 
+  BasicPeriodFormatter(BasicPeriodFormatterFactory factory,
                        String localeName,
-                       PeriodFormatterData data, 
+                       PeriodFormatterData data,
                        Customizations customs) {
     this.factory = factory;
     this.localeName = localeName;
@@ -34,17 +36,19 @@ class BasicPeriodFormatter implements PeriodFormatter {
     this.customs = customs;
   }
 
-  public String format(Period period) {
+  @Override
+public String format(Period period) {
     if (!period.isSet()) {
       throw new IllegalArgumentException("period is not set");
     }
     return format(period.timeLimit, period.inFuture, period.counts);
   }
 
+  @Override
   public PeriodFormatter withLocale(String locName) {
     if (!this.localeName.equals(locName)) {
       PeriodFormatterData newData = factory.getData(locName);
-      return new BasicPeriodFormatter(factory, locName, newData, 
+      return new BasicPeriodFormatter(factory, locName, newData,
                                       customs);
     }
     return this;
@@ -58,7 +62,7 @@ class BasicPeriodFormatter implements PeriodFormatter {
       }
     }
 
-    // if the data does not allow formatting of zero periods, 
+    // if the data does not allow formatting of zero periods,
     // remove these from consideration.  If the result has no
     // periods set, return null to indicate we could not format
     // the duration.
@@ -77,13 +81,13 @@ class BasicPeriodFormatter implements PeriodFormatter {
     // set, merge them with seconds and force display of seconds to
     // decimal with 3 places.
     boolean forceD3Seconds = false;
-    if (data.useMilliseconds() != EMilliSupport.YES && 
+    if (data.useMilliseconds() != EMilliSupport.YES &&
         (mask & (1 << TimeUnit.MILLISECOND.ordinal)) != 0) {
       int sx = TimeUnit.SECOND.ordinal;
       int mx = TimeUnit.MILLISECOND.ordinal;
       int sf = 1 << sx;
       int mf = 1 << mx;
-      switch (data.useMilliseconds()) {      
+      switch (data.useMilliseconds()) {
         case EMilliSupport.WITH_SECONDS: {
           // if there are seconds, merge with seconds, otherwise leave alone
           if ((mask & sf) != 0) {
@@ -174,7 +178,7 @@ class BasicPeriodFormatter implements PeriodFormatter {
         cv = ECountVariant.INTEGER;
       }
       boolean isLast = i == last;
-      boolean mustSkip = data.appendUnit(unit, count, cv, customs.unitVariant, 
+      boolean mustSkip = data.appendUnit(unit, count, cv, customs.unitVariant,
                                          countSep, useDigitPrefix, multiple, isLast, wasSkipped, sb);
       skipped |= mustSkip;
       wasSkipped = false;
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/BasicPeriodFormatterFactory.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/BasicPeriodFormatterFactory.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/duration/BasicPeriodFormatterFactory.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/BasicPeriodFormatterFactory.java
index 1857716..ecff5a0 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/BasicPeriodFormatterFactory.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/BasicPeriodFormatterFactory.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2007-2010, International Business Machines Corporation and   *
@@ -79,6 +81,7 @@ public class BasicPeriodFormatterFactory implements PeriodFormatterFactory {
   /**
    * Set the locale for this factory.
    */
+  @Override
   public PeriodFormatterFactory setLocale(String localeName) {
     data = null;
     this.localeName = localeName;
@@ -91,6 +94,7 @@ public class BasicPeriodFormatterFactory implements PeriodFormatterFactory {
    * @param display true if limits will be displayed
    * @return this PeriodFormatterFactory
    */
+  @Override
   public PeriodFormatterFactory setDisplayLimit(boolean display) {
     updateCustomizations().displayLimit = display;
     return this;
@@ -111,6 +115,7 @@ public class BasicPeriodFormatterFactory implements PeriodFormatterFactory {
    * @param display true if past and future will be displayed
    * @return this PeriodFormatterFactory
    */
+  @Override
   public PeriodFormatterFactory setDisplayPastFuture(boolean display) {
     updateCustomizations().displayDirection = display;
     return this;
@@ -131,6 +136,7 @@ public class BasicPeriodFormatterFactory implements PeriodFormatterFactory {
    * @param variant the variant indicating separators will be displayed
    * @return this PeriodFormatterFactory
    */
+  @Override
   public PeriodFormatterFactory setSeparatorVariant(int variant) {
     updateCustomizations().separatorVariant = (byte) variant;
     return this;
@@ -151,6 +157,7 @@ public class BasicPeriodFormatterFactory implements PeriodFormatterFactory {
    * @param variant the variant to use
    * @return this PeriodFormatterFactory
    */
+  @Override
   public PeriodFormatterFactory setUnitVariant(int variant) {
     updateCustomizations().unitVariant = (byte) variant;
     return this;
@@ -171,6 +178,7 @@ public class BasicPeriodFormatterFactory implements PeriodFormatterFactory {
    * @param variant the variant to use
    * @return this PeriodFormatterFactory
    */
+  @Override
   public PeriodFormatterFactory setCountVariant(int variant) {
     updateCustomizations().countVariant = (byte) variant;
     return this;
@@ -185,9 +193,10 @@ public class BasicPeriodFormatterFactory implements PeriodFormatterFactory {
     return customizations.countVariant;
   }
 
+  @Override
   public PeriodFormatter getFormatter() {
     customizationsInUse = true;
-    return new BasicPeriodFormatter(this, localeName, getData(), 
+    return new BasicPeriodFormatter(this, localeName, getData(),
                                     customizations);
   }
 
@@ -219,7 +228,7 @@ public class BasicPeriodFormatterFactory implements PeriodFormatterFactory {
     byte separatorVariant = ESeparatorVariant.FULL;
     byte unitVariant = EUnitVariant.PLURALIZED;
     byte countVariant = ECountVariant.INTEGER;
-    
+
     public Customizations copy() {
         Customizations result = new Customizations();
         result.displayLimit = displayLimit;
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/BasicPeriodFormatterService.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/BasicPeriodFormatterService.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/impl/duration/BasicPeriodFormatterService.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/BasicPeriodFormatterService.java
index ddb92c1..c840bdc 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/BasicPeriodFormatterService.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/BasicPeriodFormatterService.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ******************************************************************************
  * Copyright (C) 2007-2010, International Business Machines Corporation and   *
@@ -22,7 +24,7 @@ public class BasicPeriodFormatterService implements PeriodFormatterService {
 
     /**
      * Return the default service instance. This uses the default data service.
-     * 
+     *
      * @return an BasicPeriodFormatterService
      */
     public static BasicPeriodFormatterService getInstance() {
@@ -37,25 +39,29 @@ public class BasicPeriodFormatterService implements PeriodFormatterService {
     /**
      * Construct a BasicPeriodFormatterService using the given
      * PeriodFormatterDataService.
-     * 
+     *
      * @param ds the data service to use
      */
     public BasicPeriodFormatterService(PeriodFormatterDataService ds) {
         this.ds = ds;
     }
 
+    @Override
     public DurationFormatterFactory newDurationFormatterFactory() {
         return new BasicDurationFormatterFactory(this);
     }
 
+    @Override
     public PeriodFormatterFactory newPeriodFormatterFactory() {
         return new BasicPeriodFormatterFactory(ds);
     }
 
+    @Override
     public PeriodBuilderFactory newPeriodBuilderFactory() {
         return new BasicPeriodBuilderFactory(ds);
     }
 
+    @Override
     public Collection<String> getAvailableLocaleNames() {
         return ds.getAvailableLocales();
     }
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/DateFormatter.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/DateFormatter.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/impl/duration/DateFormatter.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/DateFormatter.java
index e0232f7..fdecb4f 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/DateFormatter.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/DateFormatter.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/DurationFormatter.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/DurationFormatter.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/impl/duration/DurationFormatter.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/DurationFormatter.java
index d78d80c..0e7236d 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/DurationFormatter.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/DurationFormatter.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/DurationFormatterFactory.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/DurationFormatterFactory.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/impl/duration/DurationFormatterFactory.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/DurationFormatterFactory.java
index 2b1dda1..eccec7b 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/DurationFormatterFactory.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/DurationFormatterFactory.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2009, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/Period.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/Period.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/impl/duration/Period.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/Period.java
index 427de06..2f2a105 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/Period.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/Period.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and   *
@@ -15,9 +17,9 @@ import com.ibm.icu.impl.duration.impl.DataRecord.ETimeLimit;
  * In addition Period can either represent the duration as being into the past
  * or future, and as being more or less than the defined value.
  * <p>
- * Use a PeriodFormatter to convert a Period to a String.  
+ * Use a PeriodFormatter to convert a Period to a String.
  * <p>
- * Periods are immutable.  Mutating operations return the new 
+ * Periods are immutable.  Mutating operations return the new
  * result leaving the original unchanged.
  * <p>
  * Example:<pre>
@@ -90,7 +92,7 @@ public final class Period {
   public Period omit(TimeUnit unit) {
     return setTimeUnitInternalValue(unit, 0);
   }
-  
+
   /**
    * Mark the duration as being at the defined duration.
    *
@@ -195,9 +197,9 @@ public final class Period {
   }
 
   /**
-   * Returns true if this represents a 
+   * Returns true if this represents a
    * duration into the future.
-   * @return true if this represents a 
+   * @return true if this represents a
    * duration into the future.
    */
   public boolean isInFuture() {
@@ -205,9 +207,9 @@ public final class Period {
   }
 
   /**
-   * Returns true if this represents a 
+   * Returns true if this represents a
    * duration into the past
-   * @return true if this represents a 
+   * @return true if this represents a
    * duration into the past
    */
   public boolean isInPast  () {
@@ -234,12 +236,13 @@ public final class Period {
     return timeLimit == ETimeLimit.LT;
   }
 
-  /** 
+  /**
    * Returns true if rhs extends Period and
    * the two Periods are equal.
    * @param rhs the object to compare to
    * @return true if rhs is a Period and is equal to this
    */
+  @Override
   public boolean equals(Object rhs) {
     try {
       return equals((Period)rhs);
@@ -273,11 +276,12 @@ public final class Period {
     return false;
   }
 
-  /** 
-   * Returns the hashCode. 
+  /**
+   * Returns the hashCode.
    * @return the hashCode
    */
-  public int hashCode() {
+  @Override
+public int hashCode() {
     int hc = (timeLimit << 1) | (inFuture ? 1 : 0);
     for (int i = 0; i < counts.length; ++i) {
       hc = (hc << 2) ^ counts[i];
@@ -314,7 +318,7 @@ public final class Period {
     return setTimeUnitInternalValue(unit, (int)(value * 1000) + 1);
   }
 
-  /** 
+  /**
    * Sets the period to have the provided value, 1/1000 of the
    * unit plus 1.  Thus unset values are '0', 1' is the set value '0',
    * 2 is the set value '1/1000', 3 is the set value '2/1000' etc.
@@ -366,7 +370,7 @@ public final class Period {
    */
   private static void checkCount(float count) {
     if (count < 0) {
-      throw new IllegalArgumentException("count (" + count + 
+      throw new IllegalArgumentException("count (" + count +
                                          ") cannot be negative");
     }
   }
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/PeriodBuilder.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/PeriodBuilder.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/impl/duration/PeriodBuilder.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/PeriodBuilder.java
index 188b352..08085cf 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/PeriodBuilder.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/PeriodBuilder.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/PeriodBuilderFactory.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/PeriodBuilderFactory.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/duration/PeriodBuilderFactory.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/PeriodBuilderFactory.java
index 5b022ff..4e61f25 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/PeriodBuilderFactory.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/PeriodBuilderFactory.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2007-2009, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/PeriodFormatter.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/PeriodFormatter.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/impl/duration/PeriodFormatter.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/PeriodFormatter.java
index a3363f1..615345d 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/PeriodFormatter.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/PeriodFormatter.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/PeriodFormatterFactory.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/PeriodFormatterFactory.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/impl/duration/PeriodFormatterFactory.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/PeriodFormatterFactory.java
index 2110d45..56e0f6f 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/PeriodFormatterFactory.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/PeriodFormatterFactory.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/PeriodFormatterService.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/PeriodFormatterService.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/impl/duration/PeriodFormatterService.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/PeriodFormatterService.java
index 8135325..81f27eb 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/PeriodFormatterService.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/PeriodFormatterService.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ******************************************************************************
  * Copyright (C) 2007-2009, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/TimeUnit.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/TimeUnit.java
similarity index 86%
rename from app/src/main/java/com/ibm/icu/impl/duration/TimeUnit.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/TimeUnit.java
index a9f1e01..e9065bc 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/TimeUnit.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/TimeUnit.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and   *
@@ -8,7 +10,7 @@
 package com.ibm.icu.impl.duration;
 
 /**
- * 'Enum' for individual time units.  Not an actual enum so that it can be 
+ * 'Enum' for individual time units.  Not an actual enum so that it can be
  * used by Java 1.4.
  */
 public final class TimeUnit {
@@ -24,32 +26,33 @@ public final class TimeUnit {
     this.ordinal = (byte) ordinal;
   }
 
+  @Override
   public String toString() {
     return name;
   }
-  
-  /** Represents a year. */ 
+
+  /** Represents a year. */
   public static final TimeUnit YEAR = new TimeUnit("year", 0);
 
-  /** Represents a month. */  
+  /** Represents a month. */
   public static final TimeUnit MONTH = new TimeUnit("month", 1);
 
-  /** Represents a week. */ 
+  /** Represents a week. */
   public static final TimeUnit WEEK = new TimeUnit("week", 2);
 
-  /** Represents a day. */ 
+  /** Represents a day. */
   public static final TimeUnit DAY = new TimeUnit("day", 3);
 
-  /** Represents an hour. */ 
+  /** Represents an hour. */
   public static final TimeUnit HOUR = new TimeUnit("hour", 4);
 
-  /** Represents a minute. */ 
+  /** Represents a minute. */
   public static final TimeUnit MINUTE = new TimeUnit("minute", 5);
 
-  /** Represents a second. */ 
+  /** Represents a second. */
   public static final TimeUnit SECOND = new TimeUnit("second", 6);
 
-  /** Represents a millisecond. */ 
+  /** Represents a millisecond. */
   public static final TimeUnit MILLISECOND = new TimeUnit("millisecond", 7);
 
   /** Returns the next larger time unit, or null if this is the largest. */
@@ -79,7 +82,7 @@ public final class TimeUnit {
   // compute entire expression using 'long'.  differs from initializtion of
   // a single constant
   static final long[] approxDurations = {
-    36525L*24*60*60*10, 3045*24*60*60*10L, 7*24*60*60*1000L, 24*60*60*1000L, 
+    36525L*24*60*60*10, 3045*24*60*60*10L, 7*24*60*60*1000L, 24*60*60*1000L,
     60*60*1000L, 60*1000L, 1000L, 1L
   };
 }
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/TimeUnitConstants.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/TimeUnitConstants.java
similarity index 90%
rename from app/src/main/java/com/ibm/icu/impl/duration/TimeUnitConstants.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/TimeUnitConstants.java
index 9de023b..b4ec282 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/TimeUnitConstants.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/TimeUnitConstants.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/impl/DataRecord.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/impl/DataRecord.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/duration/impl/DataRecord.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/impl/DataRecord.java
index d1e55a8..1aaf8a4 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/impl/DataRecord.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/impl/DataRecord.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ******************************************************************************
  * Copyright (C) 2007-2009, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/impl/PeriodFormatterData.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/impl/PeriodFormatterData.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/duration/impl/PeriodFormatterData.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/impl/PeriodFormatterData.java
index 36bef03..13c99d1 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/impl/PeriodFormatterData.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/impl/PeriodFormatterData.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2009-2011, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/impl/PeriodFormatterDataService.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/impl/PeriodFormatterDataService.java
similarity index 89%
rename from app/src/main/java/com/ibm/icu/impl/duration/impl/PeriodFormatterDataService.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/impl/PeriodFormatterDataService.java
index 4bdcd99..1f5eac8 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/impl/PeriodFormatterDataService.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/impl/PeriodFormatterDataService.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ******************************************************************************
  * Copyright (C) 2007-2009, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/impl/RecordReader.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/impl/RecordReader.java
similarity index 86%
rename from app/src/main/java/com/ibm/icu/impl/duration/impl/RecordReader.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/impl/RecordReader.java
index 64e3fee..fd361c3 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/impl/RecordReader.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/impl/RecordReader.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/impl/RecordWriter.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/impl/RecordWriter.java
similarity index 88%
rename from app/src/main/java/com/ibm/icu/impl/duration/impl/RecordWriter.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/impl/RecordWriter.java
index bb94d76..4367616 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/impl/RecordWriter.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/impl/RecordWriter.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2007, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/impl/ResourceBasedPeriodFormatterDataService.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/impl/ResourceBasedPeriodFormatterDataService.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/duration/impl/ResourceBasedPeriodFormatterDataService.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/impl/ResourceBasedPeriodFormatterDataService.java
index 99f81c0..e6f3754 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/impl/ResourceBasedPeriodFormatterDataService.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/impl/ResourceBasedPeriodFormatterDataService.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ******************************************************************************
  * Copyright (C) 2007-2015, International Business Machines Corporation and
@@ -80,6 +82,7 @@ public class ResourceBasedPeriodFormatterDataService extends
         availableLocales = Collections.unmodifiableList(localeNames);
     }
 
+    @Override
     public PeriodFormatterData get(String localeName) {
         // remove tag info including calendar, we don't use the calendar
         int x = localeName.indexOf('@');
@@ -150,6 +153,7 @@ public class ResourceBasedPeriodFormatterDataService extends
         }
     }
 
+    @Override
     public Collection<String> getAvailableLocales() {
         return availableLocales;
     }
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/impl/Utils.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/impl/Utils.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/impl/duration/impl/Utils.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/impl/Utils.java
index 3bb44f9..d36b02f 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/impl/Utils.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/impl/Utils.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2007-2012, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/impl/XMLRecordReader.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/impl/XMLRecordReader.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/impl/duration/impl/XMLRecordReader.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/impl/XMLRecordReader.java
index d6274ba..0b8e5bf 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/impl/XMLRecordReader.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/impl/XMLRecordReader.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2007-2010, International Business Machines Corporation and   *
@@ -38,6 +40,7 @@ public class XMLRecordReader implements RecordReader {
         }
     }
 
+    @Override
     public boolean open(String title) {
         if (getTag().equals(title)) {
             nameStack.add(title);
@@ -47,6 +50,7 @@ public class XMLRecordReader implements RecordReader {
         return false;
     }
 
+    @Override
     public boolean close() {
         int ix = nameStack.size() - 1;
         String name = nameStack.get(ix);
@@ -58,6 +62,7 @@ public class XMLRecordReader implements RecordReader {
         return false;
     }
 
+    @Override
     public boolean bool(String name) {
         String s = string(name);
         if (s != null) {
@@ -66,6 +71,7 @@ public class XMLRecordReader implements RecordReader {
         return false;
     }
 
+    @Override
     public boolean[] boolArray(String name) {
         String[] sa = stringArray(name);
         if (sa != null) {
@@ -78,6 +84,7 @@ public class XMLRecordReader implements RecordReader {
         return null;
     }
 
+    @Override
     public char character(String name) {
         String s = string(name);
         if (s != null) {
@@ -86,6 +93,7 @@ public class XMLRecordReader implements RecordReader {
         return '\uffff';
     }
 
+    @Override
     public char[] characterArray(String name) {
         String[] sa = stringArray(name);
         if (sa != null) {
@@ -98,6 +106,7 @@ public class XMLRecordReader implements RecordReader {
         return null;
     }
 
+    @Override
     public byte namedIndex(String name, String[] names) {
         String sa = string(name);
         if (sa != null) {
@@ -110,6 +119,7 @@ public class XMLRecordReader implements RecordReader {
         return (byte) -1;
     }
 
+    @Override
     public byte[] namedIndexArray(String name, String[] names) {
         String[] sa = stringArray(name);
         if (sa != null) {
@@ -129,6 +139,7 @@ public class XMLRecordReader implements RecordReader {
         return null;
     }
 
+    @Override
     public String string(String name) {
         if (match(name)) {
             String result = readData();
@@ -139,6 +150,7 @@ public class XMLRecordReader implements RecordReader {
         return null;
     }
 
+    @Override
     public String[] stringArray(String name) {
         if (match(name + "List")) {
             List<String> list = new ArrayList<String>();
@@ -156,6 +168,7 @@ public class XMLRecordReader implements RecordReader {
         return null;
     }
 
+    @Override
     public String[][] stringTable(String name) {
         if (match(name + "Table")) {
             List<String[]> list = new ArrayList<String[]>();
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/impl/XMLRecordWriter.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/impl/XMLRecordWriter.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/impl/duration/impl/XMLRecordWriter.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/impl/XMLRecordWriter.java
index 7d63ae2..d2f1867 100644
--- a/app/src/main/java/com/ibm/icu/impl/duration/impl/XMLRecordWriter.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/duration/impl/XMLRecordWriter.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ******************************************************************************
  * Copyright (C) 2007-2010, International Business Machines Corporation and   *
@@ -23,6 +25,7 @@ public class XMLRecordWriter implements RecordWriter {
         this.nameStack = new ArrayList<String>();
     }
 
+    @Override
     public boolean open(String title) {
         newline();
         writeString("<" + title + ">");
@@ -30,6 +33,7 @@ public class XMLRecordWriter implements RecordWriter {
         return true;
     }
 
+    @Override
     public boolean close() {
         int ix = nameStack.size() - 1;
         if (ix >= 0) {
@@ -48,10 +52,12 @@ public class XMLRecordWriter implements RecordWriter {
         }
     }
 
+    @Override
     public void bool(String name, boolean value) {
         internalString(name, String.valueOf(value));
     }
 
+    @Override
     public void boolArray(String name, boolean[] values) {
         if (values != null) {
             String[] stringValues = new String[values.length];
@@ -72,12 +78,14 @@ public class XMLRecordWriter implements RecordWriter {
         return String.valueOf(value);
     }
 
+    @Override
     public void character(String name, char value) {
         if (value != '\uffff') {
             internalString(name, ctos(value));
         }
     }
 
+    @Override
     public void characterArray(String name, char[] values) {
         if (values != null) {
             String[] stringValues = new String[values.length];
@@ -93,12 +101,14 @@ public class XMLRecordWriter implements RecordWriter {
         }
     }
 
+    @Override
     public void namedIndex(String name, String[] names, int value) {
         if (value >= 0) {
             internalString(name, names[value]);
         }
     }
 
+    @Override
     public void namedIndexArray(String name, String[] names, byte[] values) {
         if (values != null) {
             String[] stringValues = new String[values.length];
@@ -180,10 +190,12 @@ public class XMLRecordWriter implements RecordWriter {
         }
     }
 
+    @Override
     public void string(String name, String value) {
         internalString(name, normalize(value));
     }
 
+    @Override
     public void stringArray(String name, String[] values) {
         if (values != null) {
             push(name + "List");
@@ -198,6 +210,7 @@ public class XMLRecordWriter implements RecordWriter {
         }
     }
 
+    @Override
     public void stringTable(String name, String[][] values) {
         if (values != null) {
             push(name + "Table");
diff --git a/app/src/main/java/com/ibm/icu/impl/duration/impl/YMDDateFormatter.java b/icu4j/src/main/java/com/ibm/icu/impl/duration/impl/YMDDateFormatter.java
similarity index 100%
rename from app/src/main/java/com/ibm/icu/impl/duration/impl/YMDDateFormatter.java
rename to icu4j/src/main/java/com/ibm/icu/impl/duration/impl/YMDDateFormatter.java
diff --git a/app/src/main/java/com/ibm/icu/impl/locale/AsciiUtil.java b/icu4j/src/main/java/com/ibm/icu/impl/locale/AsciiUtil.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/impl/locale/AsciiUtil.java
rename to icu4j/src/main/java/com/ibm/icu/impl/locale/AsciiUtil.java
index c03d659..527230e 100644
--- a/app/src/main/java/com/ibm/icu/impl/locale/AsciiUtil.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/locale/AsciiUtil.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2010, International Business Machines Corporation and    *
@@ -6,9 +8,11 @@
  */
 package com.ibm.icu.impl.locale;
 
+import com.ibm.icu.impl.Utility;
+
 public final class AsciiUtil {
     public static boolean caseIgnoreMatch(String s1, String s2) {
-        if (s1 == s2) {
+        if (Utility.sameObjects(s1, s2)) {
             return true;
         }
         int len = s1.length();
@@ -28,7 +32,7 @@ public final class AsciiUtil {
     }
 
     public static int caseIgnoreCompare(String s1, String s2) {
-        if (s1 == s2) {
+        if (Utility.sameObjects(s1, s2)) {
             return 0;
         }
         return AsciiUtil.toLowerString(s1).compareTo(AsciiUtil.toLowerString(s2));
@@ -166,6 +170,7 @@ public final class AsciiUtil {
             _hash = AsciiUtil.toLowerString(key).hashCode();
         }
 
+        @Override
         public boolean equals(Object o) {
             if (this == o) {
                 return true;
@@ -176,6 +181,7 @@ public final class AsciiUtil {
             return false;
         }
 
+        @Override
         public int hashCode() {
             return _hash;
         }
diff --git a/app/src/main/java/com/ibm/icu/impl/locale/BaseLocale.java b/icu4j/src/main/java/com/ibm/icu/impl/locale/BaseLocale.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/locale/BaseLocale.java
rename to icu4j/src/main/java/com/ibm/icu/impl/locale/BaseLocale.java
index 46d0496..66deee9 100644
--- a/app/src/main/java/com/ibm/icu/impl/locale/BaseLocale.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/locale/BaseLocale.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2010, International Business Machines Corporation and    *
@@ -76,6 +78,7 @@ public final class BaseLocale {
         return _variant;
     }
 
+    @Override
     public boolean equals(Object obj) {
         if (this == obj) {
             return true;
@@ -91,6 +94,7 @@ public final class BaseLocale {
                 && _variant.equals(other._variant);
     }
 
+    @Override
     public String toString() {
         StringBuilder buf = new StringBuilder();
         if (_language.length() > 0) {
@@ -121,6 +125,7 @@ public final class BaseLocale {
         return buf.toString();
     }
 
+    @Override
     public int hashCode() {
         int h = _hash;
         if (h == 0) {
@@ -165,6 +170,7 @@ public final class BaseLocale {
             }
         }
 
+        @Override
         public boolean equals(Object obj) {
             if (JDKIMPL) {
                 return (this == obj) ||
@@ -182,6 +188,7 @@ public final class BaseLocale {
                     && AsciiUtil.caseIgnoreMatch(((Key)obj)._vart, this._vart);
         }
 
+        @Override
         public int compareTo(Key other) {
             int res = AsciiUtil.caseIgnoreCompare(this._lang, other._lang);
             if (res == 0) {
@@ -200,6 +207,7 @@ public final class BaseLocale {
             return res;
         }
 
+        @Override
         public int hashCode() {
             int h = _hash;
             if (h == 0) {
@@ -245,10 +253,12 @@ public final class BaseLocale {
         public Cache() {
         }
 
+        @Override
         protected Key normalizeKey(Key key) {
             return Key.normalize(key);
         }
 
+        @Override
         protected BaseLocale createObject(Key key) {
             return new BaseLocale(key._lang, key._scrt, key._regn, key._vart);
         }
diff --git a/app/src/main/java/com/ibm/icu/impl/locale/Extension.java b/icu4j/src/main/java/com/ibm/icu/impl/locale/Extension.java
similarity index 86%
rename from app/src/main/java/com/ibm/icu/impl/locale/Extension.java
rename to icu4j/src/main/java/com/ibm/icu/impl/locale/Extension.java
index d2bf959..bccda56 100644
--- a/app/src/main/java/com/ibm/icu/impl/locale/Extension.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/locale/Extension.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2010, International Business Machines Corporation and    *
@@ -32,6 +34,7 @@ public class Extension {
         return _key + LanguageTag.SEP + _value;
     }
 
+    @Override
     public String toString() {
         return getID();
     }
diff --git a/app/src/main/java/com/ibm/icu/impl/locale/InternalLocaleBuilder.java b/icu4j/src/main/java/com/ibm/icu/impl/locale/InternalLocaleBuilder.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/locale/InternalLocaleBuilder.java
rename to icu4j/src/main/java/com/ibm/icu/impl/locale/InternalLocaleBuilder.java
index 14a0d4b..615156b 100644
--- a/app/src/main/java/com/ibm/icu/impl/locale/InternalLocaleBuilder.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/locale/InternalLocaleBuilder.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2010, International Business Machines Corporation and    *
@@ -640,10 +642,12 @@ public final class InternalLocaleBuilder {
             return _s;
         }
 
+        @Override
         public int hashCode() {
             return AsciiUtil.toLowerString(_s).hashCode();
         }
 
+        @Override
         public boolean equals(Object obj) {
             if (this == obj) {
                 return true;
@@ -666,10 +670,12 @@ public final class InternalLocaleBuilder {
             return _c;
         }
 
+        @Override
         public int hashCode() {
             return AsciiUtil.toLower(_c);
         }
 
+        @Override
         public boolean equals(Object obj) {
             if (this == obj) {
                 return true;
diff --git a/app/src/main/java/com/ibm/icu/impl/locale/KeyTypeData.java b/icu4j/src/main/java/com/ibm/icu/impl/locale/KeyTypeData.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/impl/locale/KeyTypeData.java
rename to icu4j/src/main/java/com/ibm/icu/impl/locale/KeyTypeData.java
index 437f1ac..cea97d8 100644
--- a/app/src/main/java/com/ibm/icu/impl/locale/KeyTypeData.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/locale/KeyTypeData.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014-2016, International Business Machines Corporation and
@@ -17,6 +19,7 @@ import java.util.MissingResourceException;
 import java.util.Set;
 import java.util.regex.Pattern;
 
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.util.Output;
 import com.ibm.icu.util.UResourceBundle;
@@ -39,6 +42,7 @@ public class KeyTypeData {
 
     private static class CodepointsTypeHandler extends SpecialTypeHandler {
         private static final Pattern pat = Pattern.compile("[0-9a-fA-F]{4,6}(-[0-9a-fA-F]{4,6})*");
+        @Override
         boolean isWellFormed(String value) {
             return pat.matcher(value).matches();
         }
@@ -46,6 +50,7 @@ public class KeyTypeData {
 
     private static class ReorderCodeTypeHandler extends SpecialTypeHandler {
         private static final Pattern pat = Pattern.compile("[a-zA-Z]{3,8}(-[a-zA-Z]{3,8})*");
+        @Override
         boolean isWellFormed(String value) {
             return pat.matcher(value).matches();
         }
@@ -53,20 +58,23 @@ public class KeyTypeData {
 
     private static class RgKeyValueTypeHandler extends SpecialTypeHandler {
         private static final Pattern pat = Pattern.compile("([a-zA-Z]{2}|[0-9]{3})[zZ]{4}");
+        @Override
         boolean isWellFormed(String value) {
             return pat.matcher(value).matches();
         }
     }
-    
+
     private static class SubdivisionKeyValueTypeHandler extends SpecialTypeHandler {
         private static final Pattern pat = Pattern.compile("([a-zA-Z]{2}|[0-9]{3})");
+        @Override
         boolean isWellFormed(String value) {
             return pat.matcher(value).matches();
         }
     }
-    
+
     private static class PrivateUseKeyValueTypeHandler extends SpecialTypeHandler {
         private static final Pattern pat = Pattern.compile("[a-zA-Z0-9]{3,8}(-[a-zA-Z0-9]{3,8})*");
+        @Override
         boolean isWellFormed(String value) {
             return pat.matcher(value).matches();
         }
@@ -203,7 +211,7 @@ public class KeyTypeData {
 
     private static void initFromResourceBundle() {
         UResourceBundle keyTypeDataRes = UResourceBundle.getBundleInstance(
-                ICUResourceBundle.ICU_BASE_NAME,
+                ICUData.ICU_BASE_NAME,
                 "keyTypeData",
                 ICUResourceBundle.ICU_DATA_CLASS_LOADER);
 
@@ -655,7 +663,7 @@ typeInfo{
     public static Set<String> getBcp47Keys() {
         return BCP47_KEYS.keySet();
     };
-    
+
     public static Set<String> getBcp47KeyTypes(String key) {
         return BCP47_KEYS.get(key);
     };
diff --git a/app/src/main/java/com/ibm/icu/impl/locale/LanguageTag.java b/icu4j/src/main/java/com/ibm/icu/impl/locale/LanguageTag.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/impl/locale/LanguageTag.java
rename to icu4j/src/main/java/com/ibm/icu/impl/locale/LanguageTag.java
index f159e0b..786b4a0 100644
--- a/app/src/main/java/com/ibm/icu/impl/locale/LanguageTag.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/locale/LanguageTag.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2010-2013, International Business Machines Corporation and    *
@@ -112,38 +114,38 @@ public class LanguageTag {
 
     /*
      * BNF in RFC5464
-     *  
+     *
      * Language-Tag  = langtag             ; normal language tags
      *               / privateuse          ; private use tag
      *               / grandfathered       ; grandfathered tags
      *
-     * 
+     *
      * langtag       = language
      *                 ["-" script]
      *                 ["-" region]
      *                 *("-" variant)
      *                 *("-" extension)
      *                 ["-" privateuse]
-     * 
+     *
      * language      = 2*3ALPHA            ; shortest ISO 639 code
      *                 ["-" extlang]       ; sometimes followed by
      *                                     ; extended language subtags
      *               / 4ALPHA              ; or reserved for future use
      *               / 5*8ALPHA            ; or registered language subtag
-     * 
+     *
      * extlang       = 3ALPHA              ; selected ISO 639 codes
      *                 *2("-" 3ALPHA)      ; permanently reserved
-     * 
+     *
      * script        = 4ALPHA              ; ISO 15924 code
-     * 
+     *
      * region        = 2ALPHA              ; ISO 3166-1 code
      *               / 3DIGIT              ; UN M.49 code
-     * 
+     *
      * variant       = 5*8alphanum         ; registered variants
      *               / (DIGIT 3alphanum)
-     * 
+     *
      * extension     = singleton 1*("-" (2*8alphanum))
-     * 
+     *
      *                                     ; Single alphanumerics
      *                                     ; "x" reserved for private use
      * singleton     = DIGIT               ; 0 - 9
@@ -151,9 +153,9 @@ public class LanguageTag {
      *               / %x59-5A             ; Y - Z
      *               / %x61-77             ; a - w
      *               / %x79-7A             ; y - z
-     * 
+     *
      * privateuse    = "x" 1*("-" (1*8alphanum))
-     * 
+     *
      */
     public static LanguageTag parse(String languageTag, ParseStatus sts) {
         if (sts == null) {
@@ -199,7 +201,7 @@ public class LanguageTag {
             if (s.length() == 0) {
                 sts._errorMsg = "Empty subtag";
             } else {
-                sts._errorMsg = "Invalid subtag: " + s; 
+                sts._errorMsg = "Invalid subtag: " + s;
             }
         }
 
@@ -690,6 +692,7 @@ public class LanguageTag {
         return AsciiUtil.toLowerString(s);
     }
 
+    @Override
     public String toString() {
         StringBuilder sb = new StringBuilder();
 
diff --git a/app/src/main/java/com/ibm/icu/impl/locale/LocaleExtensions.java b/icu4j/src/main/java/com/ibm/icu/impl/locale/LocaleExtensions.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/locale/LocaleExtensions.java
rename to icu4j/src/main/java/com/ibm/icu/impl/locale/LocaleExtensions.java
index 474c468..6418cd9 100644
--- a/app/src/main/java/com/ibm/icu/impl/locale/LocaleExtensions.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/locale/LocaleExtensions.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2010, International Business Machines Corporation and    *
@@ -197,6 +199,7 @@ public class LocaleExtensions {
     }
 
 
+    @Override
     public String toString() {
         return _id;
     }
@@ -205,10 +208,12 @@ public class LocaleExtensions {
         return _id;
     }
 
+    @Override
     public int hashCode() {
         return _id.hashCode();
     }
 
+    @Override
     public boolean equals(Object other) {
         if (this == other) {
             return true;
diff --git a/app/src/main/java/com/ibm/icu/impl/locale/LocaleObjectCache.java b/icu4j/src/main/java/com/ibm/icu/impl/locale/LocaleObjectCache.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/impl/locale/LocaleObjectCache.java
rename to icu4j/src/main/java/com/ibm/icu/impl/locale/LocaleObjectCache.java
index 7d239d3..2604780 100644
--- a/app/src/main/java/com/ibm/icu/impl/locale/LocaleObjectCache.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/locale/LocaleObjectCache.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2010, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/impl/locale/LocaleSyntaxException.java b/icu4j/src/main/java/com/ibm/icu/impl/locale/LocaleSyntaxException.java
similarity index 86%
rename from app/src/main/java/com/ibm/icu/impl/locale/LocaleSyntaxException.java
rename to icu4j/src/main/java/com/ibm/icu/impl/locale/LocaleSyntaxException.java
index 14d1130..d9fb69e 100644
--- a/app/src/main/java/com/ibm/icu/impl/locale/LocaleSyntaxException.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/locale/LocaleSyntaxException.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009, International Business Machines Corporation and         *
diff --git a/app/src/main/java/com/ibm/icu/impl/locale/LocaleValidityChecker.java b/icu4j/src/main/java/com/ibm/icu/impl/locale/LocaleValidityChecker.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/impl/locale/LocaleValidityChecker.java
rename to icu4j/src/main/java/com/ibm/icu/impl/locale/LocaleValidityChecker.java
index 2d5f2ec..fbe8261 100644
--- a/app/src/main/java/com/ibm/icu/impl/locale/LocaleValidityChecker.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/locale/LocaleValidityChecker.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2015-2016, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/impl/locale/ParseStatus.java b/icu4j/src/main/java/com/ibm/icu/impl/locale/ParseStatus.java
similarity index 87%
rename from app/src/main/java/com/ibm/icu/impl/locale/ParseStatus.java
rename to icu4j/src/main/java/com/ibm/icu/impl/locale/ParseStatus.java
index 2fa66c3..3215472 100644
--- a/app/src/main/java/com/ibm/icu/impl/locale/ParseStatus.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/locale/ParseStatus.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2010, International Business Machines Corporation and         *
diff --git a/app/src/main/java/com/ibm/icu/impl/locale/StringTokenIterator.java b/icu4j/src/main/java/com/ibm/icu/impl/locale/StringTokenIterator.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/impl/locale/StringTokenIterator.java
rename to icu4j/src/main/java/com/ibm/icu/impl/locale/StringTokenIterator.java
index 13cad08..2edfa7c 100644
--- a/app/src/main/java/com/ibm/icu/impl/locale/StringTokenIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/locale/StringTokenIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009, International Business Machines Corporation and         *
diff --git a/app/src/main/java/com/ibm/icu/impl/locale/UnicodeLocaleExtension.java b/icu4j/src/main/java/com/ibm/icu/impl/locale/UnicodeLocaleExtension.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/locale/UnicodeLocaleExtension.java
rename to icu4j/src/main/java/com/ibm/icu/impl/locale/UnicodeLocaleExtension.java
index 96b50b7..bc27a49 100644
--- a/app/src/main/java/com/ibm/icu/impl/locale/UnicodeLocaleExtension.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/locale/UnicodeLocaleExtension.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2014, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/impl/text/RbnfScannerProviderImpl.java b/icu4j/src/main/java/com/ibm/icu/impl/text/RbnfScannerProviderImpl.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/impl/text/RbnfScannerProviderImpl.java
rename to icu4j/src/main/java/com/ibm/icu/impl/text/RbnfScannerProviderImpl.java
index 5a3c05a..46f452b 100644
--- a/app/src/main/java/com/ibm/icu/impl/text/RbnfScannerProviderImpl.java
+++ b/icu4j/src/main/java/com/ibm/icu/impl/text/RbnfScannerProviderImpl.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2009-2014, International Business Machines Corporation and    *
@@ -178,12 +180,14 @@ public class RbnfScannerProviderImpl implements RbnfLenientScannerProvider {
             int oKey = keyIter.next();
             while (oKey != CollationElementIterator.NULLORDER) {
                 while (oStr != CollationElementIterator.NULLORDER &&
-                       CollationElementIterator.primaryOrder(oStr) == 0)
+                       CollationElementIterator.primaryOrder(oStr) == 0) {
                     oStr = strIter.next();
+                }
 
                 while (oKey != CollationElementIterator.NULLORDER &&
-                       CollationElementIterator.primaryOrder(oKey) == 0)
+                       CollationElementIterator.primaryOrder(oKey) == 0) {
                     oKey = keyIter.next();
+                }
 
                 if (oStr == CollationElementIterator.NULLORDER) {
                     return new int[] { -1, 0 };
@@ -208,11 +212,7 @@ public class RbnfScannerProviderImpl implements RbnfLenientScannerProvider {
                 }
             }
 
-            if (oKey == CollationElementIterator.NULLORDER) {
-                return new int[] { keyStart, strIter.getOffset() - keyStart };
-            }
-
-            return new int[] { -1, 0 };
+            return new int[] { keyStart, strIter.getOffset() - keyStart };
         }
         ///CLOVER:ON
 
diff --git a/app/src/main/java/com/ibm/icu/lang/CharSequences.java b/icu4j/src/main/java/com/ibm/icu/lang/CharSequences.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/lang/CharSequences.java
rename to icu4j/src/main/java/com/ibm/icu/lang/CharSequences.java
index ef09edc..1608905 100644
--- a/app/src/main/java/com/ibm/icu/lang/CharSequences.java
+++ b/icu4j/src/main/java/com/ibm/icu/lang/CharSequences.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ********************************************************************************
  * Copyright (C) 2010-2014, Google, International Business Machines Corporation *
@@ -172,7 +174,8 @@ public class CharSequences {
      */
     @Deprecated
     public static int compare(int codepoint, CharSequence a) {
-        return -compare(a, codepoint);
+        int result = compare(a, codepoint);
+        return result > 0 ? -1 : result < 0 ? 1 : 0; // Reverse the order.
     }
 
     /**
diff --git a/app/src/main/java/com/ibm/icu/lang/UCharacter.java b/icu4j/src/main/java/com/ibm/icu/lang/UCharacter.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/lang/UCharacter.java
rename to icu4j/src/main/java/com/ibm/icu/lang/UCharacter.java
index d9d3031..40fecc7 100644
--- a/app/src/main/java/com/ibm/icu/lang/UCharacter.java
+++ b/icu4j/src/main/java/com/ibm/icu/lang/UCharacter.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and
@@ -13,6 +15,8 @@ import java.util.Iterator;
 import java.util.Locale;
 import java.util.Map;
 
+import com.ibm.icu.impl.CaseMap;
+import com.ibm.icu.impl.CaseMap.StringContextIterator;
 import com.ibm.icu.impl.IllegalIcuArgumentException;
 import com.ibm.icu.impl.Trie2;
 import com.ibm.icu.impl.UBiDiProps;
@@ -1132,10 +1136,39 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
         /** @stable ICU 56 */
         public static final int SUTTON_SIGNWRITING_ID = 262; /*[1D800]*/
 
-        /**
-         * @stable ICU 2.4
+        /* New blocks in Unicode 9.0 */
+
+        /** @stable ICU 58 */
+        public static final int ADLAM_ID = 263; /*[1E900]*/
+        /** @stable ICU 58 */
+        public static final int BHAIKSUKI_ID = 264; /*[11C00]*/
+        /** @stable ICU 58 */
+        public static final int CYRILLIC_EXTENDED_C_ID = 265; /*[1C80]*/
+        /** @stable ICU 58 */
+        public static final int GLAGOLITIC_SUPPLEMENT_ID = 266; /*[1E000]*/
+        /** @stable ICU 58 */
+        public static final int IDEOGRAPHIC_SYMBOLS_AND_PUNCTUATION_ID = 267; /*[16FE0]*/
+        /** @stable ICU 58 */
+        public static final int MARCHEN_ID = 268; /*[11C70]*/
+        /** @stable ICU 58 */
+        public static final int MONGOLIAN_SUPPLEMENT_ID = 269; /*[11660]*/
+        /** @stable ICU 58 */
+        public static final int NEWA_ID = 270; /*[11400]*/
+        /** @stable ICU 58 */
+        public static final int OSAGE_ID = 271; /*[104B0]*/
+        /** @stable ICU 58 */
+        public static final int TANGUT_ID = 272; /*[17000]*/
+        /** @stable ICU 58 */
+        public static final int TANGUT_COMPONENTS_ID = 273; /*[18800]*/
+
+        /**
+         * One more than the highest normal UnicodeBlock value.
+         * The highest value is available via UCharacter.getIntPropertyMaxValue(UProperty.BLOCK).
+         *
+         * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
          */
-        public static final int COUNT = 263;
+        @Deprecated
+        public static final int COUNT = 274;
 
         // blocks objects ---------------------------------------------------
 
@@ -2363,6 +2396,36 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
         public static final UnicodeBlock SUTTON_SIGNWRITING =
                 new UnicodeBlock("SUTTON_SIGNWRITING", SUTTON_SIGNWRITING_ID); /*[1D800]*/
 
+        /* New blocks in Unicode 9.0 */
+
+        /** @stable ICU 58 */
+        public static final UnicodeBlock ADLAM = new UnicodeBlock("ADLAM", ADLAM_ID); /*[1E900]*/
+        /** @stable ICU 58 */
+        public static final UnicodeBlock BHAIKSUKI = new UnicodeBlock("BHAIKSUKI", BHAIKSUKI_ID); /*[11C00]*/
+        /** @stable ICU 58 */
+        public static final UnicodeBlock CYRILLIC_EXTENDED_C =
+                new UnicodeBlock("CYRILLIC_EXTENDED_C", CYRILLIC_EXTENDED_C_ID); /*[1C80]*/
+        /** @stable ICU 58 */
+        public static final UnicodeBlock GLAGOLITIC_SUPPLEMENT =
+                new UnicodeBlock("GLAGOLITIC_SUPPLEMENT", GLAGOLITIC_SUPPLEMENT_ID); /*[1E000]*/
+        /** @stable ICU 58 */
+        public static final UnicodeBlock IDEOGRAPHIC_SYMBOLS_AND_PUNCTUATION =
+                new UnicodeBlock("IDEOGRAPHIC_SYMBOLS_AND_PUNCTUATION", IDEOGRAPHIC_SYMBOLS_AND_PUNCTUATION_ID); /*[16FE0]*/
+        /** @stable ICU 58 */
+        public static final UnicodeBlock MARCHEN = new UnicodeBlock("MARCHEN", MARCHEN_ID); /*[11C70]*/
+        /** @stable ICU 58 */
+        public static final UnicodeBlock MONGOLIAN_SUPPLEMENT =
+                new UnicodeBlock("MONGOLIAN_SUPPLEMENT", MONGOLIAN_SUPPLEMENT_ID); /*[11660]*/
+        /** @stable ICU 58 */
+        public static final UnicodeBlock NEWA = new UnicodeBlock("NEWA", NEWA_ID); /*[11400]*/
+        /** @stable ICU 58 */
+        public static final UnicodeBlock OSAGE = new UnicodeBlock("OSAGE", OSAGE_ID); /*[104B0]*/
+        /** @stable ICU 58 */
+        public static final UnicodeBlock TANGUT = new UnicodeBlock("TANGUT", TANGUT_ID); /*[17000]*/
+        /** @stable ICU 58 */
+        public static final UnicodeBlock TANGUT_COMPONENTS =
+                new UnicodeBlock("TANGUT_COMPONENTS", TANGUT_COMPONENTS_ID); /*[18800]*/
+
         /**
          * @stable ICU 2.4
          */
@@ -2529,8 +2592,12 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
          */
         public static final int WIDE = 5;
         /**
-         * @stable ICU 2.4
+         * One more than the highest normal EastAsianWidth value.
+         * The highest value is available via UCharacter.getIntPropertyMaxValue(UProperty.EAST_ASIAN_WIDTH).
+         *
+         * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
          */
+        @Deprecated
         public static final int COUNT = 6;
     }
 
@@ -2614,8 +2681,12 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
          */
         public static final int WIDE = 17;
         /**
-         * @stable ICU 2.4
+         * One more than the highest normal DecompositionType value.
+         * The highest value is available via UCharacter.getIntPropertyMaxValue(UProperty.DECOMPOSITION_TYPE).
+         *
+         * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
          */
+        @Deprecated
         public static final int COUNT = 18;
     }
 
@@ -2651,8 +2722,12 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
          */
         public static final int TRANSPARENT = 5;
         /**
-         * @stable ICU 2.4
+         * One more than the highest normal JoiningType value.
+         * The highest value is available via UCharacter.getIntPropertyMaxValue(UProperty.JOINING_TYPE).
+         *
+         * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
          */
+        @Deprecated
         public static final int COUNT = 6;
     }
 
@@ -2949,10 +3024,21 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
         /** @stable ICU 54 */
         public static final int STRAIGHT_WAW = 85;
 
+        /** @stable ICU 58 */
+        public static final int AFRICAN_FEH = 86;
+        /** @stable ICU 58 */
+        public static final int AFRICAN_NOON = 87;
+        /** @stable ICU 58 */
+        public static final int AFRICAN_QAF = 88;
+
         /**
-         * @stable ICU 2.4
+         * One more than the highest normal JoiningGroup value.
+         * The highest value is available via UCharacter.getIntPropertyMaxValue(UProperty.JoiningGroup).
+         *
+         * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
          */
-        public static final int COUNT = 86;
+        @Deprecated
+        public static final int COUNT = 89;
     }
 
     /**
@@ -3011,10 +3097,24 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
         public static final int PREPEND = 11;
         /** @stable ICU 50 */
         public static final int REGIONAL_INDICATOR = 12;  /*[RI]*/ /* new in Unicode 6.2/ICU 50 */
-        /**
-         * @stable ICU 3.4
+        /** @stable ICU 58 */
+        public static final int E_BASE = 13;          /*[EB]*/ /* from here on: new in Unicode 9.0/ICU 58 */
+        /** @stable ICU 58 */
+        public static final int E_BASE_GAZ = 14;      /*[EBG]*/
+        /** @stable ICU 58 */
+        public static final int E_MODIFIER = 15;      /*[EM]*/
+        /** @stable ICU 58 */
+        public static final int GLUE_AFTER_ZWJ = 16;  /*[GAZ]*/
+        /** @stable ICU 58 */
+        public static final int ZWJ = 17;             /*[ZWJ]*/
+        /**
+         * One more than the highest normal GraphemeClusterBreak value.
+         * The highest value is available via UCharacter.getIntPropertyMaxValue(UProperty.GRAPHEME_CLUSTER_BREAK).
+         *
+         * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
          */
-        public static final int COUNT = 13;
+        @Deprecated
+        public static final int COUNT = 18;
     }
 
     /**
@@ -3083,10 +3183,24 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
         public static final int SINGLE_QUOTE = 15;     /*[SQ]*/
         /** @stable ICU 52 */
         public static final int DOUBLE_QUOTE = 16;     /*[DQ]*/
-        /**
-         * @stable ICU 4.0
+        /** @stable ICU 58 */
+        public static final int E_BASE = 17;           /*[EB]*/ /* from here on: new in Unicode 9.0/ICU 58 */
+        /** @stable ICU 58 */
+        public static final int E_BASE_GAZ = 18;       /*[EBG]*/
+        /** @stable ICU 58 */
+        public static final int E_MODIFIER = 19;       /*[EM]*/
+        /** @stable ICU 58 */
+        public static final int GLUE_AFTER_ZWJ = 20;   /*[GAZ]*/
+        /** @stable ICU 58 */
+        public static final int ZWJ = 21;              /*[ZWJ]*/
+        /**
+         * One more than the highest normal WordBreak value.
+         * The highest value is available via UCharacter.getIntPropertyMaxValue(UProperty.WORD_BREAK).
+         *
+         * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
          */
-        public static final int COUNT = 17;
+        @Deprecated
+        public static final int COUNT = 22;
     }
 
     /**
@@ -3156,8 +3270,12 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
          */
         public static final int SCONTINUE = 14;
         /**
-         * @stable ICU 4.0
+         * One more than the highest normal SentenceBreak value.
+         * The highest value is available via UCharacter.getIntPropertyMaxValue(UProperty.SENTENCE_BREAK).
+         *
+         * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
          */
+        @Deprecated
         public static final int COUNT = 15;
     }
 
@@ -3326,10 +3444,20 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
         public static final int HEBREW_LETTER = 38;  /*[HL]*/ /* new in Unicode 6.1/ICU 49 */
         /** @stable ICU 50 */
         public static final int REGIONAL_INDICATOR = 39;  /*[RI]*/ /* new in Unicode 6.2/ICU 50 */
-        /**
-         * @stable ICU 2.4
+        /** @stable ICU 58 */
+        public static final int E_BASE = 40;  /*[EB]*/ /* from here on: new in Unicode 9.0/ICU 58 */
+        /** @stable ICU 58 */
+        public static final int E_MODIFIER = 41;  /*[EM]*/
+        /** @stable ICU 58 */
+        public static final int ZWJ = 42;  /*[ZWJ]*/
+        /**
+         * One more than the highest normal LineBreak value.
+         * The highest value is available via UCharacter.getIntPropertyMaxValue(UProperty.LINE_BREAK).
+         *
+         * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
          */
-        public static final int COUNT = 40;
+        @Deprecated
+        public static final int COUNT = 43;
     }
 
     /**
@@ -3356,8 +3484,12 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
          */
         public static final int NUMERIC = 3;
         /**
-         * @stable ICU 2.4
+         * One more than the highest normal NumericType value.
+         * The highest value is available via UCharacter.getIntPropertyMaxValue(UProperty.NUMERIC_TYPE).
+         *
+         * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
          */
+        @Deprecated
         public static final int COUNT = 4;
     }
 
@@ -3394,8 +3526,12 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
          */
         public static final int LVT_SYLLABLE        = 5;   /*[LVT]*/
         /**
-         * @stable ICU 2.6
+         * One more than the highest normal HangulSyllableType value.
+         * The highest value is available via UCharacter.getIntPropertyMaxValue(UProperty.HANGUL_SYLLABLE_TYPE).
+         *
+         * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
          */
+        @Deprecated
         public static final int COUNT               = 6;
     }
 
@@ -3422,8 +3558,12 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
          */
         public static final int CLOSE = 2;
         /**
-         * @stable ICU 52
+         * One more than the highest normal BidiPairedBracketType value.
+         * The highest value is available via UCharacter.getIntPropertyMaxValue(UProperty.BIDI_PAIRED_BRACKET_TYPE).
+         *
+         * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
          */
+        @Deprecated
         public static final int COUNT = 3;
     }
 
@@ -4726,124 +4866,6 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
         throw new IllegalArgumentException("Illegal codepoint");
     }
 
-    /**
-     * Implementation of UCaseProps.ContextIterator, iterates over a String.
-     * See ustrcase.c/utf16_caseContextIterator().
-     */
-    private static class StringContextIterator implements UCaseProps.ContextIterator {
-        /**
-         * Constructor.
-         * @param s String to iterate over.
-         */
-        StringContextIterator(String s) {
-            this.s=s;
-            limit=s.length();
-            cpStart=cpLimit=index=0;
-            dir=0;
-        }
-
-        /**
-         * Set the iteration limit for nextCaseMapCP() to an index within the string.
-         * If the limit parameter is negative or past the string, then the
-         * string length is restored as the iteration limit.
-         *
-         * <p>This limit does not affect the next() function which always
-         * iterates to the very end of the string.
-         *
-         * @param lim The iteration limit.
-         */
-        public void setLimit(int lim) {
-            if(0<=lim && lim<=s.length()) {
-                limit=lim;
-            } else {
-                limit=s.length();
-            }
-        }
-
-        /**
-         * Move to the iteration limit without fetching code points up to there.
-         */
-        public void moveToLimit() {
-            cpStart=cpLimit=limit;
-        }
-
-        /**
-         * Iterate forward through the string to fetch the next code point
-         * to be case-mapped, and set the context indexes for it.
-         *
-         * <p>When the iteration limit is reached (and -1 is returned),
-         * getCPStart() will be at the iteration limit.
-         *
-         * <p>Iteration with next() does not affect the position for nextCaseMapCP().
-         *
-         * @return The next code point to be case-mapped, or <0 when the iteration is done.
-         */
-        public int nextCaseMapCP() {
-            cpStart=cpLimit;
-            if(cpLimit<limit) {
-                int c=s.codePointAt(cpLimit);
-                cpLimit+=Character.charCount(c);
-                return c;
-            } else {
-                return -1;
-            }
-        }
-
-        /**
-         * Returns the start of the code point that was last returned
-         * by nextCaseMapCP().
-         */
-        public int getCPStart() {
-            return cpStart;
-        }
-
-        /**
-         * Returns the limit of the code point that was last returned
-         * by nextCaseMapCP().
-         */
-        public int getCPLimit() {
-            return cpLimit;
-        }
-
-        // implement UCaseProps.ContextIterator
-        // The following code is not used anywhere in this private class
-        public void reset(int direction) {
-            if(direction>0) {
-                /* reset for forward iteration */
-                dir=1;
-                index=cpLimit;
-            } else if(direction<0) {
-                /* reset for backward iteration */
-                dir=-1;
-                index=cpStart;
-            } else {
-                // not a valid direction
-                dir=0;
-                index=0;
-            }
-        }
-
-        public int next() {
-            int c;
-
-            if(dir>0 && index<s.length()) {
-                c=s.codePointAt(index);
-                index+=Character.charCount(c);
-                return c;
-            } else if(dir<0 && index>0) {
-                c=s.codePointBefore(index);
-                index-=Character.charCount(c);
-                return c;
-            }
-            return -1;
-        }
-
-        // variables
-        protected String s;
-        protected int index, limit, cpStart, cpLimit;
-        protected int dir; // 0=initial state  >0=forward  <0=backward
-    }
-
     /**
      * Returns the uppercase version of the argument string.
      * Casing is dependent on the default locale and context-sensitive.
@@ -4913,31 +4935,7 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
      * @stable ICU 3.2
      */
     public static String toUpperCase(ULocale locale, String str) {
-        StringContextIterator iter = new StringContextIterator(str);
-        StringBuilder result = new StringBuilder(str.length());
-        int[] locCache = new int[1];
-        int c;
-
-        if (locale == null) {
-            locale = ULocale.getDefault();
-        }
-        locCache[0]=0;
-
-        while((c=iter.nextCaseMapCP())>=0) {
-            c = UCaseProps.INSTANCE.toFullUpper(c, iter, result, locale, locCache);
-
-            /* decode the result */
-            if(c<0) {
-                /* (not) original code point */
-                c=~c;
-            } else if(c<=UCaseProps.MAX_STRING_LENGTH) {
-                /* mapping already appended to result */
-                continue;
-                /* } else { append single-code point mapping */
-            }
-            result.appendCodePoint(c);
-        }
-        return result.toString();
+        return CaseMap.toUpper(locale, str);
     }
 
     /**
@@ -5184,79 +5182,79 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
     }
 
 
-    private static final int BREAK_MASK =  
-            (1<<UCharacterCategory.DECIMAL_DIGIT_NUMBER)  
-            | (1<<UCharacterCategory.OTHER_LETTER)  
-            | (1<<UCharacterCategory.MODIFIER_LETTER); 
-
-    /** 
-     * Return a string with just the first word titlecased, for menus and UI, etc. This does not affect most of the string,  
-     * and sometimes has no effect at all; the original string is returned whenever casing 
-     * would not be appropriate for the first word (such as for CJK characters or initial numbers).  
-     * Initial non-letters are skipped in order to find the character to change.  
-     * Characters past the first affected are left untouched: see also TITLECASE_NO_LOWERCASE. 
-     * <p>Examples: 
-     * <table border='1'><tr><th>Source</th><th>Result</th><th>Locale</th></tr> 
-     * <tr><td>anglo-American locale</td><td>Anglo-American locale</td></tr> 
-     * <tr><td>“contact us”</td><td>“Contact us”</td></tr> 
-     * <tr><td>49ers win!</td><td>49ers win!</td></tr> 
-     * <tr><td>丰(abc)</td><td>丰(abc)</td></tr> 
-     * <tr><td>«ijs»</td><td>«Ijs»</td></tr> 
-     * <tr><td>«ijs»</td><td>«IJs»</td><td>nl-BE</td></tr> 
-     * <tr><td>«ijs»</td><td>«İjs»</td><td>tr-DE</td></tr> 
-     * </table> 
-     * @param locale the locale for accessing exceptional behavior (eg for tr). 
-     * @param str the source string to change 
-     * @return the modified string, or the original if no modifications were necessary. 
-     * @internal 
+    private static final int BREAK_MASK =
+            (1<<UCharacterCategory.DECIMAL_DIGIT_NUMBER)
+            | (1<<UCharacterCategory.OTHER_LETTER)
+            | (1<<UCharacterCategory.MODIFIER_LETTER);
+
+    /**
+     * Return a string with just the first word titlecased, for menus and UI, etc. This does not affect most of the string,
+     * and sometimes has no effect at all; the original string is returned whenever casing
+     * would not be appropriate for the first word (such as for CJK characters or initial numbers).
+     * Initial non-letters are skipped in order to find the character to change.
+     * Characters past the first affected are left untouched: see also TITLECASE_NO_LOWERCASE.
+     * <p>Examples:
+     * <table border='1'><tr><th>Source</th><th>Result</th><th>Locale</th></tr>
+     * <tr><td>anglo-American locale</td><td>Anglo-American locale</td></tr>
+     * <tr><td>“contact us”</td><td>“Contact us”</td></tr>
+     * <tr><td>49ers win!</td><td>49ers win!</td></tr>
+     * <tr><td>丰(abc)</td><td>丰(abc)</td></tr>
+     * <tr><td>«ijs»</td><td>«Ijs»</td></tr>
+     * <tr><td>«ijs»</td><td>«IJs»</td><td>nl-BE</td></tr>
+     * <tr><td>«ijs»</td><td>«İjs»</td><td>tr-DE</td></tr>
+     * </table>
+     * @param locale the locale for accessing exceptional behavior (eg for tr).
+     * @param str the source string to change
+     * @return the modified string, or the original if no modifications were necessary.
+     * @internal
      * @deprecated ICU internal only
-     */ 
-    @Deprecated 
-    public static String toTitleFirst(ULocale locale, String str) { 
-        int c = 0; 
-        for (int i = 0; i < str.length(); i += UCharacter.charCount(c)) { 
-            c = UCharacter.codePointAt(str, i); 
-            int propertyMask = UCharacter.getIntPropertyValue(c, UProperty.GENERAL_CATEGORY_MASK); 
-            if ((propertyMask & BREAK_MASK) != 0) { // handle "49ers", initial CJK 
-                break; 
-            } 
-            if (UCaseProps.INSTANCE.getType(c) == UCaseProps.NONE) { 
-                continue; 
-            } 
-
-            // we now have the first cased character 
-            // What we really want is something like: 
-            // String titled = UCharacter.toTitleCase(locale, str, i, outputCharsTaken); 
-            // That is, just give us the titlecased string, for the locale, at i and following,  
-            // and tell us how many characters are replaced. 
-            // The following won't work completely: it needs some more substantial changes to UCaseProps 
-
-            String substring = str.substring(i, i+UCharacter.charCount(c)); 
-            String titled = UCharacter.toTitleCase(locale, substring, BreakIterator.getSentenceInstance(locale), 0); 
-
-            // skip if no change 
-            if (titled.codePointAt(0) == c) { 
-                // Using 0 is safe, since any change in titling will not have first initial character 
-                break; 
-            } 
-            StringBuilder result = new StringBuilder(str.length()).append(str, 0, i); 
-            int startOfSuffix; 
-
-            // handle dutch, but check first for 'i', since that's faster. Should be built into UCaseProps. 
-
-            if (c == 'i' && locale.getLanguage().equals("nl") && i < str.length() && str.charAt(i+1) == 'j') { 
-                result.append("IJ"); 
-                startOfSuffix = 2; 
-            } else { 
-                result.append(titled); 
-                startOfSuffix = i + UCharacter.charCount(c); 
-            } 
-
-            // add the remainder, and return 
-            return result.append(str, startOfSuffix, str.length()).toString(); 
-        } 
-        return str; // no change 
-    } 
+     */
+    @Deprecated
+    public static String toTitleFirst(ULocale locale, String str) {
+        int c = 0;
+        for (int i = 0; i < str.length(); i += UCharacter.charCount(c)) {
+            c = UCharacter.codePointAt(str, i);
+            int propertyMask = UCharacter.getIntPropertyValue(c, UProperty.GENERAL_CATEGORY_MASK);
+            if ((propertyMask & BREAK_MASK) != 0) { // handle "49ers", initial CJK
+                break;
+            }
+            if (UCaseProps.INSTANCE.getType(c) == UCaseProps.NONE) {
+                continue;
+            }
+
+            // we now have the first cased character
+            // What we really want is something like:
+            // String titled = UCharacter.toTitleCase(locale, str, i, outputCharsTaken);
+            // That is, just give us the titlecased string, for the locale, at i and following,
+            // and tell us how many characters are replaced.
+            // The following won't work completely: it needs some more substantial changes to UCaseProps
+
+            String substring = str.substring(i, i+UCharacter.charCount(c));
+            String titled = UCharacter.toTitleCase(locale, substring, BreakIterator.getSentenceInstance(locale), 0);
+
+            // skip if no change
+            if (titled.codePointAt(0) == c) {
+                // Using 0 is safe, since any change in titling will not have first initial character
+                break;
+            }
+            StringBuilder result = new StringBuilder(str.length()).append(str, 0, i);
+            int startOfSuffix;
+
+            // handle dutch, but check first for 'i', since that's faster. Should be built into UCaseProps.
+
+            if (c == 'i' && locale.getLanguage().equals("nl") && i < str.length() && str.charAt(i+1) == 'j') {
+                result.append("IJ");
+                startOfSuffix = 2;
+            } else {
+                result.append(titled);
+                startOfSuffix = i + UCharacter.charCount(c);
+            }
+
+            // add the remainder, and return
+            return result.append(str, startOfSuffix, str.length()).toString();
+        }
+        return str; // no change
+    }
 
     /**
      * {@icu} <p>Returns the titlecase version of the argument string.
@@ -5523,6 +5521,7 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
         }
 
         // implements RangeValueIterator
+        @Override
         public boolean next(Element element) {
             if(trieIterator.hasNext() && !(range=trieIterator.next()).leadSurrogate) {
                 element.start=range.startCodePoint;
@@ -5535,6 +5534,7 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
         }
 
         // implements RangeValueIterator
+        @Override
         public void reset() {
             trieIterator=UCharacterProperty.INSTANCE.m_trie_.iterator(MASK_TYPE);
         }
@@ -5544,6 +5544,7 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
 
         private static final class MaskType implements Trie2.ValueMapper {
             // Extracts the general category ("character type") from the trie value.
+            @Override
             public int map(int value) {
                 return value & UCharacterProperty.TYPE_MASK;
             }
@@ -5589,8 +5590,11 @@ public final class UCharacter implements ECharacterCategory, ECharacterDirection
     }
 
     private static final class DummyValueIterator implements ValueIterator {
+        @Override
         public boolean next(Element element) { return false; }
+        @Override
         public void reset() {}
+        @Override
         public void setRange(int start, int limit) {}
     }
 
diff --git a/app/src/main/java/com/ibm/icu/lang/UCharacterCategory.java b/icu4j/src/main/java/com/ibm/icu/lang/UCharacterCategory.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/lang/UCharacterCategory.java
rename to icu4j/src/main/java/com/ibm/icu/lang/UCharacterCategory.java
index 60c0a64..64e2106 100644
--- a/app/src/main/java/com/ibm/icu/lang/UCharacterCategory.java
+++ b/icu4j/src/main/java/com/ibm/icu/lang/UCharacterCategory.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
  *******************************************************************************
  * Copyright (C) 1996-2004, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/lang/UCharacterDirection.java b/icu4j/src/main/java/com/ibm/icu/lang/UCharacterDirection.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/lang/UCharacterDirection.java
rename to icu4j/src/main/java/com/ibm/icu/lang/UCharacterDirection.java
index 2d40c75..0633ba3 100644
--- a/app/src/main/java/com/ibm/icu/lang/UCharacterDirection.java
+++ b/icu4j/src/main/java/com/ibm/icu/lang/UCharacterDirection.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
 *******************************************************************************
 * Copyright (C) 1996-2013, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/lang/UCharacterEnums.java b/icu4j/src/main/java/com/ibm/icu/lang/UCharacterEnums.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/lang/UCharacterEnums.java
rename to icu4j/src/main/java/com/ibm/icu/lang/UCharacterEnums.java
index bab4413..c192da8 100644
--- a/app/src/main/java/com/ibm/icu/lang/UCharacterEnums.java
+++ b/icu4j/src/main/java/com/ibm/icu/lang/UCharacterEnums.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
  *******************************************************************************
  * Copyright (C) 2004-2016, International Business Machines Corporation and
@@ -18,7 +20,7 @@ public class UCharacterEnums {
     private UCharacterEnums() {}
 
     /**
-     * 'Enum' for the CharacterCategory constants.  These constants are 
+     * 'Enum' for the CharacterCategory constants.  These constants are
      * compatible in name <b>but not in value</b> with those defined in
      * {@link java.lang.Character}.
      * @see UCharacterCategory
@@ -29,11 +31,11 @@ public class UCharacterEnums {
          * Unassigned character type
          * @stable ICU 2.1
          */
-        public static final byte UNASSIGNED              = 0; 
+        public static final byte UNASSIGNED              = 0;
 
         /**
          * Character type Cn
-         * Not Assigned (no characters in [UnicodeData.txt] have this property) 
+         * Not Assigned (no characters in [UnicodeData.txt] have this property)
          * @stable ICU 2.6
          */
         public static final byte GENERAL_OTHER_TYPES     = 0;
@@ -89,7 +91,7 @@ public class UCharacterEnums {
 
         /**
          * Character type Nd
-         * @stable ICU 2.1      
+         * @stable ICU 2.1
          */
         public static final byte DECIMAL_DIGIT_NUMBER    = 9;
 
@@ -98,7 +100,7 @@ public class UCharacterEnums {
          * @stable ICU 2.1
          */
         public static final byte LETTER_NUMBER           = 10;
-        
+
         /**
          * Character type No
          * @stable ICU 2.1
@@ -158,7 +160,7 @@ public class UCharacterEnums {
          * @stable ICU 2.1
          */
         public static final byte START_PUNCTUATION       = 20;
-        
+
         /**
          * Character type Pe
          * @stable ICU 2.1
@@ -188,19 +190,19 @@ public class UCharacterEnums {
          * @stable ICU 2.1
          */
         public static final byte CURRENCY_SYMBOL         = 25;
-        
+
         /**
          * Character type Sk
          * @stable ICU 2.1
          */
         public static final byte MODIFIER_SYMBOL         = 26;
-        
+
         /**
          * Character type So
          * @stable ICU 2.1
          */
         public static final byte OTHER_SYMBOL            = 27;
-        
+
         /**
          * Character type Pi
          * @see #INITIAL_QUOTE_PUNCTUATION
@@ -230,9 +232,11 @@ public class UCharacterEnums {
          * @stable ICU 2.8
          */
         public static final byte FINAL_QUOTE_PUNCTUATION   = 29;
-        
+
         /**
-         * Character type count
+         * One more than the highest normal ECharacterCategory value.
+         * This numeric value is stable (will not change), see
+         * http://www.unicode.org/policies/stability_policy.html#Property_Value
          * @stable ICU 2.1
          */
         public static final byte CHAR_CATEGORY_COUNT     = 30;
@@ -319,7 +323,7 @@ public class UCharacterEnums {
         /**
          * Directional type AN
          * @stable ICU 2.1
-         */                                                    
+         */
         public static final int ARABIC_NUMBER              = 5;
 
         /**
@@ -361,7 +365,7 @@ public class UCharacterEnums {
         /**
          * Directional type S
          * @stable ICU 2.1
-         */      
+         */
         public static final int SEGMENT_SEPARATOR          = 8;
 
         /**
@@ -416,7 +420,7 @@ public class UCharacterEnums {
          * Directional type LRO
          * @stable ICU 2.1
          */
-        public static final int LEFT_TO_RIGHT_OVERRIDE     = 12;  
+        public static final int LEFT_TO_RIGHT_OVERRIDE     = 12;
 
         /**
          * Equivalent to {@link
@@ -535,9 +539,12 @@ public class UCharacterEnums {
         public static final byte POP_DIRECTIONAL_ISOLATE     = 22;
 
         /**
-         * Number of directional types
-         * @stable ICU 2.1
+         * One more than the highest normal ECharacterDirection value.
+         * The highest value is available via UCharacter.getIntPropertyMaxValue(UProperty.BIDI_CLASS).
+         *
+         * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
          */
+        @Deprecated
         public static final int CHAR_DIRECTION_COUNT       = 23;
 
         /**
diff --git a/app/src/main/java/com/ibm/icu/lang/UCharacterNameIterator.java b/icu4j/src/main/java/com/ibm/icu/lang/UCharacterNameIterator.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/lang/UCharacterNameIterator.java
rename to icu4j/src/main/java/com/ibm/icu/lang/UCharacterNameIterator.java
index 9a8d3ad..b38da26 100644
--- a/app/src/main/java/com/ibm/icu/lang/UCharacterNameIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/lang/UCharacterNameIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 1996-2011, International Business Machines Corporation and   *
@@ -32,6 +34,7 @@ class UCharacterNameIterator implements ValueIterator
     * @return true if we are not at the end of the iteration, false otherwise.
     * @see com.ibm.icu.util.ValueIterator.Element
     */
+    @Override
     public boolean next(ValueIterator.Element element)
     {
         if (m_current_ >= m_limit_) {
@@ -72,7 +75,7 @@ class UCharacterNameIterator implements ValueIterator
                             return true;
                         }
                     }
-                    /* 
+                    /*
                     // "if (m_current_ >= m_limit_)" would not return true
                     // because it can never be reached due to:
                     // 1) It has already been checked earlier
@@ -114,6 +117,7 @@ class UCharacterNameIterator implements ValueIterator
     * UCharacter.MIN_VALUE or X if a setRange(X, Y) has been called previously.
     * </p>
     */
+    @Override
     public void reset()
     {
         m_current_        = m_start_;
@@ -136,6 +140,7 @@ class UCharacterNameIterator implements ValueIterator
      * @exception IllegalArgumentException thrown when attempting to set an
      *            illegal range. E.g limit <= start
      */
+    @Override
     public void setRange(int start, int limit)
     {
         if (start >= limit) {
diff --git a/app/src/main/java/com/ibm/icu/lang/UProperty.java b/icu4j/src/main/java/com/ibm/icu/lang/UProperty.java
similarity index 88%
rename from app/src/main/java/com/ibm/icu/lang/UProperty.java
rename to icu4j/src/main/java/com/ibm/icu/lang/UProperty.java
index b588cab..1dc3b56 100644
--- a/app/src/main/java/com/ibm/icu/lang/UProperty.java
+++ b/icu4j/src/main/java/com/ibm/icu/lang/UProperty.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
 *******************************************************************************
 * Copyright (C) 1996-2016, International Business Machines Corporation and
@@ -157,160 +159,160 @@ public interface UProperty
 
     /**
      * <p>Binary property Hyphen.
-     * <p>Dashes used to mark connections between pieces of words, plus the 
+     * <p>Dashes used to mark connections between pieces of words, plus the
      * Katakana middle dot.
      * @stable ICU 2.6
-     */ 
-    public static final int HYPHEN = 14; 
+     */
+    public static final int HYPHEN = 14;
 
-    /** 
+    /**
      * <p>Binary property ID_Continue.
      * <p>Characters that can continue an identifier.
      * <p>ID_Start+Mn+Mc+Nd+Pc
      * @stable ICU 2.6
-     */ 
-    public static final int ID_CONTINUE = 15; 
+     */
+    public static final int ID_CONTINUE = 15;
 
-    /** 
+    /**
      * <p>Binary property ID_Start.
      * <p>Characters that can start an identifier.
      * <p>Lu+Ll+Lt+Lm+Lo+Nl
      * @stable ICU 2.6
-     */ 
-    public static final int ID_START = 16; 
+     */
+    public static final int ID_START = 16;
 
-    /** 
+    /**
      * <p>Binary property Ideographic.
      * <p>CJKV ideographs.
      * @stable ICU 2.6
-     */ 
-    public static final int IDEOGRAPHIC = 17; 
+     */
+    public static final int IDEOGRAPHIC = 17;
 
-    /** 
+    /**
      * <p>Binary property IDS_Binary_Operator (new).
      * <p>For programmatic determination of Ideographic Description Sequences.
      *
      * @stable ICU 2.6
-     */ 
-    public static final int IDS_BINARY_OPERATOR = 18; 
+     */
+    public static final int IDS_BINARY_OPERATOR = 18;
 
-    /** 
+    /**
      * <p>Binary property IDS_Trinary_Operator (new).
      * <p>For programmatic determination of Ideographic Description
      * Sequences.
      * @stable ICU 2.6
-     */ 
-    public static final int IDS_TRINARY_OPERATOR = 19; 
+     */
+    public static final int IDS_TRINARY_OPERATOR = 19;
 
-    /** 
+    /**
      * <p>Binary property Join_Control.
      * <p>Format controls for cursive joining and ligation.
      * @stable ICU 2.6
-     */ 
-    public static final int JOIN_CONTROL = 20; 
+     */
+    public static final int JOIN_CONTROL = 20;
 
-    /** 
+    /**
      * <p>Binary property Logical_Order_Exception (new).
-     * <p>Characters that do not use logical order and require special 
+     * <p>Characters that do not use logical order and require special
      * handling in most processing.
      * @stable ICU 2.6
-     */ 
-    public static final int LOGICAL_ORDER_EXCEPTION = 21; 
+     */
+    public static final int LOGICAL_ORDER_EXCEPTION = 21;
 
-    /** 
+    /**
      * <p>Binary property Lowercase.
-     * <p>Same as UCharacter.isULowercase(), different from 
+     * <p>Same as UCharacter.isULowercase(), different from
      * UCharacter.islower().
      * <p>Ll+Other_Lowercase
      * @stable ICU 2.6
-     */ 
-    public static final int LOWERCASE = 22; 
+     */
+    public static final int LOWERCASE = 22;
 
     /** <p>Binary property Math.
      * <p>Sm+Other_Math
      * @stable ICU 2.6
-     */ 
-    public static final int MATH = 23; 
+     */
+    public static final int MATH = 23;
 
-    /** 
+    /**
      * <p>Binary property Noncharacter_Code_Point.
-     * <p>Code points that are explicitly defined as illegal for the encoding 
+     * <p>Code points that are explicitly defined as illegal for the encoding
      * of characters.
      * @stable ICU 2.6
-     */ 
-    public static final int NONCHARACTER_CODE_POINT = 24; 
+     */
+    public static final int NONCHARACTER_CODE_POINT = 24;
 
-    /** 
+    /**
      * <p>Binary property Quotation_Mark.
      * @stable ICU 2.6
-     */ 
-    public static final int QUOTATION_MARK = 25; 
+     */
+    public static final int QUOTATION_MARK = 25;
 
-    /** 
+    /**
      * <p>Binary property Radical (new).
-     * <p>For programmatic determination of Ideographic Description 
+     * <p>For programmatic determination of Ideographic Description
      * Sequences.
      * @stable ICU 2.6
-     */ 
-    public static final int RADICAL = 26; 
+     */
+    public static final int RADICAL = 26;
 
-    /** 
+    /**
      * <p>Binary property Soft_Dotted (new).
      * <p>Characters with a "soft dot", like i or j.
      * <p>An accent placed on these characters causes the dot to disappear.
      * @stable ICU 2.6
-     */ 
-    public static final int SOFT_DOTTED = 27; 
+     */
+    public static final int SOFT_DOTTED = 27;
 
-    /** 
+    /**
      * <p>Binary property Terminal_Punctuation.
-     * <p>Punctuation characters that generally mark the end of textual 
+     * <p>Punctuation characters that generally mark the end of textual
      * units.
      * @stable ICU 2.6
-     */ 
-    public static final int TERMINAL_PUNCTUATION = 28; 
+     */
+    public static final int TERMINAL_PUNCTUATION = 28;
 
-    /** 
+    /**
      * <p>Binary property Unified_Ideograph (new).
-     * <p>For programmatic determination of Ideographic Description 
+     * <p>For programmatic determination of Ideographic Description
      * Sequences.
      * @stable ICU 2.6
-     */ 
-    public static final int UNIFIED_IDEOGRAPH = 29; 
+     */
+    public static final int UNIFIED_IDEOGRAPH = 29;
 
-    /** 
+    /**
      * <p>Binary property Uppercase.
-     * <p>Same as UCharacter.isUUppercase(), different from 
+     * <p>Same as UCharacter.isUUppercase(), different from
      * UCharacter.isUpperCase().
      * <p>Lu+Other_Uppercase
      * @stable ICU 2.6
-     */ 
-    public static final int UPPERCASE = 30; 
+     */
+    public static final int UPPERCASE = 30;
 
-    /** 
+    /**
      * <p>Binary property White_Space.
-     * <p>Same as UCharacter.isUWhiteSpace(), different from 
+     * <p>Same as UCharacter.isUWhiteSpace(), different from
      * UCharacter.isSpace() and UCharacter.isWhitespace().
      * Space characters+TAB+CR+LF-ZWSP-ZWNBSP
      * @stable ICU 2.6
-     */ 
-    public static final int WHITE_SPACE = 31; 
+     */
+    public static final int WHITE_SPACE = 31;
 
-    /** 
+    /**
      * <p>Binary property XID_Continue.
-     * <p>ID_Continue modified to allow closure under normalization forms 
+     * <p>ID_Continue modified to allow closure under normalization forms
      * NFKC and NFKD.
      * @stable ICU 2.6
-     */ 
-    public static final int XID_CONTINUE = 32; 
+     */
+    public static final int XID_CONTINUE = 32;
 
-    /** 
+    /**
      * <p>Binary property XID_Start.
-     * <p>ID_Start modified to allow closure under normalization forms NFKC 
+     * <p>ID_Start modified to allow closure under normalization forms NFKC
      * and NFKD.
      * @stable ICU 2.6
-     */ 
-    public static final int XID_START = 33; 
+     */
+    public static final int XID_START = 33;
 
     /**
      * <p>Binary property Case_Sensitive.
@@ -338,7 +340,7 @@ public interface UProperty
      */
     public static final int VARIATION_SELECTOR = 36;
 
-    /** 
+    /**
      * Binary property NFD_Inert.
      * ICU-specific property for characters that are inert under NFD,
      * i.e., they do not interact with adjacent characters.
@@ -364,7 +366,7 @@ public interface UProperty
      */
     public static final int NFD_INERT = 37;
 
-    /** 
+    /**
      * Binary property NFKD_Inert.
      * ICU-specific property for characters that are inert under NFKD,
      * i.e., they do not interact with adjacent characters.
@@ -372,11 +374,11 @@ public interface UProperty
      * to find the boundary of safely normalizable text despite possible
      * text additions.
      * @see #NFD_INERT
-     * @stable ICU 3.0 
+     * @stable ICU 3.0
      */
     public static final int NFKD_INERT = 38;
 
-    /** 
+    /**
      * Binary property NFC_Inert.
      * ICU-specific property for characters that are inert under NFC,
      * i.e., they do not interact with adjacent characters.
@@ -384,11 +386,11 @@ public interface UProperty
      * to find the boundary of safely normalizable text despite possible
      * text additions.
      * @see #NFD_INERT
-     * @stable ICU 3.0 
+     * @stable ICU 3.0
      */
     public static final int NFC_INERT = 39;
 
-    /** 
+    /**
      * Binary property NFKC_Inert.
      * ICU-specific property for characters that are inert under NFKC,
      * i.e., they do not interact with adjacent characters.
@@ -396,7 +398,7 @@ public interface UProperty
      * to find the boundary of safely normalizable text despite possible
      * text additions.
      * @see #NFD_INERT
-     * @stable ICU 3.0 
+     * @stable ICU 3.0
      */
     public static final int NFKC_INERT = 40;
 
@@ -410,7 +412,7 @@ public interface UProperty
      * ICU uses this property for segmenting a string for generating a set of
      * canonically equivalent strings, e.g. for canonical closure while
      * processing collation tailoring rules.
-     * @stable ICU 3.0 
+     * @stable ICU 3.0
      */
     public static final int SEGMENT_STARTER = 41;
 
@@ -546,100 +548,101 @@ public interface UProperty
     public static final int EMOJI_MODIFIER_BASE=60;
 
     /**
-     * One more than the last constant for binary Unicode properties. 
-     * @stable ICU 2.6
+     * One more than the last constant for binary Unicode properties.
+     * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
      */
+    @Deprecated
     public static final int BINARY_LIMIT = 61;
 
-    /** 
+    /**
      * Enumerated property Bidi_Class.
-     * Same as UCharacter.getDirection(int), returns UCharacterDirection values. 
-     * @stable ICU 2.4 
+     * Same as UCharacter.getDirection(int), returns UCharacterDirection values.
+     * @stable ICU 2.4
      */
     public static final int BIDI_CLASS = 0x1000;
 
-    /** 
-     * First constant for enumerated/integer Unicode properties. 
+    /**
+     * First constant for enumerated/integer Unicode properties.
      * @stable ICU 2.4
      */
     public static final int INT_START = BIDI_CLASS;
 
-    /** 
+    /**
      * Enumerated property Block.
-     * Same as UCharacter.UnicodeBlock.of(int), returns UCharacter.UnicodeBlock 
-     * values. 
-     * @stable ICU 2.4 
+     * Same as UCharacter.UnicodeBlock.of(int), returns UCharacter.UnicodeBlock
+     * values.
+     * @stable ICU 2.4
      */
     public static final int BLOCK = 0x1001;
 
-    /** 
+    /**
      * Enumerated property Canonical_Combining_Class.
-     * Same as UCharacter.getCombiningClass(int), returns 8-bit numeric values. 
-     * @stable ICU 2.4 
+     * Same as UCharacter.getCombiningClass(int), returns 8-bit numeric values.
+     * @stable ICU 2.4
      */
     public static final int CANONICAL_COMBINING_CLASS = 0x1002;
 
-    /** 
+    /**
      * Enumerated property Decomposition_Type.
-     * Returns UCharacter.DecompositionType values. 
+     * Returns UCharacter.DecompositionType values.
      * @stable ICU 2.4
      */
     public static final int DECOMPOSITION_TYPE = 0x1003;
 
-    /** 
+    /**
      * Enumerated property East_Asian_Width.
      * See http://www.unicode.org/reports/tr11/
-     * Returns UCharacter.EastAsianWidth values. 
-     * @stable ICU 2.4 
+     * Returns UCharacter.EastAsianWidth values.
+     * @stable ICU 2.4
      */
     public static final int EAST_ASIAN_WIDTH = 0x1004;
 
-    /** 
+    /**
      * Enumerated property General_Category.
-     * Same as UCharacter.getType(int), returns UCharacterCategory values. 
-     * @stable ICU 2.4 
+     * Same as UCharacter.getType(int), returns UCharacterCategory values.
+     * @stable ICU 2.4
      */
     public static final int GENERAL_CATEGORY = 0x1005;
 
-    /** 
+    /**
      * Enumerated property Joining_Group.
-     * Returns UCharacter.JoiningGroup values. 
-     * @stable ICU 2.4 
+     * Returns UCharacter.JoiningGroup values.
+     * @stable ICU 2.4
      */
     public static final int JOINING_GROUP = 0x1006;
 
-    /** 
+    /**
      * Enumerated property Joining_Type.
-     * Returns UCharacter.JoiningType values. 
-     * @stable ICU 2.4 
+     * Returns UCharacter.JoiningType values.
+     * @stable ICU 2.4
      */
     public static final int JOINING_TYPE = 0x1007;
 
-    /** 
+    /**
      * Enumerated property Line_Break.
-     * Returns UCharacter.LineBreak values. 
-     * @stable ICU 2.4 
+     * Returns UCharacter.LineBreak values.
+     * @stable ICU 2.4
      */
     public static final int LINE_BREAK = 0x1008;
 
-    /** 
+    /**
      * Enumerated property Numeric_Type.
-     * Returns UCharacter.NumericType values. 
-     * @stable ICU 2.4 
+     * Returns UCharacter.NumericType values.
+     * @stable ICU 2.4
      */
     public static final int NUMERIC_TYPE = 0x1009;
 
-    /** 
+    /**
      * Enumerated property Script.
-     * Same as UScript.getScript(int), returns UScript values. 
-     * @stable ICU 2.4 
+     * Same as UScript.getScript(int), returns UScript values.
+     * @stable ICU 2.4
      */
     public static final int SCRIPT = 0x100A;
-    
-    /** 
+
+    /**
      * Enumerated property Hangul_Syllable_Type, new in Unicode 4.
-     * Returns UCharacter.HangulSyllableType values. 
-     * @stable ICU 2.6 
+     * Returns UCharacter.HangulSyllableType values.
+     * @stable ICU 2.6
      */
     public static final int HANGUL_SYLLABLE_TYPE = 0x100B;
 
@@ -729,36 +732,37 @@ public interface UProperty
      */
     public static final int BIDI_PAIRED_BRACKET_TYPE = 0x1015;
 
-    /** 
-     * One more than the last constant for enumerated/integer Unicode 
-     * properties. 
-     * @stable ICU 2.4 
+    /**
+     * One more than the last constant for enumerated/integer Unicode properties.
+     * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
      */
+    @Deprecated
     public static final int INT_LIMIT = 0x1016;
 
-    /** 
+    /**
      * Bitmask property General_Category_Mask.
      * This is the General_Category property returned as a bit mask.
      * When used in UCharacter.getIntPropertyValue(c),
-     * returns bit masks for UCharacterCategory values where exactly one bit is set. 
-     * When used with UCharacter.getPropertyValueName() and UCharacter.getPropertyValueEnum(), 
-     * a multi-bit mask is used for sets of categories like "Letters". 
+     * returns bit masks for UCharacterCategory values where exactly one bit is set.
+     * When used with UCharacter.getPropertyValueName() and UCharacter.getPropertyValueEnum(),
+     * a multi-bit mask is used for sets of categories like "Letters".
      * @stable ICU 2.4
-     */ 
-    public static final int GENERAL_CATEGORY_MASK = 0x2000; 
+     */
+    public static final int GENERAL_CATEGORY_MASK = 0x2000;
 
-    /** 
-     * First constant for bit-mask Unicode properties. 
+    /**
+     * First constant for bit-mask Unicode properties.
      * @stable ICU 2.4
      */
     public static final int MASK_START = GENERAL_CATEGORY_MASK;
 
-    /** 
-     * One more than the last constant for bit-mask Unicode properties. 
-     * @stable ICU 2.4
-     */ 
-    public static final int MASK_LIMIT = 0x2001; 
-    
+    /**
+     * One more than the last constant for bit-mask Unicode properties.
+     * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
+     */
+    @Deprecated
+    public static final int MASK_LIMIT = 0x2001;
+
     /**
      * Double property Numeric_Value.
      * Corresponds to UCharacter.getUnicodeNumericValue(int).
@@ -774,8 +778,9 @@ public interface UProperty
 
     /**
      * One more than the last constant for double Unicode properties.
-     * @stable ICU 2.4
+     * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
      */
+    @Deprecated
     public static final int DOUBLE_LIMIT = 0x3001;
 
     /**
@@ -888,8 +893,9 @@ public interface UProperty
 
     /**
      * One more than the last constant for string Unicode properties.
-     * @stable ICU 2.4
+     * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
      */
+    @Deprecated
     public static final int STRING_LIMIT = 0x400E;
 
     /**
@@ -907,8 +913,9 @@ public interface UProperty
     public static final int OTHER_PROPERTY_START=SCRIPT_EXTENSIONS;
     /**
      * One more than the last constant for Unicode properties with unusual value types.
-     * @stable ICU 4.6
+     * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
      */
+    @Deprecated
     public static final int OTHER_PROPERTY_LIMIT=0x7001;
 
     /**
@@ -943,8 +950,9 @@ public interface UProperty
         /**
          * The number of predefined property name choices.  Individual
          * properties or values may have more than COUNT aliases.
-         * @stable ICU 2.4
+         * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
          */
+        @Deprecated
         static final int COUNT = 2;
     }
 }
diff --git a/app/src/main/java/com/ibm/icu/lang/UScript.java b/icu4j/src/main/java/com/ibm/icu/lang/UScript.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/lang/UScript.java
rename to icu4j/src/main/java/com/ibm/icu/lang/UScript.java
index 962664f..1e4107b 100644
--- a/app/src/main/java/com/ibm/icu/lang/UScript.java
+++ b/icu4j/src/main/java/com/ibm/icu/lang/UScript.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
  *******************************************************************************
  * Copyright (C) 2001-2016 International Business Machines Corporation and
@@ -23,13 +25,13 @@ import com.ibm.icu.util.ULocale;
  * See UAX #24 Unicode Script Property (http://www.unicode.org/reports/tr24/)
  * and http://www.unicode.org/Public/UCD/latest/ucd/PropertyValueAliases.txt .
  *
- * <p>Starting with ICU 3.6, constants for most ISO 15924 script codes
+ * <p>In addition, constants for many ISO 15924 script codes
  * are included, for use with language tags, CLDR data, and similar.
  * Some of those codes are not used in the Unicode Character Database (UCD).
  * For example, there are no characters that have a UCD script property value of
  * Hans or Hant. All Han ideographs have the Hani script property value in Unicode.
  *
- * <p>Private-use codes Qaaa..Qabx are not included.
+ * <p>Private-use codes Qaaa..Qabx are not included, except as used in the UCD or in CLDR.
  *
  * <p>Starting with ICU 55, script codes are only added when their scripts
  * have been or will certainly be encoded in Unicode,
@@ -283,60 +285,60 @@ public final class UScript {
     public static final int TAGBANWA     = 45;  /* Tagb */
     /**
      * Braille
-     * Script in Unicode 4 
-     * @stable ICU 2.6 
-     * 
-     */ 
+     * Script in Unicode 4
+     * @stable ICU 2.6
+     *
+     */
     public static final int BRAILLE      = 46;  /* Brai */
     /**
      * Cypriot
-     * Script in Unicode 4 
-     * @stable ICU 2.6 
-     * 
-     */  
-    public static final int CYPRIOT              = 47;  /* Cprt */ 
+     * Script in Unicode 4
+     * @stable ICU 2.6
+     *
+     */
+    public static final int CYPRIOT              = 47;  /* Cprt */
     /**
      * Limbu
-     * Script in Unicode 4 
-     * @stable ICU 2.6 
-     * 
-     */       
-    public static final int LIMBU                = 48;  /* Limb */ 
+     * Script in Unicode 4
+     * @stable ICU 2.6
+     *
+     */
+    public static final int LIMBU                = 48;  /* Limb */
     /**
      * Linear B
-     * Script in Unicode 4 
-     * @stable ICU 2.6 
-     * 
-     */ 
-    public static final int LINEAR_B     = 49;  /* Linb */ 
+     * Script in Unicode 4
+     * @stable ICU 2.6
+     *
+     */
+    public static final int LINEAR_B     = 49;  /* Linb */
     /**
      * Osmanya
-     * Script in Unicode 4 
-     * @stable ICU 2.6 
-     * 
-     */ 
-    public static final int OSMANYA              = 50;  /* Osma */ 
+     * Script in Unicode 4
+     * @stable ICU 2.6
+     *
+     */
+    public static final int OSMANYA              = 50;  /* Osma */
     /**
      * Shavian
-     * Script in Unicode 4 
-     * @stable ICU 2.6 
-     * 
-     */ 
-    public static final int SHAVIAN              = 51;  /* Shaw */ 
+     * Script in Unicode 4
+     * @stable ICU 2.6
+     *
+     */
+    public static final int SHAVIAN              = 51;  /* Shaw */
     /**
      * Tai Le
-     * Script in Unicode 4 
-     * @stable ICU 2.6 
-     * 
-     */ 
-    public static final int TAI_LE               = 52;  /* Tale */ 
+     * Script in Unicode 4
+     * @stable ICU 2.6
+     *
+     */
+    public static final int TAI_LE               = 52;  /* Tale */
     /**
      * Ugaritic
-     * Script in Unicode 4 
-     * @stable ICU 2.6 
-     * 
-     */ 
-    public static final int UGARITIC     = 53;  /* Ugar */ 
+     * Script in Unicode 4
+     * @stable ICU 2.6
+     *
+     */
+    public static final int UGARITIC     = 53;  /* Ugar */
     /**
      * Script in Unicode 4.0.1
      * @stable ICU 3.0
@@ -609,7 +611,7 @@ public final class UScript {
     /**
      * ISO 15924 script code
      * @stable ICU 3.8
-     */ 
+     */
     public static final int CARIAN                        = 104;/* Cari */
     /**
      * ISO 15924 script code
@@ -954,17 +956,55 @@ public final class UScript {
     public static final int SIDDHAM = 166; /* Sidd */
 
     /**
-     * <p>One higher than the last script code constant.
-     * This value increases as constants for script codes are added.
-     *
-     * <p>There are constants for Unicode 7 script property values.
-     * There are constants for ISO 15924 script codes assigned on or before 2013-10-12.
-     * There are no constants for private use codes from Qaaa - Qabx
-     * except as used in the UCD.
+     * ISO 15924 script code
+     * @stable ICU 58
+     */
+    public static final int ADLAM = 167; /* Adlm */
+    /**
+     * ISO 15924 script code
+     * @stable ICU 58
+     */
+    public static final int BHAIKSUKI = 168; /* Bhks */
+    /**
+     * ISO 15924 script code
+     * @stable ICU 58
+     */
+    public static final int MARCHEN = 169; /* Marc */
+    /**
+     * ISO 15924 script code
+     * @stable ICU 58
+     */
+    public static final int NEWA = 170; /* Newa */
+    /**
+     * ISO 15924 script code
+     * @stable ICU 58
+     */
+    public static final int OSAGE = 171; /* Osge */
+
+    /**
+     * ISO 15924 script code
+     * @stable ICU 58
+     */
+    public static final int HAN_WITH_BOPOMOFO = 172; /* Hanb */
+    /**
+     * ISO 15924 script code
+     * @stable ICU 58
+     */
+    public static final int JAMO = 173; /* Jamo */
+    /**
+     * ISO 15924 script code
+     * @stable ICU 58
+     */
+    public static final int SYMBOLS_EMOJI = 174; /* Zsye */
+
+    /**
+     * One more than the highest normal UScript code.
+     * The highest value is available via UCharacter.getIntPropertyMaxValue(UProperty.SCRIPT).
      *
-     * @stable ICU 2.4
+     * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
      */
-    public static final int CODE_LIMIT   = 167;
+    @Deprecated
+    public static final int CODE_LIMIT   = 175;
 
     private static int[] getCodesFromLocale(ULocale locale) {
         // Multi-script languages, equivalent to the LocaleScript data
@@ -1110,8 +1150,6 @@ public final class UScript {
      * <p>Some characters are commonly used in multiple scripts.
      * For more information, see UAX #24: http://www.unicode.org/reports/tr24/.
      *
-     * <p>The Script_Extensions property is provisional. It may be modified or removed
-     * in future versions of the Unicode Standard, and thus in ICU.
      * @param c code point
      * @param sc script code
      * @return true if sc is in Script_Extensions(c)
@@ -1158,8 +1196,6 @@ public final class UScript {
      * <p>Some characters are commonly used in multiple scripts.
      * For more information, see UAX #24: http://www.unicode.org/reports/tr24/.
      *
-     * <p>The Script_Extensions property is provisional. It may be modified or removed
-     * in future versions of the Unicode Standard, and thus in ICU.
      * @param c code point
      * @param set set of script code integers; will be cleared, then bits are set
      *            corresponding to c's Script_Extensions
@@ -1277,7 +1313,7 @@ public final class UScript {
             0x1826 | ASPIRATIONAL,  // Mong
             0x1000 | RECOMMENDED | LB_LETTERS,  // Mymr
             0x168F | EXCLUSION,  // Ogam
-            0x10308 | EXCLUSION,  // Ital
+            0x10300 | EXCLUSION,  // Ital
             0x0B15 | RECOMMENDED,  // Orya
             0x16A0 | EXCLUSION,  // Runr
             0x0D85 | RECOMMENDED,  // Sinh
@@ -1307,7 +1343,7 @@ public final class UScript {
             0x10A00 | EXCLUSION | RTL,  // Khar
             0xA800 | LIMITED_USE,  // Sylo
             0x1980 | LIMITED_USE | LB_LETTERS,  // Talu
-            0x2D5E | ASPIRATIONAL,  // Tfng
+            0x2D30 | ASPIRATIONAL,  // Tfng
             0x103A0 | EXCLUSION,  // Xpeo
             0x1B05 | LIMITED_USE,  // Bali
             0x1BC0 | LIMITED_USE,  // Batk
@@ -1334,7 +1370,7 @@ public final class UScript {
             0x0840 | LIMITED_USE | RTL,  // Mand
             0,
             0x10980 | EXCLUSION | RTL,  // Mero
-            0x07D8 | LIMITED_USE | RTL,  // Nkoo
+            0x07CA | LIMITED_USE | RTL,  // Nkoo
             0x10C00 | EXCLUSION | RTL,  // Orkh
             0x1036B | EXCLUSION,  // Perm
             0xA840 | EXCLUSION,  // Phag
@@ -1351,7 +1387,7 @@ public final class UScript {
             0x12000 | EXCLUSION,  // Xsux
             0,
             0xFDD0 | UNKNOWN,  // Zzzz
-            0x102B7 | EXCLUSION,  // Cari
+            0x102A0 | EXCLUSION,  // Cari
             0x304B | RECOMMENDED | LB_LETTERS,  // Jpan
             0x1A20 | LIMITED_USE | LB_LETTERS,  // Lana
             0x10280 | EXCLUSION,  // Lyci
@@ -1368,7 +1404,7 @@ public final class UScript {
             0x11103 | LIMITED_USE,  // Cakm
             0xAC00 | RECOMMENDED,  // Kore
             0x11083 | EXCLUSION,  // Kthi
-            0x10AC1 | EXCLUSION | RTL,  // Mani
+            0x10AD8 | EXCLUSION | RTL,  // Mani
             0x10B60 | EXCLUSION | RTL,  // Phli
             0x10B8F | EXCLUSION | RTL,  // Phlp
             0,
@@ -1378,7 +1414,7 @@ public final class UScript {
             0,
             0,
             0xA6A0 | LIMITED_USE,  // Bamu
-            0xA4E8 | LIMITED_USE,  // Lisu
+            0xA4D0 | LIMITED_USE,  // Lisu
             0,
             0x10A60 | EXCLUSION | RTL,  // Sarb
             0x16AE6 | EXCLUSION,  // Bass
@@ -1401,7 +1437,7 @@ public final class UScript {
             0x11183 | EXCLUSION,  // Shrd
             0x110D0 | EXCLUSION,  // Sora
             0x11680 | EXCLUSION,  // Takr
-            0,
+            0x18229 | EXCLUSION | LB_LETTERS,  // Tang
             0,
             0x14400 | EXCLUSION,  // Hluw
             0x11208 | EXCLUSION,  // Khoj
@@ -1414,6 +1450,14 @@ public final class UScript {
             0x1128F | EXCLUSION,  // Mult
             0x11AC0 | EXCLUSION,  // Pauc
             0x1158E | EXCLUSION,  // Sidd
+            0x1E909 | LIMITED_USE | RTL | CASED,  // Adlm
+            0x11C0E | EXCLUSION,  // Bhks
+            0x11C72 | EXCLUSION,  // Marc
+            0x11412 | LIMITED_USE,  // Newa
+            0x104B5 | LIMITED_USE | CASED,  // Osge
+            0x5B57 | RECOMMENDED | LB_LETTERS,  // Hanb
+            0x1112 | RECOMMENDED,  // Jamo
+            0,
             // End copy-paste from parsescriptmetadata.py
         };
 
diff --git a/app/src/main/java/com/ibm/icu/lang/UScriptRun.java b/icu4j/src/main/java/com/ibm/icu/lang/UScriptRun.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/lang/UScriptRun.java
rename to icu4j/src/main/java/com/ibm/icu/lang/UScriptRun.java
index 761a467..6ed5728 100644
--- a/app/src/main/java/com/ibm/icu/lang/UScriptRun.java
+++ b/icu4j/src/main/java/com/ibm/icu/lang/UScriptRun.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  *
diff --git a/app/src/main/java/com/ibm/icu/math/BigDecimal.java b/icu4j/src/main/java/com/ibm/icu/math/BigDecimal.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/math/BigDecimal.java
rename to icu4j/src/main/java/com/ibm/icu/math/BigDecimal.java
index 652fe91..b329300 100644
--- a/app/src/main/java/com/ibm/icu/math/BigDecimal.java
+++ b/icu4j/src/main/java/com/ibm/icu/math/BigDecimal.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /* Generated from 'BigDecimal.nrx' 8 Sep 2000 11:10:50 [v2.00] */
 /* Options: Binary Comments Crossref Format Java Logo Strictargs Strictcase Trace2 Verbose3 */
 package com.ibm.icu.math;
@@ -123,7 +125,7 @@ import com.ibm.icu.lang.UCharacter;
  * The floating point arithmetic provided by this class is defined by the ANSI X3.274-1996 standard, and is also
  * documented at <code>http://www2.hursley.ibm.com/decimal</code> <br>
  * <i>[This URL will change.]</i>
- * 
+ *
  * <h3>Operator methods</h3>
  * <p>
  * Operations on <code>BigDecimal</code> numbers are controlled by a {@link MathContext} object, which provides the
@@ -213,7 +215,7 @@ import com.ibm.icu.lang.UCharacter;
  * <p>
  * The names of methods in this class follow the conventions established by <code>java.lang.Number</code>,
  * <code>java.math.BigInteger</code>, and <code>java.math.BigDecimal</code> in Java 1.1 and Java 1.2.
- * 
+ *
  * @see MathContext
  * @author Mike Cowlishaw
  * @stable ICU 2.0
@@ -226,7 +228,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
     /* properties constant public */// useful to others
     /**
      * The <code>BigDecimal</code> constant "0".
-     * 
+     *
      * @see #ONE
      * @see #TEN
      * @stable ICU 2.0
@@ -238,7 +240,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
 
     /**
      * The <code>BigDecimal</code> constant "1".
-     * 
+     *
      * @see #TEN
      * @see #ZERO
      * @stable ICU 2.0
@@ -250,7 +252,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
 
     /**
      * The <code>BigDecimal</code> constant "10".
-     * 
+     *
      * @see #ONE
      * @see #ZERO
      * @stable ICU 2.0
@@ -260,7 +262,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
     // the rounding modes (copied here for upwards compatibility)
     /**
      * Rounding mode to round to a more positive number.
-     * 
+     *
      * @see MathContext#ROUND_CEILING
      * @stable ICU 2.0
      */
@@ -268,7 +270,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
 
     /**
      * Rounding mode to round towards zero.
-     * 
+     *
      * @see MathContext#ROUND_DOWN
      * @stable ICU 2.0
      */
@@ -276,7 +278,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
 
     /**
      * Rounding mode to round to a more negative number.
-     * 
+     *
      * @see MathContext#ROUND_FLOOR
      * @stable ICU 2.0
      */
@@ -284,7 +286,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
 
     /**
      * Rounding mode to round to nearest neighbor, where an equidistant value is rounded down.
-     * 
+     *
      * @see MathContext#ROUND_HALF_DOWN
      * @stable ICU 2.0
      */
@@ -292,7 +294,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
 
     /**
      * Rounding mode to round to nearest neighbor, where an equidistant value is rounded to the nearest even neighbor.
-     * 
+     *
      * @see MathContext#ROUND_HALF_EVEN
      * @stable ICU 2.0
      */
@@ -300,7 +302,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
 
     /**
      * Rounding mode to round to nearest neighbor, where an equidistant value is rounded up.
-     * 
+     *
      * @see MathContext#ROUND_HALF_UP
      * @stable ICU 2.0
      */
@@ -308,7 +310,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
 
     /**
      * Rounding mode to assert that no rounding is necessary.
-     * 
+     *
      * @see MathContext#ROUND_UNNECESSARY
      * @stable ICU 2.0
      */
@@ -316,7 +318,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
 
     /**
      * Rounding mode to round away from zero.
-     * 
+     *
      * @see MathContext#ROUND_UP
      * @stable ICU 2.0
      */
@@ -356,7 +358,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <ul>
      * <li>ispos -- the number is positive <li>iszero -- the number is zero <li>isneg -- the number is negative
      * </ul>
-     * 
+     *
      * @serial
      */
     private byte ind; // assumed undefined
@@ -373,7 +375,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * This property is an optimization; it allows us to defer number layout until it is actually needed as a string,
      * hence avoiding unnecessary formatting.
-     * 
+     *
      * @serial
      */
     private byte form = (byte) com.ibm.icu.math.MathContext.PLAIN; // assumed PLAIN
@@ -389,7 +391,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * If the first byte is 0 then the value of the number is zero (and mant.length=1, except when constructed from a
      * plain number, for example, 0.000).
-     * 
+     *
      * @serial
      */
     private byte mant[]; // assumed null
@@ -398,9 +400,9 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * The exponent.
      * <p>
      * For fixed point arithmetic, scale is <code>-exp</code>, and can apply to zero.
-     * 
+     *
      * Note that this property can have a value less than MinExp when the mantissa has more than one digit.
-     * 
+     *
      * @serial
      */
     private int exp;
@@ -420,7 +422,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * <i>(Note: this constructor is provided only in the <code>com.ibm.icu.math</code> version of the BigDecimal class.
      * It would not be present in a <code>java.math</code> version.)</i>
-     * 
+     *
      * @param bd The <code>BigDecimal</code> to be translated.
      * @stable ICU 2.0
      */
@@ -439,7 +441,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * The <code>BigDecimal</code> will contain only decimal digits, prefixed with a leading minus sign (hyphen) if the
      * <code>BigInteger</code> is negative. A leading zero will be present only if the <code>BigInteger</code> is zero.
-     * 
+     *
      * @param bi The <code>BigInteger</code> to be converted.
      * @stable ICU 2.0
      */
@@ -462,7 +464,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * The <code>BigDecimal</code> will contain only decimal digits, (with an embedded decimal point followed by <code>
      * scale</code> decimal digits if the scale is positive), prefixed with a leading minus sign (hyphen) if the <code>
      * BigInteger</code> is negative. A leading zero will be present only if the <code>BigInteger</code> is zero.
-     * 
+     *
      * @param bi The <code>BigInteger</code> to be converted.
      * @param scale The <code>int</code> specifying the scale.
      * @throws NumberFormatException If the scale is negative.
@@ -486,7 +488,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * Using this constructor is faster than using the <code>BigDecimal(String)</code> constructor if the string is
      * already available in character array form.
-     * 
+     *
      * @param inchars The <code>char[]</code> array containing the number to be converted.
      * @throws NumberFormatException If the parameter is not a valid number.
      * @stable ICU 2.0
@@ -506,7 +508,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * Using this constructor is faster than using the <code>BigDecimal(String)</code> constructor if the string is
      * already available within a character array.
-     * 
+     *
      * @param inchars The <code>char[]</code> array containing the number to be converted.
      * @param offset The <code>int</code> offset into the array of the start of the number to be converted.
      * @param length The <code>int</code> length of the number.
@@ -618,7 +620,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
                             if (dvalue < 0)
                                 bad(inchars); // not base 10
                         } else
-                            dvalue = ((int) (sj)) - ((int) ('0'));
+                            dvalue = ((sj)) - (('0'));
                         exp = (exp * 10) + dvalue;
                     }
                 }/* j */
@@ -674,7 +676,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
                             j++; // at dot
                         sj = inchars[j];
                         if (sj <= '9')
-                            mant[i] = (byte) (((int) (sj)) - ((int) ('0')));/* easy */
+                            mant[i] = (byte) (((sj)) - (('0')));/* easy */
                         else {
                             dvalue = UCharacter.digit(sj, 10);
                             if (dvalue < 0)
@@ -694,7 +696,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
                     for (; $5 > 0; $5--, i++) {
                         if (i == dotoff)
                             j++;
-                        mant[i] = (byte) (((int) (inchars[j])) - ((int) ('0')));
+                        mant[i] = (byte) (((inchars[j])) - (('0')));
                         j++;
                     }
                 }/* i */
@@ -741,7 +743,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * </code> to a <code>String</code> using the <code>Double.toString()</code> method and then using the
      * {@link #BigDecimal(java.lang.String)} constructor. To get that result, use the static {@link #valueOf(double)}
      * method to construct a <code>BigDecimal</code> from a <code>double</code>.
-     * 
+     *
      * @param num The <code>double</code> to be converted.
      * @throws NumberFormatException If the parameter is infinite or not a number.
      * @stable ICU 2.0
@@ -762,7 +764,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * Constructs a <code>BigDecimal</code> which is the exact decimal representation of the 32-bit signed binary
      * integer parameter. The <code>BigDecimal</code> will contain only decimal digits, prefixed with a leading minus
      * sign (hyphen) if the parameter is negative. A leading zero will be present only if the parameter is zero.
-     * 
+     *
      * @param num The <code>int</code> to be converted.
      * @stable ICU 2.0
      */
@@ -841,7 +843,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * Constructs a <code>BigDecimal</code> which is the exact decimal representation of the 64-bit signed binary
      * integer parameter. The <code>BigDecimal</code> will contain only decimal digits, prefixed with a leading minus
      * sign (hyphen) if the parameter is negative. A leading zero will be present only if the parameter is zero.
-     * 
+     *
      * @param num The <code>long</code> to be converted.
      * @stable ICU 2.0
      */
@@ -894,13 +896,13 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * decimal point, and exponential notation may be used. They follow conventional syntax, and may not contain blanks.
      * <p>
      * Some valid strings from which a <code>BigDecimal</code> might be constructed are:
-     * 
+     *
      * <pre>
-     * 
+     *
      * "0" -- Zero "12" -- A whole number "-76" -- A signed whole number "12.70" -- Some decimal places "+0.003" -- Plus
      * sign is allowed "17." -- The same as 17 ".5" -- The same as 0.5 "4E+9" -- Exponential notation "0.73e-7" --
      * Exponential notation
-     * 
+     *
      * </pre>
      * <p>
      * (Exponential notation means that the number includes an optional sign and a power of ten following an
@@ -918,7 +920,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * Any digits in the parameter must be decimal; that is, <code>Character.digit(c, 10)</code> (where <code>c</code>
      * is the character in question) would not return -1.
-     * 
+     *
      * @param string The <code>String</code> to be converted.
      * @throws NumberFormatException If the parameter is not a valid number.
      * @stable ICU 2.0
@@ -946,7 +948,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * The same as {@link #abs(MathContext)}, where the context is <code>new MathContext(0, MathContext.PLAIN)</code>.
      * <p>
      * The length of the decimal part (the scale) of the result will be <code>this.scale()</code>
-     * 
+     *
      * @return A <code>BigDecimal</code> whose value is the absolute value of this <code>BigDecimal</code>.
      * @stable ICU 2.0
      */
@@ -961,7 +963,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * If the current object is zero or positive, then the same result as invoking the {@link #plus(MathContext)} method
      * with the same parameter is returned. Otherwise, the same result as invoking the {@link #negate(MathContext)}
      * method with the same parameter is returned.
-     * 
+     *
      * @param set The <code>MathContext</code> arithmetic settings.
      * @return A <code>BigDecimal</code> whose value is the absolute value of this <code>BigDecimal</code>.
      * @stable ICU 2.0
@@ -980,7 +982,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * context is <code>new MathContext(0, MathContext.PLAIN)</code>.
      * <p>
      * The length of the decimal part (the scale) of the result will be the maximum of the scales of the two operands.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the addition.
      * @return A <code>BigDecimal</code> whose value is <code>this+rhs</code>, using fixed point arithmetic.
      * @stable ICU 2.0
@@ -995,7 +997,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * Implements the addition (<b><code>+</code></b>) operator (as defined in the decimal documentation, see
      * {@link BigDecimal class header}), and returns the result as a <code>BigDecimal</code> object.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the addition.
      * @param set The <code>MathContext</code> arithmetic settings.
      * @return A <code>BigDecimal</code> whose value is <code>this+rhs</code>.
@@ -1216,13 +1218,14 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * The same as {@link #compareTo(BigDecimal, MathContext)}, where the <code>BigDecimal</code> is <code>rhs</code>,
      * and the context is <code>new MathContext(0, MathContext.PLAIN)</code>.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the comparison.
      * @return An <code>int</code> whose value is -1, 0, or 1 as <code>this</code> is numerically less than, equal to,
      *         or greater than <code>rhs</code>.
      * @stable ICU 2.0
      */
 
+    @Override
     public int compareTo(com.ibm.icu.math.BigDecimal rhs) {
         return this.compareTo(rhs, plainMC);
     }
@@ -1247,7 +1250,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * </table>
      * <p>
      * A {@link #compareTo(BigDecimal)} method is also provided.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the comparison.
      * @param set The <code>MathContext</code> arithmetic settings.
      * @return An <code>int</code> whose value is -1, 0, or 1 as <code>this</code> is numerically less than, equal to,
@@ -1306,10 +1309,10 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * The same as {@link #divide(BigDecimal, int)}, where the <code>BigDecimal</code> is <code>rhs</code>, and the
      * rounding mode is {@link MathContext#ROUND_HALF_UP}.
-     * 
+     *
      * The length of the decimal part (the scale) of the result will be the same as the scale of the current object, if
      * the latter were formatted without exponential notation.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the division.
      * @return A plain <code>BigDecimal</code> whose value is <code>this/rhs</code>, using fixed point arithmetic.
      * @throws ArithmeticException If <code>rhs</code> is zero.
@@ -1330,7 +1333,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * The length of the decimal part (the scale) of the result will therefore be the same as the scale of the current
      * object, if the latter were formatted without exponential notation.
      * <p>
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the division.
      * @param round The <code>int</code> rounding mode to be used for the division (see the {@link MathContext} class).
      * @return A plain <code>BigDecimal</code> whose value is <code>this/rhs</code>, using fixed point arithmetic and
@@ -1359,7 +1362,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * The length of the decimal part (the scale) of the result will be the same as the scale of the current object, if
      * the latter were formatted without exponential notation.
      * <p>
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the division.
      * @param scale The <code>int</code> scale to be used for the result.
      * @param round The <code>int</code> rounding mode to be used for the division (see the {@link MathContext} class).
@@ -1386,7 +1389,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * Implements the division (<b><code>/</code></b>) operator (as defined in the decimal documentation, see
      * {@link BigDecimal class header}), and returns the result as a <code>BigDecimal</code> object.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the division.
      * @param set The <code>MathContext</code> arithmetic settings.
      * @return A <code>BigDecimal</code> whose value is <code>this/rhs</code>.
@@ -1403,7 +1406,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * The same as {@link #divideInteger(BigDecimal, MathContext)}, where the <code>BigDecimal</code> is <code>rhs
      * </code>, and the context is <code>new MathContext(0, MathContext.PLAIN)</code>.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the integer division.
      * @return A <code>BigDecimal</code> whose value is the integer part of <code>this/rhs</code>.
      * @throws ArithmeticException if <code>rhs</code> is zero.
@@ -1420,7 +1423,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * Implements the integer division operator (as defined in the decimal documentation, see {@link BigDecimal class
      * header}), and returns the result as a <code>BigDecimal</code> object.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the integer division.
      * @param set The <code>MathContext</code> arithmetic settings.
      * @return A <code>BigDecimal</code> whose value is the integer part of <code>this/rhs</code>.
@@ -1439,7 +1442,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * The same as {@link #max(BigDecimal, MathContext)}, where the <code>BigDecimal</code> is <code>rhs</code>, and the
      * context is <code>new MathContext(0, MathContext.PLAIN)</code>.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the comparison.
      * @return A <code>BigDecimal</code> whose value is the maximum of <code>this</code> and <code>rhs</code>.
      * @stable ICU 2.0
@@ -1459,7 +1462,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * (using the same <code>MathContext</code> parameter) is returned. Otherwise, the result of calling the
      * {@link #plus(MathContext)} method on the first parameter object (using the same <code>MathContext</code>
      * parameter) is returned.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the comparison.
      * @param set The <code>MathContext</code> arithmetic settings.
      * @return A <code>BigDecimal</code> whose value is the maximum of <code>this</code> and <code>rhs</code>.
@@ -1478,7 +1481,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * The same as {@link #min(BigDecimal, MathContext)}, where the <code>BigDecimal</code> is <code>rhs</code>, and the
      * context is <code>new MathContext(0, MathContext.PLAIN)</code>.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the comparison.
      * @return A <code>BigDecimal</code> whose value is the minimum of <code>this</code> and <code>rhs</code>.
      * @stable ICU 2.0
@@ -1498,7 +1501,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * (using the same <code>MathContext</code> parameter) is returned. Otherwise, the result of calling the
      * {@link #plus(MathContext)} method on the first parameter object (using the same <code>MathContext</code>
      * parameter) is returned.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the comparison.
      * @param set The <code>MathContext</code> arithmetic settings.
      * @return A <code>BigDecimal</code> whose value is the minimum of <code>this</code> and <code>rhs</code>.
@@ -1520,7 +1523,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * The length of the decimal part (the scale) of the result will be the sum of the scales of the operands, if they
      * were formatted without exponential notation.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the multiplication.
      * @return A <code>BigDecimal</code> whose value is <code>this*rhs</code>, using fixed point arithmetic.
      * @stable ICU 2.0
@@ -1535,7 +1538,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * Implements the multiplication (<b><code>&#42;</code></b>) operator (as defined in the decimal documentation, see
      * {@link BigDecimal class header}), and returns the result as a <code>BigDecimal</code> object.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the multiplication.
      * @param set The <code>MathContext</code> arithmetic settings.
      * @return A <code>BigDecimal</code> whose value is <code>this*rhs</code>.
@@ -1636,8 +1639,8 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * .
      * <p>
      * The length of the decimal part (the scale) of the result will be be <code>this.scale()</code>
-     * 
-     * 
+     *
+     *
      * @return A <code>BigDecimal</code> whose value is <code>-this</code>.
      * @stable ICU 2.0
      */
@@ -1651,7 +1654,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * Implements the negation (Prefix <b><code>-</code></b>) operator (as defined in the decimal documentation, see
      * {@link BigDecimal class header}), and returns the result as a <code>BigDecimal</code> object.
-     * 
+     *
      * @param set The <code>MathContext</code> arithmetic settings.
      * @return A <code>BigDecimal</code> whose value is <code>-this</code>.
      * @stable ICU 2.0
@@ -1675,7 +1678,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * The same as {@link #plus(MathContext)}, where the context is <code>new MathContext(0, MathContext.PLAIN)</code>.
      * <p>
      * The length of the decimal part (the scale) of the result will be be <code>this.scale()</code>
-     * 
+     *
      * @return A <code>BigDecimal</code> whose value is <code>+this</code>.
      * @stable ICU 2.0
      */
@@ -1691,7 +1694,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * {@link BigDecimal class header}), and returns the result as a <code>BigDecimal</code> object.
      * <p>
      * This method is useful for rounding or otherwise applying a context to a decimal value.
-     * 
+     *
      * @param set The <code>MathContext</code> arithmetic settings.
      * @return A <code>BigDecimal</code> whose value is <code>+this</code>.
      * @stable ICU 2.0
@@ -1725,7 +1728,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * In addition, the power must not be negative, as no <code>MathContext</code> is used and so the result would then
      * always be 0.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the operation (the power).
      * @return A <code>BigDecimal</code> whose value is <code>this**rhs</code>, using fixed point arithmetic.
      * @throws ArithmeticException if <code>rhs</code> is out of range or is not a whole number.
@@ -1751,7 +1754,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * If the <code>digits</code> setting of the <code>MathContext</code> parameter is 0, the power must be zero or
      * positive.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the operation (the power).
      * @param set The <code>MathContext</code> arithmetic settings.
      * @return A <code>BigDecimal</code> whose value is <code>this**rhs</code>.
@@ -1831,7 +1834,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * and the context is <code>new MathContext(0, MathContext.PLAIN)</code>.
      * <p>
      * This is not the modulo operator -- the result may be negative.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the remainder operation.
      * @return A <code>BigDecimal</code> whose value is the remainder of <code>this/rhs</code>, using fixed point
      *         arithmetic.
@@ -1850,7 +1853,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * and returns the result as a <code>BigDecimal</code> object.
      * <p>
      * This is not the modulo operator -- the result may be negative.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the remainder operation.
      * @param set The <code>MathContext</code> arithmetic settings.
      * @return A <code>BigDecimal</code> whose value is the remainder of <code>this+rhs</code>.
@@ -1870,7 +1873,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * and the context is <code>new MathContext(0, MathContext.PLAIN)</code>.
      * <p>
      * The length of the decimal part (the scale) of the result will be the maximum of the scales of the two operands.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the subtraction.
      * @return A <code>BigDecimal</code> whose value is <code>this-rhs</code>, using fixed point arithmetic.
      * @stable ICU 2.0
@@ -1885,7 +1888,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * Implements the subtraction (<b><code>-</code></b>) operator (as defined in the decimal documentation, see
      * {@link BigDecimal class header}), and returns the result as a <code>BigDecimal</code> object.
-     * 
+     *
      * @param rhs The <code>BigDecimal</code> for the right hand side of the subtraction.
      * @param set The <code>MathContext</code> arithmetic settings.
      * @return A <code>BigDecimal</code> whose value is <code>this-rhs</code>.
@@ -1912,7 +1915,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * Converts this <code>BigDecimal</code> to a <code>byte</code>. If the <code>BigDecimal</code> has a non-zero
      * decimal part or is out of the possible range for a <code>byte</code> (8-bit signed integer) result then an <code>
      * ArithmeticException</code> is thrown.
-     * 
+     *
      * @return A <code>byte</code> equal in value to <code>this</code>.
      * @throws ArithmeticException if <code>this</code> has a non-zero decimal part, or will not fit in a <code>byte</code>.
      * @stable ICU 2.0
@@ -1934,11 +1937,12 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * The double produced is identical to result of expressing the <code>BigDecimal</code> as a <code>String</code> and
      * then converting it using the <code>Double(String)</code> constructor; this can result in values of <code>
      * Double.NEGATIVE_INFINITY</code> or <code>Double.POSITIVE_INFINITY</code>.
-     * 
+     *
      * @return A <code>double</code> corresponding to <code>this</code>.
      * @stable ICU 2.0
      */
 
+    @Override
     public double doubleValue() {
         // We go via a String [as does BigDecimal in JDK 1.2]
         // Next line could possibly raise NumberFormatException
@@ -1955,7 +1959,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * are identical (they have the same characters in the same sequence).
      * <p>
      * The {@link #compareTo(BigDecimal, MathContext)} method should be used for more general comparisons.
-     * 
+     *
      * @param obj The <code>Object</code> for the right hand side of the comparison.
      * @return A <code>boolean</code> whose value <i>true</i> if and only if the operands have identical string
      *         representations.
@@ -1965,6 +1969,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * @see #compareTo(BigDecimal, MathContext)
      */
 
+    @Override
     public boolean equals(java.lang.Object obj) {
         com.ibm.icu.math.BigDecimal rhs;
         int i = 0;
@@ -2016,11 +2021,12 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * The float produced is identical to result of expressing the <code>BigDecimal</code> as a <code>String</code> and
      * then converting it using the <code>Float(String)</code> constructor; this can result in values of <code>
      * Float.NEGATIVE_INFINITY</code> or <code>Float.POSITIVE_INFINITY</code>.
-     * 
+     *
      * @return A <code>float</code> corresponding to <code>this</code>.
      * @stable ICU 2.0
      */
 
+    @Override
     public float floatValue() {
         return java.lang.Float.valueOf(this.toString()).floatValue();
     }
@@ -2054,7 +2060,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * Other rounding methods, and the use of exponential notation, can be selected by using
      * {@link #format(int,int,int,int,int,int)}. Using the two-parameter form of the method has exactly the same effect
      * as using the six-parameter form with the final four parameters all being -1.
-     * 
+     *
      * @param before The <code>int</code> specifying the number of places before the decimal point. Use -1 for 'as many as are needed'.
      * @param after The <code>int</code> specifying the number of places after the decimal point. Use -1 for 'as many as are needed'.
      * @return A <code>String</code> representing this <code>BigDecimal</code>, laid out according to the specified parameters
@@ -2116,7 +2122,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * The special value <code>MathContext.ROUND_UNNECESSARY</code> may be used to detect whether non-zero digits are
      * discarded -- if <code>exround</code> has this value than if non-zero digits would be discarded (rounded) during
      * formatting then an <code>ArithmeticException</code> is thrown.
-     * 
+     *
      * @param before The <code>int</code> specifying the number of places before the decimal point. Use -1 for 'as many as
      *            are needed'.
      * @param after The <code>int</code> specifying the number of places after the decimal point. Use -1 for 'as many as
@@ -2301,7 +2307,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
                         newa[i] = ' ';
                     }
                 }/* i */
-                java.lang.System.arraycopy((java.lang.Object) a, 0, (java.lang.Object) newa, i, a.length);
+                java.lang.System.arraycopy(a, 0, newa, i, a.length);
                 a = newa;
             }
             // [if p=before then it's just the right length]
@@ -2320,7 +2326,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
             // p is now offset of 'E', or 0
             if (p == 0) { // no E part; add trailing blanks
                 newa = new char[(a.length + explaces) + 2];
-                java.lang.System.arraycopy((java.lang.Object) a, 0, (java.lang.Object) newa, 0, a.length);
+                java.lang.System.arraycopy(a, 0, newa, 0, a.length);
                 {
                     int $14 = explaces + 2;
                     i = a.length;
@@ -2335,7 +2341,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
                     badarg("format", 3, java.lang.String.valueOf(explaces));
                 if (places < explaces) { // need to insert zeros
                     newa = new char[(a.length + explaces) - places];
-                    java.lang.System.arraycopy((java.lang.Object) a, 0, (java.lang.Object) newa, 0, p + 2); // through E
+                    java.lang.System.arraycopy(a, 0, newa, 0, p + 2); // through E
                                                                                                             // and sign
                     {
                         int $15 = explaces - places;
@@ -2344,7 +2350,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
                             newa[i] = '0';
                         }
                     }/* i */
-                    java.lang.System.arraycopy((java.lang.Object) a, p + 2, (java.lang.Object) newa, i, places); // remainder
+                    java.lang.System.arraycopy(a, p + 2, newa, i, places); // remainder
                                                                                                                  // of
                                                                                                                  // exponent
                     a = newa;
@@ -2362,11 +2368,12 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * Note that two <code>BigDecimal</code> objects are only guaranteed to produce the same hashcode if they are
      * exactly equal (that is, the <code>String</code> representations of the <code>BigDecimal</code> numbers are
      * identical -- they have the same characters in the same sequence).
-     * 
+     *
      * @return An <code>int</code> that is the hashcode for <code>this</code>.
      * @stable ICU 2.0
      */
 
+    @Override
     public int hashCode() {
         // Maybe calculate ourselves, later. If so, note that there can be
         // more than one internal representation for a given toString() result.
@@ -2379,11 +2386,12 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * (32-bit signed integer) result then only the low-order 32 bits are used. (That is, the number may be
      * <i>decapitated</i>.) To avoid unexpected errors when these conditions occur, use the {@link #intValueExact}
      * method.
-     * 
+     *
      * @return An <code>int</code> converted from <code>this</code>, truncated and decapitated if necessary.
      * @stable ICU 2.0
      */
 
+    @Override
     public int intValue() {
         return toBigInteger().intValue();
     }
@@ -2392,7 +2400,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * Converts this <code>BigDecimal</code> to an <code>int</code>. If the <code>BigDecimal</code> has a non-zero
      * decimal part or is out of the possible range for an <code>int</code> (32-bit signed integer) result then an
      * <code>ArithmeticException</code> is thrown.
-     * 
+     *
      * @return An <code>int</code> equal in value to <code>this</code>.
      * @throws ArithmeticException if <code>this</code> has a non-zero decimal part, or will not fit in an <code>int</code>.
      * @stable ICU 2.0
@@ -2463,11 +2471,12 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * (64-bit signed integer) result then only the low-order 64 bits are used. (That is, the number may be
      * <i>decapitated</i>.) To avoid unexpected errors when these conditions occur, use the {@link #longValueExact}
      * method.
-     * 
+     *
      * @return A <code>long</code> converted from <code>this</code>, truncated and decapitated if necessary.
      * @stable ICU 2.0
      */
 
+    @Override
     public long longValue() {
         return toBigInteger().longValue();
     }
@@ -2476,7 +2485,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * Converts this <code>BigDecimal</code> to a <code>long</code>. If the <code>BigDecimal</code> has a non-zero
      * decimal part or is out of the possible range for a <code>long</code> (64-bit signed integer) result then an
      * <code>ArithmeticException</code> is thrown.
-     * 
+     *
      * @return A <code>long</code> equal in value to <code>this</code>.
      * @throws ArithmeticException if <code>this</code> has a non-zero decimal part, or will not fit in a <code>long</code>.
      * @stable ICU 2.0
@@ -2515,7 +2524,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
         // note that we could safely use the 'test for wrap to negative'
         // algorithm here, but instead we parallel the intValueExact
         // algorithm for ease of checking and maintenance.
-        result = (long) 0;
+        result = 0;
         {
             int $17 = lodigit + useexp;
             i = 0;
@@ -2554,7 +2563,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * <code>n</code> may be negative, in which case the method returns the same result as <code>movePointRight(-n)
      * </code>.
-     * 
+     *
      * @param n The <code>int</code> specifying the number of places to move the decimal point leftwards.
      * @return A <code>BigDecimal</code> derived from <code>this</code>, with the decimal point moved <code>n</code>
      *         places to the left.
@@ -2578,7 +2587,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * <code>n</code> may be negative, in which case the method returns the same result as <code>movePointLeft(-n)
      * </code>.
-     * 
+     *
      * @param n The <code>int</code> specifying the number of places to move the decimal point rightwards.
      * @return A <code>BigDecimal</code> derived from <code>this</code>, with the decimal point moved <code>n</code>
      *         places to the right.
@@ -2596,7 +2605,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * Returns the scale of this <code>BigDecimal</code>. Returns a non-negative <code>int</code> which is the scale of
      * the number. The scale is the number of digits in the decimal part of the number if the number were formatted
      * without exponential notation.
-     * 
+     *
      * @return An <code>int</code> whose value is the scale of this <code>BigDecimal</code>.
      * @stable ICU 2.0
      */
@@ -2619,7 +2628,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * The same as {@link #setScale(int, int)}, where the first parameter is the scale, and the second is <code>
      * MathContext.ROUND_UNNECESSARY</code>.
-     * 
+     *
      * @param scale The <code>int</code> specifying the scale of the resulting <code>BigDecimal</code>.
      * @return A plain <code>BigDecimal</code> with the given scale.
      * @throws ArithmeticException if <code>scale</code> is negative.
@@ -2644,7 +2653,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * If <code>round</code> is <code>MathContext.ROUND_UNNECESSARY</code>, an <code>ArithmeticException</code> is
      * thrown if any discarded digits are non-zero.
-     * 
+     *
      * @param scale The <code>int</code> specifying the scale of the resulting <code>BigDecimal</code>.
      * @param round The <code>int</code> rounding mode to be used for the division (see the {@link MathContext} class).
      * @return A plain <code>BigDecimal</code> with the given scale.
@@ -2696,7 +2705,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * Converts this <code>BigDecimal</code> to a <code>short</code>. If the <code>BigDecimal</code> has a non-zero
      * decimal part or is out of the possible range for a <code>short</code> (16-bit signed integer) result then an
      * <code>ArithmeticException</code> is thrown.
-     * 
+     *
      * @return A <code>short</code> equal in value to <code>this</code>.
      * @throws ArithmeticException if <code>this</code> has a non-zero decimal part, or will not fit in a <code>short</code>.
      * @stable ICU 2.0
@@ -2714,14 +2723,14 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * Returns the sign of this <code>BigDecimal</code>, as an <code>int</code>. This returns the <i>signum</i> function
      * value that represents the sign of this <code>BigDecimal</code>. That is, -1 if the <code>BigDecimal</code> is
      * negative, 0 if it is numerically equal to zero, or 1 if it is positive.
-     * 
+     *
      * @return An <code>int</code> which is -1 if the <code>BigDecimal</code> is negative, 0 if it is numerically equal
      *         to zero, or 1 if it is positive.
      * @stable ICU 2.0
      */
 
     public int signum() {
-        return (int) this.ind; // [note this assumes values for ind.]
+        return this.ind; // [note this assumes values for ind.]
     }
 
     /**
@@ -2733,7 +2742,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * <i>(Note: this method is provided only in the <code>com.ibm.icu.math</code> version of the BigDecimal class. It
      * would not be present in a <code>java.math</code> version.)</i>
-     * 
+     *
      * @return The <code>java.math.BigDecimal</code> equal in value to this <code>BigDecimal</code>.
      * @stable ICU 2.0
      */
@@ -2747,7 +2756,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * Any decimal part is truncated (discarded). If an exception is desired should the decimal part be non-zero, use
      * {@link #toBigIntegerExact()}.
-     * 
+     *
      * @return The <code>java.math.BigInteger</code> equal in value to the integer part of this <code>BigDecimal</code>.
      * @stable ICU 2.0
      */
@@ -2771,7 +2780,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
                         res = clone(this); // safe copy
                         newlen = res.mant.length + res.exp;
                         newmant = new byte[newlen]; // [shorter]
-                        java.lang.System.arraycopy((java.lang.Object) res.mant, 0, (java.lang.Object) newmant, 0,
+                        java.lang.System.arraycopy(res.mant, 0, newmant, 0,
                                 newlen);
                         res.mant = newmant;
                         res.form = (byte) com.ibm.icu.math.MathContext.PLAIN;
@@ -2787,7 +2796,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * Converts this <code>BigDecimal</code> to a <code>java.math.BigInteger</code>.
      * <p>
      * An exception is thrown if the decimal part (if any) is non-zero.
-     * 
+     *
      * @return The <code>java.math.BigInteger</code> equal in value to the integer part of this <code>BigDecimal</code>.
      * @throws ArithmeticException if <code>this</code> has a non-zero decimal part.
      * @stable ICU 2.0
@@ -2807,7 +2816,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * Returns the <code>BigDecimal</code> as a character array. The result of this method is the same as using the
      * sequence <code>toString().toCharArray()</code>, but avoids creating the intermediate <code>String</code> and
      * <code>char[]</code> objects.
-     * 
+     *
      * @return The <code>char[]</code> array corresponding to this <code>BigDecimal</code>.
      * @stable ICU 2.0
      */
@@ -2823,7 +2832,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <p>
      * By definition, using the {@link #BigDecimal(String)} constructor on the result <code>String</code> will create a
      * <code>BigDecimal</code> that is exactly equal to the original <code>BigDecimal</code>.
-     * 
+     *
      * @return The <code>String</code> exactly corresponding to this <code>BigDecimal</code>.
      * @see #format(int, int)
      * @see #format(int, int, int, int, int, int)
@@ -2831,6 +2840,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * @stable ICU 2.0
      */
 
+    @Override
     public java.lang.String toString() {
         return new java.lang.String(layout());
     }
@@ -2839,7 +2849,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * Returns the number as a <code>BigInteger</code> after removing the scale. That is, the number is expressed as a
      * plain number, any decimal point is then removed (retaining the digits of any decimal part), and the result is
      * then converted to a <code>BigInteger</code>.
-     * 
+     *
      * @return The <code>java.math.BigInteger</code> equal in value to this <code>BigDecimal</code> multiplied by ten to
      *         the power of <code>this.scale()</code>.
      * @stable ICU 2.0
@@ -2866,7 +2876,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * The number is constructed as though <code>num</code> had been converted to a <code>String</code> using the <code>
      * Double.toString()</code> method and the {@link #BigDecimal(java.lang.String)} constructor had then been used.
      * This is typically not an exact conversion.
-     * 
+     *
      * @param dub The <code>double</code> to be translated.
      * @return The <code>BigDecimal</code> equal in value to <code>dub</code>.
      * @throws NumberFormatException if the parameter is infinite or not a number.
@@ -2883,7 +2893,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
     /**
      * Translates a <code>long</code> to a <code>BigDecimal</code>. That is, returns a plain <code>BigDecimal</code>
      * whose value is equal to the given <code>long</code>.
-     * 
+     *
      * @param lint The <code>long</code> to be translated.
      * @return The <code>BigDecimal</code> equal in value to <code>lint</code>.
      * @stable ICU 2.0
@@ -2903,7 +2913,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <code> (new BigDecimal(lint)).divide(TEN.pow(new BigDecimal(scale))) </code>
      * <p>
      * A <code>NumberFormatException</code> is thrown if <code>scale</code> is negative.
-     * 
+     *
      * @param lint The <code>long</code> to be translated.
      * @param scale The <code>int</code> scale to be applied.
      * @return The <code>BigDecimal</code> equal in value to <code>lint</code>.
@@ -2961,7 +2971,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
             int $18 = mant.length;
             i = 0;
             for (; $18 > 0; $18--, i++) {
-                cmant[i] = (char) (mant[i] + ((int) ('0')));
+                cmant[i] = (char) (mant[i] + (('0')));
             }
         }/* i */
 
@@ -3017,7 +3027,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
                 return cmant; // non-negative integer
             rec = new char[cmant.length + 1];
             rec[0] = '-';
-            java.lang.System.arraycopy((java.lang.Object) cmant, 0, (java.lang.Object) rec, 1, cmant.length);
+            java.lang.System.arraycopy(cmant, 0, rec, 1, cmant.length);
             return rec;
         }
 
@@ -3043,7 +3053,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
                     rec[i] = '0';
                 }
             }/* i */
-            java.lang.System.arraycopy((java.lang.Object) cmant, 0, (java.lang.Object) rec, (needsign + 2) - mag,
+            java.lang.System.arraycopy(cmant, 0, rec, (needsign + 2) - mag,
                     cmant.length);
             return rec;
         }
@@ -3053,7 +3063,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
             rec = new char[len];
             if (needsign != 0)
                 rec[0] = '-';
-            java.lang.System.arraycopy((java.lang.Object) cmant, 0, (java.lang.Object) rec, needsign, cmant.length);
+            java.lang.System.arraycopy(cmant, 0, rec, needsign, cmant.length);
             {
                 int $21 = mag - cmant.length;
                 i = needsign + cmant.length;
@@ -3069,9 +3079,9 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
         rec = new char[len];
         if (needsign != 0)
             rec[0] = '-';
-        java.lang.System.arraycopy((java.lang.Object) cmant, 0, (java.lang.Object) rec, needsign, mag);
+        java.lang.System.arraycopy(cmant, 0, rec, needsign, mag);
         rec[needsign + mag] = '.';
-        java.lang.System.arraycopy((java.lang.Object) cmant, mag, (java.lang.Object) rec, (needsign + mag) + 1,
+        java.lang.System.arraycopy(cmant, mag, rec, (needsign + mag) + 1,
                 cmant.length - mag);
         return rec;
     }
@@ -3094,9 +3104,9 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
     /*
      * Arg1 is operation code: D=divide, I=integer divide, R=remainder Arg2 is the rhs. Arg3 is the context. Arg4 is
      * explicit scale iff code='D' or 'I' (-1 if none).
-     * 
+     *
      * Underlying algorithm (complications for Remainder function and scaled division are omitted for clarity):
-     * 
+     *
      * Test for x/0 and then 0/x Exp =Exp1 - Exp2 Exp =Exp +len(var1) -len(var2) Sign=Sign1 Sign2 Pad accumulator (Var1)
      * to double-length with 0's (pad1) Pad Var2 to same length as Var1 B2B=1st two digits of var2, +1 to allow for
      * roundup have=0 Do until (have=digits+1 OR residue=0) if exp<0 then if integer divide/residue then leave
@@ -3106,7 +3116,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * if mult=0 then mult=1 this_digit=this_digit+mult subtract end inner_loop if have\=0 | this_digit\=0 then do
      * output this_digit have=have+1; end var2=var2/10 exp=exp-1 end outer_loop exp=exp+1 -- set the proper exponent if
      * have=0 then generate answer=0 Return to FINISHED Result defined by MATHV1
-     * 
+     *
      * For extended commentary, see DMSRCN.
      */
 
@@ -3246,7 +3256,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
                                 } while (false);
                             }/* compare */
                             /* prepare for subtraction. Estimate BA (lengths the same) */
-                            ba = (int) var1[0]; // use only first digit
+                            ba = var1[0]; // use only first digit
                         } // lengths the same
                         else {/* lhs longer than rhs */
                             /* use first two digits for estimate */
@@ -3279,7 +3289,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
                         if (start == 0)
                             continue inner;
                         // shift left
-                        java.lang.System.arraycopy((java.lang.Object) var1, start, (java.lang.Object) var1, 0, var1len);
+                        java.lang.System.arraycopy(var1, start, var1, 0, var1len);
                     }
                 }/* inner */
 
@@ -3349,7 +3359,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
                     }/* i */
                     if (d < var1.length) {/* need to reduce */
                         newvar1 = new byte[d];
-                        java.lang.System.arraycopy((java.lang.Object) var1, 0, (java.lang.Object) newvar1, 0, d); // shorten
+                        java.lang.System.arraycopy(var1, 0, newvar1, 0, d); // shorten
                         var1 = newvar1;
                     }
                     res.mant = var1;
@@ -3402,7 +3412,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
             // [we could let finish do this, during strip, if we adjusted
             // the exponent; however, truncation avoids the strip loop]
             newmant = new byte[have]; // shorten
-            java.lang.System.arraycopy((java.lang.Object) res.mant, 0, (java.lang.Object) newmant, 0, have);
+            java.lang.System.arraycopy(res.mant, 0, newmant, 0, have);
             res.mant = newmant;
         }
         return res.finish(set, true);
@@ -3427,7 +3437,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
     /*
      * <sgml> Extend byte array to given length, padding with 0s. If no extension is required then return the same
      * array. </sgml>
-     * 
+     *
      * Arg1 is the source byte array Arg2 is the new length (longer)
      */
 
@@ -3436,7 +3446,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
         if (inarr.length == newlen)
             return inarr;
         newarr = new byte[newlen];
-        java.lang.System.arraycopy((java.lang.Object) inarr, 0, (java.lang.Object) newarr, 0, inarr.length);
+        java.lang.System.arraycopy(inarr, 0, newarr, 0, inarr.length);
         // 0 padding is carried out by the JVM on allocation initialization
         return newarr;
     }
@@ -3445,15 +3455,15 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
      * <sgml> Add or subtract two >=0 integers in byte arrays <p>This routine performs the calculation: <pre> C=A+(BM)
      * </pre> Where M is in the range -9 through +9 <p> If M<0 then A>=B must be true, so the result is always
      * non-negative.
-     * 
+     *
      * Leading zeros are not removed after a subtraction. The result is either the same length as the longer of A and B,
      * or 1 longer than that (if a carry occurred).
-     * 
+     *
      * A is not altered unless Arg6 is 1. B is never altered.
-     * 
+     *
      * Arg1 is A Arg2 is A length to use (if longer than A, pad with 0's) Arg3 is B Arg4 is B length to use (if longer
      * than B, pad with 0's) Arg5 is M, the multiplier Arg6 is 1 if A can be used to build the result (if it fits)
-     * 
+     *
      * This routine is severely performance-critical;any change here must be measured (timed) to assure no performance
      * degradation.
      */
@@ -3486,7 +3496,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
         maxarr = bp;
         if (maxarr < ap)
             maxarr = ap;
-        reb = (byte[]) null; // result byte array
+        reb = null; // result byte array
         if (reuse)
             if ((maxarr + 1) == alength)
                 reb = a; // OK to reuse A
@@ -3541,7 +3551,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
         // if digit<0 then signal ArithmeticException("internal.error ["digit"]")
 
         /* We have carry -- need to make space for the extra digit */
-        newarr = (byte[]) null;
+        newarr = null;
         if (reuse)
             if ((maxarr + 2) == a.length)
                 newarr = a; // OK to reuse A
@@ -3557,7 +3567,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
             }
         }/* i */
         else
-            java.lang.System.arraycopy((java.lang.Object) reb, 0, (java.lang.Object) newarr, 1, maxarr + 1);
+            java.lang.System.arraycopy(reb, 0, newarr, 1, maxarr + 1);
         return newarr;
     }
 
@@ -3635,9 +3645,9 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
     /*
      * <sgml> Round to specified digits, if necessary. Arg1 is requested length (digits to round to) [may be <=0 when
      * called from format, dodivide, etc.] Arg2 is rounding mode returns this, for convenience
-     * 
+     *
      * ind and exp are adjusted, but not cleared for a mantissa of zero
-     * 
+     *
      * The length of the mantissa returned will be Arg1, except when Arg1 is 0, in which case the returned mantissa
      * length will be 1. </sgml>
      */
@@ -3655,12 +3665,12 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
             return this; // nowt to do
 
         exp = exp + adjust; // exponent of result
-        sign = (int) ind; // save [assumes -1, 0, 1]
+        sign = ind; // save [assumes -1, 0, 1]
         oldmant = mant; // save
         if (len > 0) {
             // remove the unwanted digits
             mant = new byte[len];
-            java.lang.System.arraycopy((java.lang.Object) oldmant, 0, (java.lang.Object) mant, 0, len);
+            java.lang.System.arraycopy(oldmant, 0, mant, 0, len);
             reuse = true; // can reuse mantissa
             first = oldmant[len]; // first of discarded digits
         } else {/* len<=0 */
@@ -3734,7 +3744,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
                         // drop rightmost digit and raise exponent
                         exp++;
                         // mant is already the correct length
-                        java.lang.System.arraycopy((java.lang.Object) newmant, 0, (java.lang.Object) mant, 0,
+                        java.lang.System.arraycopy(newmant, 0, mant, 0,
                                 mant.length);
                     } else
                         mant = newmant;
@@ -3750,7 +3760,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
     /*
      * <sgml> Test if rightmost digits are all 0. Arg1 is a mantissa array to test Arg2 is the offset of first digit to
      * check [may be negative; if so, digits to left are 0's] returns 1 if all the digits starting at Arg2 are 0
-     * 
+     *
      * Arg2 may be beyond array bounds, in which case 1 is returned </sgml>
      */
 
@@ -3807,7 +3817,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
                 }/* i */
                 if (d < this.mant.length) {/* need to reduce */
                     newmant = new byte[d];
-                    java.lang.System.arraycopy((java.lang.Object) this.mant, 0, (java.lang.Object) newmant, 0, d);
+                    java.lang.System.arraycopy(this.mant, 0, newmant, 0, d);
                     this.mant = newmant;
                 }
             }
@@ -3825,7 +3835,7 @@ public class BigDecimal extends java.lang.Number implements java.io.Serializable
                     if (i > 0) {
                         do {
                             newmant = new byte[this.mant.length - i];
-                            java.lang.System.arraycopy((java.lang.Object) this.mant, i, (java.lang.Object) newmant, 0,
+                            java.lang.System.arraycopy(this.mant, i, newmant, 0,
                                     this.mant.length - i);
                             this.mant = newmant;
                         } while (false);
diff --git a/app/src/main/java/com/ibm/icu/math/MathContext.java b/icu4j/src/main/java/com/ibm/icu/math/MathContext.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/math/MathContext.java
rename to icu4j/src/main/java/com/ibm/icu/math/MathContext.java
index 725186a..d777c4b 100644
--- a/app/src/main/java/com/ibm/icu/math/MathContext.java
+++ b/icu4j/src/main/java/com/ibm/icu/math/MathContext.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /* Generated from 'MathContext.nrx' 8 Sep 2000 11:07:48 [v2.00] */
 /* Options: Binary Comments Crossref Format Java Logo Strictargs Strictcase Trace2 Verbose3 */
 package com.ibm.icu.math;
@@ -79,7 +81,7 @@ package com.ibm.icu.math;
 
 public final class MathContext implements java.io.Serializable{
  //private static final java.lang.String $0="MathContext.nrx";
- 
+
  /* ----- Properties ----- */
  /* properties public constant */
  /**
@@ -94,7 +96,7 @@ public final class MathContext implements java.io.Serializable{
   * @stable ICU 2.0
   */
  public static final int PLAIN=0; // [no exponent]
- 
+
  /**
   * Standard floating point notation (with scientific exponential
   * format, where there is one digit before any decimal point).
@@ -108,7 +110,7 @@ public final class MathContext implements java.io.Serializable{
   * @stable ICU 2.0
   */
  public static final int SCIENTIFIC=1; // 1 digit before .
- 
+
  /**
   * Standard floating point notation (with engineering exponential
   * format, where the power of ten is a multiple of 3).
@@ -122,7 +124,7 @@ public final class MathContext implements java.io.Serializable{
   * @stable ICU 2.0
   */
  public static final int ENGINEERING=2; // 1-3 digits before .
- 
+
  // The rounding modes match the original BigDecimal class values
  /**
   * Rounding mode to round to a more positive number.
@@ -134,7 +136,7 @@ public final class MathContext implements java.io.Serializable{
   * @stable ICU 2.0
   */
  public static final int ROUND_CEILING=2;
- 
+
  /**
   * Rounding mode to round towards zero.
   * Used as a setting to control the rounding mode used during a
@@ -145,7 +147,7 @@ public final class MathContext implements java.io.Serializable{
   * @stable ICU 2.0
   */
  public static final int ROUND_DOWN=1;
- 
+
  /**
   * Rounding mode to round to a more negative number.
   * Used as a setting to control the rounding mode used during a
@@ -156,7 +158,7 @@ public final class MathContext implements java.io.Serializable{
   * @stable ICU 2.0
   */
  public static final int ROUND_FLOOR=3;
- 
+
  /**
   * Rounding mode to round to nearest neighbor, where an equidistant
   * value is rounded down.
@@ -170,7 +172,7 @@ public final class MathContext implements java.io.Serializable{
   * @stable ICU 2.0
   */
  public static final int ROUND_HALF_DOWN=5;
- 
+
  /**
   * Rounding mode to round to nearest neighbor, where an equidistant
   * value is rounded to the nearest even neighbor.
@@ -188,7 +190,7 @@ public final class MathContext implements java.io.Serializable{
   * @stable ICU 2.0
   */
  public static final int ROUND_HALF_EVEN=6;
- 
+
  /**
   * Rounding mode to round to nearest neighbor, where an equidistant
   * value is rounded up.
@@ -202,7 +204,7 @@ public final class MathContext implements java.io.Serializable{
   * @stable ICU 2.0
   */
  public static final int ROUND_HALF_UP=4;
- 
+
  /**
   * Rounding mode to assert that no rounding is necessary.
   * Used as a setting to control the rounding mode used during a
@@ -214,7 +216,7 @@ public final class MathContext implements java.io.Serializable{
   * @stable ICU 2.0
   */
  public static final int ROUND_UNNECESSARY=7;
- 
+
  /**
   * Rounding mode to round away from zero.
   * Used as a setting to control the rounding mode used during a
@@ -225,8 +227,8 @@ public final class MathContext implements java.io.Serializable{
   * @stable ICU 2.0
   */
  public static final int ROUND_UP=0;
- 
- 
+
+
  /* properties shared */
  /**
   * The number of digits (precision) to be used for an operation.
@@ -243,7 +245,7 @@ public final class MathContext implements java.io.Serializable{
   * @serial
   */
  int digits;
- 
+
  /**
   * The form of results from an operation.
   * <p>
@@ -257,7 +259,7 @@ public final class MathContext implements java.io.Serializable{
   * @serial
   */
  int form; // values for this must fit in a byte
- 
+
  /**
   * Controls whether lost digits checking is enabled for an
   * operation.
@@ -273,7 +275,7 @@ public final class MathContext implements java.io.Serializable{
   * @serial
   */
  boolean lostDigits;
- 
+
  /**
   * The rounding algorithm to be used for an operation.
   * <p>
@@ -294,33 +296,33 @@ public final class MathContext implements java.io.Serializable{
   * @serial
   */
  int roundingMode;
- 
+
  /* properties private constant */
  // default settings
  private static final int DEFAULT_FORM=SCIENTIFIC;
  private static final int DEFAULT_DIGITS=9;
  private static final boolean DEFAULT_LOSTDIGITS=false;
  private static final int DEFAULT_ROUNDINGMODE=ROUND_HALF_UP;
- 
+
  /* properties private constant */
- 
+
  private static final int MIN_DIGITS=0; // smallest value for DIGITS.
  private static final int MAX_DIGITS=999999999; // largest value for DIGITS.  If increased,
  // the BigDecimal class may need update.
  // list of valid rounding mode values, most common two first
  private static final int ROUNDS[]=new int[]{ROUND_HALF_UP,ROUND_UNNECESSARY,ROUND_CEILING,ROUND_DOWN,ROUND_FLOOR,ROUND_HALF_DOWN,ROUND_HALF_EVEN,ROUND_UP};
- 
- 
+
+
  private static final java.lang.String ROUNDWORDS[]=new java.lang.String[]{"ROUND_HALF_UP","ROUND_UNNECESSARY","ROUND_CEILING","ROUND_DOWN","ROUND_FLOOR","ROUND_HALF_DOWN","ROUND_HALF_EVEN","ROUND_UP"}; // matching names of the ROUNDS values
- 
- 
- 
- 
+
+
+
+
  /* properties private constant unused */
- 
+
  // Serialization version
  private static final long serialVersionUID=7163376998892515376L;
- 
+
  /* properties public constant */
  /**
   * A <code>MathContext</code> object initialized to the default
@@ -334,11 +336,11 @@ public final class MathContext implements java.io.Serializable{
   */
  public static final com.ibm.icu.math.MathContext DEFAULT=new com.ibm.icu.math.MathContext(DEFAULT_DIGITS,DEFAULT_FORM,DEFAULT_LOSTDIGITS,DEFAULT_ROUNDINGMODE);
 
- 
- 
- 
+
+
+
  /* ----- Constructors ----- */
- 
+
  /**
   * Constructs a new <code>MathContext</code> with a specified
   * precision.
@@ -354,12 +356,12 @@ public final class MathContext implements java.io.Serializable{
   * @throws IllegalArgumentException parameter out of range.
   * @stable ICU 2.0
   */
- 
+
  public MathContext(int setdigits){
   this(setdigits,DEFAULT_FORM,DEFAULT_LOSTDIGITS,DEFAULT_ROUNDINGMODE);
   return;}
 
- 
+
  /**
   * Constructs a new <code>MathContext</code> with a specified
   * precision and form.
@@ -379,7 +381,7 @@ public final class MathContext implements java.io.Serializable{
   * @throws IllegalArgumentException parameter out of range.
   * @stable ICU 2.0
   */
- 
+
  public MathContext(int setdigits,int setform){
   this(setdigits,setform,DEFAULT_LOSTDIGITS,DEFAULT_ROUNDINGMODE);
   return;}
@@ -405,7 +407,7 @@ public final class MathContext implements java.io.Serializable{
   * @throws IllegalArgumentException parameter out of range.
   * @stable ICU 2.0
   */
- 
+
  public MathContext(int setdigits,int setform,boolean setlostdigits){
   this(setdigits,setform,setlostdigits,DEFAULT_ROUNDINGMODE);
   return;}
@@ -431,16 +433,16 @@ public final class MathContext implements java.io.Serializable{
   * @throws IllegalArgumentException parameter out of range.
   * @stable ICU 2.0
   */
- 
+
  public MathContext(int setdigits,int setform,boolean setlostdigits,int setroundingmode){super();
-  
-  
+
+
   // set values, after checking
-  if (setdigits!=DEFAULT_DIGITS) 
+  if (setdigits!=DEFAULT_DIGITS)
    {
-    if (setdigits<MIN_DIGITS) 
+    if (setdigits<MIN_DIGITS)
      throw new java.lang.IllegalArgumentException("Digits too small:"+" "+setdigits);
-    if (setdigits>MAX_DIGITS) 
+    if (setdigits>MAX_DIGITS)
      throw new java.lang.IllegalArgumentException("Digits too large:"+" "+setdigits);
    }
   {/*select*/
@@ -452,7 +454,7 @@ public final class MathContext implements java.io.Serializable{
    throw new java.lang.IllegalArgumentException("Bad form value:"+" "+setform);
   }
   }
-  if ((!(isValidRound(setroundingmode)))) 
+  if ((!(isValidRound(setroundingmode))))
    throw new java.lang.IllegalArgumentException("Bad roundingMode value:"+" "+setroundingmode);
   digits=setdigits;
   form=setform;
@@ -468,7 +470,7 @@ public final class MathContext implements java.io.Serializable{
   *         setting
   * @stable ICU 2.0
   */
- 
+
  public int getDigits(){
   return digits;
   }
@@ -483,7 +485,7 @@ public final class MathContext implements java.io.Serializable{
   * @return an <code>int</code> which is the value of the form setting
   * @stable ICU 2.0
   */
- 
+
  public int getForm(){
   return form;
   }
@@ -497,7 +499,7 @@ public final class MathContext implements java.io.Serializable{
   *           setting
   * @stable ICU 2.0
   */
- 
+
  public boolean getLostDigits(){
   return lostDigits;
   }
@@ -518,7 +520,7 @@ public final class MathContext implements java.io.Serializable{
   *         setting
   * @stable ICU 2.0
   */
- 
+
  public int getRoundingMode(){
   return roundingMode;
   }
@@ -560,7 +562,8 @@ public final class MathContext implements java.io.Serializable{
   * @return a <code>String</code> representing the context settings.
   * @stable ICU 2.0
   */
- 
+
+ @Override
  public java.lang.String toString(){
   java.lang.String formstr=null;
   int r=0;
@@ -575,7 +578,7 @@ public final class MathContext implements java.io.Serializable{
   }
   }
   {int $1=ROUNDS.length;r=0;r:for(;$1>0;$1--,r++){
-   if (roundingMode==ROUNDS[r]) 
+   if (roundingMode==ROUNDS[r])
     {
      roundword=ROUNDWORDS[r];
      break r;
@@ -585,14 +588,14 @@ public final class MathContext implements java.io.Serializable{
   return "digits="+digits+" "+"form="+formstr+" "+"lostDigits="+(lostDigits?"1":"0")+" "+"roundingMode="+roundword;
   }
 
- 
+
  /* <sgml> Test whether round is valid. </sgml> */
  // This could be made shared for use by BigDecimal for setScale.
- 
+
  private static boolean isValidRound(int testround){
   int r=0;
   {int $2=ROUNDS.length;for(r=0;$2>0;$2--,r++){
-   if (testround==ROUNDS[r]) 
+   if (testround==ROUNDS[r])
     return true;
    }
   }/*r*/
diff --git a/app/src/main/java/com/ibm/icu/text/AlphabeticIndex.java b/icu4j/src/main/java/com/ibm/icu/text/AlphabeticIndex.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/AlphabeticIndex.java
rename to icu4j/src/main/java/com/ibm/icu/text/AlphabeticIndex.java
index 947284f..6bbf999 100644
--- a/app/src/main/java/com/ibm/icu/text/AlphabeticIndex.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/AlphabeticIndex.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2008-2016, Google Inc, International Business Machines Corporation
@@ -55,18 +57,18 @@ import com.ibm.icu.util.ULocale;
  * <h2>Direct Use</h2>
  * <p>The following shows an example of building an index directly.
  *  The "show..." methods below are just to illustrate usage.
- * 
+ *
  * <pre>
  * // Create a simple index where the values for the strings are Integers, and add the strings
- * 
+ *
  * AlphabeticIndex&lt;Integer&gt; index = new AlphabeticIndex&lt;Integer&gt;(desiredLocale).addLabels(additionalLocale);
  * int counter = 0;
  * for (String item : test) {
- *     index.addRecord(item, counter++); 
+ *     index.addRecord(item, counter++);
  * }
  * ...
  * // Show index at top. We could skip or gray out empty buckets
- * 
+ *
  * for (AlphabeticIndex.Bucket&lt;Integer&gt; bucket : index) {
  *     if (showAll || bucket.size() != 0) {
  *         showLabelAtTop(UI, bucket.getLabel());
@@ -74,7 +76,7 @@ import com.ibm.icu.util.ULocale;
  * }
  *  ...
  * // Show the buckets with their contents, skipping empty buckets
- * 
+ *
  * for (AlphabeticIndex.Bucket&lt;Integer&gt; bucket : index) {
  *     if (bucket.size() != 0) {
  *         showLabelInList(UI, bucket.getLabel());
@@ -138,6 +140,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
 
     // Comparator for records, so that the Record class can be static.
     private final Comparator<Record<V>> recordComparator = new Comparator<Record<V>>() {
+        @Override
         public int compare(Record<V> o1, Record<V> o2) {
             return collatorOriginal.compare(o1.name, o2.name);
         }
@@ -216,6 +219,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
          * {@inheritDoc}
          * @stable ICU 51
          */
+        @Override
         public Iterator<Bucket<V>> iterator() {
             return buckets.iterator();
         }
@@ -223,7 +227,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
 
     /**
      * Create the index object.
-     * 
+     *
      * @param locale
      *            The locale for the index.
      * @stable ICU 4.8
@@ -234,7 +238,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
 
     /**
      * Create the index object.
-     * 
+     *
      * @param locale
      *            The locale for the index.
      * @stable ICU 4.8
@@ -243,16 +247,16 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
         this(ULocale.forLocale(locale), null);
     }
 
-    /** 
+    /**
      * Create an AlphabeticIndex that uses a specific collator.
-     * 
+     *
      * <p>The index will be created with no labels; the addLabels() function must be called
      * after creation to add the desired labels to the index.
-     * 
-     * <p>The index will work directly with the supplied collator. If the caller will need to 
+     *
+     * <p>The index will work directly with the supplied collator. If the caller will need to
      * continue working with the collator it should be cloned first, so that the
      * collator provided to the AlphabeticIndex remains unchanged after creation of the index.
-     * 
+     *
      * @param collator The collator to use to order the contents of this index.
      * @stable ICU 51
      */
@@ -351,7 +355,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
 
     /**
      * Get the default label used in the IndexCharacters' locale for underflow, eg the last item in: X Y Z ...
-     * 
+     *
      * @return underflow label
      * @stable ICU 4.8
      */
@@ -374,7 +378,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
 
     /**
      * Get the default label used in the IndexCharacters' locale for overflow, eg the first item in: ... A B C
-     * 
+     *
      * @return overflow label
      * @stable ICU 4.8
      */
@@ -398,7 +402,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
     /**
      * Get the default label used for abbreviated buckets <i>between</i> other labels. For example, consider the labels
      * for Latin and Greek are used: X Y Z ... &#x0391; &#x0392; &#x0393;.
-     * 
+     *
      * @return inflow label
      * @stable ICU 4.8
      */
@@ -409,7 +413,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
 
     /**
      * Get the limit on the number of labels in the index. The number of buckets can be slightly larger: see getBucketCount().
-     * 
+     *
      * @return maxLabelCount maximum number of labels.
      * @stable ICU 4.8
      */
@@ -630,7 +634,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
 
     /**
      * Get the labels.
-     * 
+     *
      * @return The list of bucket labels, after processing.
      * @stable ICU 4.8
      */
@@ -649,7 +653,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
      * <p>
      * <b><i>Don't use this method across threads if you are changing the settings on the collator, at least not without
      * synchronizing.</i></b>
-     * 
+     *
      * @return a clone of the collator used internally
      * @stable ICU 4.8
      */
@@ -669,7 +673,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
      * Add a record (name and data) to the index. The name will be used to sort the items into buckets, and to sort
      * within the bucket. Two records may have the same name. When they do, the sort order is according to the order added:
      * the first added comes first.
-     * 
+     *
      * @param name
      *            Name, such as a name
      * @param data
@@ -696,7 +700,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
      * <p>
      * Note that the bucket number (and sort key) are only valid for the settings of the current AlphabeticIndex; if
      * those are changed, then the bucket number and sort key must be regenerated.
-     * 
+     *
      * @param name
      *            Name, such as a name
      * @return the bucket index for the name
@@ -709,7 +713,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
 
     /**
      * Clear the index.
-     * 
+     *
      * @return this, for chaining
      * @stable ICU 4.8
      */
@@ -723,7 +727,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
 
     /**
      * Return the number of buckets in the index. This will be the same as the number of labels, plus buckets for the underflow, overflow, and inflow(s).
-     * 
+     *
      * @return number of buckets
      * @stable ICU 4.8
      */
@@ -734,7 +738,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
 
     /**
      * Return the number of records in the index: that is, the total number of distinct &lt;name,data&gt; pairs added with addRecord(...), over all the buckets.
-     * 
+     *
      * @return total number of records in buckets
      * @stable ICU 4.8
      */
@@ -744,10 +748,11 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
 
     /**
      * Return an iterator over the buckets.
-     * 
+     *
      * @return iterator over buckets.
      * @stable ICU 4.8
      */
+    @Override
     public Iterator<Bucket<V>> iterator() {
         initBuckets();
         return buckets.iterator();
@@ -837,7 +842,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
     /**
      * A (name, data) pair, to be sorted by name into one of the index buckets.
      * The user data is not used by the index implementation.
-     * 
+     *
      * @stable ICU 4.8
      */
     public static class Record<V> {
@@ -851,7 +856,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
 
         /**
          * Get the name
-         * 
+         *
          * @return the name
          * @stable ICU 4.8
          */
@@ -861,7 +866,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
 
         /**
          * Get the data
-         * 
+         *
          * @return the data
          * @stable ICU 4.8
          */
@@ -873,6 +878,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
          * Standard toString()
          * @stable ICU 4.8
          */
+        @Override
         public String toString() {
             return name + "=" + data;
         }
@@ -885,7 +891,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
      * returned by {@link AlphabeticIndex.ImmutableIndex#getBucket(int)},
      * and {@link AlphabeticIndex#addRecord(CharSequence, Object)} adds a record
      * into a bucket according to the record's name.
-     * 
+     *
      * @param <V>
      *            Data type
      * @stable ICU 4.8
@@ -900,7 +906,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
 
         /**
          * Type of the label
-         * 
+         *
          * @stable ICU 4.8
          */
         public enum LabelType {
@@ -928,7 +934,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
 
         /**
          * Set up the bucket.
-         * 
+         *
          * @param label
          *            label for the bucket
          * @param labelType
@@ -943,7 +949,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
 
         /**
          * Get the label
-         * 
+         *
          * @return label for the bucket
          * @stable ICU 4.8
          */
@@ -953,7 +959,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
 
         /**
          * Is a normal, underflow, overflow, or inflow bucket
-         * 
+         *
          * @return is an underflow, overflow, or inflow bucket
          * @stable ICU 4.8
          */
@@ -963,7 +969,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
 
         /**
          * Get the number of records in the bucket.
-         * 
+         *
          * @return number of records in bucket
          * @stable ICU 4.8
          */
@@ -975,6 +981,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
          * Iterator over the records in the bucket
          * @stable ICU 4.8
          */
+        @Override
         public Iterator<Record<V>> iterator() {
             if (records == null) {
                 return Collections.<Record<V>>emptyList().iterator();
@@ -1186,6 +1193,7 @@ public final class AlphabeticIndex<V> implements Iterable<Bucket<V>> {
         /**
          * Iterator over just the visible buckets.
          */
+        @Override
         public Iterator<Bucket<V>> iterator() {
             return immutableVisibleList.iterator(); // use immutable list to prevent remove().
         }
diff --git a/app/src/main/java/com/ibm/icu/text/AnyTransliterator.java b/icu4j/src/main/java/com/ibm/icu/text/AnyTransliterator.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/AnyTransliterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/AnyTransliterator.java
index 435a88e..bc2bc2d 100644
--- a/app/src/main/java/com/ibm/icu/text/AnyTransliterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/AnyTransliterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *****************************************************************
 * Copyright (c) 2002-2014, International Business Machines Corporation
@@ -64,7 +66,7 @@ class AnyTransliterator extends Transliterator {
      * The target script code.  Never USCRIPT_INVALID_CODE.
      */
     private int targetScript;
-    
+
     /**
      * Special code for handling width characters
      */
@@ -73,6 +75,7 @@ class AnyTransliterator extends Transliterator {
     /**
      * Implements {@link Transliterator#handleTransliterate}.
      */
+    @Override
     protected void handleTransliterate(Replaceable text,
                                        Position pos, boolean isIncremental) {
         int allStart = pos.start;
@@ -147,7 +150,7 @@ class AnyTransliterator extends Transliterator {
      * @param id the ID of the form S-T or S-T/V, where T is theTarget
      * and V is theVariant.  Must not be empty.
      * @param filter The Unicode filter.
-     * @param target2 the target name. 
+     * @param target2 the target name.
      * @param targetScript2 the script code corresponding to theTarget.
      * @param widthFix2 The Transliterator width fix.
      * @param cache2 The Map object for cache.
@@ -255,7 +258,7 @@ class AnyTransliterator extends Transliterator {
                 for (Enumeration<String> v = Transliterator.getAvailableVariants(source, target);
                      v.hasMoreElements(); ) {
                     String variant = v.nextElement();
-                    
+
                     // Only process each target/variant pair once
                     if (seenVariants.contains(variant)) {
                         continue;
diff --git a/app/src/main/java/com/ibm/icu/text/ArabicShaping.java b/icu4j/src/main/java/com/ibm/icu/text/ArabicShaping.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/text/ArabicShaping.java
rename to icu4j/src/main/java/com/ibm/icu/text/ArabicShaping.java
index 2ed1d82..1944de6 100644
--- a/app/src/main/java/com/ibm/icu/text/ArabicShaping.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/ArabicShaping.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 *   Copyright (C) 2001-2012, International Business Machines
@@ -59,7 +61,7 @@ public final class ArabicShaping {
     private char tailChar;
 
     /**
-     * Convert a range of text in the source array, putting the result 
+     * Convert a range of text in the source array, putting the result
      * into a range of text in the destination array, and return the number
      * of characters written.
      *
@@ -67,14 +69,14 @@ public final class ArabicShaping {
      * @param sourceStart The start of the range of text to convert
      * @param sourceLength The length of the range of text to convert
      * @param dest The destination array that will receive the result.
-     *   It may be <code>NULL</code> only if  <code>destSize</code> is 0.  
+     *   It may be <code>NULL</code> only if  <code>destSize</code> is 0.
      * @param destStart The start of the range of the destination buffer to use.
      * @param destSize The size (capacity) of the destination buffer.
      *   If <code>destSize</code> is 0, then no output is produced,
      *   but the necessary buffer size is returned ("preflighting").  This
-     *   does not validate the text against the options, for example, 
+     *   does not validate the text against the options, for example,
      *   if letters are being unshaped, and spaces are being consumed
-     *   following lamalef, this will not detect a lamalef without a 
+     *   following lamalef, this will not detect a lamalef without a
      *   corresponding space.  An error will be thrown when the actual
      *   conversion is attempted.
      * @return The number of chars written to the destination buffer.
@@ -98,33 +100,33 @@ public final class ArabicShaping {
         }
         if ((destSize != 0) &&
             (destStart < 0 || destSize < 0 || destStart + destSize > dest.length)) {
-            throw new IllegalArgumentException("bad dest start (" + destStart + 
-                                               ") or size (" + destSize + 
+            throw new IllegalArgumentException("bad dest start (" + destStart +
+                                               ") or size (" + destSize +
                                                ") for buffer of length " + dest.length);
         }
         /* Validate input options */
-        if ( ((options&TASHKEEL_MASK) > 0) &&
+        if ( ((options&TASHKEEL_MASK) != 0) &&
              !(((options & TASHKEEL_MASK)==TASHKEEL_BEGIN)  ||
-               ((options & TASHKEEL_MASK)==TASHKEEL_END )   ||
-               ((options & TASHKEEL_MASK)==TASHKEEL_RESIZE )||
-               ((options & TASHKEEL_MASK)==TASHKEEL_REPLACE_BY_TATWEEL)) ){
+               ((options & TASHKEEL_MASK)==TASHKEEL_END)    ||
+               ((options & TASHKEEL_MASK)==TASHKEEL_RESIZE) ||
+               ((options & TASHKEEL_MASK)==TASHKEEL_REPLACE_BY_TATWEEL))) {
             throw new IllegalArgumentException("Wrong Tashkeel argument");
         }
 
        ///CLOVER:OFF
        //According to Steven Loomis, the code is unreachable when you OR all the constants within the if statements
-       if(((options&LAMALEF_MASK) > 0)&&
+       if(((options&LAMALEF_MASK) != 0) &&
               !(((options & LAMALEF_MASK)==LAMALEF_BEGIN)  ||
-                ((options & LAMALEF_MASK)==LAMALEF_END )   ||
-                ((options & LAMALEF_MASK)==LAMALEF_RESIZE )||
-                 ((options & LAMALEF_MASK)==LAMALEF_AUTO)  ||
-                 ((options & LAMALEF_MASK)==LAMALEF_NEAR))){
+                ((options & LAMALEF_MASK)==LAMALEF_END)    ||
+                ((options & LAMALEF_MASK)==LAMALEF_RESIZE) ||
+                ((options & LAMALEF_MASK)==LAMALEF_AUTO)   ||
+                ((options & LAMALEF_MASK)==LAMALEF_NEAR))) {
            throw new IllegalArgumentException("Wrong Lam Alef argument");
        }
        ///CLOVER:ON
-       
+
        /* Validate Tashkeel (Tashkeel replacement options should be enabled in shaping mode only)*/
-       if(((options&TASHKEEL_MASK) > 0) && (options&LETTERS_MASK) == LETTERS_UNSHAPE) {
+       if(((options&TASHKEEL_MASK) != 0) && (options&LETTERS_MASK) == LETTERS_UNSHAPE) {
             throw new IllegalArgumentException("Tashkeel replacement should not be enabled in deshaping mode ");
        }
        return internalShape(source, sourceStart, sourceLength, dest, destStart, destSize);
@@ -172,7 +174,7 @@ public final class ArabicShaping {
      * Construct ArabicShaping using the options flags.
      * The flags are as follows:<br>
      * 'LENGTH' flags control whether the text can change size, and if not,
-     * how to maintain the size of the text when LamAlef ligatures are 
+     * how to maintain the size of the text when LamAlef ligatures are
      * formed or broken.<br>
      * 'TEXT_DIRECTION' flags control whether the text is read and written
      * in visual order or in logical order.<br>
@@ -189,7 +191,7 @@ public final class ArabicShaping {
         if ((options & DIGITS_MASK) > 0x80) {
             throw new IllegalArgumentException("bad DIGITS options");
         }
-        
+
         isLogical = ( (options & TEXT_DIRECTION_MASK) == TEXT_DIRECTION_LOGICAL );
         /* Validate options */
         spacesRelativeToTextBeginEnd = ( (options & SPACES_RELATIVE_TO_TEXT_MASK) == SPACES_RELATIVE_TO_TEXT_BEGIN_END );
@@ -199,11 +201,11 @@ public final class ArabicShaping {
             tailChar = OLD_TAIL_CHAR;
         }
     }
-    
-    /* Seen Tail options */ 
+
+    /* Seen Tail options */
     /**
      * Memory option: the result must have the same length as the source.
-     * Shaping mode: The SEEN family character will expand into two characters using space near 
+     * Shaping mode: The SEEN family character will expand into two characters using space near
      *               the SEEN family character(i.e. the space after the character).
      *               if there are no spaces found, ArabicShapingException will be thrown
      *
@@ -214,35 +216,35 @@ public final class ArabicShaping {
      */
     public static final int SEEN_TWOCELL_NEAR = 0x200000;
 
-    /** Bit mask for Seen memory options. 
+    /** Bit mask for Seen memory options.
      * @stable ICU 4.2
      */
     public static final int SEEN_MASK = 0x700000;
 
-    /* YehHamza options */ 
+    /* YehHamza options */
     /**
      * Memory option: the result must have the same length as the source.
-     * Shaping mode: The YEHHAMZA character will expand into two characters using space near it 
+     * Shaping mode: The YEHHAMZA character will expand into two characters using space near it
      *              (i.e. the space after the character)
      *               if there are no spaces found, ArabicShapingException will be thrown
      *
      * De-shaping mode: Any Yeh (final or isolated) character followed by Hamza character will be
      *                  replaced by one cell YehHamza and space will replace the Hamza.
      * Affects: YehHamza options
-     * @stable ICU 4.2 
+     * @stable ICU 4.2
      */
     public static final int YEHHAMZA_TWOCELL_NEAR  = 0x1000000;
 
 
-    /** Bit mask for YehHamza memory options. 
+    /** Bit mask for YehHamza memory options.
      * @stable ICU 4.2
      */
     public static final int YEHHAMZA_MASK = 0x3800000;
 
-    /* New Tashkeel options */ 
+    /* New Tashkeel options */
     /**
      * Memory option: the result must have the same length as the source.
-     * Shaping mode: Tashkeel characters will be replaced by spaces. 
+     * Shaping mode: Tashkeel characters will be replaced by spaces.
      *               Spaces will be placed at beginning of the buffer
      *
      * De-shaping mode: N/A
@@ -253,7 +255,7 @@ public final class ArabicShaping {
 
     /**
      * Memory option: the result must have the same length as the source.
-     * Shaping mode: Tashkeel characters will be replaced by spaces. 
+     * Shaping mode: Tashkeel characters will be replaced by spaces.
      *               Spaces will be placed at end of the buffer
      *
      * De-shaping mode: N/A
@@ -264,8 +266,8 @@ public final class ArabicShaping {
 
     /**
      * Memory option: allow the result to have a different length than the source.
-     * Shaping mode: Tashkeel characters will be removed, buffer length will shrink. 
-     * De-shaping mode: N/A 
+     * Shaping mode: Tashkeel characters will be removed, buffer length will shrink.
+     * De-shaping mode: N/A
      *
      * Affects: Tashkeel options
      * @stable ICU 4.2
@@ -283,42 +285,42 @@ public final class ArabicShaping {
      */
     public static final int TASHKEEL_REPLACE_BY_TATWEEL = 0xC0000;
 
-    /** Bit mask for Tashkeel replacement with Space or Tatweel memory options. 
+    /** Bit mask for Tashkeel replacement with Space or Tatweel memory options.
      *  @stable ICU 4.2
      */
     public static final int TASHKEEL_MASK  = 0xE0000;
-    
-    /* Space location Control options */ 
+
+    /* Space location Control options */
     /**
      * This option effects the meaning of BEGIN and END options. if this option is not used the default
-     * for BEGIN and END will be as following: 
+     * for BEGIN and END will be as following:
      * The Default (for both Visual LTR, Visual RTL and Logical Text)
      *           1. BEGIN always refers to the start address of physical memory.
      *           2. END always refers to the end address of physical memory.
      *
-     * If this option is used it will swap the meaning of BEGIN and END only for Visual LTR text. 
+     * If this option is used it will swap the meaning of BEGIN and END only for Visual LTR text.
      *
      * The affect on BEGIN and END Memory Options will be as following:
-     *    A. BEGIN For Visual LTR text: This will be the beginning (right side) of the visual text 
+     *    A. BEGIN For Visual LTR text: This will be the beginning (right side) of the visual text
      *       (corresponding to the physical memory address end, same as END in default behavior)
-     *    B. BEGIN For Logical text: Same as BEGIN in default behavior. 
-     *    C. END For Visual LTR text: This will be the end (left side) of the visual text. (corresponding to  
-     *      the physical memory address beginning, same as BEGIN in default behavior) 
-     *    D. END For Logical text: Same as END in default behavior. 
+     *    B. BEGIN For Logical text: Same as BEGIN in default behavior.
+     *    C. END For Visual LTR text: This will be the end (left side) of the visual text. (corresponding to
+     *      the physical memory address beginning, same as BEGIN in default behavior)
+     *    D. END For Logical text: Same as END in default behavior.
      * Affects: All LamAlef BEGIN, END and AUTO options.
-     * @stable ICU 4.2 
+     * @stable ICU 4.2
      */
     public static final int SPACES_RELATIVE_TO_TEXT_BEGIN_END = 0x4000000;
 
-    /** Bit mask for swapping BEGIN and END for Visual LTR text 
+    /** Bit mask for swapping BEGIN and END for Visual LTR text
      * @stable ICU 4.2
      */
     public static final int SPACES_RELATIVE_TO_TEXT_MASK = 0x4000000;
-    
+
     /**
-     * If this option is used, shaping will use the new Unicode code point for TAIL (i.e. 0xFE73). 
+     * If this option is used, shaping will use the new Unicode code point for TAIL (i.e. 0xFE73).
      * If this option is not specified (Default), old unofficial Unicode TAIL code point is used (i.e. 0x200B)
-     * De-shaping will not use this option as it will always search for both the new Unicode code point for the 
+     * De-shaping will not use this option as it will always search for both the new Unicode code point for the
      * TAIL (i.e. 0xFE73) or the old unofficial Unicode TAIL code point (i.e. 0x200B) and de-shape the
      * Seen-Family letter accordingly.
      *
@@ -329,7 +331,7 @@ public final class ArabicShaping {
      */
     public static final int SHAPE_TAIL_NEW_UNICODE = 0x8000000;
 
-    /** Bit mask for new Unicode Tail option 
+    /** Bit mask for new Unicode Tail option
      * @stable ICU 4.2
      */
     public static final int SHAPE_TAIL_TYPE_MASK = 0x8000000;
@@ -347,7 +349,7 @@ public final class ArabicShaping {
      * @stable ICU 4.2
      */
     public static final int LAMALEF_RESIZE   = 0;
-    
+
     /**
      * Memory option: the result must have the same length as the source.
      * If more room is necessary, then try to consume spaces next to modified characters.
@@ -363,7 +365,7 @@ public final class ArabicShaping {
      * @stable ICU 4.2
      */
     public static final int LAMALEF_NEAR = 1 ;
-        
+
     /**
      * Memory option: the result must have the same length as the source.
      * If more room is necessary, then try to consume spaces at the end of the text.
@@ -380,7 +382,7 @@ public final class ArabicShaping {
      * @stable ICU 4.2
      */
     public static final int LAMALEF_END = 2;
-    
+
     /**
      * Memory option: the result must have the same length as the source.
      * If more room is necessary, then try to consume spaces at the beginning of the text.
@@ -395,7 +397,7 @@ public final class ArabicShaping {
      * This option is an alias to LENGTH_FIXED_SPACES_AT_BEGINNING
      * @stable ICU 4.2
      */
-    public static final int LAMALEF_BEGIN = 3; 
+    public static final int LAMALEF_BEGIN = 3;
 
     /**
      * Memory option: the result must have the same length as the source.
@@ -404,26 +406,26 @@ public final class ArabicShaping {
      *               is no space at beginning of the buffer, use spaces at the near (i.e. the space
      *               after the LAMALEF character).
      *
-     * Deshaping Mode: Perform the same function as the flag equals LAMALEF_END. 
+     * Deshaping Mode: Perform the same function as the flag equals LAMALEF_END.
      * Affects: LamAlef options
      * @stable ICU 4.2
      */
-    public static final int LAMALEF_AUTO  = 0x10000; 
-    
-    /** 
-     * Bit mask for memory options. 
+    public static final int LAMALEF_AUTO  = 0x10000;
+
+    /**
+     * Bit mask for memory options.
      * @stable ICU 2.0
      */
     public static final int LENGTH_MASK = 0x10003;
 
-    /** Bit mask for LamAlef memory options. 
+    /** Bit mask for LamAlef memory options.
      * @stable ICU 4.2
      */
 
     public static final int LAMALEF_MASK  = 0x10003;
 
-    /** 
-     * Direction indicator: the source is in logical (keyboard) order. 
+    /**
+     * Direction indicator: the source is in logical (keyboard) order.
      * @stable ICU 2.0
      */
     public static final int TEXT_DIRECTION_LOGICAL = 0;
@@ -435,28 +437,28 @@ public final class ArabicShaping {
      * @stable ICU 4.2
      */
     public static final int TEXT_DIRECTION_VISUAL_RTL = 0;
-    
-    /** 
+
+    /**
      * Direction indicator: the source is in visual (display) order, that is,
      * the leftmost displayed character is stored first.
      * @stable ICU 2.0
      */
     public static final int TEXT_DIRECTION_VISUAL_LTR = 4;
 
-    /** 
-     * Bit mask for direction indicators. 
+    /**
+     * Bit mask for direction indicators.
      * @stable ICU 2.0
      */
     public static final int TEXT_DIRECTION_MASK = 4;
 
 
     /**
-     * Letter shaping option: do not perform letter shaping. 
+     * Letter shaping option: do not perform letter shaping.
      * @stable ICU 2.0
      */
     public static final int LETTERS_NOOP = 0;
 
-    /** 
+    /**
      * Letter shaping option: replace normative letter characters in the U+0600 (Arabic) block,
      * by shaped ones in the U+FE70 (Presentation Forms B) block. Performs Lam-Alef ligature
      * substitution.
@@ -464,7 +466,7 @@ public final class ArabicShaping {
      */
     public static final int LETTERS_SHAPE = 8;
 
-    /** 
+    /**
      * Letter shaping option: replace shaped letter characters in the U+FE70 (Presentation Forms B) block
      * by normative ones in the U+0600 (Arabic) block.  Converts Lam-Alef ligatures to pairs of Lam and
      * Alef characters, consuming spaces if required.
@@ -481,15 +483,15 @@ public final class ArabicShaping {
      */
     public static final int LETTERS_SHAPE_TASHKEEL_ISOLATED = 0x18;
 
-    /** 
-     * Bit mask for letter shaping options. 
+    /**
+     * Bit mask for letter shaping options.
      * @stable ICU 2.0
      */
     public static final int LETTERS_MASK = 0x18;
 
 
-    /** 
-     * Digit shaping option: do not perform digit shaping. 
+    /**
+     * Digit shaping option: do not perform digit shaping.
      * @stable ICU 2.0
      */
     public static final int DIGITS_NOOP = 0;
@@ -510,7 +512,7 @@ public final class ArabicShaping {
      * Digit shaping option:
      * Replace European digits (U+0030...U+0039) by Arabic-Indic digits
      * if the most recent strongly directional character
-     * is an Arabic letter (its Bidi direction value is RIGHT_TO_LEFT_ARABIC). 
+     * is an Arabic letter (its Bidi direction value is RIGHT_TO_LEFT_ARABIC).
      * The initial state at the start of the text is assumed to be not an Arabic,
      * letter, so European digits at the start of the text will not change.
      * Compare to DIGITS_ALEN2AN_INIT_AL.
@@ -522,7 +524,7 @@ public final class ArabicShaping {
      * Digit shaping option:
      * Replace European digits (U+0030...U+0039) by Arabic-Indic digits
      * if the most recent strongly directional character
-     * is an Arabic letter (its Bidi direction value is RIGHT_TO_LEFT_ARABIC). 
+     * is an Arabic letter (its Bidi direction value is RIGHT_TO_LEFT_ARABIC).
      * The initial state at the start of the text is assumed to be an Arabic,
      * letter, so European digits at the start of the text will change.
      * Compare to DIGITS_ALEN2AN_INT_LR.
@@ -533,26 +535,26 @@ public final class ArabicShaping {
     /** Not a valid option value. */
     //private static final int DIGITS_RESERVED = 0xa0;
 
-    /** 
-     * Bit mask for digit shaping options. 
+    /**
+     * Bit mask for digit shaping options.
      * @stable ICU 2.0
      */
     public static final int DIGITS_MASK = 0xe0;
 
-    /** 
-     * Digit type option: Use Arabic-Indic digits (U+0660...U+0669). 
+    /**
+     * Digit type option: Use Arabic-Indic digits (U+0660...U+0669).
      * @stable ICU 2.0
      */
     public static final int DIGIT_TYPE_AN = 0;
 
-    /** 
-     * Digit type option: Use Eastern (Extended) Arabic-Indic digits (U+06f0...U+06f9). 
+    /**
+     * Digit type option: Use Eastern (Extended) Arabic-Indic digits (U+06f0...U+06f9).
      * @stable ICU 2.0
      */
     public static final int DIGIT_TYPE_AN_EXTENDED = 0x100;
 
-    /** 
-     * Bit mask for digit type options. 
+    /**
+     * Bit mask for digit type options.
      * @stable ICU 2.0
      */
     public static final int DIGIT_TYPE_MASK = 0x0100; // 0x3f00?
@@ -569,7 +571,7 @@ public final class ArabicShaping {
     private static final char LAM_CHAR      = '\u0644';
     private static final char SPACE_CHAR    = '\u0020';
     private static final char SHADDA_CHAR   = '\uFE7C';
-    private static final char SHADDA06_CHAR = '\u0651'; 
+    private static final char SHADDA06_CHAR = '\u0651';
     private static final char TATWEEL_CHAR  = '\u0640';
     private static final char SHADDA_TATWEEL_CHAR = '\uFE7D';
     private static final char NEW_TAIL_CHAR = '\uFE73';
@@ -580,9 +582,10 @@ public final class ArabicShaping {
     /**
      * @stable ICU 2.0
      */
+    @Override
     public boolean equals(Object rhs) {
-        return rhs != null && 
-            rhs.getClass() == ArabicShaping.class && 
+        return rhs != null &&
+            rhs.getClass() == ArabicShaping.class &&
             options == ((ArabicShaping)rhs).options;
     }
 
@@ -590,6 +593,7 @@ public final class ArabicShaping {
      * @stable ICU 2.0
      */
      ///CLOVER:OFF
+    @Override
     public int hashCode() {
         return options;
     }
@@ -597,6 +601,7 @@ public final class ArabicShaping {
     /**
      * @stable ICU 2.0
      */
+    @Override
     public String toString() {
         StringBuilder buf = new StringBuilder(super.toString());
         buf.append('[');
@@ -660,23 +665,23 @@ public final class ArabicShaping {
     private static final int LINKL = 2;
     private static final int LINK_MASK = 3;
 
-    private static final int irrelevantPos[] = { 
-        0x0, 0x2, 0x4, 0x6, 0x8, 0xA, 0xC, 0xE 
+    private static final int irrelevantPos[] = {
+        0x0, 0x2, 0x4, 0x6, 0x8, 0xA, 0xC, 0xE
     };
 
 /*
     private static final char convertLamAlef[] =  {
-        '\u0622', // FEF5 
+        '\u0622', // FEF5
         '\u0622', // FEF6
         '\u0623', // FEF7
         '\u0623', // FEF8
         '\u0625', // FEF9
         '\u0625', // FEFA
         '\u0627', // FEFB
-        '\u0627'  // FEFC 
+        '\u0627'  // FEFC
     };
 */
-    
+
     private static final int tailFamilyIsolatedFinal[] = {
         /* FEB1 */ 1,
         /* FEB2 */ 1,
@@ -921,7 +926,7 @@ public final class ArabicShaping {
      * Function: Converts the Alef characters into an equivalent
      *           LamAlef location in the 0x06xx Range, this is an
      *           intermediate stage in the operation of the program
-     *           later it'll be converted into the 0xFExx LamAlefs 
+     *           later it'll be converted into the 0xFExx LamAlefs
      *           in the shaping function.
      */
     private static char changeLamAlef(char ch) {
@@ -940,7 +945,7 @@ public final class ArabicShaping {
      *           function, this function returns 1 or 2 for these special characters
      */
     private static int specialChar(char ch) {
-        if ((ch > '\u0621' && ch < '\u0626') || 
+        if ((ch > '\u0621' && ch < '\u0626') ||
             (ch == '\u0627') ||
             (ch > '\u062E' && ch < '\u0633') ||
             (ch > '\u0647' && ch < '\u064A') ||
@@ -948,7 +953,7 @@ public final class ArabicShaping {
             return 1;
         } else if (ch >= '\u064B' && ch<= '\u0652') {
             return 2;
-        } else if (ch >= 0x0653 && ch <= 0x0655 || 
+        } else if (ch >= 0x0653 && ch <= 0x0655 ||
                    ch == 0x0670 ||
                    ch >= 0xFE70 && ch <= 0xFE7F) {
             return 3;
@@ -956,10 +961,10 @@ public final class ArabicShaping {
             return 0;
         }
     }
-    
+
     /*
      * Name    : getLink
-     * Function: Resolves the link between the characters as 
+     * Function: Resolves the link between the characters as
      *           Arabic characters have four forms :
      *           Isolated, Initial, Middle and Final Form
      */
@@ -982,7 +987,7 @@ public final class ArabicShaping {
      * Function: Counts the number of spaces
      *           at each end of the logical buffer
      */
-    private static int countSpacesLeft(char[] dest, 
+    private static int countSpacesLeft(char[] dest,
                                        int start,
                                        int count) {
         for (int i = start, e = start + count; i < e; ++i) {
@@ -1015,7 +1020,7 @@ public final class ArabicShaping {
 
     /*
      *Name     : isSeenTailFamilyChar
-     *Function : returns 1 if the character is a seen family isolated character 
+     *Function : returns 1 if the character is a seen family isolated character
      *           in the FE range otherwise returns 0
      */
 
@@ -1042,7 +1047,7 @@ public final class ArabicShaping {
 
     /*
      *Name     : isTailChar
-     *Function : returns true if the character matches one of the tail characters 
+     *Function : returns true if the character matches one of the tail characters
      *           (0xfe73 or 0x200b) otherwise returns false
      */
 
@@ -1053,15 +1058,15 @@ public final class ArabicShaping {
                 return false;
         }
     }
-    
+
     /*
      *Name     : isAlefMaksouraChar
-     *Function : returns true if the character is a Alef Maksoura Final or isolated 
+     *Function : returns true if the character is a Alef Maksoura Final or isolated
      *           otherwise returns false
      */
     private static boolean isAlefMaksouraChar(char ch) {
         return ( (ch == 0xFEEF) || ( ch == 0xFEF0) || (ch == 0x0649));
-    } 
+    }
 
     /*
      * Name     : isYehHamzaChar
@@ -1074,22 +1079,22 @@ public final class ArabicShaping {
         }else{
             return false;
         }
-    } 
+    }
 
     /*
      *Name     : isTashkeelCharFE
      *Function : Returns true for Tashkeel characters in FE range else return false
      */
-        
+
     private static boolean isTashkeelCharFE(char ch) {
         return ( ch!=0xFE75 &&(ch>=0xFE70 && ch<= 0xFE7F) );
     }
 
-    /* 
+    /*
      * Name: isTashkeelOnTatweelChar
-     * Function: Checks if the Tashkeel Character is on Tatweel or not,if the 
-     *           Tashkeel on tatweel (FE range), it returns 1 else if the 
-     *           Tashkeel with shadda on tatweel (FC range)return 2 otherwise 
+     * Function: Checks if the Tashkeel Character is on Tatweel or not,if the
+     *           Tashkeel on tatweel (FE range), it returns 1 else if the
+     *           Tashkeel with shadda on tatweel (FC range)return 2 otherwise
      *           returns 0
      */
     private static int isTashkeelOnTatweelChar(char ch){
@@ -1102,11 +1107,11 @@ public final class ArabicShaping {
             return 0;
         }
     }
-    
+
     /*
      * Name: isIsolatedTashkeelChar
-     * Function: Checks if the Tashkeel Character is in the isolated form 
-     *           (i.e. Unicode FE range) returns 1 else if the Tashkeel 
+     * Function: Checks if the Tashkeel Character is in the isolated form
+     *           (i.e. Unicode FE range) returns 1 else if the Tashkeel
      *           with shadda is in the isolated form (i.e. Unicode FC range)
      *           returns 1 otherwise returns 0
      */
@@ -1119,7 +1124,7 @@ public final class ArabicShaping {
             return 0;
         }
     }
-   
+
     /*
      * Name    : isAlefChar
      * Function: Returns 1 for Alef characters else return 0
@@ -1127,7 +1132,7 @@ public final class ArabicShaping {
     private static boolean isAlefChar(char ch) {
         return ch == '\u0622' || ch == '\u0623' || ch == '\u0625' || ch == '\u0627';
     }
-     
+
     /*
      * Name    : isLamAlefChar
      * Function: Returns true for LamAlef characters else return false
@@ -1148,9 +1153,9 @@ public final class ArabicShaping {
     private int calculateSize(char[] source,
                               int sourceStart,
                               int sourceLength) {
-    
+
         int destSize = sourceLength;
-        
+
         switch (options & LETTERS_MASK) {
         case LETTERS_SHAPE:
         case LETTERS_SHAPE_TASHKEEL_ISOLATED:
@@ -1183,8 +1188,8 @@ public final class ArabicShaping {
 
         return destSize;
     }
-    
-    
+
+
     /*
      * Name    : countSpaceSub
      * Function: Counts number of times the subChar appears in the array
@@ -1197,10 +1202,10 @@ public final class ArabicShaping {
               count++;
               }
           i++;
-        } 
-        return count;  
+        }
+        return count;
     }
-    
+
     /*
      * Name    : shiftArray
      * Function: Shifts characters to replace space sub characters
@@ -1237,12 +1242,12 @@ public final class ArabicShaping {
          }
         return w;
       }
-    
+
     /*
      * Name     : handleTashkeelWithTatweel
-     * Function : Replaces Tashkeel as following: 
-     *            Case 1 :if the Tashkeel on tatweel, replace it with Tatweel.   
-     *            Case 2 :if the Tashkeel aggregated with Shadda on Tatweel, replace 
+     * Function : Replaces Tashkeel as following:
+     *            Case 1 :if the Tashkeel on tatweel, replace it with Tatweel.
+     *            Case 2 :if the Tashkeel aggregated with Shadda on Tatweel, replace
      *                   it with Shadda on Tatweel.
      *            Case 3: if the Tashkeel is isolated replace it with Space.
      *
@@ -1264,53 +1269,53 @@ public final class ArabicShaping {
     /*
      *Name     : handleGeneratedSpaces
      *Function : The shapeUnicode function converts Lam + Alef into LamAlef + space,
-     *           and Tashkeel to space. 
-     *           handleGeneratedSpaces function puts these generated spaces 
+     *           and Tashkeel to space.
+     *           handleGeneratedSpaces function puts these generated spaces
      *           according to the options the user specifies. LamAlef and Tashkeel
-     *           spaces can be replaced at begin, at end, at near or decrease the 
+     *           spaces can be replaced at begin, at end, at near or decrease the
      *           buffer size.
      *
      *           There is also Auto option for LamAlef and tashkeel, which will put
-     *           the spaces at end of the buffer (or end of text if the user used 
+     *           the spaces at end of the buffer (or end of text if the user used
      *           the option SPACES_RELATIVE_TO_TEXT_BEGIN_END).
      *
-     *           If the text type was visual_LTR and the option 
-     *           SPACES_RELATIVE_TO_TEXT_BEGIN_END was selected the END 
+     *           If the text type was visual_LTR and the option
+     *           SPACES_RELATIVE_TO_TEXT_BEGIN_END was selected the END
      *           option will place the space at the beginning of the buffer and
-     *           BEGIN will place the space at the end of the buffer. 
+     *           BEGIN will place the space at the end of the buffer.
      */
-  private int handleGeneratedSpaces(char[] dest, 
+  private int handleGeneratedSpaces(char[] dest,
             int start,
             int length) {
-      
+
       int lenOptionsLamAlef = options & LAMALEF_MASK;
       int lenOptionsTashkeel = options & TASHKEEL_MASK;
       boolean lamAlefOn = false;
       boolean tashkeelOn = false;
-      
+
       if (!isLogical & !spacesRelativeToTextBeginEnd) {
           switch (lenOptionsLamAlef) {
           case LAMALEF_BEGIN: lenOptionsLamAlef = LAMALEF_END; break;
           case LAMALEF_END: lenOptionsLamAlef = LAMALEF_BEGIN; break;
           default: break;
-         }   
+         }
           switch (lenOptionsTashkeel){
           case TASHKEEL_BEGIN: lenOptionsTashkeel = TASHKEEL_END; break;
           case TASHKEEL_END: lenOptionsTashkeel = TASHKEEL_BEGIN; break;
           default: break;
           }
         }
-      
-     
+
+
       if (lenOptionsLamAlef == LAMALEF_NEAR) {
           for (int i = start, e = i + length; i < e; ++i) {
               if (dest[i] == LAMALEF_SPACE_SUB) {
                   dest[i] = SPACE_CHAR;
               }
           }
-          
+
       } else {
-          
+
           final int e = start + length;
           int wL = countSpaceSub(dest, length, LAMALEF_SPACE_SUB);
           int wT = countSpaceSub(dest, length, TASHKEEL_SPACE_SUB);
@@ -1323,11 +1328,11 @@ public final class ArabicShaping {
           }
 
 
-          if (lamAlefOn && (lenOptionsLamAlef == LAMALEF_END)) { 
+          if (lamAlefOn && (lenOptionsLamAlef == LAMALEF_END)) {
             shiftArray(dest, start, e, LAMALEF_SPACE_SUB);
             while (wL > start) {
                 dest[--wL] = SPACE_CHAR;
-            } 
+            }
           }
 
           if (tashkeelOn && (lenOptionsTashkeel == TASHKEEL_END)){
@@ -1336,32 +1341,32 @@ public final class ArabicShaping {
                  dest[--wT] = SPACE_CHAR;
             }
           }
-            
-          lamAlefOn = false; 
+
+          lamAlefOn = false;
           tashkeelOn = false;
-        
+
           if (lenOptionsLamAlef == LAMALEF_RESIZE){
             lamAlefOn = true;
           }
           if (lenOptionsTashkeel == TASHKEEL_RESIZE){
             tashkeelOn = true;
           }
-        
+
           if (lamAlefOn && (lenOptionsLamAlef == LAMALEF_RESIZE)){
               shiftArray(dest, start, e, LAMALEF_SPACE_SUB);
               wL = flipArray(dest,start,e, wL);
               length = wL - start;
           }
-          if (tashkeelOn && (lenOptionsTashkeel == TASHKEEL_RESIZE)) { 
+          if (tashkeelOn && (lenOptionsTashkeel == TASHKEEL_RESIZE)) {
               shiftArray(dest, start, e, TASHKEEL_SPACE_SUB);
               wT = flipArray(dest,start,e, wT);
               length = wT - start;
-          } 
+          }
+
+          lamAlefOn = false;
+          tashkeelOn = false;
 
-          lamAlefOn = false; 
-          tashkeelOn = false;          
-        
-          if ((lenOptionsLamAlef == LAMALEF_BEGIN) || 
+          if ((lenOptionsLamAlef == LAMALEF_BEGIN) ||
               (lenOptionsLamAlef == LAMALEF_AUTO)){
                 lamAlefOn = true;
           }
@@ -1385,15 +1390,15 @@ public final class ArabicShaping {
                   }
               }
            }
-      
+
       return length;
   }
-  
-  
+
+
   /*
    *Name     :expandCompositCharAtBegin
    *Function :Expands the LamAlef character to Lam and Alef consuming the required
-   *         space from beginning of the buffer. If the text type was visual_LTR 
+   *         space from beginning of the buffer. If the text type was visual_LTR
    *         and the option SPACES_RELATIVE_TO_TEXT_BEGIN_END was selected
    *         the spaces will be located at end of buffer.
    *         If there are no spaces to expand the LamAlef, an exception is thrown.
@@ -1401,7 +1406,7 @@ public final class ArabicShaping {
  private boolean expandCompositCharAtBegin(char[] dest,int start, int length,
                             int lacount) {
      boolean spaceNotFound = false;
-     
+
      if (lacount > countSpacesRight(dest, start, length)) {
          spaceNotFound = true;
          return spaceNotFound;
@@ -1416,22 +1421,22 @@ public final class ArabicShaping {
          }
      }
      return spaceNotFound;
- 
+
   }
 
   /*
    *Name     : expandCompositCharAtEnd
-   *Function : Expands the LamAlef character to Lam and Alef consuming the 
+   *Function : Expands the LamAlef character to Lam and Alef consuming the
    *           required space from end of the buffer. If the text type was
    *           Visual LTR and the option SPACES_RELATIVE_TO_TEXT_BEGIN_END
-   *           was used, the spaces will be consumed from begin of buffer. If 
-   *           there are no spaces to expand the LamAlef, an exception is thrown. 
+   *           was used, the spaces will be consumed from begin of buffer. If
+   *           there are no spaces to expand the LamAlef, an exception is thrown.
    */
 
   private boolean  expandCompositCharAtEnd(char[] dest,int start, int length,
                           int lacount){
       boolean spaceNotFound = false;
-      
+
       if (lacount > countSpacesLeft(dest, start, length)) {
           spaceNotFound = true;
           return spaceNotFound;
@@ -1451,22 +1456,22 @@ public final class ArabicShaping {
   /*
    *Name     : expandCompositCharAtNear
    *Function : Expands the LamAlef character into Lam + Alef, YehHamza character
-   *           into Yeh + Hamza, SeenFamily character into SeenFamily character 
-   *           + Tail, while consuming the space next to the character. 
+   *           into Yeh + Hamza, SeenFamily character into SeenFamily character
+   *           + Tail, while consuming the space next to the character.
    */
 
   private boolean expandCompositCharAtNear(char[] dest,int start, int length,
                                        int yehHamzaOption, int seenTailOption, int lamAlefOption){
-      
+
       boolean spaceNotFound = false;
-      
-      
-      
+
+
+
       if (isNormalizedLamAlefChar(dest[start])) {
           spaceNotFound = true;
           return spaceNotFound;
       }
-      for (int i = start + length; --i >=start;) { 
+      for (int i = start + length; --i >=start;) {
           char ch = dest[i];
           if (lamAlefOption == 1 && isNormalizedLamAlefChar(ch)) {
               if (i>start &&dest[i-1] == SPACE_CHAR) {
@@ -1484,7 +1489,7 @@ public final class ArabicShaping {
                   return spaceNotFound;
               }
           }else if(yehHamzaOption == 1 && isYehHamzaChar(ch)){
-              
+
                if(i>start &&dest[i-1] == SPACE_CHAR){
                   dest[i] = yehHamzaToYeh[ch - YEH_HAMZAFE_CHAR];
                   dest[i-1] = HAMZAFE_CHAR;
@@ -1492,14 +1497,14 @@ public final class ArabicShaping {
                   spaceNotFound = true;
                   return spaceNotFound;
                 }
-              
-              
+
+
           }
       }
       return false;
 
   }
-    
+
     /*
      * Name    : expandCompositChar
      * Function: LamAlef needs special handling as the LamAlef is
@@ -1518,9 +1523,9 @@ public final class ArabicShaping {
 
         int lenOptionsLamAlef = options & LAMALEF_MASK;
         int lenOptionsSeen = options & SEEN_MASK;
-        int lenOptionsYehHamza = options & YEHHAMZA_MASK; 
+        int lenOptionsYehHamza = options & YEHHAMZA_MASK;
         boolean spaceNotFound = false;
-        
+
         if (!isLogical && !spacesRelativeToTextBeginEnd) {
             switch (lenOptionsLamAlef) {
             case LAMALEF_BEGIN: lenOptionsLamAlef = LAMALEF_END; break;
@@ -1528,7 +1533,7 @@ public final class ArabicShaping {
             default: break;
             }
         }
-        
+
         if(shapingMode == 1){
             if(lenOptionsLamAlef == LAMALEF_AUTO){
                 if(isLogical){
@@ -1563,11 +1568,11 @@ public final class ArabicShaping {
                 spaceNotFound = expandCompositCharAtBegin(dest, start, length, lacount);
                 if(spaceNotFound){
                     throw new ArabicShapingException("No spacefor lamalef");
-                }                
+                }
             }else if(lenOptionsLamAlef == LAMALEF_NEAR){
                 spaceNotFound = expandCompositCharAtNear(dest, start, length,0,0,1);
                 if(spaceNotFound){
-                    throw new ArabicShapingException("No spacefor lamalef");                
+                    throw new ArabicShapingException("No spacefor lamalef");
             }
             }else if(lenOptionsLamAlef == LAMALEF_RESIZE){
                 for (int r = start + length, w = r + lacount; --r >= start;) {
@@ -1585,20 +1590,20 @@ public final class ArabicShaping {
                 if(lenOptionsSeen == SEEN_TWOCELL_NEAR){
                 spaceNotFound = expandCompositCharAtNear(dest, start, length,0,1,0);
                 if(spaceNotFound){
-                    throw new ArabicShapingException("No space for Seen tail expansion"); 
+                    throw new ArabicShapingException("No space for Seen tail expansion");
                 }
             }
             if(lenOptionsYehHamza == YEHHAMZA_TWOCELL_NEAR){
                 spaceNotFound = expandCompositCharAtNear(dest, start, length,1,0,0);
                 if(spaceNotFound){
-                    throw new ArabicShapingException("No space for YehHamza expansion"); 
+                    throw new ArabicShapingException("No space for YehHamza expansion");
                 }
-            }   
+            }
             }
         return length;
     }
 
-    
+
     /* Convert the input buffer from FExx Range into 06xx Range
      * to put all characters into the 06xx range
      * even the lamalef is converted to the special region in
@@ -1621,9 +1626,9 @@ public final class ArabicShaping {
     /*
      * Name    : deshapeNormalize
      * Function: Convert the input buffer from FExx Range into 06xx Range
-     *           even the lamalef is converted to the special region in the 06xx range.  
-     *           According to the options the user enters, all seen family characters 
-     *           followed by a tail character are merged to seen tail family character and 
+     *           even the lamalef is converted to the special region in the 06xx range.
+     *           According to the options the user enters, all seen family characters
+     *           followed by a tail character are merged to seen tail family character and
      *           any yeh followed by a hamza character are merged to yehhamza character.
      *           Method returns the number of lamalef chars found.
      */
@@ -1634,15 +1639,15 @@ public final class ArabicShaping {
 
         yehHamzaComposeEnabled = ((options&YEHHAMZA_MASK) == YEHHAMZA_TWOCELL_NEAR) ? 1 : 0;
         seenComposeEnabled = ((options&SEEN_MASK) == SEEN_TWOCELL_NEAR)? 1 : 0;
-    
+
         for (int i = start, e = i + length; i < e; ++i) {
             char ch = dest[i];
-        
-        if( (yehHamzaComposeEnabled == 1) && ((ch == HAMZA06_CHAR) || (ch == HAMZAFE_CHAR)) 
+
+        if( (yehHamzaComposeEnabled == 1) && ((ch == HAMZA06_CHAR) || (ch == HAMZAFE_CHAR))
                && (i < (length - 1)) && isAlefMaksouraChar(dest[i+1] )) {
                 dest[i] = SPACE_CHAR;
                 dest[i+1] = YEH_HAMZA_CHAR;
-       } else if ( (seenComposeEnabled == 1) && (isTailChar(ch)) && (i< (length - 1)) 
+       } else if ( (seenComposeEnabled == 1) && (isTailChar(ch)) && (i< (length - 1))
                        && (isSeenTailFamilyChar(dest[i+1])==1) ) {
                dest[i] = SPACE_CHAR;
        }
@@ -1661,12 +1666,12 @@ public final class ArabicShaping {
      * Function: Converts an Arabic Unicode buffer in 06xx Range into a shaped
      *           arabic Unicode buffer in FExx Range
      */
-    private int shapeUnicode(char[] dest, 
+    private int shapeUnicode(char[] dest,
                              int start,
                              int length,
                              int destSize,
                              int tashkeelFlag)throws ArabicShapingException {
-        
+
         int lamalef_count = normalize(dest, start, length);
 
         // resolve the link between the characters.
@@ -1687,8 +1692,8 @@ public final class ArabicShaping {
         int nw = 0;
 
         while (i >= 0) {
-            // If high byte of currLink > 0 then there might be more than one shape
-            if ((currLink & '\uFF00') > 0 || isTashkeelChar(dest[i])) {
+            // If high byte of currLink != 0 then there might be more than one shape
+            if ((currLink & '\uFF00') != 0 || isTashkeelChar(dest[i])) {
                 nw = i - 1;
                 nx = -2;
                 while (nx < 0) { // we need to know about next char
@@ -1706,7 +1711,7 @@ public final class ArabicShaping {
                 }
 
                 if (((currLink & ALEFTYPE) > 0) && ((lastLink & LAMTYPE) > 0)) {
-                    lamalef_found = true; 
+                    lamalef_found = true;
                     char wLamalef = changeLamAlef(dest[i]); // get from 0x065C-0x065f
                     if (wLamalef != '\u0000') {
                         // replace alef by marker, it will be removed later
@@ -1719,7 +1724,7 @@ public final class ArabicShaping {
                     currLink = getLink(wLamalef); // requires '\u0000', unfortunately
                 }
                 if ((i > 0) && (dest[i-1] == SPACE_CHAR))
-                { 
+                {
                     if ( isSeenFamilyChar(dest[i]) == 1){
                         seenfam_found = true;
                     } else if (dest[i] == YEH_HAMZA_CHAR) {
@@ -1749,31 +1754,31 @@ public final class ArabicShaping {
                     shape &= 0x1;
                 } else if (flag == 2) {
                     if (tashkeelFlag == 0 &&
-                        ((lastLink & LINKL) != 0) && 
-                        ((nextLink & LINKR) != 0) && 
-                        dest[i] != '\u064C' && 
+                        ((lastLink & LINKL) != 0) &&
+                        ((nextLink & LINKR) != 0) &&
+                        dest[i] != '\u064C' &&
                         dest[i] != '\u064D' &&
-                        !((nextLink & ALEFTYPE) == ALEFTYPE && 
+                        !((nextLink & ALEFTYPE) == ALEFTYPE &&
                           (lastLink & LAMTYPE) == LAMTYPE)) {
-        
+
                         shape = 1;
-                      
+
                     } else if(tashkeelFlag == 2 && dest[i] == SHADDA06_CHAR){
                         shape = 1;
-                     
+
                     } else {
                         shape = 0;
                     }
                 }
                 if (flag == 2) {
-                    if (tashkeelFlag == 2 && dest[i] != SHADDA06_CHAR) { 
+                    if (tashkeelFlag == 2 && dest[i] != SHADDA06_CHAR) {
                         dest[i] = TASHKEEL_SPACE_SUB;
                         tashkeel_found = true;
                     }
                     else{
                         dest[i] = (char)('\uFE70' + irrelevantPos[dest[i] - '\u064B'] + shape);
                     }
-                    // else leave tashkeel alone                    
+                    // else leave tashkeel alone
                 } else {
                     dest[i] = (char)('\uFE70' + (currLink >> 8) + shape);
                 }
@@ -1796,7 +1801,7 @@ public final class ArabicShaping {
             }
         }
 
-        // If we found a lam/alef pair in the buffer 
+        // If we found a lam/alef pair in the buffer
         // call handleGeneratedSpaces to remove the spaces that were added
 
         destSize = length;
@@ -1814,17 +1819,17 @@ public final class ArabicShaping {
      * Function: Converts an Arabic Unicode buffer in FExx Range into unshaped
      *           arabic Unicode buffer in 06xx Range
      */
-    private int deShapeUnicode(char[] dest, 
+    private int deShapeUnicode(char[] dest,
                                int start,
                                int length,
                                int destSize) throws ArabicShapingException {
 
-        int lamalef_count = deshapeNormalize(dest, start, length); 
+        int lamalef_count = deshapeNormalize(dest, start, length);
 
         // If there was a lamalef in the buffer call expandLamAlef
         if (lamalef_count != 0) {
             // need to adjust dest to fit expanded buffer... !!!
-            destSize = expandCompositChar(dest, start, length, lamalef_count,DESHAPE_MODE); 
+            destSize = expandCompositChar(dest, start, length, lamalef_count,DESHAPE_MODE);
         } else {
             destSize = length;
         }
@@ -1832,7 +1837,7 @@ public final class ArabicShaping {
         return destSize;
     }
 
-    private int internalShape(char[] source, 
+    private int internalShape(char[] source,
                               int sourceStart,
                               int sourceLength,
                               char[] dest,
@@ -1846,7 +1851,7 @@ public final class ArabicShaping {
         if (destSize == 0) {
             if (((options & LETTERS_MASK) != LETTERS_NOOP) &&
                 ((options & LAMALEF_MASK) == LAMALEF_RESIZE)) {
-    
+
                 return calculateSize(source, sourceStart, sourceLength);
             } else {
                 return sourceLength; // by definition
@@ -1869,7 +1874,7 @@ public final class ArabicShaping {
             break;
 
         case LETTERS_SHAPE:
-            if( ((options&TASHKEEL_MASK)> 0) && 
+            if( ((options&TASHKEEL_MASK) != 0) &&
                 ((options&TASHKEEL_MASK) !=TASHKEEL_REPLACE_BY_TATWEEL)) {
                    /* Call the shaping function with tashkeel flag == 2 for removal of tashkeel */
                 outputSize = shapeUnicode(temp, 0, sourceLength, destSize, 2);
@@ -1886,12 +1891,12 @@ public final class ArabicShaping {
 
         case LETTERS_UNSHAPE:
             outputSize = deShapeUnicode(temp, 0, sourceLength, destSize);
-            break; 
+            break;
 
         default:
             break;
         }
-                
+
         if (outputSize > destSize) {
             throw new ArabicShapingException("not enough room for result data");
         }
@@ -1953,9 +1958,9 @@ public final class ArabicShaping {
         if (isLogical) {
             invertBuffer(temp, 0, outputSize);
         }
-      
+
         System.arraycopy(temp, 0, dest, destStart, outputSize);
-      
+
         return outputSize;
     }
 }
diff --git a/app/src/main/java/com/ibm/icu/text/ArabicShapingException.java b/icu4j/src/main/java/com/ibm/icu/text/ArabicShapingException.java
similarity index 86%
rename from app/src/main/java/com/ibm/icu/text/ArabicShapingException.java
rename to icu4j/src/main/java/com/ibm/icu/text/ArabicShapingException.java
index 76720e1..c72f451 100644
--- a/app/src/main/java/com/ibm/icu/text/ArabicShapingException.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/ArabicShapingException.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  *   Copyright (C) 2001-2008, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/text/Bidi.java b/icu4j/src/main/java/com/ibm/icu/text/Bidi.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/Bidi.java
rename to icu4j/src/main/java/com/ibm/icu/text/Bidi.java
index 0f51a10..62a276d 100644
--- a/app/src/main/java/com/ibm/icu/text/Bidi.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/Bidi.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 *   Copyright (C) 2001-2016, International Business Machines
@@ -527,7 +529,6 @@ public class Bidi {
         int   contextPos;               /* position of last strong char found before opening */
         short flags;                    /* bits for L or R/AL found within the pair */
         byte  contextDir;               /* L or R according to last strong char before opening */
-        byte  filler;                   /* to complete a nice multiple of 4 bytes */
     }
 
     static class IsoRun {
@@ -977,11 +978,14 @@ public class Bidi {
     /**
      * Value returned by <code>BidiClassifier</code> when there is no need to
      * override the standard Bidi class for a given code point.
+     *
+     * <p>This constant is deprecated; use UCharacter.getIntPropertyMaxValue(UProperty.BIDI_CLASS)+1 instead.
+     *
      * @see BidiClassifier
-     * @stable ICU 3.8
+     * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
      */
-    public static final int CLASS_DEFAULT = UCharacterDirection
-                                            .CHAR_DIRECTION_COUNT;
+    @Deprecated
+    public static final int CLASS_DEFAULT = UCharacterDirection.CHAR_DIRECTION_COUNT;
 
     /* number of paras entries allocated initially */
     static final int SIMPLE_PARAS_COUNT = 10;
@@ -4676,8 +4680,8 @@ public class Bidi {
     /**
      * Retrieves the Bidi class for a given code point.
      * <p>If a <code>BidiClassifier</code> is defined and returns a value
-     * other than <code>CLASS_DEFAULT</code>, that value is used; otherwise
-     * the default class determination mechanism is invoked.
+     * other than <code>CLASS_DEFAULT=UCharacter.getIntPropertyMaxValue(UProperty.BIDI_CLASS)+1</code>,
+     * that value is used; otherwise the default class determination mechanism is invoked.
      *
      * @param c The code point to get a Bidi class for.
      *
diff --git a/app/src/main/java/com/ibm/icu/text/BidiClassifier.java b/icu4j/src/main/java/com/ibm/icu/text/BidiClassifier.java
similarity index 90%
rename from app/src/main/java/com/ibm/icu/text/BidiClassifier.java
rename to icu4j/src/main/java/com/ibm/icu/text/BidiClassifier.java
index 37c3731..71cd645 100644
--- a/app/src/main/java/com/ibm/icu/text/BidiClassifier.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/BidiClassifier.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2000-2009, International Business Machines Corporation and    *
@@ -84,8 +86,8 @@ public /*abstract*/ class BidiClassifier {
      *
      * @param c Code point to be classified.
      * @return An integer representing directional property / Bidi class for the
-     *         given code point <code>c</code>, or CLASS_DEFAULT to signify
-     *         that there is no need to override the standard Bidi class for
+     *         given code point <code>c</code>, or Bidi.CLASS_DEFAULT=UCharacter.getIntPropertyMaxValue(UProperty.BIDI_CLASS)+1
+     *         to signify that there is no need to override the standard Bidi class for
      *         the given code point.
      * @see Bidi#CLASS_DEFAULT
      * @stable ICU 3.8
diff --git a/app/src/main/java/com/ibm/icu/text/BidiLine.java b/icu4j/src/main/java/com/ibm/icu/text/BidiLine.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/BidiLine.java
rename to icu4j/src/main/java/com/ibm/icu/text/BidiLine.java
index 5eefe5d..375f085 100644
--- a/app/src/main/java/com/ibm/icu/text/BidiLine.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/BidiLine.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 *   Copyright (C) 2001-2014, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/text/BidiRun.java b/icu4j/src/main/java/com/ibm/icu/text/BidiRun.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/text/BidiRun.java
rename to icu4j/src/main/java/com/ibm/icu/text/BidiRun.java
index d58b952..011d810 100644
--- a/app/src/main/java/com/ibm/icu/text/BidiRun.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/BidiRun.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 *   Copyright (C) 2001-2016, International Business Machines
@@ -146,6 +148,7 @@ public class BidiRun {
      * String to display run
      * @stable ICU 3.8
      */
+    @Override
     public String toString()
     {
         return "BidiRun " + start + " - " + limit + " @ " + level;
diff --git a/icu4j/src/main/java/com/ibm/icu/text/BidiTransform.java b/icu4j/src/main/java/com/ibm/icu/text/BidiTransform.java
new file mode 100644
index 0000000..240ef44
--- /dev/null
+++ b/icu4j/src/main/java/com/ibm/icu/text/BidiTransform.java
@@ -0,0 +1,667 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
+
+package com.ibm.icu.text;
+
+import com.ibm.icu.lang.UCharacter;
+
+/**
+ * Bidi Layout Transformation Engine.
+ *
+ * @author Lina Kemmel
+ *
+ * @draft ICU 58
+ * @provisional This API might change or be removed in a future release.
+ */
+public class BidiTransform
+{
+    /**
+     * <code>{@link Order}</code> indicates the order of text.
+     * <p>
+     * This bidi transformation engine supports all possible combinations (4 in
+     * total) of input and output text order:
+     * <ul>
+     * <li>{logical input, visual output}: unless the output direction is RTL,
+     * this corresponds to a normal operation of the Bidi algorithm as
+     * described in the Unicode Technical Report and implemented by
+     * <code>{@link Bidi}</code> when the reordering mode is set to
+     * <code>Bidi#REORDER_DEFAULT</code>. Visual RTL mode is not supported by
+     * <code>{@link Bidi}</code> and is accomplished through reversing a visual
+     * LTR string,</li>
+     * <li>{visual input, logical output}: unless the input direction is RTL,
+     * this corresponds to an "inverse bidi algorithm" in
+     * <code>{@link Bidi}</code> with the reordering mode set to
+     * <code>{@link Bidi#REORDER_INVERSE_LIKE_DIRECT}</code>. Visual RTL mode
+     * is not not supported by <code>{@link Bidi}</code> and is accomplished
+     * through reversing a visual LTR string,</li>
+     * <li>{logical input, logical output}: if the input and output base
+     * directions mismatch, this corresponds to the <code>{@link Bidi}</code>
+     * implementation with the reordering mode set to
+     * <code>{@link Bidi#REORDER_RUNS_ONLY}</code>; and if the input and output
+     * base directions are identical, the transformation engine will only
+     * handle character mirroring and Arabic shaping operations without
+     * reordering,</li>
+     * <li>{visual input, visual output}: this reordering mode is not supported
+     * by the <code>{@link Bidi}</code> engine; it implies character mirroring,
+     * Arabic shaping, and - if the input/output base directions mismatch -
+     * string reverse operations.</li>
+     * </ul>
+     *
+     * @see Bidi#setInverse
+     * @see Bidi#setReorderingMode
+     * @see Bidi#REORDER_DEFAULT
+     * @see Bidi#REORDER_INVERSE_LIKE_DIRECT
+     * @see Bidi#REORDER_RUNS_ONLY
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public enum Order {
+        /**
+         * Constant indicating a logical order.
+         *
+         * @draft ICU 58
+         * @provisional This API might change or be removed in a future release.
+         */
+        LOGICAL,
+        /**
+         * Constant indicating a visual order.
+         *
+         * @draft ICU 58
+         * @provisional This API might change or be removed in a future release.
+         */
+        VISUAL;
+    }
+
+    /**
+     * <code>{@link Mirroring}</code> indicates whether or not characters with
+     * the "mirrored" property in RTL runs should be replaced with their
+     * mirror-image counterparts.
+     *
+     * @see Bidi#DO_MIRRORING
+     * @see Bidi#setReorderingOptions
+     * @see Bidi#writeReordered
+     * @see Bidi#writeReverse
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public enum Mirroring {
+        /**
+         * Constant indicating that character mirroring should not be
+         * performed.
+         *
+         * @draft ICU 58
+         * @provisional This API might change or be removed in a future release.
+         */
+        OFF,
+        /**
+         * Constant indicating that character mirroring should be performed.
+         * <p>
+         * This corresponds to calling <code>{@link Bidi#writeReordered}</code>
+         * or <code>{@link Bidi#writeReverse}</code> with the
+         * <code>{@link Bidi#DO_MIRRORING}</code> option bit set.
+         *
+         * @draft ICU 58
+         * @provisional This API might change or be removed in a future release.
+         */
+        ON;
+    }
+
+    private Bidi bidi;
+    private String text;
+    private int reorderingOptions;
+    private int shapingOptions;
+
+    /**
+     * <code>{@link BidiTransform}</code> default constructor.
+     *
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public BidiTransform()
+    {
+    }
+
+    /**
+     * Performs transformation of text from the bidi layout defined by the
+     * input ordering scheme to the bidi layout defined by the output ordering
+     * scheme, and applies character mirroring and Arabic shaping operations.
+     * <p>
+     * In terms of <code>{@link Bidi}</code> class, such a transformation
+     * implies:
+     * <ul>
+     * <li>calling <code>{@link Bidi#setReorderingMode}</code> as needed (when
+     * the reordering mode is other than normal),</li>
+     * <li>calling <code>{@link Bidi#setInverse}</code> as needed (when text
+     * should be transformed from a visual to a logical form),</li>
+     * <li>resolving embedding levels of each character in the input text by
+     * calling <code>{@link Bidi#setPara}</code>,</li>
+     * <li>reordering the characters based on the computed embedding levels,
+     * also performing character mirroring as needed, and streaming the result
+     * to the output, by calling <code>{@link Bidi#writeReordered}</code>,</li>
+     * <li>performing Arabic digit and letter shaping on the output text by
+     * calling <code>{@link ArabicShaping#shape}</code>.</li>
+     * </ul><p>
+     * An "ordering scheme" encompasses the base direction and the order of
+     * text, and these characteristics must be defined by the caller for both
+     * input and output explicitly .<p>
+     * There are 36 possible combinations of {input, output} ordering schemes,
+     * which are partially supported by <code>{@link Bidi}</code> already.
+     * Examples of the currently supported combinations:
+     * <ul>
+     * <li>{Logical LTR, Visual LTR}: this is equivalent to calling
+     * <code>{@link Bidi#setPara}</code> with
+     * <code>paraLevel == {@link Bidi#LTR}</code>,</li>
+     * <li>{Logical RTL, Visual LTR}: this is equivalent to calling
+     * <code>{@link Bidi#setPara}</code> with
+     * <code>paraLevel == {@link Bidi#RTL}</code>,</li>
+     * <li>{Logical Default ("Auto") LTR, Visual LTR}: this is equivalent to
+     * calling <code>{@link Bidi#setPara}</code> with
+     * <code>paraLevel == {@link Bidi#LEVEL_DEFAULT_LTR}</code>,</li>
+     * <li>{Logical Default ("Auto") RTL, Visual LTR}: this is equivalent to
+     * calling <code>{@link Bidi#setPara}</code> with
+     * <code>paraLevel == {@link Bidi#LEVEL_DEFAULT_RTL}</code>,</li>
+     * <li>{Visual LTR, Logical LTR}: this is equivalent to
+     * calling <code>{@link Bidi#setInverse}(true)</code> and then
+     * <code>{@link Bidi#setPara}</code> with
+     * <code>paraLevel == {@link Bidi#LTR}</code>,</li>
+     * <li>{Visual LTR, Logical RTL}: this is equivalent to calling
+     * <code>{@link Bidi#setInverse}(true)</code> and then
+     * <code>{@link Bidi#setPara}</code> with
+     * <code>paraLevel == {@link Bidi#RTL}</code>.</li>
+     * </ul><p>
+     * All combinations that involve the Visual RTL scheme are unsupported by
+     * <code>{@link Bidi}</code>, for instance:
+     * <ul>
+     * <li>{Logical LTR, Visual RTL},</li>
+     * <li>{Visual RTL, Logical RTL}.</li>
+     * </ul>
+     * <p>Example of usage of the transformation engine:</p>
+     * <pre>
+     * BidiTransform bidiTransform = new BidiTransform();
+     * String in = "abc \u06f0123"; // "abc \\u06f0123"
+     * // Run a transformation.
+     * String out = bidiTransform.transform(in,
+     *          Bidi.LTR, Order.VISUAL,
+     *          Bidi.RTL, Order.LOGICAL,
+     *          Mirroring.OFF,
+     *          ArabicShaping.DIGITS_AN2EN | ArabicShaping.DIGIT_TYPE_AN_EXTENDED);
+     * // Result: "0123 abc".
+     * // Do something with out.
+     * out = out.replace('0', '4');
+     * // Result: "4123 abc".
+     * // Run a reverse transformation.
+     * String inNew = bidiTransform.transform(out,
+     *          Bidi.RTL, Order.LOGICAL,
+     *          Bidi.LTR, Order.VISUAL,
+     *          Mirroring.OFF,
+     *          ArabicShaping.DIGITS_EN2AN | ArabicShaping.DIGIT_TYPE_AN_EXTENDED);
+     * // Result: "abc \\u06f4\\u06f1\\u06f2\\u06f3"
+     * </pre>
+     *
+     * @param text An input character sequence that the Bidi layout
+     *        transformations will be performed on.
+     * @param inParaLevel A base embedding level of the input as defined in
+     *        <code>{@link Bidi#setPara(String, byte, byte[])}</code>
+     *        documentation for the <code>paraLevel</code> parameter.
+     * @param inOrder An order of the input, which can be one of the
+     *        <code>{@link Order}</code> values.
+     * @param outParaLevel A base embedding level of the output as defined in
+     *        <code>{@link Bidi#setPara(String, byte, byte[])}</code>
+     *        documentation for the <code>paraLevel</code> parameter.
+     * @param outOrder An order of the output, which can be one of the
+     *        <code>{@link Order}</code> values.
+     * @param doMirroring Indicates whether or not to perform character
+     *        mirroring, and can accept one of the
+     *        <code>{@link Mirroring}</code> values.
+     * @param shapingOptions Arabic digit and letter shaping options defined in
+     *        the <code>{@link ArabicShaping}</code> documentation.
+     *        <p><strong>Note:</strong> Direction indicator options are
+     *        computed by the transformation engine based on the effective
+     *        ordering schemes, so user-defined direction indicators will be
+     *        ignored.
+     * @return The output string, which is the result of the layout
+     *        transformation.
+     * @throws IllegalArgumentException if <code>text</code>,
+     *        <code>inOrder</code>, <code>outOrder</code>, or
+     *        <code>doMirroring</code> parameter is <code>null</code>.
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public String transform(CharSequence text,
+            byte inParaLevel, Order inOrder,
+            byte outParaLevel, Order outOrder,
+            Mirroring doMirroring, int shapingOptions)
+    {
+        if (text == null || inOrder == null || outOrder == null || doMirroring == null) {
+            throw new IllegalArgumentException();
+        }
+        this.text = text.toString();
+
+        byte[] levels = {inParaLevel, outParaLevel};
+        resolveBaseDirection(levels);
+
+        ReorderingScheme currentScheme = findMatchingScheme(levels[0], inOrder,
+                levels[1], outOrder);
+        if (currentScheme != null) {
+            this.bidi = new Bidi();
+            this.reorderingOptions = Mirroring.ON.equals(doMirroring)
+                    ? Bidi.DO_MIRRORING : Bidi.REORDER_DEFAULT;
+
+             /* Ignore TEXT_DIRECTION_* flags, as we apply our own depending on the
+                text scheme at the time shaping is invoked. */
+            this.shapingOptions = shapingOptions & ~ArabicShaping.TEXT_DIRECTION_MASK;
+            currentScheme.doTransform(this);
+        }
+        return this.text;
+    }
+
+    /**
+     * When the direction option is
+     * <code>{@link Bidi#LEVEL_DEFAULT_LTR}</code> or
+     * <code>{@link Bidi#LEVEL_DEFAULT_RTL}</code>, resolves the base
+     * direction according to that of the first strong directional character in
+     * the text.
+     *
+     * @param levels Byte array, where levels[0] is an input level levels[1] is
+     *        an output level. Resolved levels override these.
+     */
+    private void resolveBaseDirection(byte[] levels) {
+        if (Bidi.IsDefaultLevel(levels[0])) {
+            byte level = Bidi.getBaseDirection(text);
+            levels[0] = level != Bidi.NEUTRAL ? level
+                : levels[0] == Bidi.LEVEL_DEFAULT_RTL ? Bidi.RTL : Bidi.LTR;
+        } else {
+            levels[0] &= 1;
+        }
+        if (Bidi.IsDefaultLevel(levels[1])) {
+            levels[1] = levels[0];
+        } else {
+            levels[1] &= 1;
+        }
+    }
+
+    /**
+     * Finds a valid <code>{@link ReorderingScheme}</code> matching the
+     * caller-defined scheme.
+     *
+     * @return A valid <code>ReorderingScheme</code> object or null
+     */
+    private ReorderingScheme findMatchingScheme(byte inLevel, Order inOrder,
+            byte outLevel, Order outOrder) {
+        for (ReorderingScheme scheme : ReorderingScheme.values()) {
+            if (scheme.matches(inLevel, inOrder, outLevel, outOrder)) {
+                return scheme;
+            }
+        }
+        return null;
+    }
+
+    /**
+     * Performs bidi resolution of text.
+     *
+     * @param level Base embedding level
+     * @param options Reordering options
+     */
+    private void resolve(byte level, int options) {
+        bidi.setInverse((options & Bidi.REORDER_INVERSE_LIKE_DIRECT) != 0);
+        bidi.setReorderingMode(options);
+        bidi.setPara(text, level, null);
+    }
+
+    /**
+     * Performs basic reordering of text (Logical LTR or RTL to Visual LTR).
+     *
+     */
+    private void reorder() {
+        text = bidi.writeReordered(reorderingOptions);
+        reorderingOptions = Bidi.REORDER_DEFAULT;
+    }
+
+    /**
+     * Performs string reverse.
+     */
+    private void reverse() {
+        text = Bidi.writeReverse(text, Bidi.OPTION_DEFAULT);
+    }
+
+    /**
+     * Performs character mirroring without reordering. When this method is
+     * called, <code>{@link #text}</code> should be in a Logical form.
+     */
+    private void mirror() {
+        if ((reorderingOptions & Bidi.DO_MIRRORING) == 0) {
+            return;
+        }
+        StringBuffer sb = new StringBuffer(text);
+        byte[] levels = bidi.getLevels();
+        for (int i = 0, n = levels.length; i < n;) {
+            int ch = UTF16.charAt(sb, i);
+            if ((levels[i] & 1) != 0) {
+                UTF16.setCharAt(sb, i, UCharacter.getMirror(ch));
+            }
+            i += UTF16.getCharCount(ch);
+        }
+        text = sb.toString();
+        reorderingOptions &= ~Bidi.DO_MIRRORING;
+    }
+
+    /**
+     * Performs digit and letter shaping
+     *
+     * @param digitsDir Digit shaping option that indicates whether the text
+     *      should be treated as logical or visual.
+     * @param lettersDir Letter shaping option that indicates whether the text
+     *      should be treated as logical or visual form (can mismatch the digit
+     *      option).
+     */
+    private void shapeArabic(int digitsDir, int lettersDir) {
+        if (digitsDir == lettersDir) {
+            shapeArabic(shapingOptions | digitsDir);
+        } else {
+            /* Honor all shape options other than letters (not necessarily digits
+               only) */
+            shapeArabic((shapingOptions & ~ArabicShaping.LETTERS_MASK) | digitsDir);
+
+            /* Honor all shape options other than digits (not necessarily letters
+               only) */
+            shapeArabic((shapingOptions & ~ArabicShaping.DIGITS_MASK) | lettersDir);
+        }
+    }
+
+    /**
+     * Performs digit and letter shaping
+     *
+     * @param options Shaping options covering both letters and digits
+     */
+    private void shapeArabic(int options) {
+        if (options != 0) {
+            ArabicShaping shaper = new ArabicShaping(options);
+            try {
+                text = shaper.shape(text);
+            } catch(ArabicShapingException e) {
+            }
+        }
+    }
+
+    private enum ReorderingScheme {
+        LOG_LTR_TO_VIS_LTR {
+            @Override
+            boolean matches(byte inLevel, Order inOrder, byte outLevel, Order outOrder) {
+                return IsLTR(inLevel) && IsLogical(inOrder)
+                        && IsLTR(outLevel) && IsVisual(outOrder);
+            }
+            @Override
+            void doTransform(BidiTransform transform) {
+                transform.shapeArabic(ArabicShaping.TEXT_DIRECTION_LOGICAL, ArabicShaping.TEXT_DIRECTION_LOGICAL);
+                transform.resolve(Bidi.LTR, Bidi.REORDER_DEFAULT);
+                transform.reorder();
+            }
+        },
+        LOG_RTL_TO_VIS_LTR {
+            @Override
+            boolean matches(byte inLevel, Order inOrder, byte outLevel, Order outOrder) {
+                return IsRTL(inLevel) && IsLogical(inOrder)
+                        && IsLTR(outLevel) && IsVisual(outOrder);
+            }
+            @Override
+            void doTransform(BidiTransform transform) {
+                transform.resolve(Bidi.RTL, Bidi.REORDER_DEFAULT);
+                transform.reorder();
+                transform.shapeArabic(ArabicShaping.TEXT_DIRECTION_LOGICAL, ArabicShaping.TEXT_DIRECTION_VISUAL_LTR);
+            }
+        },
+        LOG_LTR_TO_VIS_RTL {
+            @Override
+            boolean matches(byte inLevel, Order inOrder, byte outLevel, Order outOrder) {
+                return IsLTR(inLevel) && IsLogical(inOrder)
+                        && IsRTL(outLevel) && IsVisual(outOrder);
+            }
+            @Override
+            void doTransform(BidiTransform transform) {
+                transform.shapeArabic(ArabicShaping.TEXT_DIRECTION_LOGICAL, ArabicShaping.TEXT_DIRECTION_LOGICAL);
+                transform.resolve(Bidi.LTR, Bidi.REORDER_DEFAULT);
+                transform.reorder();
+                transform.reverse();
+            }
+        },
+        LOG_RTL_TO_VIS_RTL {
+            @Override
+            boolean matches(byte inLevel, Order inOrder, byte outLevel, Order outOrder) {
+                return IsRTL(inLevel) && IsLogical(inOrder)
+                        && IsRTL(outLevel) && IsVisual(outOrder);
+            }
+            @Override
+            void doTransform(BidiTransform transform) {
+                transform.resolve(Bidi.RTL, Bidi.REORDER_DEFAULT);
+                transform.reorder();
+                transform.shapeArabic(ArabicShaping.TEXT_DIRECTION_LOGICAL, ArabicShaping.TEXT_DIRECTION_VISUAL_LTR);
+                transform.reverse();
+            }
+        },
+        VIS_LTR_TO_LOG_RTL {
+            @Override
+            boolean matches(byte inLevel, Order inOrder, byte outLevel, Order outOrder) {
+                return IsLTR(inLevel) && IsVisual(inOrder)
+                        && IsRTL(outLevel) && IsLogical(outOrder);
+            }
+            @Override
+            void doTransform(BidiTransform transform) {
+                transform.shapeArabic(ArabicShaping.TEXT_DIRECTION_LOGICAL, ArabicShaping.TEXT_DIRECTION_VISUAL_LTR);
+                transform.resolve(Bidi.RTL, Bidi.REORDER_INVERSE_LIKE_DIRECT);
+                transform.reorder();
+            }
+        },
+        VIS_RTL_TO_LOG_RTL {
+            @Override
+            boolean matches(byte inLevel, Order inOrder, byte outLevel, Order outOrder) {
+                return IsRTL(inLevel) && IsVisual(inOrder)
+                        && IsRTL(outLevel) && IsLogical(outOrder);
+            }
+            @Override
+            void doTransform(BidiTransform transform) {
+                transform.reverse();
+                transform.shapeArabic(ArabicShaping.TEXT_DIRECTION_LOGICAL, ArabicShaping.TEXT_DIRECTION_VISUAL_LTR);
+                transform.resolve(Bidi.RTL, Bidi.REORDER_INVERSE_LIKE_DIRECT);
+                transform.reorder();
+            }
+        },
+        VIS_LTR_TO_LOG_LTR {
+            @Override
+            boolean matches(byte inLevel, Order inOrder, byte outLevel, Order outOrder) {
+                return IsLTR(inLevel) && IsVisual(inOrder)
+                        && IsLTR(outLevel) && IsLogical(outOrder);
+            }
+            @Override
+            void doTransform(BidiTransform transform) {
+                transform.resolve(Bidi.LTR, Bidi.REORDER_INVERSE_LIKE_DIRECT);
+                transform.reorder();
+                transform.shapeArabic(ArabicShaping.TEXT_DIRECTION_LOGICAL, ArabicShaping.TEXT_DIRECTION_LOGICAL);
+            }
+        },
+        VIS_RTL_TO_LOG_LTR {
+            @Override
+            boolean matches(byte inLevel, Order inOrder, byte outLevel, Order outOrder) {
+                return IsRTL(inLevel) && IsVisual(inOrder)
+                        && IsLTR(outLevel) && IsLogical(outOrder);
+            }
+            @Override
+            void doTransform(BidiTransform transform) {
+                transform.reverse();
+                transform.resolve(Bidi.LTR, Bidi.REORDER_INVERSE_LIKE_DIRECT);
+                transform.reorder();
+                transform.shapeArabic(ArabicShaping.TEXT_DIRECTION_LOGICAL, ArabicShaping.TEXT_DIRECTION_LOGICAL);
+            }
+        },
+        LOG_LTR_TO_LOG_RTL {
+            @Override
+            boolean matches(byte inLevel, Order inOrder, byte outLevel, Order outOrder) {
+                return IsLTR(inLevel) && IsLogical(inOrder)
+                        && IsRTL(outLevel) && IsLogical(outOrder);
+            }
+            @Override
+            void doTransform(BidiTransform transform) {
+                transform.shapeArabic(ArabicShaping.TEXT_DIRECTION_LOGICAL, ArabicShaping.TEXT_DIRECTION_LOGICAL);
+                transform.resolve(Bidi.LTR, Bidi.REORDER_DEFAULT);
+                transform.mirror();
+                transform.resolve(Bidi.LTR, Bidi.REORDER_RUNS_ONLY);
+                transform.reorder();
+            }
+        },
+        LOG_RTL_TO_LOG_LTR {
+            @Override
+            boolean matches(byte inLevel, Order inOrder, byte outLevel, Order outOrder) {
+                return IsRTL(inLevel) && IsLogical(inOrder)
+                        && IsLTR(outLevel) && IsLogical(outOrder);
+            }
+            @Override
+            void doTransform(BidiTransform transform) {
+                transform.resolve(Bidi.RTL, Bidi.REORDER_DEFAULT);
+                transform.mirror();
+                transform.resolve(Bidi.RTL, Bidi.REORDER_RUNS_ONLY);
+                transform.reorder();
+                transform.shapeArabic(ArabicShaping.TEXT_DIRECTION_LOGICAL, ArabicShaping.TEXT_DIRECTION_LOGICAL);
+            }
+        },
+        VIS_LTR_TO_VIS_RTL {
+            @Override
+            boolean matches(byte inLevel, Order inOrder, byte outLevel, Order outOrder) {
+                return IsLTR(inLevel) && IsVisual(inOrder)
+                        && IsRTL(outLevel) && IsVisual(outOrder);
+            }
+            @Override
+            void doTransform(BidiTransform transform) {
+                transform.resolve(Bidi.LTR, Bidi.REORDER_DEFAULT);
+                transform.mirror();
+                transform.shapeArabic(ArabicShaping.TEXT_DIRECTION_LOGICAL, ArabicShaping.TEXT_DIRECTION_VISUAL_LTR);
+                transform.reverse();
+            }
+        },
+        VIS_RTL_TO_VIS_LTR {
+            @Override
+            boolean matches(byte inLevel, Order inOrder, byte outLevel, Order outOrder) {
+                return IsRTL(inLevel) && IsVisual(inOrder)
+                        && IsLTR(outLevel) && IsVisual(outOrder);
+            }
+            @Override
+            void doTransform(BidiTransform transform) {
+                transform.reverse();
+                transform.resolve(Bidi.LTR, Bidi.REORDER_DEFAULT);
+                transform.mirror();
+                transform.shapeArabic(ArabicShaping.TEXT_DIRECTION_LOGICAL, ArabicShaping.TEXT_DIRECTION_VISUAL_LTR);
+            }
+        },
+        LOG_LTR_TO_LOG_LTR {
+            @Override
+            boolean matches(byte inLevel, Order inOrder, byte outLevel, Order outOrder) {
+                return IsLTR(inLevel) && IsLogical(inOrder)
+                        && IsLTR(outLevel) && IsLogical(outOrder);
+            }
+            @Override
+            void doTransform(BidiTransform transform) {
+                transform.resolve(Bidi.LTR, Bidi.REORDER_DEFAULT);
+                transform.mirror();
+                transform.shapeArabic(ArabicShaping.TEXT_DIRECTION_LOGICAL, ArabicShaping.TEXT_DIRECTION_LOGICAL);
+            }
+        },
+        LOG_RTL_TO_LOG_RTL {
+            @Override
+            boolean matches(byte inLevel, Order inOrder, byte outLevel, Order outOrder) {
+                return IsRTL(inLevel) && IsLogical(inOrder)
+                        && IsRTL(outLevel) && IsLogical(outOrder);
+            }
+            @Override
+            void doTransform(BidiTransform transform) {
+                transform.resolve(Bidi.RTL, Bidi.REORDER_DEFAULT);
+                transform.mirror();
+                transform.shapeArabic(ArabicShaping.TEXT_DIRECTION_VISUAL_LTR, ArabicShaping.TEXT_DIRECTION_LOGICAL);
+            }
+        },
+        VIS_LTR_TO_VIS_LTR {
+            @Override
+            boolean matches(byte inLevel, Order inOrder, byte outLevel, Order outOrder) {
+                return IsLTR(inLevel) && IsVisual(inOrder)
+                        && IsLTR(outLevel) && IsVisual(outOrder);
+            }
+            @Override
+            void doTransform(BidiTransform transform) {
+                transform.resolve(Bidi.LTR, Bidi.REORDER_DEFAULT);
+                transform.mirror();
+                transform.shapeArabic(ArabicShaping.TEXT_DIRECTION_LOGICAL, ArabicShaping.TEXT_DIRECTION_VISUAL_LTR);
+            }
+        },
+        VIS_RTL_TO_VIS_RTL {
+            @Override
+            boolean matches(byte inLevel, Order inOrder, byte outLevel, Order outOrder) {
+                return IsRTL(inLevel) && IsVisual(inOrder)
+                        && IsRTL(outLevel) && IsVisual(outOrder);
+            }
+            @Override
+            void doTransform(BidiTransform transform) {
+                transform.reverse();
+                transform.resolve(Bidi.LTR, Bidi.REORDER_DEFAULT);
+                transform.mirror();
+                transform.shapeArabic(ArabicShaping.TEXT_DIRECTION_LOGICAL, ArabicShaping.TEXT_DIRECTION_VISUAL_LTR);
+                transform.reverse();
+            }
+        };
+
+        /**
+         * Indicates whether this scheme matches another one in terms of
+         * equality of base direction and ordering scheme.
+         *
+         * @param inLevel Base level of the input text
+         * @param inOrder Order of the input text
+         * @param outLevel Base level of the output text
+         * @param outOrder Order of the output text
+         *
+         * @return <code>true</code> if it's a match, <code>false</code>
+         * otherwise
+         */
+        abstract boolean matches(byte inLevel, Order inOrder, byte outLevel, Order outOrder);
+
+        /**
+         * Performs a series of bidi layout transformations unique for the current
+         * scheme.
+
+         * @param transform Bidi transformation engine
+         */
+        abstract void doTransform(BidiTransform transform);
+    }
+
+    /**
+     * Is level LTR? convenience method
+
+     * @param level Embedding level
+     */
+    private static boolean IsLTR(byte level) {
+        return (level & 1) == 0;
+    }
+
+    /**
+     * Is level RTL? convenience method
+
+     * @param level Embedding level
+     */
+    private static boolean IsRTL(byte level) {
+        return (level & 1) == 1;
+    }
+
+    /**
+     * Is order logical? convenience method
+
+     * @param level Order value
+     */
+    private static boolean IsLogical(Order order) {
+        return Order.LOGICAL.equals(order);
+    }
+
+    /**
+     * Is order visual? convenience method
+
+     * @param level Order value
+     */
+    private static boolean IsVisual(Order order) {
+        return Order.VISUAL.equals(order);
+    }
+
+}
diff --git a/app/src/main/java/com/ibm/icu/text/BidiWriter.java b/icu4j/src/main/java/com/ibm/icu/text/BidiWriter.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/BidiWriter.java
rename to icu4j/src/main/java/com/ibm/icu/text/BidiWriter.java
index e3a03aa..5431688 100644
--- a/app/src/main/java/com/ibm/icu/text/BidiWriter.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/BidiWriter.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 *   Copyright (C) 2001-2010, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/text/BreakIterator.java b/icu4j/src/main/java/com/ibm/icu/text/BreakIterator.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/BreakIterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/BreakIterator.java
index 38aa860..fefeea0 100644
--- a/app/src/main/java/com/ibm/icu/text/BreakIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/BreakIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and    *
@@ -7,12 +9,12 @@
 
 package com.ibm.icu.text;
 
-import java.lang.ref.SoftReference;
 import java.text.CharacterIterator;
 import java.text.StringCharacterIterator;
 import java.util.Locale;
 import java.util.MissingResourceException;
 
+import com.ibm.icu.impl.CacheValue;
 import com.ibm.icu.impl.ICUDebug;
 import com.ibm.icu.util.ICUCloneNotSupportedException;
 import com.ibm.icu.util.ULocale;
@@ -229,6 +231,7 @@ public abstract class BreakIterator implements Cloneable
      * @return The clone.
      * @stable ICU 2.0
      */
+    @Override
     public Object clone()
     {
         try {
@@ -378,52 +381,52 @@ public abstract class BreakIterator implements Cloneable
      */
     public abstract int current();
 
-    
-    /** 
-     * Tag value for "words" that do not fit into any of other categories. 
-     * Includes spaces and most punctuation. 
+
+    /**
+     * Tag value for "words" that do not fit into any of other categories.
+     * Includes spaces and most punctuation.
      * @stable ICU 53
      */
     public static final int WORD_NONE           = 0;
 
     /**
-     * Upper bound for tags for uncategorized words. 
+     * Upper bound for tags for uncategorized words.
      * @stable ICU 53
      */
     public static final int WORD_NONE_LIMIT     = 100;
 
     /**
-     * Tag value for words that appear to be numbers, lower limit. 
+     * Tag value for words that appear to be numbers, lower limit.
      * @stable ICU 53
      */
     public static final int WORD_NUMBER         = 100;
 
-    /** 
+    /**
      * Tag value for words that appear to be numbers, upper limit.
      * @stable ICU 53
      */
     public static final int WORD_NUMBER_LIMIT   = 200;
 
-    /** 
+    /**
      * Tag value for words that contain letters, excluding
-     * hiragana, katakana or ideographic characters, lower limit. 
+     * hiragana, katakana or ideographic characters, lower limit.
      * @stable ICU 53
      */
     public static final int WORD_LETTER         = 200;
 
-    /** 
-     * Tag value for words containing letters, upper limit 
+    /**
+     * Tag value for words containing letters, upper limit
      * @stable ICU 53
      */
     public static final int WORD_LETTER_LIMIT   = 300;
 
-    /** 
+    /**
      * Tag value for words containing kana characters, lower limit
      * @stable ICU 53
      */
     public static final int WORD_KANA           = 300;
 
-    /** 
+    /**
      * Tag value for words containing kana characters, upper limit
      * @stable ICU 53
      */
@@ -556,7 +559,7 @@ public abstract class BreakIterator implements Cloneable
      */
     private static final int KIND_COUNT = 5;
 
-    private static final SoftReference<?>[] iterCache = new SoftReference<?>[5];
+    private static final CacheValue<?>[] iterCache = new CacheValue<?>[5];
 
     /**
      * Returns a new instance of BreakIterator that locates word boundaries.
@@ -762,11 +765,11 @@ s     */
      * {@icu} Registers a new break iterator of the indicated kind, to use in the given
      * locale.  Clones of the iterator will be returned if a request for a break iterator
      * of the given kind matches or falls back to this locale.
-     * 
+     *
      * <p>Because ICU may choose to cache BreakIterator objects internally, this must
      * be called at application startup, prior to any calls to
      * BreakIterator.getInstance to avoid undefined behavior.
-     * 
+     *
      * @param iter the BreakIterator instance to adopt.
      * @param locale the Locale for which this instance is to be registered
      * @param kind the type of iterator for which this instance is to be registered
@@ -781,11 +784,11 @@ s     */
      * {@icu} Registers a new break iterator of the indicated kind, to use in the given
      * locale.  Clones of the iterator will be returned if a request for a break iterator
      * of the given kind matches or falls back to this locale.
-     * 
+     *
      * <p>Because ICU may choose to cache BreakIterator objects internally, this must
      * be called at application startup, prior to any calls to
      * BreakIterator.getInstance to avoid undefined behavior.
-     * 
+     *
      * @param iter the BreakIterator instance to adopt.
      * @param locale the Locale for which this instance is to be registered
      * @param kind the type of iterator for which this instance is to be registered
@@ -867,7 +870,7 @@ s     */
         BreakIterator result = getShim().createBreakIterator(where, kind);
 
         BreakIteratorCache cache = new BreakIteratorCache(where, result);
-        iterCache[kind] = new SoftReference<BreakIteratorCache>(cache);
+        iterCache[kind] = CacheValue.getInstance(cache);
         if (result instanceof RuleBasedBreakIterator) {
             RuleBasedBreakIterator rbbi = (RuleBasedBreakIterator)result;
             rbbi.setBreakType(kind);
diff --git a/app/src/main/java/com/ibm/icu/text/BreakIteratorFactory.java b/icu4j/src/main/java/com/ibm/icu/text/BreakIteratorFactory.java
similarity index 87%
rename from app/src/main/java/com/ibm/icu/text/BreakIteratorFactory.java
rename to icu4j/src/main/java/com/ibm/icu/text/BreakIteratorFactory.java
index 9cf9d02..e08e335 100644
--- a/app/src/main/java/com/ibm/icu/text/BreakIteratorFactory.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/BreakIteratorFactory.java
@@ -1,6 +1,8 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2002-2015, International Business Machines Corporation and
+ * Copyright (C) 2002-2016, International Business Machines Corporation and
  * others. All Rights Reserved.
  *******************************************************************************
  */
@@ -31,11 +33,13 @@ import com.ibm.icu.util.ULocale;
  */
 final class BreakIteratorFactory extends BreakIterator.BreakIteratorServiceShim {
 
+    @Override
     public Object registerInstance(BreakIterator iter, ULocale locale, int kind) {
         iter.setText(new java.text.StringCharacterIterator(""));
         return service.registerObject(iter, locale, kind);
     }
 
+    @Override
     public boolean unregister(Object key) {
         if (service.isDefault()) {
             return false;
@@ -43,6 +47,7 @@ final class BreakIteratorFactory extends BreakIterator.BreakIteratorServiceShim
         return service.unregisterFactory((Factory)key);
     }
 
+    @Override
     public Locale[] getAvailableLocales() {
         if (service == null) {
             return ICUResourceBundle.getAvailableLocales();
@@ -51,6 +56,7 @@ final class BreakIteratorFactory extends BreakIterator.BreakIteratorServiceShim
         }
     }
 
+    @Override
     public ULocale[] getAvailableULocales() {
         if (service == null) {
             return ICUResourceBundle.getAvailableULocales();
@@ -59,6 +65,7 @@ final class BreakIteratorFactory extends BreakIterator.BreakIteratorServiceShim
         }
     }
 
+    @Override
     public BreakIterator createBreakIterator(ULocale locale, int kind) {
     // TODO: convert to ULocale when service switches over
         if (service.isDefault()) {
@@ -75,6 +82,7 @@ final class BreakIteratorFactory extends BreakIterator.BreakIteratorServiceShim
             super("BreakIterator");
 
             class RBBreakIteratorFactory extends ICUResourceBundleFactory {
+                @Override
                 protected Object handleCreate(ULocale loc, int kind, ICUService srvc) {
                     return createBreakInstance(loc, kind);
                 }
@@ -113,8 +121,8 @@ final class BreakIteratorFactory extends BreakIterator.BreakIteratorServiceShim
     private static BreakIterator createBreakInstance(ULocale locale, int kind) {
 
         RuleBasedBreakIterator    iter = null;
-        ICUResourceBundle rb           = (ICUResourceBundle)ICUResourceBundle.
-                getBundleInstance(ICUResourceBundle.ICU_BRKITR_BASE_NAME, locale,
+        ICUResourceBundle rb           = ICUResourceBundle.
+                getBundleInstance(ICUData.ICU_BRKITR_BASE_NAME, locale,
                         ICUResourceBundle.OpenType.LOCALE_ROOT);
 
         //
@@ -128,6 +136,7 @@ final class BreakIteratorFactory extends BreakIterator.BreakIteratorServiceShim
                 typeKeyExt = "_" + lbKeyValue;
             }
         }
+
         try {
             String         typeKey       = (typeKeyExt == null)? KIND_NAMES[kind]: KIND_NAMES[kind] + typeKeyExt;
             String         brkfname      = rb.getStringWithFallback("boundaries/" + typeKey);
@@ -154,6 +163,15 @@ final class BreakIteratorFactory extends BreakIterator.BreakIteratorServiceShim
         iter.setLocale(uloc, uloc);
         iter.setBreakType(kind);
 
+        // filtered break
+        if (kind == BreakIterator.KIND_SENTENCE) {
+            final String ssKeyword = locale.getKeywordValue("ss");
+            if (ssKeyword != null && ssKeyword.equals("standard")) {
+                final ULocale base = new ULocale(locale.getBaseName());
+                return FilteredBreakIteratorBuilder.createInstance(base).build(iter);
+            }
+        }
+
         return iter;
 
     }
diff --git a/app/src/main/java/com/ibm/icu/text/BreakTransliterator.java b/icu4j/src/main/java/com/ibm/icu/text/BreakTransliterator.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/text/BreakTransliterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/BreakTransliterator.java
index 005ea36..3c9ed7d 100644
--- a/app/src/main/java/com/ibm/icu/text/BreakTransliterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/BreakTransliterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2014, International Business Machines Corporation and
@@ -71,6 +73,7 @@ final class BreakTransliterator extends Transliterator {
         | (1<<Character.NON_SPACING_MARK)
         | (1<<Character.ENCLOSING_MARK)
         ;
+    @Override
     protected synchronized void handleTransliterate(Replaceable text, Position pos, boolean incremental) {
         boundaryCount = 0;
         int boundary = 0;
@@ -228,6 +231,7 @@ final class BreakTransliterator extends Transliterator {
         * Implements CharacterIterator.first() for String.
         * @see CharacterIterator#first
         */
+        @Override
         public char first()
         {
             pos = begin;
@@ -238,6 +242,7 @@ final class BreakTransliterator extends Transliterator {
         * Implements CharacterIterator.last() for String.
         * @see CharacterIterator#last
         */
+        @Override
         public char last()
         {
             if (end != begin) {
@@ -252,6 +257,7 @@ final class BreakTransliterator extends Transliterator {
         * Implements CharacterIterator.setIndex() for String.
         * @see CharacterIterator#setIndex
         */
+        @Override
         public char setIndex(int p)
         {
         if (p < begin || p > end) {
@@ -265,6 +271,7 @@ final class BreakTransliterator extends Transliterator {
         * Implements CharacterIterator.current() for String.
         * @see CharacterIterator#current
         */
+        @Override
         public char current()
         {
             if (pos >= begin && pos < end) {
@@ -279,6 +286,7 @@ final class BreakTransliterator extends Transliterator {
         * Implements CharacterIterator.next() for String.
         * @see CharacterIterator#next
         */
+        @Override
         public char next()
         {
             if (pos < end - 1) {
@@ -295,6 +303,7 @@ final class BreakTransliterator extends Transliterator {
         * Implements CharacterIterator.previous() for String.
         * @see CharacterIterator#previous
         */
+        @Override
         public char previous()
         {
             if (pos > begin) {
@@ -310,6 +319,7 @@ final class BreakTransliterator extends Transliterator {
         * Implements CharacterIterator.getBeginIndex() for String.
         * @see CharacterIterator#getBeginIndex
         */
+        @Override
         public int getBeginIndex()
         {
             return begin;
@@ -319,6 +329,7 @@ final class BreakTransliterator extends Transliterator {
         * Implements CharacterIterator.getEndIndex() for String.
         * @see CharacterIterator#getEndIndex
         */
+        @Override
         public int getEndIndex()
         {
             return end;
@@ -328,6 +339,7 @@ final class BreakTransliterator extends Transliterator {
         * Implements CharacterIterator.getIndex() for String.
         * @see CharacterIterator#getIndex
         */
+        @Override
         public int getIndex()
         {
             return pos;
@@ -339,6 +351,7 @@ final class BreakTransliterator extends Transliterator {
         * @return true if the given obj is the same as this
         * ReplaceableCharacterIterator object; false otherwise.
         */
+        @Override
         public boolean equals(Object obj)
         {
             if (this == obj) {
@@ -366,6 +379,7 @@ final class BreakTransliterator extends Transliterator {
         * Computes a hashcode for this iterator.
         * @return A hash code
         */
+        @Override
         public int hashCode()
         {
             return text.hashCode() ^ pos ^ begin ^ end;
@@ -375,6 +389,7 @@ final class BreakTransliterator extends Transliterator {
         * Creates a copy of this iterator.
         * @return A copy of this
         */
+        @Override
         public Object clone()
         {
             try {
diff --git a/app/src/main/java/com/ibm/icu/text/BurmeseBreakEngine.java b/icu4j/src/main/java/com/ibm/icu/text/BurmeseBreakEngine.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/text/BurmeseBreakEngine.java
rename to icu4j/src/main/java/com/ibm/icu/text/BurmeseBreakEngine.java
index f70e8bf..141e3e0 100644
--- a/app/src/main/java/com/ibm/icu/text/BurmeseBreakEngine.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/BurmeseBreakEngine.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014, International Business Machines Corporation and         *
@@ -14,7 +16,7 @@ import com.ibm.icu.lang.UProperty;
 import com.ibm.icu.lang.UScript;
 
 class BurmeseBreakEngine extends DictionaryBreakEngine {
-    
+
     // Constants for BurmeseBreakIterator
     // How many words in a row are "good enough"?
     private static final byte BURMESE_LOOKAHEAD = 3;
@@ -25,13 +27,13 @@ class BurmeseBreakEngine extends DictionaryBreakEngine {
     private static final byte BURMESE_PREFIX_COMBINE_THRESHOLD = 3;
     // Minimum word size
     private static final byte BURMESE_MIN_WORD = 2;
-    
+
     private DictionaryMatcher fDictionary;
     private static UnicodeSet fBurmeseWordSet;
     private static UnicodeSet fEndWordSet;
     private static UnicodeSet fBeginWordSet;
     private static UnicodeSet fMarkSet;
-    
+
     static {
         // Initialize UnicodeSets
         fBurmeseWordSet = new UnicodeSet();
@@ -50,14 +52,14 @@ class BurmeseBreakEngine extends DictionaryBreakEngine {
         fMarkSet.compact();
         fEndWordSet.compact();
         fBeginWordSet.compact();
-        
+
         // Freeze the static UnicodeSet
         fBurmeseWordSet.freeze();
         fMarkSet.freeze();
         fEndWordSet.freeze();
         fBeginWordSet.freeze();
     }
-    
+
     public BurmeseBreakEngine() throws IOException {
         super(BreakIterator.KIND_WORD, BreakIterator.KIND_LINE);
         setCharacters(fBurmeseWordSet);
@@ -65,16 +67,19 @@ class BurmeseBreakEngine extends DictionaryBreakEngine {
         fDictionary = DictionaryData.loadDictionaryFor("Mymr");
     }
 
+    @Override
     public boolean equals(Object obj) {
         // Normally is a singleton, but it's possible to have duplicates
         //   during initialization. All are equivalent.
         return obj instanceof BurmeseBreakEngine;
     }
 
+    @Override
     public int hashCode() {
         return getClass().hashCode();
     }
-    
+
+    @Override
     public boolean handles(int c, int breakType) {
         if (breakType == BreakIterator.KIND_WORD || breakType == BreakIterator.KIND_LINE) {
             int script = UCharacter.getIntPropertyValue(c, UProperty.SCRIPT);
@@ -83,10 +88,11 @@ class BurmeseBreakEngine extends DictionaryBreakEngine {
         return false;
     }
 
+    @Override
     public int divideUpDictionaryRange(CharacterIterator fIter, int rangeStart, int rangeEnd,
             DequeI foundBreaks) {
-        
-        
+
+
         if ((rangeEnd - rangeStart) < BURMESE_MIN_WORD) {
             return 0;  // Not enough characters for word
         }
@@ -157,7 +163,7 @@ class BurmeseBreakEngine extends DictionaryBreakEngine {
                 // no preceding word, or the non-word shares less than the minimum threshold
                 // of characters with a dictionary word, then scan to resynchronize
                 if (words[wordsFound%BURMESE_LOOKAHEAD].candidates(fIter, fDictionary, rangeEnd) <= 0 &&
-                        (wordLength == 0 || 
+                        (wordLength == 0 ||
                                 words[wordsFound%BURMESE_LOOKAHEAD].longestPrefix() < BURMESE_PREFIX_COMBINE_THRESHOLD)) {
                     // Look for a plausible word boundary
                     int remaining = rangeEnd - (current + wordLength);
@@ -203,7 +209,7 @@ class BurmeseBreakEngine extends DictionaryBreakEngine {
 
             // Look ahead for possible suffixes if a dictionary word does not follow.
             // We do this in code rather than using a rule so that the heuristic
-            // resynch continues to function. For example, one of the suffix characters 
+            // resynch continues to function. For example, one of the suffix characters
             // could be a typo in the middle of a word.
             // NOT CURRENTLY APPLICABLE TO BURMESE
 
diff --git a/app/src/main/java/com/ibm/icu/text/BytesDictionaryMatcher.java b/icu4j/src/main/java/com/ibm/icu/text/BytesDictionaryMatcher.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/text/BytesDictionaryMatcher.java
rename to icu4j/src/main/java/com/ibm/icu/text/BytesDictionaryMatcher.java
index 0a50c0a..b7c5f5c 100644
--- a/app/src/main/java/com/ibm/icu/text/BytesDictionaryMatcher.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/BytesDictionaryMatcher.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014, International Business Machines Corporation and         *
@@ -15,7 +17,7 @@ import com.ibm.icu.util.BytesTrie.Result;
 class BytesDictionaryMatcher extends DictionaryMatcher {
     private final byte[] characters;
     private final int transform;
-    
+
     public BytesDictionaryMatcher(byte[] chars, int transform) {
         characters = chars;
         Assert.assrt((transform & DictionaryData.TRANSFORM_TYPE_MASK) == DictionaryData.TRANSFORM_TYPE_OFFSET);
@@ -24,9 +26,9 @@ class BytesDictionaryMatcher extends DictionaryMatcher {
         // than adding a "transform type" variable
         this.transform = transform;
     }
-    
+
     private int transform(int c) {
-        if (c == 0x200D) { 
+        if (c == 0x200D) {
             return 0xFF;
         } else if (c == 0x200C) {
             return 0xFE;
@@ -39,6 +41,7 @@ class BytesDictionaryMatcher extends DictionaryMatcher {
         return delta;
     }
 
+    @Override
     public int matches(CharacterIterator text_, int maxLength, int[] lengths, int[] count_, int limit, int[] values) {
         UCharacterIterator text = UCharacterIterator.getInstance(text_);
         BytesTrie bt = new BytesTrie(characters, 0);
@@ -81,6 +84,7 @@ class BytesDictionaryMatcher extends DictionaryMatcher {
         return numChars;
     }
 
+    @Override
     public int getType() {
         return DictionaryData.TRIE_TYPE_BYTES;
     }
diff --git a/app/src/main/java/com/ibm/icu/text/CanonicalIterator.java b/icu4j/src/main/java/com/ibm/icu/text/CanonicalIterator.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/CanonicalIterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/CanonicalIterator.java
index ba78d00..34a1560 100644
--- a/app/src/main/java/com/ibm/icu/text/CanonicalIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CanonicalIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2014, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/CaseFoldTransliterator.java b/icu4j/src/main/java/com/ibm/icu/text/CaseFoldTransliterator.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/text/CaseFoldTransliterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/CaseFoldTransliterator.java
index b256e18..c7b936e 100644
--- a/app/src/main/java/com/ibm/icu/text/CaseFoldTransliterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CaseFoldTransliterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2011, Google, International Business Machines Corporation
@@ -19,7 +21,7 @@ class CaseFoldTransliterator extends Transliterator{
      * Package accessible ID.
      */
     static final String _ID = "Any-CaseFold";
-    
+
     // TODO: Add variants for tr, az, lt, default = default locale
 
     /**
@@ -27,6 +29,7 @@ class CaseFoldTransliterator extends Transliterator{
      */
     static void register() {
         Transliterator.registerFactory(_ID, new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new CaseFoldTransliterator();
             }
@@ -35,7 +38,7 @@ class CaseFoldTransliterator extends Transliterator{
         Transliterator.registerSpecialInverse("CaseFold", "Upper", false);
     }
 
-    private UCaseProps csp;
+    private final UCaseProps csp;
     private ReplaceableContextIterator iter;
     private StringBuilder result;
 
@@ -53,6 +56,7 @@ class CaseFoldTransliterator extends Transliterator{
     /**
      * Implements {@link Transliterator#handleTransliterate}.
      */
+    @Override
     protected synchronized void handleTransliterate(Replaceable text,
                                        Position offsets, boolean isIncremental) {
         if(csp==null) {
@@ -61,7 +65,7 @@ class CaseFoldTransliterator extends Transliterator{
 
         if(offsets.start >= offsets.limit) {
             return;
-        } 
+        }
 
         iter.setText(text);
         result.setLength(0);
@@ -103,9 +107,9 @@ class CaseFoldTransliterator extends Transliterator{
         }
         offsets.start = offsets.limit;
     }
-    
+
     static SourceTargetUtility sourceTargetUtility = null;
-    
+
     /* (non-Javadoc)
      * @see com.ibm.icu.text.Transliterator#addSourceTargetSet(com.ibm.icu.text.UnicodeSet, com.ibm.icu.text.UnicodeSet, com.ibm.icu.text.UnicodeSet)
      */
@@ -114,6 +118,7 @@ class CaseFoldTransliterator extends Transliterator{
         synchronized (UppercaseTransliterator.class) {
             if (sourceTargetUtility == null) {
                 sourceTargetUtility = new SourceTargetUtility(new Transform<String,String>() {
+                    @Override
                     public String transform(String source) {
                         return UCharacter.foldCase(source, true);
                     }
diff --git a/app/src/main/java/com/ibm/icu/text/CharsDictionaryMatcher.java b/icu4j/src/main/java/com/ibm/icu/text/CharsDictionaryMatcher.java
similarity index 92%
rename from app/src/main/java/com/ibm/icu/text/CharsDictionaryMatcher.java
rename to icu4j/src/main/java/com/ibm/icu/text/CharsDictionaryMatcher.java
index 58fd714..f1c2a91 100644
--- a/app/src/main/java/com/ibm/icu/text/CharsDictionaryMatcher.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CharsDictionaryMatcher.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014, International Business Machines Corporation and         *
@@ -13,11 +15,12 @@ import com.ibm.icu.util.CharsTrie;
 
 class CharsDictionaryMatcher extends DictionaryMatcher {
     private CharSequence characters;
-    
+
     public CharsDictionaryMatcher(CharSequence chars) {
         characters = chars;
     }
 
+    @Override
     public int matches(CharacterIterator text_, int maxLength, int[] lengths, int[] count_, int limit, int[] values) {
         UCharacterIterator text = UCharacterIterator.getInstance(text_);
         CharsTrie uct = new CharsTrie(characters, 0);
@@ -51,7 +54,7 @@ class CharsDictionaryMatcher extends DictionaryMatcher {
             }
             c = text.nextCodePoint();
             if (c == UCharacterIterator.DONE) {
-                break;                
+                break;
             }
             ++numChars;
             result = uct.nextForCodePoint(c);
@@ -60,6 +63,7 @@ class CharsDictionaryMatcher extends DictionaryMatcher {
         return numChars;
     }
 
+    @Override
     public int getType() {
         return DictionaryData.TRIE_TYPE_UCHARS;
     }
diff --git a/app/src/main/java/com/ibm/icu/text/CharsetDetector.java b/icu4j/src/main/java/com/ibm/icu/text/CharsetDetector.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/CharsetDetector.java
rename to icu4j/src/main/java/com/ibm/icu/text/CharsetDetector.java
index d7421c3..f58a202 100644
--- a/app/src/main/java/com/ibm/icu/text/CharsetDetector.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CharsetDetector.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
 *******************************************************************************
 * Copyright (C) 2005-2016, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/CharsetMatch.java b/icu4j/src/main/java/com/ibm/icu/text/CharsetMatch.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/text/CharsetMatch.java
rename to icu4j/src/main/java/com/ibm/icu/text/CharsetMatch.java
index c7a14a7..c695233 100644
--- a/app/src/main/java/com/ibm/icu/text/CharsetMatch.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CharsetMatch.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
 *******************************************************************************
 * Copyright (C) 2005-2016, International Business Machines Corporation and    *
@@ -28,13 +30,13 @@ import java.io.Reader;
  */
 public class CharsetMatch implements Comparable<CharsetMatch> {
 
-    
+
     /**
      * Create a java.io.Reader for reading the Unicode character data corresponding
      * to the original byte data supplied to the Charset detect operation.
      * <p>
      * CAUTION:  if the source of the byte data was an InputStream, a Reader
-     * can be created for only one matching char set using this method.  If more 
+     * can be created for only one matching char set using this method.  If more
      * than one charset needs to be tried, the caller will need to reset
      * the InputStream and create InputStreamReaders itself, based on the charset name.
      *
@@ -44,11 +46,11 @@ public class CharsetMatch implements Comparable<CharsetMatch> {
      */
     public Reader getReader() {
         InputStream inputStream = fInputStream;
-        
+
         if (inputStream == null) {
             inputStream = new ByteArrayInputStream(fRawInput, 0, fRawLength);
         }
-        
+
         try {
             inputStream.reset();
             return new InputStreamReader(inputStream, getName());
@@ -92,14 +94,14 @@ public class CharsetMatch implements Comparable<CharsetMatch> {
             Reader reader = getReader();
             int max = maxLength < 0? Integer.MAX_VALUE : maxLength;
             int bytesRead = 0;
-            
+
             while ((bytesRead = reader.read(buffer, 0, Math.min(max, 1024))) >= 0) {
                 sb.append(buffer, 0, bytesRead);
                 max -= bytesRead;
             }
-            
+
             reader.close();
-            
+
             return sb.toString();
         } else {
             String name = getName();
@@ -117,7 +119,7 @@ public class CharsetMatch implements Comparable<CharsetMatch> {
         return result;
 
     }
-    
+
     /**
      * Get an indication of the confidence in the charset detected.
      * Confidence values range from 0-100, with larger numbers indicating
@@ -133,7 +135,7 @@ public class CharsetMatch implements Comparable<CharsetMatch> {
     }
 
     /**
-     * Get the name of the detected charset.  
+     * Get the name of the detected charset.
      * The name will be one that can be used with other APIs on the
      * platform that accept charset names.  It is the "Canonical name"
      * as defined by the class java.nio.charset.Charset; for
@@ -150,9 +152,9 @@ public class CharsetMatch implements Comparable<CharsetMatch> {
     public String getName() {
         return fCharsetName;
     }
-    
+
     /**
-     * Get the ISO code for the language of the detected charset.  
+     * Get the ISO code for the language of the detected charset.
      *
      * @return The ISO code for the language or <code>null</code> if the language cannot be determined.
      *
@@ -164,17 +166,18 @@ public class CharsetMatch implements Comparable<CharsetMatch> {
 
     /**
      * Compare to other CharsetMatch objects.
-     * Comparison is based on the match confidence value, which 
-     *   allows CharsetDetector.detectAll() to order its results. 
+     * Comparison is based on the match confidence value, which
+     *   allows CharsetDetector.detectAll() to order its results.
      *
      * @param other the CharsetMatch object to compare against.
-     * @return  a negative integer, zero, or a positive integer as the 
+     * @return  a negative integer, zero, or a positive integer as the
      *          confidence level of this CharsetMatch
      *          is less than, equal to, or greater than that of
      *          the argument.
      * @throws ClassCastException if the argument is not a CharsetMatch.
      * @stable ICU 4.4
      */
+    @Override
     public int compareTo (CharsetMatch other) {
         int compareResult = 0;
         if (this.fConfidence > other.fConfidence) {
@@ -190,7 +193,7 @@ public class CharsetMatch implements Comparable<CharsetMatch> {
      */
     CharsetMatch(CharsetDetector det, CharsetRecognizer rec, int conf) {
         fConfidence = conf;
-        
+
         // The references to the original application input data must be copied out
         //   of the charset recognizer to here, in case the application resets the
         //   recognizer before using this CharsetMatch.
@@ -210,7 +213,7 @@ public class CharsetMatch implements Comparable<CharsetMatch> {
      */
     CharsetMatch(CharsetDetector det, CharsetRecognizer rec, int conf, String csName, String lang) {
         fConfidence = conf;
-        
+
         // The references to the original application input data must be copied out
         //   of the charset recognizer to here, in case the application resets the
         //   recognizer before using this CharsetMatch.
@@ -225,7 +228,7 @@ public class CharsetMatch implements Comparable<CharsetMatch> {
         fLang = lang;
     }
 
-    
+
     //
     //   Private Data
     //
@@ -236,7 +239,7 @@ public class CharsetMatch implements Comparable<CharsetMatch> {
 
     private InputStream         fInputStream = null;  // User's input stream, or null if the user
                                                       //   gave us a byte array.
-    
+
     private String              fCharsetName;         // The name of the charset this CharsetMatch
                                                       //   represents.  Filled in by the recognizer.
     private String              fLang;                // The language, if one was determined by
diff --git a/app/src/main/java/com/ibm/icu/text/CharsetRecog_2022.java b/icu4j/src/main/java/com/ibm/icu/text/CharsetRecog_2022.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/text/CharsetRecog_2022.java
rename to icu4j/src/main/java/com/ibm/icu/text/CharsetRecog_2022.java
index e9b2661..712d4f2 100644
--- a/app/src/main/java/com/ibm/icu/text/CharsetRecog_2022.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CharsetRecog_2022.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2005 - 2012, International Business Machines Corporation and  *
@@ -11,19 +13,19 @@ package com.ibm.icu.text;
  *                           This is a superclass for the individual detectors for
  *                           each of the detectable members of the ISO 2022 family
  *                           of encodings.
- * 
+ *
  *                           The separate classes are nested within this class.
  */
 abstract class CharsetRecog_2022 extends CharsetRecognizer {
 
-    
+
     /**
      * Matching function shared among the 2022 detectors JP, CN and KR
      * Counts up the number of legal an unrecognized escape sequences in
      * the sample of text, and computes a score based on the total number &
      * the proportion that fit the encoding.
-     * 
-     * 
+     *
+     *
      * @param text the byte buffer containing text to analyse
      * @param textLen  the size of the text in the byte.
      * @param escapeSequences the byte escape sequences to test for.
@@ -42,59 +44,59 @@ abstract class CharsetRecog_2022 extends CharsetRecognizer {
                     checkEscapes:
                         for (escN=0; escN<escapeSequences.length; escN++) {
                             byte [] seq = escapeSequences[escN];
-                            
+
                             if ((textLen - i) < seq.length) {
                                 continue checkEscapes;
                             }
-                            
+
                             for (j=1; j<seq.length; j++) {
                                 if (seq[j] != text[i+j])  {
                                     continue checkEscapes;
-                                }                                   
+                                }
                             }
-                            
-                            hits++; 
+
+                            hits++;
                             i += seq.length-1;
                             continue scanInput;
                         }
-                
-                        misses++;                  
+
+                        misses++;
                 }
-                
+
                 if (text[i] == 0x0e || text[i] == 0x0f) {
                     // Shift in/out
                     shifts++;
                 }
             }
-        
+
         if (hits == 0) {
             return 0;
         }
-        
+
         //
         // Initial quality is based on relative proportion of recongized vs.
-        //   unrecognized escape sequences. 
+        //   unrecognized escape sequences.
         //   All good:  quality = 100;
         //   half or less good: quality = 0;
         //   linear inbetween.
         quality = (100*hits - 100*misses) / (hits + misses);
-        
+
         // Back off quality if there were too few escape sequences seen.
         //   Include shifts in this computation, so that KR does not get penalized
         //   for having only a single Escape sequence, but many shifts.
         if (hits+shifts < 5) {
             quality -= (5-(hits+shifts))*10;
         }
-        
+
         if (quality < 0) {
             quality = 0;
-        }        
+        }
         return quality;
     }
 
-    
- 
-    
+
+
+
     static class CharsetRecog_2022JP extends CharsetRecog_2022 {
         private byte [] [] escapeSequences = {
                 {0x1b, 0x24, 0x28, 0x43},   // KS X 1001:1992
@@ -110,11 +112,13 @@ abstract class CharsetRecog_2022 extends CharsetRecognizer {
                 {0x1b, 0x2e, 0x41},         // ISO 8859-1
                 {0x1b, 0x2e, 0x46}          // ISO 8859-7
                 };
-        
+
+        @Override
         String getName() {
             return "ISO-2022-JP";
         }
-        
+
+        @Override
         CharsetMatch   match(CharsetDetector det) {
             int confidence = match(det.fInputBytes, det.fInputLen, escapeSequences);
             return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
@@ -123,13 +127,15 @@ abstract class CharsetRecog_2022 extends CharsetRecognizer {
 
     static class CharsetRecog_2022KR extends CharsetRecog_2022 {
         private byte [] [] escapeSequences = {
-                {0x1b, 0x24, 0x29, 0x43}   
+                {0x1b, 0x24, 0x29, 0x43}
                  };
-        
+
+        @Override
         String getName() {
             return "ISO-2022-KR";
         }
-        
+
+        @Override
         CharsetMatch   match(CharsetDetector det) {
             int confidence =  match(det.fInputBytes, det.fInputLen, escapeSequences);
             return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
@@ -150,16 +156,18 @@ abstract class CharsetRecog_2022 extends CharsetRecognizer {
                 {0x1b, 0x4e},               // SS2
                 {0x1b, 0x4f},               // SS3
         };
-        
+
+        @Override
         String getName() {
             return "ISO-2022-CN";
         }
-        
+
+        @Override
         CharsetMatch   match(CharsetDetector det) {
             int confidence = match(det.fInputBytes, det.fInputLen, escapeSequences);
             return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
         }
     }
-    
+
 }
 
diff --git a/app/src/main/java/com/ibm/icu/text/CharsetRecog_UTF8.java b/icu4j/src/main/java/com/ibm/icu/text/CharsetRecog_UTF8.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/text/CharsetRecog_UTF8.java
rename to icu4j/src/main/java/com/ibm/icu/text/CharsetRecog_UTF8.java
index 3735732..0d53253 100644
--- a/app/src/main/java/com/ibm/icu/text/CharsetRecog_UTF8.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CharsetRecog_UTF8.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
 *******************************************************************************
 * Copyright (C) 2005 - 2014, International Business Machines Corporation and  *
@@ -11,6 +13,7 @@ package com.ibm.icu.text;
  */
 class CharsetRecog_UTF8 extends CharsetRecognizer {
 
+    @Override
     String getName() {
         return "UTF-8";
     }
@@ -18,6 +21,7 @@ class CharsetRecog_UTF8 extends CharsetRecognizer {
     /* (non-Javadoc)
      * @see com.ibm.icu.text.CharsetRecognizer#match(com.ibm.icu.text.CharsetDetector)
      */
+    @Override
     CharsetMatch match(CharsetDetector det) {
         boolean     hasBOM = false;
         int         numValid = 0;
@@ -26,22 +30,22 @@ class CharsetRecog_UTF8 extends CharsetRecognizer {
         int         i;
         int         trailBytes = 0;
         int         confidence;
-        
-        if (det.fRawLength >= 3 && 
+
+        if (det.fRawLength >= 3 &&
                 (input[0] & 0xFF) == 0xef && (input[1] & 0xFF) == 0xbb && (input[2] & 0xFF) == 0xbf) {
             hasBOM = true;
         }
-        
+
         // Scan for multi-byte sequences
         for (i=0; i<det.fRawLength; i++) {
             int b = input[i];
             if ((b & 0x80) == 0) {
                 continue;   // ASCII
             }
-            
+
             // Hi bit on char found.  Figure out how long the sequence should be
             if ((b & 0x0e0) == 0x0c0) {
-                trailBytes = 1;                
+                trailBytes = 1;
             } else if ((b & 0x0f0) == 0x0e0) {
                 trailBytes = 2;
             } else if ((b & 0x0f8) == 0xf0) {
@@ -50,7 +54,7 @@ class CharsetRecog_UTF8 extends CharsetRecognizer {
                 numInvalid++;
                 continue;
             }
-                
+
             // Verify that we've got the right number of trail bytes in the sequence
             for (;;) {
                 i++;
@@ -68,7 +72,7 @@ class CharsetRecog_UTF8 extends CharsetRecognizer {
                 }
             }
         }
-        
+
         // Cook up some sort of confidence score, based on presense of a BOM
         //    and the existence of valid and/or invalid multi-byte sequences.
         confidence = 0;
@@ -77,14 +81,14 @@ class CharsetRecog_UTF8 extends CharsetRecognizer {
         } else if (hasBOM && numValid > numInvalid*10) {
             confidence = 80;
         } else if (numValid > 3 && numInvalid == 0) {
-            confidence = 100;            
+            confidence = 100;
         } else if (numValid > 0 && numInvalid == 0) {
             confidence = 80;
         } else if (numValid == 0 && numInvalid == 0) {
             // Plain ASCII. Confidence must be > 10, it's more likely than UTF-16, which
             //              accepts ASCII with confidence = 10.
             // TODO: add plain ASCII as an explicitly detected type.
-            confidence = 15;            
+            confidence = 15;
         } else if (numValid > numInvalid*10) {
             // Probably corruput utf-8 data.  Valid sequences aren't likely by chance.
             confidence = 25;
diff --git a/app/src/main/java/com/ibm/icu/text/CharsetRecog_Unicode.java b/icu4j/src/main/java/com/ibm/icu/text/CharsetRecog_Unicode.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/text/CharsetRecog_Unicode.java
rename to icu4j/src/main/java/com/ibm/icu/text/CharsetRecog_Unicode.java
index 6c65629..d467790 100644
--- a/app/src/main/java/com/ibm/icu/text/CharsetRecog_Unicode.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CharsetRecog_Unicode.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2013, International Business Machines Corporation and    *
@@ -17,22 +19,24 @@ abstract class CharsetRecog_Unicode extends CharsetRecognizer {
     /* (non-Javadoc)
      * @see com.ibm.icu.text.CharsetRecognizer#getName()
      */
+    @Override
     abstract String getName();
 
     /* (non-Javadoc)
      * @see com.ibm.icu.text.CharsetRecognizer#match(com.ibm.icu.text.CharsetDetector)
      */
+    @Override
     abstract CharsetMatch match(CharsetDetector det);
-    
+
     static int codeUnit16FromBytes(byte hi, byte lo) {
         return ((hi & 0xff) << 8) | (lo & 0xff);
     }
-    
+
     // UTF-16 confidence calculation. Very simple minded, but better than nothing.
     //   Any 8 bit non-control characters bump the confidence up. These have a zero high byte,
     //     and are very likely to be UTF-16, although they could also be part of a UTF-32 code.
     //   NULs are a contra-indication, they will appear commonly if the actual encoding is UTF-32.
-    //   NULs should be rare in actual text. 
+    //   NULs should be rare in actual text.
     static int adjustConfidence(int codeUnit, int confidence) {
         if (codeUnit == 0) {
             confidence -= 10;
@@ -46,19 +50,21 @@ abstract class CharsetRecog_Unicode extends CharsetRecognizer {
         }
         return confidence;
     }
-    
+
     static class CharsetRecog_UTF_16_BE extends CharsetRecog_Unicode
     {
+        @Override
         String getName()
         {
             return "UTF-16BE";
         }
-        
+
+        @Override
         CharsetMatch match(CharsetDetector det)
         {
             byte[] input = det.fRawInput;
             int confidence = 10;
-            
+
             int bytesToCheck = Math.min(input.length, 30);
             for (int charIndex=0; charIndex<bytesToCheck-1; charIndex+=2) {
                 int codeUnit = codeUnit16FromBytes(input[charIndex], input[charIndex + 1]);
@@ -80,19 +86,21 @@ abstract class CharsetRecog_Unicode extends CharsetRecognizer {
             return null;
         }
     }
-    
+
     static class CharsetRecog_UTF_16_LE extends CharsetRecog_Unicode
     {
+        @Override
         String getName()
         {
             return "UTF-16LE";
         }
-        
+
+        @Override
         CharsetMatch match(CharsetDetector det)
         {
             byte[] input = det.fRawInput;
             int confidence = 10;
-            
+
             int bytesToCheck = Math.min(input.length, 30);
             for (int charIndex=0; charIndex<bytesToCheck-1; charIndex+=2) {
                 int codeUnit = codeUnit16FromBytes(input[charIndex+1], input[charIndex]);
@@ -114,13 +122,15 @@ abstract class CharsetRecog_Unicode extends CharsetRecognizer {
             return null;
         }
     }
-    
+
     static abstract class CharsetRecog_UTF_32 extends CharsetRecog_Unicode
     {
         abstract int getChar(byte[] input, int index);
-        
+
+        @Override
         abstract String getName();
-        
+
+        @Override
         CharsetMatch match(CharsetDetector det)
         {
             byte[] input   = det.fRawInput;
@@ -129,25 +139,25 @@ abstract class CharsetRecog_Unicode extends CharsetRecognizer {
             int numInvalid = 0;
             boolean hasBOM = false;
             int confidence = 0;
-            
+
             if (limit==0) {
                 return null;
             }
             if (getChar(input, 0) == 0x0000FEFF) {
                 hasBOM = true;
             }
-            
+
             for(int i = 0; i < limit; i += 4) {
                 int ch = getChar(input, i);
-                
+
                 if (ch < 0 || ch >= 0x10FFFF || (ch >= 0xD800 && ch <= 0xDFFF)) {
                     numInvalid += 1;
                 } else {
                     numValid += 1;
                 }
             }
-            
-            
+
+
             // Cook up some sort of confidence score, based on presence of a BOM
             //    and the existence of valid and/or invalid multi-byte sequences.
             if (hasBOM && numInvalid==0) {
@@ -155,41 +165,45 @@ abstract class CharsetRecog_Unicode extends CharsetRecognizer {
             } else if (hasBOM && numValid > numInvalid*10) {
                 confidence = 80;
             } else if (numValid > 3 && numInvalid == 0) {
-                confidence = 100;            
+                confidence = 100;
             } else if (numValid > 0 && numInvalid == 0) {
                 confidence = 80;
             } else if (numValid > numInvalid*10) {
                 // Probably corrupt UTF-32BE data.  Valid sequences aren't likely by chance.
                 confidence = 25;
             }
-            
+
             return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
         }
     }
-    
+
     static class CharsetRecog_UTF_32_BE extends CharsetRecog_UTF_32
     {
+        @Override
         int getChar(byte[] input, int index)
         {
             return (input[index + 0] & 0xFF) << 24 | (input[index + 1] & 0xFF) << 16 |
                    (input[index + 2] & 0xFF) <<  8 | (input[index + 3] & 0xFF);
         }
-        
+
+        @Override
         String getName()
         {
             return "UTF-32BE";
         }
     }
 
-    
+
     static class CharsetRecog_UTF_32_LE extends CharsetRecog_UTF_32
     {
+        @Override
         int getChar(byte[] input, int index)
         {
             return (input[index + 3] & 0xFF) << 24 | (input[index + 2] & 0xFF) << 16 |
                    (input[index + 1] & 0xFF) <<  8 | (input[index + 0] & 0xFF);
         }
-        
+
+        @Override
         String getName()
         {
             return "UTF-32LE";
diff --git a/app/src/main/java/com/ibm/icu/text/CharsetRecog_mbcs.java b/icu4j/src/main/java/com/ibm/icu/text/CharsetRecog_mbcs.java
similarity index 83%
rename from app/src/main/java/com/ibm/icu/text/CharsetRecog_mbcs.java
rename to icu4j/src/main/java/com/ibm/icu/text/CharsetRecog_mbcs.java
index 3d95e73..034e4a8 100644
--- a/app/src/main/java/com/ibm/icu/text/CharsetRecog_mbcs.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CharsetRecog_mbcs.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ****************************************************************************
  * Copyright (C) 2005-2012, International Business Machines Corporation and *
@@ -27,13 +29,14 @@ abstract class CharsetRecog_mbcs extends CharsetRecognizer {
      * Get the IANA name of this charset.
      * @return the charset name.
      */
+    @Override
     abstract String      getName() ;
-    
-    
+
+
     /**
      * Test the match of this charset with the input text data
      *      which is obtained via the CharsetDetector object.
-     * 
+     *
      * @param det  The CharsetDetector, which contains the input text
      *             to be checked for being in this charset.
      * @return     Two values packed into one int  (Damn java, anyhow)
@@ -51,15 +54,15 @@ abstract class CharsetRecog_mbcs extends CharsetRecognizer {
         int   totalCharCount      = 0;
         int   confidence          = 0;
         iteratedChar   iter       = new iteratedChar();
-        
+
         detectBlock: {
             for (iter.reset(); nextChar(iter, det);) {
                 totalCharCount++;
                 if (iter.error) {
-                    badCharCount++; 
+                    badCharCount++;
                 } else {
                     long cv = iter.charValue & 0xFFFFFFFFL;
-                                        
+
                     if (cv <= 0xff) {
                         singleByteCharCount++;
                     } else {
@@ -77,7 +80,7 @@ abstract class CharsetRecog_mbcs extends CharsetRecognizer {
                     break detectBlock;
                 }
             }
-            
+
             if (doubleByteCharCount <= 10 && badCharCount== 0) {
                 // Not many multi-byte chars.
                 if (doubleByteCharCount == 0 && totalCharCount < 10) {
@@ -91,10 +94,10 @@ abstract class CharsetRecog_mbcs extends CharsetRecognizer {
                     //   but is not incompatible with our encoding, so don't give it a zero.
                     confidence = 10;
                 }
-                
+
                 break detectBlock;
             }
-            
+
             //
             //  No match if there are too many characters that don't fit the encoding scheme.
             //    (should we have zero tolerance for these?)
@@ -103,7 +106,7 @@ abstract class CharsetRecog_mbcs extends CharsetRecognizer {
                 confidence = 0;
                 break detectBlock;
             }
-            
+
             if (commonChars == null) {
                 // We have no statistics on frequently occuring characters.
                 //  Assess confidence purely on having a reasonable number of
@@ -122,10 +125,10 @@ abstract class CharsetRecog_mbcs extends CharsetRecognizer {
                 confidence = Math.min(confidence, 100);
             }
         }   // end of detectBlock:
-        
+
         return confidence;
     }
-    
+
      // "Character"  iterated character class.
      //    Recognizers for specific mbcs encodings make their "characters" available
      //    by providing a nextChar() function that fills in an instance of iteratedChar
@@ -139,34 +142,32 @@ abstract class CharsetRecog_mbcs extends CharsetRecognizer {
      //
      static class iteratedChar {
          int             charValue = 0;             // 1-4 bytes from the raw input data
-         int             index     = 0;
          int             nextIndex = 0;
          boolean         error     = false;
          boolean         done      = false;
-         
+
          void reset() {
              charValue = 0;
-             index     = -1;
              nextIndex = 0;
              error     = false;
              done      = false;
          }
-         
+
          int nextByte(CharsetDetector det) {
              if (nextIndex >= det.fRawLength) {
                  done = true;
                  return -1;
              }
-             int byteValue = (int)det.fRawInput[nextIndex++] & 0x00ff;
+             int byteValue = det.fRawInput[nextIndex++] & 0x00ff;
              return byteValue;
-         }       
+         }
      }
-     
+
      /**
       * Get the next character (however many bytes it is) from the input data
       *    Subclasses for specific charset encodings must implement this function
       *    to get characters according to the rules of their encoding scheme.
-      * 
+      *
       *  This function is not a method of class iteratedChar only because
       *   that would require a lot of extra derived classes, which is awkward.
       * @param it  The iteratedChar "struct" into which the returned char is placed.
@@ -175,43 +176,43 @@ abstract class CharsetRecog_mbcs extends CharsetRecognizer {
       * @return    True if a character was returned, false at end of input.
       */
      abstract boolean nextChar(iteratedChar it, CharsetDetector det);
-     
 
 
-     
-     
+
+
+
      /**
-      *   Shift-JIS charset recognizer.   
+      *   Shift-JIS charset recognizer.
       *
       */
      static class CharsetRecog_sjis extends CharsetRecog_mbcs {
-         static int [] commonChars = 
+         static int [] commonChars =
              // TODO:  This set of data comes from the character frequency-
              //        of-occurence analysis tool.  The data needs to be moved
              //        into a resource and loaded from there.
-            {0x8140, 0x8141, 0x8142, 0x8145, 0x815b, 0x8169, 0x816a, 0x8175, 0x8176, 0x82a0, 
-             0x82a2, 0x82a4, 0x82a9, 0x82aa, 0x82ab, 0x82ad, 0x82af, 0x82b1, 0x82b3, 0x82b5, 
-             0x82b7, 0x82bd, 0x82be, 0x82c1, 0x82c4, 0x82c5, 0x82c6, 0x82c8, 0x82c9, 0x82cc, 
-             0x82cd, 0x82dc, 0x82e0, 0x82e7, 0x82e8, 0x82e9, 0x82ea, 0x82f0, 0x82f1, 0x8341, 
-             0x8343, 0x834e, 0x834f, 0x8358, 0x835e, 0x8362, 0x8367, 0x8375, 0x8376, 0x8389, 
+            {0x8140, 0x8141, 0x8142, 0x8145, 0x815b, 0x8169, 0x816a, 0x8175, 0x8176, 0x82a0,
+             0x82a2, 0x82a4, 0x82a9, 0x82aa, 0x82ab, 0x82ad, 0x82af, 0x82b1, 0x82b3, 0x82b5,
+             0x82b7, 0x82bd, 0x82be, 0x82c1, 0x82c4, 0x82c5, 0x82c6, 0x82c8, 0x82c9, 0x82cc,
+             0x82cd, 0x82dc, 0x82e0, 0x82e7, 0x82e8, 0x82e9, 0x82ea, 0x82f0, 0x82f1, 0x8341,
+             0x8343, 0x834e, 0x834f, 0x8358, 0x835e, 0x8362, 0x8367, 0x8375, 0x8376, 0x8389,
              0x838a, 0x838b, 0x838d, 0x8393, 0x8e96, 0x93fa, 0x95aa};
-         
-         boolean nextChar(iteratedChar it, CharsetDetector det) {
-             it.index = it.nextIndex;
+
+         @Override
+        boolean nextChar(iteratedChar it, CharsetDetector det) {
              it.error = false;
              int firstByte;
              firstByte = it.charValue = it.nextByte(det);
              if (firstByte < 0) {
                  return false;
              }
-             
+
              if (firstByte <= 0x7f || (firstByte>0xa0 && firstByte<=0xdf)) {
                  return true;
              }
-             
+
              int secondByte = it.nextByte(det);
              if (secondByte < 0)  {
-                 return false;          
+                 return false;
              }
              it.charValue = (firstByte << 8) | secondByte;
              if (! ((secondByte>=0x40 && secondByte<=0x7f) || (secondByte>=0x80 && secondByte<=0xff))) {
@@ -220,62 +221,65 @@ abstract class CharsetRecog_mbcs extends CharsetRecognizer {
              }
              return true;
          }
-         
-         CharsetMatch match(CharsetDetector det) {
+
+         @Override
+        CharsetMatch match(CharsetDetector det) {
              int confidence = match(det, commonChars);
              return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
          }
-         
-         String getName() {
+
+         @Override
+        String getName() {
              return "Shift_JIS";
          }
-         
-         public String getLanguage()
+
+         @Override
+        public String getLanguage()
          {
              return "ja";
          }
 
-         
+
      }
-     
-     
+
+
      /**
-      *   Big5 charset recognizer.   
+      *   Big5 charset recognizer.
       *
       */
      static class CharsetRecog_big5 extends CharsetRecog_mbcs {
-         static int [] commonChars = 
+         static int [] commonChars =
              // TODO:  This set of data comes from the character frequency-
              //        of-occurence analysis tool.  The data needs to be moved
              //        into a resource and loaded from there.
-            {0xa140, 0xa141, 0xa142, 0xa143, 0xa147, 0xa149, 0xa175, 0xa176, 0xa440, 0xa446, 
-             0xa447, 0xa448, 0xa451, 0xa454, 0xa457, 0xa464, 0xa46a, 0xa46c, 0xa477, 0xa4a3, 
-             0xa4a4, 0xa4a7, 0xa4c1, 0xa4ce, 0xa4d1, 0xa4df, 0xa4e8, 0xa4fd, 0xa540, 0xa548, 
-             0xa558, 0xa569, 0xa5cd, 0xa5e7, 0xa657, 0xa661, 0xa662, 0xa668, 0xa670, 0xa6a8, 
-             0xa6b3, 0xa6b9, 0xa6d3, 0xa6db, 0xa6e6, 0xa6f2, 0xa740, 0xa751, 0xa759, 0xa7da, 
-             0xa8a3, 0xa8a5, 0xa8ad, 0xa8d1, 0xa8d3, 0xa8e4, 0xa8fc, 0xa9c0, 0xa9d2, 0xa9f3, 
-             0xaa6b, 0xaaba, 0xaabe, 0xaacc, 0xaafc, 0xac47, 0xac4f, 0xacb0, 0xacd2, 0xad59, 
-             0xaec9, 0xafe0, 0xb0ea, 0xb16f, 0xb2b3, 0xb2c4, 0xb36f, 0xb44c, 0xb44e, 0xb54c, 
-             0xb5a5, 0xb5bd, 0xb5d0, 0xb5d8, 0xb671, 0xb7ed, 0xb867, 0xb944, 0xbad8, 0xbb44, 
+            {0xa140, 0xa141, 0xa142, 0xa143, 0xa147, 0xa149, 0xa175, 0xa176, 0xa440, 0xa446,
+             0xa447, 0xa448, 0xa451, 0xa454, 0xa457, 0xa464, 0xa46a, 0xa46c, 0xa477, 0xa4a3,
+             0xa4a4, 0xa4a7, 0xa4c1, 0xa4ce, 0xa4d1, 0xa4df, 0xa4e8, 0xa4fd, 0xa540, 0xa548,
+             0xa558, 0xa569, 0xa5cd, 0xa5e7, 0xa657, 0xa661, 0xa662, 0xa668, 0xa670, 0xa6a8,
+             0xa6b3, 0xa6b9, 0xa6d3, 0xa6db, 0xa6e6, 0xa6f2, 0xa740, 0xa751, 0xa759, 0xa7da,
+             0xa8a3, 0xa8a5, 0xa8ad, 0xa8d1, 0xa8d3, 0xa8e4, 0xa8fc, 0xa9c0, 0xa9d2, 0xa9f3,
+             0xaa6b, 0xaaba, 0xaabe, 0xaacc, 0xaafc, 0xac47, 0xac4f, 0xacb0, 0xacd2, 0xad59,
+             0xaec9, 0xafe0, 0xb0ea, 0xb16f, 0xb2b3, 0xb2c4, 0xb36f, 0xb44c, 0xb44e, 0xb54c,
+             0xb5a5, 0xb5bd, 0xb5d0, 0xb5d8, 0xb671, 0xb7ed, 0xb867, 0xb944, 0xbad8, 0xbb44,
              0xbba1, 0xbdd1, 0xc2c4, 0xc3b9, 0xc440, 0xc45f};
-          
-         boolean nextChar(iteratedChar it, CharsetDetector det) {
-             it.index = it.nextIndex;
+
+         @Override
+        boolean nextChar(iteratedChar it, CharsetDetector det) {
              it.error = false;
              int firstByte;
              firstByte = it.charValue = it.nextByte(det);
              if (firstByte < 0) {
                  return false;
              }
-             
+
              if (firstByte <= 0x7f || firstByte==0xff) {
                  // single byte character.
                  return true;
              }
-             
+
              int secondByte = it.nextByte(det);
              if (secondByte < 0)  {
-                 return false;          
+                 return false;
              }
              it.charValue = (it.charValue << 8) | secondByte;
 
@@ -286,48 +290,51 @@ abstract class CharsetRecog_mbcs extends CharsetRecognizer {
              }
              return true;
          }
-         
-         CharsetMatch match(CharsetDetector det) {
+
+         @Override
+        CharsetMatch match(CharsetDetector det) {
              int confidence = match(det, commonChars);
              return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
          }
-         
-         String getName() {
+
+         @Override
+        String getName() {
              return "Big5";
          }
-         
-         
-         public String getLanguage()
+
+
+         @Override
+        public String getLanguage()
          {
              return "zh";
          }
      }
-     
-     
+
+
      /**
       *   EUC charset recognizers.  One abstract class that provides the common function
       *             for getting the next character according to the EUC encoding scheme,
-      *             and nested derived classes for EUC_KR, EUC_JP, EUC_CN.   
+      *             and nested derived classes for EUC_KR, EUC_JP, EUC_CN.
       *
       */
      abstract static class CharsetRecog_euc extends CharsetRecog_mbcs {
-         
+
          /*
           *  (non-Javadoc)
           *  Get the next character value for EUC based encodings.
           *  Character "value" is simply the raw bytes that make up the character
           *     packed into an int.
           */
-         boolean nextChar(iteratedChar it, CharsetDetector det) {
-             it.index = it.nextIndex;
+         @Override
+        boolean nextChar(iteratedChar it, CharsetDetector det) {
              it.error = false;
              int firstByte  = 0;
              int secondByte = 0;
              int thirdByte  = 0;
              //int fourthByte = 0;
-             
+
              buildChar: {
-                 firstByte = it.charValue = it.nextByte(det);                 
+                 firstByte = it.charValue = it.nextByte(det);
                  if (firstByte < 0) {
                      // Ran off the end of the input data
                      it.done = true;
@@ -337,10 +344,10 @@ abstract class CharsetRecog_mbcs extends CharsetRecognizer {
                      // single byte char
                      break buildChar;
                  }
-                 
+
                  secondByte = it.nextByte(det);
                  it.charValue = (it.charValue << 8) | secondByte;
-                 
+
                  if (firstByte >= 0xA1 && firstByte <= 0xfe) {
                      // Two byte Char
                      if (secondByte < 0xa1) {
@@ -354,13 +361,13 @@ abstract class CharsetRecog_mbcs extends CharsetRecognizer {
                      //   In EUC-TW, total char size is 4 bytes, three bytes contribute to char value.
                      // We don't know which we've got.
                      // Treat it like EUC-JP.  If the data really was EUC-TW, the following two
-                     //   bytes will look like a well formed 2 byte char.  
+                     //   bytes will look like a well formed 2 byte char.
                      if (secondByte < 0xa1) {
                          it.error = true;
                      }
-                     break buildChar;                     
+                     break buildChar;
                  }
-                 
+
                  if (firstByte == 0x8f) {
                      // Code set 3.
                      // Three byte total char size, two bytes of actual char value.
@@ -371,176 +378,185 @@ abstract class CharsetRecog_mbcs extends CharsetRecognizer {
                      }
                  }
               }
-             
+
              return (it.done == false);
          }
-         
+
          /**
           * The charset recognize for EUC-JP.  A singleton instance of this class
           *    is created and kept by the public CharsetDetector class
           */
          static class CharsetRecog_euc_jp extends CharsetRecog_euc {
-             static int [] commonChars = 
+             static int [] commonChars =
                  // TODO:  This set of data comes from the character frequency-
                  //        of-occurence analysis tool.  The data needs to be moved
                  //        into a resource and loaded from there.
-                {0xa1a1, 0xa1a2, 0xa1a3, 0xa1a6, 0xa1bc, 0xa1ca, 0xa1cb, 0xa1d6, 0xa1d7, 0xa4a2, 
-                 0xa4a4, 0xa4a6, 0xa4a8, 0xa4aa, 0xa4ab, 0xa4ac, 0xa4ad, 0xa4af, 0xa4b1, 0xa4b3, 
-                 0xa4b5, 0xa4b7, 0xa4b9, 0xa4bb, 0xa4bd, 0xa4bf, 0xa4c0, 0xa4c1, 0xa4c3, 0xa4c4, 
-                 0xa4c6, 0xa4c7, 0xa4c8, 0xa4c9, 0xa4ca, 0xa4cb, 0xa4ce, 0xa4cf, 0xa4d0, 0xa4de, 
-                 0xa4df, 0xa4e1, 0xa4e2, 0xa4e4, 0xa4e8, 0xa4e9, 0xa4ea, 0xa4eb, 0xa4ec, 0xa4ef, 
-                 0xa4f2, 0xa4f3, 0xa5a2, 0xa5a3, 0xa5a4, 0xa5a6, 0xa5a7, 0xa5aa, 0xa5ad, 0xa5af, 
-                 0xa5b0, 0xa5b3, 0xa5b5, 0xa5b7, 0xa5b8, 0xa5b9, 0xa5bf, 0xa5c3, 0xa5c6, 0xa5c7, 
-                 0xa5c8, 0xa5c9, 0xa5cb, 0xa5d0, 0xa5d5, 0xa5d6, 0xa5d7, 0xa5de, 0xa5e0, 0xa5e1, 
-                 0xa5e5, 0xa5e9, 0xa5ea, 0xa5eb, 0xa5ec, 0xa5ed, 0xa5f3, 0xb8a9, 0xb9d4, 0xbaee, 
-                 0xbbc8, 0xbef0, 0xbfb7, 0xc4ea, 0xc6fc, 0xc7bd, 0xcab8, 0xcaf3, 0xcbdc, 0xcdd1};             
-             String getName() {
+                {0xa1a1, 0xa1a2, 0xa1a3, 0xa1a6, 0xa1bc, 0xa1ca, 0xa1cb, 0xa1d6, 0xa1d7, 0xa4a2,
+                 0xa4a4, 0xa4a6, 0xa4a8, 0xa4aa, 0xa4ab, 0xa4ac, 0xa4ad, 0xa4af, 0xa4b1, 0xa4b3,
+                 0xa4b5, 0xa4b7, 0xa4b9, 0xa4bb, 0xa4bd, 0xa4bf, 0xa4c0, 0xa4c1, 0xa4c3, 0xa4c4,
+                 0xa4c6, 0xa4c7, 0xa4c8, 0xa4c9, 0xa4ca, 0xa4cb, 0xa4ce, 0xa4cf, 0xa4d0, 0xa4de,
+                 0xa4df, 0xa4e1, 0xa4e2, 0xa4e4, 0xa4e8, 0xa4e9, 0xa4ea, 0xa4eb, 0xa4ec, 0xa4ef,
+                 0xa4f2, 0xa4f3, 0xa5a2, 0xa5a3, 0xa5a4, 0xa5a6, 0xa5a7, 0xa5aa, 0xa5ad, 0xa5af,
+                 0xa5b0, 0xa5b3, 0xa5b5, 0xa5b7, 0xa5b8, 0xa5b9, 0xa5bf, 0xa5c3, 0xa5c6, 0xa5c7,
+                 0xa5c8, 0xa5c9, 0xa5cb, 0xa5d0, 0xa5d5, 0xa5d6, 0xa5d7, 0xa5de, 0xa5e0, 0xa5e1,
+                 0xa5e5, 0xa5e9, 0xa5ea, 0xa5eb, 0xa5ec, 0xa5ed, 0xa5f3, 0xb8a9, 0xb9d4, 0xbaee,
+                 0xbbc8, 0xbef0, 0xbfb7, 0xc4ea, 0xc6fc, 0xc7bd, 0xcab8, 0xcaf3, 0xcbdc, 0xcdd1};
+             @Override
+            String getName() {
                  return "EUC-JP";
              }
-             
-             CharsetMatch match(CharsetDetector det) {
+
+             @Override
+            CharsetMatch match(CharsetDetector det) {
                  int confidence = match(det, commonChars);
                  return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
              }
-             
-             public String getLanguage()
+
+             @Override
+            public String getLanguage()
              {
                  return "ja";
              }
          }
-         
+
          /**
           * The charset recognize for EUC-KR.  A singleton instance of this class
           *    is created and kept by the public CharsetDetector class
           */
          static class CharsetRecog_euc_kr extends CharsetRecog_euc {
-             static int [] commonChars = 
+             static int [] commonChars =
                  // TODO:  This set of data comes from the character frequency-
                  //        of-occurence analysis tool.  The data needs to be moved
                  //        into a resource and loaded from there.
-                {0xb0a1, 0xb0b3, 0xb0c5, 0xb0cd, 0xb0d4, 0xb0e6, 0xb0ed, 0xb0f8, 0xb0fa, 0xb0fc, 
-                 0xb1b8, 0xb1b9, 0xb1c7, 0xb1d7, 0xb1e2, 0xb3aa, 0xb3bb, 0xb4c2, 0xb4cf, 0xb4d9, 
-                 0xb4eb, 0xb5a5, 0xb5b5, 0xb5bf, 0xb5c7, 0xb5e9, 0xb6f3, 0xb7af, 0xb7c2, 0xb7ce, 
-                 0xb8a6, 0xb8ae, 0xb8b6, 0xb8b8, 0xb8bb, 0xb8e9, 0xb9ab, 0xb9ae, 0xb9cc, 0xb9ce, 
-                 0xb9fd, 0xbab8, 0xbace, 0xbad0, 0xbaf1, 0xbbe7, 0xbbf3, 0xbbfd, 0xbcad, 0xbcba, 
-                 0xbcd2, 0xbcf6, 0xbdba, 0xbdc0, 0xbdc3, 0xbdc5, 0xbec6, 0xbec8, 0xbedf, 0xbeee, 
-                 0xbef8, 0xbefa, 0xbfa1, 0xbfa9, 0xbfc0, 0xbfe4, 0xbfeb, 0xbfec, 0xbff8, 0xc0a7, 
-                 0xc0af, 0xc0b8, 0xc0ba, 0xc0bb, 0xc0bd, 0xc0c7, 0xc0cc, 0xc0ce, 0xc0cf, 0xc0d6, 
-                 0xc0da, 0xc0e5, 0xc0fb, 0xc0fc, 0xc1a4, 0xc1a6, 0xc1b6, 0xc1d6, 0xc1df, 0xc1f6, 
+                {0xb0a1, 0xb0b3, 0xb0c5, 0xb0cd, 0xb0d4, 0xb0e6, 0xb0ed, 0xb0f8, 0xb0fa, 0xb0fc,
+                 0xb1b8, 0xb1b9, 0xb1c7, 0xb1d7, 0xb1e2, 0xb3aa, 0xb3bb, 0xb4c2, 0xb4cf, 0xb4d9,
+                 0xb4eb, 0xb5a5, 0xb5b5, 0xb5bf, 0xb5c7, 0xb5e9, 0xb6f3, 0xb7af, 0xb7c2, 0xb7ce,
+                 0xb8a6, 0xb8ae, 0xb8b6, 0xb8b8, 0xb8bb, 0xb8e9, 0xb9ab, 0xb9ae, 0xb9cc, 0xb9ce,
+                 0xb9fd, 0xbab8, 0xbace, 0xbad0, 0xbaf1, 0xbbe7, 0xbbf3, 0xbbfd, 0xbcad, 0xbcba,
+                 0xbcd2, 0xbcf6, 0xbdba, 0xbdc0, 0xbdc3, 0xbdc5, 0xbec6, 0xbec8, 0xbedf, 0xbeee,
+                 0xbef8, 0xbefa, 0xbfa1, 0xbfa9, 0xbfc0, 0xbfe4, 0xbfeb, 0xbfec, 0xbff8, 0xc0a7,
+                 0xc0af, 0xc0b8, 0xc0ba, 0xc0bb, 0xc0bd, 0xc0c7, 0xc0cc, 0xc0ce, 0xc0cf, 0xc0d6,
+                 0xc0da, 0xc0e5, 0xc0fb, 0xc0fc, 0xc1a4, 0xc1a6, 0xc1b6, 0xc1d6, 0xc1df, 0xc1f6,
                  0xc1f8, 0xc4a1, 0xc5cd, 0xc6ae, 0xc7cf, 0xc7d1, 0xc7d2, 0xc7d8, 0xc7e5, 0xc8ad};
-             
-             String getName() {
+
+             @Override
+            String getName() {
                  return "EUC-KR";
              }
-             
-             CharsetMatch match(CharsetDetector det) {
+
+             @Override
+            CharsetMatch match(CharsetDetector det) {
                  int confidence = match(det, commonChars);
                  return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
              }
-             
-             public String getLanguage()
+
+             @Override
+            public String getLanguage()
              {
                  return "ko";
              }
          }
      }
-     
+
      /**
-      * 
-      *   GB-18030 recognizer. Uses simplified Chinese statistics.   
+      *
+      *   GB-18030 recognizer. Uses simplified Chinese statistics.
       *
       */
      static class CharsetRecog_gb_18030 extends CharsetRecog_mbcs {
-         
+
          /*
           *  (non-Javadoc)
           *  Get the next character value for EUC based encodings.
           *  Character "value" is simply the raw bytes that make up the character
           *     packed into an int.
           */
-         boolean nextChar(iteratedChar it, CharsetDetector det) {
-             it.index = it.nextIndex;
+         @Override
+        boolean nextChar(iteratedChar it, CharsetDetector det) {
              it.error = false;
              int firstByte  = 0;
              int secondByte = 0;
              int thirdByte  = 0;
              int fourthByte = 0;
-             
+
              buildChar: {
-                 firstByte = it.charValue = it.nextByte(det); 
-                 
+                 firstByte = it.charValue = it.nextByte(det);
+
                  if (firstByte < 0) {
                      // Ran off the end of the input data
                      it.done = true;
                      break buildChar;
                  }
-                 
+
                  if (firstByte <= 0x80) {
                      // single byte char
                      break buildChar;
                  }
-                 
+
                  secondByte = it.nextByte(det);
                  it.charValue = (it.charValue << 8) | secondByte;
-                 
+
                  if (firstByte >= 0x81 && firstByte <= 0xFE) {
                      // Two byte Char
                      if ((secondByte >= 0x40 && secondByte <= 0x7E) || (secondByte >=80 && secondByte <=0xFE)) {
                          break buildChar;
                      }
-                     
+
                      // Four byte char
                      if (secondByte >= 0x30 && secondByte <= 0x39) {
                          thirdByte = it.nextByte(det);
-                         
+
                          if (thirdByte >= 0x81 && thirdByte <= 0xFE) {
                              fourthByte = it.nextByte(det);
-                             
+
                              if (fourthByte >= 0x30 && fourthByte <= 0x39) {
                                  it.charValue = (it.charValue << 16) | (thirdByte << 8) | fourthByte;
                                  break buildChar;
                              }
                          }
                      }
-                     
+
                      it.error = true;
                      break buildChar;
                  }
              }
-                 
+
              return (it.done == false);
          }
-         
-         static int [] commonChars = 
+
+         static int [] commonChars =
              // TODO:  This set of data comes from the character frequency-
              //        of-occurence analysis tool.  The data needs to be moved
              //        into a resource and loaded from there.
-            {0xa1a1, 0xa1a2, 0xa1a3, 0xa1a4, 0xa1b0, 0xa1b1, 0xa1f1, 0xa1f3, 0xa3a1, 0xa3ac, 
-             0xa3ba, 0xb1a8, 0xb1b8, 0xb1be, 0xb2bb, 0xb3c9, 0xb3f6, 0xb4f3, 0xb5bd, 0xb5c4, 
-             0xb5e3, 0xb6af, 0xb6d4, 0xb6e0, 0xb7a2, 0xb7a8, 0xb7bd, 0xb7d6, 0xb7dd, 0xb8b4, 
-             0xb8df, 0xb8f6, 0xb9ab, 0xb9c9, 0xb9d8, 0xb9fa, 0xb9fd, 0xbacd, 0xbba7, 0xbbd6, 
-             0xbbe1, 0xbbfa, 0xbcbc, 0xbcdb, 0xbcfe, 0xbdcc, 0xbecd, 0xbedd, 0xbfb4, 0xbfc6, 
-             0xbfc9, 0xc0b4, 0xc0ed, 0xc1cb, 0xc2db, 0xc3c7, 0xc4dc, 0xc4ea, 0xc5cc, 0xc6f7, 
-             0xc7f8, 0xc8ab, 0xc8cb, 0xc8d5, 0xc8e7, 0xc9cf, 0xc9fa, 0xcab1, 0xcab5, 0xcac7, 
-             0xcad0, 0xcad6, 0xcaf5, 0xcafd, 0xccec, 0xcdf8, 0xceaa, 0xcec4, 0xced2, 0xcee5, 
-             0xcfb5, 0xcfc2, 0xcfd6, 0xd0c2, 0xd0c5, 0xd0d0, 0xd0d4, 0xd1a7, 0xd2aa, 0xd2b2, 
+            {0xa1a1, 0xa1a2, 0xa1a3, 0xa1a4, 0xa1b0, 0xa1b1, 0xa1f1, 0xa1f3, 0xa3a1, 0xa3ac,
+             0xa3ba, 0xb1a8, 0xb1b8, 0xb1be, 0xb2bb, 0xb3c9, 0xb3f6, 0xb4f3, 0xb5bd, 0xb5c4,
+             0xb5e3, 0xb6af, 0xb6d4, 0xb6e0, 0xb7a2, 0xb7a8, 0xb7bd, 0xb7d6, 0xb7dd, 0xb8b4,
+             0xb8df, 0xb8f6, 0xb9ab, 0xb9c9, 0xb9d8, 0xb9fa, 0xb9fd, 0xbacd, 0xbba7, 0xbbd6,
+             0xbbe1, 0xbbfa, 0xbcbc, 0xbcdb, 0xbcfe, 0xbdcc, 0xbecd, 0xbedd, 0xbfb4, 0xbfc6,
+             0xbfc9, 0xc0b4, 0xc0ed, 0xc1cb, 0xc2db, 0xc3c7, 0xc4dc, 0xc4ea, 0xc5cc, 0xc6f7,
+             0xc7f8, 0xc8ab, 0xc8cb, 0xc8d5, 0xc8e7, 0xc9cf, 0xc9fa, 0xcab1, 0xcab5, 0xcac7,
+             0xcad0, 0xcad6, 0xcaf5, 0xcafd, 0xccec, 0xcdf8, 0xceaa, 0xcec4, 0xced2, 0xcee5,
+             0xcfb5, 0xcfc2, 0xcfd6, 0xd0c2, 0xd0c5, 0xd0d0, 0xd0d4, 0xd1a7, 0xd2aa, 0xd2b2,
              0xd2b5, 0xd2bb, 0xd2d4, 0xd3c3, 0xd3d0, 0xd3fd, 0xd4c2, 0xd4da, 0xd5e2, 0xd6d0};
 
-         
-         String getName() {
+
+         @Override
+        String getName() {
              return "GB18030";
          }
-         
-         CharsetMatch match(CharsetDetector det) {
+
+         @Override
+        CharsetMatch match(CharsetDetector det) {
              int confidence = match(det, commonChars);
              return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
          }
-         
-         public String getLanguage()
+
+         @Override
+        public String getLanguage()
          {
              return "zh";
          }
      }
-     
-     
+
+
 }
diff --git a/app/src/main/java/com/ibm/icu/text/CharsetRecog_sbcs.java b/icu4j/src/main/java/com/ibm/icu/text/CharsetRecog_sbcs.java
similarity index 71%
rename from app/src/main/java/com/ibm/icu/text/CharsetRecog_sbcs.java
rename to icu4j/src/main/java/com/ibm/icu/text/CharsetRecog_sbcs.java
index e051ea2..ea42f5b 100644
--- a/app/src/main/java/com/ibm/icu/text/CharsetRecog_sbcs.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CharsetRecog_sbcs.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ****************************************************************************
  * Copyright (C) 2005-2013, International Business Machines Corporation and *
@@ -17,6 +19,7 @@ abstract class CharsetRecog_sbcs extends CharsetRecognizer {
     /* (non-Javadoc)
      * @see com.ibm.icu.text.CharsetRecognizer#getName()
      */
+    @Override
     abstract String getName();
 
     static class NGramParser
@@ -26,36 +29,36 @@ abstract class CharsetRecog_sbcs extends CharsetRecognizer {
 
         protected int byteIndex = 0;
         private int ngram = 0;
-        
+
         private int[] ngramList;
         protected byte[] byteMap;
-        
+
         private int ngramCount;
         private int hitCount;
-        
+
         protected byte spaceChar;
-        
+
         public NGramParser(int[] theNgramList, byte[] theByteMap)
         {
             ngramList = theNgramList;
             byteMap   = theByteMap;
-            
+
             ngram = 0;
-            
+
             ngramCount = hitCount = 0;
         }
-        
+
         /*
          * Binary search for value in table, which must have exactly 64 entries.
          */
         private static int search(int[] table, int value)
         {
             int index = 0;
-            
+
             if (table[index + 32] <= value) {
                 index += 32;
             }
-            
+
             if (table[index + 16] <= value) {
                 index += 16;
             }
@@ -79,57 +82,57 @@ abstract class CharsetRecog_sbcs extends CharsetRecognizer {
             if (table[index] > value) {
                 index -= 1;
             }
-            
+
             if (index < 0 || table[index] != value) {
                 return -1;
             }
-            
+
             return index;
         }
 
         private void lookup(int thisNgram)
         {
             ngramCount += 1;
-            
+
             if (search(ngramList, thisNgram) >= 0) {
                 hitCount += 1;
             }
-            
+
         }
-        
+
         protected void addByte(int b)
         {
             ngram = ((ngram << 8) + (b & 0xFF)) & N_GRAM_MASK;
             lookup(ngram);
         }
-        
+
         private int nextByte(CharsetDetector det)
         {
             if (byteIndex >= det.fInputLen) {
                 return -1;
             }
-            
+
             return det.fInputBytes[byteIndex++] & 0xFF;
         }
-        
+
         protected void parseCharacters(CharsetDetector det)
         {
             int b;
             boolean ignoreSpace = false;
-            
+
             while ((b = nextByte(det)) >= 0) {
                 byte mb = byteMap[b];
-                
+
                 // TODO: 0x20 might not be a space in all character sets...
                 if (mb != 0) {
                     if (!(mb == spaceChar && ignoreSpace)) {
-                        addByte(mb);                    
+                        addByte(mb);
                     }
-                    
+
                     ignoreSpace = (mb == spaceChar);
                 }
             }
-            
+
         }
 
         public int parse(CharsetDetector det)
@@ -138,60 +141,60 @@ abstract class CharsetRecog_sbcs extends CharsetRecognizer {
         }
         public int parse(CharsetDetector det, byte spaceCh)
         {
-            
+
             this.spaceChar = spaceCh;
-            
+
             parseCharacters(det);
-            
+
             // TODO: Is this OK? The buffer could have ended in the middle of a word...
             addByte(spaceChar);
 
             double rawPercent = (double) hitCount / (double) ngramCount;
-            
+
 //                if (rawPercent <= 2.0) {
 //                    return 0;
 //                }
-            
+
             // TODO - This is a bit of a hack to take care of a case
             // were we were getting a confidence of 135...
             if (rawPercent > 0.33) {
                 return 98;
             }
-            
+
             return (int) (rawPercent * 300.0);
         }
     }
-        
+
     static class NGramParser_IBM420 extends NGramParser
     {
         private byte alef = 0x00;
-        
+
         protected static byte[] unshapeMap = {
 /*                 -0           -1           -2           -3           -4           -5           -6           -7           -8           -9           -A           -B           -C           -D           -E           -F   */
-/* 0- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 1- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 2- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 3- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 4- */    (byte) 0x40, (byte) 0x40, (byte) 0x42, (byte) 0x42, (byte) 0x44, (byte) 0x45, (byte) 0x46, (byte) 0x47, (byte) 0x47, (byte) 0x49, (byte) 0x4A, (byte) 0x4B, (byte) 0x4C, (byte) 0x4D, (byte) 0x4E, (byte) 0x4F, 
-/* 5- */    (byte) 0x50, (byte) 0x49, (byte) 0x52, (byte) 0x53, (byte) 0x54, (byte) 0x55, (byte) 0x56, (byte) 0x56, (byte) 0x58, (byte) 0x58, (byte) 0x5A, (byte) 0x5B, (byte) 0x5C, (byte) 0x5D, (byte) 0x5E, (byte) 0x5F, 
-/* 6- */    (byte) 0x60, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x63, (byte) 0x65, (byte) 0x65, (byte) 0x67, (byte) 0x67, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-/* 7- */    (byte) 0x69, (byte) 0x71, (byte) 0x71, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, (byte) 0x77, (byte) 0x79, (byte) 0x7A, (byte) 0x7B, (byte) 0x7C, (byte) 0x7D, (byte) 0x7E, (byte) 0x7F, 
-/* 8- */    (byte) 0x80, (byte) 0x81, (byte) 0x82, (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x80, (byte) 0x8B, (byte) 0x8B, (byte) 0x8D, (byte) 0x8D, (byte) 0x8F, 
-/* 9- */    (byte) 0x90, (byte) 0x91, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97, (byte) 0x98, (byte) 0x99, (byte) 0x9A, (byte) 0x9A, (byte) 0x9A, (byte) 0x9A, (byte) 0x9E, (byte) 0x9E, 
-/* A- */    (byte) 0x9E, (byte) 0xA1, (byte) 0xA2, (byte) 0xA3, (byte) 0xA4, (byte) 0xA5, (byte) 0xA6, (byte) 0xA7, (byte) 0xA8, (byte) 0xA9, (byte) 0x9E, (byte) 0xAB, (byte) 0xAB, (byte) 0xAD, (byte) 0xAD, (byte) 0xAF, 
-/* B- */    (byte) 0xAF, (byte) 0xB1, (byte) 0xB2, (byte) 0xB3, (byte) 0xB4, (byte) 0xB5, (byte) 0xB6, (byte) 0xB7, (byte) 0xB8, (byte) 0xB9, (byte) 0xB1, (byte) 0xBB, (byte) 0xBB, (byte) 0xBD, (byte) 0xBD, (byte) 0xBF, 
-/* C- */    (byte) 0xC0, (byte) 0xC1, (byte) 0xC2, (byte) 0xC3, (byte) 0xC4, (byte) 0xC5, (byte) 0xC6, (byte) 0xC7, (byte) 0xC8, (byte) 0xC9, (byte) 0xCA, (byte) 0xBF, (byte) 0xCC, (byte) 0xBF, (byte) 0xCE, (byte) 0xCF, 
-/* D- */    (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7, (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0xDA, (byte) 0xDC, (byte) 0xDC, (byte) 0xDC, (byte) 0xDF, 
-/* E- */    (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF, 
-/* F- */    (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7, (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xFF, 
+/* 0- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 1- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 2- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 3- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 4- */    (byte) 0x40, (byte) 0x40, (byte) 0x42, (byte) 0x42, (byte) 0x44, (byte) 0x45, (byte) 0x46, (byte) 0x47, (byte) 0x47, (byte) 0x49, (byte) 0x4A, (byte) 0x4B, (byte) 0x4C, (byte) 0x4D, (byte) 0x4E, (byte) 0x4F,
+/* 5- */    (byte) 0x50, (byte) 0x49, (byte) 0x52, (byte) 0x53, (byte) 0x54, (byte) 0x55, (byte) 0x56, (byte) 0x56, (byte) 0x58, (byte) 0x58, (byte) 0x5A, (byte) 0x5B, (byte) 0x5C, (byte) 0x5D, (byte) 0x5E, (byte) 0x5F,
+/* 6- */    (byte) 0x60, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x63, (byte) 0x65, (byte) 0x65, (byte) 0x67, (byte) 0x67, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+/* 7- */    (byte) 0x69, (byte) 0x71, (byte) 0x71, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, (byte) 0x77, (byte) 0x79, (byte) 0x7A, (byte) 0x7B, (byte) 0x7C, (byte) 0x7D, (byte) 0x7E, (byte) 0x7F,
+/* 8- */    (byte) 0x80, (byte) 0x81, (byte) 0x82, (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x80, (byte) 0x8B, (byte) 0x8B, (byte) 0x8D, (byte) 0x8D, (byte) 0x8F,
+/* 9- */    (byte) 0x90, (byte) 0x91, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97, (byte) 0x98, (byte) 0x99, (byte) 0x9A, (byte) 0x9A, (byte) 0x9A, (byte) 0x9A, (byte) 0x9E, (byte) 0x9E,
+/* A- */    (byte) 0x9E, (byte) 0xA1, (byte) 0xA2, (byte) 0xA3, (byte) 0xA4, (byte) 0xA5, (byte) 0xA6, (byte) 0xA7, (byte) 0xA8, (byte) 0xA9, (byte) 0x9E, (byte) 0xAB, (byte) 0xAB, (byte) 0xAD, (byte) 0xAD, (byte) 0xAF,
+/* B- */    (byte) 0xAF, (byte) 0xB1, (byte) 0xB2, (byte) 0xB3, (byte) 0xB4, (byte) 0xB5, (byte) 0xB6, (byte) 0xB7, (byte) 0xB8, (byte) 0xB9, (byte) 0xB1, (byte) 0xBB, (byte) 0xBB, (byte) 0xBD, (byte) 0xBD, (byte) 0xBF,
+/* C- */    (byte) 0xC0, (byte) 0xC1, (byte) 0xC2, (byte) 0xC3, (byte) 0xC4, (byte) 0xC5, (byte) 0xC6, (byte) 0xC7, (byte) 0xC8, (byte) 0xC9, (byte) 0xCA, (byte) 0xBF, (byte) 0xCC, (byte) 0xBF, (byte) 0xCE, (byte) 0xCF,
+/* D- */    (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7, (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0xDA, (byte) 0xDC, (byte) 0xDC, (byte) 0xDC, (byte) 0xDF,
+/* E- */    (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,
+/* F- */    (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7, (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xFF,
         };
-    
+
 
         public NGramParser_IBM420(int[] theNgramList, byte[] theByteMap)
         {
            super(theNgramList, theByteMap);
         }
-        
+
         private byte isLamAlef(byte b) {
              if(b == (byte)0xb2 || b == (byte)0xb3){
                  return (byte)0x47;
@@ -202,7 +205,7 @@ abstract class CharsetRecog_sbcs extends CharsetRecognizer {
              }else
                  return (byte)0x00;
          }
-        
+
         /*
          * Arabic shaping needs to be done manually. Cannot call ArabicShaping class
          * because CharsetDetector is dealing with bytes not Unicode code points. We could
@@ -214,70 +217,71 @@ abstract class CharsetRecog_sbcs extends CharsetRecognizer {
          {
              if (byteIndex >= det.fInputLen || det.fInputBytes[byteIndex] == 0) {
                  return -1;
-             }              
+             }
             int next;
-             
+
             alef = isLamAlef(det.fInputBytes[byteIndex]);
             if(alef != (byte)0x00)
                 next = 0xB1 & 0xFF;
             else
                 next = unshapeMap[det.fInputBytes[byteIndex]& 0xFF] & 0xFF;
-            
+
             byteIndex++;
-             
+
             return next;
          }
-         
+
+         @Override
          protected void parseCharacters(CharsetDetector det)
          {
-              int b;
+             int b;
              boolean ignoreSpace = false;
-             
+
              while ((b = nextByte(det)) >= 0) {
                  byte mb = byteMap[b];
-                 
+
                  // TODO: 0x20 might not be a space in all character sets...
                  if (mb != 0) {
                      if (!(mb == spaceChar && ignoreSpace)) {
-                         addByte(mb);                    
+                         addByte(mb);
                      }
-                     
+
                      ignoreSpace = (mb == spaceChar);
                  }
                  if(alef != (byte)0x00){
                      mb = byteMap[alef & 0xFF];
-                     
+
                      // TODO: 0x20 might not be a space in all character sets...
                      if (mb != 0) {
                          if (!(mb == spaceChar && ignoreSpace)) {
-                             addByte(mb);                    
+                             addByte(mb);
                          }
-                         
+
                          ignoreSpace = (mb == spaceChar);
                      }
-                     
+
                  }
              }
         }
     }
-        
-     
+
+
     int match(CharsetDetector det, int[] ngrams,  byte[] byteMap)
     {
         return match (det, ngrams, byteMap, (byte)0x20);
     }
-    
+
     int match(CharsetDetector det, int[] ngrams,  byte[] byteMap, byte spaceChar)
     {
         NGramParser parser = new NGramParser(ngrams, byteMap);
         return parser.parse(det, spaceChar);
     }
-    
+
     int matchIBM420(CharsetDetector det, int[] ngrams,  byte[] byteMap, byte spaceChar){
         NGramParser_IBM420 parser = new NGramParser_IBM420(ngrams, byteMap);
         return parser.parse(det, spaceChar);
     }
-    
+
     static class NGramsPlusLang {
         int[] fNGrams;
         String  fLang;
@@ -290,134 +294,135 @@ abstract class CharsetRecog_sbcs extends CharsetRecognizer {
     static class CharsetRecog_8859_1 extends CharsetRecog_sbcs
     {
         protected static byte[] byteMap = {
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0xAA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xB5, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0xBA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, 
-            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF, 
-            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0x20, 
-            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xDF, 
-            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, 
-            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF, 
-            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0x20, 
-            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xFF, 
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0xAA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xB5, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0xBA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,
+            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,
+            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0x20,
+            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xDF,
+            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,
+            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,
+            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0x20,
+            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xFF,
         };
-        
-       
+
+
         private static NGramsPlusLang[] ngrams_8859_1 = new NGramsPlusLang[] {
             new NGramsPlusLang(
-                    "da", 
+                    "da",
                     new int[] {
-                            0x206166, 0x206174, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920, 0x206D65, 0x206F67, 0x2070E5, 0x207369, 0x207374, 0x207469, 0x207669, 0x616620, 
-                            0x616E20, 0x616E64, 0x617220, 0x617420, 0x646520, 0x64656E, 0x646572, 0x646574, 0x652073, 0x656420, 0x656465, 0x656E20, 0x656E64, 0x657220, 0x657265, 0x657320, 
-                            0x657420, 0x666F72, 0x676520, 0x67656E, 0x676572, 0x696765, 0x696C20, 0x696E67, 0x6B6520, 0x6B6B65, 0x6C6572, 0x6C6967, 0x6C6C65, 0x6D6564, 0x6E6465, 0x6E6520, 
-                            0x6E6720, 0x6E6765, 0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722064, 0x722065, 0x722073, 0x726520, 0x737465, 0x742073, 0x746520, 0x746572, 0x74696C, 0x766572, 
+                            0x206166, 0x206174, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920, 0x206D65, 0x206F67, 0x2070E5, 0x207369, 0x207374, 0x207469, 0x207669, 0x616620,
+                            0x616E20, 0x616E64, 0x617220, 0x617420, 0x646520, 0x64656E, 0x646572, 0x646574, 0x652073, 0x656420, 0x656465, 0x656E20, 0x656E64, 0x657220, 0x657265, 0x657320,
+                            0x657420, 0x666F72, 0x676520, 0x67656E, 0x676572, 0x696765, 0x696C20, 0x696E67, 0x6B6520, 0x6B6B65, 0x6C6572, 0x6C6967, 0x6C6C65, 0x6D6564, 0x6E6465, 0x6E6520,
+                            0x6E6720, 0x6E6765, 0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722064, 0x722065, 0x722073, 0x726520, 0x737465, 0x742073, 0x746520, 0x746572, 0x74696C, 0x766572,
                     }),
             new NGramsPlusLang(
                     "de",
                     new int[] {
-                            0x20616E, 0x206175, 0x206265, 0x206461, 0x206465, 0x206469, 0x206569, 0x206765, 0x206861, 0x20696E, 0x206D69, 0x207363, 0x207365, 0x20756E, 0x207665, 0x20766F, 
-                            0x207765, 0x207A75, 0x626572, 0x636820, 0x636865, 0x636874, 0x646173, 0x64656E, 0x646572, 0x646965, 0x652064, 0x652073, 0x65696E, 0x656974, 0x656E20, 0x657220, 
-                            0x657320, 0x67656E, 0x68656E, 0x687420, 0x696368, 0x696520, 0x696E20, 0x696E65, 0x697420, 0x6C6963, 0x6C6C65, 0x6E2061, 0x6E2064, 0x6E2073, 0x6E6420, 0x6E6465, 
-                            0x6E6520, 0x6E6720, 0x6E6765, 0x6E7465, 0x722064, 0x726465, 0x726569, 0x736368, 0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x756E64, 0x756E67, 0x766572,                             
+                            0x20616E, 0x206175, 0x206265, 0x206461, 0x206465, 0x206469, 0x206569, 0x206765, 0x206861, 0x20696E, 0x206D69, 0x207363, 0x207365, 0x20756E, 0x207665, 0x20766F,
+                            0x207765, 0x207A75, 0x626572, 0x636820, 0x636865, 0x636874, 0x646173, 0x64656E, 0x646572, 0x646965, 0x652064, 0x652073, 0x65696E, 0x656974, 0x656E20, 0x657220,
+                            0x657320, 0x67656E, 0x68656E, 0x687420, 0x696368, 0x696520, 0x696E20, 0x696E65, 0x697420, 0x6C6963, 0x6C6C65, 0x6E2061, 0x6E2064, 0x6E2073, 0x6E6420, 0x6E6465,
+                            0x6E6520, 0x6E6720, 0x6E6765, 0x6E7465, 0x722064, 0x726465, 0x726569, 0x736368, 0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x756E64, 0x756E67, 0x766572,
                     }),
             new NGramsPlusLang(
                     "en",
                     new int[] {
-                            0x206120, 0x20616E, 0x206265, 0x20636F, 0x20666F, 0x206861, 0x206865, 0x20696E, 0x206D61, 0x206F66, 0x207072, 0x207265, 0x207361, 0x207374, 0x207468, 0x20746F, 
-                            0x207768, 0x616964, 0x616C20, 0x616E20, 0x616E64, 0x617320, 0x617420, 0x617465, 0x617469, 0x642061, 0x642074, 0x652061, 0x652073, 0x652074, 0x656420, 0x656E74, 
-                            0x657220, 0x657320, 0x666F72, 0x686174, 0x686520, 0x686572, 0x696420, 0x696E20, 0x696E67, 0x696F6E, 0x697320, 0x6E2061, 0x6E2074, 0x6E6420, 0x6E6720, 0x6E7420, 
-                            0x6F6620, 0x6F6E20, 0x6F7220, 0x726520, 0x727320, 0x732061, 0x732074, 0x736169, 0x737420, 0x742074, 0x746572, 0x746861, 0x746865, 0x74696F, 0x746F20, 0x747320, 
+                            0x206120, 0x20616E, 0x206265, 0x20636F, 0x20666F, 0x206861, 0x206865, 0x20696E, 0x206D61, 0x206F66, 0x207072, 0x207265, 0x207361, 0x207374, 0x207468, 0x20746F,
+                            0x207768, 0x616964, 0x616C20, 0x616E20, 0x616E64, 0x617320, 0x617420, 0x617465, 0x617469, 0x642061, 0x642074, 0x652061, 0x652073, 0x652074, 0x656420, 0x656E74,
+                            0x657220, 0x657320, 0x666F72, 0x686174, 0x686520, 0x686572, 0x696420, 0x696E20, 0x696E67, 0x696F6E, 0x697320, 0x6E2061, 0x6E2074, 0x6E6420, 0x6E6720, 0x6E7420,
+                            0x6F6620, 0x6F6E20, 0x6F7220, 0x726520, 0x727320, 0x732061, 0x732074, 0x736169, 0x737420, 0x742074, 0x746572, 0x746861, 0x746865, 0x74696F, 0x746F20, 0x747320,
                     }),
 
             new NGramsPlusLang(
                     "es",
                     new int[] {
-                            0x206120, 0x206361, 0x20636F, 0x206465, 0x20656C, 0x20656E, 0x206573, 0x20696E, 0x206C61, 0x206C6F, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207265, 0x207365, 
-                            0x20756E, 0x207920, 0x612063, 0x612064, 0x612065, 0x61206C, 0x612070, 0x616369, 0x61646F, 0x616C20, 0x617220, 0x617320, 0x6369F3, 0x636F6E, 0x646520, 0x64656C, 
-                            0x646F20, 0x652064, 0x652065, 0x65206C, 0x656C20, 0x656E20, 0x656E74, 0x657320, 0x657374, 0x69656E, 0x69F36E, 0x6C6120, 0x6C6F73, 0x6E2065, 0x6E7465, 0x6F2064, 
-                            0x6F2065, 0x6F6E20, 0x6F7220, 0x6F7320, 0x706172, 0x717565, 0x726120, 0x726573, 0x732064, 0x732065, 0x732070, 0x736520, 0x746520, 0x746F20, 0x756520, 0xF36E20, 
+                            0x206120, 0x206361, 0x20636F, 0x206465, 0x20656C, 0x20656E, 0x206573, 0x20696E, 0x206C61, 0x206C6F, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207265, 0x207365,
+                            0x20756E, 0x207920, 0x612063, 0x612064, 0x612065, 0x61206C, 0x612070, 0x616369, 0x61646F, 0x616C20, 0x617220, 0x617320, 0x6369F3, 0x636F6E, 0x646520, 0x64656C,
+                            0x646F20, 0x652064, 0x652065, 0x65206C, 0x656C20, 0x656E20, 0x656E74, 0x657320, 0x657374, 0x69656E, 0x69F36E, 0x6C6120, 0x6C6F73, 0x6E2065, 0x6E7465, 0x6F2064,
+                            0x6F2065, 0x6F6E20, 0x6F7220, 0x6F7320, 0x706172, 0x717565, 0x726120, 0x726573, 0x732064, 0x732065, 0x732070, 0x736520, 0x746520, 0x746F20, 0x756520, 0xF36E20,
                     }),
-                                            
+
             new NGramsPlusLang(
                     "fr",
                     new int[] {
-                            0x206175, 0x20636F, 0x206461, 0x206465, 0x206475, 0x20656E, 0x206574, 0x206C61, 0x206C65, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207365, 0x20736F, 0x20756E, 
-                            0x20E020, 0x616E74, 0x617469, 0x636520, 0x636F6E, 0x646520, 0x646573, 0x647520, 0x652061, 0x652063, 0x652064, 0x652065, 0x65206C, 0x652070, 0x652073, 0x656E20, 
-                            0x656E74, 0x657220, 0x657320, 0x657420, 0x657572, 0x696F6E, 0x697320, 0x697420, 0x6C6120, 0x6C6520, 0x6C6573, 0x6D656E, 0x6E2064, 0x6E6520, 0x6E7320, 0x6E7420, 
+                            0x206175, 0x20636F, 0x206461, 0x206465, 0x206475, 0x20656E, 0x206574, 0x206C61, 0x206C65, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207365, 0x20736F, 0x20756E,
+                            0x20E020, 0x616E74, 0x617469, 0x636520, 0x636F6E, 0x646520, 0x646573, 0x647520, 0x652061, 0x652063, 0x652064, 0x652065, 0x65206C, 0x652070, 0x652073, 0x656E20,
+                            0x656E74, 0x657220, 0x657320, 0x657420, 0x657572, 0x696F6E, 0x697320, 0x697420, 0x6C6120, 0x6C6520, 0x6C6573, 0x6D656E, 0x6E2064, 0x6E6520, 0x6E7320, 0x6E7420,
                             0x6F6E20, 0x6F6E74, 0x6F7572, 0x717565, 0x72206C, 0x726520, 0x732061, 0x732064, 0x732065, 0x73206C, 0x732070, 0x742064, 0x746520, 0x74696F, 0x756520, 0x757220,
                     }),
 
             new NGramsPlusLang(
                     "it",
                     new int[] {
-                            0x20616C, 0x206368, 0x20636F, 0x206465, 0x206469, 0x206520, 0x20696C, 0x20696E, 0x206C61, 0x207065, 0x207072, 0x20756E, 0x612063, 0x612064, 0x612070, 0x612073, 
-                            0x61746F, 0x636865, 0x636F6E, 0x64656C, 0x646920, 0x652061, 0x652063, 0x652064, 0x652069, 0x65206C, 0x652070, 0x652073, 0x656C20, 0x656C6C, 0x656E74, 0x657220, 
-                            0x686520, 0x692061, 0x692063, 0x692064, 0x692073, 0x696120, 0x696C20, 0x696E20, 0x696F6E, 0x6C6120, 0x6C6520, 0x6C6920, 0x6C6C61, 0x6E6520, 0x6E6920, 0x6E6F20, 
-                            0x6E7465, 0x6F2061, 0x6F2064, 0x6F2069, 0x6F2073, 0x6F6E20, 0x6F6E65, 0x706572, 0x726120, 0x726520, 0x736920, 0x746120, 0x746520, 0x746920, 0x746F20, 0x7A696F, 
+                            0x20616C, 0x206368, 0x20636F, 0x206465, 0x206469, 0x206520, 0x20696C, 0x20696E, 0x206C61, 0x207065, 0x207072, 0x20756E, 0x612063, 0x612064, 0x612070, 0x612073,
+                            0x61746F, 0x636865, 0x636F6E, 0x64656C, 0x646920, 0x652061, 0x652063, 0x652064, 0x652069, 0x65206C, 0x652070, 0x652073, 0x656C20, 0x656C6C, 0x656E74, 0x657220,
+                            0x686520, 0x692061, 0x692063, 0x692064, 0x692073, 0x696120, 0x696C20, 0x696E20, 0x696F6E, 0x6C6120, 0x6C6520, 0x6C6920, 0x6C6C61, 0x6E6520, 0x6E6920, 0x6E6F20,
+                            0x6E7465, 0x6F2061, 0x6F2064, 0x6F2069, 0x6F2073, 0x6F6E20, 0x6F6E65, 0x706572, 0x726120, 0x726520, 0x736920, 0x746120, 0x746520, 0x746920, 0x746F20, 0x7A696F,
                     }),
-                    
+
             new NGramsPlusLang(
                     "nl",
                     new int[] {
-                            0x20616C, 0x206265, 0x206461, 0x206465, 0x206469, 0x206565, 0x20656E, 0x206765, 0x206865, 0x20696E, 0x206D61, 0x206D65, 0x206F70, 0x207465, 0x207661, 0x207665, 
-                            0x20766F, 0x207765, 0x207A69, 0x61616E, 0x616172, 0x616E20, 0x616E64, 0x617220, 0x617420, 0x636874, 0x646520, 0x64656E, 0x646572, 0x652062, 0x652076, 0x65656E, 
-                            0x656572, 0x656E20, 0x657220, 0x657273, 0x657420, 0x67656E, 0x686574, 0x696520, 0x696E20, 0x696E67, 0x697320, 0x6E2062, 0x6E2064, 0x6E2065, 0x6E2068, 0x6E206F, 
-                            0x6E2076, 0x6E6465, 0x6E6720, 0x6F6E64, 0x6F6F72, 0x6F7020, 0x6F7220, 0x736368, 0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x76616E, 0x766572, 0x766F6F, 
+                            0x20616C, 0x206265, 0x206461, 0x206465, 0x206469, 0x206565, 0x20656E, 0x206765, 0x206865, 0x20696E, 0x206D61, 0x206D65, 0x206F70, 0x207465, 0x207661, 0x207665,
+                            0x20766F, 0x207765, 0x207A69, 0x61616E, 0x616172, 0x616E20, 0x616E64, 0x617220, 0x617420, 0x636874, 0x646520, 0x64656E, 0x646572, 0x652062, 0x652076, 0x65656E,
+                            0x656572, 0x656E20, 0x657220, 0x657273, 0x657420, 0x67656E, 0x686574, 0x696520, 0x696E20, 0x696E67, 0x697320, 0x6E2062, 0x6E2064, 0x6E2065, 0x6E2068, 0x6E206F,
+                            0x6E2076, 0x6E6465, 0x6E6720, 0x6F6E64, 0x6F6F72, 0x6F7020, 0x6F7220, 0x736368, 0x737465, 0x742064, 0x746520, 0x74656E, 0x746572, 0x76616E, 0x766572, 0x766F6F,
                     }),
-                    
+
             new NGramsPlusLang(
                     "no",
                     new int[] {
-                            0x206174, 0x206176, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920, 0x206D65, 0x206F67, 0x2070E5, 0x207365, 0x20736B, 0x20736F, 0x207374, 0x207469, 
-                            0x207669, 0x20E520, 0x616E64, 0x617220, 0x617420, 0x646520, 0x64656E, 0x646574, 0x652073, 0x656420, 0x656E20, 0x656E65, 0x657220, 0x657265, 0x657420, 0x657474, 
-                            0x666F72, 0x67656E, 0x696B6B, 0x696C20, 0x696E67, 0x6B6520, 0x6B6B65, 0x6C6520, 0x6C6C65, 0x6D6564, 0x6D656E, 0x6E2073, 0x6E6520, 0x6E6720, 0x6E6765, 0x6E6E65, 
-                            0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722073, 0x726520, 0x736F6D, 0x737465, 0x742073, 0x746520, 0x74656E, 0x746572, 0x74696C, 0x747420, 0x747465, 0x766572, 
+                            0x206174, 0x206176, 0x206465, 0x20656E, 0x206572, 0x20666F, 0x206861, 0x206920, 0x206D65, 0x206F67, 0x2070E5, 0x207365, 0x20736B, 0x20736F, 0x207374, 0x207469,
+                            0x207669, 0x20E520, 0x616E64, 0x617220, 0x617420, 0x646520, 0x64656E, 0x646574, 0x652073, 0x656420, 0x656E20, 0x656E65, 0x657220, 0x657265, 0x657420, 0x657474,
+                            0x666F72, 0x67656E, 0x696B6B, 0x696C20, 0x696E67, 0x6B6520, 0x6B6B65, 0x6C6520, 0x6C6C65, 0x6D6564, 0x6D656E, 0x6E2073, 0x6E6520, 0x6E6720, 0x6E6765, 0x6E6E65,
+                            0x6F6720, 0x6F6D20, 0x6F7220, 0x70E520, 0x722073, 0x726520, 0x736F6D, 0x737465, 0x742073, 0x746520, 0x74656E, 0x746572, 0x74696C, 0x747420, 0x747465, 0x766572,
                     }),
-                    
+
             new NGramsPlusLang(
                     "pt",
                     new int[] {
-                            0x206120, 0x20636F, 0x206461, 0x206465, 0x20646F, 0x206520, 0x206573, 0x206D61, 0x206E6F, 0x206F20, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207265, 0x207365, 
-                            0x20756D, 0x612061, 0x612063, 0x612064, 0x612070, 0x616465, 0x61646F, 0x616C20, 0x617220, 0x617261, 0x617320, 0x636F6D, 0x636F6E, 0x646120, 0x646520, 0x646F20, 
-                            0x646F73, 0x652061, 0x652064, 0x656D20, 0x656E74, 0x657320, 0x657374, 0x696120, 0x696361, 0x6D656E, 0x6E7465, 0x6E746F, 0x6F2061, 0x6F2063, 0x6F2064, 0x6F2065, 
-                            0x6F2070, 0x6F7320, 0x706172, 0x717565, 0x726120, 0x726573, 0x732061, 0x732064, 0x732065, 0x732070, 0x737461, 0x746520, 0x746F20, 0x756520, 0xE36F20, 0xE7E36F, 
+                            0x206120, 0x20636F, 0x206461, 0x206465, 0x20646F, 0x206520, 0x206573, 0x206D61, 0x206E6F, 0x206F20, 0x207061, 0x20706F, 0x207072, 0x207175, 0x207265, 0x207365,
+                            0x20756D, 0x612061, 0x612063, 0x612064, 0x612070, 0x616465, 0x61646F, 0x616C20, 0x617220, 0x617261, 0x617320, 0x636F6D, 0x636F6E, 0x646120, 0x646520, 0x646F20,
+                            0x646F73, 0x652061, 0x652064, 0x656D20, 0x656E74, 0x657320, 0x657374, 0x696120, 0x696361, 0x6D656E, 0x6E7465, 0x6E746F, 0x6F2061, 0x6F2063, 0x6F2064, 0x6F2065,
+                            0x6F2070, 0x6F7320, 0x706172, 0x717565, 0x726120, 0x726573, 0x732061, 0x732064, 0x732065, 0x732070, 0x737461, 0x746520, 0x746F20, 0x756520, 0xE36F20, 0xE7E36F,
 
                     }),
-                    
+
             new NGramsPlusLang(
                     "sv",
                     new int[] {
-                            0x206174, 0x206176, 0x206465, 0x20656E, 0x2066F6, 0x206861, 0x206920, 0x20696E, 0x206B6F, 0x206D65, 0x206F63, 0x2070E5, 0x20736B, 0x20736F, 0x207374, 0x207469, 
-                            0x207661, 0x207669, 0x20E472, 0x616465, 0x616E20, 0x616E64, 0x617220, 0x617474, 0x636820, 0x646520, 0x64656E, 0x646572, 0x646574, 0x656420, 0x656E20, 0x657220, 
-                            0x657420, 0x66F672, 0x67656E, 0x696C6C, 0x696E67, 0x6B6120, 0x6C6C20, 0x6D6564, 0x6E2073, 0x6E6120, 0x6E6465, 0x6E6720, 0x6E6765, 0x6E696E, 0x6F6368, 0x6F6D20, 
-                            0x6F6E20, 0x70E520, 0x722061, 0x722073, 0x726120, 0x736B61, 0x736F6D, 0x742073, 0x746120, 0x746520, 0x746572, 0x74696C, 0x747420, 0x766172, 0xE47220, 0xF67220, 
+                            0x206174, 0x206176, 0x206465, 0x20656E, 0x2066F6, 0x206861, 0x206920, 0x20696E, 0x206B6F, 0x206D65, 0x206F63, 0x2070E5, 0x20736B, 0x20736F, 0x207374, 0x207469,
+                            0x207661, 0x207669, 0x20E472, 0x616465, 0x616E20, 0x616E64, 0x617220, 0x617474, 0x636820, 0x646520, 0x64656E, 0x646572, 0x646574, 0x656420, 0x656E20, 0x657220,
+                            0x657420, 0x66F672, 0x67656E, 0x696C6C, 0x696E67, 0x6B6120, 0x6C6C20, 0x6D6564, 0x6E2073, 0x6E6120, 0x6E6465, 0x6E6720, 0x6E6765, 0x6E696E, 0x6F6368, 0x6F6D20,
+                            0x6F6E20, 0x70E520, 0x722061, 0x722073, 0x726120, 0x736B61, 0x736F6D, 0x742073, 0x746120, 0x746520, 0x746572, 0x74696C, 0x747420, 0x766172, 0xE47220, 0xF67220,
                     }),
-                    
+
         };
 
-        
+
+        @Override
         public CharsetMatch match(CharsetDetector det)
         {
             String name = det.fC1Bytes ? "windows-1252" : "ISO-8859-1";
@@ -433,86 +438,88 @@ abstract class CharsetRecog_sbcs extends CharsetRecognizer {
             return bestConfidenceSoFar <= 0 ? null : new CharsetMatch(det, this, bestConfidenceSoFar, name, lang);
         }
 
-            
+
+        @Override
         public String getName()
         {
             return "ISO-8859-1";
         }
     }
 
-    
+
     static class CharsetRecog_8859_2 extends CharsetRecog_sbcs
     {
         protected static byte[] byteMap = {
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0xB1, (byte) 0x20, (byte) 0xB3, (byte) 0x20, (byte) 0xB5, (byte) 0xB6, (byte) 0x20, 
-            (byte) 0x20, (byte) 0xB9, (byte) 0xBA, (byte) 0xBB, (byte) 0xBC, (byte) 0x20, (byte) 0xBE, (byte) 0xBF, 
-            (byte) 0x20, (byte) 0xB1, (byte) 0x20, (byte) 0xB3, (byte) 0x20, (byte) 0xB5, (byte) 0xB6, (byte) 0xB7, 
-            (byte) 0x20, (byte) 0xB9, (byte) 0xBA, (byte) 0xBB, (byte) 0xBC, (byte) 0x20, (byte) 0xBE, (byte) 0xBF, 
-            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, 
-            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF, 
-            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0x20, 
-            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xDF, 
-            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, 
-            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF, 
-            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0x20, 
-            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0x20, 
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0xB1, (byte) 0x20, (byte) 0xB3, (byte) 0x20, (byte) 0xB5, (byte) 0xB6, (byte) 0x20,
+            (byte) 0x20, (byte) 0xB9, (byte) 0xBA, (byte) 0xBB, (byte) 0xBC, (byte) 0x20, (byte) 0xBE, (byte) 0xBF,
+            (byte) 0x20, (byte) 0xB1, (byte) 0x20, (byte) 0xB3, (byte) 0x20, (byte) 0xB5, (byte) 0xB6, (byte) 0xB7,
+            (byte) 0x20, (byte) 0xB9, (byte) 0xBA, (byte) 0xBB, (byte) 0xBC, (byte) 0x20, (byte) 0xBE, (byte) 0xBF,
+            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,
+            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,
+            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0x20,
+            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xDF,
+            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,
+            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,
+            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0x20,
+            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0x20,
         };
 
         private static NGramsPlusLang[] ngrams_8859_2 = new NGramsPlusLang[] {
             new NGramsPlusLang(
-                    "cs", 
+                    "cs",
                     new int[] {
-                            0x206120, 0x206279, 0x20646F, 0x206A65, 0x206E61, 0x206E65, 0x206F20, 0x206F64, 0x20706F, 0x207072, 0x2070F8, 0x20726F, 0x207365, 0x20736F, 0x207374, 0x20746F, 
-                            0x207620, 0x207679, 0x207A61, 0x612070, 0x636520, 0x636820, 0x652070, 0x652073, 0x652076, 0x656D20, 0x656EED, 0x686F20, 0x686F64, 0x697374, 0x6A6520, 0x6B7465, 
-                            0x6C6520, 0x6C6920, 0x6E6120, 0x6EE920, 0x6EEC20, 0x6EED20, 0x6F2070, 0x6F646E, 0x6F6A69, 0x6F7374, 0x6F7520, 0x6F7661, 0x706F64, 0x706F6A, 0x70726F, 0x70F865, 
-                            0x736520, 0x736F75, 0x737461, 0x737469, 0x73746E, 0x746572, 0x746EED, 0x746F20, 0x752070, 0xBE6520, 0xE16EED, 0xE9686F, 0xED2070, 0xED2073, 0xED6D20, 0xF86564, 
+                            0x206120, 0x206279, 0x20646F, 0x206A65, 0x206E61, 0x206E65, 0x206F20, 0x206F64, 0x20706F, 0x207072, 0x2070F8, 0x20726F, 0x207365, 0x20736F, 0x207374, 0x20746F,
+                            0x207620, 0x207679, 0x207A61, 0x612070, 0x636520, 0x636820, 0x652070, 0x652073, 0x652076, 0x656D20, 0x656EED, 0x686F20, 0x686F64, 0x697374, 0x6A6520, 0x6B7465,
+                            0x6C6520, 0x6C6920, 0x6E6120, 0x6EE920, 0x6EEC20, 0x6EED20, 0x6F2070, 0x6F646E, 0x6F6A69, 0x6F7374, 0x6F7520, 0x6F7661, 0x706F64, 0x706F6A, 0x70726F, 0x70F865,
+                            0x736520, 0x736F75, 0x737461, 0x737469, 0x73746E, 0x746572, 0x746EED, 0x746F20, 0x752070, 0xBE6520, 0xE16EED, 0xE9686F, 0xED2070, 0xED2073, 0xED6D20, 0xF86564,
                     }),
             new NGramsPlusLang(
-                    "hu", 
+                    "hu",
                     new int[] {
-                            0x206120, 0x20617A, 0x206265, 0x206567, 0x20656C, 0x206665, 0x206861, 0x20686F, 0x206973, 0x206B65, 0x206B69, 0x206BF6, 0x206C65, 0x206D61, 0x206D65, 0x206D69, 
-                            0x206E65, 0x20737A, 0x207465, 0x20E973, 0x612061, 0x61206B, 0x61206D, 0x612073, 0x616B20, 0x616E20, 0x617A20, 0x62616E, 0x62656E, 0x656779, 0x656B20, 0x656C20, 
-                            0x656C65, 0x656D20, 0x656E20, 0x657265, 0x657420, 0x657465, 0x657474, 0x677920, 0x686F67, 0x696E74, 0x697320, 0x6B2061, 0x6BF67A, 0x6D6567, 0x6D696E, 0x6E2061, 
-                            0x6E616B, 0x6E656B, 0x6E656D, 0x6E7420, 0x6F6779, 0x732061, 0x737A65, 0x737A74, 0x737AE1, 0x73E967, 0x742061, 0x747420, 0x74E173, 0x7A6572, 0xE16E20, 0xE97320, 
+                            0x206120, 0x20617A, 0x206265, 0x206567, 0x20656C, 0x206665, 0x206861, 0x20686F, 0x206973, 0x206B65, 0x206B69, 0x206BF6, 0x206C65, 0x206D61, 0x206D65, 0x206D69,
+                            0x206E65, 0x20737A, 0x207465, 0x20E973, 0x612061, 0x61206B, 0x61206D, 0x612073, 0x616B20, 0x616E20, 0x617A20, 0x62616E, 0x62656E, 0x656779, 0x656B20, 0x656C20,
+                            0x656C65, 0x656D20, 0x656E20, 0x657265, 0x657420, 0x657465, 0x657474, 0x677920, 0x686F67, 0x696E74, 0x697320, 0x6B2061, 0x6BF67A, 0x6D6567, 0x6D696E, 0x6E2061,
+                            0x6E616B, 0x6E656B, 0x6E656D, 0x6E7420, 0x6F6779, 0x732061, 0x737A65, 0x737A74, 0x737AE1, 0x73E967, 0x742061, 0x747420, 0x74E173, 0x7A6572, 0xE16E20, 0xE97320,
                     }),
             new NGramsPlusLang(
-                    "pl", 
+                    "pl",
                     new int[] {
-                            0x20637A, 0x20646F, 0x206920, 0x206A65, 0x206B6F, 0x206D61, 0x206D69, 0x206E61, 0x206E69, 0x206F64, 0x20706F, 0x207072, 0x207369, 0x207720, 0x207769, 0x207779, 
-                            0x207A20, 0x207A61, 0x612070, 0x612077, 0x616E69, 0x636820, 0x637A65, 0x637A79, 0x646F20, 0x647A69, 0x652070, 0x652073, 0x652077, 0x65207A, 0x65676F, 0x656A20, 
-                            0x656D20, 0x656E69, 0x676F20, 0x696120, 0x696520, 0x69656A, 0x6B6120, 0x6B6920, 0x6B6965, 0x6D6965, 0x6E6120, 0x6E6961, 0x6E6965, 0x6F2070, 0x6F7761, 0x6F7769, 
-                            0x706F6C, 0x707261, 0x70726F, 0x70727A, 0x727A65, 0x727A79, 0x7369EA, 0x736B69, 0x737461, 0x776965, 0x796368, 0x796D20, 0x7A6520, 0x7A6965, 0x7A7920, 0xF37720, 
+                            0x20637A, 0x20646F, 0x206920, 0x206A65, 0x206B6F, 0x206D61, 0x206D69, 0x206E61, 0x206E69, 0x206F64, 0x20706F, 0x207072, 0x207369, 0x207720, 0x207769, 0x207779,
+                            0x207A20, 0x207A61, 0x612070, 0x612077, 0x616E69, 0x636820, 0x637A65, 0x637A79, 0x646F20, 0x647A69, 0x652070, 0x652073, 0x652077, 0x65207A, 0x65676F, 0x656A20,
+                            0x656D20, 0x656E69, 0x676F20, 0x696120, 0x696520, 0x69656A, 0x6B6120, 0x6B6920, 0x6B6965, 0x6D6965, 0x6E6120, 0x6E6961, 0x6E6965, 0x6F2070, 0x6F7761, 0x6F7769,
+                            0x706F6C, 0x707261, 0x70726F, 0x70727A, 0x727A65, 0x727A79, 0x7369EA, 0x736B69, 0x737461, 0x776965, 0x796368, 0x796D20, 0x7A6520, 0x7A6965, 0x7A7920, 0xF37720,
                     }),
             new NGramsPlusLang(
-                    "ro", 
+                    "ro",
                     new int[] {
-                            0x206120, 0x206163, 0x206361, 0x206365, 0x20636F, 0x206375, 0x206465, 0x206469, 0x206C61, 0x206D61, 0x207065, 0x207072, 0x207365, 0x2073E3, 0x20756E, 0x20BA69, 
-                            0x20EE6E, 0x612063, 0x612064, 0x617265, 0x617420, 0x617465, 0x617520, 0x636172, 0x636F6E, 0x637520, 0x63E320, 0x646520, 0x652061, 0x652063, 0x652064, 0x652070, 
-                            0x652073, 0x656120, 0x656920, 0x656C65, 0x656E74, 0x657374, 0x692061, 0x692063, 0x692064, 0x692070, 0x696520, 0x696920, 0x696E20, 0x6C6120, 0x6C6520, 0x6C6F72, 
-                            0x6C7569, 0x6E6520, 0x6E7472, 0x6F7220, 0x70656E, 0x726520, 0x726561, 0x727520, 0x73E320, 0x746520, 0x747275, 0x74E320, 0x756920, 0x756C20, 0xBA6920, 0xEE6E20, 
+                            0x206120, 0x206163, 0x206361, 0x206365, 0x20636F, 0x206375, 0x206465, 0x206469, 0x206C61, 0x206D61, 0x207065, 0x207072, 0x207365, 0x2073E3, 0x20756E, 0x20BA69,
+                            0x20EE6E, 0x612063, 0x612064, 0x617265, 0x617420, 0x617465, 0x617520, 0x636172, 0x636F6E, 0x637520, 0x63E320, 0x646520, 0x652061, 0x652063, 0x652064, 0x652070,
+                            0x652073, 0x656120, 0x656920, 0x656C65, 0x656E74, 0x657374, 0x692061, 0x692063, 0x692064, 0x692070, 0x696520, 0x696920, 0x696E20, 0x6C6120, 0x6C6520, 0x6C6F72,
+                            0x6C7569, 0x6E6520, 0x6E7472, 0x6F7220, 0x70656E, 0x726520, 0x726561, 0x727520, 0x73E320, 0x746520, 0x747275, 0x74E320, 0x756920, 0x756C20, 0xBA6920, 0xEE6E20,
                     })
         };
 
+        @Override
         public CharsetMatch match(CharsetDetector det)
         {
             String name = det.fC1Bytes ? "windows-1250" : "ISO-8859-2";
@@ -528,199 +535,209 @@ abstract class CharsetRecog_sbcs extends CharsetRecognizer {
             return bestConfidenceSoFar <= 0 ? null : new CharsetMatch(det, this, bestConfidenceSoFar, name, lang);
         }
 
+        @Override
         public String getName()
         {
             return "ISO-8859-2";
         }
 
     }
-    
-    
+
+
     abstract static class CharsetRecog_8859_5 extends CharsetRecog_sbcs
     {
         protected static byte[] byteMap = {
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7, 
-            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0x20, (byte) 0xFE, (byte) 0xFF, 
-            (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7, 
-            (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF, 
-            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, 
-            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF, 
-            (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7, 
-            (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF, 
-            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, 
-            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF, 
-            (byte) 0x20, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7, 
-            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0x20, (byte) 0xFE, (byte) 0xFF, 
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7,
+            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0x20, (byte) 0xFE, (byte) 0xFF,
+            (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7,
+            (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF,
+            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,
+            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,
+            (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7,
+            (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF,
+            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,
+            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,
+            (byte) 0x20, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7,
+            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0x20, (byte) 0xFE, (byte) 0xFF,
         };
 
+        @Override
         public String getName()
         {
             return "ISO-8859-5";
         }
     }
-    
+
     static class CharsetRecog_8859_5_ru extends CharsetRecog_8859_5
     {
         private static int[] ngrams = {
-            0x20D220, 0x20D2DE, 0x20D4DE, 0x20D7D0, 0x20D820, 0x20DAD0, 0x20DADE, 0x20DDD0, 0x20DDD5, 0x20DED1, 0x20DFDE, 0x20DFE0, 0x20E0D0, 0x20E1DE, 0x20E1E2, 0x20E2DE, 
-            0x20E7E2, 0x20EDE2, 0xD0DDD8, 0xD0E2EC, 0xD3DE20, 0xD5DBEC, 0xD5DDD8, 0xD5E1E2, 0xD5E220, 0xD820DF, 0xD8D520, 0xD8D820, 0xD8EF20, 0xDBD5DD, 0xDBD820, 0xDBECDD, 
-            0xDDD020, 0xDDD520, 0xDDD8D5, 0xDDD8EF, 0xDDDE20, 0xDDDED2, 0xDE20D2, 0xDE20DF, 0xDE20E1, 0xDED220, 0xDED2D0, 0xDED3DE, 0xDED920, 0xDEDBEC, 0xDEDC20, 0xDEE1E2, 
-            0xDFDEDB, 0xDFE0D5, 0xDFE0D8, 0xDFE0DE, 0xE0D0D2, 0xE0D5D4, 0xE1E2D0, 0xE1E2D2, 0xE1E2D8, 0xE1EF20, 0xE2D5DB, 0xE2DE20, 0xE2DEE0, 0xE2EC20, 0xE7E2DE, 0xEBE520, 
+            0x20D220, 0x20D2DE, 0x20D4DE, 0x20D7D0, 0x20D820, 0x20DAD0, 0x20DADE, 0x20DDD0, 0x20DDD5, 0x20DED1, 0x20DFDE, 0x20DFE0, 0x20E0D0, 0x20E1DE, 0x20E1E2, 0x20E2DE,
+            0x20E7E2, 0x20EDE2, 0xD0DDD8, 0xD0E2EC, 0xD3DE20, 0xD5DBEC, 0xD5DDD8, 0xD5E1E2, 0xD5E220, 0xD820DF, 0xD8D520, 0xD8D820, 0xD8EF20, 0xDBD5DD, 0xDBD820, 0xDBECDD,
+            0xDDD020, 0xDDD520, 0xDDD8D5, 0xDDD8EF, 0xDDDE20, 0xDDDED2, 0xDE20D2, 0xDE20DF, 0xDE20E1, 0xDED220, 0xDED2D0, 0xDED3DE, 0xDED920, 0xDEDBEC, 0xDEDC20, 0xDEE1E2,
+            0xDFDEDB, 0xDFE0D5, 0xDFE0D8, 0xDFE0DE, 0xE0D0D2, 0xE0D5D4, 0xE1E2D0, 0xE1E2D2, 0xE1E2D8, 0xE1EF20, 0xE2D5DB, 0xE2DE20, 0xE2DEE0, 0xE2EC20, 0xE7E2DE, 0xEBE520,
         };
 
+        @Override
         public String getLanguage()
         {
             return "ru";
         }
-        
+
+        @Override
         public CharsetMatch match(CharsetDetector det)
         {
             int confidence = match(det, ngrams, byteMap);
             return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
         }
     }
-    
+
     abstract static class CharsetRecog_8859_6 extends CharsetRecog_sbcs
     {
         protected static byte[] byteMap = {
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0xC1, (byte) 0xC2, (byte) 0xC3, (byte) 0xC4, (byte) 0xC5, (byte) 0xC6, (byte) 0xC7, 
-            (byte) 0xC8, (byte) 0xC9, (byte) 0xCA, (byte) 0xCB, (byte) 0xCC, (byte) 0xCD, (byte) 0xCE, (byte) 0xCF, 
-            (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7, 
-            (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, 
-            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0xC1, (byte) 0xC2, (byte) 0xC3, (byte) 0xC4, (byte) 0xC5, (byte) 0xC6, (byte) 0xC7,
+            (byte) 0xC8, (byte) 0xC9, (byte) 0xCA, (byte) 0xCB, (byte) 0xCC, (byte) 0xCD, (byte) 0xCE, (byte) 0xCF,
+            (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7,
+            (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,
+            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
         };
 
+        @Override
         public String getName()
         {
             return "ISO-8859-6";
         }
     }
-    
+
     static class CharsetRecog_8859_6_ar extends CharsetRecog_8859_6
     {
         private static int[] ngrams = {
-            0x20C7E4, 0x20C7E6, 0x20C8C7, 0x20D9E4, 0x20E1EA, 0x20E4E4, 0x20E5E6, 0x20E8C7, 0xC720C7, 0xC7C120, 0xC7CA20, 0xC7D120, 0xC7E420, 0xC7E4C3, 0xC7E4C7, 0xC7E4C8, 
-            0xC7E4CA, 0xC7E4CC, 0xC7E4CD, 0xC7E4CF, 0xC7E4D3, 0xC7E4D9, 0xC7E4E2, 0xC7E4E5, 0xC7E4E8, 0xC7E4EA, 0xC7E520, 0xC7E620, 0xC7E6CA, 0xC820C7, 0xC920C7, 0xC920E1, 
-            0xC920E4, 0xC920E5, 0xC920E8, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920, 0xD320C7, 0xD920C7, 0xD9E4E9, 0xE1EA20, 0xE420C7, 0xE4C920, 0xE4E920, 0xE4EA20, 
-            0xE520C7, 0xE5C720, 0xE5C920, 0xE5E620, 0xE620C7, 0xE720C7, 0xE7C720, 0xE8C7E4, 0xE8E620, 0xE920C7, 0xEA20C7, 0xEA20E5, 0xEA20E8, 0xEAC920, 0xEAD120, 0xEAE620, 
+            0x20C7E4, 0x20C7E6, 0x20C8C7, 0x20D9E4, 0x20E1EA, 0x20E4E4, 0x20E5E6, 0x20E8C7, 0xC720C7, 0xC7C120, 0xC7CA20, 0xC7D120, 0xC7E420, 0xC7E4C3, 0xC7E4C7, 0xC7E4C8,
+            0xC7E4CA, 0xC7E4CC, 0xC7E4CD, 0xC7E4CF, 0xC7E4D3, 0xC7E4D9, 0xC7E4E2, 0xC7E4E5, 0xC7E4E8, 0xC7E4EA, 0xC7E520, 0xC7E620, 0xC7E6CA, 0xC820C7, 0xC920C7, 0xC920E1,
+            0xC920E4, 0xC920E5, 0xC920E8, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920, 0xD320C7, 0xD920C7, 0xD9E4E9, 0xE1EA20, 0xE420C7, 0xE4C920, 0xE4E920, 0xE4EA20,
+            0xE520C7, 0xE5C720, 0xE5C920, 0xE5E620, 0xE620C7, 0xE720C7, 0xE7C720, 0xE8C7E4, 0xE8E620, 0xE920C7, 0xEA20C7, 0xEA20E5, 0xEA20E8, 0xEAC920, 0xEAD120, 0xEAE620,
         };
 
+        @Override
         public String getLanguage()
         {
             return "ar";
         }
-        
+
+        @Override
         public CharsetMatch match(CharsetDetector det)
         {
             int confidence = match(det, ngrams, byteMap);
             return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
         }
     }
-    
+
     abstract static class CharsetRecog_8859_7 extends CharsetRecog_sbcs
     {
         protected static byte[] byteMap = {
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0xA1, (byte) 0xA2, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xDC, (byte) 0x20, 
-            (byte) 0xDD, (byte) 0xDE, (byte) 0xDF, (byte) 0x20, (byte) 0xFC, (byte) 0x20, (byte) 0xFD, (byte) 0xFE, 
-            (byte) 0xC0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, 
-            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF, 
-            (byte) 0xF0, (byte) 0xF1, (byte) 0x20, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7, 
-            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF, 
-            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, 
-            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF, 
-            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7, 
-            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0x20, 
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0xA1, (byte) 0xA2, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xDC, (byte) 0x20,
+            (byte) 0xDD, (byte) 0xDE, (byte) 0xDF, (byte) 0x20, (byte) 0xFC, (byte) 0x20, (byte) 0xFD, (byte) 0xFE,
+            (byte) 0xC0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,
+            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,
+            (byte) 0xF0, (byte) 0xF1, (byte) 0x20, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7,
+            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF,
+            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,
+            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,
+            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7,
+            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0x20,
         };
 
+        @Override
         public String getName()
         {
             return "ISO-8859-7";
         }
     }
-    
+
     static class CharsetRecog_8859_7_el extends CharsetRecog_8859_7
     {
         private static int[] ngrams = {
-            0x20E1ED, 0x20E1F0, 0x20E3E9, 0x20E4E9, 0x20E5F0, 0x20E720, 0x20EAE1, 0x20ECE5, 0x20EDE1, 0x20EF20, 0x20F0E1, 0x20F0EF, 0x20F0F1, 0x20F3F4, 0x20F3F5, 0x20F4E7, 
-            0x20F4EF, 0xDFE120, 0xE120E1, 0xE120F4, 0xE1E920, 0xE1ED20, 0xE1F0FC, 0xE1F220, 0xE3E9E1, 0xE5E920, 0xE5F220, 0xE720F4, 0xE7ED20, 0xE7F220, 0xE920F4, 0xE9E120, 
-            0xE9EADE, 0xE9F220, 0xEAE1E9, 0xEAE1F4, 0xECE520, 0xED20E1, 0xED20E5, 0xED20F0, 0xEDE120, 0xEFF220, 0xEFF520, 0xF0EFF5, 0xF0F1EF, 0xF0FC20, 0xF220E1, 0xF220E5, 
-            0xF220EA, 0xF220F0, 0xF220F4, 0xF3E520, 0xF3E720, 0xF3F4EF, 0xF4E120, 0xF4E1E9, 0xF4E7ED, 0xF4E7F2, 0xF4E9EA, 0xF4EF20, 0xF4EFF5, 0xF4F9ED, 0xF9ED20, 0xFEED20, 
+            0x20E1ED, 0x20E1F0, 0x20E3E9, 0x20E4E9, 0x20E5F0, 0x20E720, 0x20EAE1, 0x20ECE5, 0x20EDE1, 0x20EF20, 0x20F0E1, 0x20F0EF, 0x20F0F1, 0x20F3F4, 0x20F3F5, 0x20F4E7,
+            0x20F4EF, 0xDFE120, 0xE120E1, 0xE120F4, 0xE1E920, 0xE1ED20, 0xE1F0FC, 0xE1F220, 0xE3E9E1, 0xE5E920, 0xE5F220, 0xE720F4, 0xE7ED20, 0xE7F220, 0xE920F4, 0xE9E120,
+            0xE9EADE, 0xE9F220, 0xEAE1E9, 0xEAE1F4, 0xECE520, 0xED20E1, 0xED20E5, 0xED20F0, 0xEDE120, 0xEFF220, 0xEFF520, 0xF0EFF5, 0xF0F1EF, 0xF0FC20, 0xF220E1, 0xF220E5,
+            0xF220EA, 0xF220F0, 0xF220F4, 0xF3E520, 0xF3E720, 0xF3F4EF, 0xF4E120, 0xF4E1E9, 0xF4E7ED, 0xF4E7F2, 0xF4E9EA, 0xF4EF20, 0xF4EFF5, 0xF4F9ED, 0xF9ED20, 0xFEED20,
         };
 
+        @Override
         public String getLanguage()
         {
             return "el";
         }
-        
+
+        @Override
         public CharsetMatch match(CharsetDetector det)
         {
             String name = det.fC1Bytes ?  "windows-1253" : "ISO-8859-7";
@@ -728,69 +745,73 @@ abstract class CharsetRecog_sbcs extends CharsetRecognizer {
             return confidence == 0 ? null : new CharsetMatch(det, this, confidence, name, "el");
         }
     }
-    
+
     abstract static class CharsetRecog_8859_8 extends CharsetRecog_sbcs
     {
         protected static byte[] byteMap = {
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xB5, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, 
-            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF, 
-            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7, 
-            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xB5, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,
+            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,
+            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7,
+            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
         };
 
+        @Override
         public String getName()
         {
             return "ISO-8859-8";
         }
     }
-    
+
     static class CharsetRecog_8859_8_I_he extends CharsetRecog_8859_8
     {
         private static int[] ngrams = {
-            0x20E0E5, 0x20E0E7, 0x20E0E9, 0x20E0FA, 0x20E1E9, 0x20E1EE, 0x20E4E0, 0x20E4E5, 0x20E4E9, 0x20E4EE, 0x20E4F2, 0x20E4F9, 0x20E4FA, 0x20ECE0, 0x20ECE4, 0x20EEE0, 
-            0x20F2EC, 0x20F9EC, 0xE0FA20, 0xE420E0, 0xE420E1, 0xE420E4, 0xE420EC, 0xE420EE, 0xE420F9, 0xE4E5E0, 0xE5E020, 0xE5ED20, 0xE5EF20, 0xE5F820, 0xE5FA20, 0xE920E4, 
-            0xE9E420, 0xE9E5FA, 0xE9E9ED, 0xE9ED20, 0xE9EF20, 0xE9F820, 0xE9FA20, 0xEC20E0, 0xEC20E4, 0xECE020, 0xECE420, 0xED20E0, 0xED20E1, 0xED20E4, 0xED20EC, 0xED20EE, 
-            0xED20F9, 0xEEE420, 0xEF20E4, 0xF0E420, 0xF0E920, 0xF0E9ED, 0xF2EC20, 0xF820E4, 0xF8E9ED, 0xF9EC20, 0xFA20E0, 0xFA20E1, 0xFA20E4, 0xFA20EC, 0xFA20EE, 0xFA20F9, 
+            0x20E0E5, 0x20E0E7, 0x20E0E9, 0x20E0FA, 0x20E1E9, 0x20E1EE, 0x20E4E0, 0x20E4E5, 0x20E4E9, 0x20E4EE, 0x20E4F2, 0x20E4F9, 0x20E4FA, 0x20ECE0, 0x20ECE4, 0x20EEE0,
+            0x20F2EC, 0x20F9EC, 0xE0FA20, 0xE420E0, 0xE420E1, 0xE420E4, 0xE420EC, 0xE420EE, 0xE420F9, 0xE4E5E0, 0xE5E020, 0xE5ED20, 0xE5EF20, 0xE5F820, 0xE5FA20, 0xE920E4,
+            0xE9E420, 0xE9E5FA, 0xE9E9ED, 0xE9ED20, 0xE9EF20, 0xE9F820, 0xE9FA20, 0xEC20E0, 0xEC20E4, 0xECE020, 0xECE420, 0xED20E0, 0xED20E1, 0xED20E4, 0xED20EC, 0xED20EE,
+            0xED20F9, 0xEEE420, 0xEF20E4, 0xF0E420, 0xF0E920, 0xF0E9ED, 0xF2EC20, 0xF820E4, 0xF8E9ED, 0xF9EC20, 0xFA20E0, 0xFA20E1, 0xFA20E4, 0xFA20EC, 0xFA20EE, 0xFA20F9,
         };
 
+        @Override
         public String getName()
         {
             return "ISO-8859-8-I";
         }
 
+        @Override
         public String getLanguage()
         {
             return "he";
         }
-        
+
+        @Override
         public CharsetMatch match(CharsetDetector det)
         {
             String name = det.fC1Bytes ? "windows-1255" : "ISO-8859-8-I";
@@ -798,21 +819,23 @@ abstract class CharsetRecog_sbcs extends CharsetRecognizer {
             return confidence == 0 ? null : new CharsetMatch(det, this, confidence, name, "he");
         }
     }
-    
+
     static class CharsetRecog_8859_8_he extends CharsetRecog_8859_8
     {
         private static int[] ngrams = {
-            0x20E0E5, 0x20E0EC, 0x20E4E9, 0x20E4EC, 0x20E4EE, 0x20E4F0, 0x20E9F0, 0x20ECF2, 0x20ECF9, 0x20EDE5, 0x20EDE9, 0x20EFE5, 0x20EFE9, 0x20F8E5, 0x20F8E9, 0x20FAE0, 
-            0x20FAE5, 0x20FAE9, 0xE020E4, 0xE020EC, 0xE020ED, 0xE020FA, 0xE0E420, 0xE0E5E4, 0xE0EC20, 0xE0EE20, 0xE120E4, 0xE120ED, 0xE120FA, 0xE420E4, 0xE420E9, 0xE420EC, 
-            0xE420ED, 0xE420EF, 0xE420F8, 0xE420FA, 0xE4EC20, 0xE5E020, 0xE5E420, 0xE7E020, 0xE9E020, 0xE9E120, 0xE9E420, 0xEC20E4, 0xEC20ED, 0xEC20FA, 0xECF220, 0xECF920, 
-            0xEDE9E9, 0xEDE9F0, 0xEDE9F8, 0xEE20E4, 0xEE20ED, 0xEE20FA, 0xEEE120, 0xEEE420, 0xF2E420, 0xF920E4, 0xF920ED, 0xF920FA, 0xF9E420, 0xFAE020, 0xFAE420, 0xFAE5E9, 
+            0x20E0E5, 0x20E0EC, 0x20E4E9, 0x20E4EC, 0x20E4EE, 0x20E4F0, 0x20E9F0, 0x20ECF2, 0x20ECF9, 0x20EDE5, 0x20EDE9, 0x20EFE5, 0x20EFE9, 0x20F8E5, 0x20F8E9, 0x20FAE0,
+            0x20FAE5, 0x20FAE9, 0xE020E4, 0xE020EC, 0xE020ED, 0xE020FA, 0xE0E420, 0xE0E5E4, 0xE0EC20, 0xE0EE20, 0xE120E4, 0xE120ED, 0xE120FA, 0xE420E4, 0xE420E9, 0xE420EC,
+            0xE420ED, 0xE420EF, 0xE420F8, 0xE420FA, 0xE4EC20, 0xE5E020, 0xE5E420, 0xE7E020, 0xE9E020, 0xE9E120, 0xE9E420, 0xEC20E4, 0xEC20ED, 0xEC20FA, 0xECF220, 0xECF920,
+            0xEDE9E9, 0xEDE9F0, 0xEDE9F8, 0xEE20E4, 0xEE20ED, 0xEE20FA, 0xEEE120, 0xEEE420, 0xF2E420, 0xF920E4, 0xF920ED, 0xF920FA, 0xF9E420, 0xFAE020, 0xFAE420, 0xFAE5E9,
         };
 
+        @Override
         public String getLanguage()
         {
             return "he";
         }
-        
+
+        @Override
         public CharsetMatch match(CharsetDetector det)
         {
             String name = det.fC1Bytes ? "windows-1255" : "ISO-8859-8";
@@ -821,64 +844,67 @@ abstract class CharsetRecog_sbcs extends CharsetRecognizer {
 
         }
     }
-    
+
     abstract static class CharsetRecog_8859_9 extends CharsetRecog_sbcs
     {
         protected static byte[] byteMap = {
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0xAA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xB5, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0xBA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, 
-            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF, 
-            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0x20, 
-            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0x69, (byte) 0xFE, (byte) 0xDF, 
-            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, 
-            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF, 
-            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0x20, 
-            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xFF, 
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0xAA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xB5, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0xBA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,
+            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,
+            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0x20,
+            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0x69, (byte) 0xFE, (byte) 0xDF,
+            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,
+            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,
+            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0x20,
+            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xFF,
         };
 
+        @Override
         public String getName()
         {
             return "ISO-8859-9";
         }
     }
-    
+
     static class CharsetRecog_8859_9_tr extends CharsetRecog_8859_9
     {
         private static int[] ngrams = {
-            0x206261, 0x206269, 0x206275, 0x206461, 0x206465, 0x206765, 0x206861, 0x20696C, 0x206B61, 0x206B6F, 0x206D61, 0x206F6C, 0x207361, 0x207461, 0x207665, 0x207961, 
-            0x612062, 0x616B20, 0x616C61, 0x616D61, 0x616E20, 0x616EFD, 0x617220, 0x617261, 0x6172FD, 0x6173FD, 0x617961, 0x626972, 0x646120, 0x646520, 0x646920, 0x652062, 
-            0x65206B, 0x656469, 0x656E20, 0x657220, 0x657269, 0x657369, 0x696C65, 0x696E20, 0x696E69, 0x697220, 0x6C616E, 0x6C6172, 0x6C6520, 0x6C6572, 0x6E2061, 0x6E2062, 
-            0x6E206B, 0x6E6461, 0x6E6465, 0x6E6520, 0x6E6920, 0x6E696E, 0x6EFD20, 0x72696E, 0x72FD6E, 0x766520, 0x796120, 0x796F72, 0xFD6E20, 0xFD6E64, 0xFD6EFD, 0xFDF0FD, 
+            0x206261, 0x206269, 0x206275, 0x206461, 0x206465, 0x206765, 0x206861, 0x20696C, 0x206B61, 0x206B6F, 0x206D61, 0x206F6C, 0x207361, 0x207461, 0x207665, 0x207961,
+            0x612062, 0x616B20, 0x616C61, 0x616D61, 0x616E20, 0x616EFD, 0x617220, 0x617261, 0x6172FD, 0x6173FD, 0x617961, 0x626972, 0x646120, 0x646520, 0x646920, 0x652062,
+            0x65206B, 0x656469, 0x656E20, 0x657220, 0x657269, 0x657369, 0x696C65, 0x696E20, 0x696E69, 0x697220, 0x6C616E, 0x6C6172, 0x6C6520, 0x6C6572, 0x6E2061, 0x6E2062,
+            0x6E206B, 0x6E6461, 0x6E6465, 0x6E6520, 0x6E6920, 0x6E696E, 0x6EFD20, 0x72696E, 0x72FD6E, 0x766520, 0x796120, 0x796F72, 0xFD6E20, 0xFD6E64, 0xFD6EFD, 0xFDF0FD,
         };
 
+        @Override
         public String getLanguage()
         {
             return "tr";
         }
-        
+
+        @Override
         public CharsetMatch match(CharsetDetector det)
         {
             String name = det.fC1Bytes ? "windows-1254" : "ISO-8859-9";
@@ -886,237 +912,250 @@ abstract class CharsetRecog_sbcs extends CharsetRecognizer {
             return confidence == 0 ? null : new CharsetMatch(det, this, confidence, name, "tr");
         }
     }
-    
+
     static class CharsetRecog_windows_1251 extends CharsetRecog_sbcs
     {
         private static int[] ngrams = {
-            0x20E220, 0x20E2EE, 0x20E4EE, 0x20E7E0, 0x20E820, 0x20EAE0, 0x20EAEE, 0x20EDE0, 0x20EDE5, 0x20EEE1, 0x20EFEE, 0x20EFF0, 0x20F0E0, 0x20F1EE, 0x20F1F2, 0x20F2EE, 
-            0x20F7F2, 0x20FDF2, 0xE0EDE8, 0xE0F2FC, 0xE3EE20, 0xE5EBFC, 0xE5EDE8, 0xE5F1F2, 0xE5F220, 0xE820EF, 0xE8E520, 0xE8E820, 0xE8FF20, 0xEBE5ED, 0xEBE820, 0xEBFCED, 
-            0xEDE020, 0xEDE520, 0xEDE8E5, 0xEDE8FF, 0xEDEE20, 0xEDEEE2, 0xEE20E2, 0xEE20EF, 0xEE20F1, 0xEEE220, 0xEEE2E0, 0xEEE3EE, 0xEEE920, 0xEEEBFC, 0xEEEC20, 0xEEF1F2, 
-            0xEFEEEB, 0xEFF0E5, 0xEFF0E8, 0xEFF0EE, 0xF0E0E2, 0xF0E5E4, 0xF1F2E0, 0xF1F2E2, 0xF1F2E8, 0xF1FF20, 0xF2E5EB, 0xF2EE20, 0xF2EEF0, 0xF2FC20, 0xF7F2EE, 0xFBF520, 
+            0x20E220, 0x20E2EE, 0x20E4EE, 0x20E7E0, 0x20E820, 0x20EAE0, 0x20EAEE, 0x20EDE0, 0x20EDE5, 0x20EEE1, 0x20EFEE, 0x20EFF0, 0x20F0E0, 0x20F1EE, 0x20F1F2, 0x20F2EE,
+            0x20F7F2, 0x20FDF2, 0xE0EDE8, 0xE0F2FC, 0xE3EE20, 0xE5EBFC, 0xE5EDE8, 0xE5F1F2, 0xE5F220, 0xE820EF, 0xE8E520, 0xE8E820, 0xE8FF20, 0xEBE5ED, 0xEBE820, 0xEBFCED,
+            0xEDE020, 0xEDE520, 0xEDE8E5, 0xEDE8FF, 0xEDEE20, 0xEDEEE2, 0xEE20E2, 0xEE20EF, 0xEE20F1, 0xEEE220, 0xEEE2E0, 0xEEE3EE, 0xEEE920, 0xEEEBFC, 0xEEEC20, 0xEEF1F2,
+            0xEFEEEB, 0xEFF0E5, 0xEFF0E8, 0xEFF0EE, 0xF0E0E2, 0xF0E5E4, 0xF1F2E0, 0xF1F2E2, 0xF1F2E8, 0xF1FF20, 0xF2E5EB, 0xF2EE20, 0xF2EEF0, 0xF2FC20, 0xF7F2EE, 0xFBF520,
         };
 
         private static byte[] byteMap = {
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x90, (byte) 0x83, (byte) 0x20, (byte) 0x83, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x9A, (byte) 0x20, (byte) 0x9C, (byte) 0x9D, (byte) 0x9E, (byte) 0x9F, 
-            (byte) 0x90, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x9A, (byte) 0x20, (byte) 0x9C, (byte) 0x9D, (byte) 0x9E, (byte) 0x9F, 
-            (byte) 0x20, (byte) 0xA2, (byte) 0xA2, (byte) 0xBC, (byte) 0x20, (byte) 0xB4, (byte) 0x20, (byte) 0x20, 
-            (byte) 0xB8, (byte) 0x20, (byte) 0xBA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xBF, 
-            (byte) 0x20, (byte) 0x20, (byte) 0xB3, (byte) 0xB3, (byte) 0xB4, (byte) 0xB5, (byte) 0x20, (byte) 0x20, 
-            (byte) 0xB8, (byte) 0x20, (byte) 0xBA, (byte) 0x20, (byte) 0xBC, (byte) 0xBE, (byte) 0xBE, (byte) 0xBF, 
-            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, 
-            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF, 
-            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7, 
-            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xFF, 
-            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, 
-            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF, 
-            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7, 
-            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xFF, 
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x90, (byte) 0x83, (byte) 0x20, (byte) 0x83, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x9A, (byte) 0x20, (byte) 0x9C, (byte) 0x9D, (byte) 0x9E, (byte) 0x9F,
+            (byte) 0x90, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x9A, (byte) 0x20, (byte) 0x9C, (byte) 0x9D, (byte) 0x9E, (byte) 0x9F,
+            (byte) 0x20, (byte) 0xA2, (byte) 0xA2, (byte) 0xBC, (byte) 0x20, (byte) 0xB4, (byte) 0x20, (byte) 0x20,
+            (byte) 0xB8, (byte) 0x20, (byte) 0xBA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xBF,
+            (byte) 0x20, (byte) 0x20, (byte) 0xB3, (byte) 0xB3, (byte) 0xB4, (byte) 0xB5, (byte) 0x20, (byte) 0x20,
+            (byte) 0xB8, (byte) 0x20, (byte) 0xBA, (byte) 0x20, (byte) 0xBC, (byte) 0xBE, (byte) 0xBE, (byte) 0xBF,
+            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,
+            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,
+            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7,
+            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xFF,
+            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,
+            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,
+            (byte) 0xF0, (byte) 0xF1, (byte) 0xF2, (byte) 0xF3, (byte) 0xF4, (byte) 0xF5, (byte) 0xF6, (byte) 0xF7,
+            (byte) 0xF8, (byte) 0xF9, (byte) 0xFA, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0xFF,
         };
 
+        @Override
         public String getName()
         {
             return  "windows-1251";
         }
-        
+
+        @Override
         public String getLanguage()
         {
             return "ru";
         }
-        
+
+        @Override
         public CharsetMatch match(CharsetDetector det)
         {
             int confidence = match(det, ngrams, byteMap);
             return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
         }
     }
-    
+
     static class CharsetRecog_windows_1256 extends CharsetRecog_sbcs
     {
         private static int[] ngrams = {
-            0x20C7E1, 0x20C7E4, 0x20C8C7, 0x20DAE1, 0x20DDED, 0x20E1E1, 0x20E3E4, 0x20E6C7, 0xC720C7, 0xC7C120, 0xC7CA20, 0xC7D120, 0xC7E120, 0xC7E1C3, 0xC7E1C7, 0xC7E1C8, 
-            0xC7E1CA, 0xC7E1CC, 0xC7E1CD, 0xC7E1CF, 0xC7E1D3, 0xC7E1DA, 0xC7E1DE, 0xC7E1E3, 0xC7E1E6, 0xC7E1ED, 0xC7E320, 0xC7E420, 0xC7E4CA, 0xC820C7, 0xC920C7, 0xC920DD, 
-            0xC920E1, 0xC920E3, 0xC920E6, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920, 0xD320C7, 0xDA20C7, 0xDAE1EC, 0xDDED20, 0xE120C7, 0xE1C920, 0xE1EC20, 0xE1ED20, 
-            0xE320C7, 0xE3C720, 0xE3C920, 0xE3E420, 0xE420C7, 0xE520C7, 0xE5C720, 0xE6C7E1, 0xE6E420, 0xEC20C7, 0xED20C7, 0xED20E3, 0xED20E6, 0xEDC920, 0xEDD120, 0xEDE420, 
+            0x20C7E1, 0x20C7E4, 0x20C8C7, 0x20DAE1, 0x20DDED, 0x20E1E1, 0x20E3E4, 0x20E6C7, 0xC720C7, 0xC7C120, 0xC7CA20, 0xC7D120, 0xC7E120, 0xC7E1C3, 0xC7E1C7, 0xC7E1C8,
+            0xC7E1CA, 0xC7E1CC, 0xC7E1CD, 0xC7E1CF, 0xC7E1D3, 0xC7E1DA, 0xC7E1DE, 0xC7E1E3, 0xC7E1E6, 0xC7E1ED, 0xC7E320, 0xC7E420, 0xC7E4CA, 0xC820C7, 0xC920C7, 0xC920DD,
+            0xC920E1, 0xC920E3, 0xC920E6, 0xCA20C7, 0xCF20C7, 0xCFC920, 0xD120C7, 0xD1C920, 0xD320C7, 0xDA20C7, 0xDAE1EC, 0xDDED20, 0xE120C7, 0xE1C920, 0xE1EC20, 0xE1ED20,
+            0xE320C7, 0xE3C720, 0xE3C920, 0xE3E420, 0xE420C7, 0xE520C7, 0xE5C720, 0xE6C7E1, 0xE6E420, 0xEC20C7, 0xED20C7, 0xED20E3, 0xED20E6, 0xEDC920, 0xEDD120, 0xEDE420,
         };
 
         private static byte[] byteMap = {
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x81, (byte) 0x20, (byte) 0x83, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x88, (byte) 0x20, (byte) 0x8A, (byte) 0x20, (byte) 0x9C, (byte) 0x8D, (byte) 0x8E, (byte) 0x8F, 
-            (byte) 0x90, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x98, (byte) 0x20, (byte) 0x9A, (byte) 0x20, (byte) 0x9C, (byte) 0x20, (byte) 0x20, (byte) 0x9F, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0xAA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xB5, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0xC0, (byte) 0xC1, (byte) 0xC2, (byte) 0xC3, (byte) 0xC4, (byte) 0xC5, (byte) 0xC6, (byte) 0xC7, 
-            (byte) 0xC8, (byte) 0xC9, (byte) 0xCA, (byte) 0xCB, (byte) 0xCC, (byte) 0xCD, (byte) 0xCE, (byte) 0xCF, 
-            (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0x20, 
-            (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF, 
-            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7, 
-            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xF4, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0xF9, (byte) 0x20, (byte) 0xFB, (byte) 0xFC, (byte) 0x20, (byte) 0x20, (byte) 0xFF, 
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x81, (byte) 0x20, (byte) 0x83, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x88, (byte) 0x20, (byte) 0x8A, (byte) 0x20, (byte) 0x9C, (byte) 0x8D, (byte) 0x8E, (byte) 0x8F,
+            (byte) 0x90, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x98, (byte) 0x20, (byte) 0x9A, (byte) 0x20, (byte) 0x9C, (byte) 0x20, (byte) 0x20, (byte) 0x9F,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0xAA, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xB5, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0xC0, (byte) 0xC1, (byte) 0xC2, (byte) 0xC3, (byte) 0xC4, (byte) 0xC5, (byte) 0xC6, (byte) 0xC7,
+            (byte) 0xC8, (byte) 0xC9, (byte) 0xCA, (byte) 0xCB, (byte) 0xCC, (byte) 0xCD, (byte) 0xCE, (byte) 0xCF,
+            (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0x20,
+            (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF,
+            (byte) 0xE0, (byte) 0xE1, (byte) 0xE2, (byte) 0xE3, (byte) 0xE4, (byte) 0xE5, (byte) 0xE6, (byte) 0xE7,
+            (byte) 0xE8, (byte) 0xE9, (byte) 0xEA, (byte) 0xEB, (byte) 0xEC, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xF4, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0xF9, (byte) 0x20, (byte) 0xFB, (byte) 0xFC, (byte) 0x20, (byte) 0x20, (byte) 0xFF,
         };
 
+        @Override
         public String getName()
         {
             return  "windows-1256";
         }
-        
+
+        @Override
         public String getLanguage()
         {
             return "ar";
         }
-        
+
+        @Override
         public CharsetMatch match(CharsetDetector det)
         {
             int confidence = match(det, ngrams, byteMap);
             return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
         }
     }
-        
+
     static class CharsetRecog_KOI8_R extends CharsetRecog_sbcs
     {
         private static int[] ngrams = {
-            0x20C4CF, 0x20C920, 0x20CBC1, 0x20CBCF, 0x20CEC1, 0x20CEC5, 0x20CFC2, 0x20D0CF, 0x20D0D2, 0x20D2C1, 0x20D3CF, 0x20D3D4, 0x20D4CF, 0x20D720, 0x20D7CF, 0x20DAC1, 
-            0x20DCD4, 0x20DED4, 0xC1CEC9, 0xC1D4D8, 0xC5CCD8, 0xC5CEC9, 0xC5D3D4, 0xC5D420, 0xC7CF20, 0xC920D0, 0xC9C520, 0xC9C920, 0xC9D120, 0xCCC5CE, 0xCCC920, 0xCCD8CE, 
-            0xCEC120, 0xCEC520, 0xCEC9C5, 0xCEC9D1, 0xCECF20, 0xCECFD7, 0xCF20D0, 0xCF20D3, 0xCF20D7, 0xCFC7CF, 0xCFCA20, 0xCFCCD8, 0xCFCD20, 0xCFD3D4, 0xCFD720, 0xCFD7C1, 
-            0xD0CFCC, 0xD0D2C5, 0xD0D2C9, 0xD0D2CF, 0xD2C1D7, 0xD2C5C4, 0xD3D120, 0xD3D4C1, 0xD3D4C9, 0xD3D4D7, 0xD4C5CC, 0xD4CF20, 0xD4CFD2, 0xD4D820, 0xD9C820, 0xDED4CF, 
+            0x20C4CF, 0x20C920, 0x20CBC1, 0x20CBCF, 0x20CEC1, 0x20CEC5, 0x20CFC2, 0x20D0CF, 0x20D0D2, 0x20D2C1, 0x20D3CF, 0x20D3D4, 0x20D4CF, 0x20D720, 0x20D7CF, 0x20DAC1,
+            0x20DCD4, 0x20DED4, 0xC1CEC9, 0xC1D4D8, 0xC5CCD8, 0xC5CEC9, 0xC5D3D4, 0xC5D420, 0xC7CF20, 0xC920D0, 0xC9C520, 0xC9C920, 0xC9D120, 0xCCC5CE, 0xCCC920, 0xCCD8CE,
+            0xCEC120, 0xCEC520, 0xCEC9C5, 0xCEC9D1, 0xCECF20, 0xCECFD7, 0xCF20D0, 0xCF20D3, 0xCF20D7, 0xCFC7CF, 0xCFCA20, 0xCFCCD8, 0xCFCD20, 0xCFD3D4, 0xCFD720, 0xCFD7C1,
+            0xD0CFCC, 0xD0D2C5, 0xD0D2C9, 0xD0D2CF, 0xD2C1D7, 0xD2C5C4, 0xD3D120, 0xD3D4C1, 0xD3D4C9, 0xD3D4D7, 0xD4C5CC, 0xD4CF20, 0xD4CFD2, 0xD4D820, 0xD9C820, 0xDED4CF,
         };
 
         private static byte[] byteMap = {
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, 
-            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F, 
-            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, 
-            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xA3, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xA3, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, 
-            (byte) 0xC0, (byte) 0xC1, (byte) 0xC2, (byte) 0xC3, (byte) 0xC4, (byte) 0xC5, (byte) 0xC6, (byte) 0xC7, 
-            (byte) 0xC8, (byte) 0xC9, (byte) 0xCA, (byte) 0xCB, (byte) 0xCC, (byte) 0xCD, (byte) 0xCE, (byte) 0xCF, 
-            (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7, 
-            (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF, 
-            (byte) 0xC0, (byte) 0xC1, (byte) 0xC2, (byte) 0xC3, (byte) 0xC4, (byte) 0xC5, (byte) 0xC6, (byte) 0xC7, 
-            (byte) 0xC8, (byte) 0xC9, (byte) 0xCA, (byte) 0xCB, (byte) 0xCC, (byte) 0xCD, (byte) 0xCE, (byte) 0xCF, 
-            (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7, 
-            (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF, 
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x00,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x61, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67,
+            (byte) 0x68, (byte) 0x69, (byte) 0x6A, (byte) 0x6B, (byte) 0x6C, (byte) 0x6D, (byte) 0x6E, (byte) 0x6F,
+            (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77,
+            (byte) 0x78, (byte) 0x79, (byte) 0x7A, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xA3, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0xA3, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20, (byte) 0x20,
+            (byte) 0xC0, (byte) 0xC1, (byte) 0xC2, (byte) 0xC3, (byte) 0xC4, (byte) 0xC5, (byte) 0xC6, (byte) 0xC7,
+            (byte) 0xC8, (byte) 0xC9, (byte) 0xCA, (byte) 0xCB, (byte) 0xCC, (byte) 0xCD, (byte) 0xCE, (byte) 0xCF,
+            (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7,
+            (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF,
+            (byte) 0xC0, (byte) 0xC1, (byte) 0xC2, (byte) 0xC3, (byte) 0xC4, (byte) 0xC5, (byte) 0xC6, (byte) 0xC7,
+            (byte) 0xC8, (byte) 0xC9, (byte) 0xCA, (byte) 0xCB, (byte) 0xCC, (byte) 0xCD, (byte) 0xCE, (byte) 0xCF,
+            (byte) 0xD0, (byte) 0xD1, (byte) 0xD2, (byte) 0xD3, (byte) 0xD4, (byte) 0xD5, (byte) 0xD6, (byte) 0xD7,
+            (byte) 0xD8, (byte) 0xD9, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF,
         };
-        
+
+        @Override
         public String getName()
         {
             return  "KOI8-R";
         }
-        
+
+        @Override
         public String getLanguage()
         {
             return "ru";
         }
-        
+
+        @Override
         public CharsetMatch match(CharsetDetector det)
         {
             int confidence = match(det, ngrams, byteMap);
             return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
         }
     }
-    
+
     abstract static class CharsetRecog_IBM424_he extends CharsetRecog_sbcs
     {
         protected static byte[] byteMap = {
 /*                 -0           -1           -2           -3           -4           -5           -6           -7           -8           -9           -A           -B           -C           -D           -E           -F   */
-/* 0- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 1- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 2- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 3- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 4- */    (byte) 0x40, (byte) 0x41, (byte) 0x42, (byte) 0x43, (byte) 0x44, (byte) 0x45, (byte) 0x46, (byte) 0x47, (byte) 0x48, (byte) 0x49, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 5- */    (byte) 0x40, (byte) 0x51, (byte) 0x52, (byte) 0x53, (byte) 0x54, (byte) 0x55, (byte) 0x56, (byte) 0x57, (byte) 0x58, (byte) 0x59, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 6- */    (byte) 0x40, (byte) 0x40, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, (byte) 0x68, (byte) 0x69, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 7- */    (byte) 0x40, (byte) 0x71, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x00, (byte) 0x40, (byte) 0x40, 
-/* 8- */    (byte) 0x40, (byte) 0x81, (byte) 0x82, (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 9- */    (byte) 0x40, (byte) 0x91, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97, (byte) 0x98, (byte) 0x99, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* A- */    (byte) 0xA0, (byte) 0x40, (byte) 0xA2, (byte) 0xA3, (byte) 0xA4, (byte) 0xA5, (byte) 0xA6, (byte) 0xA7, (byte) 0xA8, (byte) 0xA9, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* B- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* C- */    (byte) 0x40, (byte) 0x81, (byte) 0x82, (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* D- */    (byte) 0x40, (byte) 0x91, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97, (byte) 0x98, (byte) 0x99, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* E- */    (byte) 0x40, (byte) 0x40, (byte) 0xA2, (byte) 0xA3, (byte) 0xA4, (byte) 0xA5, (byte) 0xA6, (byte) 0xA7, (byte) 0xA8, (byte) 0xA9, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* F- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
+/* 0- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 1- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 2- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 3- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 4- */    (byte) 0x40, (byte) 0x41, (byte) 0x42, (byte) 0x43, (byte) 0x44, (byte) 0x45, (byte) 0x46, (byte) 0x47, (byte) 0x48, (byte) 0x49, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 5- */    (byte) 0x40, (byte) 0x51, (byte) 0x52, (byte) 0x53, (byte) 0x54, (byte) 0x55, (byte) 0x56, (byte) 0x57, (byte) 0x58, (byte) 0x59, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 6- */    (byte) 0x40, (byte) 0x40, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, (byte) 0x68, (byte) 0x69, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 7- */    (byte) 0x40, (byte) 0x71, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x00, (byte) 0x40, (byte) 0x40,
+/* 8- */    (byte) 0x40, (byte) 0x81, (byte) 0x82, (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 9- */    (byte) 0x40, (byte) 0x91, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97, (byte) 0x98, (byte) 0x99, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* A- */    (byte) 0xA0, (byte) 0x40, (byte) 0xA2, (byte) 0xA3, (byte) 0xA4, (byte) 0xA5, (byte) 0xA6, (byte) 0xA7, (byte) 0xA8, (byte) 0xA9, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* B- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* C- */    (byte) 0x40, (byte) 0x81, (byte) 0x82, (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* D- */    (byte) 0x40, (byte) 0x91, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97, (byte) 0x98, (byte) 0x99, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* E- */    (byte) 0x40, (byte) 0x40, (byte) 0xA2, (byte) 0xA3, (byte) 0xA4, (byte) 0xA5, (byte) 0xA6, (byte) 0xA7, (byte) 0xA8, (byte) 0xA9, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* F- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
         };
 
+        @Override
         public String getLanguage()
         {
             return "he";
         }
     }
-    static class CharsetRecog_IBM424_he_rtl extends CharsetRecog_IBM424_he 
+    static class CharsetRecog_IBM424_he_rtl extends CharsetRecog_IBM424_he
     {
+        @Override
         public String getName()
         {
             return "IBM424_rtl";
         }
         private static int[] ngrams = {
-            0x404146, 0x404148, 0x404151, 0x404171, 0x404251, 0x404256, 0x404541, 0x404546, 0x404551, 0x404556, 0x404562, 0x404569, 0x404571, 0x405441, 0x405445, 0x405641, 
-            0x406254, 0x406954, 0x417140, 0x454041, 0x454042, 0x454045, 0x454054, 0x454056, 0x454069, 0x454641, 0x464140, 0x465540, 0x465740, 0x466840, 0x467140, 0x514045, 
-            0x514540, 0x514671, 0x515155, 0x515540, 0x515740, 0x516840, 0x517140, 0x544041, 0x544045, 0x544140, 0x544540, 0x554041, 0x554042, 0x554045, 0x554054, 0x554056, 
-            0x554069, 0x564540, 0x574045, 0x584540, 0x585140, 0x585155, 0x625440, 0x684045, 0x685155, 0x695440, 0x714041, 0x714042, 0x714045, 0x714054, 0x714056, 0x714069, 
+            0x404146, 0x404148, 0x404151, 0x404171, 0x404251, 0x404256, 0x404541, 0x404546, 0x404551, 0x404556, 0x404562, 0x404569, 0x404571, 0x405441, 0x405445, 0x405641,
+            0x406254, 0x406954, 0x417140, 0x454041, 0x454042, 0x454045, 0x454054, 0x454056, 0x454069, 0x454641, 0x464140, 0x465540, 0x465740, 0x466840, 0x467140, 0x514045,
+            0x514540, 0x514671, 0x515155, 0x515540, 0x515740, 0x516840, 0x517140, 0x544041, 0x544045, 0x544140, 0x544540, 0x554041, 0x554042, 0x554045, 0x554054, 0x554056,
+            0x554069, 0x564540, 0x574045, 0x584540, 0x585140, 0x585155, 0x625440, 0x684045, 0x685155, 0x695440, 0x714041, 0x714042, 0x714045, 0x714054, 0x714056, 0x714069,
         };
+        @Override
         public CharsetMatch match(CharsetDetector det)
         {
             int confidence = match(det, ngrams, byteMap, (byte)0x40);
             return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
         }
     }
-    static class CharsetRecog_IBM424_he_ltr extends CharsetRecog_IBM424_he 
+    static class CharsetRecog_IBM424_he_ltr extends CharsetRecog_IBM424_he
     {
+        @Override
         public String getName()
         {
             return "IBM424_ltr";
@@ -1128,44 +1167,46 @@ abstract class CharsetRecog_sbcs extends CharsetRecognizer {
             0x555151, 0x555158, 0x555168, 0x564045, 0x564055, 0x564071, 0x564240, 0x564540, 0x624540, 0x694045, 0x694055, 0x694071, 0x694540, 0x714140, 0x714540, 0x714651
 
         };
+        @Override
         public CharsetMatch match(CharsetDetector det)
         {
             int confidence = match(det, ngrams, byteMap, (byte)0x40);
             return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
         }
     }
-    
+
     abstract static class CharsetRecog_IBM420_ar extends CharsetRecog_sbcs
     {
 
         protected static byte[] byteMap = {
 /*                 -0           -1           -2           -3           -4           -5           -6           -7           -8           -9           -A           -B           -C           -D           -E           -F   */
-/* 0- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 1- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 2- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 3- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 4- */    (byte) 0x40, (byte) 0x40, (byte) 0x42, (byte) 0x43, (byte) 0x44, (byte) 0x45, (byte) 0x46, (byte) 0x47, (byte) 0x48, (byte) 0x49, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 5- */    (byte) 0x40, (byte) 0x51, (byte) 0x52, (byte) 0x40, (byte) 0x40, (byte) 0x55, (byte) 0x56, (byte) 0x57, (byte) 0x58, (byte) 0x59, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 6- */    (byte) 0x40, (byte) 0x40, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, (byte) 0x68, (byte) 0x69, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 7- */    (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, (byte) 0x78, (byte) 0x79, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, 
-/* 8- */    (byte) 0x80, (byte) 0x81, (byte) 0x82, (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x8A, (byte) 0x8B, (byte) 0x8C, (byte) 0x8D, (byte) 0x8E, (byte) 0x8F, 
-/* 9- */    (byte) 0x90, (byte) 0x91, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97, (byte) 0x98, (byte) 0x99, (byte) 0x9A, (byte) 0x9B, (byte) 0x9C, (byte) 0x9D, (byte) 0x9E, (byte) 0x9F, 
-/* A- */    (byte) 0xA0, (byte) 0x40, (byte) 0xA2, (byte) 0xA3, (byte) 0xA4, (byte) 0xA5, (byte) 0xA6, (byte) 0xA7, (byte) 0xA8, (byte) 0xA9, (byte) 0xAA, (byte) 0xAB, (byte) 0xAC, (byte) 0xAD, (byte) 0xAE, (byte) 0xAF, 
-/* B- */    (byte) 0xB0, (byte) 0xB1, (byte) 0xB2, (byte) 0xB3, (byte) 0xB4, (byte) 0xB5, (byte) 0x40, (byte) 0x40, (byte) 0xB8, (byte) 0xB9, (byte) 0xBA, (byte) 0xBB, (byte) 0xBC, (byte) 0xBD, (byte) 0xBE, (byte) 0xBF, 
-/* C- */    (byte) 0x40, (byte) 0x81, (byte) 0x82, (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x40, (byte) 0xCB, (byte) 0x40, (byte) 0xCD, (byte) 0x40, (byte) 0xCF, 
-/* D- */    (byte) 0x40, (byte) 0x91, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97, (byte) 0x98, (byte) 0x99, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF, 
-/* E- */    (byte) 0x40, (byte) 0x40, (byte) 0xA2, (byte) 0xA3, (byte) 0xA4, (byte) 0xA5, (byte) 0xA6, (byte) 0xA7, (byte) 0xA8, (byte) 0xA9, (byte) 0xEA, (byte) 0xEB, (byte) 0x40, (byte) 0xED, (byte) 0xEE, (byte) 0xEF, 
-/* F- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0x40, 
+/* 0- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 1- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 2- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 3- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 4- */    (byte) 0x40, (byte) 0x40, (byte) 0x42, (byte) 0x43, (byte) 0x44, (byte) 0x45, (byte) 0x46, (byte) 0x47, (byte) 0x48, (byte) 0x49, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 5- */    (byte) 0x40, (byte) 0x51, (byte) 0x52, (byte) 0x40, (byte) 0x40, (byte) 0x55, (byte) 0x56, (byte) 0x57, (byte) 0x58, (byte) 0x59, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 6- */    (byte) 0x40, (byte) 0x40, (byte) 0x62, (byte) 0x63, (byte) 0x64, (byte) 0x65, (byte) 0x66, (byte) 0x67, (byte) 0x68, (byte) 0x69, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 7- */    (byte) 0x70, (byte) 0x71, (byte) 0x72, (byte) 0x73, (byte) 0x74, (byte) 0x75, (byte) 0x76, (byte) 0x77, (byte) 0x78, (byte) 0x79, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40,
+/* 8- */    (byte) 0x80, (byte) 0x81, (byte) 0x82, (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x8A, (byte) 0x8B, (byte) 0x8C, (byte) 0x8D, (byte) 0x8E, (byte) 0x8F,
+/* 9- */    (byte) 0x90, (byte) 0x91, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97, (byte) 0x98, (byte) 0x99, (byte) 0x9A, (byte) 0x9B, (byte) 0x9C, (byte) 0x9D, (byte) 0x9E, (byte) 0x9F,
+/* A- */    (byte) 0xA0, (byte) 0x40, (byte) 0xA2, (byte) 0xA3, (byte) 0xA4, (byte) 0xA5, (byte) 0xA6, (byte) 0xA7, (byte) 0xA8, (byte) 0xA9, (byte) 0xAA, (byte) 0xAB, (byte) 0xAC, (byte) 0xAD, (byte) 0xAE, (byte) 0xAF,
+/* B- */    (byte) 0xB0, (byte) 0xB1, (byte) 0xB2, (byte) 0xB3, (byte) 0xB4, (byte) 0xB5, (byte) 0x40, (byte) 0x40, (byte) 0xB8, (byte) 0xB9, (byte) 0xBA, (byte) 0xBB, (byte) 0xBC, (byte) 0xBD, (byte) 0xBE, (byte) 0xBF,
+/* C- */    (byte) 0x40, (byte) 0x81, (byte) 0x82, (byte) 0x83, (byte) 0x84, (byte) 0x85, (byte) 0x86, (byte) 0x87, (byte) 0x88, (byte) 0x89, (byte) 0x40, (byte) 0xCB, (byte) 0x40, (byte) 0xCD, (byte) 0x40, (byte) 0xCF,
+/* D- */    (byte) 0x40, (byte) 0x91, (byte) 0x92, (byte) 0x93, (byte) 0x94, (byte) 0x95, (byte) 0x96, (byte) 0x97, (byte) 0x98, (byte) 0x99, (byte) 0xDA, (byte) 0xDB, (byte) 0xDC, (byte) 0xDD, (byte) 0xDE, (byte) 0xDF,
+/* E- */    (byte) 0x40, (byte) 0x40, (byte) 0xA2, (byte) 0xA3, (byte) 0xA4, (byte) 0xA5, (byte) 0xA6, (byte) 0xA7, (byte) 0xA8, (byte) 0xA9, (byte) 0xEA, (byte) 0xEB, (byte) 0x40, (byte) 0xED, (byte) 0xEE, (byte) 0xEF,
+/* F- */    (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0x40, (byte) 0xFB, (byte) 0xFC, (byte) 0xFD, (byte) 0xFE, (byte) 0x40,
         };
-        
 
+
+        @Override
         public String getLanguage()
         {
             return "ar";
         }
-                
+
     }
-    static class CharsetRecog_IBM420_ar_rtl extends CharsetRecog_IBM420_ar 
+    static class CharsetRecog_IBM420_ar_rtl extends CharsetRecog_IBM420_ar
     {
         private static int[] ngrams = {
             0x4056B1, 0x4056BD, 0x405856, 0x409AB1, 0x40ABDC, 0x40B1B1, 0x40BBBD, 0x40CF56, 0x564056, 0x564640, 0x566340, 0x567540, 0x56B140, 0x56B149, 0x56B156, 0x56B158,
@@ -1174,35 +1215,39 @@ abstract class CharsetRecog_sbcs extends CharsetRecognizer {
             0xBB4056, 0xBB5640, 0xBB6240, 0xBBBD40, 0xBD4056, 0xBF4056, 0xBF5640, 0xCF56B1, 0xCFBD40, 0xDA4056, 0xDC4056, 0xDC40BB, 0xDC40CF, 0xDC6240, 0xDC7540, 0xDCBD40,
         };
 
+        @Override
         public String getName()
         {
             return "IBM420_rtl";
         }
+        @Override
         public CharsetMatch match(CharsetDetector det)
         {
             int confidence =  matchIBM420(det, ngrams, byteMap, (byte)0x40);
             return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
         }
-        
+
     }
-    static class CharsetRecog_IBM420_ar_ltr extends CharsetRecog_IBM420_ar 
+    static class CharsetRecog_IBM420_ar_ltr extends CharsetRecog_IBM420_ar
     {
         private static int[] ngrams = {
-            0x404656, 0x4056BB, 0x4056BF, 0x406273, 0x406275, 0x4062B1, 0x4062BB, 0x4062DC, 0x406356, 0x407556, 0x4075DC, 0x40B156, 0x40BB56, 0x40BD56, 0x40BDBB, 0x40BDCF, 
+            0x404656, 0x4056BB, 0x4056BF, 0x406273, 0x406275, 0x4062B1, 0x4062BB, 0x4062DC, 0x406356, 0x407556, 0x4075DC, 0x40B156, 0x40BB56, 0x40BD56, 0x40BDBB, 0x40BDCF,
             0x40BDDC, 0x40DAB1, 0x40DCAB, 0x40DCB1, 0x49B156, 0x564056, 0x564058, 0x564062, 0x564063, 0x564073, 0x564075, 0x564078, 0x56409A, 0x5640B1, 0x5640BB, 0x5640BD,
             0x5640BF, 0x5640DA, 0x5640DC, 0x565840, 0x56B156, 0x56CF40, 0x58B156, 0x63B156, 0x63BD56, 0x67B156, 0x69B156, 0x73B156, 0x78B156, 0x9AB156, 0xAB4062, 0xADB156,
             0xB14062, 0xB15640, 0xB156CF, 0xB19A40, 0xB1B140, 0xBB4062, 0xBB40DC, 0xBBB156, 0xBD5640, 0xBDBB40, 0xCF4062, 0xCF40DC, 0xCFB156, 0xDAB19A, 0xDCAB40, 0xDCB156
         };
 
+        @Override
         public String getName()
         {
             return "IBM420_ltr";
         }
+        @Override
         public CharsetMatch match(CharsetDetector det)
         {
             int confidence = matchIBM420(det, ngrams, byteMap, (byte)0x40);
             return confidence == 0 ? null : new CharsetMatch(det, this, confidence);
         }
-        
+
     }
 }
diff --git a/app/src/main/java/com/ibm/icu/text/CharsetRecognizer.java b/icu4j/src/main/java/com/ibm/icu/text/CharsetRecognizer.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/text/CharsetRecognizer.java
rename to icu4j/src/main/java/com/ibm/icu/text/CharsetRecognizer.java
index b3ae33a..3bacff1 100644
--- a/app/src/main/java/com/ibm/icu/text/CharsetRecognizer.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CharsetRecognizer.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
 *******************************************************************************
 * Copyright (C) 2005-2012, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/ChineseDateFormat.java b/icu4j/src/main/java/com/ibm/icu/text/ChineseDateFormat.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/text/ChineseDateFormat.java
rename to icu4j/src/main/java/com/ibm/icu/text/ChineseDateFormat.java
index d5e4da6..735fac6 100644
--- a/app/src/main/java/com/ibm/icu/text/ChineseDateFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/ChineseDateFormat.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*********************************************************************
  * Copyright (C) 2000-2014, International Business Machines Corporation and
  * others. All Rights Reserved.
@@ -46,7 +48,7 @@ import com.ibm.icu.util.ULocale;
 public class ChineseDateFormat extends SimpleDateFormat {
     // Generated by serialver from JDK 1.4.1_01
     static final long serialVersionUID = -4610300753104099899L;
-    
+
     // TODO Finish the constructors
 
     /**
@@ -86,7 +88,7 @@ public class ChineseDateFormat extends SimpleDateFormat {
      */
     @Deprecated
     public ChineseDateFormat(String pattern, String override, ULocale locale) {
-       super(pattern, new ChineseDateFormatSymbols(locale), 
+       super(pattern, new ChineseDateFormatSymbols(locale),
                new ChineseCalendar(TimeZone.getDefault(), locale), locale, true, override);
     }
 
@@ -111,13 +113,14 @@ public class ChineseDateFormat extends SimpleDateFormat {
 //      default:
 //          return super.subFormat(ch, count, beginOffset, pos, formatData, cal);
 //      }
-//  }    
+//  }
 
     /**
      * {@inheritDoc}
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Override
     @Deprecated
     protected void subFormat(StringBuffer buf,
                              char ch, int count, int beginOffset,
@@ -139,10 +142,11 @@ public class ChineseDateFormat extends SimpleDateFormat {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * @deprecated ICU 50
      */
     @Deprecated
+    @Override
     protected int subParse(String text, int start, char ch, int count, boolean obeyCount, boolean allowNegative,
             boolean[] ambiguousYear, Calendar cal) {
         // Logic to handle numeric 'G' eras for chinese calendar, and to skip special 2-digit year
@@ -156,9 +160,10 @@ public class ChineseDateFormat extends SimpleDateFormat {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * @deprecated ICU 50
      */
+    @Override
     @Deprecated
     protected DateFormat.Field patternCharToDateFormatField(char ch) {
         // no longer any field corresponding to pattern char 'l'
@@ -192,10 +197,10 @@ public class ChineseDateFormat extends SimpleDateFormat {
          * the <code>ChineseCalendar</code> field which this attribute represents.
          * Use -1 for <code>calendarField</code> if this field does not have a
          * corresponding <code>ChineseCalendar</code> field.
-         * 
+         *
          * @param name          Name of the attribute
          * @param calendarField <code>Calendar</code> field constant
-         * 
+         *
          * @deprecated ICU 50
          */
         @Deprecated
@@ -207,13 +212,13 @@ public class ChineseDateFormat extends SimpleDateFormat {
          * Returns the <code>Field</code> constant that corresponds to the <code>
          * ChineseCalendar</code> field <code>calendarField</code>.  If there is no
          * corresponding <code>Field</code> is available, null is returned.
-         * 
+         *
          * @param calendarField <code>ChineseCalendar</code> field constant
          * @return <code>Field</code> associated with the <code>calendarField</code>,
          * or null if no associated <code>Field</code> is available.
          * @throws IllegalArgumentException if <code>calendarField</code> is not
          * a valid <code>Calendar</code> field constant.
-         * 
+         *
          * @deprecated ICU 50
          */
         @Deprecated
@@ -228,9 +233,10 @@ public class ChineseDateFormat extends SimpleDateFormat {
 
         /**
          * {@inheritDoc}
-         * 
+         *
          * @deprecated ICU 50
          */
+        @Override
         @Deprecated
         ///CLOVER:OFF
         protected Object readResolve() throws InvalidObjectException {
diff --git a/app/src/main/java/com/ibm/icu/text/ChineseDateFormatSymbols.java b/icu4j/src/main/java/com/ibm/icu/text/ChineseDateFormatSymbols.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/text/ChineseDateFormatSymbols.java
rename to icu4j/src/main/java/com/ibm/icu/text/ChineseDateFormatSymbols.java
index 49a827f..a4eddfe 100644
--- a/app/src/main/java/com/ibm/icu/text/ChineseDateFormatSymbols.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/ChineseDateFormatSymbols.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /****************************************************************************
  * Copyright (C) 2000-2014, International Business Machines Corporation and
  * others. All Rights Reserved.
@@ -8,7 +10,7 @@ package com.ibm.icu.text;
 
 import java.util.Locale;
 
-import com.ibm.icu.impl.CalendarData;
+import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.util.Calendar;
 import com.ibm.icu.util.ChineseCalendar;
 import com.ibm.icu.util.ULocale;
@@ -22,13 +24,13 @@ import com.ibm.icu.util.ULocale.Category;
  * @see ChineseDateFormat
  * @see com.ibm.icu.util.ChineseCalendar
  * @author Alan Liu
- * @deprecated ICU 50 
+ * @deprecated ICU 50
  */
 @Deprecated
 public class ChineseDateFormatSymbols extends DateFormatSymbols {
     // Generated by serialver from JDK 1.4.1_01
     static final long serialVersionUID = 6827816119783952890L;
-    
+
     /*
      * Package-private array that ChineseDateFormat needs to be able to
      * read.
@@ -103,11 +105,13 @@ public class ChineseDateFormatSymbols extends DateFormatSymbols {
      * @deprecated ICU 50
      */
     @Deprecated
-    protected void initializeData(ULocale loc, CalendarData calData) {
-        super.initializeData(loc, calData);
+    @Override
+    protected void initializeData(ULocale loc, ICUResourceBundle b, String calendarType) {
+        super.initializeData(loc, b, calendarType);
         initializeIsLeapMonth();
     }
 
+    @Override
     void initializeData(DateFormatSymbols dfs) {
         super.initializeData(dfs);
         if (dfs instanceof ChineseDateFormatSymbols) {
diff --git a/app/src/main/java/com/ibm/icu/text/CjkBreakEngine.java b/icu4j/src/main/java/com/ibm/icu/text/CjkBreakEngine.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/text/CjkBreakEngine.java
rename to icu4j/src/main/java/com/ibm/icu/text/CjkBreakEngine.java
index e5e9d34..b2c4c61 100644
--- a/app/src/main/java/com/ibm/icu/text/CjkBreakEngine.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CjkBreakEngine.java
@@ -1,6 +1,8 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2012-2014, International Business Machines Corporation and         *
+ * Copyright (C) 2012-2016, International Business Machines Corporation and         *
  * others. All Rights Reserved.                                                *
  *******************************************************************************
  */
@@ -25,7 +27,7 @@ class CjkBreakEngine extends DictionaryBreakEngine {
         fHanWordSet.applyPattern("[:Han:]");
         fKatakanaWordSet.applyPattern("[[:Katakana:]\\uff9e\\uff9f]");
         fHiraganaWordSet.applyPattern("[:Hiragana:]");
-        
+
         // freeze them all
         fHangulWordSet.freeze();
         fHanWordSet.freeze();
@@ -34,7 +36,7 @@ class CjkBreakEngine extends DictionaryBreakEngine {
     }
 
     private DictionaryMatcher fDictionary = null;
-    
+
     public CjkBreakEngine(boolean korean) throws IOException {
         super(BreakIterator.KIND_WORD);
         fDictionary = DictionaryData.loadDictionaryFor("Hira");
@@ -42,7 +44,6 @@ class CjkBreakEngine extends DictionaryBreakEngine {
             setCharacters(fHangulWordSet);
         } else { //Chinese and Japanese
             UnicodeSet cjSet = new UnicodeSet();
-            cjSet = new UnicodeSet();
             cjSet.addAll(fHanWordSet);
             cjSet.addAll(fKatakanaWordSet);
             cjSet.addAll(fHiraganaWordSet);
@@ -52,6 +53,7 @@ class CjkBreakEngine extends DictionaryBreakEngine {
         }
     }
 
+    @Override
     public boolean equals(Object obj) {
         if (obj instanceof CjkBreakEngine) {
             CjkBreakEngine other = (CjkBreakEngine)obj;
@@ -60,10 +62,11 @@ class CjkBreakEngine extends DictionaryBreakEngine {
         return false;
     }
 
+    @Override
     public int hashCode() {
         return getClass().hashCode();
     }
-    
+
     private static final int kMaxKatakanaLength = 8;
     private static final int kMaxKatakanaGroupLength = 20;
     private static final int maxSnlp = 255;
@@ -72,12 +75,13 @@ class CjkBreakEngine extends DictionaryBreakEngine {
         int katakanaCost[] =  new int[] { 8192, 984, 408, 240, 204, 252, 300, 372, 480 };
         return (wordlength > kMaxKatakanaLength) ? 8192 : katakanaCost[wordlength];
     }
-    
+
     private static boolean isKatakana(int value) {
         return (value >= 0x30A1 && value <= 0x30FE && value != 0x30FB) ||
                 (value >= 0xFF66 && value <= 0xFF9F);
     }
-    
+
+    @Override
     public int divideUpDictionaryRange(CharacterIterator inText, int startPos, int endPos,
             DequeI foundBreaks) {
         if (startPos >= endPos) {
@@ -123,7 +127,7 @@ class CjkBreakEngine extends DictionaryBreakEngine {
                 charPositions[numChars] = index;
             }
         }
-        
+
         // From here on out, do the algorithm. Note that our indices
         // refer to indices within the normalized string.
         int[] bestSnlp = new int[numChars + 1];
@@ -136,7 +140,7 @@ class CjkBreakEngine extends DictionaryBreakEngine {
         for (int i = 0; i <= numChars; i++) {
             prev[i] = -1;
         }
-        
+
         final int maxWordSize = 20;
         int values[] = new int[numChars];
         int lengths[] = new int[numChars];
@@ -147,17 +151,18 @@ class CjkBreakEngine extends DictionaryBreakEngine {
             if (bestSnlp[i] == kint32max) {
                 continue;
             }
-            
+
             int maxSearchLength = (i + maxWordSize < numChars) ? maxWordSize : (numChars - i);
             int[] count_ = new int[1];
             fDictionary.matches(text, maxSearchLength, lengths, count_, maxSearchLength, values);
             int count = count_[0];
-            
-            // if there are no single character matches found in the dictionary 
+
+            // if there are no single character matches found in the dictionary
             // starting with this character, treat character as a 1-character word
             // with the highest value possible (i.e. the least likely to occur).
-            // Exclude Korean characters from this treatment, as they should be 
+            // Exclude Korean characters from this treatment, as they should be
             // left together by default.
+            text.setIndex(i);  // fDictionary.matches() advances the text position; undo that.
             if ((count == 0 || lengths[0] != 1) && current32(text) != DONE32 && !fHangulWordSet.contains(current32(text))) {
                 values[count] = maxSnlp;
                 lengths[count] = 1;
@@ -171,13 +176,12 @@ class CjkBreakEngine extends DictionaryBreakEngine {
                     prev[lengths[j] + i] = i;
                 }
             }
-            
+
             // In Japanese, single-character Katakana words are pretty rare.
             // So we apply the following heuristic to Katakana: any continuous
             // run of Katakana characters is considered a candidate word with
-            // a default cost specified in the katakanaCost table according 
+            // a default cost specified in the katakanaCost table according
             // to its length.
-            text.setIndex(i);
             boolean is_katakana = isKatakana(current32(text));
             if (!is_prev_katakana && is_katakana) {
                 int j = i + 1;
@@ -186,7 +190,7 @@ class CjkBreakEngine extends DictionaryBreakEngine {
                     next32(text);
                     ++j;
                 }
-                
+
                 if ((j - i) < kMaxKatakanaGroupLength) {
                     int newSnlp = bestSnlp[i] + getKatakanaCost(j - i);
                     if (newSnlp < bestSnlp[j]) {
@@ -228,7 +232,7 @@ class CjkBreakEngine extends DictionaryBreakEngine {
             foundBreaks.pop();
             correctedNumBreaks--;
         }
-        if (!foundBreaks.isEmpty()) 
+        if (!foundBreaks.isEmpty())
             inText.setIndex(foundBreaks.peek());
         return correctedNumBreaks;
     }
diff --git a/app/src/main/java/com/ibm/icu/text/CollationElementIterator.java b/icu4j/src/main/java/com/ibm/icu/text/CollationElementIterator.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/text/CollationElementIterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/CollationElementIterator.java
index 3d7dabb..1940fe3 100644
--- a/app/src/main/java/com/ibm/icu/text/CollationElementIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CollationElementIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
 *******************************************************************************
 * Copyright (C) 1996-2016, International Business Machines Corporation and
@@ -582,37 +584,16 @@ public final class CollationElementIterator
         dir_ = 0;
     }
 
-    // Java porting note: This method is @stable ICU 2.0 in ICU4C, but not available
-    // in ICU4J. For now, keep it package local.
-    /**
-    * Gets the comparison order in the desired strength. Ignore the other
-    * differences.
-    * @param order The order value
-    */
-    int strengthOrder(int order) {
-        int s = rbc_.settings.readOnly().getStrength();
-        // Mask off the unwanted differences.
-        if (s == Collator.PRIMARY) {
-            order &= 0xffff0000;
-        }
-        else if (s == Collator.SECONDARY) {
-            order &= 0xffffff00;
-        }
-
-        return order;
-    }
-
-
     private static final class MaxExpSink implements ContractionsAndExpansions.CESink {
         MaxExpSink(Map<Integer, Integer> h) {
             maxExpansions = h;
         }
 
-        // Java 6: @Override
+        @Override
         public void handleCE(long ce) {
         }
 
-        // Java 6: @Override
+        @Override
         public void handleExpansion(long ces[], int start, int length) {
             if (length <= 1) {
                 // We do not need to add single CEs into the map.
@@ -692,6 +673,7 @@ public final class CollationElementIterator
      *             CollationElementIterator
      * @stable ICU 2.8
      */
+    @Override
     public boolean equals(Object that) {
         if (that == this) {
             return true;
@@ -713,6 +695,7 @@ public final class CollationElementIterator
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Override
     @Deprecated
     public int hashCode() {
         assert false : "hashCode not designed";
diff --git a/app/src/main/java/com/ibm/icu/text/CollationKey.java b/icu4j/src/main/java/com/ibm/icu/text/CollationKey.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/text/CollationKey.java
rename to icu4j/src/main/java/com/ibm/icu/text/CollationKey.java
index d7606b1..ca5c925 100644
--- a/app/src/main/java/com/ibm/icu/text/CollationKey.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CollationKey.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
 *******************************************************************************
 * Copyright (C) 1996-2016, International Business Machines Corporation and
@@ -19,18 +21,18 @@ import com.ibm.icu.impl.coll.Collation;
  * <code>Collator</code>s might differ.  Hence comparing
  * <code>CollationKey</code>s generated from different
  * <code>Collator</code>s can give incorrect results.
- 
+
  * <p>Both the method
  * <code>CollationKey.compareTo(CollationKey)</code> and the method
  * <code>Collator.compare(String, String)</code> compare two strings
  * and returns their relative order.  The performance characteristics
  * of these two approaches can differ.
- * Note that collation keys are often less efficient than simply doing comparison. 
+ * Note that collation keys are often less efficient than simply doing comparison.
  * For more details, see the ICU User Guide.
  *
  * <p>During the construction of a <code>CollationKey</code>, the
  * entire source string is examined and processed into a series of
- * bits terminated by a null, that are stored in the <code>CollationKey</code>. 
+ * bits terminated by a null, that are stored in the <code>CollationKey</code>.
  * When <code>CollationKey.compareTo(CollationKey)</code> executes, it
  * performs bitwise comparison on the bit sequences.  This can incurs
  * startup cost when creating the <code>CollationKey</code>, but once
@@ -43,7 +45,7 @@ import com.ibm.icu.impl.coll.Collation;
  * process the strings only until the first characters differing in
  * order.  This approach is recommended if the strings are to be
  * compared only once.</p>
- * 
+ *
  * <p>More information about the composition of the bit sequence can
  * be found in the
  * <a href="http://www.icu-project.org/userguide/Collate_ServiceArchitecture.html">
@@ -80,49 +82,50 @@ import com.ibm.icu.impl.coll.Collation;
  * @see Collator
  * @see RuleBasedCollator
  * @author Syn Wee Quek
- * @stable ICU 2.8 
+ * @stable ICU 2.8
  */
 public final class CollationKey implements Comparable<CollationKey>
 {
     // public inner classes -------------------------------------------------
-    
-    /** 
-     * Options that used in the API CollationKey.getBound() for getting a 
+
+    /**
+     * Options that used in the API CollationKey.getBound() for getting a
      * CollationKey based on the bound mode requested.
      * @stable ICU 2.6
      */
-    public static final class BoundMode 
+    public static final class BoundMode
     {
         /*
-         * do not change the values assigned to the members of this enum. 
-         * Underlying code depends on them having these numbers  
+         * do not change the values assigned to the members of this enum.
+         * Underlying code depends on them having these numbers
          */
-         
-        /** 
+
+        /**
          * Lower bound
          * @stable ICU 2.6
          */
         public static final int LOWER = 0;
 
-        /** 
+        /**
          * Upper bound that will match strings of exact size
          * @stable ICU 2.6
          */
         public static final int UPPER = 1;
 
-        /** 
-         * Upper bound that will match all the strings that have the same 
+        /**
+         * Upper bound that will match all the strings that have the same
          * initial substring as the given string
          * @stable ICU 2.6
          */
         public static final int UPPER_LONG = 2;
 
         /**
-         * Number of bound mode
-         * @stable ICU 2.6
+         * One more than the highest normal BoundMode value.
+         * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
          */
+        @Deprecated
         public static final int COUNT = 3;
-        
+
         /**
          * Private Constructor
          */
@@ -130,14 +133,14 @@ public final class CollationKey implements Comparable<CollationKey>
         private BoundMode(){}
         ///CLOVER:ON
     }
-    
+
     // public constructor ---------------------------------------------------
-    
+
     /**
      * CollationKey constructor.
      * This constructor is given public access, unlike the JDK version, to
-     * allow access to users extending the Collator class. See 
-     * {@link Collator#getCollationKey(String)}. 
+     * allow access to users extending the Collator class. See
+     * {@link Collator#getCollationKey(String)}.
      * @param source string this CollationKey is to represent
      * @param key array of bytes that represent the collation order of argument
      *            source terminated by a null
@@ -162,15 +165,15 @@ public final class CollationKey implements Comparable<CollationKey>
     }
 
     /**
-     * CollationKey constructor that forces key to release its internal byte 
-     * array for adoption. key will have a null byte array after this 
+     * CollationKey constructor that forces key to release its internal byte
+     * array for adoption. key will have a null byte array after this
      * construction.
      * @param source string this CollationKey is to represent
-     * @param key RawCollationKey object that represents the collation order of 
-     *            argument source. 
+     * @param key RawCollationKey object that represents the collation order of
+     *            argument source.
      * @see Collator
      * @see RawCollationKey
-     * @stable ICU 2.8 
+     * @stable ICU 2.8
      */
     public CollationKey(String source, RawCollationKey key)
     {
@@ -180,15 +183,15 @@ public final class CollationKey implements Comparable<CollationKey>
         assert m_key_[m_length_] == 0;
         m_hashCode_ = 0;
     }
-    
+
     // public getters -------------------------------------------------------
-    
+
     /**
      * Return the source string that this CollationKey represents.
      * @return source string that this CollationKey represents
      * @stable ICU 2.8
      */
-    public String getSourceString() 
+    public String getSourceString()
     {
         return m_source_;
     }
@@ -220,11 +223,11 @@ public final class CollationKey implements Comparable<CollationKey>
      * System.out.println("Strings are equal.");
      * </pre>
      *
-     * @return CollationKey value in a sequence of big-endian byte bytes 
+     * @return CollationKey value in a sequence of big-endian byte bytes
      *         terminated by a null.
      * @stable ICU 2.8
      */
-    public byte[] toByteArray() 
+    public byte[] toByteArray()
     {
         int length = getLength() + 1;
         byte result[] = new byte[length];
@@ -232,8 +235,8 @@ public final class CollationKey implements Comparable<CollationKey>
         return result;
     }
 
-    // public other methods -------------------------------------------------    
-     
+    // public other methods -------------------------------------------------
+
     /**
      * Compare this CollationKey to another CollationKey.  The
      * collation rules of the Collator that created this key are
@@ -246,12 +249,13 @@ public final class CollationKey implements Comparable<CollationKey>
      * @param target target CollationKey
      * @return an integer value.  If the value is less than zero this CollationKey
      *         is less than than target, if the value is zero they are equal, and
-     *         if the value is greater than zero this CollationKey is greater 
+     *         if the value is greater than zero this CollationKey is greater
      *         than target.
      * @exception NullPointerException is thrown if argument is null.
      * @see Collator#compare(String, String)
-     * @stable ICU 2.8 
+     * @stable ICU 2.8
      */
+    @Override
     public int compareTo(CollationKey target)
     {
         for (int i = 0;; ++i) {
@@ -278,24 +282,25 @@ public final class CollationKey implements Comparable<CollationKey>
      * @param target the object to compare to.
      * @return true if the two keys compare as equal, false otherwise.
      * @see #compareTo(CollationKey)
-     * @exception ClassCastException is thrown when the argument is not 
-     *            a CollationKey.  NullPointerException is thrown when the argument 
+     * @exception ClassCastException is thrown when the argument is not
+     *            a CollationKey.  NullPointerException is thrown when the argument
      *            is null.
-     * @stable ICU 2.8 
+     * @stable ICU 2.8
      */
-    public boolean equals(Object target) 
+    @Override
+    public boolean equals(Object target)
     {
         if (!(target instanceof CollationKey)) {
             return false;
         }
-        
+
         return equals((CollationKey)target);
     }
-    
+
     /**
      * Compare this CollationKey and the argument target CollationKey for
      * equality.
-     * The collation 
+     * The collation
      * rules of the Collator object which created these objects are applied.
      * <p>
      * See note in compareTo(CollationKey) for warnings of incorrect results
@@ -305,7 +310,7 @@ public final class CollationKey implements Comparable<CollationKey>
      * @exception NullPointerException is thrown when the argument is null.
      * @stable ICU 2.8
      */
-    public boolean equals(CollationKey target) 
+    public boolean equals(CollationKey target)
     {
         if (this == target) {
             return true;
@@ -329,15 +334,16 @@ public final class CollationKey implements Comparable<CollationKey>
 
     /**
      * Returns a hash code for this CollationKey. The hash value is calculated
-     * on the key itself, not the String from which the key was created. Thus 
-     * if x and y are CollationKeys, then x.hashCode(x) == y.hashCode() 
-     * if x.equals(y) is true. This allows language-sensitive comparison in a 
+     * on the key itself, not the String from which the key was created. Thus
+     * if x and y are CollationKeys, then x.hashCode(x) == y.hashCode()
+     * if x.equals(y) is true. This allows language-sensitive comparison in a
      * hash table.
      *
      * @return the hash value.
      * @stable ICU 2.8
      */
-    public int hashCode() 
+    @Override
+    public int hashCode()
     {
         if (m_hashCode_ == 0) {
             if (m_key_ == null) {
@@ -359,16 +365,16 @@ public final class CollationKey implements Comparable<CollationKey>
         }
         return m_hashCode_;
     }
-    
+
     /**
      * Produces a bound for the sort order of a given collation key and a
-     * strength level. This API does not attempt to find a bound for the 
-     * CollationKey String representation, hence null will be returned in its 
+     * strength level. This API does not attempt to find a bound for the
+     * CollationKey String representation, hence null will be returned in its
      * place.
      * <p>
      * Resulting bounds can be used to produce a range of strings that are
      * between upper and lower bounds. For example, if bounds are produced
-     * for a sortkey of string "smith", strings between upper and lower 
+     * for a sortkey of string "smith", strings between upper and lower
      * bounds with primary strength would include "Smith", "SMITH", "sMiTh".
      * <p>
      * There are two upper bounds that can be produced. If BoundMode.UPPER
@@ -376,31 +382,31 @@ public final class CollationKey implements Comparable<CollationKey>
      * is produced using BoundMode.UPPER_LONG is used, the above example will
      * also match "Smithsonian" and similar.
      * <p>
-     * For more on usage, see example in test procedure 
+     * For more on usage, see example in test procedure
      * <a href="http://source.icu-project.org/repos/icu/icu4j/trunk/src/com/ibm/icu/dev/test/collator/CollationAPITest.java">
      * src/com/ibm/icu/dev/test/collator/CollationAPITest/TestBounds.
      * </a>
      * <p>
      * Collation keys produced may be compared using the <TT>compare</TT> API.
      * @param boundType Mode of bound required. It can be BoundMode.LOWER, which
-     *              produces a lower inclusive bound, BoundMode.UPPER, that 
-     *              produces upper bound that matches strings of the same 
-     *              length or BoundMode.UPPER_LONG that matches strings that 
+     *              produces a lower inclusive bound, BoundMode.UPPER, that
+     *              produces upper bound that matches strings of the same
+     *              length or BoundMode.UPPER_LONG that matches strings that
      *              have the same starting substring as the source string.
-     * @param noOfLevels Strength levels required in the resulting bound 
+     * @param noOfLevels Strength levels required in the resulting bound
      *                 (for most uses, the recommended value is PRIMARY). This
-     *                 strength should be less than the maximum strength of 
+     *                 strength should be less than the maximum strength of
      *                 this CollationKey.
-     *                 See users guide for explanation on the strength levels a 
-     *                 collation key can have. 
-     * @return the result bounded CollationKey with a valid sort order but 
+     *                 See users guide for explanation on the strength levels a
+     *                 collation key can have.
+     * @return the result bounded CollationKey with a valid sort order but
      *         a null String representation.
-     * @exception IllegalArgumentException thrown when the strength level 
+     * @exception IllegalArgumentException thrown when the strength level
      *            requested is higher than or equal to the strength in this
-     *            CollationKey. 
-     *            In the case of an Exception, information 
-     *            about the maximum strength to use will be returned in the 
-     *            Exception. The user can then call getBound() again with the 
+     *            CollationKey.
+     *            In the case of an Exception, information
+     *            about the maximum strength to use will be returned in the
+     *            Exception. The user can then call getBound() again with the
      *            appropriate strength.
      * @see CollationKey
      * @see CollationKey.BoundMode
@@ -411,38 +417,38 @@ public final class CollationKey implements Comparable<CollationKey>
      * @see Collator#IDENTICAL
      * @stable ICU 2.6
      */
-    public CollationKey getBound(int boundType, int noOfLevels) 
+    public CollationKey getBound(int boundType, int noOfLevels)
     {
-        // Scan the string until we skip enough of the key OR reach the end of 
+        // Scan the string until we skip enough of the key OR reach the end of
         // the key
         int offset = 0;
         int keystrength = Collator.PRIMARY;
-        
+
         if (noOfLevels > Collator.PRIMARY) {
             while (offset < m_key_.length && m_key_[offset] != 0) {
-                if (m_key_[offset ++] 
+                if (m_key_[offset ++]
                         == Collation.LEVEL_SEPARATOR_BYTE) {
                     keystrength ++;
                     noOfLevels --;
-                    if (noOfLevels == Collator.PRIMARY 
+                    if (noOfLevels == Collator.PRIMARY
                         || offset == m_key_.length || m_key_[offset] == 0) {
                         offset --;
                         break;
                     }
                 }
-            } 
+            }
         }
-        
+
         if (noOfLevels > 0) {
             throw new IllegalArgumentException(
-                                  "Source collation key has only " 
-                                  + keystrength 
+                                  "Source collation key has only "
+                                  + keystrength
                                   + " strength level. Call getBound() again "
                                   + " with noOfLevels < " + keystrength);
         }
-        
-        // READ ME: this code assumes that the values for BoundMode variables 
-        // will not change. They are set so that the enum value corresponds to 
+
+        // READ ME: this code assumes that the values for BoundMode variables
+        // will not change. They are set so that the enum value corresponds to
         // the number of extra bytes each bound type needs.
         byte resultkey[] = new byte[offset + boundType + 1];
         System.arraycopy(m_key_, 0, resultkey, 0, offset);
@@ -498,7 +504,7 @@ public final class CollationKey implements Comparable<CollationKey>
      * <p>Example (uncompressed):
      * <pre>191B1D 01 050505 01 910505 00
      * 1F2123 01 050505 01 910505 00</pre>
-     * will be merged as 
+     * will be merged as
      * <pre>191B1D 02 1F2123 01 050505 02 050505 01 910505 02 910505 00</pre>
      *
      * @param source CollationKey to merge with
@@ -520,31 +526,31 @@ public final class CollationKey implements Comparable<CollationKey>
         // 1 byte extra for the 02 separator at the end of the copy of this sort key,
         // and 1 more for the terminating 00.
         byte result[] = new byte[getLength() + source.getLength() + 2];
-    
+
         // merge the sort keys with the same number of levels
         int rindex = 0;
         int index = 0;
         int sourceindex = 0;
-        while (true) { 
+        while (true) {
             // copy level from src1 not including 00 or 01
             // unsigned issues
             while (m_key_[index] < 0 || m_key_[index] >= MERGE_SEPERATOR_) {
                 result[rindex++] = m_key_[index++];
             }
-    
+
             // add a 02 merge separator
             result[rindex++] = MERGE_SEPERATOR_;
-    
+
             // copy level from src2 not including 00 or 01
-            while (source.m_key_[sourceindex] < 0 
+            while (source.m_key_[sourceindex] < 0
                    || source.m_key_[sourceindex] >= MERGE_SEPERATOR_) {
                 result[rindex++] = source.m_key_[sourceindex++];
             }
-    
-            // if both sort keys have another level, then add a 01 level 
+
+            // if both sort keys have another level, then add a 01 level
             // separator and continue
             if (m_key_[index] == Collation.LEVEL_SEPARATOR_BYTE
-                && source.m_key_[sourceindex] 
+                && source.m_key_[sourceindex]
                         == Collation.LEVEL_SEPARATOR_BYTE) {
                 ++index;
                 ++sourceindex;
@@ -568,7 +574,7 @@ public final class CollationKey implements Comparable<CollationKey>
             rindex += remainingLength;
         }
         result[rindex] = 0;
-    
+
         assert rindex == result.length - 1;
         return new CollationKey(null, result, rindex);
     }
@@ -579,10 +585,10 @@ public final class CollationKey implements Comparable<CollationKey>
      * Sequence of bytes that represents the sort key
      */
     private byte m_key_[];
-    
+
     /**
      * Source string this CollationKey represents
-     */    
+     */
     private String m_source_;
 
     /**
@@ -597,9 +603,9 @@ public final class CollationKey implements Comparable<CollationKey>
      * Collation key merge seperator
      */
     private static final int MERGE_SEPERATOR_ = 2;
-    
+
     // private methods ------------------------------------------------------
-    
+
     /**
      * Gets the length of the CollationKey
      * @return length of the CollationKey
@@ -615,7 +621,7 @@ public final class CollationKey implements Comparable<CollationKey>
                 length = index;
                 break;
             }
-        } 
+        }
         m_length_ = length;
         return m_length_;
     }
diff --git a/app/src/main/java/com/ibm/icu/text/Collator.java b/icu4j/src/main/java/com/ibm/icu/text/Collator.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/text/Collator.java
rename to icu4j/src/main/java/com/ibm/icu/text/Collator.java
index 60c5df7..79889c4 100644
--- a/app/src/main/java/com/ibm/icu/text/Collator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/Collator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
 *******************************************************************************
 * Copyright (C) 1996-2016, International Business Machines Corporation and
@@ -7,15 +9,15 @@
 package com.ibm.icu.text;
 
 import java.util.Comparator;
-import java.util.Enumeration;
-import java.util.Iterator;
 import java.util.LinkedList;
 import java.util.Locale;
 import java.util.MissingResourceException;
 import java.util.Set;
 
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUDebug;
 import com.ibm.icu.impl.ICUResourceBundle;
+import com.ibm.icu.impl.UResource;
 import com.ibm.icu.impl.coll.CollationData;
 import com.ibm.icu.impl.coll.CollationRoot;
 import com.ibm.icu.lang.UCharacter;
@@ -233,7 +235,7 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
 
     /**
      * Reordering codes for non-script groups that can be reordered under collation.
-     * 
+     *
      * @see #getReorderCodes
      * @see #setReorderCodes
      * @see #getEquivalentReorderCodes
@@ -251,7 +253,7 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
          */
         public final static int NONE          = UScript.UNKNOWN;
         /**
-         * A special reordering code that is used to specify all other codes used for reordering except 
+         * A special reordering code that is used to specify all other codes used for reordering except
          * for the codes listed as ReorderingCodes and those listed explicitly in a reordering.
          * @stable ICU 4.8
          */
@@ -293,13 +295,13 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
          */
         public final static int DIGIT          = 0x1004;
         /**
-         * The limit of the reorder codes. This is intended for use in range checking 
-         * and enumeration of the reorder codes.
-         * @stable ICU 4.8
+         * One more than the highest normal ReorderCodes value.
+         * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
          */
-        public final static int LIMIT          = 0x1005;        
+        @Deprecated
+        public final static int LIMIT          = 0x1005;
     }
-    
+
     // public methods --------------------------------------------------------
 
     /**
@@ -319,6 +321,22 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
         return this == obj || (obj != null && getClass() == obj.getClass());
     }
 
+    /**
+     * Generates a hash code for this Collator object.
+     *
+     * <p>The implementation exists just for consistency with {@link #equals(Object)}
+     * implementation in this class and does not generate a useful hash code.
+     * Subclasses should override this implementation.
+     *
+     * @return a hash code value.
+     * @stable ICU 58
+     */
+    @Override
+    public int hashCode() {
+        // Dummy return to prevent compile warnings.
+        return 0;
+    }
+
     // public setters --------------------------------------------------------
 
     private void checkNotFrozen() {
@@ -395,16 +413,16 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
         checkNotFrozen();
     }
 
-    /** 
+    /**
      * Sets the reordering codes for this collator.
      * Collation reordering allows scripts and some other groups of characters
      * to be moved relative to each other. This reordering is done on top of
-     * the DUCET/CLDR standard collation order. Reordering can specify groups to be placed 
+     * the DUCET/CLDR standard collation order. Reordering can specify groups to be placed
      * at the start and/or the end of the collation order. These groups are specified using
      * UScript codes and {@link Collator.ReorderCodes} entries.
      *
-     * <p>By default, reordering codes specified for the start of the order are placed in the 
-     * order given after several special non-script blocks. These special groups of characters 
+     * <p>By default, reordering codes specified for the start of the order are placed in the
+     * order given after several special non-script blocks. These special groups of characters
      * are space, punctuation, symbol, currency, and digit. These special groups are represented with
      * {@link Collator.ReorderCodes} entries. Script groups can be intermingled with
      * these special non-script groups if those special groups are explicitly specified in the reordering.
@@ -417,13 +435,13 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
      * <p>The special reorder code {@link Collator.ReorderCodes#DEFAULT DEFAULT}
      * will reset the reordering for this collator
      * to the default for this collator. The default reordering may be the DUCET/CLDR order or may be a reordering that
-     * was specified when this collator was created from resource data or from rules. The 
+     * was specified when this collator was created from resource data or from rules. The
      * DEFAULT code <b>must</b> be the sole code supplied when it is used.
      * If not, then an {@link IllegalArgumentException} will be thrown.
      *
      * <p>The special reorder code {@link Collator.ReorderCodes#NONE NONE}
      * will remove any reordering for this collator.
-     * The result of setting no reordering will be to have the DUCET/CLDR ordering used. The 
+     * The result of setting no reordering will be to have the DUCET/CLDR ordering used. The
      * NONE code <b>must</b> be the sole code supplied when it is used.
      *
      * @param order the reordering codes to apply to this collator; if this is null or an empty array
@@ -433,11 +451,11 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
      * @see Collator.ReorderCodes
      * @see UScript
      * @stable ICU 4.8
-     */ 
-    public void setReorderCodes(int... order) 
-    { 
-        throw new UnsupportedOperationException("Needs to be implemented by the subclass."); 
-    } 
+     */
+    public void setReorderCodes(int... order)
+    {
+        throw new UnsupportedOperationException("Needs to be implemented by the subclass.");
+    }
 
     // public getters --------------------------------------------------------
 
@@ -462,6 +480,7 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
      * @stable ICU 2.6
      * @return a clone of this collator.
      */
+    @Override
     public Object clone() throws CloneNotSupportedException {
         return super.clone();
     }
@@ -859,7 +878,7 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
 
     /**
      * {@icu} Registers a collator factory.
-     * 
+     *
      * <p>Because ICU may choose to cache Collator objects internally, this must
      * be called at application startup, prior to any calls to
      * Collator.getInstance to avoid undefined behavior.
@@ -898,7 +917,7 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
         // TODO make this wrap getAvailableULocales later
         if (shim == null) {
             return ICUResourceBundle.getAvailableLocales(
-                ICUResourceBundle.ICU_COLLATION_BASE_NAME, ICUResourceBundle.ICU_DATA_CLASS_LOADER);
+                ICUData.ICU_COLLATION_BASE_NAME, ICUResourceBundle.ICU_DATA_CLASS_LOADER);
         }
         return shim.getAvailableLocales();
     }
@@ -914,7 +933,7 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
     public static final ULocale[] getAvailableULocales() {
         if (shim == null) {
             return ICUResourceBundle.getAvailableULocales(
-                ICUResourceBundle.ICU_COLLATION_BASE_NAME, ICUResourceBundle.ICU_DATA_CLASS_LOADER);
+                ICUData.ICU_COLLATION_BASE_NAME, ICUResourceBundle.ICU_DATA_CLASS_LOADER);
         }
         return shim.getAvailableULocales();
     }
@@ -937,8 +956,8 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
      * The resource bundle base name for this service.
      * *since ICU 3.0
      */
-    
-    private static final String BASE = ICUResourceBundle.ICU_COLLATION_BASE_NAME;
+
+    private static final String BASE = ICUData.ICU_COLLATION_BASE_NAME;
 
     /**
      * {@icu} Returns an array of all possible keywords that are relevant to
@@ -981,48 +1000,47 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
      * @return an array of string values for the given key and the locale.
      * @stable ICU 4.2
      */
-    public static final String[] getKeywordValuesForLocale(String key, ULocale locale, 
+    public static final String[] getKeywordValuesForLocale(String key, ULocale locale,
                                                            boolean commonlyUsed) {
-        // Note: The parameter commonlyUsed is actually not used.
+        // Note: The parameter commonlyUsed is not used.
         // The switch is in the method signature for consistency
         // with other locale services.
 
-        // Read available collation values from collation bundles
-        String baseLoc = locale.getBaseName();
-        LinkedList<String> values = new LinkedList<String>();
+        // Read available collation values from collation bundles.
+        ICUResourceBundle bundle = (ICUResourceBundle)
+                UResourceBundle.getBundleInstance(
+                        ICUData.ICU_COLLATION_BASE_NAME, locale);
+        KeywordsSink sink = new KeywordsSink();
+        bundle.getAllItemsWithFallback("collations", sink);
+        return sink.values.toArray(new String[sink.values.size()]);
+    }
 
-        UResourceBundle bundle = UResourceBundle.getBundleInstance(
-                ICUResourceBundle.ICU_COLLATION_BASE_NAME, baseLoc);
-
-        String defcoll = null;
-        while (bundle != null) {
-            UResourceBundle collations = bundle.get("collations");
-            Enumeration<String> collEnum = collations.getKeys();
-            while (collEnum.hasMoreElements()) {
-                String collkey = collEnum.nextElement();
-                if (collkey.equals("default")) {
-                    if (defcoll == null) {
-                        // Keep the default
-                        defcoll = collations.getString("default");
+    private static final class KeywordsSink extends UResource.Sink {
+        LinkedList<String> values = new LinkedList<String>();
+        boolean hasDefault = false;
+
+        @Override
+        public void put(UResource.Key key, UResource.Value value, boolean noFallback) {
+            UResource.Table collations = value.getTable();
+            for (int i = 0; collations.getKeyAndValue(i, key, value); ++i) {
+                int type = value.getType();
+                if (type == UResourceBundle.STRING) {
+                    if (!hasDefault && key.contentEquals("default")) {
+                        String defcoll = value.getString();
+                        if (!defcoll.isEmpty()) {
+                            values.remove(defcoll);
+                            values.addFirst(defcoll);
+                            hasDefault = true;
+                        }
+                    }
+                } else if (type == UResourceBundle.TABLE && !key.startsWith("private-")) {
+                    String collkey = key.toString();
+                    if (!values.contains(collkey)) {
+                        values.add(collkey);
                     }
-                } else if (!collkey.startsWith("private-") && !values.contains(collkey)) {
-                    values.add(collkey);
                 }
             }
-            bundle = ((ICUResourceBundle)bundle).getParent();
         }
-        // Reordering
-        Iterator<String> itr = values.iterator();
-        String[] result = new String[values.size()];
-        result[0] = defcoll;
-        int idx = 1;
-        while (itr.hasNext()) {
-            String collKey = itr.next();
-            if (!collKey.equals(defcoll)) {
-                result[idx++] = collKey;
-            }
-        }
-        return result;
     }
 
     /**
@@ -1227,6 +1245,7 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
      * @throws ClassCastException thrown if either arguments cannot be cast to CharSequence.
      * @stable ICU 4.2
      */
+    @Override
     public int compare(Object source, Object target) {
         return doCompare((CharSequence)source, (CharSequence)target);
     }
@@ -1249,7 +1268,7 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
      * repeated comparison.  The resulting key depends on the collator's
      * rules, strength and decomposition mode.
      *
-     * <p>Note that collation keys are often less efficient than simply doing comparison. 
+     * <p>Note that collation keys are often less efficient than simply doing comparison.
      * For more details, see the ICU User Guide.
      *
      * <p>See the CollationKey class documentation for more information.
@@ -1270,7 +1289,7 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
      * key.  If key has a internal byte array of length that's too small for the result,
      * the internal byte array will be grown to the exact required size.
      *
-     * <p>Note that collation keys are often less efficient than simply doing comparison. 
+     * <p>Note that collation keys are often less efficient than simply doing comparison.
      * For more details, see the ICU User Guide.
      *
      * @param source the text String to be transformed into a RawCollationKey
@@ -1323,7 +1342,7 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
      * the top of one of the supported reordering groups,
      * and it must not be beyond the last of those groups.
      * See {@link #setMaxVariable(int)}.
-     * 
+     *
      * @param varTop one or more (if contraction) characters to which the
      *               variable top should be set
      * @return variable top primary weight
@@ -1345,7 +1364,7 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
 
     /**
      * {@icu} Gets the variable top value of a Collator.
-     * 
+     *
      * @return the variable top primary weight
      * @see #getMaxVariable
      * @stable ICU 2.6
@@ -1359,7 +1378,7 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
      * the top of one of the supported reordering groups,
      * and it must not be beyond the last of those groups.
      * See {@link #setMaxVariable(int)}.
-     * 
+     *
      * @param varTop primary weight, as returned by setVariableTop or getVariableTop
      * @see #getVariableTop
      * @see #setVariableTop(String)
@@ -1381,22 +1400,22 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
      * @stable ICU 2.8
      */
     public abstract VersionInfo getUCAVersion();
-    
-    /**  
+
+    /**
      * Retrieves the reordering codes for this collator.
      * These reordering codes are a combination of UScript codes and ReorderCodes.
-     * @return a copy of the reordering codes for this collator; 
+     * @return a copy of the reordering codes for this collator;
      * if none are set then returns an empty array
      * @see #setReorderCodes
      * @see #getEquivalentReorderCodes
      * @see Collator.ReorderCodes
      * @see UScript
      * @stable ICU 4.8
-     */ 
-    public int[] getReorderCodes() 
-    { 
-        throw new UnsupportedOperationException("Needs to be implemented by the subclass."); 
-    }   
+     */
+    public int[] getReorderCodes()
+    {
+        throw new UnsupportedOperationException("Needs to be implemented by the subclass.");
+    }
 
     /**
      * Retrieves all the reorder codes that are grouped with the given reorder code. Some reorder
@@ -1404,7 +1423,7 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
      * Beginning with ICU 55, scripts only reorder together if they are primary-equal,
      * for example Hiragana and Katakana.
      *
-     * @param reorderCode The reorder code to determine equivalence for. 
+     * @param reorderCode The reorder code to determine equivalence for.
      * @return the set of all reorder codes in the same group as the given reorder code.
      * @see #setReorderCodes
      * @see #getReorderCodes
@@ -1415,11 +1434,11 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
     public static int[] getEquivalentReorderCodes(int reorderCode) {
         CollationData baseData = CollationRoot.getData();
         return baseData.getEquivalentScripts(reorderCode);
-    }   
+    }
 
 
     // Freezable interface implementation -------------------------------------------------
-    
+
     /**
      * Determines whether the object has been frozen or not.
      *
@@ -1428,6 +1447,7 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
      *
      * @stable ICU 4.8
      */
+    @Override
     public boolean isFrozen() {
         return false;
     }
@@ -1437,6 +1457,7 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
      * @return the collator itself.
      * @stable ICU 4.8
      */
+    @Override
     public Collator freeze() {
         throw new UnsupportedOperationException("Needs to be implemented by the subclass.");
     }
@@ -1445,10 +1466,11 @@ public abstract class Collator implements Comparator<Object>, Freezable<Collator
      * Provides for the clone operation. Any clone is initially unfrozen.
      * @stable ICU 4.8
      */
+    @Override
     public Collator cloneAsThawed() {
         throw new UnsupportedOperationException("Needs to be implemented by the subclass.");
     }
-    
+
     /**
      * Empty default constructor to make javadocs happy
      * @stable ICU 2.4
diff --git a/app/src/main/java/com/ibm/icu/text/CollatorServiceShim.java b/icu4j/src/main/java/com/ibm/icu/text/CollatorServiceShim.java
similarity index 89%
rename from app/src/main/java/com/ibm/icu/text/CollatorServiceShim.java
rename to icu4j/src/main/java/com/ibm/icu/text/CollatorServiceShim.java
index c5419c7..53403a3 100644
--- a/app/src/main/java/com/ibm/icu/text/CollatorServiceShim.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CollatorServiceShim.java
@@ -1,6 +1,8 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
 *******************************************************************************
-* Copyright (C) 2003-2014, International Business Machines Corporation and
+* Copyright (C) 2003-2016, International Business Machines Corporation and
 * others. All Rights Reserved.
 *******************************************************************************
 */
@@ -11,6 +13,7 @@ import java.util.Locale;
 import java.util.MissingResourceException;
 import java.util.Set;
 
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICULocaleService;
 import com.ibm.icu.impl.ICULocaleService.LocaleKeyFactory;
 import com.ibm.icu.impl.ICUResourceBundle;
@@ -25,6 +28,7 @@ import com.ibm.icu.util.ULocale;
 
 final class CollatorServiceShim extends Collator.ServiceShim {
 
+    @Override
     Collator getInstance(ULocale locale) {
     // use service cache, it's faster than instantiation
 //          if (service.isDefault()) {
@@ -48,6 +52,7 @@ final class CollatorServiceShim extends Collator.ServiceShim {
         }
     }
 
+    @Override
     Object registerInstance(Collator collator, ULocale locale) {
         // Set the collator locales while registering so that getInstance()
         // need not guess whether the collator's locales are already set properly
@@ -56,6 +61,7 @@ final class CollatorServiceShim extends Collator.ServiceShim {
         return service.registerObject(collator, locale);
     }
 
+    @Override
     Object registerFactory(CollatorFactory f) {
         class CFactory extends LocaleKeyFactory {
             CollatorFactory delegate;
@@ -65,16 +71,19 @@ final class CollatorServiceShim extends Collator.ServiceShim {
                 this.delegate = fctry;
             }
 
+            @Override
             public Object handleCreate(ULocale loc, int kind, ICUService srvc) {
                 Object coll = delegate.createCollator(loc);
                 return coll;
             }
 
+            @Override
             public String getDisplayName(String id, ULocale displayLocale) {
                 ULocale objectLocale = new ULocale(id);
                 return delegate.getDisplayName(objectLocale, displayLocale);
             }
 
+            @Override
             public Set<String> getSupportedIDs() {
                 return delegate.getSupportedLocaleIDs();
             }
@@ -83,15 +92,17 @@ final class CollatorServiceShim extends Collator.ServiceShim {
         return service.registerFactory(new CFactory(f));
     }
 
+    @Override
     boolean unregister(Object registryKey) {
         return service.unregisterFactory((Factory)registryKey);
     }
 
+    @Override
     Locale[] getAvailableLocales() {
         // TODO rewrite this to just wrap getAvailableULocales later
         Locale[] result;
         if (service.isDefault()) {
-            result = ICUResourceBundle.getAvailableLocales(ICUResourceBundle.ICU_COLLATION_BASE_NAME,
+            result = ICUResourceBundle.getAvailableLocales(ICUData.ICU_COLLATION_BASE_NAME,
                     ICUResourceBundle.ICU_DATA_CLASS_LOADER);
         } else {
             result = service.getAvailableLocales();
@@ -99,10 +110,11 @@ final class CollatorServiceShim extends Collator.ServiceShim {
         return result;
     }
 
+    @Override
     ULocale[] getAvailableULocales() {
         ULocale[] result;
         if (service.isDefault()) {
-            result = ICUResourceBundle.getAvailableULocales(ICUResourceBundle.ICU_COLLATION_BASE_NAME,
+            result = ICUResourceBundle.getAvailableULocales(ICUData.ICU_COLLATION_BASE_NAME,
                     ICUResourceBundle.ICU_DATA_CLASS_LOADER);
         } else {
             result = service.getAvailableULocales();
@@ -110,6 +122,7 @@ final class CollatorServiceShim extends Collator.ServiceShim {
         return result;
     }
 
+    @Override
     String getDisplayName(ULocale objectLocale, ULocale displayLocale) {
         String id = objectLocale.getName();
         return service.getDisplayName(id, displayLocale);
@@ -121,7 +134,7 @@ final class CollatorServiceShim extends Collator.ServiceShim {
 
             class CollatorFactory extends ICUResourceBundleFactory {
                 CollatorFactory() {
-                    super(ICUResourceBundle.ICU_COLLATION_BASE_NAME);
+                    super(ICUData.ICU_COLLATION_BASE_NAME);
                 }
 
                 @Override
@@ -149,6 +162,7 @@ final class CollatorServiceShim extends Collator.ServiceShim {
 
         ///CLOVER:OFF
         // The following method can not be reached by testing
+        @Override
         protected Object handleDefault(Key key, String[] actualIDReturn) {
             if (actualIDReturn != null) {
                 actualIDReturn[0] = "root";
diff --git a/icu4j/src/main/java/com/ibm/icu/text/CompactDecimalDataCache.java b/icu4j/src/main/java/com/ibm/icu/text/CompactDecimalDataCache.java
new file mode 100644
index 0000000..8d302a5
--- /dev/null
+++ b/icu4j/src/main/java/com/ibm/icu/text/CompactDecimalDataCache.java
@@ -0,0 +1,524 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
+/*
+ *******************************************************************************
+ * Copyright (C) 2012-2016, International Business Machines Corporation and
+ * others. All Rights Reserved.
+ *******************************************************************************
+ */
+package com.ibm.icu.text;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.MissingResourceException;
+
+import com.ibm.icu.impl.ICUCache;
+import com.ibm.icu.impl.ICUData;
+import com.ibm.icu.impl.ICUResourceBundle;
+import com.ibm.icu.impl.SimpleCache;
+import com.ibm.icu.impl.UResource;
+import com.ibm.icu.text.DecimalFormat.Unit;
+import com.ibm.icu.util.ULocale;
+import com.ibm.icu.util.UResourceBundle;
+
+/**
+ * A cache containing data by locale for {@link CompactDecimalFormat}
+ *
+ * @author Travis Keep
+ */
+class CompactDecimalDataCache {
+
+    private static final String SHORT_STYLE = "short";
+    private static final String LONG_STYLE = "long";
+    private static final String SHORT_CURRENCY_STYLE = "shortCurrency";
+    private static final String NUMBER_ELEMENTS = "NumberElements";
+    private static final String PATTERNS_LONG = "patternsLong";
+    private static final String PATTERNS_SHORT = "patternsShort";
+    private static final String DECIMAL_FORMAT = "decimalFormat";
+    private static final String CURRENCY_FORMAT = "currencyFormat";
+    private static final String LATIN_NUMBERING_SYSTEM = "latn";
+
+    private static enum PatternsTableKey { PATTERNS_LONG, PATTERNS_SHORT };
+    private static enum FormatsTableKey { DECIMAL_FORMAT, CURRENCY_FORMAT };
+
+    public static final String OTHER = "other";
+
+    /**
+     * We can specify prefixes or suffixes for values with up to 15 digits,
+     * less than 10^15.
+     */
+    static final int MAX_DIGITS = 15;
+
+    private final ICUCache<ULocale, DataBundle> cache =
+            new SimpleCache<ULocale, DataBundle>();
+
+    /**
+     * Data contains the compact decimal data for a particular locale. Data consists
+     * of one array and two hashmaps. The index of the divisors array as well
+     * as the arrays stored in the values of the two hashmaps correspond
+     * to log10 of the number being formatted, so when formatting 12,345, the 4th
+     * index of the arrays should be used. Divisors contain the number to divide
+     * by before doing formatting. In the case of english, <code>divisors[4]</code>
+     * is 1000.  So to format 12,345, divide by 1000 to get 12. Then use
+     * PluralRules with the current locale to figure out which of the 6 plural variants
+     * 12 matches: "zero", "one", "two", "few", "many", or "other." Prefixes and
+     * suffixes are maps whose key is the plural variant and whose values are
+     * arrays of strings with indexes corresponding to log10 of the original number.
+     * these arrays contain the prefix or suffix to use.
+     *
+     * Each array in data is 15 in length, and every index is filled.
+     *
+     * @author Travis Keep
+     *
+     */
+    static class Data {
+        long[] divisors;
+        Map<String, DecimalFormat.Unit[]> units;
+        boolean fromFallback;
+
+        Data(long[] divisors, Map<String, DecimalFormat.Unit[]> units)
+        {
+            this.divisors = divisors;
+            this.units = units;
+        }
+
+        public boolean isEmpty() {
+            return units == null || units.isEmpty();
+        }
+    }
+
+    /**
+     * DataBundle contains compact decimal data for all the styles in a particular
+     * locale. Currently available styles are short and long for decimals, and
+     * short only for currencies.
+     *
+     * @author Travis Keep
+     */
+    static class DataBundle {
+        Data shortData;
+        Data longData;
+        Data shortCurrencyData;
+
+        private DataBundle(Data shortData, Data longData, Data shortCurrencyData) {
+            this.shortData = shortData;
+            this.longData = longData;
+            this.shortCurrencyData = shortCurrencyData;
+        }
+
+        private static DataBundle createEmpty() {
+            return new DataBundle(
+                new Data(new long[MAX_DIGITS], new HashMap<String, DecimalFormat.Unit[]>()),
+                new Data(new long[MAX_DIGITS], new HashMap<String, DecimalFormat.Unit[]>()),
+                new Data(new long[MAX_DIGITS], new HashMap<String, DecimalFormat.Unit[]>())
+            );
+        }
+    }
+
+    /**
+     * Sink for enumerating all of the compact decimal format patterns.
+     *
+     * More specific bundles (en_GB) are enumerated before their parents (en_001, en, root):
+     * Only store a value if it is still missing, that is, it has not been overridden.
+     */
+    private static final class CompactDecimalDataSink extends UResource.Sink {
+
+        private DataBundle dataBundle; // Where to save values when they are read
+        private ULocale locale; // The locale we are traversing (for exception messages)
+        private boolean isLatin; // Whether or not we are traversing the Latin table
+        private boolean isFallback; // Whether or not we are traversing the Latin table as fallback
+
+        /*
+         * NumberElements{              <-- top (numbering system table)
+         *  latn{                       <-- patternsTable (one per numbering system)
+         *    patternsLong{             <-- formatsTable (one per pattern)
+         *      decimalFormat{          <-- powersOfTenTable (one per format)
+         *        1000{                 <-- pluralVariantsTable (one per power of ten)
+         *          one{"0 thousand"}   <-- plural variant and template
+         */
+
+        public CompactDecimalDataSink(DataBundle dataBundle, ULocale locale) {
+            this.dataBundle = dataBundle;
+            this.locale = locale;
+        }
+
+        @Override
+        public void put(UResource.Key key, UResource.Value value, boolean isRoot) {
+            // SPECIAL CASE: Don't consume root in the non-Latin numbering system
+            if (isRoot && !isLatin) { return; }
+
+            UResource.Table patternsTable = value.getTable();
+            for (int i1 = 0; patternsTable.getKeyAndValue(i1, key, value); ++i1) {
+
+                // patterns table: check for patternsShort or patternsLong
+                PatternsTableKey patternsTableKey;
+                if (key.contentEquals(PATTERNS_SHORT)) {
+                    patternsTableKey = PatternsTableKey.PATTERNS_SHORT;
+                } else if (key.contentEquals(PATTERNS_LONG)) {
+                    patternsTableKey = PatternsTableKey.PATTERNS_LONG;
+                } else {
+                    continue;
+                }
+
+                // traverse into the table of formats
+                UResource.Table formatsTable = value.getTable();
+                for (int i2 = 0; formatsTable.getKeyAndValue(i2, key, value); ++i2) {
+
+                    // formats table: check for decimalFormat or currencyFormat
+                    FormatsTableKey formatsTableKey;
+                    if (key.contentEquals(DECIMAL_FORMAT)) {
+                        formatsTableKey = FormatsTableKey.DECIMAL_FORMAT;
+                    } else if (key.contentEquals(CURRENCY_FORMAT)) {
+                        formatsTableKey = FormatsTableKey.CURRENCY_FORMAT;
+                    } else {
+                        continue;
+                    }
+
+                    // Set the current style and destination based on the lvl1 and lvl2 keys
+                    String style = null;
+                    Data destination = null;
+                    if (patternsTableKey == PatternsTableKey.PATTERNS_LONG
+                            && formatsTableKey == FormatsTableKey.DECIMAL_FORMAT) {
+                        style = LONG_STYLE;
+                        destination = dataBundle.longData;
+                    } else if (patternsTableKey == PatternsTableKey.PATTERNS_SHORT
+                            && formatsTableKey == FormatsTableKey.DECIMAL_FORMAT) {
+                        style = SHORT_STYLE;
+                        destination = dataBundle.shortData;
+                    } else if (patternsTableKey == PatternsTableKey.PATTERNS_SHORT
+                            && formatsTableKey == FormatsTableKey.CURRENCY_FORMAT) {
+                        style = SHORT_CURRENCY_STYLE;
+                        destination = dataBundle.shortCurrencyData;
+                    } else {
+                        // Silently ignore this case
+                        continue;
+                    }
+
+                    // SPECIAL CASE: RULES FOR WHETHER OR NOT TO CONSUME THIS TABLE:
+                    //   1) Don't consume longData if shortData was consumed from the non-Latin
+                    //      locale numbering system
+                    //   2) Don't consume longData for the first time if this is the root bundle and
+                    //      shortData is already populated from a more specific locale. Note that if
+                    //      both longData and shortData are both only in root, longData will be
+                    //      consumed since it is alphabetically before shortData in the bundle.
+                    if (isFallback
+                            && style == LONG_STYLE
+                            && !dataBundle.shortData.isEmpty()
+                            && !dataBundle.shortData.fromFallback) {
+                        continue;
+                    }
+                    if (isRoot
+                            && style == LONG_STYLE
+                            && dataBundle.longData.isEmpty()
+                            && !dataBundle.shortData.isEmpty()) {
+                        continue;
+                    }
+
+                    // Set the "fromFallback" flag on the data object
+                    destination.fromFallback = isFallback;
+
+                    // traverse into the table of powers of ten
+                    UResource.Table powersOfTenTable = value.getTable();
+                    for (int i3 = 0; powersOfTenTable.getKeyAndValue(i3, key, value); ++i3) {
+
+                        // This value will always be some even power of 10. e.g 10000.
+                        long power10 = Long.parseLong(key.toString());
+                        int log10Value = (int) Math.log10(power10);
+
+                        // Silently ignore divisors that are too big.
+                        if (log10Value >= MAX_DIGITS) continue;
+
+                        // Iterate over the plural variants ("one", "other", etc)
+                        UResource.Table pluralVariantsTable = value.getTable();
+                        for (int i4 = 0; pluralVariantsTable.getKeyAndValue(i4, key, value); ++i4) {
+                            // TODO: Use StandardPlural rather than String.
+                            String pluralVariant = key.toString();
+                            String template = value.toString();
+
+                            // Copy the data into the in-memory data bundle (do not overwrite
+                            // existing values)
+                            int numZeros = populatePrefixSuffix(
+                                    pluralVariant, log10Value, template, locale, style, destination, false);
+
+                            // If populatePrefixSuffix returns -1, it means that this key has been
+                            // encountered already.
+                            if (numZeros < 0) {
+                                continue;
+                            }
+
+                            // Set the divisor, which is based on the number of zeros in the template
+                            // string.  If the divisor from here is different from the one previously
+                            // stored, it means that the number of zeros in different plural variants
+                            // differs; throw an exception.
+                            long divisor = calculateDivisor(power10, numZeros);
+                            if (destination.divisors[log10Value] != 0L
+                                    && destination.divisors[log10Value] != divisor) {
+                                throw new IllegalArgumentException("Plural variant '" + pluralVariant
+                                        + "' template '" + template
+                                        + "' for 10^" + log10Value
+                                        + " has wrong number of zeros in " + localeAndStyle(locale, style));
+                            }
+                            destination.divisors[log10Value] = divisor;
+                        }
+                    }
+                }
+            }
+        }
+    }
+
+    /**
+     * Fetch data for a particular locale. Clients must not modify any part of the returned data. Portions of returned
+     * data may be shared so modifying it will have unpredictable results.
+     */
+    DataBundle get(ULocale locale) {
+        DataBundle result = cache.get(locale);
+        if (result == null) {
+            result = load(locale);
+            cache.put(locale, result);
+        }
+        return result;
+    }
+
+    private static DataBundle load(ULocale ulocale) throws MissingResourceException {
+        DataBundle dataBundle = DataBundle.createEmpty();
+        String nsName = NumberingSystem.getInstance(ulocale).getName();
+        ICUResourceBundle r = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME,
+                ulocale);
+        CompactDecimalDataSink sink = new CompactDecimalDataSink(dataBundle, ulocale);
+        sink.isFallback = false;
+
+        // First load the number elements data from nsName if nsName is not Latin.
+        if (!nsName.equals(LATIN_NUMBERING_SYSTEM)) {
+            sink.isLatin = false;
+
+            try {
+                r.getAllItemsWithFallback(NUMBER_ELEMENTS + "/" + nsName, sink);
+            } catch (MissingResourceException e) {
+                // Silently ignore and use Latin
+            }
+
+            // Set the "isFallback" flag for when we read Latin
+            sink.isFallback = true;
+        }
+
+        // Now load Latin, which will fill in things that were left out from above.
+        sink.isLatin = true;
+        r.getAllItemsWithFallback(NUMBER_ELEMENTS + "/" + LATIN_NUMBERING_SYSTEM, sink);
+
+        // If longData is empty, default it to be equal to shortData
+        if (dataBundle.longData.isEmpty()) {
+            dataBundle.longData = dataBundle.shortData;
+        }
+
+        // Check for "other" variants in each of the three data classes
+        checkForOtherVariants(dataBundle.longData, ulocale, LONG_STYLE);
+        checkForOtherVariants(dataBundle.shortData, ulocale, SHORT_STYLE);
+        checkForOtherVariants(dataBundle.shortCurrencyData, ulocale, SHORT_CURRENCY_STYLE);
+
+        // Resolve missing elements
+        fillInMissing(dataBundle.longData);
+        fillInMissing(dataBundle.shortData);
+        fillInMissing(dataBundle.shortCurrencyData);
+
+        // Return the data bundle
+        return dataBundle;
+    }
+
+
+    /**
+     * Populates prefix and suffix information for a particular plural variant
+     * and index (log10 value).
+     * @param pluralVariant e.g "one", "other"
+     * @param idx the index (log10 value of the number) 0 <= idx < MAX_DIGITS
+     * @param template e.g "00K"
+     * @param locale the locale
+     * @param style the style
+     * @param destination Extracted prefix and suffix stored here.
+     * @return number of zeros found before any decimal point in template, or -1 if it was not saved.
+     */
+    private static int populatePrefixSuffix(
+            String pluralVariant, int idx, String template, ULocale locale, String style,
+            Data destination, boolean overwrite) {
+        int firstIdx = template.indexOf("0");
+        int lastIdx = template.lastIndexOf("0");
+        if (firstIdx == -1) {
+            throw new IllegalArgumentException(
+                "Expect at least one zero in template '" + template +
+                "' for variant '" +pluralVariant + "' for 10^" + idx +
+                " in " + localeAndStyle(locale, style));
+        }
+        String prefix = template.substring(0, firstIdx);
+        String suffix = template.substring(lastIdx + 1);
+
+        // Save the unit, and return -1 if it was not saved
+        boolean saved = saveUnit(new DecimalFormat.Unit(prefix, suffix), pluralVariant, idx, destination.units, overwrite);
+        if (!saved) {
+            return -1;
+        }
+
+        // If there is effectively no prefix or suffix, ignore the actual
+        // number of 0's and act as if the number of 0's matches the size
+        // of the number
+        if (prefix.trim().length() == 0 && suffix.trim().length() == 0) {
+          return idx + 1;
+        }
+
+        // Calculate number of zeros before decimal point.
+        int i = firstIdx + 1;
+        while (i <= lastIdx && template.charAt(i) == '0') {
+            i++;
+        }
+        return i - firstIdx;
+    }
+
+    /**
+     * Calculate a divisor based on the magnitude and number of zeros in the
+     * template string.
+     * @param power10
+     * @param numZeros
+     * @return
+     */
+    private static long calculateDivisor(long power10, int numZeros) {
+        // We craft our divisor such that when we divide by it, we get a
+        // number with the same number of digits as zeros found in the
+        // plural variant templates. If our magnitude is 10000 and we have
+        // two 0's in our plural variants, then we want a divisor of 1000.
+        // Note that if we have 43560 which is of same magnitude as 10000.
+        // When we divide by 1000 we a quotient which rounds to 44 (2 digits)
+        long divisor = power10;
+        for (int i = 1; i < numZeros; i++) {
+            divisor /= 10;
+        }
+        return divisor;
+    }
+
+
+    /**
+     * Returns locale and style. Used to form useful messages in thrown exceptions.
+     *
+     * Note: This is not covered by unit tests since no exceptions are thrown on the default CLDR data.  It is too
+     * cumbersome to cover via reflection.
+     *
+     * @param locale the locale
+     * @param style the style
+     */
+    private static String localeAndStyle(ULocale locale, String style) {
+        return "locale '" + locale + "' style '" + style + "'";
+    }
+
+    /**
+     * Checks to make sure that an "other" variant is present in all powers of 10.
+     * @param data
+     */
+    private static void checkForOtherVariants(Data data, ULocale locale, String style) {
+        DecimalFormat.Unit[] otherByBase = data.units.get(OTHER);
+
+        if (otherByBase == null) {
+            throw new IllegalArgumentException("No 'other' plural variants defined in "
+                    + localeAndStyle(locale, style));
+        }
+
+        // Check all other plural variants, and make sure that if any of them are populated, then
+        // other is also populated
+        for (Map.Entry<String, Unit[]> entry : data.units.entrySet()) {
+            if (entry.getKey() == OTHER) continue;
+            DecimalFormat.Unit[] variantByBase = entry.getValue();
+            for (int log10Value = 0; log10Value < MAX_DIGITS; log10Value++) {
+                if (variantByBase[log10Value] != null && otherByBase[log10Value] == null) {
+                    throw new IllegalArgumentException(
+                            "No 'other' plural variant defined for 10^" + log10Value
+                            + " but a '" + entry.getKey() + "' variant is defined"
+                            + " in " +localeAndStyle(locale, style));
+                }
+            }
+        }
+    }
+
+    /**
+     * After reading information from resource bundle into a Data object, there
+     * is guarantee that it is complete.
+     *
+     * This method fixes any incomplete data it finds within <code>result</code>.
+     * It looks at each log10 value applying the two rules.
+     *   <p>
+     *   If no prefix is defined for the "other" variant, use the divisor, prefixes and
+     *   suffixes for all defined variants from the previous log10. For log10 = 0,
+     *   use all empty prefixes and suffixes and a divisor of 1.
+     *   </p><p>
+     *   Otherwise, examine each plural variant defined for the given log10 value.
+     *   If it has no prefix and suffix for a particular variant, use the one from the
+     *   "other" variant.
+     *   </p>
+     *
+     * @param result this instance is fixed in-place.
+     */
+    private static void fillInMissing(Data result) {
+        // Initially we assume that previous divisor is 1 with no prefix or suffix.
+        long lastDivisor = 1L;
+        for (int i = 0; i < result.divisors.length; i++) {
+            if (result.units.get(OTHER)[i] == null) {
+                result.divisors[i] = lastDivisor;
+                copyFromPreviousIndex(i, result.units);
+            } else {
+                lastDivisor = result.divisors[i];
+                propagateOtherToMissing(i, result.units);
+            }
+        }
+    }
+
+    private static void propagateOtherToMissing(
+            int idx, Map<String, DecimalFormat.Unit[]> units) {
+        DecimalFormat.Unit otherVariantValue = units.get(OTHER)[idx];
+        for (DecimalFormat.Unit[] byBase : units.values()) {
+            if (byBase[idx] == null) {
+                byBase[idx] = otherVariantValue;
+            }
+        }
+    }
+
+    private static void copyFromPreviousIndex(int idx, Map<String, DecimalFormat.Unit[]> units) {
+        for (DecimalFormat.Unit[] byBase : units.values()) {
+            if (idx == 0) {
+                byBase[idx] = DecimalFormat.NULL_UNIT;
+            } else {
+                byBase[idx] = byBase[idx - 1];
+            }
+        }
+    }
+
+    private static boolean saveUnit(
+            DecimalFormat.Unit unit, String pluralVariant, int idx,
+            Map<String, DecimalFormat.Unit[]> units,
+            boolean overwrite) {
+        DecimalFormat.Unit[] byBase = units.get(pluralVariant);
+        if (byBase == null) {
+            byBase = new DecimalFormat.Unit[MAX_DIGITS];
+            units.put(pluralVariant, byBase);
+        }
+
+        // Don't overwrite a pre-existing value unless the "overwrite" flag is true.
+        if (!overwrite && byBase[idx] != null) {
+            return false;
+        }
+
+        // Save the value and return
+        byBase[idx] = unit;
+        return true;
+    }
+
+    /**
+     * Fetches a prefix or suffix given a plural variant and log10 value. If it
+     * can't find the given variant, it falls back to "other".
+     * @param prefixOrSuffix the prefix or suffix map
+     * @param variant the plural variant
+     * @param base log10 value. 0 <= base < MAX_DIGITS.
+     * @return the prefix or suffix.
+     */
+    static DecimalFormat.Unit getUnit(
+            Map<String, DecimalFormat.Unit[]> units, String variant, int base) {
+        DecimalFormat.Unit[] byBase = units.get(variant);
+        if (byBase == null) {
+            byBase = units.get(CompactDecimalDataCache.OTHER);
+        }
+        return byBase[base];
+    }
+}
diff --git a/app/src/main/java/com/ibm/icu/text/CompactDecimalFormat.java b/icu4j/src/main/java/com/ibm/icu/text/CompactDecimalFormat.java
similarity index 86%
rename from app/src/main/java/com/ibm/icu/text/CompactDecimalFormat.java
rename to icu4j/src/main/java/com/ibm/icu/text/CompactDecimalFormat.java
index 603ade8..078f10d 100644
--- a/app/src/main/java/com/ibm/icu/text/CompactDecimalFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CompactDecimalFormat.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, Google, International Business Machines Corporation and
@@ -22,6 +24,7 @@ import java.util.HashMap;
 import java.util.Locale;
 import java.util.Map;
 import java.util.Map.Entry;
+import java.util.regex.Pattern;
 
 import com.ibm.icu.text.CompactDecimalDataCache.Data;
 import com.ibm.icu.text.PluralRules.FixedDecimal;
@@ -47,7 +50,7 @@ import com.ibm.icu.util.ULocale;
  * "5,3 Mio. €" instead of "5.300.000,00 €" (German).  Localized data concerning longer formats is not available yet in
  * the Unicode CLDR. Because of this, attempting to format a currency amount using the "long" style will produce
  * an UnsupportedOperationException.
- * 
+ *
  * At this time, negative numbers and parsing are not supported, and will produce an UnsupportedOperationException.
  * Resetting the pattern prefixes or suffixes is not supported; the method calls are ignored.
  * <p>
@@ -134,7 +137,7 @@ public class CompactDecimalFormat extends DecimalFormat {
         this.currencyDivisor = currencyData.divisors;
         this.style = style;
         pluralToCurrencyAffixes = null;
-        
+
 //        DecimalFormat currencyFormat = (DecimalFormat) NumberFormat.getCurrencyInstance(locale);
 //        // TODO fix to use plural-dependent affixes
 //        Unit currency = new Unit(currencyFormat.getPositivePrefix(), currencyFormat.getPositiveSuffix());
@@ -143,7 +146,7 @@ public class CompactDecimalFormat extends DecimalFormat {
 //            pluralToCurrencyAffixes.put(key, currency);
 //        }
 //        // TODO fix to get right symbol for the count
-        
+
         finishInit(style, format.toPattern(), format.getDecimalFormatSymbols());
     }
 
@@ -165,7 +168,7 @@ public class CompactDecimalFormat extends DecimalFormat {
      * @param pluralAffixes
      *            A map from plural categories to affixes.
      * @param currencyAffixes
-     *            A map from plural categories to currency affixes. 
+     *            A map from plural categories to currency affixes.
      * @param debugCreationErrors
      *            A collection of strings for debugging. If null on input, then any errors found will be added to that
      *            collection instead of throwing exceptions.
@@ -173,11 +176,11 @@ public class CompactDecimalFormat extends DecimalFormat {
      * @deprecated This API is ICU internal only.
      */
     @Deprecated
-    public CompactDecimalFormat(String pattern, DecimalFormatSymbols formatSymbols, 
+    public CompactDecimalFormat(String pattern, DecimalFormatSymbols formatSymbols,
             CompactStyle style, PluralRules pluralRules,
-            long[] divisor, Map<String,String[][]> pluralAffixes, Map<String, String[]> currencyAffixes, 
+            long[] divisor, Map<String,String[][]> pluralAffixes, Map<String, String[]> currencyAffixes,
             Collection<String> debugCreationErrors) {
-        
+
         this.pluralRules = pluralRules;
         this.units = otherPluralVariant(pluralAffixes, divisor, debugCreationErrors);
         this.currencyUnits = otherPluralVariant(pluralAffixes, divisor, debugCreationErrors);
@@ -222,8 +225,8 @@ public class CompactDecimalFormat extends DecimalFormat {
         CompactDecimalFormat other = (CompactDecimalFormat) obj;
         return mapsAreEqual(units, other.units)
                 && Arrays.equals(divisor, other.divisor)
-                && (pluralToCurrencyAffixes == other.pluralToCurrencyAffixes 
-                || pluralToCurrencyAffixes != null && pluralToCurrencyAffixes.equals(other.pluralToCurrencyAffixes)) 
+                && (pluralToCurrencyAffixes == other.pluralToCurrencyAffixes
+                || pluralToCurrencyAffixes != null && pluralToCurrencyAffixes.equals(other.pluralToCurrencyAffixes))
                 && pluralRules.equals(other.pluralRules);
     }
 
@@ -332,35 +335,80 @@ public class CompactDecimalFormat extends DecimalFormat {
 
     /* INTERNALS */
     private StringBuffer format(double number, Currency curr, StringBuffer toAppendTo, FieldPosition pos) {
-        if (number < 0 ||
-            (curr != null && style == CompactStyle.LONG)) {
-            throw new UnsupportedOperationException();
+        if (curr != null && style == CompactStyle.LONG) {
+            throw new UnsupportedOperationException("CompactDecimalFormat does not support LONG style for currency.");
         }
+
+        // Compute the scaled amount, prefix, and suffix appropriate for the number's magnitude.
         Output<Unit> currencyUnit = new Output<Unit>();
         Amount amount = toAmount(number, curr, currencyUnit);
+        Unit unit = amount.getUnit();
+
+        // Note that currencyUnit is a remnant.  In almost all cases, it will be null.
+        StringBuffer prefix = new StringBuffer();
+        StringBuffer suffix = new StringBuffer();
         if (currencyUnit.value != null) {
-            currencyUnit.value.writePrefix(toAppendTo);
+            currencyUnit.value.writePrefix(prefix);
         }
-        Unit unit = amount.getUnit();
-        String originalPattern = this.toPattern();
-        StringBuffer newPattern = new StringBuffer();
-        unit.writePrefix(newPattern);
-        newPattern.append(this.toPattern());
-        unit.writeSuffix(newPattern);
-        applyPattern(newPattern.toString());
+        unit.writePrefix(prefix);
+        unit.writeSuffix(suffix);
+        if (currencyUnit.value != null) {
+            currencyUnit.value.writeSuffix(suffix);
+        }
+
         if (curr == null) {
+            // Prevent locking when not formatting a currency number.
+            toAppendTo.append(escape(prefix.toString()));
             super.format(amount.getQty(), toAppendTo, pos);
+            toAppendTo.append(escape(suffix.toString()));
+
         } else {
-            CurrencyAmount currAmt = new CurrencyAmount(amount.getQty(),curr);
-            super.format(currAmt, toAppendTo, pos);
-        }
-        applyPattern(originalPattern);
-        if (currencyUnit.value != null) {
-            currencyUnit.value.writeSuffix(toAppendTo);
+            // To perform the formatting, we set this DecimalFormat's pattern to have the correct prefix, suffix,
+            // and currency, and then reset it back to what it was before.
+            // This has to be synchronized since this information is held in the state of the DecimalFormat object.
+            synchronized(this) {
+
+                String originalPattern = this.toPattern();
+                Currency originalCurrency = this.getCurrency();
+                StringBuffer newPattern = new StringBuffer();
+
+                // Write prefixes and suffixes to the pattern.  Note that we have to apply it to both halves of a
+                // positive/negative format (separated by ';')
+                int semicolonPos = originalPattern.indexOf(';');
+                newPattern.append(prefix);
+                if (semicolonPos != -1) {
+                    newPattern.append(originalPattern, 0, semicolonPos);
+                    newPattern.append(suffix);
+                    newPattern.append(';');
+                    newPattern.append(prefix);
+                }
+                newPattern.append(originalPattern, semicolonPos + 1, originalPattern.length());
+                newPattern.append(suffix);
+
+                // Overwrite the pattern and currency.
+                setCurrency(curr);
+                applyPattern(newPattern.toString());
+
+                // Actually perform the formatting.
+                super.format(amount.getQty(), toAppendTo, pos);
+
+                // Reset the pattern and currency.
+                setCurrency(originalCurrency);
+                applyPattern(originalPattern);
+            }
         }
         return toAppendTo;
     }
 
+    private static final Pattern UNESCAPE_QUOTE = Pattern.compile("((?<!'))'");
+
+    private static String escape(String string) {
+        if (string.indexOf('\'') >= 0) {
+            return UNESCAPE_QUOTE.matcher(string).replaceAll("$1");
+        }
+        return string;
+    }
+
     private Amount toAmount(double number, Currency curr, Output<Unit> currencyUnit) {
         // We do this here so that the prefix or suffix we choose is always consistent
         // with the rounding we do. This way, 999999 -> 1M instead of 1000K.
@@ -399,7 +447,7 @@ public class CompactDecimalFormat extends DecimalFormat {
     /**
      * Manufacture the unit list from arrays
      */
-    private Map<String, DecimalFormat.Unit[]> otherPluralVariant(Map<String, String[][]> pluralCategoryToPower10ToAffix, 
+    private Map<String, DecimalFormat.Unit[]> otherPluralVariant(Map<String, String[][]> pluralCategoryToPower10ToAffix,
             long[] divisor, Collection<String> debugCreationErrors) {
 
         // check for bad divisors
@@ -429,7 +477,7 @@ public class CompactDecimalFormat extends DecimalFormat {
 
         Map<String, DecimalFormat.Unit[]> result = new HashMap<String, DecimalFormat.Unit[]>();
         Map<String,Integer> seen = new HashMap<String,Integer>();
-        
+
         String[][] defaultPower10ToAffix = pluralCategoryToPower10ToAffix.get("other");
 
         for (Entry<String, String[][]> pluralCategoryAndPower10ToAffix : pluralCategoryToPower10ToAffix.entrySet()) {
diff --git a/app/src/main/java/com/ibm/icu/text/ComposedCharIter.java b/icu4j/src/main/java/com/ibm/icu/text/ComposedCharIter.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/ComposedCharIter.java
rename to icu4j/src/main/java/com/ibm/icu/text/ComposedCharIter.java
index 64902e7..5d6e35e 100644
--- a/app/src/main/java/com/ibm/icu/text/ComposedCharIter.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/ComposedCharIter.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2014, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/CompoundTransliterator.java b/icu4j/src/main/java/com/ibm/icu/text/CompoundTransliterator.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/CompoundTransliterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/CompoundTransliterator.java
index 0b83f05..709e6a1 100644
--- a/app/src/main/java/com/ibm/icu/text/CompoundTransliterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CompoundTransliterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
@@ -115,7 +117,7 @@ class CompoundTransliterator extends Transliterator {
     /**
      * Internal method for safeClone...
      * @param id
-     * @param filter2 
+     * @param filter2
      * @param trans2
      * @param numAnonymousRBTs2
      */
@@ -124,7 +126,7 @@ class CompoundTransliterator extends Transliterator {
         trans = trans2;
         numAnonymousRBTs = numAnonymousRBTs2;
     }
-    
+
     /**
      * Finish constructing a transliterator: only to be called by
      * constructors.  Before calling init(), set trans and filter to NULL.
@@ -261,6 +263,7 @@ class CompoundTransliterator extends Transliterator {
      * U+000A, U+0020..U+007E.
      * @return the rule string
      */
+    @Override
     public String toRules(boolean escapeUnprintable) {
         // We do NOT call toRules() on our component transliterators, in
         // general.  If we have several rule-based transliterators, this
@@ -337,6 +340,7 @@ class CompoundTransliterator extends Transliterator {
     /**
      * Implements {@link Transliterator#handleTransliterate}.
      */
+    @Override
     protected void handleTransliterate(Replaceable text,
                                        Position index, boolean incremental) {
         /* Call each transliterator with the same start value and
diff --git a/app/src/main/java/com/ibm/icu/text/CurrencyDisplayNames.java b/icu4j/src/main/java/com/ibm/icu/text/CurrencyDisplayNames.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/CurrencyDisplayNames.java
rename to icu4j/src/main/java/com/ibm/icu/text/CurrencyDisplayNames.java
index 56bf5a9..0f9c594 100644
--- a/app/src/main/java/com/ibm/icu/text/CurrencyDisplayNames.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CurrencyDisplayNames.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2016, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/CurrencyFormat.java b/icu4j/src/main/java/com/ibm/icu/text/CurrencyFormat.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/text/CurrencyFormat.java
rename to icu4j/src/main/java/com/ibm/icu/text/CurrencyFormat.java
index fcf1b64..3142226 100644
--- a/app/src/main/java/com/ibm/icu/text/CurrencyFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CurrencyFormat.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 **********************************************************************
 * Copyright (c) 2004-2014, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/text/CurrencyMetaInfo.java b/icu4j/src/main/java/com/ibm/icu/text/CurrencyMetaInfo.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/text/CurrencyMetaInfo.java
rename to icu4j/src/main/java/com/ibm/icu/text/CurrencyMetaInfo.java
index c5ce2cc..439e9f9 100644
--- a/app/src/main/java/com/ibm/icu/text/CurrencyMetaInfo.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CurrencyMetaInfo.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2015, International Business Machines Corporation and    *
@@ -12,19 +14,20 @@ import java.util.Date;
 import java.util.List;
 
 import com.ibm.icu.impl.Grego;
+import com.ibm.icu.impl.Utility;
 import com.ibm.icu.util.Currency.CurrencyUsage;
 
 /**
  * Provides information about currencies that is not specific to a locale.
- * 
+ *
  * A note about currency dates.  The CLDR data provides data to the day,
  * inclusive.  The date information used by CurrencyInfo and CurrencyFilter
- * is represented by milliseconds, which is overly precise.  These times are 
+ * is represented by milliseconds, which is overly precise.  These times are
  * in GMT, so queries involving dates should use GMT times, but more generally
  * you should avoid relying on time of day in queries.
- * 
+ *
  * This class is not intended for public subclassing.
- * 
+ *
  * @stable ICU 4.4
  */
 public class CurrencyMetaInfo {
@@ -41,7 +44,7 @@ public class CurrencyMetaInfo {
     }
 
     /**
-     * Returns the unique instance of the currency meta info, or null if 
+     * Returns the unique instance of the currency meta info, or null if
      * noSubstitute is true and there is no data to support this API.
      * @param noSubstitute true if no substitute data should be used
      * @return the meta info, or null
@@ -99,7 +102,7 @@ public class CurrencyMetaInfo {
          * @stable ICU 4.4
          */
         public final long to;
-        
+
         /**
          * true if we are filtering only for currencies used as legal tender.
          * @internal
@@ -114,7 +117,7 @@ public class CurrencyMetaInfo {
             this.from = from;
             this.to = to;
             this.tenderOnly = tenderOnly;
-            
+
         }
 
         private static final CurrencyFilter ALL = new CurrencyFilter(
@@ -185,7 +188,7 @@ public class CurrencyMetaInfo {
         public static CurrencyFilter onDateRange(Date from, Date to) {
             return ALL.withDateRange(from, to);
         }
-        
+
         /**
          * Returns a filter that accepts all currencies in use on the given date.
          * @param date the date as milliseconds after Jan 1, 1970
@@ -208,7 +211,7 @@ public class CurrencyMetaInfo {
         public static CurrencyFilter onDateRange(long from, long to) {
             return ALL.withDateRange(from, to);
         }
-        
+
         /**
          * Returns a CurrencyFilter for finding currencies that were either once used,
          * are used, or will be used as tender.
@@ -266,7 +269,7 @@ public class CurrencyMetaInfo {
             long toLong = to == null ? Long.MAX_VALUE : to.getTime();
             return new CurrencyFilter(this.region, this.currency, fromLong, toLong, this.tenderOnly);
         }
-        
+
         /**
          * Returns a copy of this filter that accepts all currencies in use on
          * the given date.
@@ -290,7 +293,7 @@ public class CurrencyMetaInfo {
         public CurrencyFilter withDateRange(long from, long to) {
             return new CurrencyFilter(this.region, this.currency, from, to, this.tenderOnly);
         }
-        
+
         /**
          * Returns a copy of this filter that filters for currencies that were
          * either once used, are used, or will be used as tender.
@@ -317,7 +320,7 @@ public class CurrencyMetaInfo {
          * @stable ICU 4.4
          */
         public boolean equals(CurrencyFilter rhs) {
-            return this == rhs || (rhs != null &&
+          return Utility.sameObjects(this, rhs) || (rhs != null &&
                     equals(this.region, rhs.region) &&
                     equals(this.currency, rhs.currency) &&
                     this.from == rhs.from &&
@@ -357,7 +360,8 @@ public class CurrencyMetaInfo {
         }
 
         private static boolean equals(String lhs, String rhs) {
-            return lhs == rhs || (lhs != null && lhs.equals(rhs));
+            return (Utility.sameObjects(lhs, rhs) ||
+                    (lhs != null && lhs.equals(rhs)));
         }
     }
 
@@ -420,8 +424,8 @@ public class CurrencyMetaInfo {
         public final String code;
 
         /**
-         * Date on which the currency was first officially used in the region.  
-         * This is midnight at the start of the first day on which the currency was used, GMT. 
+         * Date on which the currency was first officially used in the region.
+         * This is midnight at the start of the first day on which the currency was used, GMT.
          * If there is no date, this is Long.MIN_VALUE;
          * @stable ICU 4.4
          */
@@ -431,7 +435,7 @@ public class CurrencyMetaInfo {
          * Date at which the currency stopped being officially used in the region.
          * This is one millisecond before midnight at the end of the last day on which the currency was used, GMT.
          * If there is no date, this is Long.MAX_VALUE.
-         * 
+         *
          * @stable ICU 4.4
          */
         public final long to;
@@ -443,8 +447,8 @@ public class CurrencyMetaInfo {
          * @stable ICU 49
          */
         public final int priority;
-        
-        
+
+
         private final boolean tender;
 
         /**
@@ -454,10 +458,10 @@ public class CurrencyMetaInfo {
         public CurrencyInfo(String region, String code, long from, long to, int priority) {
             this(region, code, from, to, priority, true);
         }
-        
+
         /**
          * Constructs a currency info.
-         * 
+         *
          * @internal
          * @deprecated This API is ICU internal only.
          */
@@ -480,7 +484,7 @@ public class CurrencyMetaInfo {
         public String toString() {
             return debugString(this);
         }
-        
+
         /**
          * Determine whether or not this currency was once used, is used,
          * or will be used as tender in this region.
diff --git a/app/src/main/java/com/ibm/icu/text/CurrencyPluralInfo.java b/icu4j/src/main/java/com/ibm/icu/text/CurrencyPluralInfo.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/CurrencyPluralInfo.java
rename to icu4j/src/main/java/com/ibm/icu/text/CurrencyPluralInfo.java
index fdebeb4..055fafe 100644
--- a/app/src/main/java/com/ibm/icu/text/CurrencyPluralInfo.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/CurrencyPluralInfo.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2014, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/DateFormat.java b/icu4j/src/main/java/com/ibm/icu/text/DateFormat.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/DateFormat.java
rename to icu4j/src/main/java/com/ibm/icu/text/DateFormat.java
index fd6666f..84452d3 100644
--- a/app/src/main/java/com/ibm/icu/text/DateFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/DateFormat.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *   Copyright (C) 1996-2016, International Business Machines
  *   Corporation and others.  All Rights Reserved.
@@ -480,9 +482,9 @@ public abstract class DateFormat extends UFormat {
     /**
      * {@icu} Number of FieldPosition selectors for DateFormat.
      * Valid selectors range from 0 to FIELD_COUNT-1.
-     * @stable ICU 3.0
+     * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
      */
-
+    @Deprecated
     public final static int FIELD_COUNT = 38;
     // A previous comment for the above stated that we must have
     // DateFormat.FIELD_COUNT == DateFormatSymbols.patternChars.length()
@@ -512,15 +514,13 @@ public abstract class DateFormat extends UFormat {
         /**
          * indicates tolerance of pattern mismatch between input data and specified format pattern.
          * e.g. accepting "September" for a month pattern of MMM ("Sep")
-         * @draft ICU 56
-         * @provisional This API might change or be removed in a future release.
+         * @stable ICU 56
          */
         PARSE_MULTIPLE_PATTERNS_FOR_MATCH,
         /**
          * indicates tolerance of a partial literal match
          * e.g. accepting "--mon-02-march-2011" for a pattern of "'--: 'EEE-WW-MMMM-yyyy"
-         * @draft ICU 56
-         * @provisional This API might change or be removed in a future release.
+         * @stable ICU 56
          */
         PARSE_PARTIAL_LITERAL_MATCH,
         /**
@@ -591,6 +591,7 @@ public abstract class DateFormat extends UFormat {
      * @see java.text.Format
      * @stable ICU 2.0
      */
+    @Override
     public final StringBuffer format(Object obj, StringBuffer toAppendTo,
                                      FieldPosition fieldPosition)
     {
@@ -825,6 +826,7 @@ public abstract class DateFormat extends UFormat {
      * @see #parse(String, ParsePosition)
      * @stable ICU 2.0
      */
+    @Override
     public Object parseObject (String source, ParsePosition pos)
     {
         return parse(source, pos);
@@ -1747,6 +1749,7 @@ public abstract class DateFormat extends UFormat {
      */
     ///CLOVER:OFF
     // turn off code coverage since all subclasses override this
+    @Override
     public int hashCode() {
         return numberFormat.hashCode();
         // just enough fields for a reasonable distribution
@@ -1757,6 +1760,7 @@ public abstract class DateFormat extends UFormat {
      * Overrides equals.
      * @stable ICU 2.0
      */
+    @Override
     public boolean equals(Object obj) {
         if (this == obj) return true;
         if (obj == null || getClass() != obj.getClass()) return false;
@@ -1772,6 +1776,7 @@ public abstract class DateFormat extends UFormat {
      * Overrides clone.
      * @stable ICU 2.0
      */
+    @Override
     public Object clone()
     {
         DateFormat other = (DateFormat) super.clone();
@@ -2543,6 +2548,7 @@ public abstract class DateFormat extends UFormat {
          *
          * @stable ICU 3.8
          */
+        @Override
         protected Object readResolve() throws InvalidObjectException {
             ///CLOVER:OFF
             if (this.getClass() != DateFormat.Field.class) {
diff --git a/app/src/main/java/com/ibm/icu/text/DateFormatSymbols.java b/icu4j/src/main/java/com/ibm/icu/text/DateFormatSymbols.java
similarity index 79%
rename from app/src/main/java/com/ibm/icu/text/DateFormatSymbols.java
rename to icu4j/src/main/java/com/ibm/icu/text/DateFormatSymbols.java
index c394b28..f502153 100644
--- a/app/src/main/java/com/ibm/icu/text/DateFormatSymbols.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/DateFormatSymbols.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and
@@ -10,21 +12,28 @@ package com.ibm.icu.text;
 import java.io.IOException;
 import java.io.ObjectInputStream;
 import java.io.Serializable;
+import java.util.ArrayList;
 import java.util.HashMap;
+import java.util.HashSet;
+import java.util.List;
 import java.util.Locale;
 import java.util.Map;
 import java.util.MissingResourceException;
 import java.util.ResourceBundle;
+import java.util.Set;
+import java.util.TreeMap;
 
-import com.ibm.icu.impl.CalendarData;
+import com.ibm.icu.impl.CacheBase;
 import com.ibm.icu.impl.CalendarUtil;
-import com.ibm.icu.impl.ICUCache;
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
-import com.ibm.icu.impl.SimpleCache;
+import com.ibm.icu.impl.SoftCache;
+import com.ibm.icu.impl.UResource;
 import com.ibm.icu.impl.Utility;
 import com.ibm.icu.text.TimeZoneNames.NameType;
 import com.ibm.icu.util.Calendar;
 import com.ibm.icu.util.ICUCloneNotSupportedException;
+import com.ibm.icu.util.ICUException;
 import com.ibm.icu.util.TimeZone;
 import com.ibm.icu.util.ULocale;
 import com.ibm.icu.util.ULocale.Category;
@@ -1413,6 +1422,7 @@ public class DateFormatSymbols implements Serializable, Cloneable {
      * Overrides clone.
      * @stable ICU 2.0
      */
+    @Override
     public Object clone()
     {
         try {
@@ -1430,6 +1440,7 @@ public class DateFormatSymbols implements Serializable, Cloneable {
      * Generates a hash code for the DateFormatSymbols object.
      * @stable ICU 2.0
      */
+    @Override
     public int hashCode() {
         // Is this sufficient?
         return requestedLocale.toString().hashCode();
@@ -1439,6 +1450,7 @@ public class DateFormatSymbols implements Serializable, Cloneable {
      * Overrides equals.
      * @stable ICU 2.0
      */
+    @Override
     public boolean equals(Object obj)
     {
         if (this == obj) return true;
@@ -1486,8 +1498,23 @@ public class DateFormatSymbols implements Serializable, Cloneable {
     static final int millisPerHour = 60*60*1000;
 
     // DateFormatSymbols cache
-    private static ICUCache<String, DateFormatSymbols> DFSCACHE =
-        new SimpleCache<String, DateFormatSymbols>();
+    private static CacheBase<String, DateFormatSymbols, ULocale> DFSCACHE =
+        new SoftCache<String, DateFormatSymbols, ULocale>() {
+            @Override
+            protected DateFormatSymbols createInstance(String key, ULocale locale) {
+                // Extract the type string from the key.
+                // Otherwise we would have to create a pair object that
+                // carries both the locale and the type.
+                int typeStart = key.indexOf('+') + 1;
+                int typeLimit = key.indexOf('+', typeStart);
+                if (typeLimit < 0) {
+                    // no numbers keyword value
+                    typeLimit = key.length();
+                }
+                String type = key.substring(typeStart, typeLimit);
+                return new DateFormatSymbols(locale, null, type);
+            }
+        };
 
     /**
      * Initializes format symbols for the locale and calendar type
@@ -1499,24 +1526,13 @@ public class DateFormatSymbols implements Serializable, Cloneable {
     // We may need to deescalate this API to @internal.
     protected void initializeData(ULocale desiredLocale, String type)
     {
-        String key = desiredLocale.getBaseName() + "+" + type;
+        String key = desiredLocale.getBaseName() + '+' + type;
         String ns = desiredLocale.getKeywordValue("numbers");
         if (ns != null && ns.length() > 0) {
-            key += "+" + ns;
-        }
-        DateFormatSymbols dfs = DFSCACHE.get(key);
-        if (dfs == null) {
-            // Initialize data from scratch put a clone of this instance into the cache
-            CalendarData calData = new CalendarData(desiredLocale, type);
-            initializeData(desiredLocale, calData);
-            // Do not cache subclass instances
-            if (this.getClass().getName().equals("com.ibm.icu.text.DateFormatSymbols")) {
-                dfs = (DateFormatSymbols)this.clone();
-                DFSCACHE.put(key, dfs);
-            }
-        } else {
-            initializeData(dfs);
+            key += '+' + ns;
         }
+        DateFormatSymbols dfs = DFSCACHE.getInstance(key, desiredLocale);
+        initializeData(dfs);
     }
 
     /**
@@ -1569,59 +1585,350 @@ public class DateFormatSymbols implements Serializable, Cloneable {
         this.requestedLocale = dfs.requestedLocale;
     }
 
+
+    /**
+     * Sink to enumerate the calendar data
+     */
+    private static final class CalendarDataSink extends UResource.Sink {
+
+        // Data structures to store resources from the resource bundle
+        Map<String, String[]> arrays = new TreeMap<String, String[]>();
+        Map<String, Map<String, String>> maps = new TreeMap<String, Map<String, String>>();
+        List<String> aliasPathPairs = new ArrayList<String>();
+
+        // Current and next calendar resource table which should be loaded
+        String currentCalendarType = null;
+        String nextCalendarType = null;
+
+        // Resources to visit when enumerating fallback calendars
+        private Set<String> resourcesToVisit;
+
+        // Alias' relative path populated when an alias is read
+        private String aliasRelativePath;
+
+        /**
+         * Initializes CalendarDataSink with default values
+         */
+        CalendarDataSink() { }
+
+        /**
+         * Configure the CalendarSink to visit all the resources
+         */
+        void visitAllResources() {
+            resourcesToVisit = null;
+        }
+
+        /**
+         * Actions to be done before enumerating
+         */
+        void preEnumerate(String calendarType) {
+            currentCalendarType = calendarType;
+            nextCalendarType = null;
+            aliasPathPairs.clear();
+        }
+
+        @Override
+        public void put(UResource.Key key, UResource.Value value, boolean noFallback) {
+            assert currentCalendarType != null && !currentCalendarType.isEmpty();
+
+            // Stores the resources to visit on the next calendar.
+            Set<String> resourcesToVisitNext = null;
+            UResource.Table calendarData = value.getTable();
+
+            // Enumerate all resources for this calendar
+            for (int i = 0; calendarData.getKeyAndValue(i, key, value); i++) {
+                String keyString = key.toString();
+
+                // == Handle aliases ==
+                AliasType aliasType = processAliasFromValue(keyString, value);
+                if (aliasType == AliasType.GREGORIAN) {
+                    // Ignore aliases to the gregorian calendar, all of its resources will be loaded anyways.
+                    continue;
+
+                } else if (aliasType == AliasType.DIFFERENT_CALENDAR) {
+                    // Whenever an alias to the next calendar (except gregorian) is encountered, register the
+                    // calendar type it's pointing to
+                    if (resourcesToVisitNext == null) {
+                        resourcesToVisitNext = new HashSet<String>();
+                    }
+                    resourcesToVisitNext.add(aliasRelativePath);
+                    continue;
+
+                } else if (aliasType == AliasType.SAME_CALENDAR) {
+                    // Register same-calendar alias
+                    if (!arrays.containsKey(keyString) && !maps.containsKey(keyString)) {
+                        aliasPathPairs.add(aliasRelativePath);
+                        aliasPathPairs.add(keyString);
+                    }
+                    continue;
+                }
+
+                // Only visit the resources that were referenced by an alias on the previous calendar
+                // (AmPmMarkersAbbr is an exception).
+                if (resourcesToVisit != null && !resourcesToVisit.isEmpty() && !resourcesToVisit.contains(keyString)
+                        && !keyString.equals("AmPmMarkersAbbr")) { continue; }
+
+                // == Handle data ==
+                if (keyString.startsWith("AmPmMarkers")) {
+                    if (!keyString.endsWith("%variant") && !arrays.containsKey(keyString)) {
+                        String[] dataArray = value.getStringArray();
+                        arrays.put(keyString, dataArray);
+                    }
+                } else if (keyString.equals("eras")
+                        || keyString.equals("dayNames")
+                        || keyString.equals("monthNames")
+                        || keyString.equals("quarters")
+                        || keyString.equals("dayPeriod")
+                        || keyString.equals("monthPatterns")
+                        || keyString.equals("cyclicNameSets")) {
+                    processResource(keyString, key, value);
+                }
+            }
+
+            // Apply same-calendar aliases
+            boolean modified;
+            do {
+                modified = false;
+                for (int i = 0; i < aliasPathPairs.size();) {
+                    boolean mod = false;
+                    String alias = aliasPathPairs.get(i);
+                    if (arrays.containsKey(alias)) {
+                        arrays.put(aliasPathPairs.get(i + 1), arrays.get(alias));
+                        mod = true;
+                    } else if (maps.containsKey(alias)) {
+                        maps.put(aliasPathPairs.get(i + 1), maps.get(alias));
+                        mod = true;
+                    }
+                    if (mod) {
+                        aliasPathPairs.remove(i + 1);
+                        aliasPathPairs.remove(i);
+                        modified = true;
+                    } else {
+                        i += 2;
+                    }
+                }
+            } while (modified && !aliasPathPairs.isEmpty());
+
+            // Set the resources to visit on the next calendar
+            if (resourcesToVisitNext != null) {
+                resourcesToVisit = resourcesToVisitNext;
+            }
+        }
+
+        /**
+         * Process the nested resource bundle tables
+         * @param path Table's relative path to the calendar
+         * @param key Resource bundle key
+         * @param value Resource bundle value (has to have the table to read)
+         */
+        protected void processResource(String path, UResource.Key key, UResource.Value value) {
+
+            UResource.Table table = value.getTable();
+            Map<String, String> stringMap = null;
+
+            // Iterate over all the elements of the table and add them to the map
+            for(int i = 0; table.getKeyAndValue(i, key, value); i++) {
+                // Ignore '%variant' keys
+                if (key.endsWith("%variant")) { continue; }
+
+                String keyString = key.toString();
+
+                // == Handle String elements ==
+                if (value.getType() == ICUResourceBundle.STRING) {
+                    // We are on a leaf, store the map elements into the stringMap
+                    if (i == 0) {
+                        stringMap = new HashMap<String, String>();
+                        maps.put(path, stringMap);
+                    }
+                    assert stringMap != null;
+                    stringMap.put(keyString, value.getString());
+                    continue;
+                }
+                assert stringMap == null;
+
+                String currentPath = path + "/" + keyString;
+                // In cyclicNameSets ignore everything but years/format/abbreviated
+                // and zodiacs/format/abbreviated
+                if (currentPath.startsWith("cyclicNameSets")) {
+                    if (!"cyclicNameSets/years/format/abbreviated".startsWith(currentPath)
+                            && !"cyclicNameSets/zodiacs/format/abbreviated".startsWith(currentPath)
+                            && !"cyclicNameSets/dayParts/format/abbreviated".startsWith(currentPath))
+                    { continue; }
+                }
+
+                // == Handle aliases ==
+                if (arrays.containsKey(currentPath)
+                        || maps.containsKey(currentPath)) { continue; }
+
+                AliasType aliasType = processAliasFromValue(currentPath, value);
+                if (aliasType == AliasType.SAME_CALENDAR) {
+                    aliasPathPairs.add(aliasRelativePath);
+                    aliasPathPairs.add(currentPath);
+                    continue;
+                }
+                assert aliasType == AliasType.NONE;
+
+                // == Handle data ==
+                if (value.getType() == ICUResourceBundle.ARRAY) {
+                    // We are on a leaf, store the array
+                    String[] dataArray = value.getStringArray();
+                    arrays.put(currentPath, dataArray);
+                } else if (value.getType() == ICUResourceBundle.TABLE) {
+                    // We are not on a leaf, recursively process the subtable.
+                    processResource(currentPath, key, value);
+                }
+            }
+        }
+
+        // Alias' path prefix
+        private static final String CALENDAR_ALIAS_PREFIX = "/LOCALE/calendar/";
+
+        /**
+         * Populates an AliasIdentifier with the alias information contained on the UResource.Value.
+         * @param currentRelativePath Relative path of this alias' resource
+         * @param value Value which contains the alias
+         * @return The AliasType of the alias found on Value
+         */
+        private AliasType processAliasFromValue(String currentRelativePath, UResource.Value value) {
+            if (value.getType() == ICUResourceBundle.ALIAS) {
+                String aliasPath = value.getAliasString();
+                if (aliasPath.startsWith(CALENDAR_ALIAS_PREFIX) &&
+                        aliasPath.length() > CALENDAR_ALIAS_PREFIX.length()) {
+                    int typeLimit = aliasPath.indexOf('/', CALENDAR_ALIAS_PREFIX.length());
+                    if (typeLimit > CALENDAR_ALIAS_PREFIX.length()) {
+                        String aliasCalendarType = aliasPath.substring(CALENDAR_ALIAS_PREFIX.length(), typeLimit);
+                        aliasRelativePath = aliasPath.substring(typeLimit + 1);
+
+                        if (currentCalendarType.equals(aliasCalendarType)
+                                && !currentRelativePath.equals(aliasRelativePath)) {
+                            // If we have an alias to the same calendar, the path to the resource must be different
+                            return AliasType.SAME_CALENDAR;
+
+                        } else if (!currentCalendarType.equals(aliasCalendarType)
+                                && currentRelativePath.equals(aliasRelativePath)) {
+                            // If we have an alias to a different calendar, the path to the resource must be the same
+                            if (aliasCalendarType.equals("gregorian")) {
+                                return AliasType.GREGORIAN;
+                            } else if (nextCalendarType == null || nextCalendarType.equals(aliasCalendarType)) {
+                                nextCalendarType = aliasCalendarType;
+                                return AliasType.DIFFERENT_CALENDAR;
+                            }
+                        }
+                    }
+                }
+                throw new ICUException("Malformed 'calendar' alias. Path: " + aliasPath);
+            }
+            return AliasType.NONE;
+        }
+
+        /**
+         * Enum which specifies the type of alias received, or no alias
+         */
+        private enum AliasType {
+            SAME_CALENDAR,
+            DIFFERENT_CALENDAR,
+            GREGORIAN,
+            NONE
+        }
+    }
+
+    /** Private, for cache.getInstance(). */
+    private DateFormatSymbols(ULocale desiredLocale, ICUResourceBundle b, String calendarType) {
+        initializeData(desiredLocale, b, calendarType);
+    }
+
     /**
      * Initializes format symbols for the locale and calendar type
      * @param desiredLocale The locale whose symbols are desired.
-     * @param calData       The calendar resource data
+     * @param b Resource bundle provided externally
+     * @param calendarType  The calendar type being used
      * @internal
      * @deprecated This API is ICU internal only.
      */
     @Deprecated
     // This API was accidentally marked as @stable ICU 3.0 formerly.
-    protected void initializeData(ULocale desiredLocale, CalendarData calData)
+    protected void initializeData(ULocale desiredLocale, ICUResourceBundle b, String calendarType)
     {
-        // FIXME: cache only ResourceBundle. Hence every time, will do
-        // getObject(). This won't be necessary if the Resource itself
-        // is cached.
-        eras = calData.getEras("abbreviated");
+        // Create a CalendarSink to load this data and a resource bundle
+        CalendarDataSink calendarSink = new CalendarDataSink();
+        if (b == null) {
+            b = (ICUResourceBundle) UResourceBundle
+                    .getBundleInstance(ICUData.ICU_BASE_NAME, desiredLocale);
+        }
+
+        // Iterate over the resource bundle data following the fallbacks through different calendar types
+        while (calendarType != null) {
+
+            // Enumerate this calendar type. If the calendar is not found fallback to gregorian.
+            ICUResourceBundle dataForType = b.findWithFallback("calendar/" + calendarType);
+            if (dataForType == null) {
+                if (!"gregorian".equals(calendarType)) {
+                    calendarType = "gregorian";
+                    calendarSink.visitAllResources();
+                    continue;
+                }
+                throw new MissingResourceException("The 'gregorian' calendar type wasn't found for the locale: "
+                        + desiredLocale.getBaseName(), getClass().getName(), "gregorian");
+            }
+            calendarSink.preEnumerate(calendarType);
+            dataForType.getAllItemsWithFallback("", calendarSink);
+
+            // Stop loading when gregorian was loaded
+            if (calendarType.equals("gregorian")) {
+                break;
+            }
+
+            // Get the next calendar type to process from the sink
+            calendarType = calendarSink.nextCalendarType;
+
+            // Gregorian is always the last fallback
+            if (calendarType == null) {
+                calendarType = "gregorian";
+                calendarSink.visitAllResources();
+            }
+        }
 
-        eraNames = calData.getEras("wide");
+        Map<String, String[]> arrays = calendarSink.arrays;
+        Map<String, Map<String, String>> maps = calendarSink.maps;
 
-        narrowEras = calData.getEras("narrow");
+        eras = arrays.get("eras/abbreviated");
+        eraNames = arrays.get("eras/wide");
+        narrowEras = arrays.get("eras/narrow");
 
-        months = calData.getStringArray("monthNames", "wide");
-        shortMonths = calData.getStringArray("monthNames", "abbreviated");
-        narrowMonths = calData.getStringArray("monthNames", "narrow");
+        months = arrays.get("monthNames/format/wide");
+        shortMonths = arrays.get("monthNames/format/abbreviated");
+        narrowMonths = arrays.get("monthNames/format/narrow");
 
-        standaloneMonths = calData.getStringArray("monthNames", "stand-alone", "wide");
-        standaloneShortMonths = calData.getStringArray("monthNames", "stand-alone", "abbreviated");
-        standaloneNarrowMonths = calData.getStringArray("monthNames", "stand-alone", "narrow");
+        standaloneMonths = arrays.get("monthNames/stand-alone/wide");
+        standaloneShortMonths = arrays.get("monthNames/stand-alone/abbreviated");
+        standaloneNarrowMonths = arrays.get("monthNames/stand-alone/narrow");
 
-        String[] lWeekdays = calData.getStringArray("dayNames", "wide");
+        String[] lWeekdays = arrays.get("dayNames/format/wide");
         weekdays = new String[8];
         weekdays[0] = "";  // 1-based
         System.arraycopy(lWeekdays, 0, weekdays, 1, lWeekdays.length);
 
-        String[] aWeekdays = calData.getStringArray("dayNames", "abbreviated");
+        String[] aWeekdays = arrays.get("dayNames/format/abbreviated");
         shortWeekdays = new String[8];
         shortWeekdays[0] = "";  // 1-based
         System.arraycopy(aWeekdays, 0, shortWeekdays, 1, aWeekdays.length);
 
-        String[] sWeekdays = calData.getStringArray("dayNames", "short");
+        String[] sWeekdays = arrays.get("dayNames/format/short");
         shorterWeekdays = new String[8];
         shorterWeekdays[0] = "";  // 1-based
         System.arraycopy(sWeekdays, 0, shorterWeekdays, 1, sWeekdays.length);
 
-        String [] nWeekdays = null;
-        try {
-           nWeekdays = calData.getStringArray("dayNames", "narrow");
-        }
-        catch (MissingResourceException e) {
-            try {
-                nWeekdays = calData.getStringArray("dayNames", "stand-alone", "narrow");
-            }
-            catch (MissingResourceException e1) {
-                nWeekdays = calData.getStringArray("dayNames", "abbreviated");
+        String [] nWeekdays = arrays.get("dayNames/format/narrow");
+        if (nWeekdays == null) {
+            nWeekdays = arrays.get("dayNames/stand-alone/narrow");
+
+            if (nWeekdays == null) {
+                nWeekdays = arrays.get("dayNames/format/abbreviated");
+
+                if (nWeekdays == null) {
+                    throw new MissingResourceException("Resource not found",
+                            getClass().getName(), "dayNames/format/abbreviated");
+                }
             }
         }
         narrowWeekdays = new String[8];
@@ -1629,88 +1936,70 @@ public class DateFormatSymbols implements Serializable, Cloneable {
         System.arraycopy(nWeekdays, 0, narrowWeekdays, 1, nWeekdays.length);
 
         String [] swWeekdays = null;
-        swWeekdays = calData.getStringArray("dayNames", "stand-alone", "wide");
+        swWeekdays = arrays.get("dayNames/stand-alone/wide");
         standaloneWeekdays = new String[8];
         standaloneWeekdays[0] = "";  // 1-based
         System.arraycopy(swWeekdays, 0, standaloneWeekdays, 1, swWeekdays.length);
 
         String [] saWeekdays = null;
-        saWeekdays = calData.getStringArray("dayNames", "stand-alone", "abbreviated");
+        saWeekdays = arrays.get("dayNames/stand-alone/abbreviated");
         standaloneShortWeekdays = new String[8];
         standaloneShortWeekdays[0] = "";  // 1-based
         System.arraycopy(saWeekdays, 0, standaloneShortWeekdays, 1, saWeekdays.length);
 
         String [] ssWeekdays = null;
-        ssWeekdays = calData.getStringArray("dayNames", "stand-alone", "short");
+        ssWeekdays = arrays.get("dayNames/stand-alone/short");
         standaloneShorterWeekdays = new String[8];
         standaloneShorterWeekdays[0] = "";  // 1-based
         System.arraycopy(ssWeekdays, 0, standaloneShorterWeekdays, 1, ssWeekdays.length);
 
         String [] snWeekdays = null;
-        snWeekdays = calData.getStringArray("dayNames", "stand-alone", "narrow");
+        snWeekdays = arrays.get("dayNames/stand-alone/narrow");
         standaloneNarrowWeekdays = new String[8];
         standaloneNarrowWeekdays[0] = "";  // 1-based
         System.arraycopy(snWeekdays, 0, standaloneNarrowWeekdays, 1, snWeekdays.length);
 
-        ampms = calData.getStringArray("AmPmMarkers");
-        ampmsNarrow = calData.getStringArray("AmPmMarkersNarrow");
-
-        quarters = calData.getStringArray("quarters", "wide");
-        shortQuarters = calData.getStringArray("quarters", "abbreviated");
-
-        standaloneQuarters = calData.getStringArray("quarters", "stand-alone", "wide");
-        standaloneShortQuarters = calData.getStringArray("quarters", "stand-alone", "abbreviated");
-
-        abbreviatedDayPeriods = loadDayPeriodStrings(calData, false, "abbreviated");
-        wideDayPeriods = loadDayPeriodStrings(calData, false, "wide");
-        narrowDayPeriods = loadDayPeriodStrings(calData, false, "narrow");
-        standaloneAbbreviatedDayPeriods = loadDayPeriodStrings(calData, true, "abbreviated");
-        standaloneWideDayPeriods = loadDayPeriodStrings(calData, true, "wide");
-        standaloneNarrowDayPeriods = loadDayPeriodStrings(calData, true, "narrow");
-
-        // The code for getting individual symbols in the leapMonthSymbols array is here
-        // rather than in CalendarData because it depends on DateFormatSymbols constants...
-        ICUResourceBundle monthPatternsBundle = null;
-        try {
-           monthPatternsBundle = calData.get("monthPatterns");
-        }
-        catch (MissingResourceException e) {
-            monthPatternsBundle = null; // probably redundant
-        }
-        if (monthPatternsBundle != null) {
-            leapMonthPatterns = new String[DT_MONTH_PATTERN_COUNT];
-            leapMonthPatterns[DT_LEAP_MONTH_PATTERN_FORMAT_WIDE] = calData.get("monthPatterns", "wide").get("leap").getString();
-            leapMonthPatterns[DT_LEAP_MONTH_PATTERN_FORMAT_ABBREV] = calData.get("monthPatterns", "abbreviated").get("leap").getString();
-            leapMonthPatterns[DT_LEAP_MONTH_PATTERN_FORMAT_NARROW] = calData.get("monthPatterns", "narrow").get("leap").getString();
-            leapMonthPatterns[DT_LEAP_MONTH_PATTERN_STANDALONE_WIDE] = calData.get("monthPatterns", "stand-alone", "wide").get("leap").getString();
-            leapMonthPatterns[DT_LEAP_MONTH_PATTERN_STANDALONE_ABBREV] = calData.get("monthPatterns", "stand-alone", "abbreviated").get("leap").getString();
-            leapMonthPatterns[DT_LEAP_MONTH_PATTERN_STANDALONE_NARROW] = calData.get("monthPatterns", "stand-alone", "narrow").get("leap").getString();
-            leapMonthPatterns[DT_LEAP_MONTH_PATTERN_NUMERIC] = calData.get("monthPatterns", "numeric", "all").get("leap").getString();
+        ampms = arrays.get("AmPmMarkers");
+        ampmsNarrow = arrays.get("AmPmMarkersNarrow");
+
+        quarters = arrays.get("quarters/format/wide");
+        shortQuarters = arrays.get("quarters/format/abbreviated");
+
+        standaloneQuarters = arrays.get("quarters/stand-alone/wide");
+        standaloneShortQuarters = arrays.get("quarters/stand-alone/abbreviated");
+
+        abbreviatedDayPeriods = loadDayPeriodStrings(maps.get("dayPeriod/format/abbreviated"));
+        wideDayPeriods = loadDayPeriodStrings(maps.get("dayPeriod/format/wide"));
+        narrowDayPeriods = loadDayPeriodStrings(maps.get("dayPeriod/format/narrow"));
+        standaloneAbbreviatedDayPeriods = loadDayPeriodStrings(maps.get("dayPeriod/stand-alone/abbreviated"));
+        standaloneWideDayPeriods = loadDayPeriodStrings(maps.get("dayPeriod/stand-alone/wide"));
+        standaloneNarrowDayPeriods = loadDayPeriodStrings(maps.get("dayPeriod/stand-alone/narrow"));
+
+        for (int i = 0; i < DT_MONTH_PATTERN_COUNT; i++) {
+            String monthPatternPath = LEAP_MONTH_PATTERNS_PATHS[i];
+            if (monthPatternPath != null) {
+                Map<String, String> monthPatternMap = maps.get(monthPatternPath);
+                if (monthPatternMap != null) {
+                    String leapMonthPattern = monthPatternMap.get("leap");
+                    if (leapMonthPattern != null) {
+                        if (leapMonthPatterns == null) {
+                            leapMonthPatterns = new String[DT_MONTH_PATTERN_COUNT];
+                        }
+                        leapMonthPatterns[i] = leapMonthPattern;
+                    }
+                }
+            }
         }
 
-        ICUResourceBundle cyclicNameSetsBundle = null;
-        try {
-           cyclicNameSetsBundle = calData.get("cyclicNameSets");
-        }
-        catch (MissingResourceException e) {
-            cyclicNameSetsBundle = null; // probably redundant
-        }
-        if (cyclicNameSetsBundle != null) {
-            shortYearNames = calData.get("cyclicNameSets", "years", "format", "abbreviated").getStringArray();
-            shortZodiacNames = calData.get("cyclicNameSets", "zodiacs", "format", "abbreviated").getStringArray();
-        }
+        shortYearNames = arrays.get("cyclicNameSets/years/format/abbreviated");
+        shortZodiacNames = arrays.get("cyclicNameSets/zodiacs/format/abbreviated");
 
         requestedLocale = desiredLocale;
 
         ICUResourceBundle rb =
             (ICUResourceBundle)UResourceBundle.getBundleInstance(
-                ICUResourceBundle.ICU_BASE_NAME, desiredLocale);
-
-        // Because localized date/time pattern characters will be obsolete in CLDR,
-        // we decided not to maintain localized pattern characters in ICU any more.
-        // We always use the base pattern characters by default. (ticket#5597)
+                ICUData.ICU_BASE_NAME, desiredLocale);
 
-        //localPatternChars = rb.getString("localPatternChars");
         localPatternChars = patternChars;
 
         // TODO: obtain correct actual/valid locale later
@@ -1727,7 +2016,7 @@ public class DateFormatSymbols implements Serializable, Cloneable {
         }
         UResourceBundle contextTransformsBundle = null;
         try {
-           contextTransformsBundle = (UResourceBundle)rb.getWithFallback("contextTransforms");
+           contextTransformsBundle = rb.getWithFallback("contextTransforms");
         }
         catch (MissingResourceException e) {
             contextTransformsBundle = null; // probably redundant
@@ -1760,6 +2049,20 @@ public class DateFormatSymbols implements Serializable, Cloneable {
         }
     }
 
+    /**
+     * Resource bundle paths for each leap month pattern
+     */
+    private static final String[] LEAP_MONTH_PATTERNS_PATHS = new String[DT_MONTH_PATTERN_COUNT];
+    static {
+        LEAP_MONTH_PATTERNS_PATHS[DT_LEAP_MONTH_PATTERN_FORMAT_WIDE] = "monthPatterns/format/wide";
+        LEAP_MONTH_PATTERNS_PATHS[DT_LEAP_MONTH_PATTERN_FORMAT_ABBREV] = "monthPatterns/format/abbreviated";
+        LEAP_MONTH_PATTERNS_PATHS[DT_LEAP_MONTH_PATTERN_FORMAT_NARROW] = "monthPatterns/format/narrow";
+        LEAP_MONTH_PATTERNS_PATHS[DT_LEAP_MONTH_PATTERN_STANDALONE_WIDE] = "monthPatterns/stand-alone/wide";
+        LEAP_MONTH_PATTERNS_PATHS[DT_LEAP_MONTH_PATTERN_STANDALONE_ABBREV] = "monthPatterns/stand-alone/abbreviated";
+        LEAP_MONTH_PATTERNS_PATHS[DT_LEAP_MONTH_PATTERN_STANDALONE_NARROW] = "monthPatterns/stand-alone/narrow";
+        LEAP_MONTH_PATTERNS_PATHS[DT_LEAP_MONTH_PATTERN_NUMERIC] = "monthPatterns/numeric/all";
+    }
+
     private static final boolean arrayOfArrayEquals(Object[][] aa1, Object[][]aa2) {
         if (aa1 == aa2) { // both are null
             return true;
@@ -1781,32 +2084,23 @@ public class DateFormatSymbols implements Serializable, Cloneable {
     }
 
     /**
-     * Loads localized names for day periods in the requested format.
-     * @param calData where the strings come from
-     * @param standalone whether the standalone version is requested
-     * @param width "abbreviated", "wide", or "narrow".
+     * Keys for dayPeriods
      */
-    private String[] loadDayPeriodStrings(CalendarData calData, boolean standalone, String width) {
-        String[] dayPeriodKeys = {"midnight", "noon",
-                "morning1", "afternoon1", "evening1", "night1",
-                "morning2", "afternoon2", "evening2", "night2"};
+    private static final String[] DAY_PERIOD_KEYS = {"midnight", "noon",
+            "morning1", "afternoon1", "evening1", "night1",
+            "morning2", "afternoon2", "evening2", "night2"};
 
-        ICUResourceBundle b;
-        String strings[] = new String[10];
-        try {
-            if (standalone) {
-                b = calData.get("dayPeriod", "standalone", width);
-            } else {
-                b = calData.get("dayPeriod", "format", width);
+    /**
+     * Loads localized names for day periods in the requested format.
+     * @param resourceMap Contains the dayPeriod resource to load
+     */
+    private String[] loadDayPeriodStrings(Map<String, String> resourceMap) {
+        String strings[] = new String[DAY_PERIOD_KEYS.length];
+        if (resourceMap != null) {
+            for (int i = 0; i < DAY_PERIOD_KEYS.length; ++i) {
+                strings[i] = resourceMap.get(DAY_PERIOD_KEYS[i]);  // Null if string doesn't exist.
             }
-        } catch (MissingResourceException e) {
-            return strings;  // Array of null's.
         }
-
-        for (int i = 0; i < 10; ++i) {
-            strings[i] = b.findStringWithFallback(dayPeriodKeys[i]);  // Null if string doesn't exist.
-        }
-
         return strings;
     }
 
@@ -2031,8 +2325,7 @@ public class DateFormatSymbols implements Serializable, Cloneable {
      * @stable ICU 3.2
      */
     public DateFormatSymbols(ResourceBundle bundle, ULocale locale) {
-        initializeData(locale,
-            new CalendarData((ICUResourceBundle)bundle, CalendarUtil.getCalendarType(locale)));
+        initializeData(locale, (ICUResourceBundle) bundle, CalendarUtil.getCalendarType(locale));
     }
 
     /**
diff --git a/app/src/main/java/com/ibm/icu/text/DateIntervalFormat.java b/icu4j/src/main/java/com/ibm/icu/text/DateIntervalFormat.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/DateIntervalFormat.java
rename to icu4j/src/main/java/com/ibm/icu/text/DateIntervalFormat.java
index e0578df..fac49a0 100644
--- a/app/src/main/java/com/ibm/icu/text/DateIntervalFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/DateIntervalFormat.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *   Copyright (C) 2008-2016, International Business Machines
 *   Corporation and others.  All Rights Reserved.
@@ -14,8 +16,9 @@ import java.util.HashMap;
 import java.util.Locale;
 import java.util.Map;
 
-import com.ibm.icu.impl.CalendarData;
 import com.ibm.icu.impl.ICUCache;
+import com.ibm.icu.impl.ICUData;
+import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.impl.SimpleCache;
 import com.ibm.icu.impl.SimpleFormatterImpl;
 import com.ibm.icu.text.DateIntervalInfo.PatternInfo;
@@ -25,6 +28,7 @@ import com.ibm.icu.util.Output;
 import com.ibm.icu.util.TimeZone;
 import com.ibm.icu.util.ULocale;
 import com.ibm.icu.util.ULocale.Category;
+import com.ibm.icu.util.UResourceBundle;
 
 
 /**
@@ -784,7 +788,8 @@ public class DateIntervalFormat extends UFormat {
             FieldPosition otherPos = new FieldPosition(pos.getField());
             fDateFormat.format(secondCal, appendTo, otherPos);
             if (pos.getEndIndex() == 0 && otherPos.getEndIndex() > 0) {
-                pos = otherPos;
+                pos.setBeginIndex(otherPos.getBeginIndex());
+                pos.setEndIndex(otherPos.getEndIndex());
             }
         }
         fDateFormat.applyPattern(originalPattern);
@@ -1132,13 +1137,11 @@ public class DateIntervalFormat extends UFormat {
 
         // move this up here since we need it for fallbacks
         if (time.length() != 0 && date.length() != 0) {
-            // Need the Date/Time pattern for concatnation the date with
+            // Need the Date/Time pattern for concatenating the date with
             // the time interval.
             // The date/time pattern ( such as {0} {1} ) is saved in
             // calendar, that is why need to get the CalendarData here.
-            CalendarData calData = new CalendarData(locale, null);
-            String[] patterns = calData.getDateTimePatterns();
-            fDateTimeFormat = patterns[8];
+            fDateTimeFormat = getConcatenationPattern(locale);
         }
 
         boolean found = genSeparateDateTimePtn(normalizedDateSkeleton, 
@@ -1261,6 +1264,21 @@ public class DateIntervalFormat extends UFormat {
         return intervalPatterns;
     }
 
+    /**
+     * Retrieves the concatenation DateTime pattern from the resource bundle.
+     * @param locale Locale to retrieve.
+     * @return Concatenation DateTime pattern.
+     */
+    private String getConcatenationPattern(ULocale locale) {
+        ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, locale);
+        ICUResourceBundle dtPatternsRb = rb.getWithFallback("calendar/gregorian/DateTimePatterns");
+        ICUResourceBundle concatenationPatternRb = (ICUResourceBundle) dtPatternsRb.get(8);
+        if (concatenationPatternRb.getType() == UResourceBundle.STRING) {
+            return concatenationPatternRb.getString();
+        } else {
+            return concatenationPatternRb.getString(0);
+        }
+    }
 
     /*
      * Generate fall back interval pattern given a calendar field,
diff --git a/app/src/main/java/com/ibm/icu/text/DateIntervalInfo.java b/icu4j/src/main/java/com/ibm/icu/text/DateIntervalInfo.java
similarity index 90%
rename from app/src/main/java/com/ibm/icu/text/DateIntervalInfo.java
rename to icu4j/src/main/java/com/ibm/icu/text/DateIntervalInfo.java
index 5105bec..94c6ec4 100644
--- a/app/src/main/java/com/ibm/icu/text/DateIntervalInfo.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/DateIntervalInfo.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2008-2016, International Business Machines Corporation and
@@ -24,7 +26,6 @@ import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.impl.SimpleCache;
 import com.ibm.icu.impl.UResource;
 import com.ibm.icu.impl.UResource.Key;
-import com.ibm.icu.impl.UResource.TableSink;
 import com.ibm.icu.impl.UResource.Value;
 import com.ibm.icu.impl.Utility;
 import com.ibm.icu.util.Calendar;
@@ -242,11 +243,12 @@ public class DateIntervalInfo implements Cloneable, Freezable<DateIntervalInfo>,
          * @return <code>true</code> if the specified object is equal to this <code>PatternInfo</code>.
          * @stable ICU 4.0
          */
+        @Override
         public boolean equals(Object a) {
-            if ( a instanceof PatternInfo ) {
+            if (a instanceof PatternInfo) {
                 PatternInfo patternInfo = (PatternInfo)a;
                 return Utility.objectEquals(fIntervalPatternFirstPart, patternInfo.fIntervalPatternFirstPart) &&
-                       Utility.objectEquals(fIntervalPatternSecondPart, fIntervalPatternSecondPart) &&
+                       Utility.objectEquals(fIntervalPatternSecondPart, patternInfo.fIntervalPatternSecondPart) &&
                        fFirstDateInPtnIsLaterDate == patternInfo.fFirstDateInPtnIsLaterDate;
             }
             return false;
@@ -257,6 +259,7 @@ public class DateIntervalInfo implements Cloneable, Freezable<DateIntervalInfo>,
          * @return A hash code value for this object.
          * @stable ICU 4.0
          */
+        @Override
         public int hashCode() {
             int hash = fIntervalPatternFirstPart != null ? fIntervalPatternFirstPart.hashCode() : 0;
             if (fIntervalPatternSecondPart != null) {
@@ -411,10 +414,8 @@ public class DateIntervalInfo implements Cloneable, Freezable<DateIntervalInfo>,
 
     /**
      * Sink for enumerating all of the date interval skeletons.
-     * Contains inner sink classes, each one corresponding to a type of resource table.
-     * The outer class finds the dateInterval table or an alias.
      */
-    private static final class DateIntervalSink extends UResource.TableSink {
+    private static final class DateIntervalSink extends UResource.Sink {
 
         /**
          * Accepted pattern letters:
@@ -429,117 +430,66 @@ public class DateIntervalInfo implements Cloneable, Freezable<DateIntervalInfo>,
          */
         private static final String ACCEPTED_PATTERN_LETTERS = "yMdahHms";
 
-
-        /**
-         * Sink to handle each skeleton table.
-         */
-        class SkeletonSink extends UResource.TableSink {
-            @Override
-            public TableSink getOrCreateTableSink(Key key, int initialSize) {
-                currentSkeleton = key.toString();
-                return patternSink;
-            }
-        }
-        SkeletonSink skeletonSink = new SkeletonSink();
-
-        /**
-         * Sink to store the date interval pattern for each skeleton pattern character.
-         */
-        class PatternSink extends UResource.TableSink {
-
-            @Override
-            public void put(Key key, Value value) {
-                // Process the key
-                CharSequence patternLetter = validateAndProcessPatternLetter(key);
-
-                // If the calendar field has a valid value
-                if (patternLetter != null) {
-                    // Get the largest different calendar unit
-                    String lrgDiffCalUnit = patternLetter.toString();
-
-                    // Set the interval pattern
-                    setIntervalPatternIfAbsent(lrgDiffCalUnit, value);
-                }
-            }
-
-            /**
-             * Processes the pattern letter
-             * @param patternLetter
-             * @return Pattern letter
-             */
-            private CharSequence validateAndProcessPatternLetter(CharSequence patternLetter) {
-                // Check that patternLetter is just one letter
-                if (patternLetter.length() != 1) { return null; }
-
-                // Check that the pattern letter is accepted
-                char letter = patternLetter.charAt(0);
-                if (ACCEPTED_PATTERN_LETTERS.indexOf(letter) < 0) {
-                    return null;
-                }
-
-                // Replace 'h' for 'H'
-                if (letter == CALENDAR_FIELD_TO_PATTERN_LETTER[Calendar.HOUR_OF_DAY].charAt(0)) {
-                    patternLetter = CALENDAR_FIELD_TO_PATTERN_LETTER[Calendar.HOUR];
-                }
-
-                return patternLetter;
-            }
-
-            /**
-             * Stores the interval pattern for the current skeleton in the internal data structure
-             * if it's not present.
-             * @param lrgDiffCalUnit
-             * @param intervalPattern
-             */
-            private void setIntervalPatternIfAbsent(String lrgDiffCalUnit, Value intervalPattern) {
-                // Check if the pattern has already been stored on the data structure.
-                Map<String, PatternInfo> patternsOfOneSkeleton =
-                        dateIntervalInfo.fIntervalPatterns.get(currentSkeleton);
-                if (patternsOfOneSkeleton == null || !patternsOfOneSkeleton.containsKey(lrgDiffCalUnit)) {
-                    // Store the pattern
-                    dateIntervalInfo.setIntervalPatternInternally(currentSkeleton, lrgDiffCalUnit,
-                            intervalPattern.toString());
-                }
-            }
-
-        }
-        PatternSink patternSink = new PatternSink();
-
-
         // Output data
         DateIntervalInfo dateIntervalInfo;
 
         // Alias handling
         String nextCalendarType;
 
-        // Current skeleton table being enumerated
-        String currentSkeleton;
-
-
         // Constructor
         public DateIntervalSink(DateIntervalInfo dateIntervalInfo) {
             this.dateIntervalInfo = dateIntervalInfo;
         }
 
         @Override
-        public void put(Key key, Value value) {
-            // Check if it's an alias of intervalFormats
-            if (value.getType() != ICUResourceBundle.ALIAS
-                    || !key.contentEquals(INTERVAL_FORMATS_KEY)) {
-                return;
-            }
+        public void put(Key key, Value value, boolean noFallback) {
+            // Iterate over all the calendar entries and only pick the 'intervalFormats' table.
+            UResource.Table dateIntervalData = value.getTable();
+            for (int i = 0; dateIntervalData.getKeyAndValue(i, key, value); i++) {
+                if (!key.contentEquals(INTERVAL_FORMATS_KEY)) {
+                    continue;
+                }
 
-            // Get the calendar type from the alias path.
-            nextCalendarType = getCalendarTypeFromPath(value.getAliasString());
+                // Handle aliases and tables. Ignore the rest.
+                if (value.getType() == ICUResourceBundle.ALIAS) {
+                    // Get the calendar type from the alias path.
+                    nextCalendarType = getCalendarTypeFromPath(value.getAliasString());
+                    break;
+
+                } else if (value.getType() == ICUResourceBundle.TABLE) {
+                    // Iterate over all the skeletons in the 'intervalFormat' table.
+                    UResource.Table skeletonData = value.getTable();
+                    for (int j = 0; skeletonData.getKeyAndValue(j, key, value); j++) {
+                        if (value.getType() == ICUResourceBundle.TABLE) {
+                            // Process the skeleton
+                            processSkeletonTable(key, value);
+                        }
+                    }
+                    break;
+                }
+            }
         }
 
-        @Override
-        public TableSink getOrCreateTableSink(Key key, int initialSize) {
-            // Check if it's the intervalFormats table
-            if (key.contentEquals(INTERVAL_FORMATS_KEY)) {
-                return skeletonSink;
+        /** Processes the patterns for a skeleton table. */
+        public void processSkeletonTable(Key key, Value value) {
+            // Iterate over all the patterns in the current skeleton table
+            String currentSkeleton = key.toString();
+            UResource.Table patternData = value.getTable();
+            for (int k = 0; patternData.getKeyAndValue(k, key, value); k++) {
+                if (value.getType() == ICUResourceBundle.STRING) {
+                    // Process the key
+                    CharSequence patternLetter = validateAndProcessPatternLetter(key);
+
+                    // If the calendar field has a valid value
+                    if (patternLetter != null) {
+                        // Get the largest different calendar unit
+                        String lrgDiffCalUnit = patternLetter.toString();
+
+                        // Set the interval pattern
+                        setIntervalPatternIfAbsent(currentSkeleton, lrgDiffCalUnit, value);
+                    }
+                }
             }
-            return null;
         }
 
         /**
@@ -552,10 +502,10 @@ public class DateIntervalInfo implements Cloneable, Freezable<DateIntervalInfo>,
             return tmpCalendarType;
         }
 
-        // Alias' path prefix and sufix.
+        // Alias' path prefix and suffix.
         private static final String DATE_INTERVAL_PATH_PREFIX =
             "/LOCALE/" + CALENDAR_KEY + "/";
-        private static final String DATE_INTERVAL_PATH_SUFIX =
+        private static final String DATE_INTERVAL_PATH_SUFFIX =
             "/" + INTERVAL_FORMATS_KEY;
 
         /**
@@ -565,12 +515,52 @@ public class DateIntervalInfo implements Cloneable, Freezable<DateIntervalInfo>,
          */
         private String getCalendarTypeFromPath(String path) {
             if (path.startsWith(DATE_INTERVAL_PATH_PREFIX) &&
-                    path.endsWith(DATE_INTERVAL_PATH_SUFIX)) {
+                    path.endsWith(DATE_INTERVAL_PATH_SUFFIX)) {
                 return path.substring(DATE_INTERVAL_PATH_PREFIX.length(),
-                    path.length() - DATE_INTERVAL_PATH_SUFIX.length());
+                    path.length() - DATE_INTERVAL_PATH_SUFFIX.length());
             }
             throw new ICUException("Malformed 'intervalFormat' alias path: " + path);
         }
+
+        /**
+         * Processes the pattern letter
+         * @param patternLetter
+         * @return Pattern letter
+         */
+        private CharSequence validateAndProcessPatternLetter(CharSequence patternLetter) {
+            // Check that patternLetter is just one letter
+            if (patternLetter.length() != 1) { return null; }
+
+            // Check that the pattern letter is accepted
+            char letter = patternLetter.charAt(0);
+            if (ACCEPTED_PATTERN_LETTERS.indexOf(letter) < 0) {
+                return null;
+            }
+
+            // Replace 'h' for 'H'
+            if (letter == CALENDAR_FIELD_TO_PATTERN_LETTER[Calendar.HOUR_OF_DAY].charAt(0)) {
+                patternLetter = CALENDAR_FIELD_TO_PATTERN_LETTER[Calendar.HOUR];
+            }
+
+            return patternLetter;
+        }
+
+        /**
+         * Stores the interval pattern for the current skeleton in the internal data structure
+         * if it's not present.
+         * @param lrgDiffCalUnit
+         * @param intervalPattern
+         */
+        private void setIntervalPatternIfAbsent(String currentSkeleton, String lrgDiffCalUnit, Value intervalPattern) {
+            // Check if the pattern has already been stored on the data structure.
+            Map<String, PatternInfo> patternsOfOneSkeleton =
+                    dateIntervalInfo.fIntervalPatterns.get(currentSkeleton);
+            if (patternsOfOneSkeleton == null || !patternsOfOneSkeleton.containsKey(lrgDiffCalUnit)) {
+                // Store the pattern
+                dateIntervalInfo.setIntervalPatternInternally(currentSkeleton, lrgDiffCalUnit,
+                        intervalPattern.toString());
+            }
+        }
     }
 
 
@@ -621,7 +611,7 @@ public class DateIntervalInfo implements Cloneable, Freezable<DateIntervalInfo>,
 
                 // Get all resources for this calendar type
                 String pathToIntervalFormats = CALENDAR_KEY + "/" + calendarTypeToUse;
-                resource.getAllTableItemsWithFallback(pathToIntervalFormats, sink);
+                resource.getAllItemsWithFallback(pathToIntervalFormats, sink);
 
                 // Get next calendar type to load if there was an alias pointing at it
                 calendarTypeToUse = sink.getAndResetNextCalendarType();
@@ -940,6 +930,7 @@ public class DateIntervalInfo implements Cloneable, Freezable<DateIntervalInfo>,
      * @return     a copy of the object
      * @stable ICU4.0
      */
+    @Override
     public Object clone()
     {
         if ( frozen ) {
@@ -999,6 +990,7 @@ public class DateIntervalInfo implements Cloneable, Freezable<DateIntervalInfo>,
      *
      * @stable ICU 4.0
      */
+    @Override
     public boolean isFrozen() {
         return frozen;
     }
@@ -1008,6 +1000,7 @@ public class DateIntervalInfo implements Cloneable, Freezable<DateIntervalInfo>,
      *
      * @stable ICU 4.4
      */
+    @Override
     public DateIntervalInfo freeze() {
         fIntervalPatternsReadOnly = true;
         frozen = true;
@@ -1019,6 +1012,7 @@ public class DateIntervalInfo implements Cloneable, Freezable<DateIntervalInfo>,
      *
      * @stable ICU 4.4
      */
+    @Override
     public DateIntervalInfo cloneAsThawed() {
         DateIntervalInfo result = (DateIntervalInfo) (this.cloneUnfrozenDII());
         return result;
@@ -1152,6 +1146,7 @@ public class DateIntervalInfo implements Cloneable, Freezable<DateIntervalInfo>,
      * Override equals
      * @stable ICU 4.0
      */
+    @Override
     public boolean equals(Object a) {
         if ( a instanceof DateIntervalInfo ) {
             DateIntervalInfo dtInfo = (DateIntervalInfo)a;
@@ -1164,6 +1159,7 @@ public class DateIntervalInfo implements Cloneable, Freezable<DateIntervalInfo>,
      * Override hashcode
      * @stable ICU 4.0
      */
+    @Override
     public int hashCode() {
         return fIntervalPatterns.hashCode();
     }
diff --git a/app/src/main/java/com/ibm/icu/text/DateTimePatternGenerator.java b/icu4j/src/main/java/com/ibm/icu/text/DateTimePatternGenerator.java
similarity index 81%
rename from app/src/main/java/com/ibm/icu/text/DateTimePatternGenerator.java
rename to icu4j/src/main/java/com/ibm/icu/text/DateTimePatternGenerator.java
index 1375ce7..46a07ef 100644
--- a/app/src/main/java/com/ibm/icu/text/DateTimePatternGenerator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/DateTimePatternGenerator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ********************************************************************************
  * Copyright (C) 2006-2016, Google, International Business Machines Corporation
@@ -26,18 +28,18 @@ import java.util.TreeMap;
 import java.util.TreeSet;
 
 import com.ibm.icu.impl.ICUCache;
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.impl.PatternTokenizer;
 import com.ibm.icu.impl.SimpleCache;
 import com.ibm.icu.impl.SimpleFormatterImpl;
-import com.ibm.icu.impl.Utility;
+import com.ibm.icu.impl.UResource;
 import com.ibm.icu.util.Calendar;
 import com.ibm.icu.util.Freezable;
 import com.ibm.icu.util.ICUCloneNotSupportedException;
 import com.ibm.icu.util.ULocale;
 import com.ibm.icu.util.ULocale.Category;
 import com.ibm.icu.util.UResourceBundle;
-import com.ibm.icu.util.UResourceBundleIterator;
 
 /**
  * This class provides flexible generation of date format patterns, like
@@ -63,7 +65,10 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
      * @stable ICU 3.6
      */
     public static DateTimePatternGenerator getEmptyInstance() {
-        return new DateTimePatternGenerator();
+        DateTimePatternGenerator instance = new DateTimePatternGenerator();
+        instance.addCanonicalItems();
+        instance.fillInMissing();
+        return instance;
     }
 
     /**
@@ -117,40 +122,48 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
         if (result != null) {
             return result;
         }
+
         result = new DateTimePatternGenerator();
+        result.initData(uLocale);
+
+        // freeze and cache
+        result.freeze();
+        DTPNG_CACHE.put(localeKey, result);
+        return result;
+    }
+
+    private void initData(ULocale uLocale) {
+        // This instance of PatternInfo is required for calling some functions.  It is used for
+        // passing additional information to the caller.  We won't use this extra information, but
+        // we still need to make a temporary instance.
         PatternInfo returnInfo = new PatternInfo();
-        String shortTimePattern = null;
+
+        addCanonicalItems();
+        addICUPatterns(returnInfo, uLocale);
+        addCLDRData(returnInfo, uLocale);
+        setDateTimeFromCalendar(uLocale);
+        setDecimalSymbols(uLocale);
+        getAllowedHourFormats(uLocale);
+        fillInMissing();
+    }
+
+    private void addICUPatterns(PatternInfo returnInfo, ULocale uLocale) {
         // first load with the ICU patterns
         for (int i = DateFormat.FULL; i <= DateFormat.SHORT; ++i) {
             SimpleDateFormat df = (SimpleDateFormat) DateFormat.getDateInstance(i, uLocale);
-            result.addPattern(df.toPattern(), false, returnInfo);
+            addPattern(df.toPattern(), false, returnInfo);
             df = (SimpleDateFormat) DateFormat.getTimeInstance(i, uLocale);
-            result.addPattern(df.toPattern(), false, returnInfo);
+            addPattern(df.toPattern(), false, returnInfo);
+
             if (i == DateFormat.SHORT) {
-                // keep this pattern to populate other time field
-                // combination patterns by hackTimes later in this method.
-                shortTimePattern = df.toPattern();
-
-                // use hour style in SHORT time pattern as the default
-                // hour style for the locale
-                FormatParser fp = new FormatParser();
-                fp.set(shortTimePattern);
-                List<Object> items = fp.getItems();
-                for (int idx = 0; idx < items.size(); idx++) {
-                    Object item = items.get(idx);
-                    if (item instanceof VariableField) {
-                        VariableField fld = (VariableField)item;
-                        if (fld.getType() == HOUR) {
-                            result.defaultHourFormatChar = fld.toString().charAt(0);
-                            break;
-                        }
-                    }
-                }
+                consumeShortTimePattern(df.toPattern(), returnInfo);
             }
         }
+    }
 
-        ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, uLocale);
+    private String getCalendarTypeToUse(ULocale uLocale) {
         // Get the correct calendar type
+        // TODO: C++ and Java are inconsistent (see #9952).
         String calendarTypeToUse = uLocale.getKeywordValue("calendar");
         if ( calendarTypeToUse == null ) {
             String[] preferredCalendarTypes = Calendar.getKeywordValuesForLocale("calendar", uLocale, true);
@@ -159,105 +172,151 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
         if ( calendarTypeToUse == null ) {
             calendarTypeToUse = "gregorian"; // fallback
         }
+        return calendarTypeToUse;
+    }
 
-        // Get data for that calendar
-        try {
-            //      ICU4J getWithFallback does not work well when
-            //      1) A nested table is an alias to /LOCALE/...
-            //      2) getWithFallback is called multiple times for going down hierarchical resource path
-            //      #9987 resolved the issue of alias table when full path is specified in getWithFallback,
-            //      but there is no easy solution when the equivalent operation is done by multiple operations.
-            //      This issue is addressed in #9964.
-            ICUResourceBundle itemBundle = rb.getWithFallback("calendar/" + calendarTypeToUse + "/appendItems");
-            for (int i=0; i<itemBundle.getSize(); ++i) {
-                ICUResourceBundle formatBundle = (ICUResourceBundle)itemBundle.get(i);
-                String formatName = itemBundle.get(i).getKey();
-                String value = formatBundle.getString();
-                result.setAppendItemFormat(getAppendFormatNumber(formatName), value);
+    private void consumeShortTimePattern(String shortTimePattern, PatternInfo returnInfo) {
+        // keep this pattern to populate other time field
+        // combination patterns by hackTimes later in this method.
+        // use hour style in SHORT time pattern as the default
+        // hour style for the locale
+        FormatParser fp = new FormatParser();
+        fp.set(shortTimePattern);
+        List<Object> items = fp.getItems();
+        for (int idx = 0; idx < items.size(); idx++) {
+            Object item = items.get(idx);
+            if (item instanceof VariableField) {
+                VariableField fld = (VariableField)item;
+                if (fld.getType() == HOUR) {
+                    defaultHourFormatChar = fld.toString().charAt(0);
+                    break;
+                }
             }
-        }catch(MissingResourceException e) {
         }
 
-        // CLDR item names
-        try {
-            ICUResourceBundle itemBundle = rb.getWithFallback("fields");
-            ICUResourceBundle fieldBundle, dnBundle;
-            for (int i=0; i<TYPE_LIMIT; ++i) {
-                if ( isCLDRFieldName(i) ) {
-                    fieldBundle = itemBundle.getWithFallback(CLDR_FIELD_NAME[i]);
-                    dnBundle = fieldBundle.getWithFallback("dn");
-                    String value = dnBundle.getString();
-                    //System.out.println("Field name:"+value);
-                    result.setAppendItemName(i, value);
+        // some languages didn't add mm:ss or HH:mm, so put in a hack to compute that from the short time.
+        hackTimes(returnInfo, shortTimePattern);
+    }
+
+    private class AppendItemFormatsSink extends UResource.Sink {
+        @Override
+        public void put(UResource.Key key, UResource.Value value, boolean noFallback) {
+            UResource.Table itemsTable = value.getTable();
+            for (int i = 0; itemsTable.getKeyAndValue(i, key, value); ++i) {
+                int field = getAppendFormatNumber(key);
+                assert field != -1;
+                if (getAppendItemFormat(field) == null) {
+                    setAppendItemFormat(field, value.toString());
                 }
             }
-        }catch(MissingResourceException e) {
         }
+    }
 
-        // set the AvailableFormat in CLDR
-        ICUResourceBundle availFormatsBundle = null;
-        try {
-            //      ICU4J getWithFallback does not work well when
-            //      1) A nested table is an alias to /LOCALE/...
-            //      2) getWithFallback is called multiple times for going down hierarchical resource path
-            //      #9987 resolved the issue of alias table when full path is specified in getWithFallback,
-            //      but there is no easy solution when the equivalent operation is done by multiple operations.
-            //      This issue is addressed in #9964.
-            availFormatsBundle = rb.getWithFallback("calendar/" + calendarTypeToUse + "/availableFormats");
-        } catch (MissingResourceException e) {
-            // fall through
+    private class AppendItemNamesSink extends UResource.Sink {
+        @Override
+        public void put(UResource.Key key, UResource.Value value, boolean noFallback) {
+            UResource.Table itemsTable = value.getTable();
+            for (int i = 0; itemsTable.getKeyAndValue(i, key, value); ++i) {
+                int field = getCLDRFieldNumber(key);
+                if (field == -1) { continue; }
+                UResource.Table detailsTable = value.getTable();
+                for (int j = 0; detailsTable.getKeyAndValue(j, key, value); ++j) {
+                    if (!key.contentEquals("dn")) continue;
+                    if (getAppendItemName(field) == null) {
+                        setAppendItemName(field, value.toString());
+                    }
+                    break;
+                }
+            }
         }
+    }
 
-        boolean override = true;
-        while (availFormatsBundle != null) {
-            for (int i = 0; i < availFormatsBundle.getSize(); i++) {
-                String formatKey = availFormatsBundle.get(i).getKey();
+    private void fillInMissing() {
+        for (int i = 0; i < TYPE_LIMIT; ++i) {
+            if (getAppendItemFormat(i) == null) {
+                setAppendItemFormat(i, "{0} \u251C{2}: {1}\u2524");
+            }
+            if (getAppendItemName(i) == null) {
+                setAppendItemName(i, "F" + i);
+            }
+        }
+    }
+
+    private class AvailableFormatsSink extends UResource.Sink {
+        PatternInfo returnInfo;
+        public AvailableFormatsSink(PatternInfo returnInfo) {
+            this.returnInfo = returnInfo;
+        }
 
-                if (!result.isAvailableFormatSet(formatKey)) {
-                    result.setAvailableFormat(formatKey);
+        @Override
+        public void put(UResource.Key key, UResource.Value value, boolean isRoot) {
+            UResource.Table formatsTable = value.getTable();
+            for (int i = 0; formatsTable.getKeyAndValue(i, key, value); ++i) {
+                String formatKey = key.toString();
+                if (!isAvailableFormatSet(formatKey)) {
+                    setAvailableFormat(formatKey);
                     // Add pattern with its associated skeleton. Override any duplicate derived from std patterns,
                     // but not a previous availableFormats entry:
-                    String formatValue = availFormatsBundle.get(i).getString();
-                    result.addPatternWithSkeleton(formatValue, formatKey, override, returnInfo);
+                    String formatValue = value.toString();
+                    addPatternWithSkeleton(formatValue, formatKey, !isRoot, returnInfo);
                 }
             }
+        }
+    }
 
-            ICUResourceBundle pbundle = (ICUResourceBundle)availFormatsBundle.getParent();
-            if (pbundle == null) {
-                break;
-            }
-            try {
-                availFormatsBundle = pbundle.getWithFallback("calendar/" + calendarTypeToUse + "/availableFormats");
-            } catch (MissingResourceException e) {
-                availFormatsBundle = null;
-            }
-            if (availFormatsBundle != null && pbundle.getULocale().getBaseName().equals("root")) {
-                override = false;
-            }
+    private void addCLDRData(PatternInfo returnInfo, ULocale uLocale) {
+        ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, uLocale);
+        String calendarTypeToUse = getCalendarTypeToUse(uLocale);
+
+        //      ICU4J getWithFallback does not work well when
+        //      1) A nested table is an alias to /LOCALE/...
+        //      2) getWithFallback is called multiple times for going down hierarchical resource path
+        //      #9987 resolved the issue of alias table when full path is specified in getWithFallback,
+        //      but there is no easy solution when the equivalent operation is done by multiple operations.
+        //      This issue is addressed in #9964.
+
+        // Load append item formats.
+        AppendItemFormatsSink appendItemFormatsSink = new AppendItemFormatsSink();
+        try {
+            rb.getAllItemsWithFallback(
+                    "calendar/" + calendarTypeToUse + "/appendItems",
+                    appendItemFormatsSink);
+        }catch(MissingResourceException e) {
         }
 
-        // assume it is always big endian (ok for CLDR right now)
-        // some languages didn't add mm:ss or HH:mm, so put in a hack to compute that from the short time.
-        if (shortTimePattern != null) {
-            hackTimes(result, returnInfo, shortTimePattern);
+        // Load CLDR item names.
+        AppendItemNamesSink appendItemNamesSink = new AppendItemNamesSink();
+        try {
+            rb.getAllItemsWithFallback(
+                    "fields",
+                    appendItemNamesSink);
+        }catch(MissingResourceException e) {
         }
 
-        result.setDateTimeFormat(Calendar.getDateTimePattern(Calendar.getInstance(uLocale), uLocale, DateFormat.MEDIUM));
+        // Load the available formats from CLDR.
+        AvailableFormatsSink availableFormatsSink = new AvailableFormatsSink(returnInfo);
+        try {
+            rb.getAllItemsWithFallback(
+                    "calendar/" + calendarTypeToUse + "/availableFormats",
+                    availableFormatsSink);
+        } catch (MissingResourceException e) {
+        }
+    }
+
+    private void setDateTimeFromCalendar(ULocale uLocale) {
+        String dateTimeFormat = Calendar.getDateTimePattern(Calendar.getInstance(uLocale), uLocale, DateFormat.MEDIUM);
+        setDateTimeFormat(dateTimeFormat);
+    }
 
+    private void setDecimalSymbols(ULocale uLocale) {
         // decimal point for seconds
         DecimalFormatSymbols dfs = new DecimalFormatSymbols(uLocale);
-        result.setDecimal(String.valueOf(dfs.getDecimalSeparator()));
-
-        // List of allowed hour formats
-        result.allowedHourFormats = getPreferredHourFormats(uLocale); // already frozen
-
-        // freeze and cache
-        result.freeze();
-        DTPNG_CACHE.put(localeKey, result);
-        return result;
+        setDecimal(String.valueOf(dfs.getDecimalSeparator()));
     }
 
-    private static List<String> getPreferredHourFormats(ULocale uLocale) {
+    private static final String[] LAST_RESORT_ALLOWED_HOUR_FORMAT = {"H"};
+
+    private void getAllowedHourFormats(ULocale uLocale) {
         // key can be either region or locale (lang_region)
         //        ZW{
         //            allowed{
@@ -282,14 +341,51 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
             country = "001";
         }
         String langCountry = max.getLanguage() + "_" + country;
-        List<String> list = LOCALE_TO_PREFERED_HOUR.get(langCountry);
+        String[] list = LOCALE_TO_ALLOWED_HOUR.get(langCountry);
         if (list == null) {
-            list = LOCALE_TO_PREFERED_HOUR.get(country);
+            list = LOCALE_TO_ALLOWED_HOUR.get(country);
             if (list == null) {
-                list = Collections.singletonList("H");
+                list = LAST_RESORT_ALLOWED_HOUR_FORMAT;
+            }
+        }
+        allowedHourFormats = list;
+    }
+
+    private static class DayPeriodAllowedHoursSink extends UResource.Sink {
+        HashMap<String, String[]> tempMap;
+
+        private DayPeriodAllowedHoursSink(HashMap<String, String[]> tempMap) {
+            this.tempMap = tempMap;
+        }
+
+        @Override
+        public void put(UResource.Key key, UResource.Value value, boolean noFallback) {
+            UResource.Table timeData = value.getTable();
+            for (int i = 0; timeData.getKeyAndValue(i, key, value); ++i) {
+                String regionOrLocale = key.toString();
+                UResource.Table formatList = value.getTable();
+                for (int j = 0; formatList.getKeyAndValue(j, key, value); ++j) {
+                    if (key.contentEquals("allowed")) {  // Ignore "preferred" list.
+                        tempMap.put(regionOrLocale, value.getStringArrayOrStringAsArray());
+                    }
+                }
             }
         }
-        return list;
+    }
+
+    // Get the data for dayperiod C.
+    static final Map<String, String[]> LOCALE_TO_ALLOWED_HOUR;
+    static {
+        HashMap<String, String[]> temp = new HashMap<String, String[]>();
+        ICUResourceBundle suppData = (ICUResourceBundle)ICUResourceBundle.getBundleInstance(
+                ICUData.ICU_BASE_NAME,
+                "supplementalData",
+                ICUResourceBundle.ICU_DATA_CLASS_LOADER);
+
+        DayPeriodAllowedHoursSink allowedHoursSink = new DayPeriodAllowedHoursSink(temp);
+        suppData.getAllItemsWithFallback("timeData", allowedHoursSink);
+
+        LOCALE_TO_ALLOWED_HOUR = Collections.unmodifiableMap(temp);
     }
 
     /**
@@ -310,16 +406,16 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
         this.defaultHourFormatChar = defaultHourFormatChar;
     }
 
-    private static void hackTimes(DateTimePatternGenerator result, PatternInfo returnInfo, String hackPattern) {
-        result.fp.set(hackPattern);
+    private void hackTimes(PatternInfo returnInfo, String shortTimePattern) {
+        fp.set(shortTimePattern);
         StringBuilder mmss = new StringBuilder();
         // to get mm:ss, we strip all but mm literal ss
         boolean gotMm = false;
-        for (int i = 0; i < result.fp.items.size(); ++i) {
-            Object item = result.fp.items.get(i);
+        for (int i = 0; i < fp.items.size(); ++i) {
+            Object item = fp.items.get(i);
             if (item instanceof String) {
                 if (gotMm) {
-                    mmss.append(result.fp.quoteLiteral(item.toString()));
+                    mmss.append(fp.quoteLiteral(item.toString()));
                 }
             } else {
                 char ch = item.toString().charAt(0);
@@ -331,7 +427,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
                         break; // failed
                     }
                     mmss.append(item);
-                    result.addPattern(mmss.toString(), false, returnInfo);
+                    addPattern(mmss.toString(), false, returnInfo);
                     break;
                 } else if (gotMm || ch == 'z' || ch == 'Z' || ch == 'v' || ch == 'V') {
                     break; // failed
@@ -342,8 +438,8 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
         // the easiest way to do this is to mark the stuff we want to nuke, then remove it in a second pass.
         BitSet variables = new BitSet();
         BitSet nuke = new BitSet();
-        for (int i = 0; i < result.fp.items.size(); ++i) {
-            Object item = result.fp.items.get(i);
+        for (int i = 0; i < fp.items.size(); ++i) {
+            Object item = fp.items.get(i);
             if (item instanceof VariableField) {
                 variables.set(i);
                 char ch = item.toString().charAt(0);
@@ -356,8 +452,8 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
                 }
             }
         }
-        String hhmm = getFilteredPattern(result.fp, nuke);
-        result.addPattern(hhmm, false, returnInfo);
+        String hhmm = getFilteredPattern(fp, nuke);
+        addPattern(hhmm, false, returnInfo);
     }
 
     private static String getFilteredPattern(FormatParser fp, BitSet nuke) {
@@ -381,6 +477,20 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
         return -1;
     }*/
 
+    /**
+     * @internal
+     * @deprecated This API is ICU internal only.
+     */
+    @Deprecated
+    public static int getAppendFormatNumber(UResource.Key key) {
+        for (int i = 0; i < CLDR_FIELD_APPEND.length; ++i) {
+            if (key.contentEquals(CLDR_FIELD_APPEND[i])) {
+                return i;
+            }
+        }
+        return -1;
+    }
+
     /**
      * @internal CLDR
      * @deprecated This API is ICU internal only.
@@ -388,22 +498,20 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
     @Deprecated
     public static int getAppendFormatNumber(String string) {
         for (int i = 0; i < CLDR_FIELD_APPEND.length; ++i) {
-            if (CLDR_FIELD_APPEND[i].equals(string)) return i;
+            if (CLDR_FIELD_APPEND[i].equals(string)) {
+                return i;
+            }
         }
         return -1;
-
     }
 
-    private static boolean isCLDRFieldName(int index) {
-        if ((index<0) && (index>=TYPE_LIMIT)) {
-            return false;
-        }
-        if (CLDR_FIELD_NAME[index].charAt(0) == '*') {
-            return false;
-        }
-        else {
-            return true;
+    private static int getCLDRFieldNumber(UResource.Key key) {
+        for (int i = 0; i < CLDR_FIELD_NAME.length; ++i) {
+            if (key.contentEquals(CLDR_FIELD_NAME[i])) {
+                return i;
+            }
         }
+        return -1;
     }
 
     /**
@@ -422,7 +530,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
     /**
      * Return the best pattern matching the input skeleton. It is guaranteed to
      * have all of the fields in the skeleton.
-     * 
+     *
      * @param skeleton The skeleton is a pattern containing only the variable fields.
      *            For example, "MMMdd" and "mmhh" are skeletons.
      * @param options MATCH_xxx options for forcing the length of specified fields in
@@ -435,28 +543,6 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
         return getBestPattern(skeleton, null, options);
     }
 
-    // get the data for dayperiod C.
-    static final Map<String,List<String>> LOCALE_TO_PREFERED_HOUR;
-    static {
-        HashMap<String, List<String>> temp = new HashMap<String,List<String>>();
-        UResourceBundle suppData = UResourceBundle.getBundleInstance(
-                ICUResourceBundle.ICU_BASE_NAME,
-                "supplementalData",
-                ICUResourceBundle.ICU_DATA_CLASS_LOADER);
-        UResourceBundle suppTimeData = suppData.get("timeData");
-        for(UResourceBundleIterator iter = suppTimeData.getIterator(); iter.hasNext();) {
-            ICUResourceBundle subBndle = (ICUResourceBundle) iter.next();
-            final String regionOrLocale = subBndle.getKey();
-            // final List<String> list = Arrays.asList(subBndle.getStringArray()); Didn't work, so doing it the long way.
-            UResourceBundle allowedBundle = subBndle.get("allowed");
-            List<String> list = allowedBundle.getType() == UResourceBundle.STRING // getStringArray API should do this automatically!
-                    ? Collections.singletonList(allowedBundle.getString()) 
-                            : Arrays.asList(allowedBundle.getStringArray());
-                    temp.put(regionOrLocale, list);
-        }
-        LOCALE_TO_PREFERED_HOUR = Collections.unmodifiableMap(temp);
-    }
-
     /*
      * getBestPattern which takes optional skip matcher
      */
@@ -473,7 +559,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
                 if (patChr == 'j') {
                     skeletonCopy.setCharAt(patPos, defaultHourFormatChar);
                 } else if (patChr == 'C') {
-                    String preferred = allowedHourFormats.get(0);
+                    String preferred = allowedHourFormats[0];
                     skeletonCopy.setCharAt(patPos, preferred.charAt(0));
                     final DTPGflags alt = DTPGflags.getFlag(preferred);
                     if (alt != null) {
@@ -513,7 +599,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
      * PatternInfo supplies output parameters for addPattern(...). It is used because
      * Java doesn't have real output parameters. It is treated like a struct (eg
      * Point), so all fields are public.
-     * 
+     *
      * @stable ICU 3.6
      */
     public static final class PatternInfo { // struct for return information
@@ -632,7 +718,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
     /**
      * Utility to return a unique skeleton from a given pattern. For example,
      * both "MMM-dd" and "dd/MMM" produce the skeleton "MMMdd".
-     * 
+     *
      * @param pattern Input pattern, such as "dd/MMM"
      * @return skeleton, such as "MMMdd"
      * @stable ICU 3.6
@@ -646,7 +732,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
 
     /**
      * Same as getSkeleton, but allows duplicates
-     * 
+     *
      * @param pattern Input pattern, such as "dd/MMM"
      * @return skeleton, such as "MMMdd"
      * @internal
@@ -663,7 +749,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
     /**
      * Same as getSkeleton, but allows duplicates
      * and returns a string using canonical pattern chars
-     * 
+     *
      * @param pattern Input pattern, such as "ccc, d LLL"
      * @return skeleton, such as "MMMEd"
      * @internal
@@ -683,7 +769,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
      * so as to only preserve the difference between string and numeric form. So
      * for example, both "MMM-dd" and "d/MMM" produce the skeleton "MMMd"
      * (notice the single d).
-     * 
+     *
      * @param pattern Input pattern, such as "dd/MMM"
      * @return skeleton, such as "MMMdd"
      * @stable ICU 3.6
@@ -698,7 +784,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
     /**
      * Return a list of all the skeletons (in canonical form) from this class,
      * and the patterns that they map to.
-     * 
+     *
      * @param result an output Map in which to place the mapping from skeleton to
      *            pattern. If you want to see the internal order being used,
      *            supply a LinkedHashMap. If the input value is null, then a
@@ -759,7 +845,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
      * skeleton of "MMMMddhhmm", then the input pattern is adjusted to be
      * "dd-MMMM hh:mm". This is used internally to get the best match for the
      * input skeleton, but can also be used externally.
-     * 
+     *
      * @param pattern input pattern
      * @param skeleton For the pattern to match to.
      * @param options MATCH_xxx options for forcing the length of specified fields in
@@ -788,7 +874,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
      * broken up into two components "MMMd" and "hmm". There are close matches
      * for those two skeletons, so the result is put together with this pattern,
      * resulting in "d-MMM h:mm".
-     * 
+     *
      * @param dateTimeFormat message format pattern, where {1} will be replaced by the date
      *            pattern and {0} will be replaced by the time pattern.
      * @stable ICU 3.6
@@ -800,7 +886,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
 
     /**
      * Getter corresponding to setDateTimeFormat.
-     * 
+     *
      * @return pattern
      * @stable ICU 3.6
      */
@@ -815,7 +901,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
      * "hhmmssSSSS", and the best matching pattern internally is "H:mm:ss", and
      * the decimal string is ",". Then the resulting pattern is modified to be
      * "H:mm:ss,SSSS"
-     * 
+     *
      * @param decimal The decimal to set to.
      * @stable ICU 3.6
      */
@@ -837,7 +923,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
      * Redundant patterns are those which if removed, make no difference in the
      * resulting getBestPattern values. This method returns a list of them, to
      * help check the consistency of the patterns used to build this generator.
-     * 
+     *
      * @param output stores the redundant patterns that are removed. To get these
      *            in internal order, supply a LinkedHashSet. If null, a
      *            collection is allocated.
@@ -892,87 +978,89 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
     /**
      * @stable ICU 3.6
      */
-    static final public int ERA = 0;
+    public static final int ERA = 0;
 
     /**
      * @stable ICU 3.6
      */
-    static final public int YEAR = 1; 
+    public static final int YEAR = 1;
 
     /**
      * @stable ICU 3.6
      */
-    static final public int QUARTER = 2; 
+    public static final int QUARTER = 2;
 
     /**
      * @stable ICU 3.6
      */
-    static final public int MONTH = 3;
+    public static final int MONTH = 3;
 
     /**
      * @stable ICU 3.6
      */
-    static final public int WEEK_OF_YEAR = 4; 
+    public static final int WEEK_OF_YEAR = 4;
 
     /**
      * @stable ICU 3.6
      */
-    static final public int WEEK_OF_MONTH = 5; 
+    public static final int WEEK_OF_MONTH = 5;
 
     /**
      * @stable ICU 3.6
      */
-    static final public int WEEKDAY = 6; 
+    public static final int WEEKDAY = 6;
 
     /**
      * @stable ICU 3.6
      */
-    static final public int DAY = 7;
+    public static final int DAY = 7;
 
     /**
      * @stable ICU 3.6
      */
-    static final public int DAY_OF_YEAR = 8; 
+    public static final int DAY_OF_YEAR = 8;
 
     /**
      * @stable ICU 3.6
      */
-    static final public int DAY_OF_WEEK_IN_MONTH = 9; 
+    public static final int DAY_OF_WEEK_IN_MONTH = 9;
 
     /**
      * @stable ICU 3.6
      */
-    static final public int DAYPERIOD = 10;
+    public static final int DAYPERIOD = 10;
 
     /**
      * @stable ICU 3.6
      */
-    static final public int HOUR = 11; 
+    public static final int HOUR = 11;
 
     /**
      * @stable ICU 3.6
      */
-    static final public int MINUTE = 12; 
+    public static final int MINUTE = 12;
 
     /**
      * @stable ICU 3.6
      */
-    static final public int SECOND = 13; 
+    public static final int SECOND = 13;
 
     /**
      * @stable ICU 3.6
      */
-    static final public int FRACTIONAL_SECOND = 14;
+    public static final int FRACTIONAL_SECOND = 14;
 
     /**
      * @stable ICU 3.6
      */
-    static final public int ZONE = 15; 
+    public static final int ZONE = 15;
 
     /**
-     * @stable ICU 3.6
+     * One more than the highest normal field number.
+     * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
      */
-    static final public int TYPE_LIMIT = 16;
+    @Deprecated
+    public static final int TYPE_LIMIT = 16;
 
     // Option masks for getBestPattern, replaceFieldTypes (individual masks may be ORed together)
 
@@ -1030,7 +1118,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
      * {1} is the element we are adding, and {2} is the name of the element.
      * <p>
      * This reflects the way that the CLDR data is organized.
-     * 
+     *
      * @param field such as ERA
      * @param value pattern, such as "{0}, {1}"
      * @stable ICU 3.6
@@ -1043,7 +1131,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
     /**
      * Getter corresponding to setAppendItemFormats. Values below 0 or at or
      * above TYPE_LIMIT are illegal arguments.
-     * 
+     *
      * @param field The index to retrieve the append item formats.
      * @return append pattern for field
      * @stable ICU 3.6
@@ -1058,7 +1146,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
      * {2} variable.
      * <p>
      * This reflects the way that the CLDR data is organized.
-     * 
+     *
      * @param field Index of the append item names.
      * @param value The value to set the item to.
      * @stable ICU 3.6
@@ -1071,7 +1159,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
     /**
      * Getter corresponding to setAppendItemNames. Values below 0 or at or above
      * TYPE_LIMIT are illegal arguments.
-     * 
+     *
      * @param field The index to get the append item name.
      * @return name for field
      * @stable ICU 3.6
@@ -1082,7 +1170,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
 
     /**
      * Determines whether a skeleton contains a single field
-     * 
+     *
      * @param skeleton The skeleton to determine if it contains a single field.
      * @return true or not
      * @internal
@@ -1099,7 +1187,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
 
     /**
      * Add key to HashSet cldrAvailableFormatKeys.
-     * 
+     *
      * @param key of the availableFormats in CLDR
      * @stable ICU 3.6
      */
@@ -1113,7 +1201,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
      * has been added to DateTimePatternGenerator.
      * The function is to avoid the duplicate availableFomats added to
      * the pattern map from parent locales.
-     * 
+     *
      * @param key of the availableFormatMask in CLDR
      * @return TRUE if the corresponding slot of CLDR_AVAIL_FORMAT_KEY[]
      * has been added to DateTimePatternGenerator.
@@ -1127,6 +1215,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
      * {@inheritDoc}
      * @stable ICU 3.6
      */
+    @Override
     public boolean isFrozen() {
         return frozen;
     }
@@ -1135,6 +1224,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
      * {@inheritDoc}
      * @stable ICU 4.4
      */
+    @Override
     public DateTimePatternGenerator freeze() {
         frozen = true;
         return this;
@@ -1144,6 +1234,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
      * {@inheritDoc}
      * @stable ICU 4.4
      */
+    @Override
     public DateTimePatternGenerator cloneAsThawed() {
         DateTimePatternGenerator result = (DateTimePatternGenerator) (this.clone());
         frozen = false;
@@ -1155,6 +1246,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
      * @return A copy of this <code>DateTimePatternGenerator</code> object.
      * @stable ICU 3.6
      */
+    @Override
     @SuppressWarnings("unchecked")
     public Object clone() {
         try {
@@ -1182,7 +1274,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
      * variable field must consist of 1 to n variable characters, representing
      * date format fields. For example, "VVVV" is valid while "V4" is not, nor
      * is "44".
-     * 
+     *
      * @internal
      * @deprecated This API is ICU internal only.
      */
@@ -1222,7 +1314,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
         /**
          * Get the main type of this variable. These types are ERA, QUARTER,
          * MONTH, DAY, WEEK_OF_YEAR, WEEK_OF_MONTH, WEEKDAY, DAY, DAYPERIOD
-         * (am/pm), HOUR, MINUTE, SECOND,FRACTIONAL_SECOND, ZONE. 
+         * (am/pm), HOUR, MINUTE, SECOND,FRACTIONAL_SECOND, ZONE.
          * @return main type.
          * @internal
          * @deprecated This API is ICU internal only.
@@ -1267,6 +1359,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
          * @internal
          * @deprecated This API is ICU internal only.
          */
+        @Override
         @Deprecated
         public String toString() {
             return string;
@@ -1428,6 +1521,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
          * @internal
          * @deprecated This API is ICU internal only.
          */
+        @Override
         @Deprecated
         public String toString() {
             return toString(0, items.size());
@@ -1468,7 +1562,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
             for (Object item : items) {
                 if (item instanceof VariableField) {
                     int type = ((VariableField)item).getType();
-                    foundMask |= 1 << type;    
+                    foundMask |= 1 << type;
                 }
             }
             boolean isDate = (foundMask & DATE_MASK) != 0;
@@ -1494,7 +1588,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
         //                        int type = ((VariableField)item).getType();
         //                        if (minField > type) minField = type;
         //                        if (maxField < type) maxField = type;
-        //                        if (type == ZONE || type == DAYPERIOD || type == WEEKDAY) return result; // skip anything with zones                    
+        //                        if (type == ZONE || type == DAYPERIOD || type == WEEKDAY) return result; // skip anything with zones
         //                        fieldCount++;
         //                    } catch (Exception e) {
         //                        return result; // if there are any funny fields, return
@@ -1511,7 +1605,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
         //                if (item instanceof VariableField) {
         //                    int type = ((VariableField)item).getType();
         //                    if (type != minField && type != maxField) break;
-        //                    
+        //
         //                    if (i > 0) {
         //                        Object previousItem = items.get(0);
         //                        if (alpha.containsSome(previousItem.toString())) break;
@@ -1652,6 +1746,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
             pattern = pat;
             skeletonWasSpecified = skelSpecified;
         }
+        @Override
         public String toString() {
             return pattern + "," + skeletonWasSpecified;
         }
@@ -1662,12 +1757,6 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
     private String dateTimeFormat = "{1} {0}";
     private String[] appendItemFormats = new String[TYPE_LIMIT];
     private String[] appendItemNames = new String[TYPE_LIMIT];
-    {
-        for (int i = 0; i < TYPE_LIMIT; ++i) {
-            appendItemFormats[i] = "{0} \u251C{2}: {1}\u2524";
-            appendItemNames[i] = "F" + i;
-        }
-    }
     private char defaultHourFormatChar = 'H';
     //private boolean chineseMonthHack = false;
     //private boolean isComplete = false;
@@ -1677,7 +1766,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
     private transient FormatParser fp = new FormatParser();
     private transient DistanceInfo _distanceInfo = new DistanceInfo();
 
-    private List<String> allowedHourFormats;
+    private String[] allowedHourFormats;
 
     private static final int FRACTIONAL_MASK = 1<<FRACTIONAL_SECOND;
     private static final int SECOND_AND_FRACTIONAL_MASK = (1<<SECOND) | (1<<FRACTIONAL_SECOND);
@@ -1703,7 +1792,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
 
             while (distInfo.missingFieldMask != 0) { // precondition: EVERY single field must work!
 
-                // special hack for SSS. If we are missing SSS, and we had ss but found it, replace the s field according to the 
+                // special hack for SSS. If we are missing SSS, and we had ss but found it, replace the s field according to the
                 // number separator
                 if ((distInfo.missingFieldMask & SECOND_AND_FRACTIONAL_MASK) == FRACTIONAL_MASK
                         && (missingFields & SECOND_AND_FRACTIONAL_MASK) == SECOND_AND_FRACTIONAL_MASK) {
@@ -1755,27 +1844,16 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
         return i-1;
     }
 
-    /**
-     * 
-     */
-    private void complete() {
+    private void addCanonicalItems() {
         PatternInfo patternInfo = new PatternInfo();
         // make sure that every valid field occurs once, with a "default" length
         for (int i = 0; i < CANONICAL_ITEMS.length; ++i) {
-            //char c = (char)types[i][0];
             addPattern(String.valueOf(CANONICAL_ITEMS[i]), false, patternInfo);
         }
-        //isComplete = true;
-    }
-    {
-        complete();
     }
 
-    /**
-     * 
-     */
     private PatternWithMatcher getBestRaw(DateTimeMatcher source, int includeMask, DistanceInfo missingFields, DateTimeMatcher skipMatcher) {
-        //      if (SHOW_DISTANCE) System.out.println("Searching for: " + source.pattern 
+        //      if (SHOW_DISTANCE) System.out.println("Searching for: " + source.pattern
         //      + ", mask: " + showMask(includeMask));
         int bestDistance = Integer.MAX_VALUE;
         PatternWithMatcher bestPatternWithMatcher = new PatternWithMatcher("", null);
@@ -1785,7 +1863,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
                 continue;
             }
             int distance = source.getDistance(trial, includeMask, tempInfo);
-            //          if (SHOW_DISTANCE) System.out.println("\tDistance: " + trial.pattern + ":\t" 
+            //          if (SHOW_DISTANCE) System.out.println("\tDistance: " + trial.pattern + ":\t"
             //          + distance + ",\tmissing fields: " + tempInfo);
             if (distance < bestDistance) {
                 bestDistance = distance;
@@ -1811,8 +1889,8 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
      * @param fixFractionalSeconds TODO
      */
     // flags values
-    private enum DTPGflags { 
-        FIX_FRACTIONAL_SECONDS, 
+    private enum DTPGflags {
+        FIX_FRACTIONAL_SECONDS,
         SKELETON_USES_CAP_J,
         SKELETON_USES_b,
         SKELETON_USES_B,
@@ -1836,7 +1914,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
                 newPattern.append(fp.quoteLiteral((String)item));
             } else {
                 final VariableField variableField = (VariableField) item;
-                
+
                 StringBuilder fieldBuilder = new StringBuilder(variableField.toString());
                 //                int canonicalIndex = getCanonicalIndex(field, true);
                 //                if (canonicalIndex < 0) {
@@ -1844,9 +1922,9 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
                 //                }
                 //                int type = types[canonicalIndex][1];
                 int type = variableField.getType();
-                
+
                 // handle special day periods
-                if (type == DAYPERIOD 
+                if (type == DAYPERIOD
                         && !flags.isEmpty()) {
                     char c = flags.contains(DTPGflags.SKELETON_USES_b) ? 'b' : flags.contains(DTPGflags.SKELETON_USES_B) ? 'B' : '0';
                     if (c != '0') {
@@ -1857,11 +1935,10 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
                         }
                     }
                 }
-                
+
                 if (flags.contains(DTPGflags.FIX_FRACTIONAL_SECONDS) && type == SECOND) {
-                    String newField = inputRequest.original[FRACTIONAL_SECOND];
                     fieldBuilder.append(decimal);
-                    fieldBuilder.append(newField);
+                    inputRequest.original.appendFieldTo(FRACTIONAL_SECOND, fieldBuilder);
                 } else if (inputRequest.type[type] != 0) {
                     // Here:
                     // - "reqField" is the field from the originally requested skeleton, with length
@@ -1887,9 +1964,9 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
                     // Old behavior was:
                     // normally we just replace the field. However HOUR is special; we only change the length
 
-                    String reqField = inputRequest.original[type];
-                    int reqFieldLen = reqField.length();
-                    if ( reqField.charAt(0) == 'E' && reqFieldLen < 3 ) {
+                    char reqFieldChar = inputRequest.original.getFieldChar(type);
+                    int reqFieldLen = inputRequest.original.getFieldLength(type);
+                    if ( reqFieldChar == 'E' && reqFieldLen < 3 ) {
                         reqFieldLen = 3; // 1-3 for E are equivalent to 3 for c,e
                     }
                     int adjFieldLen = reqFieldLen;
@@ -1899,16 +1976,22 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
                             (type == SECOND && (options & MATCH_SECOND_FIELD_LENGTH)==0) ) {
                         adjFieldLen = fieldBuilder.length();
                     } else if (matcherWithSkeleton != null) {
-                        String skelField = matcherWithSkeleton.origStringForField(type);
-                        int skelFieldLen = skelField.length();
+                        int skelFieldLen = matcherWithSkeleton.original.getFieldLength(type);
                         boolean patFieldIsNumeric = variableField.isNumeric();
                         boolean skelFieldIsNumeric = matcherWithSkeleton.fieldIsNumeric(type);
-                        if (skelFieldLen == reqFieldLen || (patFieldIsNumeric && !skelFieldIsNumeric) || (skelFieldIsNumeric && !patFieldIsNumeric)) {
+                        if (skelFieldLen == reqFieldLen
+                                || (patFieldIsNumeric && !skelFieldIsNumeric)
+                                || (skelFieldIsNumeric && !patFieldIsNumeric)) {
                             // don't adjust the field length in the found pattern
                             adjFieldLen = fieldBuilder.length();
                         }
                     }
-                    char c = (type != HOUR && type != MONTH && type != WEEKDAY && (type != YEAR || reqField.charAt(0)=='Y')) ? reqField.charAt(0) : fieldBuilder.charAt(0);
+                    char c = (type != HOUR
+                            && type != MONTH
+                            && type != WEEKDAY
+                            && (type != YEAR || reqFieldChar=='Y'))
+                            ? reqFieldChar
+                            : fieldBuilder.charAt(0);
                     if (type == HOUR && flags.contains(DTPGflags.SKELETON_USES_CAP_J)) {
                         c = defaultHourFormatChar;
                     }
@@ -1965,34 +2048,34 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
     }
 
     private static final String[] CLDR_FIELD_APPEND = {
-        "Era", "Year", "Quarter", "Month", "Week", "*", "Day-Of-Week", 
-        "Day", "*", "*", "*", 
+        "Era", "Year", "Quarter", "Month", "Week", "*", "Day-Of-Week",
+        "Day", "*", "*", "*",
         "Hour", "Minute", "Second", "*", "Timezone"
     };
 
     private static final String[] CLDR_FIELD_NAME = {
-        "era", "year", "*", "month", "week", "*", "weekday", 
-        "day", "*", "*", "dayperiod", 
+        "era", "year", "*", "month", "week", "*", "weekday",
+        "day", "*", "*", "dayperiod",
         "hour", "minute", "second", "*", "zone"
     };
 
     private static final String[] FIELD_NAME = {
-        "Era", "Year", "Quarter", "Month", "Week_in_Year", "Week_in_Month", "Weekday", 
-        "Day", "Day_Of_Year", "Day_of_Week_in_Month", "Dayperiod", 
+        "Era", "Year", "Quarter", "Month", "Week_in_Year", "Week_in_Month", "Weekday",
+        "Day", "Day_Of_Year", "Day_of_Week_in_Month", "Dayperiod",
         "Hour", "Minute", "Second", "Fractional_Second", "Zone"
     };
 
 
     private static final String[] CANONICAL_ITEMS = {
-        "G", "y", "Q", "M", "w", "W", "E", 
-        "d", "D", "F", 
+        "G", "y", "Q", "M", "w", "W", "E",
+        "d", "D", "F",
         "H", "m", "s", "S", "v"
     };
 
     private static final Set<String> CANONICAL_SET = new HashSet<String>(Arrays.asList(CANONICAL_ITEMS));
     private Set<String> cldrAvailableFormatKeys = new HashSet<String>(20);
 
-    private static final int 
+    private static final int
     DATE_MASK = (1<<DAYPERIOD) - 1,
     TIME_MASK = (1<<TYPE_LIMIT) - 1 - DATE_MASK;
 
@@ -2007,14 +2090,15 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
     MISSING_FIELD = 0x1000;
 
 
-    static private String getName(String s) {
+    private static String getName(String s) {
         int i = getCanonicalIndex(s, true);
         String name = FIELD_NAME[types[i][1]];
-        int subtype = types[i][2];
-        boolean string = subtype < 0;
-        if (string) subtype = -subtype;
-        if (subtype < 0) name += ":S";
-        else name += ":N";
+        if (types[i][2] < 0) {
+            name += ":S"; // string
+        }
+        else {
+            name += ":N";
+        }
         return name;
     }
 
@@ -2032,7 +2116,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
         //      verify that all are the same character
         for (int i = 1; i < len; ++i) {
             if (s.charAt(i) != ch) {
-                return -1; 
+                return -1;
             }
         }
         int bestRow = -1;
@@ -2047,6 +2131,25 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
         return strict ? -1 : bestRow;
     }
 
+    /**
+     * Gets the canonical character associated with the specified field (ERA, YEAR, etc).
+     */
+    private static char getCanonicalChar(int field, char reference) {
+        // Special case: distinguish between 12-hour and 24-hour
+        if (reference == 'h' || reference == 'K') {
+            return 'h';
+        }
+
+        // Linear search over types (return the top entry for each field)
+        for (int i = 0; i < types.length; ++i) {
+            int[] row = types[i];
+            if (row[1] == field) {
+                return (char) row[0];
+            }
+        }
+        throw new IllegalArgumentException("Could not find field " + field);
+    }
+
     private static final int[][] types = {
         // the order here makes a difference only when searching for single field.
         // format is:
@@ -2133,107 +2236,201 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
         {'x', ZONE, LONG - DELTA, 4},
     };
 
+
+    /**
+     * A compact storage mechanism for skeleton field strings.  Several dozen of these will be created
+     * for a typical DateTimePatternGenerator instance.
+     * @author sffc
+     */
+    private static class SkeletonFields {
+        private byte[] chars = new byte[TYPE_LIMIT];
+        private byte[] lengths = new byte[TYPE_LIMIT];
+        private static final byte DEFAULT_CHAR = '\0';
+        private static final byte DEFAULT_LENGTH = 0;
+
+        public void clear() {
+            Arrays.fill(chars, DEFAULT_CHAR);
+            Arrays.fill(lengths, DEFAULT_LENGTH);
+        }
+
+        void copyFieldFrom(SkeletonFields other, int field) {
+            chars[field] = other.chars[field];
+            lengths[field] = other.lengths[field];
+        }
+
+        void clearField(int field) {
+            chars[field] = DEFAULT_CHAR;
+            lengths[field] = DEFAULT_LENGTH;
+        }
+
+        char getFieldChar(int field) {
+            return (char) chars[field];
+        }
+
+        int getFieldLength(int field) {
+            return lengths[field];
+        }
+
+        void populate(int field, String value) {
+            // Ensure no loss in character data
+            for (char ch : value.toCharArray()) {
+                assert ch == value.charAt(0);
+            }
+
+            populate(field, value.charAt(0), value.length());
+        }
+
+        void populate(int field, char ch, int length) {
+            assert ch <= Byte.MAX_VALUE;
+            assert length <= Byte.MAX_VALUE;
+
+            chars[field] = (byte) ch;
+            lengths[field] = (byte) length;
+        }
+
+        public boolean isFieldEmpty(int field) {
+            return lengths[field] == DEFAULT_LENGTH;
+        }
+
+        @Override
+        public String toString() {
+            return appendTo(new StringBuilder()).toString();
+        }
+
+        public String toCanonicalString() {
+            return appendTo(new StringBuilder(), true).toString();
+        }
+
+        public StringBuilder appendTo(StringBuilder sb) {
+            return appendTo(sb, false);
+        }
+
+        private StringBuilder appendTo(StringBuilder sb, boolean canonical) {
+            for (int i=0; i<TYPE_LIMIT; ++i) {
+                appendFieldTo(i, sb, canonical);
+            }
+            return sb;
+        }
+
+        public StringBuilder appendFieldTo(int field, StringBuilder sb) {
+            return appendFieldTo(field, sb, false);
+        }
+
+        private StringBuilder appendFieldTo(int field, StringBuilder sb, boolean canonical) {
+            char ch = (char) chars[field];
+            int length = lengths[field];
+
+            if (canonical) {
+                ch = getCanonicalChar(field, ch);
+            }
+
+            for (int i=0; i<length; i++) {
+                sb.append(ch);
+            }
+            return sb;
+        }
+
+        public int compareTo(SkeletonFields other) {
+            for (int i = 0; i < TYPE_LIMIT; ++i) {
+                int charDiff = chars[i] - other.chars[i];
+                if (charDiff != 0) {
+                    return charDiff;
+                }
+                int lengthDiff = lengths[i] - other.lengths[i];
+                if (lengthDiff != 0) {
+                    return lengthDiff;
+                }
+            }
+            return 0;
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            return this == other || (other != null && other instanceof SkeletonFields
+                && compareTo((SkeletonFields) other) == 0);
+        }
+
+        @Override
+        public int hashCode() {
+            return Arrays.hashCode(chars) ^ Arrays.hashCode(lengths);
+        }
+    }
+
+
     private static class DateTimeMatcher implements Comparable<DateTimeMatcher> {
         //private String pattern = null;
         private int[] type = new int[TYPE_LIMIT];
-        private String[] original = new String[TYPE_LIMIT];
-        private String[] baseOriginal = new String[TYPE_LIMIT];
+        private SkeletonFields original = new SkeletonFields();
+        private SkeletonFields baseOriginal = new SkeletonFields();
 
         // just for testing; fix to make multi-threaded later
         // private static FormatParser fp = new FormatParser();
 
-        public String origStringForField(int field) {
-            return original[field];
-        }
-
         public boolean fieldIsNumeric(int field) {
             return type[field] > 0;
         }
 
+        @Override
         public String toString() {
-            StringBuilder result = new StringBuilder();
-            for (int i = 0; i < TYPE_LIMIT; ++i) {
-                if (original[i].length() != 0) result.append(original[i]);
-            }
-            return result.toString();
+            return original.toString();
         }
 
         // returns a string like toString but using the canonical character for most types,
         // e.g. M for M or L, E for E or c, y for y or U, etc. The hour field is canonicalized
         // to 'H' (for 24-hour types) or 'h' (for 12-hour types)
         public String toCanonicalString() {
-            StringBuilder result = new StringBuilder();
-            for (int i = 0; i < TYPE_LIMIT; ++i) {
-                if (original[i].length() != 0) {
-                    // append a string of the same length using the canonical character
-                    for (int j = 0; j < types.length; ++j) {
-                        int[] row = types[j];
-                        if (row[1] == i) {
-                            char originalChar = original[i].charAt(0);
-                            char repeatChar = (originalChar=='h' || originalChar=='K')? 'h': (char)row[0];
-                            result.append(Utility.repeat(String.valueOf(repeatChar), original[i].length()));
-                            break;
-                        }
-                    }
-                }
-            }
-            return result.toString();
+            return original.toCanonicalString();
         }
 
         String getBasePattern() {
-            StringBuilder result = new StringBuilder();
-            for (int i = 0; i < TYPE_LIMIT; ++i) {
-                if (baseOriginal[i].length() != 0) result.append(baseOriginal[i]);
-            }
-            return result.toString();
+            return baseOriginal.toString();
         }
 
         DateTimeMatcher set(String pattern, FormatParser fp, boolean allowDuplicateFields) {
-            for (int i = 0; i < TYPE_LIMIT; ++i) {
-                type[i] = NONE;
-                original[i] = "";
-                baseOriginal[i] = "";
-            }
+            // Reset any data stored in this instance
+            Arrays.fill(type, NONE);
+            original.clear();
+            baseOriginal.clear();
+
             fp.set(pattern);
             for (Object obj : fp.getItems()) {
                 if (!(obj instanceof VariableField)) {
                     continue;
                 }
                 VariableField item = (VariableField)obj;
-                String field = item.toString();
-                if (field.charAt(0) == 'a') continue; // skip day period, special case
+                String value = item.toString();
+                if (value.charAt(0) == 'a') continue; // skip day period, special case
                 int canonicalIndex = item.getCanonicalIndex();
                 //                if (canonicalIndex < 0) {
                 //                    throw new IllegalArgumentException("Illegal field:\t"
                 //                            + field + "\t in " + pattern);
                 //                }
                 int[] row = types[canonicalIndex];
-                int typeValue = row[1];
-                if (original[typeValue].length() != 0) {
+                int field = row[1];
+                if (!original.isFieldEmpty(field)) {
+                    char ch1 = original.getFieldChar(field);
+                    char ch2 = value.charAt(0);
                     if ( allowDuplicateFields ||
-                            (original[typeValue].charAt(0) == 'r' && field.charAt(0) == 'U') ||
-                            (original[typeValue].charAt(0) == 'U' && field.charAt(0) == 'r') ) {
+                            (ch1 == 'r' && ch2 == 'U') ||
+                            (ch1 == 'U' && ch2 == 'r') ) {
                         continue;
                     }
                     throw new IllegalArgumentException("Conflicting fields:\t"
-                            + original[typeValue] + ", " + field + "\t in " + pattern);
+                            + ch1 + ", " + value + "\t in " + pattern);
                 }
-                original[typeValue] = field;
+                original.populate(field, value);
                 char repeatChar = (char)row[0];
                 int repeatCount = row[3];
                 // #7930 removes hack to cap repeatCount at 3
                 if ("GEzvQ".indexOf(repeatChar) >= 0) repeatCount = 1;
-                baseOriginal[typeValue] = Utility.repeat(String.valueOf(repeatChar),repeatCount);
-                int subTypeValue = row[2];
-                if (subTypeValue > 0) subTypeValue += field.length();
-                type[typeValue] = subTypeValue;
+                baseOriginal.populate(field, repeatChar, repeatCount);
+                int subField = row[2];
+                if (subField > 0) subField += value.length();
+                type[field] = subField;
             }
             return this;
         }
 
-        /**
-         * 
-         */
         int getFieldMask() {
             int result = 0;
             for (int i = 0; i < type.length; ++i) {
@@ -2242,18 +2439,15 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
             return result;
         }
 
-        /**
-         * 
-         */
         @SuppressWarnings("unused")
         void extractFrom(DateTimeMatcher source, int fieldMask) {
             for (int i = 0; i < type.length; ++i) {
                 if ((fieldMask & (1<<i)) != 0) {
                     type[i] = source.type[i];
-                    original[i] = source.original[i];
+                    original.copyFieldFrom(source.original, i);
                 } else {
                     type[i] = NONE;
-                    original[i] = "";
+                    original.clearField(i);
                 }
             }
         }
@@ -2261,7 +2455,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
         int getDistance(DateTimeMatcher other, int includeMask, DistanceInfo distanceInfo) {
             int result = 0;
             distanceInfo.clear();
-            for (int i = 0; i < type.length; ++i) {
+            for (int i = 0; i < TYPE_LIMIT; ++i) {
                 int myType = (includeMask & (1<<i)) == 0 ? 0 : type[i];
                 int otherType = other.type[i];
                 if (myType == otherType) continue; // identical (maybe both zero) add 0
@@ -2278,30 +2472,21 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
             return result;
         }
 
+        @Override
         public int compareTo(DateTimeMatcher that) {
-            for (int i = 0; i < original.length; ++i) {
-                int comp = original[i].compareTo(that.original[i]);
-                if (comp != 0) return -comp;
-            }
-            return 0;
+            int result = original.compareTo(that.original);
+            return result > 0 ? -1 : result < 0 ? 1 : 0; // Reverse the order.
         }
 
+        @Override
         public boolean equals(Object other) {
-            if (!(other instanceof DateTimeMatcher)) {
-                return false;
-            }
-            DateTimeMatcher that = (DateTimeMatcher) other;
-            for (int i = 0; i < original.length; ++i) {
-                if (!original[i].equals(that.original[i])) return false;
-            }
-            return true;
-        }       
+            return this == other || (other != null && other instanceof DateTimeMatcher
+                && original.equals(((DateTimeMatcher) other).original));
+        }
+
+        @Override
         public int hashCode() {
-            int result = 0;
-            for (int i = 0; i < original.length; ++i) {
-                result ^= original[i].hashCode();
-            }
-            return result;
+            return original.hashCode();
         }
     }
 
@@ -2311,9 +2496,6 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
         void clear() {
             missingFieldMask = extraFieldMask = 0;
         }
-        /**
-         * 
-         */
         void setTo(DistanceInfo other) {
             missingFieldMask = other.missingFieldMask;
             extraFieldMask = other.extraFieldMask;
@@ -2324,6 +2506,7 @@ public class DateTimePatternGenerator implements Freezable<DateTimePatternGenera
         void addExtra(int field) {
             extraFieldMask |= (1<<field);
         }
+        @Override
         public String toString() {
             return "missingFieldMask: " + DateTimePatternGenerator.showMask(missingFieldMask)
                     + ", extraFieldMask: " + DateTimePatternGenerator.showMask(extraFieldMask);
diff --git a/app/src/main/java/com/ibm/icu/text/DecimalFormat.java b/icu4j/src/main/java/com/ibm/icu/text/DecimalFormat.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/text/DecimalFormat.java
rename to icu4j/src/main/java/com/ibm/icu/text/DecimalFormat.java
index 6a2cf62..23fc816 100644
--- a/app/src/main/java/com/ibm/icu/text/DecimalFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/DecimalFormat.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and
@@ -843,6 +845,9 @@ public class DecimalFormat extends NumberFormat {
             }
 
             result.append(symbols.getNaN());
+            // TODO: Combine setting a single FieldPosition or adding to an AttributedCharacterIterator
+            // into a function like recordAttribute(FieldAttribute, begin, end).
+
             // [Spark/CDL] Add attribute for NaN here.
             // result.append(symbols.getNaN());
             if (parseAttr) {
@@ -891,9 +896,9 @@ public class DecimalFormat extends NumberFormat {
             addPadding(result, fieldPosition, prefixLen, suffixLen);
             return result;
         }
-        
+
         int precision = precision(false);
-        
+
         // This is to fix rounding for scientific notation. See ticket:10542.
         // This code should go away when a permanent fix is done for ticket:9931.
         //
@@ -952,7 +957,7 @@ public class DecimalFormat extends NumberFormat {
         }
         return toDigitList(number).getDouble();
     }
-    
+
     @Deprecated
     DigitList toDigitList(double number) {
         DigitList result = new DigitList();
@@ -1124,7 +1129,7 @@ public class DecimalFormat extends NumberFormat {
             digitList.set(number, precision(true));
             // Issue 11808
             if (digitList.wasRounded() && roundingMode == BigDecimal.ROUND_UNNECESSARY) {
-                throw new ArithmeticException("Rounding necessary");              
+                throw new ArithmeticException("Rounding necessary");
             }
             return subformat(number, result, fieldPosition, isNegative, true, parseAttr);
         }
@@ -1159,7 +1164,7 @@ public class DecimalFormat extends NumberFormat {
             digitList.set(number, precision(true));
             // For issue 11808.
             if (digitList.wasRounded() && roundingMode == BigDecimal.ROUND_UNNECESSARY) {
-                throw new ArithmeticException("Rounding necessary");              
+                throw new ArithmeticException("Rounding necessary");
             }
             return subformat(number.intValue(), result, fieldPosition, number.signum() < 0, true,
                              parseAttr);
@@ -1193,7 +1198,7 @@ public class DecimalFormat extends NumberFormat {
                           !areSignificantDigitsUsed());
             // For issue 11808.
             if (digitList.wasRounded() && roundingMode == BigDecimal.ROUND_UNNECESSARY) {
-                throw new ArithmeticException("Rounding necessary");              
+                throw new ArithmeticException("Rounding necessary");
             }
             return subformat(number.doubleValue(), result, fieldPosition, number.signum() < 0,
                              false, parseAttr);
@@ -1226,7 +1231,7 @@ public class DecimalFormat extends NumberFormat {
                           !areSignificantDigitsUsed());
             // For issue 11808.
             if (digitList.wasRounded() && roundingMode == BigDecimal.ROUND_UNNECESSARY) {
-                throw new ArithmeticException("Rounding necessary");              
+                throw new ArithmeticException("Rounding necessary");
             }
             return subformat(number.doubleValue(), result, fieldPosition, number.signum() < 0,
                              false, false);
@@ -1287,7 +1292,7 @@ public class DecimalFormat extends NumberFormat {
         // get the visible fractions and the number of fraction digits.
        return getFixedDecimal(number, digitList);
     }
-    
+
     FixedDecimal getFixedDecimal(double number, DigitList dl) {
         int fractionalDigitsInDigitList = dl.count - dl.decimalAt;
         int v;
@@ -1416,12 +1421,12 @@ public class DecimalFormat extends NumberFormat {
             FieldPosition fieldPosition,
             boolean isInteger,
             boolean parseAttr) {
-        char [] digits = symbols.getDigitsLocal();
+        String[] digits = symbols.getDigitStrings();
 
-        char grouping = currencySignCount == CURRENCY_SIGN_COUNT_ZERO ?
-                symbols.getGroupingSeparator(): symbols.getMonetaryGroupingSeparator();
-        char decimal = currencySignCount == CURRENCY_SIGN_COUNT_ZERO ?
-                symbols.getDecimalSeparator() : symbols.getMonetaryDecimalSeparator();
+        String grouping = currencySignCount == CURRENCY_SIGN_COUNT_ZERO ?
+                symbols.getGroupingSeparatorString(): symbols.getMonetaryGroupingSeparatorString();
+        String decimal = currencySignCount == CURRENCY_SIGN_COUNT_ZERO ?
+                symbols.getDecimalSeparatorString() : symbols.getMonetaryDecimalSeparatorString();
         boolean useSigDig = areSignificantDigitsUsed();
         int maxIntDig = getMaximumIntegerDigits();
         int minIntDig = getMinimumIntegerDigits();
@@ -1429,10 +1434,9 @@ public class DecimalFormat extends NumberFormat {
         // [Spark/CDL] Record the integer start index.
         int intBegin = result.length();
         // Record field information for caller.
-        if (fieldPosition.getField() == NumberFormat.INTEGER_FIELD) {
-            fieldPosition.setBeginIndex(result.length());
-        } else if (fieldPosition.getFieldAttribute() == NumberFormat.Field.INTEGER) {
-            fieldPosition.setBeginIndex(result.length());
+        if (fieldPosition.getField() == NumberFormat.INTEGER_FIELD ||
+                fieldPosition.getFieldAttribute() == NumberFormat.Field.INTEGER) {
+            fieldPosition.setBeginIndex(intBegin);
         }
         long fractionalDigits = 0;
         int fractionalDigitsCount = 0;
@@ -1484,27 +1488,32 @@ public class DecimalFormat extends NumberFormat {
             if (isGroupingPosition(i)) {
                 result.append(grouping);
                 // [Spark/CDL] Add grouping separator attribute here.
+                // Set only for the first instance.
+                // Length of grouping separator is 1.
+                if (fieldPosition.getFieldAttribute() == Field.GROUPING_SEPARATOR &&
+                        fieldPosition.getBeginIndex() == 0 && fieldPosition.getEndIndex() == 0) {
+                    fieldPosition.setBeginIndex(result.length()-1);
+                    fieldPosition.setEndIndex(result.length());
+                }
                 if (parseAttr) {
-                    // Length of grouping separator is 1.
                     addAttribute(Field.GROUPING_SEPARATOR, result.length() - 1, result.length());
                 }
             }
         }
 
         // Record field information for caller.
-        if (fieldPosition.getField() == NumberFormat.INTEGER_FIELD) {
-            fieldPosition.setEndIndex(result.length());
-        } else if (fieldPosition.getFieldAttribute() == NumberFormat.Field.INTEGER) {
+        if (fieldPosition.getField() == NumberFormat.INTEGER_FIELD ||
+                fieldPosition.getFieldAttribute() == NumberFormat.Field.INTEGER) {
             fieldPosition.setEndIndex(result.length());
         }
-        
+
         // This handles the special case of formatting 0. For zero only, we count the
         // zero to the left of the decimal point as one signficant digit. Ordinarily we
         // do not count any leading 0's as significant. If the number we are formatting
         // is not zero, then either sigCount or digits.getCount() will be non-zero.
         if (sigCount == 0 && digitList.count == 0) {
           sigCount = 1;
-        }      
+        }
 
         // Determine whether or not there are any printable fractional digits. If
         // we've used up the digits we know there aren't.
@@ -1620,9 +1629,9 @@ public class DecimalFormat extends NumberFormat {
     private void subformatExponential(StringBuffer result,
             FieldPosition fieldPosition,
             boolean parseAttr) {
-        char [] digits = symbols.getDigitsLocal();
-        char decimal = currencySignCount == CURRENCY_SIGN_COUNT_ZERO ?
-                symbols.getDecimalSeparator() : symbols.getMonetaryDecimalSeparator();
+        String[] digits = symbols.getDigitStringsLocal();
+        String decimal = currencySignCount == CURRENCY_SIGN_COUNT_ZERO ?
+                symbols.getDecimalSeparatorString() : symbols.getMonetaryDecimalSeparatorString();
         boolean useSigDig = areSignificantDigitsUsed();
         int maxIntDig = getMaximumIntegerDigits();
         int minIntDig = getMinimumIntegerDigits();
@@ -1640,7 +1649,6 @@ public class DecimalFormat extends NumberFormat {
             fieldPosition.setBeginIndex(-1);
         }
 
-
         // [Spark/CDL]
         // the begin index of integer part
         // the end index of integer part
@@ -1716,14 +1724,20 @@ public class DecimalFormat extends NumberFormat {
                     intEnd = result.length();
                     addAttribute(Field.INTEGER, intBegin, result.length());
                 }
+                if (fieldPosition.getFieldAttribute() == Field.DECIMAL_SEPARATOR) {
+                    fieldPosition.setBeginIndex(result.length());
+                }
                 result.append(decimal);
+                if (fieldPosition.getFieldAttribute() == Field.DECIMAL_SEPARATOR) {
+                    fieldPosition.setEndIndex(result.length());
+                }
                 // [Spark/CDL] Add attribute for decimal separator
+                fracBegin = result.length();
                 if (parseAttr) {
                     // Length of decimal separator is 1.
                     int decimalSeparatorBegin = result.length() - 1;
                     addAttribute(Field.DECIMAL_SEPARATOR, decimalSeparatorBegin,
                                  result.length());
-                    fracBegin = result.length();
                 }
                 // Record field information for caller.
                 if (fieldPosition.getField() == NumberFormat.FRACTION_FIELD) {
@@ -1748,6 +1762,22 @@ public class DecimalFormat extends NumberFormat {
             result.append(digits[0]);
         }
 
+        // add the decimal separator if it is to be always shown AND there are no decimal digits
+        if ((fracBegin == -1) && this.decimalSeparatorAlwaysShown) {
+            if (fieldPosition.getFieldAttribute() == Field.DECIMAL_SEPARATOR) {
+                fieldPosition.setBeginIndex(result.length());
+            }
+            result.append(decimal);
+            if (fieldPosition.getFieldAttribute() == Field.DECIMAL_SEPARATOR) {
+                fieldPosition.setEndIndex(result.length());
+            }
+            if (parseAttr) {
+                // Length of decimal separator is 1.
+                int decimalSeparatorBegin = result.length() - 1;
+                addAttribute(Field.DECIMAL_SEPARATOR, decimalSeparatorBegin, result.length());
+            }
+        }
+
         // Record field information
         if (fieldPosition.getField() == NumberFormat.INTEGER_FIELD) {
             if (fieldPosition.getEndIndex() < 0) {
@@ -1772,7 +1802,7 @@ public class DecimalFormat extends NumberFormat {
             ((UFieldPosition) fieldPosition).setFractionDigits(fractionalDigitsCount, fractionalDigits);
         }
 
-        // [Spark/CDL] Calcuate the end index of integer part and fractional
+        // [Spark/CDL] Calculate the end index of integer part and fractional
         // part if they are not properly processed yet.
         if (parseAttr) {
             if (intEnd < 0) {
@@ -1786,7 +1816,14 @@ public class DecimalFormat extends NumberFormat {
         // The exponent is output using the pattern-specified minimum exponent
         // digits. There is no maximum limit to the exponent digits, since truncating
         // the exponent would result in an unacceptable inaccuracy.
+        if (fieldPosition.getFieldAttribute() == Field.EXPONENT_SYMBOL) {
+            fieldPosition.setBeginIndex(result.length());
+        }
+
         result.append(symbols.getExponentSeparator());
+        if (fieldPosition.getFieldAttribute() == Field.EXPONENT_SYMBOL) {
+            fieldPosition.setEndIndex(result.length());
+        }
         // [Spark/CDL] For exponent symbol, add an attribute.
         if (parseAttr) {
             addAttribute(Field.EXPONENT_SYMBOL, result.length() -
@@ -1801,7 +1838,13 @@ public class DecimalFormat extends NumberFormat {
         boolean negativeExponent = exponent < 0;
         if (negativeExponent) {
             exponent = -exponent;
-            result.append(symbols.getMinusString());
+            if (fieldPosition.getFieldAttribute() == Field.EXPONENT_SIGN) {
+                fieldPosition.setBeginIndex(result.length());
+            }
+            result.append(symbols.getMinusSignString());
+            if (fieldPosition.getFieldAttribute() == Field.EXPONENT_SIGN) {
+                fieldPosition.setEndIndex(result.length());
+            }
             // [Spark/CDL] If exponent has sign, then add an exponent sign
             // attribute.
             if (parseAttr) {
@@ -1809,7 +1852,13 @@ public class DecimalFormat extends NumberFormat {
                 addAttribute(Field.EXPONENT_SIGN, result.length() - 1, result.length());
             }
         } else if (exponentSignAlwaysShown) {
-            result.append(symbols.getPlusString());
+            if (fieldPosition.getFieldAttribute() == Field.EXPONENT_SIGN) {
+                fieldPosition.setBeginIndex(result.length());
+            }
+            result.append(symbols.getPlusSignString());
+            if (fieldPosition.getFieldAttribute() == Field.EXPONENT_SIGN) {
+                fieldPosition.setEndIndex(result.length());
+            }
             // [Spark/CDL] Add an plus sign attribute.
             if (parseAttr) {
                 // Length of exponent sign is 1.
@@ -1832,6 +1881,10 @@ public class DecimalFormat extends NumberFormat {
                           : digits[0]);
         }
         // [Spark/CDL] Add attribute for exponent part.
+        if (fieldPosition.getFieldAttribute() == Field.EXPONENT) {
+            fieldPosition.setBeginIndex(expBegin);
+            fieldPosition.setEndIndex(result.length());
+        }
         if (parseAttr) {
             addAttribute(Field.EXPONENT, expBegin, result.length());
         }
@@ -2300,7 +2353,7 @@ public class DecimalFormat extends NumberFormat {
                 0xFF0C, 0xFF0C,
                 0xFF0E, 0xFF0E,
                 0xFF61, 0xFF61).freeze();
-    
+
     static final UnicodeSet minusSigns =
         new UnicodeSet(
                 0x002D, 0x002D,
@@ -2310,7 +2363,7 @@ public class DecimalFormat extends NumberFormat {
                 0x2796, 0x2796,
                 0xFE63, 0xFE63,
                 0xFF0D, 0xFF0D).freeze();
-    
+
     static final UnicodeSet plusSigns =
             new UnicodeSet(
                 0x002B, 0x002B,
@@ -2320,7 +2373,7 @@ public class DecimalFormat extends NumberFormat {
                 0xFB29, 0xFB29,
                 0xFE62, 0xFE62,
                 0xFF0B, 0xFF0B).freeze();
-    
+
     // equivalent grouping and decimal support
     static final boolean skipExtendedSeparatorParsing = ICUConfig.get(
         "com.ibm.icu.text.DecimalFormat.SkipExtendedSeparatorParsing", "false")
@@ -2407,25 +2460,22 @@ public class DecimalFormat extends NumberFormat {
             // DigitList, and adjust the exponent as needed.
 
             digits.decimalAt = digits.count = 0;
-            char [] digitSymbols = symbols.getDigitsLocal();
-            char decimal = (currencySignCount == CURRENCY_SIGN_COUNT_ZERO) ?
-                    symbols.getDecimalSeparator() : symbols.getMonetaryDecimalSeparator();
-            char grouping = (currencySignCount == CURRENCY_SIGN_COUNT_ZERO) ?
-                    symbols.getGroupingSeparator() : symbols.getMonetaryGroupingSeparator();
+            String decimal = (currencySignCount == CURRENCY_SIGN_COUNT_ZERO) ?
+                    symbols.getDecimalSeparatorString() : symbols.getMonetaryDecimalSeparatorString();
+            String grouping = (currencySignCount == CURRENCY_SIGN_COUNT_ZERO) ?
+                    symbols.getGroupingSeparatorString() : symbols.getMonetaryGroupingSeparatorString();
 
             String exponentSep = symbols.getExponentSeparator();
             boolean sawDecimal = false;
             boolean sawGrouping = false;
-            boolean sawExponent = false;
             boolean sawDigit = false;
             long exponent = 0; // Set to the exponent value, if any
-            int digit = 0;
 
             // strict parsing
             boolean strictParse = isParseStrict();
             boolean strictFail = false; // did we exit with a strict parse failure?
             int lastGroup = -1; // where did we last see a grouping separator?
-            int digitStart = position; // where did the digit start?
+            int groupedDigitCount = 0;  // tracking count of digits delimited by grouping separator
             int gs2 = groupingSize2 == 0 ? groupingSize : groupingSize2;
 
             UnicodeSet decimalEquiv = skipExtendedSeparatorParsing ? UnicodeSet.EMPTY :
@@ -2437,136 +2487,137 @@ public class DecimalFormat extends NumberFormat {
             // the maximum allowable digits is reached.
             int digitCount = 0;
 
-            int backup = -1;
-            int ch;
-            for (; position < text.length(); position += UTF16.getCharCount(ch)) {
-                ch = UTF16.charAt(text,position);
-
-
-                // We recognize all digit ranges, not only the Latin digit range
-                // '0'..'9'. We do so by using the UCharacter.digit() method, which
-                // converts a valid Unicode digit to the range 0..9.
-                //
-                // The character 'ch' may be a digit. If so, place its value from 0 to 9
-                // in 'digit'. First try using the locale digit, which may or MAY NOT be a
-                // standard Unicode digit range. If this fails, try using the standard
-                // Unicode digit ranges by calling UCharacter.digit(). If this also fails,
-                // digit will have a value outside the range 0..9.
-                digit = ch - digitSymbols[0];
-                if (digit < 0 || digit > 9)
-                    digit = UCharacter.digit(ch, 10);
-                if (digit < 0 || digit > 9) {
-                    for ( digit = 0 ; digit < 10 ; digit++) {
-                        if ( ch == digitSymbols[digit] )
-                            break;
-                    }
-                }
+            int backup = -1;    // used for preserving the last confirmed position
+            int[] parsedDigit = {-1};   // allocates int[1] for parsing a single digit
 
-
-
-                if (digit == 0) {
+            while (position < text.length()) {
+                // Check if the sequence at the current position matches a decimal digit
+                int matchLen = matchesDigit(text, position, parsedDigit);
+                if (matchLen > 0) {
+                    // matched a digit
                     // Cancel out backup setting (see grouping handler below)
-                    if (strictParse && backup != -1) {
-                        // comma followed by digit, so group before comma is a secondary
-                        // group. If there was a group separator before that, the group
-                        // must == the secondary group length, else it can be <= the the
-                        // secondary group length.
-                        if ((lastGroup != -1 && countCodePoints(text, lastGroup, backup) - 1 != gs2)
-                                || (lastGroup == -1 && countCodePoints(text, digitStart, position) - 1 > gs2)) {
-                            strictFail = true;
-                            break;
+                    if (backup != -1) {
+                        if (strictParse) {
+                            // comma followed by digit, so group before comma is a secondary
+                            // group. If there was a group separator before that, the group
+                            // must == the secondary group length, else it can be <= the the
+                            // secondary group length.
+                            if ((lastGroup != -1 && groupedDigitCount != gs2)
+                                    || (lastGroup == -1 && groupedDigitCount > gs2)) {
+                                strictFail = true;
+                                break;
+                            }
                         }
                         lastGroup = backup;
+                        groupedDigitCount = 0;
                     }
-                    backup = -1; // Do this BEFORE continue statement below!!!
-                    sawDigit = true;
 
-                    // Handle leading zeros
-                    if (digits.count == 0) {
+                    groupedDigitCount++;
+                    position += matchLen;
+                    backup = -1;
+                    sawDigit = true;
+                    if (parsedDigit[0] == 0 && digits.count == 0) {
+                        // Handle leading zeros
                         if (!sawDecimal) {
                             // Ignore leading zeros in integer part of number.
                             continue;
                         }
-
                         // If we have seen the decimal, but no significant digits yet,
                         // then we account for leading zeros by decrementing the
                         // digits.decimalAt into negative values.
                         --digits.decimalAt;
                     } else {
                         ++digitCount;
-                        digits.append((char) (digit + '0'));
+                        digits.append((char) (parsedDigit[0] + '0'));
                     }
-                } else if (digit > 0 && digit <= 9) // [sic] digit==0 handled above
-                {
-                    if (strictParse) {
-                        if (backup != -1) {
-                            if ((lastGroup != -1 && countCodePoints(text, lastGroup, backup) - 1 != gs2)
-                                    || (lastGroup == -1 && countCodePoints(text, digitStart, position) - 1 > gs2)) {
-                                strictFail = true;
-                                break;
-                            }
-                            lastGroup = backup;
-                        }
-                    }
-
-                    sawDigit = true;
-                    ++digitCount;
-                    digits.append((char) (digit + '0'));
+                    continue;
+                }
 
-                    // Cancel out backup setting (see grouping handler below)
-                    backup = -1;
-                } else if (ch == decimal) {
+                // Check if the sequence at the current position matches locale's decimal separator
+                int decimalStrLen = decimal.length();
+                if (text.regionMatches(position, decimal, 0, decimalStrLen)) {
+                    // matched a decimal separator
                     if (strictParse) {
                         if (backup != -1 ||
-                            (lastGroup != -1 && countCodePoints(text,lastGroup,position) != groupingSize + 1)) {
+                            (lastGroup != -1 && groupedDigitCount != groupingSize)) {
                             strictFail = true;
                             break;
                         }
                     }
+
                     // If we're only parsing integers, or if we ALREADY saw the decimal,
                     // then don't parse this one.
                     if (isParseIntegerOnly() || sawDecimal) {
                         break;
                     }
+
                     digits.decimalAt = digitCount; // Not digits.count!
                     sawDecimal = true;
-                } else if (isGroupingUsed() && ch == grouping) {
-                    if (sawDecimal) {
-                        break;
-                    }
-                    if (strictParse) {
-                        if ((!sawDigit || backup != -1)) {
-                            // leading group, or two group separators in a row
-                            strictFail = true;
+                    position += decimalStrLen;
+                    continue;
+                }
+
+                if (isGroupingUsed()) {
+                    // Check if the sequence at the current position matches locale's grouping separator
+                    int groupingStrLen = grouping.length();
+                    if (text.regionMatches(position, grouping, 0, groupingStrLen)) {
+                        if (sawDecimal) {
                             break;
                         }
+
+                        if (strictParse) {
+                            if ((!sawDigit || backup != -1)) {
+                                // leading group, or two group separators in a row
+                                strictFail = true;
+                                break;
+                            }
+                        }
+
+                        // Ignore grouping characters, if we are using them, but require that
+                        // they be followed by a digit. Otherwise we backup and reprocess
+                        // them.
+                        backup = position;
+                        position += groupingStrLen;
+                        sawGrouping = true;
+                        continue;
                     }
-                    // Ignore grouping characters, if we are using them, but require that
-                    // they be followed by a digit. Otherwise we backup and reprocess
-                    // them.
-                    backup = position;
-                    sawGrouping = true;
-                } else if (!sawDecimal && decimalEquiv.contains(ch)) {
+                }
+
+                // Check if the code point at the current position matches one of decimal/grouping equivalent group chars
+                int cp = text.codePointAt(position);
+                if (!sawDecimal && decimalEquiv.contains(cp)) {
+                    // matched a decimal separator
                     if (strictParse) {
                         if (backup != -1 ||
-                            (lastGroup != -1 && countCodePoints(text,lastGroup,position) != groupingSize + 1)) {
+                            (lastGroup != -1 && groupedDigitCount != groupingSize)) {
                             strictFail = true;
                             break;
                         }
                     }
-                    // If we're only parsing integers, then don't parse this one.
-                    if (isParseIntegerOnly())
+
+                    // If we're only parsing integers, or if we ALREADY saw the decimal,
+                    // then don't parse this one.
+                    if (isParseIntegerOnly()) {
                         break;
+                    }
+
                     digits.decimalAt = digitCount; // Not digits.count!
 
                     // Once we see a decimal separator character, we only accept that
                     // decimal separator character from then on.
-                    decimal = (char) ch;
+                    decimal = String.valueOf(Character.toChars(cp));
+
                     sawDecimal = true;
-                } else if (isGroupingUsed() && !sawGrouping && groupEquiv.contains(ch)) {
+                    position += Character.charCount(cp);
+                    continue;
+                }
+
+                if (isGroupingUsed() && !sawGrouping && groupEquiv.contains(cp)) {
+                    // matched a grouping separator
                     if (sawDecimal) {
                         break;
                     }
+
                     if (strictParse) {
                         if ((!sawDigit || backup != -1)) {
                             // leading group, or two group separators in a row
@@ -2574,25 +2625,33 @@ public class DecimalFormat extends NumberFormat {
                             break;
                         }
                     }
+
                     // Once we see a grouping character, we only accept that grouping
                     // character from then on.
-                    grouping = (char) ch;
+                    grouping = String.valueOf(Character.toChars(cp));
 
                     // Ignore grouping characters, if we are using them, but require that
                     // they be followed by a digit. Otherwise we backup and reprocess
                     // them.
                     backup = position;
+                    position += Character.charCount(cp);
                     sawGrouping = true;
-                } else if (!sawExponent && text.regionMatches(true, position, exponentSep, 0, exponentSep.length())) {
-                    // Parse sign, if present
+                    continue;
+                }
+
+                // Check if the sequence at the current position matches locale's exponent separator
+                int exponentSepStrLen = exponentSep.length();
+                if (text.regionMatches(true, position, exponentSep, 0, exponentSepStrLen)) {
+                    // parse sign, if present
                     boolean negExp = false;
                     int pos = position + exponentSep.length();
                     if (pos < text.length()) {
-                        ch = UTF16.charAt(text,pos);
-                        if (ch == symbols.getPlusSign()) {
-                            ++pos;
-                        } else if (ch == symbols.getMinusSign()) {
-                            ++pos;
+                        String plusSign = symbols.getPlusSignString();
+                        String minusSign = symbols.getMinusSignString();
+                        if (text.regionMatches(pos, plusSign, 0, plusSign.length())) {
+                            pos += plusSign.length();
+                        } else if (text.regionMatches(pos, minusSign, 0, minusSign.length())) {
+                            pos += minusSign.length();
                             negExp = true;
                         }
                     }
@@ -2600,16 +2659,10 @@ public class DecimalFormat extends NumberFormat {
                     DigitList exponentDigits = new DigitList();
                     exponentDigits.count = 0;
                     while (pos < text.length()) {
-                        digit = UTF16.charAt(text,pos) - digitSymbols[0];
-                        if (digit < 0 || digit > 9) {
-                            // Can't parse "[1E0]" when pattern is "0.###E0;[0.###E0]"
-                            // Should update reassign the value of 'ch' in the code: digit
-                            // = Character.digit(ch, 10); [Richard/GCL]
-                            digit = UCharacter.digit(UTF16.charAt(text,pos), 10);
-                        }
-                        if (digit >= 0 && digit <= 9) {
-                            exponentDigits.append((char) (digit + '0'));
-                            pos += UTF16.getCharCount(UTF16.charAt(text,pos));
+                        int digitMatchLen = matchesDigit(text, pos, parsedDigit);
+                        if (digitMatchLen > 0) {
+                            exponentDigits.append((char) (parsedDigit[0] + '0'));
+                            pos += digitMatchLen;
                         } else {
                             break;
                         }
@@ -2617,11 +2670,9 @@ public class DecimalFormat extends NumberFormat {
 
                     if (exponentDigits.count > 0) {
                         // defer strict parse until we know we have a bona-fide exponent
-                        if (strictParse) {
-                            if (backup != -1 || lastGroup != -1) {
-                                strictFail = true;
-                                break;
-                            }
+                        if (strictParse && sawGrouping) {
+                            strictFail = true;
+                            break;
                         }
 
                         // Quick overflow check for exponential part.  Actual limit check
@@ -2642,33 +2693,34 @@ public class DecimalFormat extends NumberFormat {
                             }
                         }
                         position = pos; // Advance past the exponent
-                        sawExponent = true;
                     }
 
                     break; // Whether we fail or succeed, we exit this loop
-                } else {
-                    break;
                 }
+
+                // All other cases, stop parsing
+                break;
             }
 
-            if(digits.decimalAt == 0 && isDecimalPatternMatchRequired()) {
-                if(this.formatPattern.indexOf(decimal) != -1) {
+            if (digits.decimalAt == 0 && isDecimalPatternMatchRequired()) {
+                if (this.formatPattern.indexOf(decimal) != -1) {
                     parsePosition.setIndex(oldStart);
                     parsePosition.setErrorIndex(position);
                     return false;
                 }
             }
-            
+
             if (backup != -1)
                 position = backup;
 
             // If there was no decimal point we have an integer
-            if (!sawDecimal)
+            if (!sawDecimal) {
                 digits.decimalAt = digitCount; // Not digits.count!
+            }
 
             // check for strict parse errors
             if (strictParse && !sawDecimal) {
-                if (lastGroup != -1 && countCodePoints(text,lastGroup,position) != groupingSize + 1) {
+                if (lastGroup != -1 && groupedDigitCount != groupingSize) {
                     strictFail = true;
                 }
             }
@@ -2746,21 +2798,44 @@ public class DecimalFormat extends NumberFormat {
         return true;
     }
 
-    // Utility method used to count the number of codepoints
-    private int countCodePoints(String str,int start, int end) {
-        int count = 0;
-        int index = start;
-        while ( index < end ) {
-            count++;
-            index += UTF16.getCharCount(UTF16.charAt(str, index));
+    /**
+     * Check if the substring at the specified position matches a decimal digit.
+     * If matched, this method sets the decimal value to <code>decVal</code> and
+     * returns matched length.
+     *
+     * @param str       The input string
+     * @param start     The start index
+     * @param decVal    Receives decimal value
+     * @return          Length of match, or 0 if the sequence at the position is not
+     *                  a decimal digit.
+     */
+    private int matchesDigit(String str, int start, int[] decVal) {
+        String[] localeDigits = symbols.getDigitStringsLocal();
+
+        // Check if the sequence at the current position matches locale digits.
+        for (int i = 0; i < 10; i++) {
+            int digitStrLen = localeDigits[i].length();
+            if (str.regionMatches(start, localeDigits[i], 0, digitStrLen)) {
+                decVal[0] = i;
+                return digitStrLen;
+            }
+        }
+
+        // If no locale digit match, then check if this is a Unicode digit
+        int cp = str.codePointAt(start);
+        decVal[0] = UCharacter.digit(cp, 10);
+        if (decVal[0] >= 0) {
+            return Character.charCount(cp);
         }
-        return count;
+
+        return 0;
     }
+
     /**
      * Returns a set of characters equivalent to the given desimal separator used for
      * parsing number.  This method may return an empty set.
      */
-    private UnicodeSet getEquivalentDecimals(char decimal, boolean strictParse) {
+    private UnicodeSet getEquivalentDecimals(String decimal, boolean strictParse) {
         UnicodeSet equivSet = UnicodeSet.EMPTY;
         if (strictParse) {
             if (strictDotEquivalents.contains(decimal)) {
@@ -2830,31 +2905,31 @@ public class DecimalFormat extends NumberFormat {
     /**
      * Remove bidi marks from affix
      */
-    private static String trimMarksFromAffix(String affix) { 
-        boolean hasBidiMark = false; 
-        int idx = 0; 
-        for (; idx < affix.length(); idx++) { 
-            if (isBidiMark(affix.charAt(idx))) { 
-                hasBidiMark = true; 
-                break; 
-            } 
-        } 
-        if (!hasBidiMark) { 
-            return affix; 
-        } 
-
-        StringBuilder buf = new StringBuilder(); 
-        buf.append(affix, 0, idx); 
-        idx++;  // skip the first Bidi mark 
-        for (; idx < affix.length(); idx++) { 
-            char c = affix.charAt(idx); 
-            if (!isBidiMark(c)) { 
-                buf.append(c); 
-            } 
-        } 
-
-        return buf.toString(); 
-    } 
+    private static String trimMarksFromAffix(String affix) {
+        boolean hasBidiMark = false;
+        int idx = 0;
+        for (; idx < affix.length(); idx++) {
+            if (isBidiMark(affix.charAt(idx))) {
+                hasBidiMark = true;
+                break;
+            }
+        }
+        if (!hasBidiMark) {
+            return affix;
+        }
+
+        StringBuilder buf = new StringBuilder();
+        buf.append(affix, 0, idx);
+        idx++;  // skip the first Bidi mark
+        for (; idx < affix.length(); idx++) {
+            char c = affix.charAt(idx);
+            if (!isBidiMark(c)) {
+                buf.append(c);
+            }
+        }
+
+        return buf.toString();
+    }
 
     /**
      * Return the length matched by the given affix, or -1 if none. Runs of white space in
@@ -3030,6 +3105,8 @@ public class DecimalFormat extends NumberFormat {
                 continue;
             }
 
+            String affix = null;
+
             switch (c) {
             case CURRENCY_SIGN:
                 // since the currency names in choice format is saved the same way as
@@ -3079,15 +3156,27 @@ public class DecimalFormat extends NumberFormat {
                 }
                 continue;
             case PATTERN_PERCENT:
-                c = symbols.getPercent();
+                affix = symbols.getPercentString();
                 break;
             case PATTERN_PER_MILLE:
-                c = symbols.getPerMill();
+                affix = symbols.getPerMillString();
+                break;
+            case PATTERN_PLUS_SIGN:
+                affix = symbols.getPlusSignString();
                 break;
-            case PATTERN_MINUS:
-                c = symbols.getMinusSign();
+            case PATTERN_MINUS_SIGN:
+                affix = symbols.getMinusSignString();
                 break;
+            default:
+                // fall through to affix != null test, which will fail
+                break;
+            }
+
+            if (affix != null) {
+                pos = match(text, pos, affix);
+                continue;
             }
+
             pos = match(text, pos, c);
             if (PatternProps.isWhiteSpace(c)) {
                 i = skipPatternWhiteSpace(affixPat, i);
@@ -3133,6 +3222,9 @@ public class DecimalFormat extends NumberFormat {
         for (int i = 0; i < str.length() && pos >= 0;) {
             int ch = UTF16.charAt(str, i);
             i += UTF16.getCharCount(ch);
+            if (isBidiMark(ch)) {
+                continue;
+            }
             pos = match(text, pos, ch);
             if (PatternProps.isWhiteSpace(ch)) {
                 i = skipPatternWhiteSpace(str, i);
@@ -3797,12 +3889,12 @@ public class DecimalFormat extends NumberFormat {
     public boolean isDecimalSeparatorAlwaysShown() {
         return decimalSeparatorAlwaysShown;
     }
-    
+
     /**
      * When decimal match is not required, the input does not have to
      * contain a decimal mark when there is a decimal mark specified in the
-     * pattern. 
-     * @param value true if input must contain a match to decimal mark in pattern  
+     * pattern.
+     * @param value true if input must contain a match to decimal mark in pattern
      * Default is false.
      * @stable ICU 54
      */
@@ -4153,19 +4245,20 @@ public class DecimalFormat extends NumberFormat {
                 }
                 // Here is where FieldPosition could be set for CURRENCY PLURAL.
                 buffer.append(s);
-                continue;
+                break;
             case PATTERN_PERCENT:
-                c = symbols.getPercent();
+                buffer.append(symbols.getPercentString());
                 break;
             case PATTERN_PER_MILLE:
-                c = symbols.getPerMill();
+                buffer.append(symbols.getPerMillString());
+                break;
+            case PATTERN_MINUS_SIGN:
+                buffer.append(symbols.getMinusSignString());
+                break;
+            default:
+                buffer.append(c);
                 break;
-            case PATTERN_MINUS:
-                String minusString = symbols.getMinusString();
-                buffer.append(minusString);
-                continue;
             }
-            buffer.append(c);
         }
     }
 
@@ -4210,23 +4303,22 @@ public class DecimalFormat extends NumberFormat {
             int offset = affix.indexOf(symbols.getCurrencySymbol());
             if (offset > -1) {
                 formatAffix2Attribute(isPrefix, Field.CURRENCY, buf, offset,
-                    symbols.getCurrencySymbol().length());
+                        symbols.getCurrencySymbol().length());
             }
-            offset = affix.indexOf(symbols.getMinusString());
+            offset = affix.indexOf(symbols.getMinusSignString());
             if (offset > -1) {
-              formatAffix2Attribute(isPrefix, Field.SIGN, buf, offset,
-                  symbols.getMinusString().length());
+                formatAffix2Attribute(isPrefix, Field.SIGN, buf, offset,
+                        symbols.getMinusSignString().length());
             }
-            // TODO: Consider if Percent and Permille can be more than one character.
-            offset = affix.indexOf(symbols.getPercent());
+            offset = affix.indexOf(symbols.getPercentString());
             if (offset > -1) {
-              formatAffix2Attribute(isPrefix, Field.PERCENT, buf, offset,
-                  1);
+                formatAffix2Attribute(isPrefix, Field.PERCENT, buf, offset,
+                        symbols.getPercentString().length());
             }
-            offset = affix.indexOf(symbols.getPerMill());
+            offset = affix.indexOf(symbols.getPerMillString());
             if (offset > -1) {
-              formatAffix2Attribute(isPrefix, Field.PERMILLE, buf, offset,
-                  1);
+                formatAffix2Attribute(isPrefix, Field.PERMILLE, buf, offset,
+                        symbols.getPerMillString().length());
             }
             offset = pattern.indexOf("¤¤¤");
             if (offset > -1) {
@@ -4235,7 +4327,31 @@ public class DecimalFormat extends NumberFormat {
             }
         }
 
-        // If kCurrencySymbol or kIntlCurrencySymbol is in the affix, check for currency symbol.
+        // Look for SIGN, PERCENT, PERMILLE in the formatted affix.
+        if (fieldPosition.getFieldAttribute() == NumberFormat.Field.SIGN) {
+            String sign = isNegative ? symbols.getMinusSignString() : symbols.getPlusSignString();
+            int firstPos = affix.indexOf(sign);
+            if (firstPos > -1) {
+                int startPos = buf.length() + firstPos;
+                fieldPosition.setBeginIndex(startPos);
+                fieldPosition.setEndIndex(startPos + sign.length());
+            }
+        } else if (fieldPosition.getFieldAttribute() == NumberFormat.Field.PERCENT) {
+            int firstPos = affix.indexOf(symbols.getPercentString());
+            if (firstPos > -1) {
+                int startPos = buf.length() + firstPos;
+                fieldPosition.setBeginIndex(startPos);
+                fieldPosition.setEndIndex(startPos + symbols.getPercentString().length());
+            }
+        } else if (fieldPosition.getFieldAttribute() == NumberFormat.Field.PERMILLE) {
+            int firstPos = affix.indexOf(symbols.getPerMillString());
+            if (firstPos > -1) {
+                int startPos = buf.length() + firstPos;
+                fieldPosition.setBeginIndex(startPos);
+                fieldPosition.setEndIndex(startPos + symbols.getPerMillString().length());
+            }
+        } else
+        // If CurrencySymbol or InternationalCurrencySymbol is in the affix, check for currency symbol.
         // Get spelled out name if "¤¤¤" is in the pattern.
         if (fieldPosition.getFieldAttribute() == NumberFormat.Field.CURRENCY) {
             if (affix.indexOf(symbols.getCurrencySymbol()) > -1) {
@@ -4246,7 +4362,7 @@ public class DecimalFormat extends NumberFormat {
                 fieldPosition.setBeginIndex(start);
                 fieldPosition.setEndIndex(end);
             } else if (affix.indexOf(symbols.getInternationalCurrencySymbol()) > -1) {
-                String aff = symbols.getInternationalCurrencySymbol(); 
+                String aff = symbols.getInternationalCurrencySymbol();
                 int firstPos = affix.indexOf(aff);
                 int start = buf.length() + firstPos;
                 int end = start + aff.length();
@@ -4333,6 +4449,8 @@ public class DecimalFormat extends NumberFormat {
 
     /**
      * Appends an affix pattern to the given StringBuffer. Localize unquoted specials.
+     * <p>
+     * <b>Note:</b> This implementation does not support new String localized symbols.
      */
     private void appendAffixPattern(StringBuffer buffer, boolean isNegative, boolean isPrefix,
                                     boolean localized) {
@@ -4385,7 +4503,7 @@ public class DecimalFormat extends NumberFormat {
                 case PATTERN_PERCENT:
                     ch = symbols.getPercent();
                     break;
-                case PATTERN_MINUS:
+                case PATTERN_MINUS_SIGN:
                     ch = symbols.getMinusSign();
                     break;
                 }
@@ -4403,6 +4521,8 @@ public class DecimalFormat extends NumberFormat {
 
     /**
      * Does the real work of generating a pattern.
+     * <p>
+     * <b>Note:</b> This implementation does not support new String localized symbols.
      */
     private String toPattern(boolean localized) {
         StringBuffer result = new StringBuffer();
@@ -4542,7 +4662,7 @@ public class DecimalFormat extends NumberFormat {
             }
             if (part == 0) {
                 if (negativeSuffix.equals(positiveSuffix) &&
-                    negativePrefix.equals(PATTERN_MINUS + positivePrefix)) {
+                    negativePrefix.equals(PATTERN_MINUS_SIGN + positivePrefix)) {
                     break;
                 } else {
                     result.append(localized ? symbols.getPatternSeparator() : PATTERN_SEPARATOR);
@@ -4634,7 +4754,7 @@ public class DecimalFormat extends NumberFormat {
         String exponent = String.valueOf(PATTERN_EXPONENT);
         char plus = PATTERN_PLUS_SIGN;
         char padEscape = PATTERN_PAD_ESCAPE;
-        char minus = PATTERN_MINUS; // Bug 4212072 [Richard/GCL]
+        char minus = PATTERN_MINUS_SIGN; // Bug 4212072 [Richard/GCL]
         if (localized) {
             zeroDigit = symbols.getZeroDigit();
             sigDigit = symbols.getSignificantDigit();
@@ -4896,7 +5016,7 @@ public class DecimalFormat extends NumberFormat {
                         // Fall through to append(ch)
                     } else if (ch == minus) {
                         // Convert to non-localized pattern
-                        ch = PATTERN_MINUS;
+                        ch = PATTERN_MINUS_SIGN;
                         // Fall through to append(ch)
                     } else if (ch == padEscape) {
                         if (padPos >= 0) {
@@ -5090,7 +5210,7 @@ public class DecimalFormat extends NumberFormat {
             (negPrefixPattern.equals(posPrefixPattern)
              && negSuffixPattern.equals(posSuffixPattern))) {
             negSuffixPattern = posSuffixPattern;
-            negPrefixPattern = PATTERN_MINUS + posPrefixPattern;
+            negPrefixPattern = PATTERN_MINUS_SIGN + posPrefixPattern;
         }
         setLocale(null, null);
         // save the pattern
@@ -5177,8 +5297,8 @@ public class DecimalFormat extends NumberFormat {
     /**
      * {@icu} Sets the minimum number of significant digits that will be displayed. If
      * <code>min</code> is less than one then it is set to one. If the maximum significant
-     * digits count is less than <code>min</code>, then it is set to <code>min</code>. 
-     * This function also enables the use of significant digits by this formatter - 
+     * digits count is less than <code>min</code>, then it is set to <code>min</code>.
+     * This function also enables the use of significant digits by this formatter -
      * {@link #areSignificantDigitsUsed()} will return true.
      *
      * @param min the fewest significant digits to be shown
@@ -5199,7 +5319,7 @@ public class DecimalFormat extends NumberFormat {
      * {@icu} Sets the maximum number of significant digits that will be displayed. If
      * <code>max</code> is less than one then it is set to one. If the minimum significant
      * digits count is greater than <code>max</code>, then it is set to <code>max</code>.
-     * This function also enables the use of significant digits by this formatter - 
+     * This function also enables the use of significant digits by this formatter -
      * {@link #areSignificantDigitsUsed()} will return true.
      *
      * @param max the most significant digits to be shown
@@ -5276,12 +5396,12 @@ public class DecimalFormat extends NumberFormat {
             }
         }
     }
-    
+
     /**
      * Sets the <tt>Currency Usage</tt> object used to display currency.
      * This takes effect immediately, if this format is a
-     * currency format.  
-     * @param newUsage new currency context object to use.  
+     * currency format.
+     * @param newUsage new currency context object to use.
      * @stable ICU 54
      */
     public void setCurrencyUsage(CurrencyUsage newUsage) {
@@ -5307,7 +5427,7 @@ public class DecimalFormat extends NumberFormat {
     public CurrencyUsage getCurrencyUsage() {
         return currencyUsage;
     }
-    
+
     /**
      * Returns the currency in effect for this formatter. Subclasses should override this
      * method as needed. Unlike getCurrency(), this method should never return null.
@@ -5379,9 +5499,9 @@ public class DecimalFormat extends NumberFormat {
     public boolean isParseBigDecimal() {
         return parseBigDecimal;
     }
-    
+
     /**
-    * Set the maximum number of exponent digits when parsing a number. 
+    * Set the maximum number of exponent digits when parsing a number.
     * If the limit is set too high, an OutOfMemoryException may be triggered.
     * The default value is 1000.
     * @param newValue the new limit
@@ -5392,7 +5512,7 @@ public class DecimalFormat extends NumberFormat {
             PARSE_MAX_EXPONENT = newValue;
         }
     }
-    
+
     /**
     * Get the current maximum number of exponent digits when parsing a
     * number.
@@ -5779,7 +5899,7 @@ public class DecimalFormat extends NumberFormat {
      * @since ICU 54
      */
     private CurrencyUsage currencyUsage = CurrencyUsage.STANDARD;
-    
+
     // ----------------------------------------------------------------------
 
     static final int currentSerialVersion = 4;
@@ -5801,7 +5921,7 @@ public class DecimalFormat extends NumberFormat {
      * <li><b>3</b>: ICU 2.2. Adds currency object.
      *
      * <li><b>4</b>: ICU 54. Adds currency usage(standard vs cash)
-     * 
+     *
      * </ul>
      *
      * @serial
@@ -5881,15 +6001,12 @@ public class DecimalFormat extends NumberFormat {
     static final char PATTERN_SIGNIFICANT_DIGIT = '@';
     static final char PATTERN_EXPONENT = 'E';
     static final char PATTERN_PLUS_SIGN = '+';
+    static final char PATTERN_MINUS_SIGN = '-';
 
     // Affix
     private static final char PATTERN_PER_MILLE = '\u2030';
     private static final char PATTERN_PERCENT = '%';
     static final char PATTERN_PAD_ESCAPE = '*';
-    /**
-     * Bug 4212072 To meet the need of expandAffix(String, StirngBuffer) [Richard/GCL]
-     */
-    private static final char PATTERN_MINUS = '-';
 
     // Other
     private static final char PATTERN_SEPARATOR = ';';
@@ -6099,7 +6216,7 @@ public class DecimalFormat extends NumberFormat {
      * based on rounding mode and width of fractional digits. Whenever setting affecting
      * rounding mode, rounding increment and maximum width of fractional digits, then
      * this method must be called.
-     * 
+     *
      * roundingIncrementICU is the field storing the custom rounding increment value,
      * while actual rounding increment could be larger.
      */
diff --git a/app/src/main/java/com/ibm/icu/text/DecimalFormatSymbols.java b/icu4j/src/main/java/com/ibm/icu/text/DecimalFormatSymbols.java
similarity index 58%
rename from app/src/main/java/com/ibm/icu/text/DecimalFormatSymbols.java
rename to icu4j/src/main/java/com/ibm/icu/text/DecimalFormatSymbols.java
index 1ed689a..0e3ec41 100644
--- a/app/src/main/java/com/ibm/icu/text/DecimalFormatSymbols.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/DecimalFormatSymbols.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and
@@ -13,13 +15,15 @@ import java.util.Arrays;
 import java.util.Locale;
 import java.util.MissingResourceException;
 
+import com.ibm.icu.impl.CacheBase;
 import com.ibm.icu.impl.CurrencyData;
 import com.ibm.icu.impl.CurrencyData.CurrencyDisplayInfo;
 import com.ibm.icu.impl.CurrencyData.CurrencyFormatInfo;
 import com.ibm.icu.impl.CurrencyData.CurrencySpacingInfo;
-import com.ibm.icu.impl.ICUCache;
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
-import com.ibm.icu.impl.SimpleCache;
+import com.ibm.icu.impl.SoftCache;
+import com.ibm.icu.impl.UResource;
 import com.ibm.icu.util.Currency;
 import com.ibm.icu.util.ICUCloneNotSupportedException;
 import com.ibm.icu.util.ULocale;
@@ -161,63 +165,128 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
      * Returns the character used for zero. Different for Arabic, etc.
      * @return the character
      * @stable ICU 2.0
+     * @discouraged ICU 58 use {@link #getDigitStrings()} instead.
      */
     public char getZeroDigit() {
-        if ( digits != null ) {
-            return digits[0];
-        } else {
-            return zeroDigit;
-        }
+        return zeroDigit;
     }
+
     /**
      * Returns the array of characters used as digits, in order from 0 through 9
      * @return The array
      * @stable ICU 4.6
+     * @see #getDigitStrings()
+     * @discouraged ICU 58 use {@link #getDigitStrings()} instead.
      */
     public char[] getDigits() {
-        if ( digits != null ) {
-            return digits.clone();
-        } else {
-            char [] digitArray = new char[10];
-            for ( int i = 0 ; i < 10 ; i++ ) {
-                digitArray[i] = (char) (zeroDigit + i);
-            }
-            return digitArray;
-        }
+        return digits.clone();
     }
-    
+
     /**
-     * Returns the array of characters used as digits, in order from 0 through 9
-     * Package private method - don't need to defensively copy.
-     * @return The array
+     * Sets the character used for zero.
+     * <p>
+     * <b>Note:</b> When the specified zeroDigit is a Unicode decimal digit character
+     * (category:Nd) and the number value is 0, then this method propagate digit 1 to
+     * digit 9 by incrementing code point one by one.
+     *
+     * @param zeroDigit the zero character.
+     * @stable ICU 2.0
+     * @discouraged ICU 58 use {@link #setDigitStrings(String[])} instead.
      */
-    char[] getDigitsLocal() {
-        if ( digits != null ) {
-            return digits;
-        } else {
-            char [] digitArray = new char[10];
-            for ( int i = 0 ; i < 10 ; i++ ) {
-                digitArray[i] = (char) (zeroDigit + i);
+    public void setZeroDigit(char zeroDigit) {
+        this.zeroDigit = zeroDigit;
+
+        // digitStrings or digits might be referencing a cached copy for
+        // optimization purpose, so creating a copy before making a modification
+        digitStrings = digitStrings.clone();
+        digits = digits.clone();
+
+        // Make digitStrings field and digits field in sync
+        digitStrings[0] = String.valueOf(zeroDigit);
+        digits[0] = zeroDigit;
+
+        // Propagate digit 1 - 9 only when the input zeroDigit is a
+        // Unicode number and its integer value is 0.
+
+        if (Character.digit(zeroDigit, 10) == 0) {
+            for (int i = 1; i < 10; i++) {
+                char d = (char)(zeroDigit + i);
+                digitStrings[i] = String.valueOf(d);
+                digits[i] = d;
             }
-            return digitArray;
         }
     }
 
     /**
-     * Sets the character used for zero.
-     * @param zeroDigit the zero character.
-     * @stable ICU 2.0
+    * {@icu} Returns the array of strings used as digits, in order from 0 through 9
+    * @return The array of ten digit strings
+    * @see #setDigitStrings(String[])
+    * @draft ICU 58
+    * @provisional This API might change or be removed in a future release.
+    */
+    public String[] getDigitStrings() {
+        return digitStrings.clone();
+    }
+
+    /**
+     * Returns the array of strings used as digits, in order from 0 through 9
+     * Package private method - doesn't create a defensively copy.
+     * @return the array of digit strings
      */
-    public void setZeroDigit(char zeroDigit) {
-        if ( digits != null ) {
-            this.digits[0] = zeroDigit;
-            if (Character.digit(zeroDigit,10) == 0) {
-                for ( int i = 1 ; i < 10 ; i++ ) {
-                    this.digits[i] = (char)(zeroDigit+i);
-                }
+    String[] getDigitStringsLocal() {
+        return digitStrings;
+    }
+
+    /**
+    * {@icu} Sets the array of strings used as digits, in order from 0 through 9
+    * <p>
+    * <b>Note:</b>
+    * <p>
+    * When the input array of digit strings contains any strings
+    * represented by multiple Java chars, then {@link #getDigits()} will return
+    * the default digits ('0' - '9') and {@link #getZeroDigit()} will return the
+    * default zero digit ('0').
+    *
+    * @param digitStrings The array of digit strings. The length of the array must be exactly 10.
+    * @throws NullPointerException if the <code>digitStrings</code> is null.
+    * @throws IllegalArgumentException if the length of the array is not 10.
+    * @see #getDigitStrings()
+    * @draft ICU 58
+    * @provisional This API might change or be removed in a future release.
+    */
+    public void setDigitStrings(String[] digitStrings) {
+        if (digitStrings == null) {
+            throw new NullPointerException("The input digit string array is null");
+        }
+        if (digitStrings.length != 10) {
+            throw new IllegalArgumentException("Number of digit strings is not 10");
+        }
+
+        // Scan input array and create char[] representation if possible
+        String[] tmpDigitStrings = new String[10];
+        char[] tmpDigits = new char[10];
+        for (int i = 0; i < 10; i++) {
+            if (digitStrings[i] == null) {
+                throw new IllegalArgumentException("The input digit string array contains a null element");
+            }
+            tmpDigitStrings[i] = digitStrings[i];
+            if (tmpDigits != null && digitStrings[i].length() == 1) {
+                tmpDigits[i] = digitStrings[i].charAt(0);
+            } else {
+                // contains digit string with multiple UTF-16 code units
+                tmpDigits = null;
             }
+        }
+
+        this.digitStrings = tmpDigitStrings;
+
+        if (tmpDigits == null) {
+            // fallback to the default digit chars
+            this.zeroDigit = DEF_DIGIT_CHARS_ARRAY[0];
+            this.digits = DEF_DIGIT_CHARS_ARRAY;
         } else {
-            this.zeroDigit = zeroDigit;
+            this.zeroDigit = tmpDigits[0];
+            this.digits = tmpDigits;
         }
     }
 
@@ -240,27 +309,68 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
     }
 
     /**
-     * Returns the character used for thousands separator. Different for French, etc.
+     * Returns the character used for grouping separator. Different for French, etc.
      * @return the thousands character
      * @stable ICU 2.0
+     * @discouraged ICU 58 use {@link #getGroupingSeparatorString()} instead.
      */
     public char getGroupingSeparator() {
         return groupingSeparator;
     }
 
     /**
-     * Sets the character used for thousands separator. Different for French, etc.
+     * Sets the character used for grouping separator. Different for French, etc.
      * @param groupingSeparator the thousands character
      * @stable ICU 2.0
+     * @see #setGroupingSeparatorString(String)
      */
     public void setGroupingSeparator(char groupingSeparator) {
         this.groupingSeparator = groupingSeparator;
+        this.groupingSeparatorString = String.valueOf(groupingSeparator);
+    }
+
+    /**
+     * {@icu} Returns the string used for grouping separator. Different for French, etc.
+     * @return the grouping separator string
+     * @see #setGroupingSeparatorString(String)
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public String getGroupingSeparatorString() {
+        return groupingSeparatorString;
+    }
+
+    /**
+     * {@icu} Sets the string used for grouping separator.
+     * <p>
+     * <b>Note:</b> When the input grouping separator String is represented
+     * by multiple Java chars, then {@link #getGroupingSeparator()} will
+     * return the default grouping separator character (',').
+     *
+     * @param groupingSeparatorString the grouping separator string
+     * @throws NullPointerException if <code>groupingSeparatorString</code> is null.
+     * @see #getGroupingSeparatorString()
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public void setGroupingSeparatorString(String groupingSeparatorString) {
+        if (groupingSeparatorString == null) {
+            throw new NullPointerException("The input grouping separator is null");
+        }
+        this.groupingSeparatorString = groupingSeparatorString;
+        if (groupingSeparatorString.length() == 1) {
+            this.groupingSeparator = groupingSeparatorString.charAt(0);
+        } else {
+            // Use the default grouping separator character as fallback
+            this.groupingSeparator = DEF_GROUPING_SEPARATOR;
+        }
     }
 
     /**
      * Returns the character used for decimal sign. Different for French, etc.
      * @return the decimal character
      * @stable ICU 2.0
+     * @discouraged ICU 58 use {@link #getDecimalSeparatorString()} instead.
      */
     public char getDecimalSeparator() {
         return decimalSeparator;
@@ -273,12 +383,51 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
      */
     public void setDecimalSeparator(char decimalSeparator) {
         this.decimalSeparator = decimalSeparator;
+        this.decimalSeparatorString = String.valueOf(decimalSeparator);
+    }
+
+    /**
+     * {@icu} Returns the string used for decimal sign.
+     * @return the decimal sign string
+     * @see #setDecimalSeparatorString(String)
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public String getDecimalSeparatorString() {
+        return decimalSeparatorString;
+    }
+
+    /**
+     * {@icu} Sets the string used for decimal sign.
+     * <p>
+     * <b>Note:</b> When the input decimal separator String is represented
+     * by multiple Java chars, then {@link #getDecimalSeparator()} will
+     * return the default decimal separator character ('.').
+     *
+     * @param decimalSeparatorString the decimal sign string
+     * @throws NullPointerException if <code>decimalSeparatorString</code> is null.
+     * @see #getDecimalSeparatorString()
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public void setDecimalSeparatorString(String decimalSeparatorString) {
+        if (decimalSeparatorString == null) {
+            throw new NullPointerException("The input decimal separator is null");
+        }
+        this.decimalSeparatorString = decimalSeparatorString;
+        if (decimalSeparatorString.length() == 1) {
+            this.decimalSeparator = decimalSeparatorString.charAt(0);
+        } else {
+            // Use the default decimal separator character as fallback
+            this.decimalSeparator = DEF_DECIMAL_SEPARATOR;
+        }
     }
 
     /**
      * Returns the character used for mille percent sign. Different for Arabic, etc.
      * @return the mille percent character
      * @stable ICU 2.0
+     * @discouraged ICU 58 use {@link #getPerMillString()} instead.
      */
     public char getPerMill() {
         return perMill;
@@ -291,12 +440,51 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
      */
     public void setPerMill(char perMill) {
         this.perMill = perMill;
+        this.perMillString = String.valueOf(perMill);
+    }
+
+    /**
+     * {@icu} Returns the string used for permille sign.
+     * @return the permille string
+     * @see #setPerMillString(String)
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public String getPerMillString() {
+        return perMillString;
+    }
+
+    /**
+    * {@icu} Sets the string used for permille sign.
+     * <p>
+     * <b>Note:</b> When the input permille String is represented
+     * by multiple Java chars, then {@link #getPerMill()} will
+     * return the default permille character ('&#x2030;').
+     *
+     * @param perMillString the permille string
+     * @throws NullPointerException if <code>perMillString</code> is null.
+     * @see #getPerMillString()
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public void setPerMillString(String perMillString) {
+        if (perMillString == null) {
+            throw new NullPointerException("The input permille string is null");
+        }
+        this.perMillString = perMillString;
+        if (perMillString.length() == 1) {
+            this.perMill = perMillString.charAt(0);
+        } else {
+            // Use the default permille character as fallback
+            this.perMill = DEF_PERMILL;
+        }
     }
 
     /**
      * Returns the character used for percent sign. Different for Arabic, etc.
      * @return the percent character
      * @stable ICU 2.0
+     * @discouraged ICU 58 use {@link #getPercentString()} instead.
      */
     public char getPercent() {
         return percent;
@@ -309,6 +497,44 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
      */
     public void setPercent(char percent) {
         this.percent = percent;
+        this.percentString = String.valueOf(percent);
+    }
+
+    /**
+     * {@icu} Returns the string used for percent sign.
+     * @return the percent string
+     * @see #setPercentString(String)
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public String getPercentString() {
+        return percentString;
+    }
+
+    /**
+     * {@icu} Sets the string used for percent sign.
+     * <p>
+     * <b>Note:</b> When the input grouping separator String is represented
+     * by multiple Java chars, then {@link #getPercent()} will
+     * return the default percent sign character ('%').
+     *
+     * @param percentString the percent string
+     * @throws NullPointerException if <code>percentString</code> is null.
+     * @see #getPercentString()
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public void setPercentString(String percentString) {
+        if (percentString == null) {
+            throw new NullPointerException("The input percent sign is null");
+        }
+        this.percentString = percentString;
+        if (percentString.length() == 1) {
+            this.percent = percentString.charAt(0);
+        } else {
+            // Use default percent character as fallback
+            this.percent = DEF_PERCENT;
+        }
     }
 
     /**
@@ -398,22 +624,12 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
      * minusSign to the positive format.
      * @return the minus sign character
      * @stable ICU 2.0
+     * @discouraged ICU 58 use {@link #getMinusSignString()} instead.
      */
     public char getMinusSign() {
         return minusSign;
     }
 
-    /**
-     * Returns the string used to represent minus sign.
-     * @return the minus sign string
-     * @internal
-     * @deprecated This API is ICU internal only.
-     */
-    @Deprecated
-    public String getMinusString() {
-        return minusString;
-    }
-
     /**
      * Sets the character used to represent minus sign. If no explicit
      * negative format is specified, one is formed by prefixing
@@ -423,9 +639,109 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
      */
     public void setMinusSign(char minusSign) {
         this.minusSign = minusSign;
-        // Also updates minusString
-        char[] minusArray = { minusSign };
-        minusString = new String(minusArray);
+        this.minusString = String.valueOf(minusSign);
+    }
+
+    /**
+     * {@icu} Returns the string used to represent minus sign.
+     * @return the minus sign string
+     * @see #setMinusSignString(String)
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public String getMinusSignString() {
+        return minusString;
+    }
+
+    /**
+     * {@icu} Sets the string used to represent minus sign.
+     * <p>
+     * <b>Note:</b> When the input minus sign String is represented
+     * by multiple Java chars, then {@link #getMinusSign()} will
+     * return the default minus sign character ('-').
+     *
+     * @param minusSignString the minus sign string
+     * @throws NullPointerException if <code>minusSignString</code> is null.
+     * @see #getGroupingSeparatorString()
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public void setMinusSignString(String minusSignString) {
+        if (minusSignString == null) {
+            throw new NullPointerException("The input minus sign is null");
+        }
+        this.minusString = minusSignString;
+        if (minusSignString.length() == 1) {
+            this.minusSign = minusSignString.charAt(0);
+        } else {
+            // Use the default minus sign as fallback
+            this.minusSign = DEF_MINUS_SIGN;
+        }
+    }
+
+    /**
+     * {@icu} Returns the localized plus sign.
+     * @return the plus sign, used in localized patterns and formatted
+     * strings
+     * @see #setPlusSign
+     * @see #setMinusSign
+     * @see #getMinusSign
+     * @stable ICU 2.0
+     * @discouraged ICU 58 use {@link #getPlusSignString()} instead.
+     */
+    public char getPlusSign() {
+        return plusSign;
+    }
+
+    /**
+     * {@icu} Sets the localized plus sign.
+     * @param plus the plus sign, used in localized patterns and formatted
+     * strings
+     * @see #getPlusSign
+     * @see #setMinusSign
+     * @see #getMinusSign
+     * @stable ICU 2.0
+     */
+    public void setPlusSign(char plus) {
+        this.plusSign = plus;
+        this.plusString = String.valueOf(plus);
+    }
+
+    /**
+     * {@icu} Returns the string used to represent plus sign.
+     * @return the plus sign string
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public String getPlusSignString() {
+        return plusString;
+    }
+
+    /**
+     * {@icu} Sets the localized plus sign string.
+     * <p>
+     * <b>Note:</b> When the input plus sign String is represented
+     * by multiple Java chars, then {@link #getPlusSign()} will
+     * return the default plus sign character ('+').
+     *
+     * @param plusSignString the plus sign string, used in localized patterns and formatted
+     * strings
+     * @throws NullPointerException if <code>plusSignString</code> is null.
+     * @see #getPlusSignString()
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public void setPlusSignString(String plusSignString) {
+        if (plusSignString == null) {
+            throw new NullPointerException("The input plus sign is null");
+        }
+        this.plusString = plusSignString;
+        if (plusSignString.length() == 1) {
+            this.plusSign = plusSignString.charAt(0);
+        } else {
+            // Use the default plus sign as fallback
+            this.plusSign = DEF_PLUS_SIGN;
+        }
     }
 
     /**
@@ -504,46 +820,125 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
      * Returns the monetary decimal separator.
      * @return the monetary decimal separator character
      * @stable ICU 2.0
+     * @discouraged ICU 58 use {@link #getMonetaryDecimalSeparatorString()} instead.
      */
     public char getMonetaryDecimalSeparator() {
         return monetarySeparator;
     }
 
+    /**
+     * Sets the monetary decimal separator.
+     * @param sep the monetary decimal separator character
+     * @stable ICU 2.0
+     */
+    public void setMonetaryDecimalSeparator(char sep) {
+        this.monetarySeparator = sep;
+        this.monetarySeparatorString = String.valueOf(sep);
+    }
+
+    /**
+     * {@icu} Returns the monetary decimal separator string.
+     * @return the monetary decimal separator string
+     * @see #setMonetaryDecimalSeparatorString(String)
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public String getMonetaryDecimalSeparatorString() {
+        return monetarySeparatorString;
+    }
+
+    /**
+     * {@icu} Sets the monetary decimal separator string.
+     * <p>
+     * <b>Note:</b> When the input monetary decimal separator String is represented
+     * by multiple Java chars, then {@link #getMonetaryDecimalSeparatorString()} will
+     * return the default monetary decimal separator character ('.').
+     *
+     * @param sep the monetary decimal separator string
+     * @throws NullPointerException if <code>sep</code> is null.
+     * @see #getMonetaryDecimalSeparatorString()
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public void setMonetaryDecimalSeparatorString(String sep) {
+        if (sep == null) {
+            throw new NullPointerException("The input monetary decimal separator is null");
+        }
+        this.monetarySeparatorString = sep;
+        if (sep.length() == 1) {
+            this.monetarySeparator = sep.charAt(0);
+        } else {
+            // Use default decimap separator character as fallbacl
+            this.monetarySeparator = DEF_DECIMAL_SEPARATOR;
+        }
+    }
+
     /**
      * {@icu} Returns the monetary grouping separator.
      * @return the monetary grouping separator character
      * @stable ICU 3.6
+     * @discouraged ICU 58 use {@link #getMonetaryGroupingSeparatorString()} instead.
      */
     public char getMonetaryGroupingSeparator() {
         return monetaryGroupingSeparator;
     }
 
     /**
-     * Internal API for NumberFormat
-     * @return String currency pattern string
+     * {@icu} Sets the monetary grouping separator.
+     * @param sep the monetary grouping separator character
+     * @stable ICU 3.6
      */
-    String getCurrencyPattern() {
-        return currencyPattern;
+    public void setMonetaryGroupingSeparator(char sep) {
+        this.monetaryGroupingSeparator = sep;
+        this.monetaryGroupingSeparatorString = String.valueOf(sep);
     }
 
     /**
-     * Sets the monetary decimal separator.
-     * @param sep the monetary decimal separator character
-     * @stable ICU 2.0
+     * {@icu} Returns the monetary grouping separator.
+     * @return the monetary grouping separator string
+     * @see #setMonetaryGroupingSeparatorString(String)
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
      */
-    public void setMonetaryDecimalSeparator(char sep) {
-        monetarySeparator = sep;
+    public String getMonetaryGroupingSeparatorString() {
+        return monetaryGroupingSeparatorString;
     }
 
     /**
-     * Sets the monetary decimal separator.
-     * @param sep the monetary decimal separator character
-     * @stable ICU 3.6
+     * {@icu} Sets the monetary grouping separator string.
+     * <p>
+     * <b>Note:</b> When the input grouping separator String is represented
+     * by multiple Java chars, then {@link #getMonetaryGroupingSeparator()} will
+     * return the default monetary grouping separator character (',').
+     *
+     * @param sep the monetary grouping separator string
+     * @throws NullPointerException if <code>sep</code> is null.
+     * @see #getMonetaryGroupingSeparatorString()
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
      */
-    public void setMonetaryGroupingSeparator(char sep) {
-        monetaryGroupingSeparator = sep;
+    public void setMonetaryGroupingSeparatorString(String sep) {
+        if (sep == null) {
+            throw new NullPointerException("The input monetary grouping separator is null");
+        }
+        this.monetaryGroupingSeparatorString = sep;
+        if (sep.length() == 1) {
+            this.monetaryGroupingSeparator = sep.charAt(0);
+        } else {
+            // Use default grouping separator character as fallback
+            this.monetaryGroupingSeparator = DEF_GROUPING_SEPARATOR;
+        }
     }
-    
+
+    /**
+    }
+     * Internal API for NumberFormat
+     * @return String currency pattern string
+     */
+    String getCurrencyPattern() {
+        return currencyPattern;
+    }
+
     /**
     * Returns the multiplication sign
     * @stable ICU 54
@@ -551,7 +946,7 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
     public String getExponentMultiplicationSign() {
         return exponentMultiplicationSign;
     }
-    
+
     /**
     * Sets the multiplication sign
     * @stable ICU 54
@@ -584,46 +979,6 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
         exponentSeparator = exp;
     }
 
-    /**
-     * {@icu} Returns the localized plus sign.
-     * @return the plus sign, used in localized patterns and formatted
-     * strings
-     * @see #setPlusSign
-     * @see #setMinusSign
-     * @see #getMinusSign
-     * @stable ICU 2.0
-     */
-    public char getPlusSign() {
-        return plusSign;
-    }
-
-    /**
-     * Returns the string used to represent plus sign.
-     * @return the plus sign string
-     * @internal
-     * @deprecated This API is ICU internal only.
-     */
-    @Deprecated
-    public String getPlusString() {
-        return plusString;
-    }
-
-    /**
-     * {@icu} Sets the localized plus sign.
-     * @param plus the plus sign, used in localized patterns and formatted
-     * strings
-     * @see #getPlusSign
-     * @see #setMinusSign
-     * @see #getMinusSign
-     * @stable ICU 2.0
-     */
-    public void setPlusSign(char plus) {
-        plusSign = plus;
-        // Also updates plusString
-        char[] plusArray = { plusSign };
-        plusString = new String(plusArray);
-    }
-
     /**
      * {@icu} Returns the character used to pad numbers out to a specified width.  This is
      * not the pad character itself; rather, it is the special pattern character
@@ -758,9 +1113,10 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
      * {@inheritDoc}
      * @stable ICU 2.0
      */
+    @Override
     public Object clone() {
         try {
-            return (DecimalFormatSymbols) super.clone();
+            return super.clone();
             // other fields are bit-copied
         } catch (CloneNotSupportedException e) {
             ///CLOVER:OFF
@@ -773,6 +1129,7 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
      * {@inheritDoc}
      * @stable ICU 2.0
      */
+    @Override
     public boolean equals(Object obj) {
         if (!(obj instanceof DecimalFormatSymbols)) {
             return false;
@@ -789,7 +1146,7 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
                 return false;
             }
         }
-        
+
         if ( other.digits == null ) {
             for (int i = 0 ; i < 10 ; i++) {
                 if (digits[i] != other.zeroDigit + i) {
@@ -826,6 +1183,7 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
      * {@inheritDoc}
      * @stable ICU 2.0
      */
+    @Override
     public int hashCode() {
             int result = digits[0];
             result = result * 37 + groupingSeparator;
@@ -834,127 +1192,132 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
     }
 
     /**
-     * Check for bidi marks: LRM, RLM, ALM
+     * List of field names to be loaded from the data files.
+     * The indices of each name into the array correspond to the position of that item in the
+     * numberElements array.
      */
-    private static boolean isBidiMark(char c) {
-        return (c=='\u200E' || c=='\u200F' || c=='\u061C');
-    }
+    private static final String[] SYMBOL_KEYS = {
+            "decimal",
+            "group",
+            "list",
+            "percentSign",
+            "minusSign",
+            "plusSign",
+            "exponential",
+            "perMille",
+            "infinity",
+            "nan",
+            "currencyDecimal",
+            "currencyGroup",
+            "superscriptingExponent"
+    };
+
+    /*
+     * Default digits
+     */
+    private static final String[] DEF_DIGIT_STRINGS_ARRAY =
+        {"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"};
+
+    private static final char[] DEF_DIGIT_CHARS_ARRAY =
+        {'0', '1', '2', '3', '4', '5', '6', '7', '8', '9'};
+
+    /*
+     *  Default symbol characters, used for fallbacks.
+     */
+    private static final char DEF_DECIMAL_SEPARATOR = '.';
+    private static final char DEF_GROUPING_SEPARATOR = ',';
+    private static final char DEF_PERCENT = '%';
+    private static final char DEF_MINUS_SIGN = '-';
+    private static final char DEF_PLUS_SIGN = '+';
+    private static final char DEF_PERMILL = '\u2030';
 
     /**
-     * Initializes the symbols from the LocaleElements resource bundle.
-     * Note: The organization of LocaleElements badly needs to be
-     * cleaned up.
+     * List of default values for the symbols.
      */
-    private void initialize( ULocale locale ) {
-        this.requestedLocale = locale.toLocale();
-        this.ulocale = locale;
+    private static final String[] SYMBOL_DEFAULTS = new String[] {
+            String.valueOf(DEF_DECIMAL_SEPARATOR),  // decimal
+            String.valueOf(DEF_GROUPING_SEPARATOR), // group
+            ";", // list
+            String.valueOf(DEF_PERCENT),    // percentSign
+            String.valueOf(DEF_MINUS_SIGN), // minusSign
+            String.valueOf(DEF_PLUS_SIGN),  // plusSign
+            "E", // exponential
+            String.valueOf(DEF_PERMILL),    // perMille
+            "\u221e", // infinity
+            "NaN", // NaN
+            null, // currency decimal
+            null, // currency group
+            "\u00D7" // superscripting exponent
+        };
 
-        String nsName;
-        // Attempt to set the zero digit based on the numbering system for the locale requested
-        NumberingSystem ns = NumberingSystem.getInstance(locale);
-        digits = new char[10];
-        if ( ns != null && ns.getRadix() == 10 && !ns.isAlgorithmic() &&
-             NumberingSystem.isValidDigitString(ns.getDescription())) {
-            String digitString = ns.getDescription();
-            digits[0] = digitString.charAt(0);
-            digits[1] = digitString.charAt(1);
-            digits[2] = digitString.charAt(2);
-            digits[3] = digitString.charAt(3);
-            digits[4] = digitString.charAt(4);
-            digits[5] = digitString.charAt(5);
-            digits[6] = digitString.charAt(6);
-            digits[7] = digitString.charAt(7);
-            digits[8] = digitString.charAt(8);
-            digits[9] = digitString.charAt(9);
-            nsName = ns.getName();
-        } else {
-            digits[0] = DecimalFormat.PATTERN_ZERO_DIGIT;
-            digits[1] = DecimalFormat.PATTERN_ONE_DIGIT;
-            digits[2] = DecimalFormat.PATTERN_TWO_DIGIT;
-            digits[3] = DecimalFormat.PATTERN_THREE_DIGIT;
-            digits[4] = DecimalFormat.PATTERN_FOUR_DIGIT;
-            digits[5] = DecimalFormat.PATTERN_FIVE_DIGIT;
-            digits[6] = DecimalFormat.PATTERN_SIX_DIGIT;
-            digits[7] = DecimalFormat.PATTERN_SEVEN_DIGIT;
-            digits[8] = DecimalFormat.PATTERN_EIGHT_DIGIT;
-            digits[9] = DecimalFormat.PATTERN_NINE_DIGIT;
-            nsName = "latn"; // Default numbering system
+    /**
+     * Constants for path names in the data bundles.
+     */
+    private static final String LATIN_NUMBERING_SYSTEM = "latn";
+    private static final String NUMBER_ELEMENTS = "NumberElements";
+    private static final String SYMBOLS = "symbols";
+
+    /**
+     * Sink for enumerating all of the decimal format symbols (more specifically, anything
+     * under the "NumberElements.symbols" tree).
+     *
+     * More specific bundles (en_GB) are enumerated before their parents (en_001, en, root):
+     * Only store a value if it is still missing, that is, it has not been overridden.
+     */
+    private static final class DecFmtDataSink extends UResource.Sink {
+
+        private String[] numberElements; // Array where to store the characters (set in constructor)
+
+        public DecFmtDataSink(String[] numberElements) {
+            this.numberElements = numberElements;
         }
 
-        /* try the cache first */
-        String[][] data = cachedLocaleData.get(locale);
-        String[] numberElements;
-        if (data == null) {  /* cache miss */
-            data = new String[1][];
-            ICUResourceBundle rb = (ICUResourceBundle)UResourceBundle.
-                getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, locale);
-            boolean isLatn = nsName.equals("latn");
-            String baseKey = "NumberElements/" + nsName + "/symbols/";
-            String latnKey = "NumberElements/latn/symbols/";
-            String[] symbolKeys = { "decimal", "group", "list", "percentSign", "minusSign", "plusSign", "exponential", "perMille", "infinity", "nan", "currencyDecimal", "currencyGroup", "superscriptingExponent" };
-            String[] fallbackElements = { ".", ",", ";", "%", "-", "+", "E", "\u2030", "\u221e", "NaN", null, null };
-            String[] symbolsArray = new String[symbolKeys.length];
-            for ( int i = 0 ; i < symbolKeys.length; i++ ) {
-                try {
-                    symbolsArray[i] = rb.getStringWithFallback(baseKey+symbolKeys[i]);
-                } catch (MissingResourceException ex) {
-                    if (!isLatn) { // Fall back to latn numbering system for symbols if desired symbol isn't found.
-                        try {
-                            symbolsArray[i] = rb.getStringWithFallback(latnKey+symbolKeys[i]);
-                        } catch (MissingResourceException ex1) {
-                            symbolsArray[i] = fallbackElements[i];
+        @Override
+        public void put(UResource.Key key, UResource.Value value, boolean noFallback) {
+            UResource.Table symbolsTable = value.getTable();
+            for (int j = 0; symbolsTable.getKeyAndValue(j, key, value); ++j) {
+                for (int i = 0; i < SYMBOL_KEYS.length; i++) {
+                    if (key.contentEquals(SYMBOL_KEYS[i])) {
+                        if (numberElements[i] == null) {
+                            numberElements[i] = value.toString();
                         }
-                    } else {
-                        symbolsArray[i] = fallbackElements[i];
+                        break;
                     }
                 }
             }
-
-            data[0] = symbolsArray;
-            /* update cache */
-            cachedLocaleData.put(locale, data);
         }
-        numberElements = data[0];
-
-        ICUResourceBundle r = (ICUResourceBundle)UResourceBundle.
-            getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, locale);
+    }
 
-        // TODO: Determine actual and valid locale correctly.
-        ULocale uloc = r.getULocale();
-        setLocale(uloc, uloc);
+    /**
+     * Initializes the symbols from the locale data.
+     */
+    private void initialize( ULocale locale ) {
+        this.requestedLocale = locale.toLocale();
+        this.ulocale = locale;
+        CacheData data = cachedLocaleData.getInstance(locale, null /* unused */);
+        setLocale(data.validLocale, data.validLocale);
+        setDigitStrings(data.digits);
+        String[] numberElements = data.numberElements;
 
+        // Copy data from the numberElements map into instance fields
+        setDecimalSeparatorString(numberElements[0]);
+        setGroupingSeparatorString(numberElements[1]);
 
-        decimalSeparator = numberElements[0].charAt(0);
-        groupingSeparator = numberElements[1].charAt(0);
+        // See CLDR #9781
+        // assert numberElements[2].length() == 1;
         patternSeparator = numberElements[2].charAt(0);
-        percent = numberElements[3].charAt(0);
-        minusString = numberElements[4];
-        minusSign = (minusString.length() > 1 && isBidiMark(minusString.charAt(0)))? minusString.charAt(1): minusString.charAt(0);
-        plusString = numberElements[5];
-        plusSign = (plusString.length() > 1 && isBidiMark(plusString.charAt(0)))? plusString.charAt(1): plusString.charAt(0);
-        exponentSeparator = numberElements[6];
-        perMill = numberElements[7].charAt(0);
-        infinity = numberElements[8];
-        NaN = numberElements[9];
-
-        if ( numberElements[10] != null) {
-            monetarySeparator = numberElements[10].charAt(0);
-        } else {
-            monetarySeparator = decimalSeparator;
-        }
-        
-        if ( numberElements[11] != null) {
-            monetaryGroupingSeparator = numberElements[11].charAt(0);
-        } else {
-            monetaryGroupingSeparator = groupingSeparator;
-        }
-        
-        if ( numberElements[12] != null) {
-            exponentMultiplicationSign = numberElements[12];
-        } else {
-            exponentMultiplicationSign = "\u00D7";
-        }
-        
+
+        setPercentString(numberElements[3]);
+        setMinusSignString(numberElements[4]);
+        setPlusSignString(numberElements[5]);
+        setExponentSeparator(numberElements[6]);
+        setPerMillString(numberElements[7]);
+        setInfinity(numberElements[8]);
+        setNaN(numberElements[9]);
+        setMonetaryDecimalSeparatorString(numberElements[10]);
+        setMonetaryGroupingSeparatorString(numberElements[11]);
+        setExponentMultiplicationSign(numberElements[12]);
+
         digit = DecimalFormat.PATTERN_DIGIT;  // Localized pattern character no longer in CLDR
         padEscape = DecimalFormat.PATTERN_PAD_ESCAPE;
         sigDigit  = DecimalFormat.PATTERN_SIGNIFICANT_DIGIT;
@@ -972,8 +1335,8 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
             CurrencyFormatInfo fmtInfo = info.getFormatInfo(intlCurrencySymbol);
             if (fmtInfo != null) {
                 currencyPattern = fmtInfo.currencyPattern;
-                monetarySeparator = fmtInfo.monetarySeparator;
-                monetaryGroupingSeparator = fmtInfo.monetaryGroupingSeparator;
+                setMonetaryDecimalSeparatorString(fmtInfo.monetarySeparator);
+                setMonetaryGroupingSeparatorString(fmtInfo.monetaryGroupingSeparator);
             }
         } else {
             intlCurrencySymbol = "XXX";
@@ -982,18 +1345,83 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
 
 
         // Get currency spacing data.
-        currencySpcBeforeSym = new String[3];
-        currencySpcAfterSym = new String[3];
         initSpacingInfo(info.getSpacingInfo());
     }
 
+    private static CacheData loadData(ULocale locale) {
+        String nsName;
+        // Attempt to set the decimal digits based on the numbering system for the requested locale.
+        NumberingSystem ns = NumberingSystem.getInstance(locale);
+        String[] digits = new String[10];
+        if (ns != null && ns.getRadix() == 10 && !ns.isAlgorithmic() &&
+                NumberingSystem.isValidDigitString(ns.getDescription())) {
+            String digitString = ns.getDescription();
+
+            for (int i = 0, offset = 0; i < 10; i++) {
+                int cp = digitString.codePointAt(offset);
+                int nextOffset = offset + Character.charCount(cp);
+                digits[i] = digitString.substring(offset, nextOffset);
+                offset = nextOffset;
+            }
+            nsName = ns.getName();
+        } else {
+            // Default numbering system
+            digits = DEF_DIGIT_STRINGS_ARRAY;
+            nsName = "latn";
+        }
+
+        // Open the resource bundle and get the locale IDs.
+        // TODO: Is there a better way to get the locale than making an ICUResourceBundle instance?
+        ICUResourceBundle rb = (ICUResourceBundle)UResourceBundle.
+                getBundleInstance(ICUData.ICU_BASE_NAME, locale);
+        // TODO: Determine actual and valid locale correctly.
+        ULocale validLocale = rb.getULocale();
+
+        String[] numberElements = new String[SYMBOL_KEYS.length];
+
+        // Load using a data sink
+        DecFmtDataSink sink = new DecFmtDataSink(numberElements);
+        try {
+            rb.getAllItemsWithFallback(NUMBER_ELEMENTS + "/" + nsName + "/" + SYMBOLS, sink);
+        } catch (MissingResourceException e) {
+            // The symbols don't exist for the given nsName and resource bundle.
+            // Silently ignore and fall back to Latin.
+        }
+
+        // Load the Latin fallback if necessary
+        boolean hasNull = false;
+        for (String entry : numberElements) {
+            if (entry == null) {
+                hasNull = true;
+                break;
+            }
+        }
+        if (hasNull && !nsName.equals(LATIN_NUMBERING_SYSTEM)) {
+            rb.getAllItemsWithFallback(NUMBER_ELEMENTS + "/" + LATIN_NUMBERING_SYSTEM + "/" + SYMBOLS, sink);
+        }
+
+        // Fill in any remaining missing values
+        for (int i = 0; i < SYMBOL_KEYS.length; i++) {
+            if (numberElements[i] == null) {
+                numberElements[i] = SYMBOL_DEFAULTS[i];
+            }
+        }
+
+        // If monetary decimal or grouping were not explicitly set, then set them to be the same as
+        // their non-monetary counterparts.
+        if (numberElements[10] == null) {
+            numberElements[10] = numberElements[0];
+        }
+        if (numberElements[11] == null) {
+            numberElements[11] = numberElements[1];
+        }
+
+        return new CacheData(validLocale, digits, numberElements);
+    }
+
     private void initSpacingInfo(CurrencySpacingInfo spcInfo) {
-        currencySpcBeforeSym[CURRENCY_SPC_CURRENCY_MATCH] = spcInfo.beforeCurrencyMatch;
-        currencySpcBeforeSym[CURRENCY_SPC_SURROUNDING_MATCH] = spcInfo.beforeContextMatch;
-        currencySpcBeforeSym[CURRENCY_SPC_INSERT] = spcInfo.beforeInsert;
-        currencySpcAfterSym[CURRENCY_SPC_CURRENCY_MATCH] = spcInfo.afterCurrencyMatch;
-        currencySpcAfterSym[CURRENCY_SPC_SURROUNDING_MATCH] = spcInfo.afterContextMatch;
-        currencySpcAfterSym[CURRENCY_SPC_INSERT] = spcInfo.afterInsert;
+        currencySpcBeforeSym = spcInfo.getBeforeSymbols();
+        currencySpcAfterSym = spcInfo.getAfterSymbols();
     }
 
     /**
@@ -1058,12 +1486,10 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
         if (serialVersionOnStream < 7) {
             // Set minusString,plusString from minusSign,plusSign
             if (minusString == null) {
-                char[] minusArray = { minusSign };
-                minusString = new String(minusArray);
+                minusString = String.valueOf(minusSign);
             }
             if (plusString == null) {
-                char[] plusArray = { plusSign };
-                plusString = new String(plusArray);
+                plusString = String.valueOf(plusSign);
             }
         }
         if (serialVersionOnStream < 8) {
@@ -1071,6 +1497,49 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
                 exponentMultiplicationSign = "\u00D7";
             }
         }
+        if (serialVersionOnStream < 9) {
+            // String version of digits
+            if (digitStrings == null) {
+                digitStrings = new String[10];
+                if (digits != null && digits.length == 10) {
+                    zeroDigit = digits[0];
+                    for (int i = 0; i < 10; i++) {
+                        digitStrings[i] = String.valueOf(digits[i]);
+                    }
+                } else {
+                    char digit = zeroDigit;
+                    if (digits == null) {
+                        digits = new char[10];
+                    }
+                    for (int i = 0; i < 10; i++) {
+                        digits[i] = digit;
+                        digitStrings[i] = String.valueOf(digit);
+                        digit++;
+                    }
+                }
+            }
+
+            // String version of symbols
+            if (decimalSeparatorString == null) {
+                decimalSeparatorString = String.valueOf(decimalSeparator);
+            }
+            if (groupingSeparatorString == null) {
+                groupingSeparatorString = String.valueOf(groupingSeparator);
+            }
+            if (percentString == null) {
+                percentString = String.valueOf(percentString);
+            }
+            if (perMillString == null) {
+                perMillString = String.valueOf(perMill);
+            }
+            if (monetarySeparatorString == null) {
+                monetarySeparatorString = String.valueOf(monetarySeparator);
+            }
+            if (monetaryGroupingSeparatorString == null) {
+                monetaryGroupingSeparatorString = String.valueOf(monetaryGroupingSeparator);
+            }
+        }
+
         serialVersionOnStream = currentSerialVersion;
 
     // recreate
@@ -1085,13 +1554,18 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
      * @see #getZeroDigit
      */
     private  char    zeroDigit;
-    
+
     /**
      * Array of characters used for the digits 0-9 in order.
-     *
-     */   
+     */
     private  char    digits[];
 
+    /**
+     * Array of Strings used for the digits 0-9 in order.
+     * @serial
+     */
+    private String digitStrings[];
+
     /**
      * Character used for thousands separator.
      *
@@ -1100,6 +1574,12 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
      */
     private  char    groupingSeparator;
 
+    /**
+     * String used for thousands separator.
+     * @serial
+     */
+    private String groupingSeparatorString;
+
     /**
      * Character used for decimal sign.
      *
@@ -1108,6 +1588,12 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
      */
     private  char    decimalSeparator;
 
+    /**
+     * String used for decimal sign.
+     * @serial
+     */
+    private String decimalSeparatorString;
+
     /**
      * Character used for mille percent sign.
      *
@@ -1116,6 +1602,12 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
      */
     private  char    perMill;
 
+    /**
+     * String used for mille percent sign.
+     * @serial
+     */
+    private String perMillString;
+
     /**
      * Character used for percent sign.
      * @serial
@@ -1123,6 +1615,12 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
      */
     private  char    percent;
 
+    /**
+     * String used for percent sign.
+     * @serial
+     */
+    private String percentString;
+
     /**
      * Character used for a digit in a pattern.
      *
@@ -1169,6 +1667,27 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
      */
     private  char    minusSign;
 
+    /**
+     * String versions of minus sign.
+     * @serial
+     * @since ICU 52
+     */
+    private String minusString;
+
+    /**
+     * The character used to indicate a plus sign.
+     * @serial
+     * @since AlphaWorks
+     */
+    private char plusSign;
+
+    /**
+     * String versions of plus sign.
+     * @serial
+     * @since ICU 52
+     */
+    private String plusString;
+
     /**
      * String denoting the local currency, e.g. "$".
      * @serial
@@ -1184,19 +1703,31 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
     private  String  intlCurrencySymbol;
 
     /**
-     * The decimal separator used when formatting currency values.
+     * The decimal separator character used when formatting currency values.
      * @serial
      * @see #getMonetaryDecimalSeparator
      */
     private  char    monetarySeparator; // Field new in JDK 1.1.6
 
     /**
-     * The decimal separator used when formatting currency values.
+     * The decimal separator string used when formatting currency values.
+     * @serial
+     */
+    private String monetarySeparatorString;
+
+    /**
+     * The grouping separator character used when formatting currency values.
      * @serial
      * @see #getMonetaryGroupingSeparator
      */
     private  char    monetaryGroupingSeparator; // Field new in JDK 1.1.6
 
+    /**
+     * The grouping separator string used when formatting currency values.
+     * @serial
+     */
+    private String monetaryGroupingSeparatorString;
+
     /**
      * The character used to distinguish the exponent in a number formatted
      * in exponential notation, e.g. 'E' for a number such as "1.23E45".
@@ -1227,13 +1758,6 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
      */
     private char padEscape;
 
-    /**
-     * The character used to indicate a plus sign.
-     * @serial
-     * @since AlphaWorks
-     */
-    private char plusSign;
-
     /**
      * The locale for which this object was constructed.  Set to the
      * default locale for objects resurrected from old streams.
@@ -1247,14 +1771,6 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
      */
     private ULocale ulocale;
 
-    /**
-     * String versions of some number symbols.
-     * @serial
-     * @since ICU 52
-     */
-    private String minusString = null;
-    private String plusString = null;
-    
     /**
      * Exponent multiplication sign. e.g "x"
      * @serial
@@ -1277,6 +1793,7 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
     // - 6 for ICU 4.2, which includes the currencySpc* fields
     // - 7 for ICU 52, which includes the minusString and plusString fields
     // - 8 for ICU 54, which includes exponentMultiplicationSign field.
+    // - 9 for ICU 58, which includes a series of String symbol fields.
     private static final int currentSerialVersion = 8;
 
     /**
@@ -1292,7 +1809,7 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
      * <li><b>3</b>: Version for ICU 2.2, which adds locale.
      * <li><b>4</b>: Version for ICU 3.2, which adds ulocale.
      * <li><b>5</b>: Version for ICU 3.6, which adds monetaryGroupingSeparator.
-     * <li><b>6</b>: Version for ICU 4.2, which adds currencySpcBeforeSym and 
+     * <li><b>6</b>: Version for ICU 4.2, which adds currencySpcBeforeSym and
      *      currencySpcAfterSym.
      * <li><b>7</b>: Version for ICU 52, which adds minusString and plusString.
      * </ul>
@@ -1307,8 +1824,13 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
     /**
      * cache to hold the NumberElements of a Locale.
      */
-    private static final ICUCache<ULocale, String[][]> cachedLocaleData =
-        new SimpleCache<ULocale, String[][]>();
+    private static final CacheBase<ULocale, CacheData, Void> cachedLocaleData =
+        new SoftCache<ULocale, CacheData, Void>() {
+            @Override
+            protected CacheData createInstance(ULocale locale, Void unused) {
+                return DecimalFormatSymbols.loadData(locale);
+            }
+        };
 
     /**
      *
@@ -1390,4 +1912,16 @@ public class DecimalFormatSymbols implements Cloneable, Serializable {
     private transient Currency currency;
 
     // -------- END ULocale boilerplate --------
+
+    private static class CacheData {
+        final ULocale validLocale;
+        final String[] digits;
+        final String[] numberElements;
+
+        public CacheData(ULocale loc, String[] digits, String[] numberElements) {
+            validLocale = loc;
+            this.digits = digits;
+            this.numberElements = numberElements;
+        }
+    }
 }
diff --git a/app/src/main/java/com/ibm/icu/text/DictionaryBreakEngine.java b/icu4j/src/main/java/com/ibm/icu/text/DictionaryBreakEngine.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/text/DictionaryBreakEngine.java
rename to icu4j/src/main/java/com/ibm/icu/text/DictionaryBreakEngine.java
index f8e9cfa..99ed238 100644
--- a/app/src/main/java/com/ibm/icu/text/DictionaryBreakEngine.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/DictionaryBreakEngine.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014, International Business Machines Corporation and         *
@@ -12,7 +14,7 @@ import java.util.BitSet;
 import com.ibm.icu.impl.CharacterIteration;
 
 abstract class DictionaryBreakEngine implements LanguageBreakEngine {
-    
+
     /* Helper class for improving readability of the Thai/Lao/Khmer word break
      * algorithm.
      */
@@ -80,7 +82,7 @@ abstract class DictionaryBreakEngine implements LanguageBreakEngine {
             mark = current;
         }
     }
-    
+
     /**
      *  A deque-like structure holding raw ints.
      *  Partial, limited implementation, only what is needed by the dictionary implementation.
@@ -91,55 +93,55 @@ abstract class DictionaryBreakEngine implements LanguageBreakEngine {
         private int[] data = new int[50];
         private int lastIdx = 4;   // or base of stack. Index of element.
         private int firstIdx = 4;  // or Top of Stack. Index of element + 1.
-        
+
         int size() {
             return firstIdx - lastIdx;
         }
-        
+
         boolean isEmpty() {
             return size() == 0;
         }
-        
+
         private void grow() {
             int[] newData = new int[data.length * 2];
             System.arraycopy(data,  0,  newData,  0, data.length);
             data = newData;
         }
-        
+
         void offer(int v) {
             // Note that the actual use cases of offer() add at most one element.
             //   We make no attempt to handle more than a few.
             assert lastIdx > 0;
             data[--lastIdx] = v;
         }
-        
+
         void push(int v) {
             if (firstIdx >= data.length) {
                 grow();
             }
             data[firstIdx++] = v;
         }
-        
+
         int pop() {
             assert size() > 0;
             return data[--firstIdx];
         }
-        
+
         int peek() {
             assert size() > 0;
             return data[firstIdx - 1];
         }
-        
+
         int peekLast() {
             assert size() > 0;
             return data[lastIdx];
         }
-        
+
         int pollLast() {
             assert size() > 0;
             return data[lastIdx++];
         }
-        
+
         boolean contains(int v) {
             for (int i=lastIdx; i< firstIdx; i++) {
                 if (data[i] == v) {
@@ -149,13 +151,13 @@ abstract class DictionaryBreakEngine implements LanguageBreakEngine {
             return false;
         }
     }
-    
+
     UnicodeSet fSet = new UnicodeSet();
     private BitSet fTypes = new BitSet(32);
 
     /**
      * @param breakTypes The types of break iterators that can use this engine.
-     *  For example, BreakIterator.KIND_LINE 
+     *  For example, BreakIterator.KIND_LINE
      */
     public DictionaryBreakEngine(Integer... breakTypes) {
         for (Integer type: breakTypes) {
@@ -163,15 +165,17 @@ abstract class DictionaryBreakEngine implements LanguageBreakEngine {
         }
     }
 
+    @Override
     public boolean handles(int c, int breakType) {
         return fTypes.get(breakType) &&  // this type can use us
                 fSet.contains(c);        // we recognize the character
     }
 
-    public int findBreaks(CharacterIterator text, int startPos, int endPos, 
+    @Override
+    public int findBreaks(CharacterIterator text, int startPos, int endPos,
             boolean reverse, int breakType, DequeI foundBreaks) {
          int result = 0;
-       
+
          // Find the span of characters included in the set.
          //   The span to break begins at the current position int the text, and
          //   extends towards the start or end of the text, depending on 'reverse'.
@@ -204,7 +208,7 @@ abstract class DictionaryBreakEngine implements LanguageBreakEngine {
 
         return result;
     }
-    
+
     void setCharacters(UnicodeSet set) {
         fSet = new UnicodeSet(set);
         fSet.compact();
diff --git a/app/src/main/java/com/ibm/icu/text/DictionaryData.java b/icu4j/src/main/java/com/ibm/icu/text/DictionaryData.java
similarity index 92%
rename from app/src/main/java/com/ibm/icu/text/DictionaryData.java
rename to icu4j/src/main/java/com/ibm/icu/text/DictionaryData.java
index 8610566..3980e3b 100644
--- a/app/src/main/java/com/ibm/icu/text/DictionaryData.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/DictionaryData.java
@@ -1,6 +1,8 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2012-2015, International Business Machines Corporation and
+ * Copyright (C) 2012-2016, International Business Machines Corporation and
  * others. All Rights Reserved.
  *******************************************************************************
  */
@@ -42,7 +44,7 @@ final class DictionaryData {
     private static final int DATA_FORMAT_ID = 0x44696374;
 
     public static DictionaryMatcher loadDictionaryFor(String dictType) throws IOException {
-        ICUResourceBundle rb = (ICUResourceBundle)UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BRKITR_BASE_NAME);
+        ICUResourceBundle rb = (ICUResourceBundle)UResourceBundle.getBundleInstance(ICUData.ICU_BRKITR_BASE_NAME);
         String dictFileName = rb.getStringWithFallback("dictionaries/" + dictType);
         dictFileName = ICUData.ICU_BRKITR_NAME + '/' + dictFileName;
         ByteBuffer bytes = ICUBinary.getRequiredData(dictFileName);
diff --git a/app/src/main/java/com/ibm/icu/text/DictionaryMatcher.java b/icu4j/src/main/java/com/ibm/icu/text/DictionaryMatcher.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/text/DictionaryMatcher.java
rename to icu4j/src/main/java/com/ibm/icu/text/DictionaryMatcher.java
index c46f003..f8b6a4e 100644
--- a/app/src/main/java/com/ibm/icu/text/DictionaryMatcher.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/DictionaryMatcher.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2012, International Business Machines Corporation and         *
diff --git a/app/src/main/java/com/ibm/icu/text/DigitList.java b/icu4j/src/main/java/com/ibm/icu/text/DigitList.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/text/DigitList.java
rename to icu4j/src/main/java/com/ibm/icu/text/DigitList.java
index e238472..12fb197 100644
--- a/app/src/main/java/com/ibm/icu/text/DigitList.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/DigitList.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2015, International Business Machines Corporation and    *
@@ -233,54 +235,6 @@ final class DigitList {
         return stringRep.toString();
     }
 
-    /**
-     * Return a <code>BigDecimal</code> representing the value stored in this
-     * <code>DigitList</code>.
-     * [bnf]
-     * @param isPositive determines the sign of the returned result
-     * @return the value of this object as a <code>BigDecimal</code>
-     */
-    ///CLOVER:OFF
-    // The method is in a protected class and is not called by anything
-    public java.math.BigDecimal getBigDecimal(boolean isPositive) {
-        if (isZero()) {
-            return java.math.BigDecimal.valueOf(0);
-        }
-        // if exponential notion is negative,
-        // we prefer to use BigDecimal constructor with scale,
-        // because it works better when extremely small value
-        // is used.  See #5698.
-        long scale = (long)count - (long)decimalAt;
-        if (scale > 0) {
-            int numDigits = count;
-            if (scale > (long)Integer.MAX_VALUE) {
-                // try to reduce the scale
-                long numShift = scale - (long)Integer.MAX_VALUE;
-                if (numShift < count) {
-                    numDigits -= numShift;
-                } else {
-                    // fallback to 0
-                    return new java.math.BigDecimal(0);
-                }
-            }
-            StringBuilder significantDigits = new StringBuilder(numDigits + 1);
-            if (!isPositive) {
-                significantDigits.append('-');
-            }
-            for (int i = 0; i < numDigits; i++) {
-                significantDigits.append((char)digits[i]);
-            }
-            BigInteger unscaledVal = new BigInteger(significantDigits.toString());
-            return new java.math.BigDecimal(unscaledVal, (int)scale);
-        } else {
-            // We should be able to use a negative scale value for a positive exponential
-            // value on JDK1.5.  But it is not supported by older JDK.  So, for now,
-            // we always use BigDecimal constructor which takes String.
-            return new java.math.BigDecimal(getStringRep(isPositive));
-        }
-    }
-    ///CLOVER:ON
-
     /**
      * Return an <code>ICU BigDecimal</code> representing the value stored in this
      * <code>DigitList</code>.
@@ -840,11 +794,6 @@ final class DigitList {
 //
 //    private static final double LOG10 = Math.log(10.0);
 
-    // (The following boilerplate methods are currently not called,
-    // and cannot be called by tests since this class is
-    // package-private.  The methods may be useful in the future, so
-    // we do not delete them.  2003-06-11 ICU 2.6 Alan)
-    ///CLOVER:OFF
     /**
      * equality test between two digit lists.
      */
@@ -884,5 +833,4 @@ final class DigitList {
         buf.append(decimalAt);
         return buf.toString();
     }
-    ///CLOVER:ON
 }
diff --git a/app/src/main/java/com/ibm/icu/text/DisplayContext.java b/icu4j/src/main/java/com/ibm/icu/text/DisplayContext.java
similarity index 79%
rename from app/src/main/java/com/ibm/icu/text/DisplayContext.java
rename to icu4j/src/main/java/com/ibm/icu/text/DisplayContext.java
index 821a1dc..751b476 100644
--- a/app/src/main/java/com/ibm/icu/text/DisplayContext.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/DisplayContext.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2012-2015, International Business Machines Corporation and    *
@@ -86,7 +88,26 @@ public enum DisplayContext {
      * e.g. "U.S." for US.
      * @stable ICU 54
      */
-    LENGTH_SHORT(Type.DISPLAY_LENGTH, 1);
+    LENGTH_SHORT(Type.DISPLAY_LENGTH, 1),
+    /**
+     * ================================
+     * Settings for SUBSTITUTE_HANDLING (choose one)
+     */
+    /**
+     * A possible setting for SUBSTITUTE_HANDLING:
+     * Returns a fallback value (e.g., the input code) when no data is available.
+     * This is the default behavior.
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    SUBSTITUTE(Type.SUBSTITUTE_HANDLING, 0),
+    /**
+     * A possible setting for SUBSTITUTE_HANDLING:
+     * Returns a null value when no data is available.
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    NO_SUBSTITUTE(Type.SUBSTITUTE_HANDLING, 1);
 
     /**
      * Type values for DisplayContext
@@ -108,7 +129,13 @@ public enum DisplayContext {
          * DISPLAY_LENGTH can be set to LENGTH_FULL or LENGTH_SHORT.
          * @stable ICU 54
          */
-        DISPLAY_LENGTH
+        DISPLAY_LENGTH,
+        /**
+         * SUBSTITUTE_HANDLING can be set to SUBSTITUTE or NO_SUBSTITUTE.
+         * @draft ICU 58
+         * @provisional This API might change or be removed in a future release.
+         */
+        SUBSTITUTE_HANDLING
     }
 
     private final Type type;
diff --git a/app/src/main/java/com/ibm/icu/text/DurationFormat.java b/icu4j/src/main/java/com/ibm/icu/text/DurationFormat.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/text/DurationFormat.java
rename to icu4j/src/main/java/com/ibm/icu/text/DurationFormat.java
index 2637a2d..3a0fcd2 100644
--- a/app/src/main/java/com/ibm/icu/text/DurationFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/DurationFormat.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2007-2015, International Business Machines Corporation and
@@ -37,7 +39,7 @@ public abstract class DurationFormat extends UFormat {
     public static DurationFormat getInstance(ULocale locale) {
         return BasicDurationFormat.getInstance(locale);
     }
-    
+
 
     /**
      * Subclass interface
@@ -47,7 +49,7 @@ public abstract class DurationFormat extends UFormat {
     @Deprecated
     protected DurationFormat() {
     }
-    
+
     /**
      * Subclass interface
      * @internal
@@ -68,6 +70,7 @@ public abstract class DurationFormat extends UFormat {
      * @deprecated ICU 56
      */
     @Deprecated
+    @Override
     public abstract StringBuffer format(Object object, StringBuffer toAppend,
             FieldPosition pos);
 
@@ -75,6 +78,7 @@ public abstract class DurationFormat extends UFormat {
      * DurationFormat cannot parse, by default. This method will throw an UnsupportedOperationException.
      * @deprecated ICU 56
      */
+    @Override
     @Deprecated
     public Object parseObject(String source, ParsePosition pos) {
        throw new UnsupportedOperationException();
@@ -87,7 +91,7 @@ public abstract class DurationFormat extends UFormat {
      * formatDurationFrom(long, long) using now
      * as the reference date, and the difference between now and
      * <code>targetDate.getTime()</code> as the duration.
-     * 
+     *
      * @param targetDate the ending date
      * @return the formatted time
      * @deprecated ICU 56
@@ -100,7 +104,7 @@ public abstract class DurationFormat extends UFormat {
      * <p>
      * This is a convenience method that calls formatDurationFrom
      * using the current system time as the reference date.
-     * 
+     *
      * @param duration the duration in milliseconds
      * @return the formatted time
      * @deprecated ICU 56
@@ -117,7 +121,7 @@ public abstract class DurationFormat extends UFormat {
      * The duration is expressed as the number of milliseconds in the
      * past (negative values) or future (positive values) with respect
      * to a reference date (expressed as milliseconds in epoch).
-     * 
+     *
      * @param duration the duration in milliseconds
      * @param referenceDate the date from which to compute the duration
      * @return the formatted time
diff --git a/app/src/main/java/com/ibm/icu/text/EscapeTransliterator.java b/icu4j/src/main/java/com/ibm/icu/text/EscapeTransliterator.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/text/EscapeTransliterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/EscapeTransliterator.java
index 9fb826f..2ceec92 100644
--- a/app/src/main/java/com/ibm/icu/text/EscapeTransliterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/EscapeTransliterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 **********************************************************************
 *   Copyright (c) 2001-2011, International Business Machines
@@ -80,31 +82,35 @@ class EscapeTransliterator extends Transliterator {
     static void register() {
         // Unicode: "U+10FFFF" hex, min=4, max=6
         Transliterator.registerFactory("Any-Hex/Unicode", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new EscapeTransliterator("Any-Hex/Unicode",
                                                 "U+", "", 16, 4, true, null);
             }
         });
-        
+
         // Java: "\\uFFFF" hex, min=4, max=4
         Transliterator.registerFactory("Any-Hex/Java", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new EscapeTransliterator("Any-Hex/Java",
                                                 "\\u", "", 16, 4, false, null);
             }
         });
-        
+
         // C: "\\uFFFF" hex, min=4, max=4; \\U0010FFFF hex, min=8, max=8
         Transliterator.registerFactory("Any-Hex/C", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new EscapeTransliterator("Any-Hex/C",
                                                 "\\u", "", 16, 4, true,
                        new EscapeTransliterator("", "\\U", "", 16, 8, true, null));
             }
         });
-        
+
         // XML: "&#x10FFFF;" hex, min=1, max=6
         Transliterator.registerFactory("Any-Hex/XML", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new EscapeTransliterator("Any-Hex/XML",
                                                 "&#x", ";", 16, 1, true, null);
@@ -113,6 +119,7 @@ class EscapeTransliterator extends Transliterator {
 
         // XML10: "&1114111;" dec, min=1, max=7 (not really "Any-Hex")
         Transliterator.registerFactory("Any-Hex/XML10", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new EscapeTransliterator("Any-Hex/XML10",
                                                 "&#", ";", 10, 1, true, null);
@@ -121,6 +128,7 @@ class EscapeTransliterator extends Transliterator {
 
         // Perl: "\\x{263A}" hex, min=1, max=6
         Transliterator.registerFactory("Any-Hex/Perl", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new EscapeTransliterator("Any-Hex/Perl",
                                                 "\\x{", "}", 16, 1, true, null);
@@ -129,14 +137,16 @@ class EscapeTransliterator extends Transliterator {
 
         // Plain: "FFFF" hex, min=4, max=6
         Transliterator.registerFactory("Any-Hex/Plain", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new EscapeTransliterator("Any-Hex/Plain",
                                                 "", "", 16, 4, true, null);
             }
         });
-        
+
         // Generic
         Transliterator.registerFactory("Any-Hex", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new EscapeTransliterator("Any-Hex",
                                                 "\\u", "", 16, 4, false, null);
@@ -164,6 +174,7 @@ class EscapeTransliterator extends Transliterator {
     /**
      * Implements {@link Transliterator#handleTransliterate}.
      */
+    @Override
     protected void handleTransliterate(Replaceable text,
                                        Position pos, boolean incremental) {
         int start = pos.start;
diff --git a/app/src/main/java/com/ibm/icu/text/FilteredBreakIteratorBuilder.java b/icu4j/src/main/java/com/ibm/icu/text/FilteredBreakIteratorBuilder.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/text/FilteredBreakIteratorBuilder.java
rename to icu4j/src/main/java/com/ibm/icu/text/FilteredBreakIteratorBuilder.java
index 53b285f..a265942 100644
--- a/app/src/main/java/com/ibm/icu/text/FilteredBreakIteratorBuilder.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/FilteredBreakIteratorBuilder.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014-2016, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/text/FilteredNormalizer2.java b/icu4j/src/main/java/com/ibm/icu/text/FilteredNormalizer2.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/FilteredNormalizer2.java
rename to icu4j/src/main/java/com/ibm/icu/text/FilteredNormalizer2.java
index e973ba2..419874d 100644
--- a/app/src/main/java/com/ibm/icu/text/FilteredNormalizer2.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/FilteredNormalizer2.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 *   Copyright (C) 2009-2014, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/text/FunctionReplacer.java b/icu4j/src/main/java/com/ibm/icu/text/FunctionReplacer.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/text/FunctionReplacer.java
rename to icu4j/src/main/java/com/ibm/icu/text/FunctionReplacer.java
index 6912298..a11f453 100644
--- a/app/src/main/java/com/ibm/icu/text/FunctionReplacer.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/FunctionReplacer.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 **********************************************************************
 *   Copyright (c) 2002-2010, International Business Machines Corporation
@@ -44,6 +46,7 @@ class FunctionReplacer implements UnicodeReplacer {
     /**
      * UnicodeReplacer API
      */
+    @Override
     public int replace(Replaceable text,
                        int start,
                        int limit,
@@ -62,6 +65,7 @@ class FunctionReplacer implements UnicodeReplacer {
     /**
      * UnicodeReplacer API
      */
+    @Override
     public String toReplacerPattern(boolean escapeUnprintable) {
         StringBuilder rule = new StringBuilder("&");
         rule.append(translit.getID());
@@ -76,6 +80,7 @@ class FunctionReplacer implements UnicodeReplacer {
      * into the given set.
      * @param toUnionTo the set into which to union the output characters
      */
+    @Override
     public void addReplacementSetTo(UnicodeSet toUnionTo) {
         toUnionTo.addAll(translit.getTargetSet());
     }
diff --git a/app/src/main/java/com/ibm/icu/text/IDNA.java b/icu4j/src/main/java/com/ibm/icu/text/IDNA.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/IDNA.java
rename to icu4j/src/main/java/com/ibm/icu/text/IDNA.java
index 6439409..831f026 100644
--- a/app/src/main/java/com/ibm/icu/text/IDNA.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/IDNA.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2003-2016, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/IdentifierInfo.java b/icu4j/src/main/java/com/ibm/icu/text/IdentifierInfo.java
similarity index 100%
rename from app/src/main/java/com/ibm/icu/text/IdentifierInfo.java
rename to icu4j/src/main/java/com/ibm/icu/text/IdentifierInfo.java
diff --git a/app/src/main/java/com/ibm/icu/text/KhmerBreakEngine.java b/icu4j/src/main/java/com/ibm/icu/text/KhmerBreakEngine.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/KhmerBreakEngine.java
rename to icu4j/src/main/java/com/ibm/icu/text/KhmerBreakEngine.java
index 695c61a..7c8926c 100644
--- a/app/src/main/java/com/ibm/icu/text/KhmerBreakEngine.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/KhmerBreakEngine.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014, International Business Machines Corporation and         *
diff --git a/app/src/main/java/com/ibm/icu/text/LanguageBreakEngine.java b/icu4j/src/main/java/com/ibm/icu/text/LanguageBreakEngine.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/text/LanguageBreakEngine.java
rename to icu4j/src/main/java/com/ibm/icu/text/LanguageBreakEngine.java
index 496cd61..b24f113 100644
--- a/app/src/main/java/com/ibm/icu/text/LanguageBreakEngine.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/LanguageBreakEngine.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014, International Business Machines Corporation and         *
diff --git a/app/src/main/java/com/ibm/icu/text/LaoBreakEngine.java b/icu4j/src/main/java/com/ibm/icu/text/LaoBreakEngine.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/LaoBreakEngine.java
rename to icu4j/src/main/java/com/ibm/icu/text/LaoBreakEngine.java
index 4c76f31..3937549 100644
--- a/app/src/main/java/com/ibm/icu/text/LaoBreakEngine.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/LaoBreakEngine.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014, International Business Machines Corporation and         *
diff --git a/app/src/main/java/com/ibm/icu/text/ListFormatter.java b/icu4j/src/main/java/com/ibm/icu/text/ListFormatter.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/ListFormatter.java
rename to icu4j/src/main/java/com/ibm/icu/text/ListFormatter.java
index cc1c76c..daec20b 100644
--- a/app/src/main/java/com/ibm/icu/text/ListFormatter.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/ListFormatter.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2012-2016, Google, International Business Machines Corporation and
@@ -13,6 +15,7 @@ import java.util.Iterator;
 import java.util.Locale;
 
 import com.ibm.icu.impl.ICUCache;
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.impl.SimpleCache;
 import com.ibm.icu.impl.SimpleFormatterImpl;
@@ -316,7 +319,7 @@ final public class ListFormatter {
 
         private static ListFormatter load(ULocale ulocale, String style) {
             ICUResourceBundle r = (ICUResourceBundle)UResourceBundle.
-                    getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, ulocale);
+                    getBundleInstance(ICUData.ICU_BASE_NAME, ulocale);
             StringBuilder sb = new StringBuilder();
             return new ListFormatter(
                 compilePattern(r.getWithFallback("listPattern/" + style + "/2").getString(), sb),
diff --git a/app/src/main/java/com/ibm/icu/text/LocaleDisplayNames.java b/icu4j/src/main/java/com/ibm/icu/text/LocaleDisplayNames.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/LocaleDisplayNames.java
rename to icu4j/src/main/java/com/ibm/icu/text/LocaleDisplayNames.java
index 3b97204..005e52a 100644
--- a/app/src/main/java/com/ibm/icu/text/LocaleDisplayNames.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/LocaleDisplayNames.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2016, International Business Machines Corporation and    *
@@ -109,7 +111,7 @@ public abstract class LocaleDisplayNames {
         if (FACTORY_DISPLAYCONTEXT != null) {
             try {
                 result = (LocaleDisplayNames) FACTORY_DISPLAYCONTEXT.invoke(null,
-                        locale, (Object[])contexts);
+                        locale, contexts);
             } catch (InvocationTargetException e) {
                 // fall through
             } catch (IllegalAccessException e) {
@@ -343,6 +345,12 @@ public abstract class LocaleDisplayNames {
          */
         @Override
         public boolean equals(Object obj) {
+            if (this == obj) {
+                return true;
+            }
+            if (obj == null || !(obj instanceof UiListItem)) {
+                return false;
+            }
             UiListItem other = (UiListItem)obj;
             return nameInDisplayLocale.equals(other.nameInDisplayLocale)
                     && nameInSelf.equals(other.nameInSelf)
@@ -389,6 +397,7 @@ public abstract class LocaleDisplayNames {
                 this.collator = collator;
                 this.useSelf = useSelf;
             }
+            @Override
             public int compare(UiListItem o1, UiListItem o2) {
                 int result = useSelf ? collator.compare(o1.nameInSelf, o2.nameInSelf)
                         : collator.compare(o1.nameInDisplayLocale, o2.nameInDisplayLocale);
diff --git a/app/src/main/java/com/ibm/icu/text/LowercaseTransliterator.java b/icu4j/src/main/java/com/ibm/icu/text/LowercaseTransliterator.java
similarity index 92%
rename from app/src/main/java/com/ibm/icu/text/LowercaseTransliterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/LowercaseTransliterator.java
index a1aa89d..95bb60b 100644
--- a/app/src/main/java/com/ibm/icu/text/LowercaseTransliterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/LowercaseTransliterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2011, International Business Machines Corporation and    *
@@ -20,14 +22,15 @@ class LowercaseTransliterator extends Transliterator{
      * Package accessible ID.
      */
     static final String _ID = "Any-Lower";
-    
-    // TODO: Add variants for tr, az, lt, default = default locale
+
+    // TODO: Add variants for tr/az, lt, default = default locale: ICU ticket #12720
 
     /**
      * System registration hook.
      */
     static void register() {
         Transliterator.registerFactory(_ID, new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new LowercaseTransliterator(ULocale.US);
             }
@@ -36,9 +39,9 @@ class LowercaseTransliterator extends Transliterator{
         Transliterator.registerSpecialInverse("Lower", "Upper", true);
     }
 
-    private ULocale locale;
+    private final ULocale locale;
 
-    private UCaseProps csp;
+    private final UCaseProps csp;
     private ReplaceableContextIterator iter;
     private StringBuilder result;
     private int[] locCache;
@@ -60,6 +63,7 @@ class LowercaseTransliterator extends Transliterator{
     /**
      * Implements {@link Transliterator#handleTransliterate}.
      */
+    @Override
     protected synchronized void handleTransliterate(Replaceable text,
                                        Position offsets, boolean isIncremental) {
         if(csp==null) {
@@ -68,7 +72,7 @@ class LowercaseTransliterator extends Transliterator{
 
         if(offsets.start >= offsets.limit) {
             return;
-        } 
+        }
 
         iter.setText(text);
         result.setLength(0);
@@ -110,10 +114,10 @@ class LowercaseTransliterator extends Transliterator{
         }
         offsets.start = offsets.limit;
     }
-    
+
     // NOTE: normally this would be static, but because the results vary by locale....
     SourceTargetUtility sourceTargetUtility = null;
-    
+
     /* (non-Javadoc)
      * @see com.ibm.icu.text.Transliterator#addSourceTargetSet(com.ibm.icu.text.UnicodeSet, com.ibm.icu.text.UnicodeSet, com.ibm.icu.text.UnicodeSet)
      */
@@ -122,8 +126,9 @@ class LowercaseTransliterator extends Transliterator{
         synchronized (this) {
             if (sourceTargetUtility == null) {
                 sourceTargetUtility = new SourceTargetUtility(new Transform<String,String>() {
+                    @Override
                     public String transform(String source) {
-                        return UCharacter.toLowerCase(locale, source);                    
+                        return UCharacter.toLowerCase(locale, source);
                     }
                 });
             }
diff --git a/app/src/main/java/com/ibm/icu/text/MeasureFormat.java b/icu4j/src/main/java/com/ibm/icu/text/MeasureFormat.java
similarity index 89%
rename from app/src/main/java/com/ibm/icu/text/MeasureFormat.java
rename to icu4j/src/main/java/com/ibm/icu/text/MeasureFormat.java
index 29df617..ca7dcde 100644
--- a/app/src/main/java/com/ibm/icu/text/MeasureFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/MeasureFormat.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  **********************************************************************
  * Copyright (c) 2004-2016, International Business Machines
@@ -562,9 +564,38 @@ public class MeasureFormat extends UFormat {
                     measures[i],
                     i == measures.length - 1 ? numberFormat : integerFormat);
         }
-        return appendTo.append(listFormatter.format((Object[]) results));                 
+        return appendTo.append(listFormatter.format((Object[]) results));
 
-    }   
+    }
+
+    /**
+     * Gets the display name of the specified {@link MeasureUnit} corresponding to the current
+     * locale and format width.
+     * @param unit  The unit for which to get a display name.
+     * @return  The display name in the locale and width specified in
+     *          {@link MeasureFormat#getInstance}, or null if there is no display name available
+     *          for the specified unit.
+     *
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public String getUnitDisplayName(MeasureUnit unit) {
+        FormatWidth width = getRegularWidth(formatWidth);
+        Map<FormatWidth, String> styleToDnam = cache.unitToStyleToDnam.get(unit);
+        if (styleToDnam == null) {
+            return null;
+        }
+
+        String dnam = styleToDnam.get(width);
+        if (dnam != null) {
+            return dnam;
+        }
+        FormatWidth fallbackWidth = cache.widthFallback[width.ordinal()];
+        if (fallbackWidth != null) {
+            dnam = styleToDnam.get(fallbackWidth);
+        }
+        return dnam;
+    }
 
     /**
      * Two MeasureFormats, a and b, are equal if and only if they have the same formatWidth,
@@ -741,117 +772,126 @@ public class MeasureFormat extends UFormat {
      * C++: Each inner sink class has a reference to the main outer sink.
      * Java: Use non-static inner classes instead.
      */
-    private static final class UnitDataSink extends UResource.TableSink {
-        /**
-         * Sink for a table of display patterns. For example,
-         * unitsShort/duration/hour contains other{"{0} hrs"}.
-         */
-        class UnitPatternSink extends UResource.TableSink {
-            String[] patterns;
-
-            void setFormatterIfAbsent(int index, UResource.Value value, int minPlaceholders) {
-                if (patterns == null) {
-                    EnumMap<FormatWidth, String[]> styleToPatterns =
-                            cacheData.unitToStyleToPatterns.get(unit);
-                    if (styleToPatterns == null) {
-                        styleToPatterns =
-                                new EnumMap<FormatWidth, String[]>(FormatWidth.class);
-                        cacheData.unitToStyleToPatterns.put(unit, styleToPatterns);
-                    } else {
-                        patterns = styleToPatterns.get(width);
-                    }
-                    if (patterns == null) {
-                        patterns = new String[MeasureFormatData.PATTERN_COUNT];
-                        styleToPatterns.put(width, patterns);
-                    }
+    private static final class UnitDataSink extends UResource.Sink {
+        void setFormatterIfAbsent(int index, UResource.Value value, int minPlaceholders) {
+            if (patterns == null) {
+                EnumMap<FormatWidth, String[]> styleToPatterns =
+                        cacheData.unitToStyleToPatterns.get(unit);
+                if (styleToPatterns == null) {
+                    styleToPatterns =
+                            new EnumMap<FormatWidth, String[]>(FormatWidth.class);
+                    cacheData.unitToStyleToPatterns.put(unit, styleToPatterns);
+                } else {
+                    patterns = styleToPatterns.get(width);
                 }
-                if (patterns[index] == null) {
-                    patterns[index] = SimpleFormatterImpl.compileToStringMinMaxArguments(
-                            value.getString(), sb, minPlaceholders, 1);
+                if (patterns == null) {
+                    patterns = new String[MeasureFormatData.PATTERN_COUNT];
+                    styleToPatterns.put(width, patterns);
                 }
             }
+            if (patterns[index] == null) {
+                patterns[index] = SimpleFormatterImpl.compileToStringMinMaxArguments(
+                        value.getString(), sb, minPlaceholders, 1);
+            }
+        }
 
-            @Override
-            public void put(UResource.Key key, UResource.Value value) {
-                if (key.contentEquals("dnam")) {
-                    // Skip the unit display name for now.
-                } else if (key.contentEquals("per")) {
-                    // For example, "{0}/h".
-                    setFormatterIfAbsent(MeasureFormatData.PER_UNIT_INDEX, value, 1);
-                } else {
-                    // The key must be one of the plural form strings. For example:
-                    // one{"{0} hr"}
-                    // other{"{0} hrs"}
-                    setFormatterIfAbsent(StandardPlural.indexFromString(key), value, 0);
-                }
+        void setDnamIfAbsent(UResource.Value value) {
+            EnumMap<FormatWidth, String> styleToDnam = cacheData.unitToStyleToDnam.get(unit);
+            if (styleToDnam == null) {
+                styleToDnam = new EnumMap<FormatWidth, String>(FormatWidth.class);
+                cacheData.unitToStyleToDnam.put(unit, styleToDnam);
+            }
+            if (styleToDnam.get(width) == null) {
+                styleToDnam.put(width, value.getString());
+            }
+        }
+
+        /**
+         * Consume a display pattern. For example,
+         * unitsShort/duration/hour contains other{"{0} hrs"}.
+         */
+        void consumePattern(UResource.Key key, UResource.Value value) {
+            if (key.contentEquals("dnam")) {
+                // The display name for the unit in the current width.
+                setDnamIfAbsent(value);
+            } else if (key.contentEquals("per")) {
+                // For example, "{0}/h".
+                setFormatterIfAbsent(MeasureFormatData.PER_UNIT_INDEX, value, 1);
+            } else {
+                // The key must be one of the plural form strings. For example:
+                // one{"{0} hr"}
+                // other{"{0} hrs"}
+                setFormatterIfAbsent(StandardPlural.indexFromString(key), value, 0);
             }
         }
-        UnitPatternSink patternSink = new UnitPatternSink();
 
         /**
-         * Sink for a table of per-unit tables. For example,
+         * Consume a table of per-unit tables. For example,
          * unitsShort/duration contains tables for duration-unit subtypes day & hour.
          */
-        class UnitSubtypeSink extends UResource.TableSink {
-            @Override
-            public UResource.TableSink getOrCreateTableSink(UResource.Key key, int initialSize) {
-                // Should we ignore or reject unknown units?
-                unit = MeasureUnit.internalGetInstance(type, key.toString());  // never null
-                // Trigger a fresh lookup of the patterns for this unit+width.
-                patternSink.patterns = null;
-                return patternSink;
+        void consumeSubtypeTable(UResource.Key key, UResource.Value value) {
+            unit = MeasureUnit.internalGetInstance(type, key.toString());  // never null
+            // Trigger a fresh lookup of the patterns for this unit+width.
+            patterns = null;
+
+            if (value.getType() == ICUResourceBundle.STRING) {
+                // Units like "coordinate" that don't have plural variants
+                setFormatterIfAbsent(StandardPlural.OTHER.ordinal(), value, 0);
+            } else if (value.getType() == ICUResourceBundle.TABLE) {
+                // Units that have plural variants
+                UResource.Table patternTableTable = value.getTable();
+                for (int i = 0; patternTableTable.getKeyAndValue(i, key, value); i++) {
+                    consumePattern(key, value);
+                }
+            } else {
+                throw new ICUException("Data for unit '" + unit + "' is in an unknown format");
             }
         }
-        UnitSubtypeSink subtypeSink = new UnitSubtypeSink();
 
         /**
-         * Sink for compound x-per-y display pattern. For example,
+         * Consume compound x-per-y display pattern. For example,
          * unitsShort/compound/per may be "{0}/{1}".
          */
-        class UnitCompoundSink extends UResource.TableSink {
-            @Override
-            public void put(UResource.Key key, UResource.Value value) {
-                if (key.contentEquals("per")) {
-                    cacheData.styleToPerPattern.put(width,
-                            SimpleFormatterImpl.compileToStringMinMaxArguments(
-                                    value.getString(), sb, 2, 2));
-                }
+        void consumeCompoundPattern(UResource.Key key, UResource.Value value) {
+            if (key.contentEquals("per")) {
+                cacheData.styleToPerPattern.put(width,
+                        SimpleFormatterImpl.compileToStringMinMaxArguments(
+                                value.getString(), sb, 2, 2));
             }
         }
-        UnitCompoundSink compoundSink = new UnitCompoundSink();
 
         /**
-         * Sink for a table of unit type tables. For example,
+         * Consume a table of unit type tables. For example,
          * unitsShort contains tables for area & duration.
          * It also contains a table for the compound/per pattern.
          */
-        class UnitTypeSink extends UResource.TableSink {
-            @Override
-            public UResource.TableSink getOrCreateTableSink(UResource.Key key, int initialSize) {
-                if (key.contentEquals("currency")) {
-                    // Skip.
-                } else if (key.contentEquals("compound")) {
-                    if (!cacheData.hasPerFormatter(width)) {
-                        return compoundSink;
+        void consumeUnitTypesTable(UResource.Key key, UResource.Value value) {
+            if (key.contentEquals("currency")) {
+                // Skip.
+            } else if (key.contentEquals("compound")) {
+                if (!cacheData.hasPerFormatter(width)) {
+                    UResource.Table compoundTable = value.getTable();
+                    for (int i = 0; compoundTable.getKeyAndValue(i, key, value); i++) {
+                        consumeCompoundPattern(key, value);
                     }
-                } else {
-                    type = key.toString();
-                    return subtypeSink;
                 }
-                return null;
+            } else {
+                type = key.toString();
+                UResource.Table subtypeTable = value.getTable();
+                for (int i = 0; subtypeTable.getKeyAndValue(i, key, value); i++) {
+                    consumeSubtypeTable(key, value);
+                }
             }
         }
-        UnitTypeSink typeSink = new UnitTypeSink();
 
         UnitDataSink(MeasureFormatData outputData) {
             cacheData = outputData;
         }
-        @Override
-        public void put(UResource.Key key, UResource.Value value) {
+
+        void consumeAlias(UResource.Key key, UResource.Value value) {
             // Handle aliases like
             // units:alias{"/LOCALE/unitsShort"}
             // which should only occur in the root bundle.
-            if (value.getType() != ICUResourceBundle.ALIAS) { return; }
             FormatWidth sourceWidth = widthFromKey(key);
             if (sourceWidth == null) {
                 // Alias from something we don't care about.
@@ -870,12 +910,14 @@ public class MeasureFormat extends UFormat {
             }
             cacheData.widthFallback[sourceWidth.ordinal()] = targetWidth;
         }
-        @Override
-        public UResource.TableSink getOrCreateTableSink(UResource.Key key, int initialSize) {
+
+        public void consumeTable(UResource.Key key, UResource.Value value) {
             if ((width = widthFromKey(key)) != null) {
-                return typeSink;
+                UResource.Table unitTypesTable = value.getTable();
+                for (int i = 0; unitTypesTable.getKeyAndValue(i, key, value); i++) {
+                    consumeUnitTypesTable(key, value);
+                }
             }
-            return null;
         }
 
         static FormatWidth widthFromKey(UResource.Key key) {
@@ -906,6 +948,19 @@ public class MeasureFormat extends UFormat {
             return null;
         }
 
+        @Override
+        public void put(UResource.Key key, UResource.Value value, boolean noFallback) {
+            // Main entry point to sink
+            UResource.Table widthsTable = value.getTable();
+            for (int i = 0; widthsTable.getKeyAndValue(i, key, value); i++) {
+                if (value.getType() == ICUResourceBundle.ALIAS) {
+                    consumeAlias(key, value);
+                } else {
+                    consumeTable(key, value);
+                }
+            }
+        }
+
         // Output data.
         MeasureFormatData cacheData;
 
@@ -916,6 +971,7 @@ public class MeasureFormat extends UFormat {
 
         // Temporary
         StringBuilder sb = new StringBuilder();
+        String[] patterns;
     }
 
     /**
@@ -926,7 +982,7 @@ public class MeasureFormat extends UFormat {
                 (ICUResourceBundle)UResourceBundle.getBundleInstance(ICUData.ICU_UNIT_BASE_NAME, locale);
         MeasureFormatData cacheData = new MeasureFormatData();
         UnitDataSink sink = new UnitDataSink(cacheData);
-        resource.getAllTableItemsWithFallback("", sink);
+        resource.getAllItemsWithFallback("", sink);
         return cacheData;
     }
 
@@ -1061,6 +1117,8 @@ public class MeasureFormat extends UFormat {
         /** Measure unit -> format width -> array of patterns ("{0} meters") (plurals + PER_UNIT_INDEX) */
         final Map<MeasureUnit, EnumMap<FormatWidth, String[]>> unitToStyleToPatterns =
                 new HashMap<MeasureUnit, EnumMap<FormatWidth, String[]>>();
+        final Map<MeasureUnit, EnumMap<FormatWidth, String>> unitToStyleToDnam =
+                new HashMap<MeasureUnit, EnumMap<FormatWidth, String>>();
         final EnumMap<FormatWidth, String> styleToPerPattern =
                 new EnumMap<FormatWidth, String>(FormatWidth.class);;
     }
@@ -1096,7 +1154,7 @@ public class MeasureFormat extends UFormat {
             return positive ? ((DecimalFormat)nf).getPositivePrefix() : ((DecimalFormat)nf).getNegativePrefix();
         }
         public String getSuffix(boolean positive) {
-            return positive ? ((DecimalFormat)nf).getPositiveSuffix() : ((DecimalFormat)nf).getPositiveSuffix();
+            return positive ? ((DecimalFormat)nf).getPositiveSuffix() : ((DecimalFormat)nf).getNegativeSuffix();
         }
     }
 
diff --git a/app/src/main/java/com/ibm/icu/text/MessageFormat.java b/icu4j/src/main/java/com/ibm/icu/text/MessageFormat.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/MessageFormat.java
rename to icu4j/src/main/java/com/ibm/icu/text/MessageFormat.java
index ee61e3e..9b2dd30 100644
--- a/app/src/main/java/com/ibm/icu/text/MessageFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/MessageFormat.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 **********************************************************************
 * Copyright (c) 2004-2016, International Business Machines
@@ -305,7 +307,7 @@ import com.ibm.icu.util.ULocale.Category;
  * System.out.println(msgFmt.format(args));
  * args.put("num_files", 3);
  * System.out.println(msgFmt.format(args));
- * 
+ *
  * <em>output</em>:
  * There are no files on disk "MyDisk".
  * There are 3 files on "MyDisk".
@@ -435,7 +437,7 @@ public class MessageFormat extends UFormat {
     public ULocale getULocale() {
         return ulocale;
     }
-    
+
     /**
      * Sets the pattern used by this message format.
      * Parses the pattern and caches Format objects for simple argument types.
@@ -1051,6 +1053,7 @@ public class MessageFormat extends UFormat {
      *         an array of Object and this format uses named arguments
      * @stable ICU 3.0
      */
+    @Override
     public final StringBuffer format(Object arguments, StringBuffer result,
                                      FieldPosition pos)
     {
@@ -1094,6 +1097,7 @@ public class MessageFormat extends UFormat {
      *         expected by the corresponding argument or custom Format object.
      * @stable ICU 3.8
      */
+    @Override
     public AttributedCharacterIterator formatToCharacterIterator(Object arguments) {
         if (arguments == null) {
             throw new NullPointerException(
@@ -1146,7 +1150,7 @@ public class MessageFormat extends UFormat {
                     "This method is not available in MessageFormat objects " +
                     "that use named argument.");
         }
-        
+
         // Count how many slots we need in the array.
         int maxArgId = -1;
         for (int partIndex = 0; (partIndex = nextTopLevelArgStart(partIndex)) >= 0;) {
@@ -1165,7 +1169,7 @@ public class MessageFormat extends UFormat {
 
         return resultArray;
     }
-    
+
     /**
      * {@icu} Parses the string, returning the results in a Map.
      * This is similar to the version that returns an array
@@ -1186,9 +1190,9 @@ public class MessageFormat extends UFormat {
         if (pos.getIndex() == backupStartPos) {
             return null;
         }
-        return result;        
+        return result;
     }
-    
+
     /**
      * Parses text from the beginning of the given string to produce an object
      * array.
@@ -1263,7 +1267,7 @@ public class MessageFormat extends UFormat {
             // We do not support parsing Plural formats. (No REPLACE_NUMBER here.)
             assert type==Part.Type.ARG_START : "Unexpected Part "+part+" in parsed message.";
             int argLimit=msgPattern.getLimitPartIndex(i);
-            
+
             ArgType argType=part.getArgType();
             part=msgPattern.getPart(++i);
             // Compute the argId, so we can use it as a key.
@@ -1403,6 +1407,7 @@ public class MessageFormat extends UFormat {
      * @throws NullPointerException if <code>pos</code> is null.
      * @stable ICU 3.0
      */
+    @Override
     public Object parseObject(String source, ParsePosition pos) {
         if (!msgPattern.hasNamedArguments()) {
             return parse(source, pos);
@@ -1427,7 +1432,7 @@ public class MessageFormat extends UFormat {
         } else {
             other.customFormatArgStarts = null;
         }
-        
+
         if (cachedFormatters != null) {
             other.cachedFormatters = new HashMap<Integer, Format>();
             Iterator<Map.Entry<Integer, Format>> it = cachedFormatters.entrySet().iterator();
@@ -1438,7 +1443,7 @@ public class MessageFormat extends UFormat {
         } else {
             other.cachedFormatters = null;
         }
-        
+
         other.msgPattern = msgPattern == null ? null : (MessagePattern)msgPattern.clone();
         other.stockDateFormatter =
                 stockDateFormatter == null ? null : (DateFormat) stockDateFormatter.clone();
@@ -1508,6 +1513,7 @@ public class MessageFormat extends UFormat {
          *
          * @stable ICU 3.8
          */
+        @Override
         protected Object readResolve() throws InvalidObjectException {
             if (this.getClass() != MessageFormat.Field.class) {
                 throw new InvalidObjectException(
@@ -1822,7 +1828,7 @@ public class MessageFormat extends UFormat {
      * as soon as it finds an argument, or it reaches the end of the string.
      * @param from Index in the pattern string to start from.
      * @return A substring from the pattern string representing the longest possible
-     *         substring with no arguments. 
+     *         substring with no arguments.
      */
     private String getLiteralStringUntilNextArgument(int from) {
         StringBuilder b = new StringBuilder();
@@ -2078,6 +2084,7 @@ public class MessageFormat extends UFormat {
             msgFormat = mf;
             this.type = type;
         }
+        @Override
         public String select(Object ctx, double number) {
             if(rules == null) {
                 rules = PluralRules.forLocale(msgFormat.ulocale, type);
diff --git a/app/src/main/java/com/ibm/icu/text/MessagePattern.java b/icu4j/src/main/java/com/ibm/icu/text/MessagePattern.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/MessagePattern.java
rename to icu4j/src/main/java/com/ibm/icu/text/MessagePattern.java
index c7fd2ab..1331672 100644
--- a/app/src/main/java/com/ibm/icu/text/MessagePattern.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/MessagePattern.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 *   Copyright (C) 2010-2016, International Business Machines
@@ -872,6 +874,7 @@ public final class MessagePattern implements Cloneable, Freezable<MessagePattern
      * @return a copy of this object.
      * @stable ICU 4.8
      */
+    @Override
     @SuppressWarnings("unchecked")
     public MessagePattern cloneAsThawed() {
         MessagePattern newMsg;
@@ -890,9 +893,10 @@ public final class MessagePattern implements Cloneable, Freezable<MessagePattern
 
     /**
      * Freezes this object, making it immutable and thread-safe.
-     * @return this 
+     * @return this
      * @stable ICU 4.8
      */
+    @Override
     public MessagePattern freeze() {
         frozen=true;
         return this;
@@ -903,6 +907,7 @@ public final class MessagePattern implements Cloneable, Freezable<MessagePattern
      * @return true if this object is frozen.
      * @stable ICU 4.8
      */
+    @Override
     public boolean isFrozen() {
         return frozen;
     }
@@ -936,7 +941,7 @@ public final class MessagePattern implements Cloneable, Freezable<MessagePattern
             char c=msg.charAt(index++);
             if(c=='\'') {
                 if(index==msg.length()) {
-                    // The apostrophe is the last character in the pattern. 
+                    // The apostrophe is the last character in the pattern.
                     // Add a Part for auto-quoting.
                     addPart(Part.Type.INSERT_CHAR, index, 0, '\'');  // value=char to be inserted
                     needsAutoQuoting=true;
diff --git a/app/src/main/java/com/ibm/icu/text/MessagePatternUtil.java b/icu4j/src/main/java/com/ibm/icu/text/MessagePatternUtil.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/MessagePatternUtil.java
rename to icu4j/src/main/java/com/ibm/icu/text/MessagePatternUtil.java
index b35da9a..40c6670 100644
--- a/app/src/main/java/com/ibm/icu/text/MessagePatternUtil.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/MessagePatternUtil.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 *   Copyright (C) 2011-2014, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/text/NFRule.java b/icu4j/src/main/java/com/ibm/icu/text/NFRule.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/text/NFRule.java
rename to icu4j/src/main/java/com/ibm/icu/text/NFRule.java
index f65d1a5..018f8ea 100644
--- a/app/src/main/java/com/ibm/icu/text/NFRule.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/NFRule.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2015, International Business Machines Corporation and    *
@@ -165,7 +167,7 @@ final class NFRule {
             // base value is an even multiple of its divisor (or it's one
             // of the special rules)
             if ((rule1.baseValue > 0
-                 && rule1.baseValue % (Math.pow(rule1.radix, rule1.exponent)) == 0)
+                 && rule1.baseValue % (power(rule1.radix, rule1.exponent)) == 0)
                 || rule1.baseValue == IMPROPER_FRACTION_RULE
                 || rule1.baseValue == MASTER_RULE)
             {
@@ -565,7 +567,7 @@ final class NFRule {
         // gives us 1.9999999996 instead of 2.  The extra logic here is to take
         // that into account
         short tempResult = (short)(Math.log(baseValue) / Math.log(radix));
-        if (Math.pow(radix, tempResult + 1) <= baseValue) {
+        if (power(radix, (short)(tempResult + 1)) <= baseValue) {
             return (short)(tempResult + 1);
         } else {
             return tempResult;
@@ -721,8 +723,8 @@ final class NFRule {
      * of its substitutions)
      * @return The rule's divisor
      */
-    public double getDivisor() {
-        return Math.pow(radix, exponent);
+    public long getDivisor() {
+        return power(radix, exponent);
     }
 
     //-----------------------------------------------------------------------
@@ -738,7 +740,7 @@ final class NFRule {
      * @param pos The position in toInsertInto where the resultant text
      * should be inserted
      */
-    public void doFormat(long number, StringBuffer toInsertInto, int pos, int recursionCount) {
+    public void doFormat(long number, StringBuilder toInsertInto, int pos, int recursionCount) {
         // first, insert the rule's rule text into toInsertInto at the
         // specified position, then insert the results of the substitutions
         // into the right places in toInsertInto (notice we do the
@@ -756,7 +758,7 @@ final class NFRule {
             if (pluralRuleEnd < ruleText.length() - 1) {
                 toInsertInto.insert(pos, ruleText.substring(pluralRuleEnd + 2));
             }
-            toInsertInto.insert(pos, rulePatternFormat.format((long)(number/Math.pow(radix, exponent))));
+            toInsertInto.insert(pos, rulePatternFormat.format(number / power(radix, exponent)));
             if (pluralRuleStart > 0) {
                 toInsertInto.insert(pos, ruleText.substring(0, pluralRuleStart));
             }
@@ -779,7 +781,7 @@ final class NFRule {
      * @param pos The position in toInsertInto where the resultant text
      * should be inserted
      */
-    public void doFormat(double number, StringBuffer toInsertInto, int pos, int recursionCount) {
+    public void doFormat(double number, StringBuilder toInsertInto, int pos, int recursionCount) {
         // first, insert the rule's rule text into toInsertInto at the
         // specified position, then insert the results of the substitutions
         // into the right places in toInsertInto
@@ -802,10 +804,10 @@ final class NFRule {
             if (0 <= pluralVal && pluralVal < 1) {
                 // We're in a fractional rule, and we have to match the NumeratorSubstitution behavior.
                 // 2.3 can become 0.2999999999999998 for the fraction due to rounding errors.
-                pluralVal = Math.round(pluralVal * Math.pow(radix, exponent));
+                pluralVal = Math.round(pluralVal * power(radix, exponent));
             }
             else {
-                pluralVal = pluralVal / Math.pow(radix, exponent);
+                pluralVal = pluralVal / power(radix, exponent);
             }
             toInsertInto.insert(pos, rulePatternFormat.format((long)(pluralVal)));
             if (pluralRuleStart > 0) {
@@ -821,6 +823,31 @@ final class NFRule {
         }
     }
 
+    /**
+     * This is an equivalent to Math.pow that accurately works on 64-bit numbers
+     * @param base The base
+     * @param exponent The exponent
+     * @return radix ** exponent
+     * @see Math#pow(double, double)
+     */
+    static long power(long base, short exponent) {
+        if (exponent < 0) {
+            throw new IllegalArgumentException("Exponent can not be negative");
+        }
+        if (base < 0) {
+            throw new IllegalArgumentException("Base can not be negative");
+        }
+        long result = 1;
+        while (exponent > 0) {
+            if ((exponent & 1) == 1) {
+                result *= base;
+            }
+            base *= base;
+            exponent >>= 1;
+        }
+        return result;
+    }
+
     /**
      * Used by the owning rule set to determine whether to invoke the
      * rollback rule (i.e., whether this rule or the one that precedes
@@ -829,7 +856,7 @@ final class NFRule {
      * @return True if the rule set should use the rule that precedes
      * this one in its list; false if it should use this rule
      */
-    public boolean shouldRollBack(double number) {
+    public boolean shouldRollBack(long number) {
         // we roll back if the rule contains a modulus substitution,
         // the number being formatted is an even multiple of the rule's
         // divisor, and the rule's base value is NOT an even multiple
@@ -846,8 +873,11 @@ final class NFRule {
         // a modulus substitution, its base value isn't an even multiple
         // of 100, and the value we're trying to format _is_ an even
         // multiple of 100.  This is called the "rollback rule."
-        return ((sub1 != null && sub1.isModulusSubstitution()) || (sub2 != null && sub2.isModulusSubstitution()))
-                && (number % Math.pow(radix, exponent)) == 0 && (baseValue % Math.pow(radix, exponent)) != 0;
+        if (!((sub1 != null && sub1.isModulusSubstitution()) || (sub2 != null && sub2.isModulusSubstitution()))) {
+            return false;
+        }
+        long divisor = power(radix, exponent);
+        return (number % divisor) == 0 && (baseValue % divisor) != 0;
     }
 
     //-----------------------------------------------------------------------
@@ -1275,7 +1305,7 @@ final class NFRule {
      */
     private boolean allIgnorable(String str) {
         // if the string is empty, we can just return true
-        if (str.length() == 0) {
+        if (str == null || str.length() == 0) {
             return true;
         }
         RbnfLenientScanner scanner = formatter.getLenientScanner();
diff --git a/app/src/main/java/com/ibm/icu/text/NFRuleSet.java b/icu4j/src/main/java/com/ibm/icu/text/NFRuleSet.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/NFRuleSet.java
rename to icu4j/src/main/java/com/ibm/icu/text/NFRuleSet.java
index 9e9b6bb..30838f5 100644
--- a/app/src/main/java/com/ibm/icu/text/NFRuleSet.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/NFRuleSet.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2015, International Business Machines Corporation and    *
@@ -428,7 +430,7 @@ final class NFRuleSet {
      * @param pos The position in toInsertInto where the result of
      * this operation is to be inserted
      */
-    public void format(long number, StringBuffer toInsertInto, int pos, int recursionCount) {
+    public void format(long number, StringBuilder toInsertInto, int pos, int recursionCount) {
         if (recursionCount >= RECURSION_LIMIT) {
             throw new IllegalStateException("Recursion limit exceeded when applying ruleSet " + name);
         }
@@ -444,7 +446,7 @@ final class NFRuleSet {
      * @param pos The position in toInsertInto where the result of
      * this operation is to be inserted
      */
-    public void format(double number, StringBuffer toInsertInto, int pos, int recursionCount) {
+    public void format(double number, StringBuilder toInsertInto, int pos, int recursionCount) {
         if (recursionCount >= RECURSION_LIMIT) {
             throw new IllegalStateException("Recursion limit exceeded when applying ruleSet " + name);
         }
@@ -491,7 +493,7 @@ final class NFRuleSet {
         }
 
         // if the number isn't an integer, we use one f the fraction rules...
-        if (nonNumericalRules != null && number != Math.floor(number)) {
+        if (number != Math.floor(number)) {
             if (number < 1 && nonNumericalRules[PROPER_FRACTION_RULE_INDEX] != null) {
                 // if the number is between 0 and 1, return the proper
                 // fraction rule
@@ -504,7 +506,7 @@ final class NFRuleSet {
         }
 
         // if there's a master rule, use it to format the number
-        if (nonNumericalRules != null && nonNumericalRules[MASTER_RULE_INDEX] != null) {
+        if (nonNumericalRules[MASTER_RULE_INDEX] != null) {
             return nonNumericalRules[MASTER_RULE_INDEX];
         }
         else {
diff --git a/app/src/main/java/com/ibm/icu/text/NFSubstitution.java b/icu4j/src/main/java/com/ibm/icu/text/NFSubstitution.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/text/NFSubstitution.java
rename to icu4j/src/main/java/com/ibm/icu/text/NFSubstitution.java
index bf5d1e8..057069d 100644
--- a/app/src/main/java/com/ibm/icu/text/NFSubstitution.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/NFSubstitution.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2015, International Business Machines Corporation and    *
@@ -99,7 +101,7 @@ abstract class NFSubstitution {
             }
             else {
                 // otherwise, return a MultiplierSubstitution
-                return new MultiplierSubstitution(pos, rule.getDivisor(), ruleSet,
+                return new MultiplierSubstitution(pos, rule, ruleSet,
                                                   description);
             }
 
@@ -129,7 +131,7 @@ abstract class NFSubstitution {
             }
             else {
                 // otherwise, return a ModulusSubstitution
-                return new ModulusSubstitution(pos, rule.getDivisor(), rulePredecessor,
+                return new ModulusSubstitution(pos, rule, rulePredecessor,
                                                ruleSet, description);
             }
         case '=':
@@ -217,7 +219,7 @@ abstract class NFSubstitution {
      * @param radix The radix of the divisor
      * @param exponent The exponent of the divisor
      */
-    public void setDivisor(int radix, int exponent) {
+    public void setDivisor(int radix, short exponent) {
         // a no-op for all substitutions except multiplier and modulus substitutions
     }
 
@@ -286,24 +288,15 @@ abstract class NFSubstitution {
      * rule text begins (this value is added to this substitution's
      * position to determine exactly where to insert the new text)
      */
-    public void doSubstitution(long number, StringBuffer toInsertInto, int position, int recursionCount) {
-        if (ruleSet != null) {
-            // perform a transformation on the number that is dependent
-            // on the type of substitution this is, then just call its
-            // rule set's format() method to format the result
-            long numberToFormat = transformNumber(number);
+    public void doSubstitution(long number, StringBuilder toInsertInto, int position, int recursionCount) {
+        // perform a transformation on the number that is dependent
+        // on the type of substitution this is, then just call its
+        // rule set's format() method to format the result
+        long numberToFormat = transformNumber(number);
 
+        if (ruleSet != null) {
             ruleSet.format(numberToFormat, toInsertInto, position + pos, recursionCount);
         } else {
-            // or perform the transformation on the number (preserving
-            // the result's fractional part if the formatter it set
-            // to show it), then use that formatter's format() method
-            // to format the result
-            double numberToFormat = transformNumber((double)number);
-            if (numberFormat.getMaximumFractionDigits() == 0) {
-                numberToFormat = Math.floor(numberToFormat);
-            }
-
             toInsertInto.insert(position + pos, numberFormat.format(numberToFormat));
         }
     }
@@ -318,7 +311,7 @@ abstract class NFSubstitution {
      * rule text begins (this value is added to this substitution's
      * position to determine exactly where to insert the new text)
      */
-    public void doSubstitution(double number, StringBuffer toInsertInto, int position, int recursionCount) {
+    public void doSubstitution(double number, StringBuilder toInsertInto, int position, int recursionCount) {
         // perform a transformation on the number being formatted that
         // is dependent on the type of substitution this is
         double numberToFormat = transformNumber(number);
@@ -637,7 +630,7 @@ class MultiplierSubstitution extends NFSubstitution {
     /**
      * The divisor of the rule that owns this substitution.
      */
-    double divisor;
+    long divisor;
 
     //-----------------------------------------------------------------------
     // construction
@@ -648,12 +641,12 @@ class MultiplierSubstitution extends NFSubstitution {
      * constructor to initialize most members, but this substitution
      * also maintains its own copy of its rule's divisor.
      * @param pos The substitution's position in its rule's rule text
-     * @param divisor The owning rule's divisor
+     * @param rule The rule that owns this substitution
      * @param ruleSet The ruleSet this substitution uses to format its result
      * @param description The description describing this substitution
      */
     MultiplierSubstitution(int pos,
-                           double divisor,
+                           NFRule rule,
                            NFRuleSet ruleSet,
                            String description) {
         super(pos, ruleSet, description);
@@ -661,7 +654,7 @@ class MultiplierSubstitution extends NFSubstitution {
         // the owning rule's divisor affects the behavior of this
         // substitution.  Rather than keeping a back-pointer to the
         // rule, we keep a copy of the divisor
-        this.divisor = divisor;
+        this.divisor = rule.getDivisor();
 
         if (divisor == 0) { // this will cause recursion
             throw new IllegalStateException("Substitution with divisor 0 " + description.substring(0, pos) +
@@ -674,8 +667,8 @@ class MultiplierSubstitution extends NFSubstitution {
      * @param radix The radix of the divisor.
      * @param exponent The exponent of the divisor.
      */
-    public void setDivisor(int radix, int exponent) {
-        divisor = Math.pow(radix, exponent);
+    public void setDivisor(int radix, short exponent) {
+        divisor = NFRule.power(radix, exponent);
 
         if (divisor == 0) {
             throw new IllegalStateException("Substitution with divisor 0");
@@ -781,7 +774,7 @@ class ModulusSubstitution extends NFSubstitution {
     /**
      * The divisor of the rule owning this substitution
      */
-    double divisor;
+    long divisor;
 
     /**
      * If this is a &gt;&gt;&gt; substitution, the rule to use to format
@@ -800,13 +793,13 @@ class ModulusSubstitution extends NFSubstitution {
      * that precedes the rule containing this substitution in the rule
      * set's rule list.
      * @param pos The substitution's position in its rule's rule text
-     * @param divisor The divisor of the rule that owns this substitution
+     * @param rule The rule that owns this substitution
      * @param rulePredecessor The rule that precedes this substitution's
      * rule in its rule set's rule list
      * @param description The description for this substitution
      */
     ModulusSubstitution(int pos,
-                        double divisor,
+                        NFRule rule,
                         NFRule rulePredecessor,
                         NFRuleSet ruleSet,
                         String description)
@@ -816,7 +809,7 @@ class ModulusSubstitution extends NFSubstitution {
         // the owning rule's divisor controls the behavior of this
         // substitution: rather than keeping a backpointer to the rule,
         // we keep a copy of the divisor
-        this.divisor = divisor;
+        this.divisor = rule.getDivisor();
 
         if (divisor == 0) { // this will cause recursion
             throw new IllegalStateException("Substitution with bad divisor (" + divisor + ") "+ description.substring(0, pos) +
@@ -841,8 +834,8 @@ class ModulusSubstitution extends NFSubstitution {
      * @param radix The radix of the divisor.
      * @param exponent The exponent of the divisor.
      */
-    public void setDivisor(int radix, int exponent) {
-        divisor = Math.pow(radix, exponent);
+    public void setDivisor(int radix, short exponent) {
+        divisor = NFRule.power(radix, exponent);
 
         if (divisor == 0) { // this will cause recursion
             throw new IllegalStateException("Substitution with bad divisor");
@@ -881,7 +874,7 @@ class ModulusSubstitution extends NFSubstitution {
      * into
      * @param position The position of the rule text in toInsertInto
      */
-    public void doSubstitution(long number, StringBuffer toInsertInto, int position, int recursionCount) {
+    public void doSubstitution(long number, StringBuilder toInsertInto, int position, int recursionCount) {
         // if this isn't a >>> substitution, just use the inherited version
         // of this function (which uses either a rule set or a DecimalFormat
         // to format its substitution value)
@@ -904,7 +897,7 @@ class ModulusSubstitution extends NFSubstitution {
      * into
      * @param position The position of the rule text in toInsertInto
      */
-    public void doSubstitution(double number, StringBuffer toInsertInto, int position, int recursionCount) {
+    public void doSubstitution(double number, StringBuilder toInsertInto, int position, int recursionCount) {
         // if this isn't a >>> substitution, just use the inherited version
         // of this function (which uses either a rule set or a DecimalFormat
         // to format its substitution value)
@@ -927,7 +920,7 @@ class ModulusSubstitution extends NFSubstitution {
      * @return "number" mod divisor
      */
     public long transformNumber(long number) {
-        return (long)Math.floor(number % divisor);
+        return number % divisor;
     }
 
     /**
@@ -1176,7 +1169,7 @@ class FractionalPartSubstitution extends NFSubstitution {
      * @param position The position of the owning rule's rule text in
      * toInsertInto
      */
-    public void doSubstitution(double number, StringBuffer toInsertInto, int position, int recursionCount) {
+    public void doSubstitution(double number, StringBuilder toInsertInto, int position, int recursionCount) {
         if (!byDigits) {
             // if we're not in "byDigits" mode, just use the inherited
             // doSubstitution() routine
@@ -1501,7 +1494,7 @@ class NumeratorSubstitution extends NFSubstitution {
      * rule text begins (this value is added to this substitution's
      * position to determine exactly where to insert the new text)
      */
-    public void doSubstitution(double number, StringBuffer toInsertInto, int position, int recursionCount) {
+    public void doSubstitution(double number, StringBuilder toInsertInto, int position, int recursionCount) {
         // perform a transformation on the number being formatted that
         // is dependent on the type of substitution this is
         //String s = toInsertInto.toString();
diff --git a/app/src/main/java/com/ibm/icu/text/NameUnicodeTransliterator.java b/icu4j/src/main/java/com/ibm/icu/text/NameUnicodeTransliterator.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/text/NameUnicodeTransliterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/NameUnicodeTransliterator.java
index 8020705..8c4383b 100644
--- a/app/src/main/java/com/ibm/icu/text/NameUnicodeTransliterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/NameUnicodeTransliterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  * Copyright (C) 1996-2011, International Business Machines Corporation and
  * others. All Rights Reserved.
@@ -27,6 +29,7 @@ class NameUnicodeTransliterator extends Transliterator {
      */
     static void register() {
         Transliterator.registerFactory(_ID, new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new NameUnicodeTransliterator(null);
             }
@@ -43,6 +46,7 @@ class NameUnicodeTransliterator extends Transliterator {
     /**
      * Implements {@link Transliterator#handleTransliterate}.
      */
+    @Override
     protected void handleTransliterate(Replaceable text,
                                        Position offsets, boolean isIncremental) {
 
@@ -62,7 +66,7 @@ class NameUnicodeTransliterator extends Transliterator {
         // 1 - after open delimiter
         int mode = 0;
         int openPos = -1; // open delim candidate pos
-        
+
         int c;
         while (cursor < limit) {
             c = text.char32At(cursor);
@@ -86,7 +90,7 @@ class NameUnicodeTransliterator extends Transliterator {
                 // to a single space.  If closeDelimiter is found, exit
                 // the loop.  If any other character is found, exit the
                 // loop.  If the limit is reached, exit the loop.
-                
+
                 // Convert \s+ => SPACE.  This assumes there are no
                 // runs of >1 space characters in names.
                 if (PatternProps.isWhiteSpace(c)) {
@@ -106,7 +110,7 @@ class NameUnicodeTransliterator extends Transliterator {
                 if (c == CLOSE_DELIM) {
 
                     int len = name.length();
-                    
+
                     // Delete trailing space, if any
                     if (len > 0 &&
                         name.charAt(len-1) == SPACE) {
@@ -173,7 +177,7 @@ class NameUnicodeTransliterator extends Transliterator {
     public void addSourceTargetSet(UnicodeSet inputFilter, UnicodeSet sourceSet, UnicodeSet targetSet) {
         UnicodeSet myFilter = getFilterAsUnicodeSet(inputFilter);
         if (!myFilter.containsAll(UnicodeNameTransliterator.OPEN_DELIM) || !myFilter.contains(CLOSE_DELIM)) {
-            return; // we have to contain both prefix and suffix 
+            return; // we have to contain both prefix and suffix
         }
         UnicodeSet items = new UnicodeSet()
         .addAll('0', '9')
diff --git a/app/src/main/java/com/ibm/icu/text/NormalizationTransliterator.java b/icu4j/src/main/java/com/ibm/icu/text/NormalizationTransliterator.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/text/NormalizationTransliterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/NormalizationTransliterator.java
index 36dab9a..8877882 100644
--- a/app/src/main/java/com/ibm/icu/text/NormalizationTransliterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/NormalizationTransliterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  **********************************************************************
  *   Copyright (C) 2001-2014, International Business Machines
@@ -26,31 +28,37 @@ final class NormalizationTransliterator extends Transliterator {
      */
     static void register() {
         Transliterator.registerFactory("Any-NFC", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new NormalizationTransliterator("NFC", Normalizer2.getNFCInstance());
             }
         });
         Transliterator.registerFactory("Any-NFD", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new NormalizationTransliterator("NFD", Normalizer2.getNFDInstance());
             }
         });
         Transliterator.registerFactory("Any-NFKC", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new NormalizationTransliterator("NFKC", Normalizer2.getNFKCInstance());
             }
         });
         Transliterator.registerFactory("Any-NFKD", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new NormalizationTransliterator("NFKD", Normalizer2.getNFKDInstance());
             }
         });
         Transliterator.registerFactory("Any-FCD", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new NormalizationTransliterator("FCD", Norm2AllModes.getFCDNormalizer2());
             }
         });
         Transliterator.registerFactory("Any-FCC", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new NormalizationTransliterator("FCC", Norm2AllModes.getNFCInstance().fcc);
             }
@@ -72,6 +80,7 @@ final class NormalizationTransliterator extends Transliterator {
     /**
      * Implements {@link Transliterator#handleTransliterate}.
      */
+    @Override
     protected void handleTransliterate(Replaceable text,
             Position offsets, boolean isIncremental) {
         // start and limit of the input range
@@ -128,16 +137,17 @@ final class NormalizationTransliterator extends Transliterator {
     }
 
     static final Map<Normalizer2, SourceTargetUtility> SOURCE_CACHE = new HashMap<Normalizer2, SourceTargetUtility>();
-    
+
     // TODO Get rid of this if Normalizer2 becomes a Transform
     static class NormalizingTransform implements Transform<String,String> {
         final Normalizer2 norm2;
         public NormalizingTransform(Normalizer2 norm2) {
             this.norm2 = norm2;
         }
+        @Override
         public String transform(String source) {
             return norm2.normalize(source);
-        }   
+        }
     }
 
     /* (non-Javadoc)
diff --git a/app/src/main/java/com/ibm/icu/text/Normalizer.java b/icu4j/src/main/java/com/ibm/icu/text/Normalizer.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/text/Normalizer.java
rename to icu4j/src/main/java/com/ibm/icu/text/Normalizer.java
index 546b4ff..f4bd467 100644
--- a/app/src/main/java/com/ibm/icu/text/Normalizer.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/Normalizer.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2000-2016, International Business Machines Corporation and
@@ -45,8 +47,8 @@ import com.ibm.icu.util.ICUCloneNotSupportedException;
  * </pre>
  *
  * <p>To a user of your program, however, both of these sequences should be
- * treated as the same "user-level" character "A with acute accent".  When you 
- * are searching or comparing text, you must ensure that these two sequences are 
+ * treated as the same "user-level" character "A with acute accent".  When you
+ * are searching or comparing text, you must ensure that these two sequences are
  * treated equivalently.  In addition, you must handle characters with more than
  * one accent.  Sometimes the order of a character's combining accents is
  * significant, while in other cases accent sequences in different orders are
@@ -73,9 +75,9 @@ import com.ibm.icu.util.ICUCloneNotSupportedException;
  * into the corresponding semantic characters.  When sorting and searching, you
  * will often want to use these mappings.
  *
- * <p><code>normalize</code> helps solve these problems by transforming text into 
- * the canonical composed and decomposed forms as shown in the first example 
- * above. In addition, you can have it perform compatibility decompositions so 
+ * <p><code>normalize</code> helps solve these problems by transforming text into
+ * the canonical composed and decomposed forms as shown in the first example
+ * above. In addition, you can have it perform compatibility decompositions so
  * that you can treat compatibility characters the same as their equivalents.
  * Finally, <code>normalize</code> rearranges accents into the proper canonical
  * order, so that you do not have to worry about accent rearrangement on your
@@ -83,22 +85,22 @@ import com.ibm.icu.util.ICUCloneNotSupportedException;
  *
  * <p>Form FCD, "Fast C or D", is also designed for collation.
  * It allows to work on strings that are not necessarily normalized
- * with an algorithm (like in collation) that works under "canonical closure", 
- * i.e., it treats precomposed characters and their decomposed equivalents the 
+ * with an algorithm (like in collation) that works under "canonical closure",
+ * i.e., it treats precomposed characters and their decomposed equivalents the
  * same.
  *
- * <p>It is not a normalization form because it does not provide for uniqueness of 
- * representation. Multiple strings may be canonically equivalent (their NFDs 
+ * <p>It is not a normalization form because it does not provide for uniqueness of
+ * representation. Multiple strings may be canonically equivalent (their NFDs
  * are identical) and may all conform to FCD without being identical themselves.
  *
- * <p>The form is defined such that the "raw decomposition", the recursive 
- * canonical decomposition of each character, results in a string that is 
- * canonically ordered. This means that precomposed characters are allowed for 
+ * <p>The form is defined such that the "raw decomposition", the recursive
+ * canonical decomposition of each character, results in a string that is
+ * canonically ordered. This means that precomposed characters are allowed for
  * as long as their decompositions do not need canonical reordering.
  *
  * <p>Its advantage for a process like collation is that all NFD and most NFC texts
- * - and many unnormalized texts - already conform to FCD and do not need to be 
- * normalized (NFD) for such a process. The FCD quick check will return YES for 
+ * - and many unnormalized texts - already conform to FCD and do not need to be
+ * normalized (NFD) for such a process. The FCD quick check will return YES for
  * most strings in practice.
  *
  * <p>normalize(FCD) may be implemented with NFD.
@@ -106,9 +108,9 @@ import com.ibm.icu.util.ICUCloneNotSupportedException;
  * <p>For more details on FCD see Unicode Technical Note #5 (Canonical Equivalence in Applications):
  * http://www.unicode.org/notes/tn5/#FCD
  *
- * <p>ICU collation performs either NFD or FCD normalization automatically if 
- * normalization is turned on for the collator object. Beyond collation and 
- * string search, normalized strings may be useful for string equivalence 
+ * <p>ICU collation performs either NFD or FCD normalization automatically if
+ * normalization is turned on for the collator object. Beyond collation and
+ * string search, normalized strings may be useful for string equivalence
  * comparisons, transliteration/transcription, unique representations, etc.
  *
  * <p>The W3C generally recommends to exchange texts in NFC.
@@ -244,40 +246,46 @@ public final class Normalizer implements Cloneable {
     }
 
     private static final class NONEMode extends Mode {
+        @Override
         protected Normalizer2 getNormalizer2(int options) { return Norm2AllModes.NOOP_NORMALIZER2; }
     }
     private static final class NFDMode extends Mode {
+        @Override
         protected Normalizer2 getNormalizer2(int options) {
             return (options&UNICODE_3_2) != 0 ?
                     NFD32ModeImpl.INSTANCE.normalizer2 : NFDModeImpl.INSTANCE.normalizer2;
         }
     }
     private static final class NFKDMode extends Mode {
+        @Override
         protected Normalizer2 getNormalizer2(int options) {
             return (options&UNICODE_3_2) != 0 ?
                     NFKD32ModeImpl.INSTANCE.normalizer2 : NFKDModeImpl.INSTANCE.normalizer2;
         }
     }
     private static final class NFCMode extends Mode {
+        @Override
         protected Normalizer2 getNormalizer2(int options) {
             return (options&UNICODE_3_2) != 0 ?
                     NFC32ModeImpl.INSTANCE.normalizer2 : NFCModeImpl.INSTANCE.normalizer2;
         }
     }
     private static final class NFKCMode extends Mode {
+        @Override
         protected Normalizer2 getNormalizer2(int options) {
             return (options&UNICODE_3_2) != 0 ?
                     NFKC32ModeImpl.INSTANCE.normalizer2 : NFKCModeImpl.INSTANCE.normalizer2;
         }
     }
     private static final class FCDMode extends Mode {
+        @Override
         protected Normalizer2 getNormalizer2(int options) {
             return (options&UNICODE_3_2) != 0 ?
                     FCD32ModeImpl.INSTANCE.normalizer2 : FCDModeImpl.INSTANCE.normalizer2;
         }
     }
 
-    /** 
+    /**
      * No decomposition/composition.
      *
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
@@ -285,7 +293,7 @@ public final class Normalizer implements Cloneable {
     @Deprecated
     public static final Mode NONE = new NONEMode();
 
-    /** 
+    /**
      * Canonical decomposition.
      *
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
@@ -293,7 +301,7 @@ public final class Normalizer implements Cloneable {
     @Deprecated
     public static final Mode NFD = new NFDMode();
 
-    /** 
+    /**
      * Compatibility decomposition.
      *
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
@@ -301,7 +309,7 @@ public final class Normalizer implements Cloneable {
     @Deprecated
     public static final Mode NFKD = new NFKDMode();
 
-    /** 
+    /**
      * Canonical decomposition followed by canonical composition.
      *
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
@@ -309,15 +317,15 @@ public final class Normalizer implements Cloneable {
     @Deprecated
     public static final Mode NFC = new NFCMode();
 
-    /** 
+    /**
      * Default normalization.
      *
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
      */
     @Deprecated
-    public static final Mode DEFAULT = NFC; 
+    public static final Mode DEFAULT = NFC;
 
-    /** 
+    /**
      * Compatibility decomposition followed by canonical composition.
      *
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
@@ -325,7 +333,7 @@ public final class Normalizer implements Cloneable {
     @Deprecated
     public static final Mode NFKC =new NFKCMode();
 
-    /** 
+    /**
      * "Fast C or D" form.
      *
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
@@ -352,13 +360,13 @@ public final class Normalizer implements Cloneable {
 
     /**
      * Canonical decomposition followed by canonical composition.  Used with the
-     * {@link com.ibm.icu.text.Normalizer constructors} and the static 
-     * {@link #normalize normalize} method to determine the operation to be 
+     * {@link com.ibm.icu.text.Normalizer constructors} and the static
+     * {@link #normalize normalize} method to determine the operation to be
      * performed.
      * <p>
      * If all optional features (<i>e.g.</i> {@link #IGNORE_HANGUL}) are turned
      * off, this operation produces output that is in
-     * <a href=http://www.unicode.org/unicode/reports/tr15/>Unicode Canonical 
+     * <a href=http://www.unicode.org/unicode/reports/tr15/>Unicode Canonical
      * Form</a>
      * <b>C</b>.
      * <p>
@@ -372,12 +380,12 @@ public final class Normalizer implements Cloneable {
     /**
      * Compatibility decomposition followed by canonical composition.
      * Used with the {@link com.ibm.icu.text.Normalizer constructors} and the static
-     * {@link #normalize normalize} method to determine the operation to be 
+     * {@link #normalize normalize} method to determine the operation to be
      * performed.
      * <p>
      * If all optional features (<i>e.g.</i> {@link #IGNORE_HANGUL}) are turned
      * off, this operation produces output that is in
-     * <a href=http://www.unicode.org/unicode/reports/tr15/>Unicode Canonical 
+     * <a href=http://www.unicode.org/unicode/reports/tr15/>Unicode Canonical
      * Form</a>
      * <b>KC</b>.
      * <p>
@@ -396,7 +404,7 @@ public final class Normalizer implements Cloneable {
      * <p>
      * If all optional features (<i>e.g.</i> {@link #IGNORE_HANGUL}) are turned
      * off, this operation produces output that is in
-     * <a href=http://www.unicode.org/unicode/reports/tr15/>Unicode Canonical 
+     * <a href=http://www.unicode.org/unicode/reports/tr15/>Unicode Canonical
      * Form</a>
      * <b>D</b>.
      * <p>
@@ -409,13 +417,13 @@ public final class Normalizer implements Cloneable {
 
     /**
      * Compatibility decomposition.  This value is passed to the
-     * {@link com.ibm.icu.text.Normalizer constructors} and the static 
+     * {@link com.ibm.icu.text.Normalizer constructors} and the static
      * {@link #normalize normalize}
      * method to determine the operation to be performed.
      * <p>
      * If all optional features (<i>e.g.</i> {@link #IGNORE_HANGUL}) are turned
      * off, this operation produces output that is in
-     * <a href=http://www.unicode.org/unicode/reports/tr15/>Unicode Canonical 
+     * <a href=http://www.unicode.org/unicode/reports/tr15/>Unicode Canonical
      * Form</a>
      * <b>KD</b>.
      * <p>
@@ -446,7 +454,7 @@ public final class Normalizer implements Cloneable {
      */
     @Deprecated
     public static final int IGNORE_HANGUL = 0x0001;
-          
+
     /**
      * Result values for quickCheck().
      * For details see Unicode Technical Report 15.
@@ -458,46 +466,46 @@ public final class Normalizer implements Cloneable {
             //resultValue=value;
         }
     }
-    /** 
+    /**
      * Indicates that string is not in the normalized format
      * @stable ICU 2.8
      */
     public static final QuickCheckResult NO = new QuickCheckResult(0);
-        
-    /** 
+
+    /**
      * Indicates that string is in the normalized format
      * @stable ICU 2.8
      */
     public static final QuickCheckResult YES = new QuickCheckResult(1);
 
-    /** 
-     * Indicates it cannot be determined if string is in the normalized 
+    /**
+     * Indicates it cannot be determined if string is in the normalized
      * format without further thorough checks.
      * @stable ICU 2.8
      */
     public static final QuickCheckResult MAYBE = new QuickCheckResult(2);
-    
+
     /**
      * Option bit for compare:
      * Case sensitively compare the strings
      * @stable ICU 2.8
      */
     public static final int FOLD_CASE_DEFAULT =  UCharacter.FOLD_CASE_DEFAULT;
-    
+
     /**
      * Option bit for compare:
      * Both input strings are assumed to fulfill FCD conditions.
      * @stable ICU 2.8
      */
     public static final int INPUT_IS_FCD    =      0x20000;
-        
+
     /**
      * Option bit for compare:
      * Perform case-insensitive comparison.
      * @stable ICU 2.8
      */
     public static final int COMPARE_IGNORE_CASE  =     0x10000;
-        
+
     /**
      * Option bit for compare:
      * Compare strings in code point order instead of code unit order.
@@ -505,7 +513,7 @@ public final class Normalizer implements Cloneable {
      */
     public static final int COMPARE_CODE_POINT_ORDER = 0x8000;
 
-    /** 
+    /**
      * Option value for case folding:
      * Use the modified set of mappings provided in CaseFolding.txt to handle dotted I
      * and dotless i appropriately for Turkic languages (tr, az).
@@ -531,7 +539,7 @@ public final class Normalizer implements Cloneable {
      */
     @Deprecated
     public static final int COMPARE_NORM_OPTIONS_SHIFT  = 20;
-        
+
     //-------------------------------------------------------------------------
     // Iterator constructors
     //-------------------------------------------------------------------------
@@ -557,7 +565,7 @@ public final class Normalizer implements Cloneable {
     @Deprecated
     public Normalizer(String str, Mode mode, int opt) {
         this.text = UCharacterIterator.getInstance(str);
-        this.mode = mode; 
+        this.mode = mode;
         this.options=opt;
         norm2 = mode.getNormalizer2(opt);
         buffer = new StringBuilder();
@@ -657,23 +665,23 @@ public final class Normalizer implements Cloneable {
      * Compose a string.
      * The string will be composed to according to the specified mode.
      * @param str        The string to compose.
-     * @param compat     If true the string will be composed according to 
-     *                    NFKC rules and if false will be composed according to 
+     * @param compat     If true the string will be composed according to
+     *                    NFKC rules and if false will be composed according to
      *                    NFC rules.
      * @return String    The composed string
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
      */
     @Deprecated
     public static String compose(String str, boolean compat) {
-        return compose(str,compat,0);           
+        return compose(str,compat,0);
     }
-    
+
     /**
      * Compose a string.
      * The string will be composed to according to the specified mode.
      * @param str        The string to compose.
-     * @param compat     If true the string will be composed according to 
-     *                    NFKC rules and if false will be composed according to 
+     * @param compat     If true the string will be composed according to
+     *                    NFKC rules and if false will be composed according to
      *                    NFC rules.
      * @param options    The only recognized option is UNICODE_3_2
      * @return String    The composed string
@@ -683,19 +691,19 @@ public final class Normalizer implements Cloneable {
     public static String compose(String str, boolean compat, int options) {
         return getComposeNormalizer2(compat, options).normalize(str);
     }
-    
+
     /**
      * Compose a string.
      * The string will be composed to according to the specified mode.
      * @param source The char array to compose.
      * @param target A char buffer to receive the normalized text.
-     * @param compat If true the char array will be composed according to 
-     *                NFKC rules and if false will be composed according to 
+     * @param compat If true the char array will be composed according to
+     *                NFKC rules and if false will be composed according to
      *                NFC rules.
      * @param options The normalization options, ORed together (0 for no options).
-     * @return int   The total buffer size needed;if greater than length of 
+     * @return int   The total buffer size needed;if greater than length of
      *                result, the output was truncated.
-     * @exception IndexOutOfBoundsException if target.length is less than the 
+     * @exception IndexOutOfBoundsException if target.length is less than the
      *             required length
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
      */
@@ -703,7 +711,7 @@ public final class Normalizer implements Cloneable {
     public static int compose(char[] source,char[] target, boolean compat, int options) {
         return compose(source, 0, source.length, target, 0, target.length, compat, options);
     }
-    
+
     /**
      * Compose a string.
      * The string will be composed to according to the specified mode.
@@ -711,15 +719,15 @@ public final class Normalizer implements Cloneable {
      * @param srcStart  Start index of the source
      * @param srcLimit  Limit index of the source
      * @param dest      The char buffer to fill in
-     * @param destStart Start index of the destination buffer  
+     * @param destStart Start index of the destination buffer
      * @param destLimit End index of the destination buffer
-     * @param compat If true the char array will be composed according to 
-     *                NFKC rules and if false will be composed according to 
+     * @param compat If true the char array will be composed according to
+     *                NFKC rules and if false will be composed according to
      *                NFC rules.
      * @param options The normalization options, ORed together (0 for no options).
-     * @return int   The total buffer size needed;if greater than length of 
+     * @return int   The total buffer size needed;if greater than length of
      *                result, the output was truncated.
-     * @exception IndexOutOfBoundsException if target.length is less than the 
+     * @exception IndexOutOfBoundsException if target.length is less than the
      *             required length
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
      */
@@ -737,23 +745,23 @@ public final class Normalizer implements Cloneable {
      * Decompose a string.
      * The string will be decomposed to according to the specified mode.
      * @param str       The string to decompose.
-     * @param compat    If true the string will be decomposed according to NFKD 
-     *                   rules and if false will be decomposed according to NFD 
+     * @param compat    If true the string will be decomposed according to NFKD
+     *                   rules and if false will be decomposed according to NFD
      *                   rules.
      * @return String   The decomposed string
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
      */
     @Deprecated
     public static String decompose(String str, boolean compat) {
-        return decompose(str,compat,0);                  
+        return decompose(str,compat,0);
     }
-    
+
     /**
      * Decompose a string.
      * The string will be decomposed to according to the specified mode.
      * @param str     The string to decompose.
-     * @param compat  If true the string will be decomposed according to NFKD 
-     *                 rules and if false will be decomposed according to NFD 
+     * @param compat  If true the string will be decomposed according to NFKD
+     *                 rules and if false will be decomposed according to NFD
      *                 rules.
      * @param options The normalization options, ORed together (0 for no options).
      * @return String The decomposed string
@@ -769,10 +777,10 @@ public final class Normalizer implements Cloneable {
      * The string will be decomposed to according to the specified mode.
      * @param source The char array to decompose.
      * @param target A char buffer to receive the normalized text.
-     * @param compat If true the char array will be decomposed according to NFKD 
-     *                rules and if false will be decomposed according to 
+     * @param compat If true the char array will be decomposed according to NFKD
+     *                rules and if false will be decomposed according to
      *                NFD rules.
-     * @return int   The total buffer size needed;if greater than length of 
+     * @return int   The total buffer size needed;if greater than length of
      *                result,the output was truncated.
      * @param options The normalization options, ORed together (0 for no options).
      * @exception IndexOutOfBoundsException if the target capacity is less than
@@ -783,7 +791,7 @@ public final class Normalizer implements Cloneable {
     public static int decompose(char[] source,char[] target, boolean compat, int options) {
         return decompose(source, 0, source.length, target, 0, target.length, compat, options);
     }
-    
+
     /**
      * Decompose a string.
      * The string will be decomposed to according to the specified mode.
@@ -791,13 +799,13 @@ public final class Normalizer implements Cloneable {
      * @param srcStart  Start index of the source
      * @param srcLimit  Limit index of the source
      * @param dest      The char buffer to fill in
-     * @param destStart Start index of the destination buffer  
+     * @param destStart Start index of the destination buffer
      * @param destLimit End index of the destination buffer
-     * @param compat If true the char array will be decomposed according to NFKD 
-     *                rules and if false will be decomposed according to 
+     * @param compat If true the char array will be decomposed according to NFKD
+     *                rules and if false will be decomposed according to
      *                NFD rules.
      * @param options The normalization options, ORed together (0 for no options).
-     * @return int   The total buffer size needed;if greater than length of 
+     * @return int   The total buffer size needed;if greater than length of
      *                result,the output was truncated.
      * @exception IndexOutOfBoundsException if the target capacity is less than
      *             the required length
@@ -832,35 +840,35 @@ public final class Normalizer implements Cloneable {
     public static String normalize(String str, Mode mode, int options) {
         return mode.getNormalizer2(options).normalize(str);
     }
-    
+
     /**
      * Normalize a string.
-     * The string will be normalized according to the specified normalization 
+     * The string will be normalized according to the specified normalization
      * mode and options.
      * @param src        The string to normalize.
-     * @param mode       The normalization mode; one of Normalizer.NONE, 
-     *                    Normalizer.NFD, Normalizer.NFC, Normalizer.NFKC, 
+     * @param mode       The normalization mode; one of Normalizer.NONE,
+     *                    Normalizer.NFD, Normalizer.NFC, Normalizer.NFKC,
      *                    Normalizer.NFKD, Normalizer.DEFAULT
      * @return the normalized string
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
      */
     @Deprecated
     public static String normalize(String src,Mode mode) {
-        return normalize(src, mode, 0);    
+        return normalize(src, mode, 0);
     }
     /**
      * Normalize a string.
-     * The string will be normalized according to the specified normalization 
+     * The string will be normalized according to the specified normalization
      * mode and options.
      * @param source The char array to normalize.
      * @param target A char buffer to receive the normalized text.
-     * @param mode   The normalization mode; one of Normalizer.NONE, 
-     *                Normalizer.NFD, Normalizer.NFC, Normalizer.NFKC, 
+     * @param mode   The normalization mode; one of Normalizer.NONE,
+     *                Normalizer.NFD, Normalizer.NFC, Normalizer.NFKC,
      *                Normalizer.NFKD, Normalizer.DEFAULT
      * @param options The normalization options, ORed together (0 for no options).
-     * @return int   The total buffer size needed;if greater than length of 
+     * @return int   The total buffer size needed;if greater than length of
      *                result, the output was truncated.
-     * @exception    IndexOutOfBoundsException if the target capacity is less 
+     * @exception    IndexOutOfBoundsException if the target capacity is less
      *                than the required length
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
      */
@@ -877,20 +885,20 @@ public final class Normalizer implements Cloneable {
      * @param srcStart  Start index of the source
      * @param srcLimit  Limit index of the source
      * @param dest      The char buffer to fill in
-     * @param destStart Start index of the destination buffer  
+     * @param destStart Start index of the destination buffer
      * @param destLimit End index of the destination buffer
-     * @param mode      The normalization mode; one of Normalizer.NONE, 
-     *                   Normalizer.NFD, Normalizer.NFC, Normalizer.NFKC, 
+     * @param mode      The normalization mode; one of Normalizer.NONE,
+     *                   Normalizer.NFD, Normalizer.NFC, Normalizer.NFKC,
      *                   Normalizer.NFKD, Normalizer.DEFAULT
-     * @param options The normalization options, ORed together (0 for no options). 
-     * @return int      The total buffer size needed;if greater than length of 
+     * @param options The normalization options, ORed together (0 for no options).
+     * @return int      The total buffer size needed;if greater than length of
      *                   result, the output was truncated.
-     * @exception       IndexOutOfBoundsException if the target capacity is 
+     * @exception       IndexOutOfBoundsException if the target capacity is
      *                   less than the required length
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
      */
     @Deprecated
-    public static int normalize(char[] src,int srcStart, int srcLimit, 
+    public static int normalize(char[] src,int srcStart, int srcLimit,
                                 char[] dest,int destStart, int destLimit,
                                 Mode  mode, int options) {
         CharBuffer srcBuffer = CharBuffer.wrap(src, srcStart, srcLimit - srcStart);
@@ -937,9 +945,9 @@ public final class Normalizer implements Cloneable {
      * Convenience method.
      *
      * @param source   string for determining if it is in a normalized format
-     * @param mode     normalization format (Normalizer.NFC,Normalizer.NFD,  
+     * @param mode     normalization format (Normalizer.NFC,Normalizer.NFD,
      *                  Normalizer.NFKC,Normalizer.NFKD)
-     * @return         Return code to specify if the text is normalized or not 
+     * @return         Return code to specify if the text is normalized or not
      *                     (Normalizer.YES, Normalizer.NO or Normalizer.MAYBE)
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
      */
@@ -949,22 +957,22 @@ public final class Normalizer implements Cloneable {
     }
 
     /**
-     * Performing quick check on a string, to quickly determine if the string is 
+     * Performing quick check on a string, to quickly determine if the string is
      * in a particular normalization format.
      * Three types of result can be returned Normalizer.YES, Normalizer.NO or
      * Normalizer.MAYBE. Result Normalizer.YES indicates that the argument
      * string is in the desired normalized format, Normalizer.NO determines that
-     * argument string is not in the desired normalized format. A 
-     * Normalizer.MAYBE result indicates that a more thorough check is required, 
-     * the user may have to put the string in its normalized form and compare 
+     * argument string is not in the desired normalized format. A
+     * Normalizer.MAYBE result indicates that a more thorough check is required,
+     * the user may have to put the string in its normalized form and compare
      * the results.
      *
      * @param source   string for determining if it is in a normalized format
-     * @param mode     normalization format (Normalizer.NFC,Normalizer.NFD,  
+     * @param mode     normalization format (Normalizer.NFC,Normalizer.NFD,
      *                  Normalizer.NFKC,Normalizer.NFKD)
      * @param options   Options for use with exclusion set and tailored Normalization
-     *                                   The only option that is currently recognized is UNICODE_3_2     
-     * @return         Return code to specify if the text is normalized or not 
+     *                                   The only option that is currently recognized is UNICODE_3_2
+     * @return         Return code to specify if the text is normalized or not
      *                     (Normalizer.YES, Normalizer.NO or Normalizer.MAYBE)
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
      */
@@ -976,13 +984,13 @@ public final class Normalizer implements Cloneable {
     /**
      * Convenience method.
      *
-     * @param source Array of characters for determining if it is in a 
+     * @param source Array of characters for determining if it is in a
      *                normalized format
-     * @param mode   normalization format (Normalizer.NFC,Normalizer.NFD,  
+     * @param mode   normalization format (Normalizer.NFC,Normalizer.NFD,
      *                Normalizer.NFKC,Normalizer.NFKD)
      * @param options   Options for use with exclusion set and tailored Normalization
      *                                   The only option that is currently recognized is UNICODE_3_2
-     * @return       Return code to specify if the text is normalized or not 
+     * @return       Return code to specify if the text is normalized or not
      *                (Normalizer.YES, Normalizer.NO or Normalizer.MAYBE)
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
      */
@@ -992,31 +1000,31 @@ public final class Normalizer implements Cloneable {
     }
 
     /**
-     * Performing quick check on a string, to quickly determine if the string is 
+     * Performing quick check on a string, to quickly determine if the string is
      * in a particular normalization format.
      * Three types of result can be returned Normalizer.YES, Normalizer.NO or
      * Normalizer.MAYBE. Result Normalizer.YES indicates that the argument
      * string is in the desired normalized format, Normalizer.NO determines that
-     * argument string is not in the desired normalized format. A 
-     * Normalizer.MAYBE result indicates that a more thorough check is required, 
-     * the user may have to put the string in its normalized form and compare 
+     * argument string is not in the desired normalized format. A
+     * Normalizer.MAYBE result indicates that a more thorough check is required,
+     * the user may have to put the string in its normalized form and compare
      * the results.
      *
      * @param source    string for determining if it is in a normalized format
      * @param start     the start index of the source
      * @param limit     the limit index of the source it is equal to the length
-     * @param mode      normalization format (Normalizer.NFC,Normalizer.NFD,  
+     * @param mode      normalization format (Normalizer.NFC,Normalizer.NFD,
      *                   Normalizer.NFKC,Normalizer.NFKD)
      * @param options   Options for use with exclusion set and tailored Normalization
-     *                                   The only option that is currently recognized is UNICODE_3_2    
-     * @return          Return code to specify if the text is normalized or not 
+     *                                   The only option that is currently recognized is UNICODE_3_2
+     * @return          Return code to specify if the text is normalized or not
      *                   (Normalizer.YES, Normalizer.NO or
      *                   Normalizer.MAYBE)
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
      */
     @Deprecated
-    public static QuickCheckResult quickCheck(char[] source,int start, 
-                                              int limit, Mode mode,int options) {       
+    public static QuickCheckResult quickCheck(char[] source,int start,
+                                              int limit, Mode mode,int options) {
         CharBuffer srcBuffer = CharBuffer.wrap(source, start, limit - start);
         return mode.getNormalizer2(options).quickCheck(srcBuffer);
     }
@@ -1030,20 +1038,20 @@ public final class Normalizer implements Cloneable {
      * For NFD, NFKD, and FCD, both functions work exactly the same.
      * For NFC and NFKC where quickCheck may return "maybe", this function will
      * perform further tests to arrive at a true/false result.
-     * @param src       The input array of characters to be checked to see if 
+     * @param src       The input array of characters to be checked to see if
      *                   it is normalized
      * @param start     The strart index in the source
      * @param limit     The limit index in the source
      * @param mode      the normalization mode
      * @param options   Options for use with exclusion set and tailored Normalization
-     *                                   The only option that is currently recognized is UNICODE_3_2    
+     *                                   The only option that is currently recognized is UNICODE_3_2
      * @return Boolean value indicating whether the source string is in the
      *         "mode" normalization form
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
      */
     @Deprecated
     public static boolean isNormalized(char[] src,int start,
-                                       int limit, Mode mode, 
+                                       int limit, Mode mode,
                                        int options) {
         CharBuffer srcBuffer = CharBuffer.wrap(src, start, limit - start);
         return mode.getNormalizer2(options).isNormalized(srcBuffer);
@@ -1058,11 +1066,11 @@ public final class Normalizer implements Cloneable {
      * For NFD, NFKD, and FCD, both functions work exactly the same.
      * For NFC and NFKC where quickCheck may return "maybe", this function will
      * perform further tests to arrive at a true/false result.
-     * @param str       the input string to be checked to see if it is 
+     * @param str       the input string to be checked to see if it is
      *                   normalized
      * @param mode      the normalization mode
      * @param options   Options for use with exclusion set and tailored Normalization
-     *                  The only option that is currently recognized is UNICODE_3_2   
+     *                  The only option that is currently recognized is UNICODE_3_2
      * @see #isNormalized
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
      */
@@ -1073,11 +1081,11 @@ public final class Normalizer implements Cloneable {
 
     /**
      * Convenience Method
-     * @param char32    the input code point to be checked to see if it is 
+     * @param char32    the input code point to be checked to see if it is
      *                   normalized
      * @param mode      the normalization mode
      * @param options   Options for use with exclusion set and tailored Normalization
-     *                  The only option that is currently recognized is UNICODE_3_2    
+     *                  The only option that is currently recognized is UNICODE_3_2
      *
      * @see #isNormalized
      * @deprecated ICU 56 Use {@link Normalizer2} instead.
@@ -1098,8 +1106,8 @@ public final class Normalizer implements Cloneable {
      * (and optionally case-folding) both strings entirely,
      * improving performance significantly.
      *
-     * Bulk normalization is only necessary if the strings do not fulfill the 
-     * FCD conditions. Only in this case, and only if the strings are relatively 
+     * Bulk normalization is only necessary if the strings do not fulfill the
+     * FCD conditions. Only in this case, and only if the strings are relatively
      * long, is memory allocated temporarily.
      * For FCD strings and short non-FCD strings there is no memory allocation.
      *
@@ -1114,14 +1122,14 @@ public final class Normalizer implements Cloneable {
      * @param s2        Second source character array.
      * @param s2Start   start index of the source
      * @param s2Limit   limit of the source
-     * 
+     *
      * @param options A bit set of options:
      *   - FOLD_CASE_DEFAULT or 0 is used for default options:
      *     Case-sensitive comparison in code unit order, and the input strings
      *     are quick-checked for FCD.
      *
      *   - INPUT_IS_FCD
-     *     Set if the caller knows that both s1 and s2 fulfill the FCD 
+     *     Set if the caller knows that both s1 and s2 fulfill the FCD
      *     conditions.If not set, the function will quickCheck for FCD
      *     and normalize if necessary.
      *
@@ -1143,16 +1151,16 @@ public final class Normalizer implements Cloneable {
     public static int compare(char[] s1, int s1Start, int s1Limit,
                               char[] s2, int s2Start, int s2Limit,
                               int options) {
-        if( s1==null || s1Start<0 || s1Limit<0 || 
+        if( s1==null || s1Start<0 || s1Limit<0 ||
             s2==null || s2Start<0 || s2Limit<0 ||
             s1Limit<s1Start || s2Limit<s2Start
         ) {
             throw new IllegalArgumentException();
         }
-        return internalCompare(CharBuffer.wrap(s1, s1Start, s1Limit-s1Start), 
-                               CharBuffer.wrap(s2, s2Start, s2Limit-s2Start), 
+        return internalCompare(CharBuffer.wrap(s1, s1Start, s1Limit-s1Start),
+                               CharBuffer.wrap(s2, s2Start, s2Limit-s2Start),
                                options);
-    } 
+    }
 
     /**
      * Compare two strings for canonical equivalence.
@@ -1165,8 +1173,8 @@ public final class Normalizer implements Cloneable {
      * (and optionally case-folding) both strings entirely,
      * improving performance significantly.
      *
-     * Bulk normalization is only necessary if the strings do not fulfill the 
-     * FCD conditions. Only in this case, and only if the strings are relatively 
+     * Bulk normalization is only necessary if the strings do not fulfill the
+     * FCD conditions. Only in this case, and only if the strings are relatively
      * long, is memory allocated temporarily.
      * For FCD strings and short non-FCD strings there is no memory allocation.
      *
@@ -1183,7 +1191,7 @@ public final class Normalizer implements Cloneable {
      *     are quick-checked for FCD.
      *
      *   - INPUT_IS_FCD
-     *     Set if the caller knows that both s1 and s2 fulfill the FCD 
+     *     Set if the caller knows that both s1 and s2 fulfill the FCD
      *     conditions. If not set, the function will quickCheck for FCD
      *     and normalize if necessary.
      *
@@ -1220,7 +1228,7 @@ public final class Normalizer implements Cloneable {
      *     are quick-checked for FCD.
      *
      *   - INPUT_IS_FCD
-     *     Set if the caller knows that both s1 and s2 fulfill the FCD 
+     *     Set if the caller knows that both s1 and s2 fulfill the FCD
      *     conditions. If not set, the function will quickCheck for FCD
      *     and normalize if necessary.
      *
@@ -1293,16 +1301,16 @@ public final class Normalizer implements Cloneable {
      * @param right Right source array.
      * @param rightStart start in the right array.
      * @param rightLimit limit in the right array (==length)
-     * @param dest The output buffer; can be null if destStart==destLimit==0 
+     * @param dest The output buffer; can be null if destStart==destLimit==0
      *              for pure preflighting.
      * @param destStart start in the destination array
      * @param destLimit limit in the destination array (==length)
      * @param mode The normalization mode.
      * @param options The normalization options, ORed together (0 for no options).
-     * @return Length of output (number of chars) when successful or 
+     * @return Length of output (number of chars) when successful or
      *          IndexOutOfBoundsException
-     * @exception IndexOutOfBoundsException whose message has the string 
-     *             representation of destination capacity required. 
+     * @exception IndexOutOfBoundsException whose message has the string
+     *             representation of destination capacity required.
      * @see #normalize
      * @see #next
      * @see #previous
@@ -1312,18 +1320,18 @@ public final class Normalizer implements Cloneable {
      */
     @Deprecated
     public static int concatenate(char[] left,  int leftStart,  int leftLimit,
-                                  char[] right, int rightStart, int rightLimit, 
+                                  char[] right, int rightStart, int rightLimit,
                                   char[] dest,  int destStart,  int destLimit,
                                   Normalizer.Mode mode, int options) {
         if(dest == null) {
             throw new IllegalArgumentException();
         }
-    
+
         /* check for overlapping right and destination */
         if (right == dest && rightStart < destLimit && destStart < rightLimit) {
             throw new IllegalArgumentException("overlapping right and dst ranges");
         }
-    
+
         /* allow left==dest */
         StringBuilder destBuilder=new StringBuilder(leftLimit-leftStart+rightLimit-rightStart+16);
         destBuilder.append(left, leftStart, leftLimit-leftStart);
@@ -1350,7 +1358,7 @@ public final class Normalizer implements Cloneable {
      *     dest=normalize(left+right, mode)
      * </code>
      *
-     * For details see concatenate 
+     * For details see concatenate
      *
      * @param left Left source string.
      * @param right Right source string.
@@ -1500,8 +1508,8 @@ public final class Normalizer implements Cloneable {
             return DONE;
         }
     }
-        
-        
+
+
     /**
      * Return the previous character in the normalized text and decrement
      * the iteration position by one.  If the beginning
@@ -1519,7 +1527,7 @@ public final class Normalizer implements Cloneable {
             return DONE;
         }
     }
-        
+
     /**
      * Reset the index to the beginning of the text.
      * This is equivalent to setIndexOnly(startIndex)).
@@ -1531,7 +1539,7 @@ public final class Normalizer implements Cloneable {
         currentIndex=nextIndex=0;
         clearBuffer();
     }
-    
+
     /**
      * Set the iteration position in the input text that is being normalized,
      * without any immediate normalization.
@@ -1547,7 +1555,7 @@ public final class Normalizer implements Cloneable {
         currentIndex=nextIndex=index;
         clearBuffer();
     }
-        
+
     /**
      * Set the iteration position in the input text that is being normalized
      * and return the first normalized character at that position.
@@ -1577,8 +1585,8 @@ public final class Normalizer implements Cloneable {
      }
      ///CLOVER:ON
     /**
-     * Retrieve the index of the start of the input text. This is the begin 
-     * index of the <tt>CharacterIterator</tt> or the start (i.e. 0) of the 
+     * Retrieve the index of the start of the input text. This is the begin
+     * index of the <tt>CharacterIterator</tt> or the start (i.e. 0) of the
      * <tt>String</tt> over which this <tt>Normalizer</tt> is iterating
      * @deprecated ICU 2.2. Use startIndex() instead.
      * @return The codepoint as an int
@@ -1612,7 +1620,7 @@ public final class Normalizer implements Cloneable {
         reset();
         return next();
     }
-        
+
     /**
      * Return the last character in the normalized text.  This resets
      * the <tt>Normalizer's</tt> position to be just before the
@@ -1653,8 +1661,8 @@ public final class Normalizer implements Cloneable {
     }
 
     /**
-     * Retrieve the index of the start of the input text. This is the begin 
-     * index of the <tt>CharacterIterator</tt> or the start (i.e. 0) of the 
+     * Retrieve the index of the start of the input text. This is the begin
+     * index of the <tt>CharacterIterator</tt> or the start (i.e. 0) of the
      * <tt>String</tt> over which this <tt>Normalizer</tt> is iterating
      * @return The current iteration position
      * @deprecated ICU 56
@@ -1762,7 +1770,7 @@ public final class Normalizer implements Cloneable {
             return 0;
         }
     }
-    
+
     /**
      * Gets the underlying text storage
      * @param fillIn the char buffer to fill the UTF-16 units.
@@ -1776,7 +1784,7 @@ public final class Normalizer implements Cloneable {
     public int getText(char[] fillIn) {
         return text.getText(fillIn);
     }
-    
+
     /**
      * Gets the length of underlying text storage
      * @return the length
@@ -1786,7 +1794,7 @@ public final class Normalizer implements Cloneable {
     public int getLength() {
         return text.getLength();
     }
-    
+
     /**
      * Returns the text under iteration as a string
      * @return a copy of the text under iteration.
@@ -1796,7 +1804,7 @@ public final class Normalizer implements Cloneable {
     public String getText() {
         return text.getText();
     }
-    
+
     /**
      * Set the input text over which this <tt>Normalizer</tt> will iterate.
      * The iteration position is set to the beginning of the input text.
@@ -1808,7 +1816,7 @@ public final class Normalizer implements Cloneable {
         UCharacterIterator newIter = UCharacterIterator.getInstance(newText);
         if (newIter == null) {
             throw new IllegalStateException("Could not create a new UCharacterIterator");
-        }  
+        }
         text = newIter;
         reset();
     }
@@ -1824,7 +1832,7 @@ public final class Normalizer implements Cloneable {
         UCharacterIterator newIter = UCharacterIterator.getInstance(newText);
         if (newIter == null) {
             throw new IllegalStateException("Could not create a new UCharacterIterator");
-        }  
+        }
         text = newIter;
         reset();
     }
@@ -1840,7 +1848,7 @@ public final class Normalizer implements Cloneable {
         UCharacterIterator newIter = UCharacterIterator.getInstance(newText);
         if (newIter == null) {
             throw new IllegalStateException("Could not create a new UCharacterIterator");
-        }  
+        }
         text = newIter;
         reset();
     }
@@ -1856,7 +1864,7 @@ public final class Normalizer implements Cloneable {
         UCharacterIterator newIter = UCharacterIterator.getInstance(newText);
         if (newIter == null) {
             throw new IllegalStateException("Could not create a new UCharacterIterator");
-        }  
+        }
         text = newIter;
         reset();
     }
@@ -1868,7 +1876,7 @@ public final class Normalizer implements Cloneable {
      * @deprecated ICU 56
      */
     @Deprecated
-    public void setText(UCharacterIterator newText) { 
+    public void setText(UCharacterIterator newText) {
         try{
             UCharacterIterator newIter = (UCharacterIterator)newText.clone();
             if (newIter == null) {
@@ -1990,7 +1998,7 @@ public final class Normalizer implements Cloneable {
         }
 
         return cmpEquivFold(s1, s2, options);
-    }    
+    }
 
     /*
      * Compare two strings for canonical equivalence.
@@ -2515,6 +2523,7 @@ public final class Normalizer implements Cloneable {
                 throw new IndexOutOfBoundsException(Integer.toString(len));
             }
         }
+        @Override
         public Appendable append(char c) {
             if(offset<limit) {
                 chars[offset]=c;
@@ -2522,9 +2531,11 @@ public final class Normalizer implements Cloneable {
             ++offset;
             return this;
         }
+        @Override
         public Appendable append(CharSequence s) {
             return append(s, 0, s.length());
         }
+        @Override
         public Appendable append(CharSequence s, int sStart, int sLimit) {
             int len=sLimit-sStart;
             if(len<=(limit-offset)) {
diff --git a/app/src/main/java/com/ibm/icu/text/Normalizer2.java b/icu4j/src/main/java/com/ibm/icu/text/Normalizer2.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/Normalizer2.java
rename to icu4j/src/main/java/com/ibm/icu/text/Normalizer2.java
index 5c977de..e2e40de 100644
--- a/app/src/main/java/com/ibm/icu/text/Normalizer2.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/Normalizer2.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  *   Copyright (C) 2009-2016, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/text/NullTransliterator.java b/icu4j/src/main/java/com/ibm/icu/text/NullTransliterator.java
similarity index 84%
rename from app/src/main/java/com/ibm/icu/text/NullTransliterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/NullTransliterator.java
index 8ae4bfc..c95386e 100644
--- a/app/src/main/java/com/ibm/icu/text/NullTransliterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/NullTransliterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
@@ -13,8 +15,8 @@ class NullTransliterator extends Transliterator {
     /**
      * Package accessible IDs for this transliterator.
      */
-    static String SHORT_ID = "Null";
-    static String _ID      = "Any-Null";
+    static final String SHORT_ID = "Null";
+    static final String _ID      = "Any-Null";
 
     /**
      * Constructs a transliterator.
@@ -26,6 +28,7 @@ class NullTransliterator extends Transliterator {
     /**
      * Implements {@link Transliterator#handleTransliterate}.
      */
+    @Override
     protected void handleTransliterate(Replaceable text,
                                        Position offsets, boolean incremental) {
         offsets.start = offsets.limit;
diff --git a/app/src/main/java/com/ibm/icu/text/NumberFormat.java b/icu4j/src/main/java/com/ibm/icu/text/NumberFormat.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/text/NumberFormat.java
rename to icu4j/src/main/java/com/ibm/icu/text/NumberFormat.java
index 4145cbe..018d75f 100644
--- a/app/src/main/java/com/ibm/icu/text/NumberFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/NumberFormat.java
@@ -1,7 +1,9 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 1996-2016, International Business Machines Corporation and    *
- * others. All Rights Reserved.                                                *
+ * Copyright (C) 1996-2016, International Business Machines Corporation and
+ * others. All Rights Reserved.
  *******************************************************************************
  */
 
@@ -21,6 +23,7 @@ import java.util.Locale;
 import java.util.MissingResourceException;
 import java.util.Set;
 
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.util.Currency;
 import com.ibm.icu.util.Currency.CurrencyUsage;
@@ -228,8 +231,7 @@ public abstract class NumberFormat extends UFormat {
      * to represent currency, for example "$3.00", using non-accounting style for
      * negative values (e.g. minus sign).
      * Overrides any style specified using -cf- key in locale.
-     * @draft ICU 56
-     * @provisional This API might change or be removed in a future release. 
+     * @stable ICU 56
      */
     public static final int STANDARDCURRENCYSTYLE = 9;
 
@@ -248,7 +250,7 @@ public abstract class NumberFormat extends UFormat {
      * @stable ICU 2.0
      */
     public static final int FRACTION_FIELD = 1;
-    
+
     /**
      * Formats a number and appends the resulting text to the given string buffer.
      * {@icunote} recognizes <code>BigInteger</code>
@@ -399,11 +401,13 @@ public abstract class NumberFormat extends UFormat {
                                StringBuffer toAppendTo,
                                FieldPosition pos) {
         // Default implementation -- subclasses may override
-        Currency save = getCurrency(), curr = currAmt.getCurrency();
-        boolean same = curr.equals(save);
-        if (!same) setCurrency(curr);
-        format(currAmt.getNumber(), toAppendTo, pos);
-        if (!same) setCurrency(save);
+        synchronized(this) {
+            Currency save = getCurrency(), curr = currAmt.getCurrency();
+            boolean same = curr.equals(save);
+            if (!same) setCurrency(curr);
+            format(currAmt.getNumber(), toAppendTo, pos);
+            if (!same) setCurrency(save);
+        }
         return toAppendTo;
     }
 
@@ -525,9 +529,9 @@ public abstract class NumberFormat extends UFormat {
 
     /**
      * {@icu} Set a particular DisplayContext value in the formatter,
-     * such as CAPITALIZATION_FOR_STANDALONE. 
-     * 
-     * @param context The DisplayContext value to set. 
+     * such as CAPITALIZATION_FOR_STANDALONE.
+     *
+     * @param context The DisplayContext value to set.
      * @stable ICU 53
      */
     public void setContext(DisplayContext context) {
@@ -539,7 +543,7 @@ public abstract class NumberFormat extends UFormat {
     /**
      * {@icu} Get the formatter's DisplayContext value for the specified DisplayContext.Type,
      * such as CAPITALIZATION.
-     * 
+     *
      * @param type the DisplayContext.Type whose value to return
      * @return the current DisplayContext setting for the specified type
      * @stable ICU 53
@@ -997,11 +1001,11 @@ public abstract class NumberFormat extends UFormat {
      * {@icu} Registers a new NumberFormatFactory.  The factory is adopted by
      * the service and must not be modified.  The returned object is a
      * key that can be used to unregister this factory.
-     * 
+     *
      * <p>Because ICU may choose to cache NumberFormat objects internally, this must
      * be called at application startup, prior to any calls to
      * NumberFormat.getInstance to avoid undefined behavior.
-     * 
+     *
      * @param factory the factory to register
      * @return a key with which to unregister the factory
      * @stable ICU 2.6
@@ -1255,7 +1259,7 @@ public abstract class NumberFormat extends UFormat {
     public Currency getCurrency() {
         return currency;
     }
-    
+
     /**
      * Returns the currency in effect for this formatter.  Subclasses
      * should override this method as needed.  Unlike getCurrency(),
@@ -1411,7 +1415,7 @@ public abstract class NumberFormat extends UFormat {
                 f.setDecimalSeparatorAlwaysShown(false);
                 f.setParseIntegerOnly(true);
             }
-            
+
             if (choice == CASHCURRENCYSTYLE) {
                 f.setCurrencyUsage(CurrencyUsage.CASH);
             }
@@ -1447,45 +1451,6 @@ public abstract class NumberFormat extends UFormat {
      * @stable ICU 3.2
      */
     protected static String getPattern(ULocale forLocale, int choice) {
-
-        /* The following code takes care of a few cases where the
-         * resource data in the underlying JDK lags the new features
-         * we have added to ICU4J: scientific notation, rounding, and
-         * secondary grouping.
-         *
-         * We detect these cases here and return various hard-coded
-         * resource data.  This is the simplest solution for now, but
-         * it is not a good long-term mechanism.
-         *
-         * We should replace this code with a data-driven mechanism
-         * that reads the bundle com.ibm.icu.impl.data.LocaleElements
-         * and parses an exception table that overrides the standard
-         * data at java.text.resource.LocaleElements*.java.
-         * Alternatively, we should create our own copy of the
-         * resource data, and use that exclusively.
-         */
-
-        // TEMPORARY, until we get scientific patterns into the main
-        // resources:  Retrieve scientific patterns from our resources.
-        //if (choice == SCIENTIFICSTYLE) {
-            // Temporarily hard code; retrieve from resource later
-            /*For ICU compatibility [Richard/GCL]*/
-        //    return "#E0";
-            // return NumberFormat.getBaseStringArray("NumberPatterns")[SCIENTIFICSTYLE];
-        //}
-
-        /* {dlf}
-        // Try the cache first
-        String[] numberPatterns = (String[]) cachedLocaleData.get(forLocale);
-        if (numberPatterns == null) {
-            OverlayBundle resource = new OverlayBundle(new String[]
-                { "com.ibm.icu.impl.data.LocaleElements", RESOURCE_BASE }, forLocale);
-            numberPatterns = resource.getStringArray("NumberPatterns");
-            // Update the cache
-            cachedLocaleData.put(forLocale, numberPatterns);
-        }
-        */
-
         /* for ISOCURRENCYSTYLE and PLURALCURRENCYSTYLE,
          * the pattern is the same as the pattern of CURRENCYSTYLE
          * but by replacing the single currency sign with
@@ -1499,7 +1464,8 @@ public abstract class NumberFormat extends UFormat {
             break;
         case CURRENCYSTYLE:
             String cfKeyValue = forLocale.getKeywordValue("cf");
-            patternKey = (cfKeyValue != null && cfKeyValue.equals("account"))? "accountingFormat": "currencyFormat";
+            patternKey = (cfKeyValue != null && cfKeyValue.equals("account")) ?
+                    "accountingFormat" : "currencyFormat";
             break;
         case CASHCURRENCYSTYLE:
         case ISOCURRENCYSTYLE:
@@ -1523,14 +1489,13 @@ public abstract class NumberFormat extends UFormat {
         }
 
         ICUResourceBundle rb = (ICUResourceBundle)UResourceBundle.
-        getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, forLocale);
+        getBundleInstance(ICUData.ICU_BASE_NAME, forLocale);
         NumberingSystem ns = NumberingSystem.getInstance(forLocale);
 
-        String result = null;
-        try {
-            result = rb.getStringWithFallback("NumberElements/" + ns.getName() + "/patterns/"+ patternKey);
-        } catch ( MissingResourceException ex ) {
-            result = rb.getStringWithFallback("NumberElements/latn/patterns/"+ patternKey);
+        String result = rb.findStringWithFallback(
+                    "NumberElements/" + ns.getName() + "/patterns/" + patternKey);
+        if (result == null) {
+            result = rb.getStringWithFallback("NumberElements/latn/patterns/" + patternKey);
         }
 
         return result;
diff --git a/app/src/main/java/com/ibm/icu/text/NumberFormatServiceShim.java b/icu4j/src/main/java/com/ibm/icu/text/NumberFormatServiceShim.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/text/NumberFormatServiceShim.java
rename to icu4j/src/main/java/com/ibm/icu/text/NumberFormatServiceShim.java
index c3a6185..7bba2d6 100644
--- a/app/src/main/java/com/ibm/icu/text/NumberFormatServiceShim.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/NumberFormatServiceShim.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2003-2011, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/NumberingSystem.java b/icu4j/src/main/java/com/ibm/icu/text/NumberingSystem.java
similarity index 71%
rename from app/src/main/java/com/ibm/icu/text/NumberingSystem.java
rename to icu4j/src/main/java/com/ibm/icu/text/NumberingSystem.java
index 0a65198..fc62629 100644
--- a/app/src/main/java/com/ibm/icu/text/NumberingSystem.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/NumberingSystem.java
@@ -1,7 +1,9 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2009-2012, International Business Machines Corporation and    *
- * others. All Rights Reserved.                                                *
+ * Copyright (C) 2009-2016, International Business Machines Corporation and
+ * others. All Rights Reserved.
  *******************************************************************************
  */
 
@@ -11,10 +13,10 @@ import java.util.ArrayList;
 import java.util.Locale;
 import java.util.MissingResourceException;
 
-import com.ibm.icu.impl.ICUCache;
+import com.ibm.icu.impl.CacheBase;
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
-import com.ibm.icu.impl.SimpleCache;
-import com.ibm.icu.lang.UCharacter;
+import com.ibm.icu.impl.SoftCache;
 import com.ibm.icu.util.ULocale;
 import com.ibm.icu.util.ULocale.Category;
 import com.ibm.icu.util.UResourceBundle;
@@ -24,7 +26,7 @@ import com.ibm.icu.util.UResourceBundleIterator;
 /**
  * <code>NumberingSystem</code> is the base class for all number
  * systems. This class provides the interface for setting different numbering
- * system types, whether it be a simple alternate digit system such as 
+ * system types, whether it be a simple alternate digit system such as
  * Thai digits or Devanagari digits, or an algorithmic numbering system such
  * as Hebrew numbering or Chinese numbering.
  *
@@ -32,6 +34,7 @@ import com.ibm.icu.util.UResourceBundleIterator;
  * @stable ICU 4.2
  */
 public class NumberingSystem {
+    private static final String[] OTHER_NS_KEYWORDS = { "native", "traditional", "finance" };
 
     /**
      * Default constructor.  Returns a numbering system that uses the Western decimal
@@ -47,7 +50,7 @@ public class NumberingSystem {
 
     /**
      * Factory method for creating a numbering system.
-     * @param radix_in The radix for this numbering system.  ICU currently 
+     * @param radix_in The radix for this numbering system.  ICU currently
      * supports only numbering systems whose radix is 10.
      * @param isAlgorithmic_in Specifies whether the numbering system is algorithmic
      * (true) or numeric (false).
@@ -62,11 +65,11 @@ public class NumberingSystem {
     public static NumberingSystem getInstance(int radix_in, boolean isAlgorithmic_in, String desc_in ) {
         return getInstance(null,radix_in,isAlgorithmic_in,desc_in);
     }
-    
+
     /**
      * Factory method for creating a numbering system.
      * @param name_in The string representing the name of the numbering system.
-     * @param radix_in The radix for this numbering system.  ICU currently 
+     * @param radix_in The radix for this numbering system.  ICU currently
      * supports only numbering systems whose radix is 10.
      * @param isAlgorithmic_in Specifies whether the numbering system is algorithmic
      * (true) or numeric (false).
@@ -78,7 +81,7 @@ public class NumberingSystem {
      * this numbering system.
      * @stable ICU 4.6
      */
-   
+
     private static NumberingSystem getInstance(String name_in, int radix_in, boolean isAlgorithmic_in, String desc_in ) {
         if ( radix_in < 2 ) {
             throw new IllegalArgumentException("Invalid radix for numbering system");
@@ -110,13 +113,8 @@ public class NumberingSystem {
      * @stable ICU 4.2
      */
     public static NumberingSystem getInstance(ULocale locale) {
-        
-        final String[] OTHER_NS_KEYWORDS = { "native", "traditional", "finance" };
- 
-        NumberingSystem ns;
-        Boolean nsResolved = true;
-
         // Check for @numbers
+        boolean nsResolved = true;
         String numbersKeyword = locale.getKeywordValue("numbers");
         if (numbersKeyword != null ) {
             for ( String keyword : OTHER_NS_KEYWORDS ) {
@@ -131,54 +129,72 @@ public class NumberingSystem {
         }
 
         if (nsResolved) {
-            ns = getInstanceByName(numbersKeyword);
-            if ( ns != null ) {
+            NumberingSystem ns = getInstanceByName(numbersKeyword);
+            if (ns != null) {
                 return ns;
-            } else { // if @numbers keyword points to a bogus numbering system name, we return the default for the locale
-                numbersKeyword = "default";
-                nsResolved = false;
             }
+            // If the @numbers keyword points to a bogus numbering system name,
+            // we return the default for the locale.
+            numbersKeyword = "default";
         }
-        
+
         // Attempt to get the numbering system from the cache
         String baseName = locale.getBaseName();
-        ns = cachedLocaleData.get(baseName+"@numbers="+numbersKeyword);
-        if (ns != null ) {
-            return ns;
+        // TODO: Caching by locale+numbersKeyword could yield a large cache.
+        // Try to load for each locale the mappings from OTHER_NS_KEYWORDS and default
+        // to real numbering system names; can we get those from supplemental data?
+        // Then look up those mappings for the locale and resolve the keyword.
+        String key = baseName+"@numbers="+numbersKeyword;
+        LocaleLookupData localeLookupData = new LocaleLookupData(locale, numbersKeyword);
+        return cachedLocaleData.getInstance(key, localeLookupData);
+    }
+
+    private static class LocaleLookupData {
+        public final ULocale locale;
+        public final String numbersKeyword;
+
+        LocaleLookupData(ULocale locale, String numbersKeyword) {
+            this.locale = locale;
+            this.numbersKeyword = numbersKeyword;
         }
-        
-        // Cache miss, create new instance
+    }
 
-        String originalNumbersKeyword = numbersKeyword;
+    static NumberingSystem lookupInstanceByLocale(LocaleLookupData localeLookupData) {
+        ULocale locale = localeLookupData.locale;
+        ICUResourceBundle rb;
+        try {
+            rb = (ICUResourceBundle)UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, locale);
+            rb = rb.getWithFallback("NumberElements");
+        } catch (MissingResourceException ex) {
+            return new NumberingSystem();
+        }
+
+        String numbersKeyword = localeLookupData.numbersKeyword;
         String resolvedNumberingSystem = null;
-        while (!nsResolved) {           
+        for (;;) {
             try {
-                ICUResourceBundle rb = (ICUResourceBundle)UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME,locale);
-                rb = rb.getWithFallback("NumberElements");
                 resolvedNumberingSystem = rb.getStringWithFallback(numbersKeyword);
-                nsResolved = true;
+                break;
             } catch (MissingResourceException ex) { // Fall back behavior as defined in TR35
-                 if (numbersKeyword.equals("native") || numbersKeyword.equals("finance")) {
-                     numbersKeyword = "default";
-                 } else if (numbersKeyword.equals("traditional")) {
-                     numbersKeyword = "native";
-                 } else {
-                     nsResolved = true;
-                 }
-            }  
+                if (numbersKeyword.equals("native") || numbersKeyword.equals("finance")) {
+                    numbersKeyword = "default";
+                } else if (numbersKeyword.equals("traditional")) {
+                    numbersKeyword = "native";
+                } else {
+                    break;
+                }
+            }
         }
 
+        NumberingSystem ns = null;
         if (resolvedNumberingSystem != null) {
             ns = getInstanceByName(resolvedNumberingSystem);
         }
-        
-        if ( ns == null ) {
+
+        if (ns == null) {
             ns = new NumberingSystem();
         }
-
-        cachedLocaleData.put(baseName+"@numbers="+originalNumbersKeyword, ns);
         return ns;
-    
     }
 
     /**
@@ -201,18 +217,16 @@ public class NumberingSystem {
      * @stable ICU 4.2
      */
     public static NumberingSystem getInstanceByName(String name) {
+        // Get the numbering system from the cache.
+        return cachedStringData.getInstance(name, null /* unused */);
+    }
+
+    private static NumberingSystem lookupInstanceByName(String name) {
         int radix;
         boolean isAlgorithmic;
         String description;
-        
-        // Get the numbering system from the cache
-        NumberingSystem ns = cachedStringData.get(name);
-        if (ns != null ) {
-            return ns;
-        }        
-        
         try {
-            UResourceBundle numberingSystemsInfo = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, "numberingSystems");
+            UResourceBundle numberingSystemsInfo = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, "numberingSystems");
             UResourceBundle nsCurrent = numberingSystemsInfo.get("numberingSystems");
             UResourceBundle nsTop = nsCurrent.get(name);
 
@@ -228,9 +242,7 @@ public class NumberingSystem {
             return null;
         }
 
-        ns = getInstance(name,radix,isAlgorithmic,description);
-        cachedStringData.put(name, ns);                       
-        return ns;     
+        return getInstance(name, radix, isAlgorithmic, description);
     }
 
     /**
@@ -239,8 +251,8 @@ public class NumberingSystem {
      * @stable ICU 4.2
      */
     public static String [] getAvailableNames() {
-    
-            UResourceBundle numberingSystemsInfo = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, "numberingSystems");
+
+            UResourceBundle numberingSystemsInfo = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, "numberingSystems");
             UResourceBundle nsCurrent = numberingSystemsInfo.get("numberingSystems");
             UResourceBundle temp;
 
@@ -256,29 +268,14 @@ public class NumberingSystem {
     }
 
     /**
-     * Convenience method to determine if a given digit string is valid for use as a 
+     * Convenience method to determine if a given digit string is valid for use as a
      * descriptor of a numeric ( non-algorithmic ) numbering system.  In order for
-     * a digit string to be valid, it must meet the following criteria:
-     * 1. Digits must be in Unicode's basic multilingual plane.
+     * a digit string to be valid, it must contain exactly ten Unicode code points.
      * @stable ICU 4.2
      */
     public static boolean isValidDigitString(String str) {
-
-        int c;
-        int i = 0;
-        UCharacterIterator it = UCharacterIterator.getInstance(str);
-
-        it.setToStart();
-        while ( (c = it.nextCodePoint()) != UCharacterIterator.DONE) {
-            if ( UCharacter.isSupplementary(c)) { // Digits outside the BMP are not currently supported
-                return false;
-            }
-            i++;
-        }
-        if ( i != 10 ) {
-            return false;
-        }
-        return true;
+        int numCodepoints = str.codePointCount(0, str.length());
+        return (numCodepoints == 10);
     }
 
     /**
@@ -314,7 +311,7 @@ public class NumberingSystem {
      * Returns the numbering system's algorithmic status.  If true,
      * the numbering system is algorithmic and uses an RBNF formatter to
      * format numerals.  If false, the numbering system is numeric and
-     * uses a fixed set of digits. 
+     * uses a fixed set of digits.
      * @stable ICU 4.2
      */
     public boolean isAlgorithmic() {
@@ -329,11 +326,22 @@ public class NumberingSystem {
     /**
      * Cache to hold the NumberingSystems by Locale.
      */
-    private static ICUCache<String, NumberingSystem> cachedLocaleData = new SimpleCache<String, NumberingSystem>();
-        
+    private static CacheBase<String, NumberingSystem, LocaleLookupData> cachedLocaleData =
+            new SoftCache<String, NumberingSystem, LocaleLookupData>() {
+        @Override
+        protected NumberingSystem createInstance(String key, LocaleLookupData localeLookupData) {
+            return lookupInstanceByLocale(localeLookupData);
+        }
+    };
+
     /**
      * Cache to hold the NumberingSystems by name.
      */
-    private static ICUCache<String, NumberingSystem> cachedStringData = new SimpleCache<String, NumberingSystem>();
-    
+    private static CacheBase<String, NumberingSystem, Void>  cachedStringData =
+            new SoftCache<String, NumberingSystem, Void>() {
+        @Override
+        protected NumberingSystem createInstance(String key, Void unused) {
+            return lookupInstanceByName(key);
+        }
+    };
 }
diff --git a/app/src/main/java/com/ibm/icu/text/PluralFormat.java b/icu4j/src/main/java/com/ibm/icu/text/PluralFormat.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/PluralFormat.java
rename to icu4j/src/main/java/com/ibm/icu/text/PluralFormat.java
index 7c89d8e..0f90d00 100644
--- a/app/src/main/java/com/ibm/icu/text/PluralFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/PluralFormat.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2007-2016, International Business Machines Corporation and
@@ -53,9 +55,9 @@ import com.ibm.icu.util.ULocale.Category;
  *     need not worry about the plural cases of a language and
  *     does not have to define the plural cases; they can simply
  *     use the predefined keywords. The whole plural formatting of messages can
- *     be done using localized patterns from resource bundles. For predefined plural 
+ *     be done using localized patterns from resource bundles. For predefined plural
  *     rules, see the CLDR <i>Language Plural Rules</i> page at
- *    http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html 
+ *    http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
  * </ul>
  *
  * <h4>Usage of <code>PluralFormat</code></h4>
@@ -88,8 +90,8 @@ import com.ibm.icu.util.ULocale.Category;
  * between the {curly braces} and their sub-message,
  * and between the '=' and the number of an explicitValue.
  * <p>
- * There are 6 predefined case keywords in CLDR/ICU - 'zero', 'one', 'two', 'few', 'many' and 
- * 'other'. You always have to define a message text for the default plural case 
+ * There are 6 predefined case keywords in CLDR/ICU - 'zero', 'one', 'two', 'few', 'many' and
+ * 'other'. You always have to define a message text for the default plural case
  * "<code>other</code>" which is contained in every rule set.
  * If you do not specify a message text for a particular plural case, the
  * message text of the plural case "<code>other</code>" gets assigned to this
@@ -153,7 +155,7 @@ public class PluralFormat extends UFormat {
      * The MessagePattern which contains the parsed structure of the pattern string.
      */
     transient private MessagePattern msgPattern;
-    
+
     /**
      * Obsolete with use of MessagePattern since ICU 4.8. Used to be:
      * The format messages for each plural case. It is a mapping:
@@ -550,6 +552,7 @@ public class PluralFormat extends UFormat {
     // We could avoid this adapter class if we made PluralSelector public
     // (or at least publicly visible) and had PluralRules implement PluralSelector.
     private final class PluralSelectorAdapter implements PluralSelector {
+        @Override
         public String select(Object context, double number) {
             FixedDecimal dec = (FixedDecimal) context;
             assert dec.source == (dec.isNegative ? -number : number);
@@ -589,6 +592,7 @@ public class PluralFormat extends UFormat {
      * @throws IllegalArgumentException if number is not an instance of Number
      * @stable ICU 3.8
      */
+    @Override
     public StringBuffer format(Object number, StringBuffer toAppendTo,
             FieldPosition pos) {
         if (!(number instanceof Number)) {
@@ -685,6 +689,7 @@ public class PluralFormat extends UFormat {
      * @throws UnsupportedOperationException will always be thrown by this method.
      * @stable ICU 3.8
      */
+    @Override
     public Object parseObject(String source, ParsePosition pos) {
         throw new UnsupportedOperationException();
     }
diff --git a/app/src/main/java/com/ibm/icu/text/PluralRanges.java b/icu4j/src/main/java/com/ibm/icu/text/PluralRanges.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/text/PluralRanges.java
rename to icu4j/src/main/java/com/ibm/icu/text/PluralRanges.java
index 7aab6d2..b1b8e31 100644
--- a/app/src/main/java/com/ibm/icu/text/PluralRanges.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/PluralRanges.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2008-2015, Google, International Business Machines Corporation and
@@ -16,7 +18,7 @@ import com.ibm.icu.util.Output;
 /**
  * Utility class for returning the plural category for a range of numbers, such as 1–5, so that appropriate messages can
  * be chosen. The rules for determining this value vary widely across locales.
- * 
+ *
  * @author markdavis
  * @internal
  * @deprecated This API is ICU internal only.
@@ -30,7 +32,7 @@ public final class PluralRanges implements Freezable<PluralRanges>, Comparable<P
 
     /**
      * Constructor
-     * 
+     *
      * @internal
      * @deprecated This API is ICU internal only.
      */
@@ -150,6 +152,7 @@ public final class PluralRanges implements Freezable<PluralRanges>, Comparable<P
             return 0 == compareTo((Matrix) other);
         }
 
+        @Override
         public int compareTo(Matrix o) {
             for (int i = 0; i < data.length; ++i) {
                 int diff = data[i] - o.data[i];
@@ -166,7 +169,7 @@ public final class PluralRanges implements Freezable<PluralRanges>, Comparable<P
             result.data = data.clone();
             return result;
         }
-        
+
         @Override
         public String toString() {
             StringBuilder result = new StringBuilder();
@@ -184,7 +187,7 @@ public final class PluralRanges implements Freezable<PluralRanges>, Comparable<P
 
     /**
      * Internal method for building. If the start or end are null, it means everything of that type.
-     * 
+     *
      * @param rangeStart
      *            plural category for the start of the range
      * @param rangeEnd
@@ -227,7 +230,7 @@ public final class PluralRanges implements Freezable<PluralRanges>, Comparable<P
     /**
      * Returns the appropriate plural category for a range from start to end. If there is no available data, then
      * 'end' is returned as an implicit value. (Such an implicit value can be tested for with {@link #isExplicit}.)
-     * 
+     *
      * @param start
      *            plural category for the start of the range
      * @param end
@@ -245,7 +248,7 @@ public final class PluralRanges implements Freezable<PluralRanges>, Comparable<P
     /**
      * Returns whether the appropriate plural category for a range from start to end
      * is explicitly in the data (vs given an implicit value). See also {@link #get}.
-     * 
+     *
      * @param start
      *            plural category for the start of the range
      * @param end
@@ -261,7 +264,7 @@ public final class PluralRanges implements Freezable<PluralRanges>, Comparable<P
 
     /**
      * Internal method to determines whether the StandardPluralCategories was explicitly used in any add statement.
-     * 
+     *
      * @param count
      *            plural category to test
      * @return true if set
@@ -307,6 +310,7 @@ public final class PluralRanges implements Freezable<PluralRanges>, Comparable<P
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Override
     @Deprecated
     public int compareTo(PluralRanges that) {
         return matrix.compareTo(that.matrix);
@@ -317,6 +321,7 @@ public final class PluralRanges implements Freezable<PluralRanges>, Comparable<P
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Override
     @Deprecated
     public boolean isFrozen() {
         return isFrozen;
@@ -327,6 +332,7 @@ public final class PluralRanges implements Freezable<PluralRanges>, Comparable<P
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Override
     @Deprecated
     public PluralRanges freeze() {
         isFrozen = true;
@@ -338,6 +344,7 @@ public final class PluralRanges implements Freezable<PluralRanges>, Comparable<P
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Override
     @Deprecated
     public PluralRanges cloneAsThawed() {
         PluralRanges result = new PluralRanges();
diff --git a/app/src/main/java/com/ibm/icu/text/PluralRules.java b/icu4j/src/main/java/com/ibm/icu/text/PluralRules.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/PluralRules.java
rename to icu4j/src/main/java/com/ibm/icu/text/PluralRules.java
index 5ba09a3..970f7ca 100644
--- a/app/src/main/java/com/ibm/icu/text/PluralRules.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/PluralRules.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2007-2016, International Business Machines Corporation and
@@ -52,7 +54,7 @@ import com.ibm.icu.util.ULocale;
  * <p>
  * Examples:
  * </p>
- * 
+ *
  * <pre>
  * &quot;one: n is 1; few: n in 2..4&quot;
  * </pre>
@@ -62,7 +64,7 @@ import com.ibm.icu.util.ULocale;
  * between 2 and 4 inclusive - and be an integer - for this condition to pass. All other numbers are assigned the
  * keyword "other" by the default rule.
  * </p>
- * 
+ *
  * <pre>
  * &quot;zero: n is 0; one: n is 1; zero: n mod 100 in 1..19&quot;
  * </pre>
@@ -71,7 +73,7 @@ import com.ibm.icu.util.ULocale;
  * keyword whose condition passes is the one returned. Also notes that a modulus is applied to n in the last rule. Thus
  * its condition holds for 119, 219, 319...
  * </p>
- * 
+ *
  * <pre>
  * &quot;one: n is 1; few: n mod 10 in 2..4 and n mod 100 not in 12..14&quot;
  * </pre>
@@ -162,7 +164,7 @@ import com.ibm.icu.util.ULocale;
  * includes all values. Using 'within' with a range_list consisting entirely of values is the same as using 'in' (it's
  * not an error).
  * </p>
- * 
+ *
  * @stable ICU 3.8
  */
 public class PluralRules implements Serializable {
@@ -190,7 +192,7 @@ public class PluralRules implements Serializable {
 
     /**
      * Provides a factory for returning plural rules
-     * 
+     *
      * @internal
      * @deprecated This API is ICU internal only.
      */
@@ -207,11 +209,11 @@ public class PluralRules implements Serializable {
 
         /**
          * Provides access to the predefined <code>PluralRules</code> for a given locale and the plural type.
-         * 
+         *
          * <p>
          * ICU defines plural rules for many locales based on CLDR <i>Language Plural Rules</i>. For these predefined
          * rules, see CLDR page at http://unicode.org/repos/cldr-tmp/trunk/diff/supplemental/language_plural_rules.html
-         * 
+         *
          * @param locale
          *            The locale for which a <code>PluralRules</code> object is returned.
          * @param type
@@ -239,7 +241,7 @@ public class PluralRules implements Serializable {
 
         /**
          * Returns the locales for which there is plurals data.
-         * 
+         *
          * @internal
          * @deprecated This API is ICU internal only.
          */
@@ -252,7 +254,7 @@ public class PluralRules implements Serializable {
          * All locales with the same functionally equivalent locale have plural rules that behave the same. This is not
          * exaustive; there may be other locales whose plural rules behave the same that do not have the same equivalent
          * locale.
-         * 
+         *
          * @param locale
          *            the locale to check
          * @param isAvailable
@@ -353,21 +355,24 @@ public class PluralRules implements Serializable {
     private static final Constraint NO_CONSTRAINT = new Constraint() {
         private static final long serialVersionUID = 9163464945387899416L;
 
+        @Override
         public boolean isFulfilled(FixedDecimal n) {
             return true;
         }
 
+        @Override
         public boolean isLimited(SampleType sampleType) {
             return false;
         }
 
+        @Override
         public String toString() {
             return "";
         }
     };
 
     /**
-     * 
+     *
      */
     private static final Rule DEFAULT_RULE = new Rule("other", NO_CONSTRAINT, null, null);
 
@@ -572,12 +577,12 @@ public class PluralRules implements Serializable {
             source = isNegative ? -n : n;
             visibleDecimalDigitCount = v;
             decimalDigits = f;
-            integerValue = n > MAX 
-                    ? MAX 
+            integerValue = n > MAX
+                    ? MAX
                             : (long)n;
             hasIntegerValue = source == integerValue;
             // check values. TODO make into unit test.
-            //            
+            //
             //            long visiblePower = (int) Math.pow(10, v);
             //            if (fractionalDigits > visiblePower) {
             //                throw new IllegalArgumentException();
@@ -652,7 +657,7 @@ public class PluralRules implements Serializable {
          * Returns 0 for infinities and nans.
          * @internal
          * @deprecated This API is ICU internal only.
-         * 
+         *
          */
         @Deprecated
         public static int decimals(double n) {
@@ -691,7 +696,7 @@ public class PluralRules implements Serializable {
                     if (buf.charAt(i) != '0') {
                         break;
                     }
-                    --numFractionDigits; 
+                    --numFractionDigits;
                 }
                 return numFractionDigits;
             }
@@ -747,6 +752,7 @@ public class PluralRules implements Serializable {
          * @internal
          * @deprecated This API is ICU internal only.
          */
+        @Override
         @Deprecated
         public int compareTo(FixedDecimal other) {
             if (integerValue != other.integerValue) {
@@ -1005,7 +1011,7 @@ public class PluralRules implements Serializable {
                 }
                 String[] rangeParts = TILDE_SEPARATED.split(range);
                 switch (rangeParts.length) {
-                case 1: 
+                case 1:
                     FixedDecimal sample = new FixedDecimal(rangeParts[0]);
                     checkDecimal(sampleType2, sample);
                     samples2.add(new FixedDecimalRange(sample, sample));
@@ -1025,7 +1031,7 @@ public class PluralRules implements Serializable {
 
         private static void checkDecimal(SampleType sampleType2, FixedDecimal sample) {
             if ((sampleType2 == SampleType.INTEGER) != (sample.getVisibleDecimalDigitCount() == 0)) {
-                throw new IllegalArgumentException("Ill-formed number range: " + sample);    
+                throw new IllegalArgumentException("Ill-formed number range: " + sample);
             }
         }
 
@@ -1253,7 +1259,7 @@ public class PluralRules implements Serializable {
                                     if (!t.equals(",")) { // adjacent number: 1 2
                                         // no separator, fail
                                         throw unexpected(t, condition);
-                                    }                                
+                                    }
                                 }
                             } else if (!t.equals(",")) { // adjacent number: 1 2
                                 // no separator, fail
@@ -1371,7 +1377,7 @@ public class PluralRules implements Serializable {
         FixedDecimalSamples integerSamples = null, decimalSamples = null;
         switch (constraintOrSamples.length) {
         case 1: break;
-        case 2: 
+        case 2:
             integerSamples = FixedDecimalSamples.parse(constraintOrSamples[1]);
             if (integerSamples.sampleType == SampleType.DECIMAL) {
                 decimalSamples = integerSamples;
@@ -1385,7 +1391,7 @@ public class PluralRules implements Serializable {
                 throw new IllegalArgumentException("Must have @integer then @decimal in " + description);
             }
             break;
-        default: 
+        default:
             throw new IllegalArgumentException("Too many samples in " + description);
         }
         if (sampleFailure) {
@@ -1417,7 +1423,7 @@ public class PluralRules implements Serializable {
             throws ParseException {
         RuleList result = new RuleList();
         // remove trailing ;
-        if (description.endsWith(";")) { 
+        if (description.endsWith(";")) {
             description = description.substring(0,description.length()-1);
         }
         String[] rules = SEMI_SEPARATED.split(description);
@@ -1456,6 +1462,7 @@ public class PluralRules implements Serializable {
             this.operand = operand;
         }
 
+        @Override
         public boolean isFulfilled(FixedDecimal number) {
             double n = number.get(operand);
             if ((integersOnly && (n - (long)n) != 0.0
@@ -1475,27 +1482,29 @@ public class PluralRules implements Serializable {
             return inRange == test;
         }
 
+        @Override
         public boolean isLimited(SampleType sampleType) {
             boolean valueIsZero = lowerBound == upperBound && lowerBound == 0d;
-            boolean hasDecimals = 
+            boolean hasDecimals =
                     (operand == Operand.v || operand == Operand.w || operand == Operand.f || operand == Operand.t)
                     && inRange != valueIsZero; // either NOT f = zero or f = non-zero
             switch (sampleType) {
-            case INTEGER: 
+            case INTEGER:
                 return hasDecimals // will be empty
                         || (operand == Operand.n || operand == Operand.i || operand == Operand.j)
-                        && mod == 0 
+                        && mod == 0
                         && inRange;
 
             case DECIMAL:
                 return  (!hasDecimals || operand == Operand.n || operand == Operand.j)
                         && (integersOnly || lowerBound == upperBound)
-                        && mod == 0 
+                        && mod == 0
                         && inRange;
             }
             return false;
         }
 
+        @Override
         public String toString() {
             StringBuilder result = new StringBuilder();
             result.append(operand);
@@ -1506,7 +1515,7 @@ public class PluralRules implements Serializable {
             result.append(
                     !isList ? (inRange ? " = " : " != ")
                             : integersOnly ? (inRange ? " = " : " != ")
-                                    : (inRange ? " within " : " not within ") 
+                                    : (inRange ? " within " : " not within ")
                     );
             if (range_list != null) {
                 for (int i = 0; i < range_list.length; i += 2) {
@@ -1556,18 +1565,21 @@ public class PluralRules implements Serializable {
             super(a, b);
         }
 
+        @Override
         public boolean isFulfilled(FixedDecimal n) {
-            return a.isFulfilled(n) 
+            return a.isFulfilled(n)
                     && b.isFulfilled(n);
         }
 
+        @Override
         public boolean isLimited(SampleType sampleType) {
             // we ignore the case where both a and b are unlimited but no values
             // satisfy both-- we still consider this 'unlimited'
-            return a.isLimited(sampleType) 
+            return a.isLimited(sampleType)
                     || b.isLimited(sampleType);
         }
 
+        @Override
         public String toString() {
             return a.toString() + " and " + b.toString();
         }
@@ -1581,16 +1593,19 @@ public class PluralRules implements Serializable {
             super(a, b);
         }
 
+        @Override
         public boolean isFulfilled(FixedDecimal n) {
-            return a.isFulfilled(n) 
+            return a.isFulfilled(n)
                     || b.isFulfilled(n);
         }
 
+        @Override
         public boolean isLimited(SampleType sampleType) {
-            return a.isLimited(sampleType) 
+            return a.isLimited(sampleType)
                     && b.isLimited(sampleType);
         }
 
+        @Override
         public String toString() {
             return a.toString() + " or " + b.toString();
         }
@@ -1601,6 +1616,8 @@ public class PluralRules implements Serializable {
      * Provides 'and' and 'or' to combine constraints.  Immutable.
      */
     private static class Rule implements Serializable {
+        // TODO - Findbugs: Class com.ibm.icu.text.PluralRules$Rule defines non-transient
+        // non-serializable instance field integerSamples. See ticket#10494.
         private static final long serialVersionUID = 1;
         private final String keyword;
         private final Constraint constraint;
@@ -1636,8 +1653,9 @@ public class PluralRules implements Serializable {
             return constraint.isLimited(sampleType);
         }
 
+        @Override
         public String toString() {
-            return keyword + ": " + constraint.toString() 
+            return keyword + ": " + constraint.toString()
                     + (integerSamples == null ? "" : " " + integerSamples.toString())
                     + (decimalSamples == null ? "" : " " + decimalSamples.toString());
         }
@@ -1741,6 +1759,7 @@ public class PluralRules implements Serializable {
             return result;
         }
 
+        @Override
         public String toString() {
             StringBuilder builder = new StringBuilder();
             for (Rule rule : rules) {
@@ -2015,7 +2034,7 @@ public class PluralRules implements Serializable {
      * @param type the type of samples requested, INTEGER or DECIMAL
      * @return the values that trigger this keyword, or null.  The returned collection
      * is immutable. It will be empty if the keyword is not defined.
-     * 
+     *
      * @internal
      * @deprecated This API is ICU internal only.
      */
@@ -2162,6 +2181,7 @@ public class PluralRules implements Serializable {
      * {@inheritDoc}
      * @stable ICU 3.8
      */
+    @Override
     public String toString() {
         return rules.toString();
     }
@@ -2170,6 +2190,7 @@ public class PluralRules implements Serializable {
      * {@inheritDoc}
      * @stable ICU 3.8
      */
+    @Override
     public boolean equals(Object rhs) {
         return rhs instanceof PluralRules && equals((PluralRules)rhs);
     }
@@ -2187,42 +2208,42 @@ public class PluralRules implements Serializable {
 
     /**
      * Status of the keyword for the rules, given a set of explicit values.
-     * 
+     *
      * @draft ICU 50
      * @provisional This API might change or be removed in a future release.
      */
     public enum KeywordStatus {
         /**
          * The keyword is not valid for the rules.
-         * 
+         *
          * @draft ICU 50
          * @provisional This API might change or be removed in a future release.
          */
         INVALID,
         /**
          * The keyword is valid, but unused (it is covered by the explicit values, OR has no values for the given {@link SampleType}).
-         * 
+         *
          * @draft ICU 50
          * @provisional This API might change or be removed in a future release.
          */
         SUPPRESSED,
         /**
          * The keyword is valid, used, and has a single possible value (before considering explicit values).
-         * 
+         *
          * @draft ICU 50
          * @provisional This API might change or be removed in a future release.
          */
         UNIQUE,
         /**
          * The keyword is valid, used, not unique, and has a finite set of values.
-         * 
+         *
          * @draft ICU 50
          * @provisional This API might change or be removed in a future release.
          */
         BOUNDED,
         /**
          * The keyword is valid but not bounded; there indefinitely many matching values.
-         * 
+         *
          * @draft ICU 50
          * @provisional This API might change or be removed in a future release.
          */
@@ -2231,7 +2252,7 @@ public class PluralRules implements Serializable {
 
     /**
      * Find the status for the keyword, given a certain set of explicit values.
-     * 
+     *
      * @param keyword
      *            the particular keyword (call rules.getKeywords() to get the valid ones)
      * @param offset
@@ -2251,7 +2272,7 @@ public class PluralRules implements Serializable {
     }
     /**
      * Find the status for the keyword, given a certain set of explicit values.
-     * 
+     *
      * @param keyword
      *            the particular keyword (call rules.getKeywords() to get the valid ones)
      * @param offset
diff --git a/app/src/main/java/com/ibm/icu/text/PluralRulesSerialProxy.java b/icu4j/src/main/java/com/ibm/icu/text/PluralRulesSerialProxy.java
similarity index 86%
rename from app/src/main/java/com/ibm/icu/text/PluralRulesSerialProxy.java
rename to icu4j/src/main/java/com/ibm/icu/text/PluralRulesSerialProxy.java
index c8b6306..daf43ff 100644
--- a/app/src/main/java/com/ibm/icu/text/PluralRulesSerialProxy.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/PluralRulesSerialProxy.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2013, Google Inc, International Business Machines Corporation and         *
diff --git a/app/src/main/java/com/ibm/icu/text/PluralSamples.java b/icu4j/src/main/java/com/ibm/icu/text/PluralSamples.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/PluralSamples.java
rename to icu4j/src/main/java/com/ibm/icu/text/PluralSamples.java
index a58b154..fdef4f0 100644
--- a/app/src/main/java/com/ibm/icu/text/PluralSamples.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/PluralSamples.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2013-2015, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/text/Quantifier.java b/icu4j/src/main/java/com/ibm/icu/text/Quantifier.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/text/Quantifier.java
rename to icu4j/src/main/java/com/ibm/icu/text/Quantifier.java
index 643ab27..de0a375 100644
--- a/app/src/main/java/com/ibm/icu/text/Quantifier.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/Quantifier.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2001-2011, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/QuantityFormatter.java b/icu4j/src/main/java/com/ibm/icu/text/QuantityFormatter.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/text/QuantityFormatter.java
rename to icu4j/src/main/java/com/ibm/icu/text/QuantityFormatter.java
index 2330f49..562439f 100644
--- a/app/src/main/java/com/ibm/icu/text/QuantityFormatter.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/QuantityFormatter.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2013-2016, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/text/RBBIDataWrapper.java b/icu4j/src/main/java/com/ibm/icu/text/RBBIDataWrapper.java
similarity index 88%
rename from app/src/main/java/com/ibm/icu/text/RBBIDataWrapper.java
rename to icu4j/src/main/java/com/ibm/icu/text/RBBIDataWrapper.java
index 1e6a291..6147cd0 100644
--- a/app/src/main/java/com/ibm/icu/text/RBBIDataWrapper.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/RBBIDataWrapper.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2015, International Business Machines Corporation and
@@ -19,7 +21,7 @@ import com.ibm.icu.impl.Trie;
 /**
 * <p>Internal class used for Rule Based Break Iterators</p>
 * <p>This class provides access to the compiled break rule data, as
-* it is stored in a .brk file.  
+* it is stored in a .brk file.
 */
 final class RBBIDataWrapper {
     //
@@ -42,6 +44,7 @@ final class RBBIDataWrapper {
 
     private static final class IsAcceptable implements Authenticate {
         // @Override when we switch to Java 6
+        @Override
         public boolean isDataVersionAcceptable(byte version[]) {
             return version[0] == (FORMAT_VERSION >>> 24);
         }
@@ -71,17 +74,17 @@ final class RBBIDataWrapper {
     final static int    DH_RULESOURCELEN  = 15;
     final static int    DH_STATUSTABLE    = 16;
     final static int    DH_STATUSTABLELEN = 17;
-    
-    
+
+
     // Index offsets to the fields in a state table row.
     //    Corresponds to struct RBBIStateTableRow in the C version.
-    //   
+    //
     final static int      ACCEPTING  = 0;
     final static int      LOOKAHEAD  = 1;
     final static int      TAGIDX     = 2;
     final static int      RESERVED   = 3;
     final static int      NEXTSTATES = 4;
-    
+
     // Index offsets to header fields of a state table
     //     struct RBBIStateTable {...   in the C version.
     //
@@ -95,37 +98,37 @@ final class RBBIDataWrapper {
     //     enum RBBIStateTableFlags in the C version.
     //
     final static int      RBBI_LOOKAHEAD_HARD_BREAK = 1;
-    final static int      RBBI_BOF_REQUIRED         = 2;  
-    
+    final static int      RBBI_BOF_REQUIRED         = 2;
+
     /**
      * Data Header.  A struct-like class with the fields from the RBBI data file header.
      */
     final static class RBBIDataHeader {
-        int         fMagic;         //  == 0xbla0 
-        int         fVersion;       //  == 1 (for ICU 3.2 and earlier. 
+        int         fMagic;         //  == 0xbla0
+        int         fVersion;       //  == 1 (for ICU 3.2 and earlier.
         byte[]      fFormatVersion; //  For ICU 3.4 and later.
-        int         fLength;        //  Total length in bytes of this RBBI Data, 
-                                       //      including all sections, not just the header. 
-        int         fCatCount;      //  Number of character categories. 
-
-        //  
-        //  Offsets and sizes of each of the subsections within the RBBI data. 
-        //  All offsets are bytes from the start of the RBBIDataHeader. 
-        //  All sizes are in bytes. 
-        //  
-        int         fFTable;         //  forward state transition table. 
+        int         fLength;        //  Total length in bytes of this RBBI Data,
+                                       //      including all sections, not just the header.
+        int         fCatCount;      //  Number of character categories.
+
+        //
+        //  Offsets and sizes of each of the subsections within the RBBI data.
+        //  All offsets are bytes from the start of the RBBIDataHeader.
+        //  All sizes are in bytes.
+        //
+        int         fFTable;         //  forward state transition table.
         int         fFTableLen;
-        int         fRTable;         //  Offset to the reverse state transition table. 
+        int         fRTable;         //  Offset to the reverse state transition table.
         int         fRTableLen;
-        int         fSFTable;        //  safe point forward transition table 
+        int         fSFTable;        //  safe point forward transition table
         int         fSFTableLen;
-        int         fSRTable;        //  safe point reverse transition table 
+        int         fSRTable;        //  safe point reverse transition table
         int         fSRTableLen;
-        int         fTrie;           //  Offset to Trie data for character categories 
+        int         fTrie;           //  Offset to Trie data for character categories
         int         fTrieLen;
-        int         fRuleSource;     //  Offset to the source for for the break 
-        int         fRuleSourceLen;  //    rules.  Stored UChar *. 
-        int         fStatusTable;    // Offset to the table of rule status values 
+        int         fRuleSource;     //  Offset to the source for for the break
+        int         fRuleSourceLen;  //    rules.  Stored UChar *.
+        int         fStatusTable;    // Offset to the table of rule status values
         int         fStatusTableLen;
 
         public RBBIDataHeader() {
@@ -133,18 +136,19 @@ final class RBBIDataWrapper {
             fFormatVersion = new byte[4];
         }
     }
-    
-    
+
+
     /**
      * RBBI State Table Indexing Function.  Given a state number, return the
      * array index of the start of the state table row for that state.
-     * 
+     *
      */
     int getRowIndex(int state){
         return ROW_DATA + state * (fHeader.fCatCount + 4);
     }
-    
+
     static class TrieFoldingFunc implements  Trie.DataManipulate {
+        @Override
         public int getFoldingOffset(int data) {
             if ((data & 0x8000) != 0) {
                 return data & 0x7fff;
@@ -154,8 +158,8 @@ final class RBBIDataWrapper {
         }
     }
     static TrieFoldingFunc  fTrieFoldingFunc = new TrieFoldingFunc();
- 
-    
+
+
     RBBIDataWrapper() {
     }
 
@@ -315,7 +319,7 @@ final class RBBIDataWrapper {
                 bytes, This.fHeader.fRuleSourceLen / 2, This.fHeader.fRuleSourceLen & 1);
 
         if (RuleBasedBreakIterator.fDebugEnv!=null && RuleBasedBreakIterator.fDebugEnv.indexOf("data")>=0) {
-            This.dump();
+            This.dump(System.out);
         }
         return This;
     }
@@ -339,35 +343,35 @@ final class RBBIDataWrapper {
 
     ///CLOVER:OFF
     /* Debug function to display the break iterator data. */
-    void dump() {
+    void dump(java.io.PrintStream out) {
         if (fFTable.length == 0) {
             // There is no table. Fail early for testing purposes.
             throw new NullPointerException();
         }
-        System.out.println("RBBI Data Wrapper dump ...");
-        System.out.println();
-        System.out.println("Forward State Table");
-        dumpTable(fFTable);
-        System.out.println("Reverse State Table");
-        dumpTable(fRTable);
-        System.out.println("Forward Safe Points Table");
-        dumpTable(fSFTable);
-        System.out.println("Reverse Safe Points Table");
-        dumpTable(fSRTable);
-        
-        dumpCharCategories();
-        System.out.println("Source Rules: " + fRuleSource);
-        
+        out.println("RBBI Data Wrapper dump ...");
+        out.println();
+        out.println("Forward State Table");
+        dumpTable(out, fFTable);
+        out.println("Reverse State Table");
+        dumpTable(out, fRTable);
+        out.println("Forward Safe Points Table");
+        dumpTable(out, fSFTable);
+        out.println("Reverse Safe Points Table");
+        dumpTable(out, fSRTable);
+
+        dumpCharCategories(out);
+        out.println("Source Rules: " + fRuleSource);
+
     }
     ///CLOVER:ON
 
     ///CLOVER:OFF
     /* Fixed width int-to-string conversion. */
     static public String intToString(int n, int width) {
-        StringBuilder  dest = new StringBuilder(width);   
+        StringBuilder  dest = new StringBuilder(width);
         dest.append(n);
         while (dest.length() < width) {
-           dest.insert(0, ' ');   
+           dest.insert(0, ' ');
         }
         return dest.toString();
     }
@@ -376,10 +380,10 @@ final class RBBIDataWrapper {
     ///CLOVER:OFF
     /* Fixed width int-to-string conversion. */
     static public String intToHexString(int n, int width) {
-        StringBuilder  dest = new StringBuilder(width);   
+        StringBuilder  dest = new StringBuilder(width);
         dest.append(Integer.toHexString(n));
         while (dest.length() < width) {
-           dest.insert(0, ' ');   
+           dest.insert(0, ' ');
         }
         return dest.toString();
     }
@@ -387,9 +391,9 @@ final class RBBIDataWrapper {
 
     ///CLOVER:OFF
     /** Dump a state table.  (A full set of RBBI rules has 4 state tables.)  */
-    private void dumpTable(short table[]) {
+    private void dumpTable(java.io.PrintStream out, short table[]) {
         if (table == null)   {
-            System.out.println("  -- null -- ");
+            out.println("  -- null -- ");
         } else {
             int n;
             int state;
@@ -397,15 +401,15 @@ final class RBBIDataWrapper {
             for (n=0; n<fHeader.fCatCount; n++) {
                 header.append(intToString(n, 5));
             }
-            System.out.println(header.toString());
+            out.println(header.toString());
             for (n=0; n<header.length(); n++) {
-                System.out.print("-");
+                out.print("-");
             }
-            System.out.println();
+            out.println();
             for (state=0; state< getStateTableNumStates(table); state++) {
-                dumpRow(table, state);   
+                dumpRow(out, table, state);
             }
-            System.out.println();
+            out.println();
         }
     }
     ///CLOVER:ON
@@ -416,32 +420,32 @@ final class RBBIDataWrapper {
      * @param table
      * @param state
      */
-    private void dumpRow(short table[], int   state) {
+    private void dumpRow(java.io.PrintStream out, short table[], int   state) {
         StringBuilder dest = new StringBuilder(fHeader.fCatCount*5 + 20);
         dest.append(intToString(state, 4));
         int row = getRowIndex(state);
         if (table[row+ACCEPTING] != 0) {
-           dest.append(intToString(table[row+ACCEPTING], 5)); 
+           dest.append(intToString(table[row+ACCEPTING], 5));
         }else {
             dest.append("     ");
         }
         if (table[row+LOOKAHEAD] != 0) {
-            dest.append(intToString(table[row+LOOKAHEAD], 5)); 
+            dest.append(intToString(table[row+LOOKAHEAD], 5));
         }else {
             dest.append("     ");
         }
-        dest.append(intToString(table[row+TAGIDX], 5)); 
-        
+        dest.append(intToString(table[row+TAGIDX], 5));
+
         for (int col=0; col<fHeader.fCatCount; col++) {
-            dest.append(intToString(table[row+NEXTSTATES+col], 5));   
+            dest.append(intToString(table[row+NEXTSTATES+col], 5));
         }
 
-        System.out.println(dest);
+        out.println(dest);
     }
     ///CLOVER:ON
 
     ///CLOVER:OFF
-    private void dumpCharCategories() {
+    private void dumpCharCategories(java.io.PrintStream out) {
         int n = fHeader.fCatCount;
         String   catStrings[] = new  String[n+1];
         int      rangeStart = 0;
@@ -450,32 +454,32 @@ final class RBBIDataWrapper {
         int      char32;
         int      category;
         int      lastNewline[] = new int[n+1];
-        
+
         for (category = 0; category <= fHeader.fCatCount; category ++) {
-            catStrings[category] = "";   
+            catStrings[category] = "";
         }
-        System.out.println("\nCharacter Categories");
-        System.out.println("--------------------");
+        out.println("\nCharacter Categories");
+        out.println("--------------------");
         for (char32 = 0; char32<=0x10ffff; char32++) {
             category = fTrie.getCodePointValue(char32);
             category &= ~0x4000;            // Mask off dictionary bit.
             if (category < 0 || category > fHeader.fCatCount) {
-                System.out.println("Error, bad category " + Integer.toHexString(category) + 
-                        " for char " + Integer.toHexString(char32)); 
+                out.println("Error, bad category " + Integer.toHexString(category) +
+                        " for char " + Integer.toHexString(char32));
                 break;
             }
             if (category == lastCat ) {
-                rangeEnd = char32;   
+                rangeEnd = char32;
             } else {
                 if (lastCat >= 0) {
                     if (catStrings[lastCat].length() > lastNewline[lastCat] + 70) {
                         lastNewline[lastCat] = catStrings[lastCat].length() + 10;
                         catStrings[lastCat] += "\n       ";
                     }
-                    
+
                     catStrings[lastCat] += " " + Integer.toHexString(rangeStart);
                     if (rangeEnd != rangeStart) {
-                        catStrings[lastCat] += "-" + Integer.toHexString(rangeEnd);   
+                        catStrings[lastCat] += "-" + Integer.toHexString(rangeEnd);
                     }
                 }
                 lastCat = category;
@@ -484,13 +488,13 @@ final class RBBIDataWrapper {
         }
         catStrings[lastCat] += " " + Integer.toHexString(rangeStart);
         if (rangeEnd != rangeStart) {
-            catStrings[lastCat] += "-" + Integer.toHexString(rangeEnd);   
+            catStrings[lastCat] += "-" + Integer.toHexString(rangeEnd);
         }
-        
+
         for (category = 0; category <= fHeader.fCatCount; category ++) {
-            System.out.println (intToString(category, 5) + "  " + catStrings[category]);   
+            out.println (intToString(category, 5) + "  " + catStrings[category]);
         }
-        System.out.println();
+        out.println();
     }
     ///CLOVER:ON
 
@@ -508,9 +512,9 @@ final class RBBIDataWrapper {
             s = args[0];
         }
         System.out.println("RBBIDataWrapper.main(" + s + ") ");
-        
+
         String versionedName = ICUResourceBundle.ICU_BUNDLE+"/"+ s + ".brk";
-        
+
         try {
             RBBIDataWrapper This = RBBIDataWrapper.get(versionedName);
             This.dump();
@@ -518,6 +522,6 @@ final class RBBIDataWrapper {
        catch (Exception e) {
            System.out.println("Exception: " + e.toString());
        }
-           
+
     }*/
 }
diff --git a/app/src/main/java/com/ibm/icu/text/RBBINode.java b/icu4j/src/main/java/com/ibm/icu/text/RBBINode.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/RBBINode.java
rename to icu4j/src/main/java/com/ibm/icu/text/RBBINode.java
index cefbbd0..d355faf 100644
--- a/app/src/main/java/com/ibm/icu/text/RBBINode.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/RBBINode.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /********************************************************************
  * COPYRIGHT:
  * Copyright (c) 2001-2016, International Business Machines Corporation and
@@ -170,8 +172,6 @@ class RBBINode {
                 n.fRightChild.fParent = n;
             }
         }
-        n.fRuleRoot = this.fRuleRoot;
-        n.fChainIn  = this.fChainIn;
         return n;
     }
 
@@ -197,8 +197,9 @@ class RBBINode {
     //-------------------------------------------------------------------------
     RBBINode flattenVariables() {
         if (fType == varRef) {
-            RBBINode retNode = fLeftChild.cloneTree();
-            // delete this;
+            RBBINode retNode  = fLeftChild.cloneTree();
+            retNode.fRuleRoot = this.fRuleRoot;
+            retNode.fChainIn  = this.fChainIn;
             return retNode;
         }
 
diff --git a/app/src/main/java/com/ibm/icu/text/RBBIRuleBuilder.java b/icu4j/src/main/java/com/ibm/icu/text/RBBIRuleBuilder.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/RBBIRuleBuilder.java
rename to icu4j/src/main/java/com/ibm/icu/text/RBBIRuleBuilder.java
index 20846fc..c56c0fa 100644
--- a/app/src/main/java/com/ibm/icu/text/RBBIRuleBuilder.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/RBBIRuleBuilder.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 //
 //    Copyright (C) 2002-2014, International Business Machines Corporation and others.
 //    All Rights Reserved.
diff --git a/app/src/main/java/com/ibm/icu/text/RBBIRuleParseTable.java b/icu4j/src/main/java/com/ibm/icu/text/RBBIRuleParseTable.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/RBBIRuleParseTable.java
rename to icu4j/src/main/java/com/ibm/icu/text/RBBIRuleParseTable.java
index 53cd225..f3869ea 100644
--- a/app/src/main/java/com/ibm/icu/text/RBBIRuleParseTable.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/RBBIRuleParseTable.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (c) 2003-2016, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/text/RBBIRuleScanner.java b/icu4j/src/main/java/com/ibm/icu/text/RBBIRuleScanner.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/RBBIRuleScanner.java
rename to icu4j/src/main/java/com/ibm/icu/text/RBBIRuleScanner.java
index a62b0d9..e16927c 100644
--- a/app/src/main/java/com/ibm/icu/text/RBBIRuleScanner.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/RBBIRuleScanner.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2003-2016, International Business Machines Corporation and others. All Rights Reserved.
@@ -46,8 +48,6 @@ class RBBIRuleScanner {
 
     RBBIRuleChar              fC = new RBBIRuleChar();    // Current char for parse state machine
                                                      //   processing.
-    String                    fVarName;          // $variableName, valid when we've just
-                                                     //   scanned one.
 
 
     short  fStack[] = new short[kStackSize];  // State stack, holds state pushes
@@ -119,7 +119,7 @@ class RBBIRuleScanner {
         fRuleSets[RBBIRuleParseTable.kRuleSet_name_start_char - 128] = new UnicodeSet(gRuleSet_name_start_char_pattern);
         fRuleSets[RBBIRuleParseTable.kRuleSet_digit_char - 128] = new UnicodeSet(gRuleSet_digit_char_pattern);
 
-        fSymbolTable = new RBBISymbolTable(this, rb.fRules);
+        fSymbolTable = new RBBISymbolTable(this);
     }
 
     //----------------------------------------------------------------------------------------
@@ -957,6 +957,12 @@ class RBBIRuleScanner {
             }
 
         }
+        
+        // If there are no forward rules throw an error.
+        //
+        if (fRB.fTreeRoots[RBBIRuleBuilder.fForwardTree] == null) {
+            error(RBBIRuleBuilder.U_BRK_RULE_SYNTAX);
+        }
 
         //
         // If there were NO user specified reverse rules, set up the equivalent of ".*;"
diff --git a/app/src/main/java/com/ibm/icu/text/RBBISetBuilder.java b/icu4j/src/main/java/com/ibm/icu/text/RBBISetBuilder.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/RBBISetBuilder.java
rename to icu4j/src/main/java/com/ibm/icu/text/RBBISetBuilder.java
index 68b92c6..b48fb68 100644
--- a/app/src/main/java/com/ibm/icu/text/RBBISetBuilder.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/RBBISetBuilder.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 * Copyright (C) 2003-2011, International Business Machines Corporation and    *
@@ -122,7 +124,7 @@ class RBBISetBuilder {
     RangeDescriptor       fRangeList;      // Head of the linked list of RangeDescriptors
 
     IntTrieBuilder        fTrie;           // The mapping TRIE that is the end result of processing
-    int                  fTrieSize;        //  the Unicode Sets.
+                                           //  the Unicode Sets.
 
     // Groups correspond to character categories -
     //       groups of ranges that are in the same original UnicodeSets.
diff --git a/app/src/main/java/com/ibm/icu/text/RBBISymbolTable.java b/icu4j/src/main/java/com/ibm/icu/text/RBBISymbolTable.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/text/RBBISymbolTable.java
rename to icu4j/src/main/java/com/ibm/icu/text/RBBISymbolTable.java
index 6564945..d9c931b 100644
--- a/app/src/main/java/com/ibm/icu/text/RBBISymbolTable.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/RBBISymbolTable.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ***************************************************************************
 *   Copyright (C) 2002-2009 International Business Machines Corporation   *
@@ -13,7 +15,6 @@ import com.ibm.icu.lang.UCharacter;
 
 class RBBISymbolTable implements SymbolTable{
     
-    String               fRules;
     HashMap<String, RBBISymbolTableEntry> fHashTable;
     RBBIRuleScanner      fRuleScanner;
 
@@ -31,8 +32,7 @@ class RBBISymbolTable implements SymbolTable{
     }
 
     
-    RBBISymbolTable(RBBIRuleScanner rs, String rules) {
-        fRules = rules;
+    RBBISymbolTable(RBBIRuleScanner rs) {
         fRuleScanner = rs;
         fHashTable = new HashMap<String, RBBISymbolTableEntry>();
         ffffString = "\uffff";
diff --git a/app/src/main/java/com/ibm/icu/text/RBBITableBuilder.java b/icu4j/src/main/java/com/ibm/icu/text/RBBITableBuilder.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/RBBITableBuilder.java
rename to icu4j/src/main/java/com/ibm/icu/text/RBBITableBuilder.java
index 2140d5e..36d3c4b 100644
--- a/app/src/main/java/com/ibm/icu/text/RBBITableBuilder.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/RBBITableBuilder.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 **********************************************************************
 *   Copyright (c) 2002-2016, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/text/RBNFChinesePostProcessor.java b/icu4j/src/main/java/com/ibm/icu/text/RBNFChinesePostProcessor.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/text/RBNFChinesePostProcessor.java
rename to icu4j/src/main/java/com/ibm/icu/text/RBNFChinesePostProcessor.java
index b201c61..3bfa013 100644
--- a/app/src/main/java/com/ibm/icu/text/RBNFChinesePostProcessor.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/RBNFChinesePostProcessor.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2004-2009, International Business Machines Corporation and    *
@@ -30,7 +32,7 @@ final class RBNFChinesePostProcessor implements RBNFPostProcessor {
      * Work routine.  Post process the output, which was generated by the
      * ruleset with the given name.
      */
-    public void process(StringBuffer buf, NFRuleSet ruleSet) {
+    public void process(StringBuilder buf, NFRuleSet ruleSet) {
         // markers depend on what rule set we are using
 
         // Commented by johnvu on the if statement since lastRuleSet is never initialized
diff --git a/app/src/main/java/com/ibm/icu/text/RBNFPostProcessor.java b/icu4j/src/main/java/com/ibm/icu/text/RBNFPostProcessor.java
similarity index 85%
rename from app/src/main/java/com/ibm/icu/text/RBNFPostProcessor.java
rename to icu4j/src/main/java/com/ibm/icu/text/RBNFPostProcessor.java
index 3d3470d..a8970da 100644
--- a/app/src/main/java/com/ibm/icu/text/RBNFPostProcessor.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/RBNFPostProcessor.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2004-2010, International Business Machines Corporation and    *
@@ -25,5 +27,5 @@ interface RBNFPostProcessor {
      * @param output the output of the main RBNF processing
      * @param ruleSet the rule set originally invoked to generate the output
      */
-    void process(StringBuffer output, NFRuleSet ruleSet);
+    void process(StringBuilder output, NFRuleSet ruleSet);
 }
diff --git a/app/src/main/java/com/ibm/icu/text/RawCollationKey.java b/icu4j/src/main/java/com/ibm/icu/text/RawCollationKey.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/text/RawCollationKey.java
rename to icu4j/src/main/java/com/ibm/icu/text/RawCollationKey.java
index 1187220..e1db856 100644
--- a/app/src/main/java/com/ibm/icu/text/RawCollationKey.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/RawCollationKey.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/RbnfLenientScanner.java b/icu4j/src/main/java/com/ibm/icu/text/RbnfLenientScanner.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/text/RbnfLenientScanner.java
rename to icu4j/src/main/java/com/ibm/icu/text/RbnfLenientScanner.java
index 3af53ce..af91b51 100644
--- a/app/src/main/java/com/ibm/icu/text/RbnfLenientScanner.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/RbnfLenientScanner.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2014, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/RbnfLenientScannerProvider.java b/icu4j/src/main/java/com/ibm/icu/text/RbnfLenientScannerProvider.java
similarity index 88%
rename from app/src/main/java/com/ibm/icu/text/RbnfLenientScannerProvider.java
rename to icu4j/src/main/java/com/ibm/icu/text/RbnfLenientScannerProvider.java
index 3d23f90..ef334da 100644
--- a/app/src/main/java/com/ibm/icu/text/RbnfLenientScannerProvider.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/RbnfLenientScannerProvider.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2014, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/RelativeDateTimeFormatter.java b/icu4j/src/main/java/com/ibm/icu/text/RelativeDateTimeFormatter.java
similarity index 82%
rename from app/src/main/java/com/ibm/icu/text/RelativeDateTimeFormatter.java
rename to icu4j/src/main/java/com/ibm/icu/text/RelativeDateTimeFormatter.java
index 5e1d3b9..73ec070 100644
--- a/app/src/main/java/com/ibm/icu/text/RelativeDateTimeFormatter.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/RelativeDateTimeFormatter.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2013-2016, International Business Machines Corporation and
@@ -9,12 +11,12 @@ package com.ibm.icu.text;
 import java.util.EnumMap;
 import java.util.Locale;
 
-import com.ibm.icu.impl.CalendarData;
+import com.ibm.icu.impl.CacheBase;
 import com.ibm.icu.impl.DontCareFieldPosition;
-import com.ibm.icu.impl.ICUCache;
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
-import com.ibm.icu.impl.SimpleCache;
 import com.ibm.icu.impl.SimpleFormatterImpl;
+import com.ibm.icu.impl.SoftCache;
 import com.ibm.icu.impl.StandardPlural;
 import com.ibm.icu.impl.UResource;
 import com.ibm.icu.lang.UCharacter;
@@ -863,17 +865,17 @@ public final class RelativeDateTimeFormatter {
     }
 
     private static class Cache {
-        private final ICUCache<String, RelativeDateTimeFormatterData> cache =
-            new SimpleCache<String, RelativeDateTimeFormatterData>();
+        private final CacheBase<String, RelativeDateTimeFormatterData, ULocale> cache =
+            new SoftCache<String, RelativeDateTimeFormatterData, ULocale>() {
+                @Override
+                protected RelativeDateTimeFormatterData createInstance(String key, ULocale locale) {
+                    return new Loader(locale).load();
+                }
+            };
 
         public RelativeDateTimeFormatterData get(ULocale locale) {
             String key = locale.toString();
-            RelativeDateTimeFormatterData result = cache.get(key);
-            if (result == null) {
-                result = new Loader(locale).load();
-                cache.put(key, result);
-            }
-            return result;
+            return cache.getInstance(key, locale);
         }
     }
 
@@ -898,18 +900,14 @@ public final class RelativeDateTimeFormatter {
 
     /**
      * Sink for enumerating all of the relative data time formatter names.
-     * Contains inner sink classes, each one corresponding to a type of resource table.
-     * The outer sink handles the top-level 'fields'.
      *
      * More specific bundles (en_GB) are enumerated before their parents (en_001, en, root):
      * Only store a value if it is still missing, that is, it has not been overridden.
-     *
-     * C++: Each inner sink class has a reference to the main outer sink.
-     * Java: Use non-static inner classes instead.
      */
-    private static final class RelDateTimeFmtDataSink extends UResource.TableSink {
+    private static final class RelDateTimeDataSink extends UResource.Sink {
+
         // For white list of units to handle in RelativeDateTimeFormatter.
-        private static enum DateTimeUnit {
+        private enum DateTimeUnit {
             SECOND(RelativeUnit.SECONDS, null),
             MINUTE(RelativeUnit.MINUTES, null),
             HOUR(RelativeUnit.HOURS, null),
@@ -994,14 +992,8 @@ public final class RelativeDateTimeFormatter {
         EnumMap<Style, EnumMap<RelativeUnit, String[][]>> styleRelUnitPatterns =
                 new EnumMap<Style, EnumMap<RelativeUnit, String[][]>>(Style.class);
 
-        private ULocale ulocale = null;
-
         StringBuilder sb = new StringBuilder();
 
-        public RelDateTimeFmtDataSink(ULocale locale) {
-            ulocale = locale;
-        }
-
         // Values keep between levels of parsing the CLDR data.
         int pastFutureIndex;
         Style style;                        // {LONG, SHORT, NARROW} Derived from unit key string.
@@ -1036,11 +1028,139 @@ public final class RelativeDateTimeFormatter {
             }
         }
 
-        @Override
-        public void put(UResource.Key key, UResource.Value value) {
-            // Parse and store aliases.
-            if (value.getType() != ICUResourceBundle.ALIAS) { return; }
+        public void consumeTableRelative(UResource.Key key, UResource.Value value) {
+            UResource.Table unitTypesTable = value.getTable();
+            for (int i = 0; unitTypesTable.getKeyAndValue(i, key, value); i++) {
+                if (value.getType() == ICUResourceBundle.STRING) {
+                    String valueString = value.getString();
+
+                    EnumMap<AbsoluteUnit, EnumMap<Direction, String>> absMap = qualitativeUnitMap.get(style);
+
+                    if (unit.relUnit == RelativeUnit.SECONDS) {
+                        if (key.contentEquals("0")) {
+                            // Handle Zero seconds for "now".
+                            EnumMap<Direction, String> unitStrings = absMap.get(AbsoluteUnit.NOW);
+                            if (unitStrings == null) {
+                                unitStrings = new EnumMap<Direction, String>(Direction.class);
+                                absMap.put(AbsoluteUnit.NOW, unitStrings);
+                            }
+                            if (unitStrings.get(Direction.PLAIN) == null) {
+                                unitStrings.put(Direction.PLAIN, valueString);
+                            }
+                            continue;
+                        }
+                    }
+                    Direction keyDirection = keyToDirection(key);
+                    if (keyDirection == null) {
+                        continue;
+                    }
+                    AbsoluteUnit absUnit = unit.absUnit;
+                    if (absUnit == null) {
+                        continue;
+                    }
 
+                    if (absMap == null) {
+                        absMap = new EnumMap<AbsoluteUnit, EnumMap<Direction, String>>(AbsoluteUnit.class);
+                        qualitativeUnitMap.put(style, absMap);
+                    }
+                    EnumMap<Direction, String> dirMap = absMap.get(absUnit);
+                    if (dirMap == null) {
+                        dirMap = new EnumMap<Direction, String>(Direction.class);
+                        absMap.put(absUnit, dirMap);
+                    }
+                    if (dirMap.get(keyDirection) == null) {
+                        // Do not override values already entered.
+                        dirMap.put(keyDirection, value.getString());
+                    }
+                }
+            }
+        }
+
+        // Record past or future and
+        public void consumeTableRelativeTime(UResource.Key key, UResource.Value value) {
+            if (unit.relUnit == null) {
+                return;
+            }
+            UResource.Table unitTypesTable = value.getTable();
+            for (int i = 0; unitTypesTable.getKeyAndValue(i, key, value); i++) {
+                if (key.contentEquals("past")) {
+                    pastFutureIndex = 0;
+                } else if (key.contentEquals("future")) {
+                    pastFutureIndex = 1;
+                } else {
+                    continue;
+                }
+                // Get the details of the relative time.
+                consumeTimeDetail(key, value);
+            }
+        }
+
+        public void consumeTimeDetail(UResource.Key key, UResource.Value value) {
+            UResource.Table unitTypesTable = value.getTable();
+
+            EnumMap<RelativeUnit, String[][]> unitPatterns  = styleRelUnitPatterns.get(style);
+            if (unitPatterns == null) {
+                unitPatterns = new EnumMap<RelativeUnit, String[][]>(RelativeUnit.class);
+                styleRelUnitPatterns.put(style, unitPatterns);
+            }
+            String[][] patterns = unitPatterns.get(unit.relUnit);
+            if (patterns == null) {
+                patterns = new String[2][StandardPlural.COUNT];
+                unitPatterns.put(unit.relUnit, patterns);
+            }
+
+            // Stuff the pattern for the correct plural index with a simple formatter.
+            for (int i = 0; unitTypesTable.getKeyAndValue(i, key, value); i++) {
+                if (value.getType() == ICUResourceBundle.STRING) {
+                    int pluralIndex = StandardPlural.indexFromString(key.toString());
+                    if (patterns[pastFutureIndex][pluralIndex] == null) {
+                        patterns[pastFutureIndex][pluralIndex] =
+                                SimpleFormatterImpl.compileToStringMinMaxArguments(
+                                        value.getString(), sb, 0, 1);
+                    }
+                }
+            }
+        }
+
+        private void handlePlainDirection(UResource.Key key, UResource.Value value) {
+            AbsoluteUnit absUnit = unit.absUnit;
+            if (absUnit == null) {
+                return;  // Not interesting.
+            }
+            EnumMap<AbsoluteUnit, EnumMap<Direction, String>> unitMap =
+                    qualitativeUnitMap.get(style);
+            if (unitMap == null) {
+                unitMap = new EnumMap<AbsoluteUnit, EnumMap<Direction, String>>(AbsoluteUnit.class);
+                qualitativeUnitMap.put(style, unitMap);
+            }
+            EnumMap<Direction,String> dirMap = unitMap.get(absUnit);
+            if (dirMap == null) {
+                dirMap = new EnumMap<Direction,String>(Direction.class);
+                unitMap.put(absUnit, dirMap);
+            }
+            if (dirMap.get(Direction.PLAIN) == null) {
+                dirMap.put(Direction.PLAIN, value.toString());
+            }
+        }
+
+        // Handle at the Unit level,
+        public void consumeTimeUnit(UResource.Key key, UResource.Value value) {
+            UResource.Table unitTypesTable = value.getTable();
+            for (int i = 0; unitTypesTable.getKeyAndValue(i, key, value); i++) {
+                if (key.contentEquals("dn") && value.getType() == ICUResourceBundle.STRING) {
+                    handlePlainDirection(key, value);
+                }
+                if (value.getType() == ICUResourceBundle.TABLE) {
+                    if (key.contentEquals("relative")) {
+                        consumeTableRelative(key, value);
+                    } else if (key.contentEquals("relativeTime")) {
+                        consumeTableRelativeTime(key, value);
+                    }
+                }
+            }
+        }
+
+        private void handleAlias(UResource.Key key, UResource.Value value, boolean noFallback) {
             Style sourceStyle = styleFromKey(key);
             int limit = key.length() - styleSuffixLength(sourceStyle);
             DateTimeUnit unit = DateTimeUnit.orNullFromString(key.substring(0, limit));
@@ -1059,165 +1179,37 @@ public final class RelativeDateTimeFormatter {
                     throw new ICUException(
                             "Inconsistent style fallback for style " + sourceStyle + " to " + targetStyle);
                 }
+                return;
             }
         }
 
         @Override
-        public UResource.TableSink getOrCreateTableSink(UResource.Key key, int initialSize) {
-            // Get base unit and style from the key value.
-            style = styleFromKey(key);
-            int limit = key.length() - styleSuffixLength(style);
-            String unitString = key.substring(0, limit);
-
-            // Process only if unitString is in the white list.
-            unit = DateTimeUnit.orNullFromString(unitString);
-            if (unit == null) {
-                return null;
+        public void put(UResource.Key key, UResource.Value value, boolean noFallback) {
+            // Main entry point to sink
+            if (value.getType() == ICUResourceBundle.ALIAS) {
+                return;
             }
-            return unitSink;  // Continue parsing this path.
-        }
 
-        // Sinks for additional levels under /fields/*/relative/ and /fields/*/relativeTime/
-
-        // Sets values under relativeTime paths, e.g., "hour/relativeTime/future/one"
-        class RelativeTimeDetailSink extends UResource.TableSink {
-            @Override
-            public void put(UResource.Key key, UResource.Value value) {
-                /* Make two lists of simplePatternFmtList, one for past and one for future.
-                 *  Set a SimpleFormatter pattern for the <style, relative unit, plurality>
-                 *
-                 * Fill in values for the particular plural given, e.g., ONE, FEW, OTHER, etc.
-                 */
-                EnumMap<RelativeUnit, String[][]> unitPatterns  =
-                        styleRelUnitPatterns.get(style);
-                if (unitPatterns == null) {
-                    unitPatterns = new EnumMap<RelativeUnit, String[][]>(RelativeUnit.class);
-                    styleRelUnitPatterns.put(style, unitPatterns);
-                }
-                String[][] patterns = unitPatterns.get(unit.relUnit);
-                if (patterns == null) {
-                    patterns = new String[2][StandardPlural.COUNT];
-                    unitPatterns.put(unit.relUnit, patterns);
-                }
-                int pluralIndex = StandardPlural.indexFromString(key.toString());
-                if (patterns[pastFutureIndex][pluralIndex] == null) {
-                    patterns[pastFutureIndex][pluralIndex] =
-                            SimpleFormatterImpl.compileToStringMinMaxArguments(
-                                    value.getString(), sb, 0, 1);
-                }
-            }
-        }
-        RelativeTimeDetailSink relativeTimeDetailSink = new RelativeTimeDetailSink();
-
-        // Handles "relativeTime" entries, e.g., under "day", "hour", "minute", "minute-short", etc.
-        class RelativeTimeSink extends UResource.TableSink {
-            @Override
-            public UResource.TableSink getOrCreateTableSink(UResource.Key key, int initialSize) {
-                if (key.contentEquals("past")) {
-                    pastFutureIndex = 0;
-                } else if (key.contentEquals("future")) {
-                    pastFutureIndex = 1;
+            UResource.Table table = value.getTable();
+            // Process each key / value in this table.
+            for (int i = 0; table.getKeyAndValue(i, key, value); i++) {
+                if (value.getType() == ICUResourceBundle.ALIAS) {
+                    handleAlias(key, value, noFallback);
                 } else {
-                    return null;
-                }
-                if (unit.relUnit == null) {
-                    return null;
-                }
-                return relativeTimeDetailSink;
-            }
-        }
-        RelativeTimeSink relativeTimeSink = new RelativeTimeSink();
-
-        // Handles "relative" entries, e.g., under "day", "day-short", "fri", "fri-narrow", "fri-short", etc.
-        class RelativeSink extends UResource.TableSink {
-            @Override
-            public void put(UResource.Key key, UResource.Value value) {
-
-                EnumMap<AbsoluteUnit, EnumMap<Direction, String>> absMap = qualitativeUnitMap.get(style);
-
-                if (unit.relUnit == RelativeUnit.SECONDS) {
-                    if (key.contentEquals("0")) {
-                        // Handle Zero seconds for "now".
-                        EnumMap<Direction, String> unitStrings = absMap.get(AbsoluteUnit.NOW);
-                        if (unitStrings == null) {
-                            unitStrings = new EnumMap<Direction, String>(Direction.class);
-                            absMap.put(AbsoluteUnit.NOW, unitStrings);
-                        }
-                        if (unitStrings.get(Direction.PLAIN) == null) {
-                            unitStrings.put(Direction.PLAIN, value.getString());
-                        }
-                        return;
+                    // Remember style and unit for deeper levels.
+                    style = styleFromKey(key);
+                    int limit = key.length() - styleSuffixLength(style);
+                    unit = DateTimeUnit.orNullFromString(key.substring(0, limit));
+                    if (unit != null) {
+                        // Process only if unitString is in the white list.
+                        consumeTimeUnit(key, value);
                     }
                 }
-                Direction keyDirection = keyToDirection(key);
-                if (keyDirection == null) {
-                    return;
-                }
-                AbsoluteUnit absUnit = unit.absUnit;
-                if (absUnit == null) {
-                    return;
-                }
-
-                if (absMap == null) {
-                    absMap = new EnumMap<AbsoluteUnit, EnumMap<Direction, String>>(AbsoluteUnit.class);
-                    qualitativeUnitMap.put(style, absMap);
-                }
-                EnumMap<Direction, String> dirMap = absMap.get(absUnit);
-                if (dirMap == null) {
-                    dirMap = new EnumMap<Direction, String>(Direction.class);
-                    absMap.put(absUnit, dirMap);
-                }
-                if (dirMap.get(keyDirection) == null) {
-                    // Do not override values already entered.
-                    dirMap.put(keyDirection, value.getString());
-                }
             }
         }
-        RelativeSink relativeSink = new RelativeSink();
-
-        // Handles entries under units, recognizing "relative" and "relativeTime" entries.
-        class UnitSink extends UResource.TableSink {
-            @Override
-            public void put(UResource.Key key, UResource.Value value) {
-                if (key.contentEquals("dn")) {
-                    // Handle Display Name for PLAIN direction for some units.
-                    AbsoluteUnit absUnit = unit.absUnit;
-                    if (absUnit == null) {
-                        return;  // Not interesting.
-                    }
-                    EnumMap<AbsoluteUnit, EnumMap<Direction, String>> unitMap =
-                            qualitativeUnitMap.get(style);
-                    if (unitMap == null) {
-                        unitMap = new EnumMap<AbsoluteUnit, EnumMap<Direction, String>>(AbsoluteUnit.class);
-                        qualitativeUnitMap.put(style, unitMap);
-                    }
-                    EnumMap<Direction,String> dirMap = unitMap.get(absUnit);
-                    if (dirMap == null) {
-                        dirMap = new EnumMap<Direction,String>(Direction.class);
-                        unitMap.put(absUnit, dirMap);
-                    }
-                    if (dirMap.get(Direction.PLAIN) == null) {
-                        String displayName = value.toString();
-                        // TODO(Travis Keep): This is a hack to get around CLDR bug 6818.
-                        if (ulocale.getLanguage().equals("en")) {
-                            displayName = displayName.toLowerCase(Locale.ROOT);
-                        }
-                        dirMap.put(Direction.PLAIN, displayName);
-                    }
-                }
-            }
 
-            @Override
-            public UResource.TableSink getOrCreateTableSink(UResource.Key key, int initialSize) {
-                if (key.contentEquals("relative")) {
-                    return relativeSink;
-                } else if (key.contentEquals("relativeTime")) {
-                    return relativeTimeSink;
-                }
-                return null;
-            }
+        RelDateTimeDataSink() {
         }
-        UnitSink unitSink = new UnitSink();
     }
 
     private static class Loader {
@@ -1227,14 +1219,37 @@ public final class RelativeDateTimeFormatter {
             this.ulocale = ulocale;
         }
 
+        private String getDateTimePattern(ICUResourceBundle r) {
+            String calType = r.getStringWithFallback("calendar/default");
+            if (calType == null || calType.equals("")) {
+                calType = "gregorian";
+            }
+            String resourcePath = "calendar/" + calType + "/DateTimePatterns";
+            ICUResourceBundle patternsRb = r.findWithFallback(resourcePath);
+            if (patternsRb == null && calType.equals("gregorian")) {
+                // Try with gregorian.
+                patternsRb = r.findWithFallback("calendar/gregorian/DateTimePatterns");
+            }
+            if (patternsRb == null || patternsRb.getSize() < 9) {
+                // Undefined or too few elements.
+                return "{1} {0}";
+            } else {
+                int elementType = patternsRb.get(8).getType();
+                if (elementType == UResourceBundle.ARRAY) {
+                    return patternsRb.get(8).getString(0);
+                } else {
+                    return patternsRb.getString(8);
+                }
+            }
+        }
+
         public RelativeDateTimeFormatterData load() {
             // Sink for traversing data.
-            RelDateTimeFmtDataSink sink = new RelDateTimeFmtDataSink(ulocale);
-            ICUResourceBundle r = (ICUResourceBundle)UResourceBundle.
-                    getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, ulocale);
+            RelDateTimeDataSink sink = new RelDateTimeDataSink();
 
-            // Use sink mechanism to traverse data structure.
-            r.getAllTableItemsWithFallback("fields", sink);
+            ICUResourceBundle r = (ICUResourceBundle)UResourceBundle.
+                    getBundleInstance(ICUData.ICU_BASE_NAME, ulocale);
+            r.getAllItemsWithFallback("fields", sink);
 
             // Check fallbacks array for loops or too many levels.
             for (Style testStyle : Style.values()) {
@@ -1251,13 +1266,9 @@ public final class RelativeDateTimeFormatter {
                 }
             }
 
-            // TODO: Replace this use of CalendarData.
-            CalendarData calData = new CalendarData(
-                    ulocale, r.getStringWithFallback("calendar/default"));
-
             return new RelativeDateTimeFormatterData(
                     sink.qualitativeUnitMap, sink.styleRelUnitPatterns,
-                    calData.getDateTimePattern());
+                    getDateTimePattern(r));
         }
     }
 
diff --git a/app/src/main/java/com/ibm/icu/text/RemoveTransliterator.java b/icu4j/src/main/java/com/ibm/icu/text/RemoveTransliterator.java
similarity index 92%
rename from app/src/main/java/com/ibm/icu/text/RemoveTransliterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/RemoveTransliterator.java
index c04fd64..e9b38d6 100644
--- a/app/src/main/java/com/ibm/icu/text/RemoveTransliterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/RemoveTransliterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2014, International Business Machines Corporation and    *
@@ -23,6 +25,7 @@ class RemoveTransliterator extends Transliterator {
      */
     static void register() {
         Transliterator.registerFactory(_ID, new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new RemoveTransliterator();
             }
@@ -40,6 +43,7 @@ class RemoveTransliterator extends Transliterator {
     /**
      * Implements {@link Transliterator#handleTransliterate}.
      */
+    @Override
     protected void handleTransliterate(Replaceable text,
                                        Position index, boolean incremental) {
         // Our caller (filteredTransliterate) has already narrowed us
diff --git a/app/src/main/java/com/ibm/icu/text/Replaceable.java b/icu4j/src/main/java/com/ibm/icu/text/Replaceable.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/Replaceable.java
rename to icu4j/src/main/java/com/ibm/icu/text/Replaceable.java
index f386c69..2922680 100644
--- a/app/src/main/java/com/ibm/icu/text/Replaceable.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/Replaceable.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/ReplaceableContextIterator.java b/icu4j/src/main/java/com/ibm/icu/text/ReplaceableContextIterator.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/text/ReplaceableContextIterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/ReplaceableContextIterator.java
index 7056f30..2a2d4d2 100644
--- a/app/src/main/java/com/ibm/icu/text/ReplaceableContextIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/ReplaceableContextIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 *
diff --git a/app/src/main/java/com/ibm/icu/text/ReplaceableString.java b/icu4j/src/main/java/com/ibm/icu/text/ReplaceableString.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/ReplaceableString.java
rename to icu4j/src/main/java/com/ibm/icu/text/ReplaceableString.java
index 35c7f47..cd387a7 100644
--- a/app/src/main/java/com/ibm/icu/text/ReplaceableString.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/ReplaceableString.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/RuleBasedBreakIterator.java b/icu4j/src/main/java/com/ibm/icu/text/RuleBasedBreakIterator.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/RuleBasedBreakIterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/RuleBasedBreakIterator.java
index 7d5f461..51f17bd 100644
--- a/app/src/main/java/com/ibm/icu/text/RuleBasedBreakIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/RuleBasedBreakIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2005-2016 International Business Machines Corporation and
@@ -125,6 +127,7 @@ public class RuleBasedBreakIterator extends BreakIterator {
      * behavior as this one.
      * @stable ICU 2.0
      */
+    @Override
     public Object clone()
     {
         RuleBasedBreakIterator result = (RuleBasedBreakIterator)super.clone();
@@ -139,6 +142,7 @@ public class RuleBasedBreakIterator extends BreakIterator {
      * rules, and iterate over the same text.
      * @stable ICU 2.0
      */
+    @Override
     public boolean equals(Object that) {
         if (that == null) {
             return false;
@@ -173,6 +177,7 @@ public class RuleBasedBreakIterator extends BreakIterator {
      * (In ICU4C, the same function is RuleBasedBreakIterator::getRules())
      * @stable ICU 2.0
      */
+    @Override
     public String toString() {
         String retStr = "";
         if (fRData != null) {
@@ -186,6 +191,7 @@ public class RuleBasedBreakIterator extends BreakIterator {
      * @return A hash code
      * @stable ICU 2.0
      */
+    @Override
     public int hashCode()
     {
         return fRData.fRuleSource.hashCode();
@@ -292,8 +298,11 @@ public class RuleBasedBreakIterator extends BreakIterator {
      * @deprecated This API is ICU internal only.
      */
     @Deprecated
-    public void dump() {
-        this.fRData.dump();
+    public void dump(java.io.PrintStream out) {
+        if (out == null) {
+            out = System.out;
+        }
+        this.fRData.dump(out);
     }
 
     /**
@@ -325,6 +334,7 @@ public class RuleBasedBreakIterator extends BreakIterator {
      * @return The offset of the beginning of the text.
      * @stable ICU 2.0
      */
+    @Override
     public int first() {
         fCachedBreakPositions = null;
         fDictionaryCharCount = 0;
@@ -344,6 +354,7 @@ public class RuleBasedBreakIterator extends BreakIterator {
      * @return The text's past-the-end offset.
      * @stable ICU 2.0
      */
+    @Override
     public int last() {
         fCachedBreakPositions = null;
         fDictionaryCharCount = 0;
@@ -375,6 +386,7 @@ public class RuleBasedBreakIterator extends BreakIterator {
      * the current one.
      * @stable ICU 2.0
      */
+    @Override
     public int next(int n) {
         int result = current();
         while (n > 0) {
@@ -393,6 +405,7 @@ public class RuleBasedBreakIterator extends BreakIterator {
      * @return The position of the first boundary after this one.
      * @stable ICU 2.0
      */
+    @Override
     public int next() {
         // if we have cached break positions and we're still in the range
         // covered by them, just move one step forward in the cache
@@ -582,6 +595,7 @@ public class RuleBasedBreakIterator extends BreakIterator {
      * @return The position of the last boundary position preceding this one.
      * @stable ICU 2.0
      */
+    @Override
     public int previous() {
         int result;
         int startPos;
@@ -680,6 +694,7 @@ public class RuleBasedBreakIterator extends BreakIterator {
      * @return The position of the first break after the current position.
      * @stable ICU 2.0
      */
+    @Override
     public int following(int offset) {
         CharacterIterator text = getText();
 
@@ -794,6 +809,7 @@ public class RuleBasedBreakIterator extends BreakIterator {
      * @return The position of the last boundary before the starting position.
      * @stable ICU 2.0
      */
+    @Override
     public int preceding(int offset) {
         CharacterIterator text = getText();
 
@@ -903,6 +919,7 @@ public class RuleBasedBreakIterator extends BreakIterator {
      * @return True if "offset" is a boundary position.
      * @stable ICU 2.0
      */
+    @Override
     public boolean isBoundary(int offset) {
         checkOffset(offset, fText);
 
@@ -936,6 +953,7 @@ public class RuleBasedBreakIterator extends BreakIterator {
      * @return The current iteration position.
      * @stable ICU 2.0
      */
+    @Override
     public int current() {
         return (fText != null) ? fText.getIndex() : BreakIterator.DONE;
     }
@@ -986,6 +1004,7 @@ public class RuleBasedBreakIterator extends BreakIterator {
      * @provisional This is a draft API and might change in a future release of ICU.
      */
 
+    @Override
     public int  getRuleStatus() {
         makeRuleStatusValid();
         //   Status records have this form:
@@ -1023,6 +1042,7 @@ public class RuleBasedBreakIterator extends BreakIterator {
      * @draft ICU 3.0 (retain)
      * @provisional This is a draft API and might change in a future release of ICU.
      */
+    @Override
     public int getRuleStatusVec(int[] fillInArray) {
         makeRuleStatusValid();
         int numStatusVals = fRData.fStatusTable[fLastRuleStatusIndex];
@@ -1043,6 +1063,7 @@ public class RuleBasedBreakIterator extends BreakIterator {
      * @return An iterator over the text being analyzed.
      * @stable ICU 2.0
      */
+    @Override
     public CharacterIterator getText() {
         return fText;
     }
@@ -1053,6 +1074,7 @@ public class RuleBasedBreakIterator extends BreakIterator {
      * @param newText An iterator over the text to analyze.
      * @stable ICU 2.0
      */
+    @Override
     public void setText(CharacterIterator newText) {
         fText = newText;
         // first() resets the caches
@@ -1306,7 +1328,7 @@ public class RuleBasedBreakIterator extends BreakIterator {
                 // Advance to the next character.
                 // If this is a beginning-of-input loop iteration, don't advance.
                 //    The next iteration will be processing the first real input character.
-                c = (int)text.next();
+                c = text.next();
                 if (c >= UTF16.LEAD_SURROGATE_MIN_VALUE) {
                     c = nextTrail32(text, c);
                 }
diff --git a/app/src/main/java/com/ibm/icu/text/RuleBasedCollator.java b/icu4j/src/main/java/com/ibm/icu/text/RuleBasedCollator.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/RuleBasedCollator.java
rename to icu4j/src/main/java/com/ibm/icu/text/RuleBasedCollator.java
index 20dc48a..4ab1343 100644
--- a/app/src/main/java/com/ibm/icu/text/RuleBasedCollator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/RuleBasedCollator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/text/RuleBasedNumberFormat.java b/icu4j/src/main/java/com/ibm/icu/text/RuleBasedNumberFormat.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/RuleBasedNumberFormat.java
rename to icu4j/src/main/java/com/ibm/icu/text/RuleBasedNumberFormat.java
index d69da43..beeb89c 100644
--- a/app/src/main/java/com/ibm/icu/text/RuleBasedNumberFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/RuleBasedNumberFormat.java
@@ -1,7 +1,9 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 1996-2016, International Business Machines Corporation and    *
- * others. All Rights Reserved.                                                *
+ * Copyright (C) 1996-2016, International Business Machines Corporation and
+ * others. All Rights Reserved.
  *******************************************************************************
  */
 
@@ -17,6 +19,7 @@ import java.util.Map;
 import java.util.MissingResourceException;
 import java.util.Set;
 
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUDebug;
 import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.impl.PatternProps;
@@ -826,7 +829,7 @@ public class RuleBasedNumberFormat extends NumberFormat {
         this.locale = locale;
 
         ICUResourceBundle bundle = (ICUResourceBundle)UResourceBundle.
-            getBundleInstance(ICUResourceBundle.ICU_RBNF_BASE_NAME, locale);
+            getBundleInstance(ICUData.ICU_RBNF_BASE_NAME, locale);
 
         // TODO: determine correct actual/valid locale.  Note ambiguity
         // here -- do actual/valid refer to pattern, DecimalFormatSymbols,
@@ -893,6 +896,7 @@ public class RuleBasedNumberFormat extends NumberFormat {
      * @return A RuleBasedNumberFormat that is equal to this one.
      * @stable ICU 2.0
      */
+    @Override
     public Object clone() {
         return super.clone();
     }
@@ -903,6 +907,7 @@ public class RuleBasedNumberFormat extends NumberFormat {
      * @return true if the two formatters have identical behavior.
      * @stable ICU 2.0
      */
+    @Override
     public boolean equals(Object that) {
         // if the other object isn't a RuleBasedNumberFormat, that's
         // all we need to know
@@ -934,13 +939,14 @@ public class RuleBasedNumberFormat extends NumberFormat {
             return true;
         }
     }
-    
+
     /**
      * Mock implementation of hashCode(). This implementation always returns a constant
      * value. When Java assertion is enabled, this method triggers an assertion failure.
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Override
     @Deprecated
     public int hashCode() {
         return super.hashCode();
@@ -954,6 +960,7 @@ public class RuleBasedNumberFormat extends NumberFormat {
      * the same result.
      * @stable ICU 2.0
      */
+    @Override
     public String toString() {
 
         // accumulate the descriptions of all the rule sets in a
@@ -1175,6 +1182,7 @@ public class RuleBasedNumberFormat extends NumberFormat {
      * @return toAppendTo
      * @stable ICU 2.0
      */
+    @Override
     public StringBuffer format(double number,
                                StringBuffer toAppendTo,
                                FieldPosition ignore) {
@@ -1204,6 +1212,7 @@ public class RuleBasedNumberFormat extends NumberFormat {
      * @return toAppendTo
      * @stable ICU 2.0
      */
+    @Override
     public StringBuffer format(long number,
                                StringBuffer toAppendTo,
                                FieldPosition ignore) {
@@ -1225,6 +1234,7 @@ public class RuleBasedNumberFormat extends NumberFormat {
      * Format a BigInteger.
      * @stable ICU 2.0
      */
+    @Override
     public StringBuffer format(BigInteger number,
                                StringBuffer toAppendTo,
                                FieldPosition pos) {
@@ -1237,22 +1247,34 @@ public class RuleBasedNumberFormat extends NumberFormat {
      * Format a BigDecimal.
      * @stable ICU 2.0
      */
+    @Override
     public StringBuffer format(java.math.BigDecimal number,
                                StringBuffer toAppendTo,
                                FieldPosition pos) {
         return format(new com.ibm.icu.math.BigDecimal(number), toAppendTo, pos);
     }
 
+    private static final com.ibm.icu.math.BigDecimal MAX_VALUE = com.ibm.icu.math.BigDecimal.valueOf(Long.MAX_VALUE);
+    private static final com.ibm.icu.math.BigDecimal MIN_VALUE = com.ibm.icu.math.BigDecimal.valueOf(Long.MIN_VALUE);
+
     /**
      * <strong style="font-family: helvetica; color: red;">NEW</strong>
      * Implement com.ibm.icu.text.NumberFormat:
      * Format a BigDecimal.
      * @stable ICU 2.0
      */
+    @Override
     public StringBuffer format(com.ibm.icu.math.BigDecimal number,
                                StringBuffer toAppendTo,
                                FieldPosition pos) {
-        // TEMPORARY:
+        if (MIN_VALUE.compareTo(number) >= 0 || MAX_VALUE.compareTo(number) <= 0) {
+            // We're outside of our normal range that this framework can handle.
+            // The DecimalFormat will provide more accurate results.
+            return getDecimalFormat().format(number, toAppendTo, pos);
+        }
+        if (number.scale() == 0) {
+            return format(number.longValue(), toAppendTo, pos);
+        }
         return format(number.doubleValue(), toAppendTo, pos);
     }
 
@@ -1272,6 +1294,7 @@ public class RuleBasedNumberFormat extends NumberFormat {
      * @see #setLenientParseMode
      * @stable ICU 2.0
      */
+    @Override
     public Number parse(String text, ParsePosition parsePosition) {
 
         // parsePosition tells us where to start parsing.  We copy the
@@ -1360,7 +1383,7 @@ public class RuleBasedNumberFormat extends NumberFormat {
     }
 
     /**
-     * Sets the provider for the lenient scanner.  If this has not been set, 
+     * Sets the provider for the lenient scanner.  If this has not been set,
      * {@link #setLenientParseMode}
      * has no effect.  This is necessary to decouple collation from format code.
      * @param scannerProvider the provider
@@ -1450,11 +1473,11 @@ public class RuleBasedNumberFormat extends NumberFormat {
         }
         return "";
     }
-    
+
     /**
      * Sets the decimal format symbols used by this formatter. The formatter uses a copy of the
      * provided symbols.
-     * 
+     *
      * @param newSymbols desired DecimalFormatSymbols
      * @see DecimalFormatSymbols
      * @stable ICU 49
@@ -1483,14 +1506,15 @@ public class RuleBasedNumberFormat extends NumberFormat {
 
     /**
      * {@icu} Set a particular DisplayContext value in the formatter,
-     * such as CAPITALIZATION_FOR_STANDALONE. Note: For getContext, see 
+     * such as CAPITALIZATION_FOR_STANDALONE. Note: For getContext, see
      * NumberFormat.
-     * 
-     * @param context The DisplayContext value to set. 
+     *
+     * @param context The DisplayContext value to set.
      * @stable ICU 53
      */
     // Here we override the NumberFormat implementation in order to
-    // lazily initialize relevant items 
+    // lazily initialize relevant items
+    @Override
     public void setContext(DisplayContext context) {
         super.setContext(context);
         if (!capitalizationInfoIsSet &&
@@ -1512,7 +1536,7 @@ public class RuleBasedNumberFormat extends NumberFormat {
      * <code>BigDecimal.ROUND_UNNECESSARY</code>.
      * @see #setRoundingMode
      * @see java.math.BigDecimal
-     * @draft ICU 56
+     * @stable ICU 56
      */
     @Override
     public int getRoundingMode() {
@@ -1528,7 +1552,7 @@ public class RuleBasedNumberFormat extends NumberFormat {
      * @exception IllegalArgumentException if <code>roundingMode</code> is unrecognized.
      * @see #getRoundingMode
      * @see java.math.BigDecimal
-     * @draft ICU 56
+     * @stable ICU 56
      */
     @Override
     public void setRoundingMode(int roundingMode) {
@@ -1840,10 +1864,10 @@ public class RuleBasedNumberFormat extends NumberFormat {
     }
 
     /**
-     * Set capitalizationForListOrMenu, capitalizationForStandAlone 
+     * Set capitalizationForListOrMenu, capitalizationForStandAlone
      */
     private void initCapitalizationContextInfo(ULocale theLocale) {
-        ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, theLocale);
+        ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, theLocale);
         try {
             ICUResourceBundle rdb = rb.getWithFallback("contextTransforms/number-spellout");
             int[] intVector = rdb.getIntVector();
@@ -1927,7 +1951,7 @@ public class RuleBasedNumberFormat extends NumberFormat {
         // be built, and pass it to the rule set (along with an insertion
         // position of 0 and the number being formatted) to the rule set
         // for formatting
-        StringBuffer result = new StringBuffer();
+        StringBuilder result = new StringBuilder();
         if (getRoundingMode() != BigDecimal.ROUND_UNNECESSARY) {
             // We convert to a string because BigDecimal insists on excessive precision.
             number = new BigDecimal(Double.toString(number)).setScale(getMaximumFractionDigits(), roundingMode).doubleValue();
@@ -1956,8 +1980,14 @@ public class RuleBasedNumberFormat extends NumberFormat {
         // be built, and pass it to the rule set (along with an insertion
         // position of 0 and the number being formatted) to the rule set
         // for formatting
-        StringBuffer result = new StringBuffer();
-        ruleSet.format(number, result, 0, 0);
+        StringBuilder result = new StringBuilder();
+        if (number == Long.MIN_VALUE) {
+            // We can't handle this value right now. Provide an accurate default value.
+            result.append(getDecimalFormat().format(Long.MIN_VALUE));
+        }
+        else {
+            ruleSet.format(number, result, 0, 0);
+        }
         postProcess(result, ruleSet);
         return result.toString();
     }
@@ -1965,7 +1995,7 @@ public class RuleBasedNumberFormat extends NumberFormat {
     /**
      * Post-process the rules if we have a post-processor.
      */
-    private void postProcess(StringBuffer result, NFRuleSet ruleSet) {
+    private void postProcess(StringBuilder result, NFRuleSet ruleSet) {
         if (postProcessRules != null) {
             if (postProcessor == null) {
                 int ix = postProcessRules.indexOf(";");
diff --git a/app/src/main/java/com/ibm/icu/text/RuleBasedTransliterator.java b/icu4j/src/main/java/com/ibm/icu/text/RuleBasedTransliterator.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/RuleBasedTransliterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/RuleBasedTransliterator.java
index 21f073a..0c42ff8 100644
--- a/app/src/main/java/com/ibm/icu/text/RuleBasedTransliterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/RuleBasedTransliterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and    *
@@ -274,7 +276,7 @@ import java.util.Map;
 @Deprecated
 public class RuleBasedTransliterator extends Transliterator {
 
-    private Data data;
+    private final Data data;
 
 //    /**
 //     * Constructs a new transliterator from the given rules.
@@ -323,6 +325,7 @@ public class RuleBasedTransliterator extends Transliterator {
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Override
     @Deprecated
     protected void handleTransliterate(Replaceable text,
                                        Position index, boolean incremental) {
@@ -440,6 +443,7 @@ public class RuleBasedTransliterator extends Transliterator {
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Override
     @Deprecated
     public String toRules(boolean escapeUnprintable) {
         return data.ruleSet.toRules(escapeUnprintable);
@@ -460,7 +464,7 @@ public class RuleBasedTransliterator extends Transliterator {
 //    public UnicodeSet getTargetSet() {
 //        return data.ruleSet.getSourceTargetSet(true, unicodeFilter);
 //    }
-    
+
     /**
      * @internal
      * @deprecated This API is ICU internal only.
diff --git a/app/src/main/java/com/ibm/icu/text/SCSU.java b/icu4j/src/main/java/com/ibm/icu/text/SCSU.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/SCSU.java
rename to icu4j/src/main/java/com/ibm/icu/text/SCSU.java
index b12b926..39196fe 100644
--- a/app/src/main/java/com/ibm/icu/text/SCSU.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/SCSU.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2007, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/ScientificNumberFormatter.java b/icu4j/src/main/java/com/ibm/icu/text/ScientificNumberFormatter.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/ScientificNumberFormatter.java
rename to icu4j/src/main/java/com/ibm/icu/text/ScientificNumberFormatter.java
index 51e97c7..527dd7e 100644
--- a/app/src/main/java/com/ibm/icu/text/ScientificNumberFormatter.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/ScientificNumberFormatter.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014-2016, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/text/SearchIterator.java b/icu4j/src/main/java/com/ibm/icu/text/SearchIterator.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/SearchIterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/SearchIterator.java
index 5b7e8d7..2a22b2c 100644
--- a/app/src/main/java/com/ibm/icu/text/SearchIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/SearchIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2015, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/SelectFormat.java b/icu4j/src/main/java/com/ibm/icu/text/SelectFormat.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/SelectFormat.java
rename to icu4j/src/main/java/com/ibm/icu/text/SelectFormat.java
index 37e9eee..3e7c4c7 100644
--- a/app/src/main/java/com/ibm/icu/text/SelectFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/SelectFormat.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2004-2016, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/SimpleDateFormat.java b/icu4j/src/main/java/com/ibm/icu/text/SimpleDateFormat.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/SimpleDateFormat.java
rename to icu4j/src/main/java/com/ibm/icu/text/SimpleDateFormat.java
index bbe9070..b5d6389 100644
--- a/app/src/main/java/com/ibm/icu/text/SimpleDateFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/SimpleDateFormat.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and
@@ -23,10 +25,11 @@ import java.util.Locale;
 import java.util.MissingResourceException;
 import java.util.UUID;
 
-import com.ibm.icu.impl.CalendarData;
 import com.ibm.icu.impl.DateNumberFormat;
 import com.ibm.icu.impl.DayPeriodRules;
 import com.ibm.icu.impl.ICUCache;
+import com.ibm.icu.impl.ICUData;
+import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.impl.PatternProps;
 import com.ibm.icu.impl.SimpleCache;
 import com.ibm.icu.impl.SimpleFormatterImpl;
@@ -41,6 +44,8 @@ import com.ibm.icu.util.TimeZone;
 import com.ibm.icu.util.TimeZoneTransition;
 import com.ibm.icu.util.ULocale;
 import com.ibm.icu.util.ULocale.Category;
+import com.ibm.icu.util.UResourceBundle;
+
 
 
 /**
@@ -1187,17 +1192,30 @@ public class SimpleDateFormat extends DateFormat {
         if (!defaultLocale.equals(cachedDefaultLocale)) {
             cachedDefaultLocale = defaultLocale;
             Calendar cal = Calendar.getInstance(cachedDefaultLocale);
+
             try {
-                CalendarData calData = new CalendarData(cachedDefaultLocale, cal.getType());
-                String[] dateTimePatterns = calData.getDateTimePatterns();
-                int glueIndex = 8;
-                if (dateTimePatterns.length >= 13)
-                {
-                    glueIndex += (SHORT + 1);
+                // Load the calendar data directly.
+                ICUResourceBundle rb = (ICUResourceBundle) UResourceBundle.getBundleInstance(
+                        ICUData.ICU_BASE_NAME, cachedDefaultLocale);
+                String resourcePath = "calendar/" + cal.getType() + "/DateTimePatterns";
+                ICUResourceBundle patternsRb= rb.findWithFallback(resourcePath);
+
+                if (patternsRb == null) {
+                    patternsRb = rb.findWithFallback("calendar/gregorian/DateTimePatterns");
+                }
+                if (patternsRb == null || patternsRb.getSize() < 9) {
+                    cachedDefaultPattern = FALLBACKPATTERN;
+                } else {
+                    int defaultIndex = 8;
+                    if (patternsRb.getSize() >= 13) {
+                        defaultIndex += (SHORT + 1);
+                    }
+                    String basePattern = patternsRb.getString(defaultIndex);
+
+                    cachedDefaultPattern = SimpleFormatterImpl.formatRawPattern(
+                            basePattern, 2, 2,
+                            patternsRb.getString(SHORT), patternsRb.getString(SHORT + 4));
                 }
-                cachedDefaultPattern = SimpleFormatterImpl.formatRawPattern(
-                        dateTimePatterns[glueIndex], 2, 2,
-                        dateTimePatterns[SHORT], dateTimePatterns[SHORT + 4]);
             } catch (MissingResourceException e) {
                 cachedDefaultPattern = FALLBACKPATTERN;
             }
@@ -1277,6 +1295,7 @@ public class SimpleDateFormat extends DateFormat {
      * @stable ICU 53
      */
     // Here we override the DateFormat implementation in order to lazily initialize relevant items
+    @Override
     public void setContext(DisplayContext context) {
         super.setContext(context);
         if (capitalizationBrkIter == null && (context==DisplayContext.CAPITALIZATION_FOR_BEGINNING_OF_SENTENCE ||
@@ -1299,6 +1318,7 @@ public class SimpleDateFormat extends DateFormat {
      * @see DateFormat
      * @stable ICU 2.0
      */
+    @Override
     public StringBuffer format(Calendar cal, StringBuffer toAppendTo,
                                FieldPosition pos) {
         TimeZone backupTZ = null;
@@ -1671,7 +1691,7 @@ public class SimpleDateFormat extends DateFormat {
                     value /= 10;
                 }
                 FieldPosition p = new FieldPosition(-1);
-                numberFormat.format((long) value, buf, p);
+                numberFormat.format(value, buf, p);
                 if (count > 3) {
                     numberFormat.setMinimumIntegerDigits(count - 3);
                     numberFormat.format(0L, buf, p);
@@ -2195,6 +2215,7 @@ public class SimpleDateFormat extends DateFormat {
      *
      * @stable ICU 2.0
      */
+    @Override
     public void setNumberFormat(NumberFormat newNumberFormat) {
         // Override this method to update local zero padding number formatter
         super.setNumberFormat(newNumberFormat);
@@ -2307,6 +2328,7 @@ public class SimpleDateFormat extends DateFormat {
      * @see DateFormat
      * @stable ICU 2.0
      */
+    @Override
     public void parse(String text, Calendar cal, ParsePosition parsePos)
     {
         TimeZone backupTZ = null;
@@ -3809,6 +3831,13 @@ public class SimpleDateFormat extends DateFormat {
 
     /**
      * Return a localized pattern string describing this date format.
+     * <p>
+     * <b>Note:</b> This implementation depends on {@link DateFormatSymbols#getLocalPatternChars()}
+     * to get localized format pattern characters. ICU does not include
+     * localized pattern character data, therefore, unless user sets localized
+     * pattern characters manually, this method returns the same result as
+     * {@link #toPattern()}.
+     *
      * @stable ICU 2.0
      */
     public String toLocalizedPattern() {
@@ -3903,6 +3932,7 @@ public class SimpleDateFormat extends DateFormat {
      * Overrides Cloneable
      * @stable ICU 2.0
      */
+    @Override
     public Object clone() {
         SimpleDateFormat other = (SimpleDateFormat) super.clone();
         other.formatData = (DateFormatSymbols) formatData.clone();
@@ -3919,6 +3949,7 @@ public class SimpleDateFormat extends DateFormat {
      * Generates the hash code for the SimpleDateFormat object
      * @stable ICU 2.0
      */
+    @Override
     public int hashCode()
     {
         return pattern.hashCode();
@@ -3929,6 +3960,7 @@ public class SimpleDateFormat extends DateFormat {
      * Override equals.
      * @stable ICU 2.0
      */
+    @Override
     public boolean equals(Object obj)
     {
         if (!super.equals(obj)) return false; // super does class check
@@ -4009,6 +4041,7 @@ public class SimpleDateFormat extends DateFormat {
      *
      * @stable ICU 3.8
      */
+    @Override
     public AttributedCharacterIterator formatToCharacterIterator(Object obj) {
         Calendar cal = calendar;
         if (obj instanceof Calendar) {
diff --git a/app/src/main/java/com/ibm/icu/text/SimpleFormatter.java b/icu4j/src/main/java/com/ibm/icu/text/SimpleFormatter.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/SimpleFormatter.java
rename to icu4j/src/main/java/com/ibm/icu/text/SimpleFormatter.java
index cfb664d..00e9d06 100644
--- a/app/src/main/java/com/ibm/icu/text/SimpleFormatter.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/SimpleFormatter.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014-2016, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/text/SourceTargetUtility.java b/icu4j/src/main/java/com/ibm/icu/text/SourceTargetUtility.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/text/SourceTargetUtility.java
rename to icu4j/src/main/java/com/ibm/icu/text/SourceTargetUtility.java
index 6c58c06..f4aa52a 100644
--- a/app/src/main/java/com/ibm/icu/text/SourceTargetUtility.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/SourceTargetUtility.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2010-2011, Google, International Business Machines            *
diff --git a/icu4j/src/main/java/com/ibm/icu/text/SpoofChecker.java b/icu4j/src/main/java/com/ibm/icu/text/SpoofChecker.java
new file mode 100644
index 0000000..151c5aa
--- /dev/null
+++ b/icu4j/src/main/java/com/ibm/icu/text/SpoofChecker.java
@@ -0,0 +1,2034 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
+/*
+ ***************************************************************************
+ * Copyright (C) 2008-2016 International Business Machines Corporation
+ * and others. All Rights Reserved.
+ ***************************************************************************
+ *
+ * Unicode Spoof Detection
+ */
+
+package com.ibm.icu.text;
+
+import java.io.IOException;
+import java.io.LineNumberReader;
+import java.io.Reader;
+import java.nio.ByteBuffer;
+import java.text.ParseException;
+import java.util.ArrayList;
+import java.util.Arrays;
+import java.util.BitSet;
+import java.util.Collections;
+import java.util.Comparator;
+import java.util.HashSet;
+import java.util.Hashtable;
+import java.util.LinkedHashSet;
+import java.util.Locale;
+import java.util.MissingResourceException;
+import java.util.Set;
+import java.util.Vector;
+import java.util.regex.Matcher;
+import java.util.regex.Pattern;
+
+import com.ibm.icu.impl.ICUBinary;
+import com.ibm.icu.impl.ICUBinary.Authenticate;
+import com.ibm.icu.impl.Utility;
+import com.ibm.icu.lang.UCharacter;
+import com.ibm.icu.lang.UCharacterCategory;
+import com.ibm.icu.lang.UProperty;
+import com.ibm.icu.lang.UScript;
+import com.ibm.icu.util.ULocale;
+
+/**
+ * <p>
+ * This class, based on <a href="http://unicode.org/reports/tr36">Unicode Technical Report #36</a> and
+ * <a href="http://unicode.org/reports/tr39">Unicode Technical Standard #39</a>, has two main functions:
+ *
+ * <ol>
+ * <li>Checking whether two strings are visually <em>confusable</em> with each other, such as "desordenado" and
+ * "ԁеѕогԁепаԁо".</li>
+ * <li>Checking whether an individual string is likely to be an attempt at confusing the reader (<em>spoof
+ * detection</em>), such as "pаypаl" spelled with Cyrillic 'а' characters.</li>
+ * </ol>
+ *
+ * <p>
+ * Although originally designed as a method for flagging suspicious identifier strings such as URLs,
+ * <code>SpoofChecker</code> has a number of other practical use cases, such as preventing attempts to evade bad-word
+ * content filters.
+ *
+ * <h2>Confusables</h2>
+ *
+ * <p>
+ * The following example shows how to use <code>SpoofChecker</code> to check for confusability between two strings:
+ *
+ * <pre>
+ * <code>
+ * SpoofChecker sc = new SpoofChecker.Builder().setChecks(SpoofChecker.CONFUSABLE).build();
+ * int result = sc.areConfusable("desordenado", "ԁеѕогԁепаԁо");
+ * System.out.println(result != 0);  // true
+ * </code>
+ * </pre>
+ *
+ * <p>
+ * <code>SpoofChecker</code> uses a builder paradigm: options are specified within the context of a lightweight
+ * {@link SpoofChecker.Builder} object, and upon calling {@link SpoofChecker.Builder#build}, expensive data loading
+ * operations are performed, and an immutable <code>SpoofChecker</code> is returned.
+ *
+ * <p>
+ * The first line of the example creates a <code>SpoofChecker</code> object with confusable-checking enabled; the second
+ * line performs the confusability test. For best performance, the instance should be created once (e.g., upon
+ * application startup), and the more efficient {@link SpoofChecker#areConfusable} method can be used at runtime.
+ *
+ * <p>
+ * UTS 39 defines two strings to be <em>confusable</em> if they map to the same skeleton. A <em>skeleton</em> is a
+ * sequence of families of confusable characters, where each family has a single exemplar character.
+ * {@link SpoofChecker#getSkeleton} computes the skeleton for a particular string, so the following snippet is
+ * equivalent to the example above:
+ *
+ * <pre>
+ * <code>
+ * SpoofChecker sc = new SpoofChecker.Builder().setChecks(SpoofChecker.CONFUSABLE).build();
+ * boolean result = sc.getSkeleton("desordenado").equals(sc.getSkeleton("ԁеѕогԁепаԁо"));
+ * System.out.println(result);  // true
+ * </code>
+ * </pre>
+ *
+ * <p>
+ * If you need to check if a string is confusable with any string in a dictionary of many strings, rather than calling
+ * {@link SpoofChecker#areConfusable} many times in a loop, {@link SpoofChecker#getSkeleton} can be used instead, as
+ * shown below:
+ *
+ * <pre>
+ * // Setup:
+ * String[] DICTIONARY = new String[]{ "lorem", "ipsum" }; // example
+ * SpoofChecker sc = new SpoofChecker.Builder().setChecks(SpoofChecker.CONFUSABLE).build();
+ * HashSet&lt;String&gt; skeletons = new HashSet&lt;String&gt;();
+ * for (String word : DICTIONARY) {
+ *   skeletons.add(sc.getSkeleton(word));
+ * }
+ *
+ * // Live Check:
+ * boolean result = skeletons.contains(sc.getSkeleton("1orern"));
+ * System.out.println(result);  // true
+ * </pre>
+ *
+ * <p>
+ * <b>Note:</b> Since the Unicode confusables mapping table is frequently updated, confusable skeletons are <em>not</em>
+ * guaranteed to be the same between ICU releases. We therefore recommend that you always compute confusable skeletons
+ * at runtime and do not rely on creating a permanent, or difficult to update, database of skeletons.
+ *
+ * <h2>Spoof Detection</h2>
+ *
+ * <p>
+ * The following snippet shows a minimal example of using <code>SpoofChecker</code> to perform spoof detection on a
+ * string:
+ *
+ * <pre>
+ * SpoofChecker sc = new SpoofChecker.Builder()
+ *     .setAllowedChars(SpoofChecker.RECOMMENDED.cloneAsThawed().addAll(SpoofChecker.INCLUSION))
+ *     .setRestrictionLevel(SpoofChecker.RestrictionLevel.MODERATELY_RESTRICTIVE)
+ *     .setChecks(SpoofChecker.ALL_CHECKS &~ SpoofChecker.CONFUSABLE)
+ *     .build();
+ * boolean result = sc.failsChecks("pаypаl");  // with Cyrillic 'а' characters
+ * System.out.println(result);  // true
+ * </pre>
+ *
+ * <p>
+ * As in the case for confusability checking, it is good practice to create one <code>SpoofChecker</code> instance at
+ * startup, and call the cheaper {@link SpoofChecker#failsChecks} online. In the second line, we specify the set of
+ * allowed characters to be those with type RECOMMENDED or INCLUSION, according to the recommendation in UTS 39. In the
+ * third line, the CONFUSABLE checks are disabled. It is good practice to disable them if you won't be using the
+ * instance to perform confusability checking.
+ *
+ * <p>
+ * To get more details on why a string failed the checks, use a {@link SpoofChecker.CheckResult}:
+ *
+ * <pre>
+ * <code>
+ * SpoofChecker sc = new SpoofChecker.Builder()
+ *     .setAllowedChars(SpoofChecker.RECOMMENDED.cloneAsThawed().addAll(SpoofChecker.INCLUSION))
+ *     .setRestrictionLevel(SpoofChecker.RestrictionLevel.MODERATELY_RESTRICTIVE)
+ *     .setChecks(SpoofChecker.ALL_CHECKS &~ SpoofChecker.CONFUSABLE)
+ *     .build();
+ * SpoofChecker.CheckResult checkResult = new SpoofChecker.CheckResult();
+ * boolean result = sc.failsChecks("pаypаl", checkResult);
+ * System.out.println(checkResult.checks);  // 16
+ * </code>
+ * </pre>
+ *
+ * <p>
+ * The return value is a bitmask of the checks that failed. In this case, there was one check that failed:
+ * {@link SpoofChecker#RESTRICTION_LEVEL}, corresponding to the fifth bit (16). The possible checks are:
+ *
+ * <ul>
+ * <li><code>RESTRICTION_LEVEL</code>: flags strings that violate the
+ * <a href="http://unicode.org/reports/tr39/#Restriction_Level_Detection">Restriction Level</a> test as specified in UTS
+ * 39; in most cases, this means flagging strings that contain characters from multiple different scripts.</li>
+ * <li><code>INVISIBLE</code>: flags strings that contain invisible characters, such as zero-width spaces, or character
+ * sequences that are likely not to display, such as multiple occurrences of the same non-spacing mark.</li>
+ * <li><code>CHAR_LIMIT</code>: flags strings that contain characters outside of a specified set of acceptable
+ * characters. See {@link SpoofChecker.Builder#setAllowedChars} and {@link SpoofChecker.Builder#setAllowedLocales}.</li>
+ * <li><code>MIXED_NUMBERS</code>: flags strings that contain digits from multiple different numbering systems.</li>
+ * </ul>
+ *
+ * <p>
+ * These checks can be enabled independently of each other. For example, if you were interested in checking for only the
+ * INVISIBLE and MIXED_NUMBERS conditions, you could do:
+ *
+ * <pre>
+ * <code>
+ * SpoofChecker sc = new SpoofChecker.Builder()
+ *     .setChecks(SpoofChecker.INVISIBLE | SpoofChecker.MIXED_NUMBERS)
+ *     .build();
+ * boolean result = sc.failsChecks("৪8");
+ * System.out.println(result);  // true
+ * </code>
+ * </pre>
+ *
+ * <p>
+ * <b>Note:</b> The Restriction Level is the most powerful of the checks. The full logic is documented in
+ * <a href="http://unicode.org/reports/tr39/#Restriction_Level_Detection">UTS 39</a>, but the basic idea is that strings
+ * are restricted to contain characters from only a single script, <em>except</em> that most scripts are allowed to have
+ * Latin characters interspersed. Although the default restriction level is <code>HIGHLY_RESTRICTIVE</code>, it is
+ * recommended that users set their restriction level to <code>MODERATELY_RESTRICTIVE</code>, which allows Latin mixed
+ * with all other scripts except Cyrillic, Greek, and Cherokee, with which it is often confusable. For more details on
+ * the levels, see UTS 39 or {@link SpoofChecker.RestrictionLevel}. The Restriction Level test is aware of the set of
+ * allowed characters set in {@link SpoofChecker.Builder#setAllowedChars}. Note that characters which have script code
+ * COMMON or INHERITED, such as numbers and punctuation, are ignored when computing whether a string has multiple
+ * scripts.
+ *
+ * <h2>Additional Information</h2>
+ *
+ * <p>
+ * A <code>SpoofChecker</code> instance may be used repeatedly to perform checks on any number of identifiers.
+ *
+ * <p>
+ * <b>Thread Safety:</b> The methods on <code>SpoofChecker</code> objects are thread safe. The test functions for
+ * checking a single identifier, or for testing whether two identifiers are potentially confusable, may called
+ * concurrently from multiple threads using the same <code>SpoofChecker</code> instance.
+ *
+ * @stable ICU 4.6
+ */
+public class SpoofChecker {
+
+    /**
+     * Constants from UTS 39 for use in setRestrictionLevel.
+     *
+     * @stable ICU 53
+     */
+    public enum RestrictionLevel {
+        /**
+         * All characters in the string are in the identifier profile and all characters in the string are in the ASCII
+         * range.
+         *
+         * @stable ICU 53
+         */
+        ASCII,
+        /**
+         * The string classifies as ASCII-Only, or all characters in the string are in the identifier profile and the
+         * string is single-script, according to the definition in UTS 39 section 5.1.
+         *
+         * @stable ICU 53
+         */
+        SINGLE_SCRIPT_RESTRICTIVE,
+        /**
+         * The string classifies as Single Script, or all characters in the string are in the identifier profile and the
+         * string is covered by any of the following sets of scripts, according to the definition in UTS 39 section 5.1:
+         * <ul>
+         * <li>Latin + Han + Bopomofo (or equivalently: Latn + Hanb)</li>
+         * <li>Latin + Han + Hiragana + Katakana (or equivalently: Latn + Jpan)</li>
+         * <li>Latin + Han + Hangul (or equivalently: Latn +Kore)</li>
+         * </ul>
+         *
+         * @stable ICU 53
+         */
+        HIGHLY_RESTRICTIVE,
+        /**
+         * The string classifies as Highly Restrictive, or all characters in the string are in the identifier profile
+         * and the string is covered by Latin and any one other Recommended or Aspirational script, except Cyrillic,
+         * Greek, and Cherokee.
+         *
+         * @stable ICU 53
+         */
+        MODERATELY_RESTRICTIVE,
+        /**
+         * All characters in the string are in the identifier profile. Allow arbitrary mixtures of scripts, such as
+         * Ωmega, Teχ, HλLF-LIFE, Toys-Я-Us.
+         *
+         * @stable ICU 53
+         */
+        MINIMALLY_RESTRICTIVE,
+        /**
+         * Any valid identifiers, including characters outside of the Identifier Profile, such as I♥NY.org
+         *
+         * @stable ICU 53
+         */
+        UNRESTRICTIVE,
+    }
+
+    /**
+     * Security Profile constant from UTS 39 for use in {@link SpoofChecker.Builder#setAllowedChars}.
+     *
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public static final UnicodeSet INCLUSION = new UnicodeSet(
+            "['\\-.\\:\\u00B7\\u0375\\u058A\\u05F3\\u05F4\\u06FD\\u06FE\\u0F0B\\u200C\\u200D\\u2010\\u"
+                    + "2019\\u2027\\u30A0\\u30FB]").freeze();
+    // Note: data from http://unicode.org/Public/security/9.0.0/IdentifierStatus.txt
+    // There is tooling to generate this constant in the unicodetools project:
+    //      org.unicode.text.tools.RecommendedSetGenerator
+    // It will print the Java and C++ code to the console for easy copy-paste into this file.
+
+    /**
+     * Security Profile constant from UTS 39 for use in {@link SpoofChecker.Builder#setAllowedChars}.
+     *
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public static final UnicodeSet RECOMMENDED = new UnicodeSet(
+            "[0-9A-Z_a-z\\u00C0-\\u00D6\\u00D8-\\u00F6\\u00F8-\\u0131\\u0134-\\u013E\\u0141-\\u014"
+                    + "8\\u014A-\\u017E\\u018F\\u01A0\\u01A1\\u01AF\\u01B0\\u01CD-\\u01DC\\u01DE-\\u01E3\\u01E"
+                    + "6-\\u01F0\\u01F4\\u01F5\\u01F8-\\u021B\\u021E\\u021F\\u0226-\\u0233\\u0259\\u02BB\\u02B"
+                    + "C\\u02EC\\u0300-\\u0304\\u0306-\\u030C\\u030F-\\u0311\\u0313\\u0314\\u031B\\u0323-\\u03"
+                    + "28\\u032D\\u032E\\u0330\\u0331\\u0335\\u0338\\u0339\\u0342\\u0345\\u037B-\\u037D\\u0386"
+                    + "\\u0388-\\u038A\\u038C\\u038E-\\u03A1\\u03A3-\\u03CE\\u03FC-\\u045F\\u048A-\\u0529\\u05"
+                    + "2E\\u052F\\u0531-\\u0556\\u0559\\u0561-\\u0586\\u05B4\\u05D0-\\u05EA\\u05F0-\\u05F2\\u0"
+                    + "620-\\u063F\\u0641-\\u0655\\u0660-\\u0669\\u0670-\\u0672\\u0674\\u0679-\\u068D\\u068F-"
+                    + "\\u06D3\\u06D5\\u06E5\\u06E6\\u06EE-\\u06FC\\u06FF\\u0750-\\u07B1\\u08A0-\\u08AC\\u08B2"
+                    + "\\u08B6-\\u08BD\\u0901-\\u094D\\u094F\\u0950\\u0956\\u0957\\u0960-\\u0963\\u0966-\\u096"
+                    + "F\\u0971-\\u0977\\u0979-\\u097F\\u0981-\\u0983\\u0985-\\u098C\\u098F\\u0990\\u0993-\\u0"
+                    + "9A8\\u09AA-\\u09B0\\u09B2\\u09B6-\\u09B9\\u09BC-\\u09C4\\u09C7\\u09C8\\u09CB-\\u09CE\\u"
+                    + "09D7\\u09E0-\\u09E3\\u09E6-\\u09F1\\u0A01-\\u0A03\\u0A05-\\u0A0A\\u0A0F\\u0A10\\u0A13-"
+                    + "\\u0A28\\u0A2A-\\u0A30\\u0A32\\u0A35\\u0A38\\u0A39\\u0A3C\\u0A3E-\\u0A42\\u0A47\\u0A48\\"
+                    + "u0A4B-\\u0A4D\\u0A5C\\u0A66-\\u0A74\\u0A81-\\u0A83\\u0A85-\\u0A8D\\u0A8F-\\u0A91\\u0A9"
+                    + "3-\\u0AA8\\u0AAA-\\u0AB0\\u0AB2\\u0AB3\\u0AB5-\\u0AB9\\u0ABC-\\u0AC5\\u0AC7-\\u0AC9\\u0"
+                    + "ACB-\\u0ACD\\u0AD0\\u0AE0-\\u0AE3\\u0AE6-\\u0AEF\\u0B01-\\u0B03\\u0B05-\\u0B0C\\u0B0F\\"
+                    + "u0B10\\u0B13-\\u0B28\\u0B2A-\\u0B30\\u0B32\\u0B33\\u0B35-\\u0B39\\u0B3C-\\u0B43\\u0B47"
+                    + "\\u0B48\\u0B4B-\\u0B4D\\u0B56\\u0B57\\u0B5F-\\u0B61\\u0B66-\\u0B6F\\u0B71\\u0B82\\u0B83"
+                    + "\\u0B85-\\u0B8A\\u0B8E-\\u0B90\\u0B92-\\u0B95\\u0B99\\u0B9A\\u0B9C\\u0B9E\\u0B9F\\u0BA3"
+                    + "\\u0BA4\\u0BA8-\\u0BAA\\u0BAE-\\u0BB9\\u0BBE-\\u0BC2\\u0BC6-\\u0BC8\\u0BCA-\\u0BCD\\u0B"
+                    + "D0\\u0BD7\\u0BE6-\\u0BEF\\u0C01-\\u0C03\\u0C05-\\u0C0C\\u0C0E-\\u0C10\\u0C12-\\u0C28\\u"
+                    + "0C2A-\\u0C33\\u0C35-\\u0C39\\u0C3D-\\u0C44\\u0C46-\\u0C48\\u0C4A-\\u0C4D\\u0C55\\u0C56"
+                    + "\\u0C60\\u0C61\\u0C66-\\u0C6F\\u0C80\\u0C82\\u0C83\\u0C85-\\u0C8C\\u0C8E-\\u0C90\\u0C92"
+                    + "-\\u0CA8\\u0CAA-\\u0CB3\\u0CB5-\\u0CB9\\u0CBC-\\u0CC4\\u0CC6-\\u0CC8\\u0CCA-\\u0CCD\\u0"
+                    + "CD5\\u0CD6\\u0CE0-\\u0CE3\\u0CE6-\\u0CEF\\u0CF1\\u0CF2\\u0D02\\u0D03\\u0D05-\\u0D0C\\u0"
+                    + "D0E-\\u0D10\\u0D12-\\u0D3A\\u0D3D-\\u0D43\\u0D46-\\u0D48\\u0D4A-\\u0D4E\\u0D54-\\u0D57"
+                    + "\\u0D60\\u0D61\\u0D66-\\u0D6F\\u0D7A-\\u0D7F\\u0D82\\u0D83\\u0D85-\\u0D8E\\u0D91-\\u0D9"
+                    + "6\\u0D9A-\\u0DA5\\u0DA7-\\u0DB1\\u0DB3-\\u0DBB\\u0DBD\\u0DC0-\\u0DC6\\u0DCA\\u0DCF-\\u0"
+                    + "DD4\\u0DD6\\u0DD8-\\u0DDE\\u0DF2\\u0E01-\\u0E32\\u0E34-\\u0E3A\\u0E40-\\u0E4E\\u0E50-\\"
+                    + "u0E59\\u0E81\\u0E82\\u0E84\\u0E87\\u0E88\\u0E8A\\u0E8D\\u0E94-\\u0E97\\u0E99-\\u0E9F\\u"
+                    + "0EA1-\\u0EA3\\u0EA5\\u0EA7\\u0EAA\\u0EAB\\u0EAD-\\u0EB2\\u0EB4-\\u0EB9\\u0EBB-\\u0EBD\\"
+                    + "u0EC0-\\u0EC4\\u0EC6\\u0EC8-\\u0ECD\\u0ED0-\\u0ED9\\u0EDE\\u0EDF\\u0F00\\u0F20-\\u0F29"
+                    + "\\u0F35\\u0F37\\u0F3E-\\u0F42\\u0F44-\\u0F47\\u0F49-\\u0F4C\\u0F4E-\\u0F51\\u0F53-\\u0F"
+                    + "56\\u0F58-\\u0F5B\\u0F5D-\\u0F68\\u0F6A-\\u0F6C\\u0F71\\u0F72\\u0F74\\u0F7A-\\u0F80\\u0"
+                    + "F82-\\u0F84\\u0F86-\\u0F92\\u0F94-\\u0F97\\u0F99-\\u0F9C\\u0F9E-\\u0FA1\\u0FA3-\\u0FA6"
+                    + "\\u0FA8-\\u0FAB\\u0FAD-\\u0FB8\\u0FBA-\\u0FBC\\u0FC6\\u1000-\\u1049\\u1050-\\u109D\\u10"
+                    + "C7\\u10CD\\u10D0-\\u10F0\\u10F7-\\u10FA\\u10FD-\\u10FF\\u1200-\\u1248\\u124A-\\u124D\\u"
+                    + "1250-\\u1256\\u1258\\u125A-\\u125D\\u1260-\\u1288\\u128A-\\u128D\\u1290-\\u12B0\\u12B2"
+                    + "-\\u12B5\\u12B8-\\u12BE\\u12C0\\u12C2-\\u12C5\\u12C8-\\u12D6\\u12D8-\\u1310\\u1312-\\u1"
+                    + "315\\u1318-\\u135A\\u135D-\\u135F\\u1380-\\u138F\\u1780-\\u17A2\\u17A5-\\u17A7\\u17A9-"
+                    + "\\u17B3\\u17B6-\\u17CA\\u17D2\\u17D7\\u17DC\\u17E0-\\u17E9\\u1C80-\\u1C88\\u1E00-\\u1E9"
+                    + "9\\u1E9E\\u1EA0-\\u1EF9\\u1F00-\\u1F15\\u1F18-\\u1F1D\\u1F20-\\u1F45\\u1F48-\\u1F4D\\u1"
+                    + "F50-\\u1F57\\u1F59\\u1F5B\\u1F5D\\u1F5F-\\u1F70\\u1F72\\u1F74\\u1F76\\u1F78\\u1F7A\\u1F"
+                    + "7C\\u1F80-\\u1FB4\\u1FB6-\\u1FBA\\u1FBC\\u1FC2-\\u1FC4\\u1FC6-\\u1FC8\\u1FCA\\u1FCC\\u1"
+                    + "FD0-\\u1FD2\\u1FD6-\\u1FDA\\u1FE0-\\u1FE2\\u1FE4-\\u1FEA\\u1FEC\\u1FF2-\\u1FF4\\u1FF6-"
+                    + "\\u1FF8\\u1FFA\\u1FFC\\u2D27\\u2D2D\\u2D80-\\u2D96\\u2DA0-\\u2DA6\\u2DA8-\\u2DAE\\u2DB0"
+                    + "-\\u2DB6\\u2DB8-\\u2DBE\\u2DC0-\\u2DC6\\u2DC8-\\u2DCE\\u2DD0-\\u2DD6\\u2DD8-\\u2DDE\\u3"
+                    + "005-\\u3007\\u3041-\\u3096\\u3099\\u309A\\u309D\\u309E\\u30A1-\\u30FA\\u30FC-\\u30FE\\u"
+                    + "3105-\\u312D\\u31A0-\\u31BA\\u3400-\\u4DB5\\u4E00-\\u9FD5\\uA660\\uA661\\uA674-\\uA67B"
+                    + "\\uA67F\\uA69F\\uA717-\\uA71F\\uA788\\uA78D\\uA78E\\uA790-\\uA793\\uA7A0-\\uA7AA\\uA7AE"
+                    + "\\uA7FA\\uA9E7-\\uA9FE\\uAA60-\\uAA76\\uAA7A-\\uAA7F\\uAB01-\\uAB06\\uAB09-\\uAB0E\\uAB"
+                    + "11-\\uAB16\\uAB20-\\uAB26\\uAB28-\\uAB2E\\uAC00-\\uD7A3\\uFA0E\\uFA0F\\uFA11\\uFA13\\uF"
+                    + "A14\\uFA1F\\uFA21\\uFA23\\uFA24\\uFA27-\\uFA29\\U00020000-\\U0002A6D6\\U0002A700-\\U0"
+                    + "002B734\\U0002B740-\\U0002B81D\\U0002B820-\\U0002CEA1]").freeze();
+    // Note: data from http://unicode.org/Public/security/9.0.0/IdentifierStatus.txt
+    // There is tooling to generate this constant in the unicodetools project:
+    //      org.unicode.text.tools.RecommendedSetGenerator
+    // It will print the Java and C++ code to the console for easy copy-paste into this file.
+
+    /**
+     * Constants for the kinds of checks that USpoofChecker can perform. These values are used both to select the set of
+     * checks that will be performed, and to report results from the check function.
+     *
+     */
+
+    /**
+     * When performing the two-string {@link SpoofChecker#areConfusable} test, this flag in the return value indicates
+     * that the two strings are visually confusable and that they are from the same script, according to UTS 39 section
+     * 4.
+     *
+     * @stable ICU 4.6
+     */
+    public static final int SINGLE_SCRIPT_CONFUSABLE = 1;
+
+    /**
+     * When performing the two-string {@link SpoofChecker#areConfusable} test, this flag in the return value indicates
+     * that the two strings are visually confusable and that they are <b>not</b> from the same script, according to UTS
+     * 39 section 4.
+     *
+     * @stable ICU 4.6
+     */
+    public static final int MIXED_SCRIPT_CONFUSABLE = 2;
+
+    /**
+     * When performing the two-string {@link SpoofChecker#areConfusable} test, this flag in the return value indicates
+     * that the two strings are visually confusable and that they are not from the same script but both of them are
+     * single-script strings, according to UTS 39 section 4.
+     *
+     * @stable ICU 4.6
+     */
+    public static final int WHOLE_SCRIPT_CONFUSABLE = 4;
+
+    /**
+     * Enable this flag in {@link SpoofChecker.Builder#setChecks} to turn on all types of confusables. You may set the
+     * checks to some subset of SINGLE_SCRIPT_CONFUSABLE, MIXED_SCRIPT_CONFUSABLE, or WHOLE_SCRIPT_CONFUSABLE to make
+     * {@link SpoofChecker#areConfusable} return only those types of confusables.
+     *
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public static final int CONFUSABLE = SINGLE_SCRIPT_CONFUSABLE | MIXED_SCRIPT_CONFUSABLE | WHOLE_SCRIPT_CONFUSABLE;
+
+    /**
+     * This flag is deprecated and no longer affects the behavior of SpoofChecker.
+     *
+     * @deprecated ICU 58 Any case confusable mappings were removed from UTS 39; the corresponding ICU API was
+     * deprecated.
+     */
+    @Deprecated
+    public static final int ANY_CASE = 8;
+
+    /**
+     * Check that an identifier satisfies the requirements for the restriction level specified in
+     * {@link SpoofChecker.Builder#setRestrictionLevel}. The default restriction level is
+     * {@link RestrictionLevel#HIGHLY_RESTRICTIVE}.
+     *
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public static final int RESTRICTION_LEVEL = 16;
+
+    /**
+     * Check that an identifier contains only characters from a single script (plus chars from the common and inherited
+     * scripts.) Applies to checks of a single identifier check only.
+     *
+     * @deprecated ICU 51 Use RESTRICTION_LEVEL
+     */
+    @Deprecated
+    public static final int SINGLE_SCRIPT = RESTRICTION_LEVEL;
+
+    /**
+     * Check an identifier for the presence of invisible characters, such as zero-width spaces, or character sequences
+     * that are likely not to display, such as multiple occurrences of the same non-spacing mark. This check does not
+     * test the input string as a whole for conformance to any particular syntax for identifiers.
+     *
+     * @stable ICU 4.6
+     */
+    public static final int INVISIBLE = 32;
+
+    /**
+     * Check that an identifier contains only characters from a specified set of acceptable characters. See
+     * {@link Builder#setAllowedChars} and {@link Builder#setAllowedLocales}. Note that a string that fails this check
+     * will also fail the {@link #RESTRICTION_LEVEL} check.
+     *
+     * @stable ICU 4.6
+     */
+    public static final int CHAR_LIMIT = 64;
+
+    /**
+     * Check that an identifier does not mix numbers from different numbering systems. For more information, see UTS 39
+     * section 5.3.
+     *
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public static final int MIXED_NUMBERS = 128;
+
+    // Update CheckResult.toString() when a new check is added.
+
+    /**
+     * Enable all spoof checks.
+     *
+     * @stable ICU 4.6
+     */
+    public static final int ALL_CHECKS = 0xFFFFFFFF;
+
+    // Used for checking for ASCII-Only restriction level
+    static final UnicodeSet ASCII = new UnicodeSet(0, 0x7F).freeze();
+
+    /**
+     * private constructor: a SpoofChecker has to be built by the builder
+     */
+    private SpoofChecker() {
+    }
+
+    /**
+     * SpoofChecker Builder. To create a SpoofChecker, first instantiate a SpoofChecker.Builder, set the desired
+     * checking options on the builder, then call the build() function to create a SpoofChecker instance.
+     *
+     * @stable ICU 4.6
+     */
+    public static class Builder {
+        int fChecks; // Bit vector of checks to perform.
+        SpoofData fSpoofData;
+        final UnicodeSet fAllowedCharsSet = new UnicodeSet(0, 0x10ffff); // The UnicodeSet of allowed characters.
+        // for this Spoof Checker. Defaults to all chars.
+        final Set<ULocale> fAllowedLocales = new LinkedHashSet<ULocale>(); // The list of allowed locales.
+        private RestrictionLevel fRestrictionLevel;
+
+        /**
+         * Constructor: Create a default Unicode Spoof Checker Builder, configured to perform all checks except for
+         * LOCALE_LIMIT and CHAR_LIMIT. Note that additional checks may be added in the future, resulting in the changes
+         * to the default checking behavior.
+         *
+         * @stable ICU 4.6
+         */
+        public Builder() {
+            fChecks = ALL_CHECKS;
+            fSpoofData = null;
+            fRestrictionLevel = RestrictionLevel.HIGHLY_RESTRICTIVE;
+        }
+
+        /**
+         * Constructor: Create a Spoof Checker Builder, and set the configuration from an existing SpoofChecker.
+         *
+         * @param src
+         *            The existing checker.
+         * @stable ICU 4.6
+         */
+        public Builder(SpoofChecker src) {
+            fChecks = src.fChecks;
+            fSpoofData = src.fSpoofData; // For the data, we will either use the source data
+                                         // as-is, or drop the builder's reference to it
+                                         // and generate new data, depending on what our
+                                         // caller does with the builder.
+            fAllowedCharsSet.set(src.fAllowedCharsSet);
+            fAllowedLocales.addAll(src.fAllowedLocales);
+            fRestrictionLevel = src.fRestrictionLevel;
+        }
+
+        /**
+         * Create a SpoofChecker with current configuration.
+         *
+         * @return SpoofChecker
+         * @stable ICU 4.6
+         */
+        public SpoofChecker build() {
+            // TODO: Make this data loading be lazy (see #12696).
+            if (fSpoofData == null) {
+                // read binary file
+                fSpoofData = SpoofData.getDefault();
+            }
+
+            // Copy all state from the builder to the new SpoofChecker.
+            // Make sure that everything is either cloned or copied, so
+            // that subsequent re-use of the builder won't modify the built
+            // SpoofChecker.
+            //
+            // One exception to this: the SpoofData is just assigned.
+            // If the builder subsequently needs to modify fSpoofData
+            // it will create a new SpoofData object first.
+
+            SpoofChecker result = new SpoofChecker();
+            result.fChecks = this.fChecks;
+            result.fSpoofData = this.fSpoofData;
+            result.fAllowedCharsSet = (UnicodeSet) (this.fAllowedCharsSet.clone());
+            result.fAllowedCharsSet.freeze();
+            result.fAllowedLocales = new HashSet<ULocale>(this.fAllowedLocales);
+            result.fRestrictionLevel = this.fRestrictionLevel;
+            return result;
+        }
+
+        /**
+         * Specify the source form of the spoof data Spoof Checker. The inputs correspond to the Unicode data file
+         * confusables.txt as described in Unicode UAX 39. The syntax of the source data is as described in UAX 39 for
+         * these files, and the content of these files is acceptable input.
+         *
+         * @param confusables
+         *            the Reader of confusable characters definitions, as found in file confusables.txt from
+         *            unicode.org.
+         * @throws ParseException
+         *             To report syntax errors in the input.
+         *
+         * @draft ICU 58
+         * @provisional This API might change or be removed in a future release.
+         */
+        public Builder setData(Reader confusables) throws ParseException, IOException {
+
+            // Compile the binary data from the source (text) format.
+            // Drop the builder's reference to any pre-existing data, which may
+            // be in use in an already-built checker.
+
+            fSpoofData = new SpoofData();
+            ConfusabledataBuilder.buildConfusableData(confusables, fSpoofData);
+            return this;
+        }
+
+        /**
+         * Deprecated as of ICU 58; use {@link SpoofChecker.Builder#setData(Reader confusables)} instead.
+         *
+         * @param confusables
+         *            the Reader of confusable characters definitions, as found in file confusables.txt from
+         *            unicode.org.
+         * @param confusablesWholeScript
+         *            No longer supported.
+         * @throws ParseException
+         *             To report syntax errors in the input.
+         *
+         * @deprecated ICU 58
+         */
+        @Deprecated
+        public Builder setData(Reader confusables, Reader confusablesWholeScript) throws ParseException, IOException {
+            setData(confusables);
+            return this;
+        }
+
+        /**
+         * Specify the bitmask of checks that will be performed by {@link SpoofChecker#failsChecks}. Calling this method
+         * overwrites any checks that may have already been enabled. By default, all checks are enabled.
+         *
+         * To enable specific checks and disable all others, the "whitelisted" checks should be ORed together. For
+         * example, to fail strings containing characters outside of the set specified by {@link #setAllowedChars} and
+         * also strings that contain digits from mixed numbering systems:
+         *
+         * <pre>
+         * {@code
+         * builder.setChecks(SpoofChecker.CHAR_LIMIT | SpoofChecker.MIXED_NUMBERS);
+         * }
+         * </pre>
+         *
+         * To disable specific checks and enable all others, the "blacklisted" checks should be ANDed away from
+         * ALL_CHECKS. For example, if you are not planning to use the {@link SpoofChecker#areConfusable} functionality,
+         * it is good practice to disable the CONFUSABLE check:
+         *
+         * <pre>
+         * {@code
+         * builder.setChecks(SpoofChecker.ALL_CHECKS & ~SpoofChecker.CONFUSABLE);
+         * }
+         * </pre>
+         *
+         * Note that methods such as {@link #setAllowedChars}, {@link #setAllowedLocales}, and
+         * {@link #setRestrictionLevel} will enable certain checks when called. Those methods will OR the check they
+         * enable onto the existing bitmask specified by this method. For more details, see the documentation of those
+         * methods.
+         *
+         * @param checks
+         *            The set of checks that this spoof checker will perform. The value is an 'or' of the desired
+         *            checks.
+         * @return self
+         * @stable ICU 4.6
+         */
+        public Builder setChecks(int checks) {
+            // Verify that the requested checks are all ones (bits) that
+            // are acceptable, known values.
+            if (0 != (checks & ~SpoofChecker.ALL_CHECKS)) {
+                throw new IllegalArgumentException("Bad Spoof Checks value.");
+            }
+            this.fChecks = (checks & SpoofChecker.ALL_CHECKS);
+            return this;
+        }
+
+        /**
+         * Limit characters that are acceptable in identifiers being checked to those normally used with the languages
+         * associated with the specified locales. Any previously specified list of locales is replaced by the new
+         * settings.
+         *
+         * A set of languages is determined from the locale(s), and from those a set of acceptable Unicode scripts is
+         * determined. Characters from this set of scripts, along with characters from the "common" and "inherited"
+         * Unicode Script categories will be permitted.
+         *
+         * Supplying an empty string removes all restrictions; characters from any script will be allowed.
+         *
+         * The {@link #CHAR_LIMIT} test is automatically enabled for this SpoofChecker when calling this function with a
+         * non-empty list of locales.
+         *
+         * The Unicode Set of characters that will be allowed is accessible via the {@link #getAllowedChars} function.
+         * setAllowedLocales() will <i>replace</i> any previously applied set of allowed characters.
+         *
+         * Adjustments, such as additions or deletions of certain classes of characters, can be made to the result of
+         * {@link #setAllowedChars} by fetching the resulting set with {@link #getAllowedChars}, manipulating it with
+         * the Unicode Set API, then resetting the spoof detectors limits with {@link #setAllowedChars}.
+         *
+         * @param locales
+         *            A Set of ULocales, from which the language and associated script are extracted. If the locales Set
+         *            is null, no restrictions will be placed on the allowed characters.
+         *
+         * @return self
+         * @stable ICU 4.6
+         */
+        public Builder setAllowedLocales(Set<ULocale> locales) {
+            fAllowedCharsSet.clear();
+
+            for (ULocale locale : locales) {
+                // Add the script chars for this locale to the accumulating set
+                // of allowed chars.
+                addScriptChars(locale, fAllowedCharsSet);
+            }
+
+            // If our caller provided an empty list of locales, we disable the
+            // allowed characters checking
+            fAllowedLocales.clear();
+            if (locales.size() == 0) {
+                fAllowedCharsSet.add(0, 0x10ffff);
+                fChecks &= ~CHAR_LIMIT;
+                return this;
+            }
+
+            // Add all common and inherited characters to the set of allowed
+            // chars.
+            UnicodeSet tempSet = new UnicodeSet();
+            tempSet.applyIntPropertyValue(UProperty.SCRIPT, UScript.COMMON);
+            fAllowedCharsSet.addAll(tempSet);
+            tempSet.applyIntPropertyValue(UProperty.SCRIPT, UScript.INHERITED);
+            fAllowedCharsSet.addAll(tempSet);
+
+            // Store the updated spoof checker state.
+            fAllowedLocales.clear();
+            fAllowedLocales.addAll(locales);
+            fChecks |= CHAR_LIMIT;
+            return this;
+        }
+
+        /**
+         * Limit characters that are acceptable in identifiers being checked to those normally used with the languages
+         * associated with the specified locales. Any previously specified list of locales is replaced by the new
+         * settings.
+         *
+         * @param locales
+         *            A Set of Locales, from which the language and associated script are extracted. If the locales Set
+         *            is null, no restrictions will be placed on the allowed characters.
+         *
+         * @return self
+         * @stable ICU 54
+         */
+        public Builder setAllowedJavaLocales(Set<Locale> locales) {
+            HashSet<ULocale> ulocales = new HashSet<ULocale>(locales.size());
+            for (Locale locale : locales) {
+                ulocales.add(ULocale.forLocale(locale));
+            }
+            return setAllowedLocales(ulocales);
+        }
+
+        // Add (union) to the UnicodeSet all of the characters for the scripts
+        // used for the specified locale. Part of the implementation of
+        // setAllowedLocales.
+        private void addScriptChars(ULocale locale, UnicodeSet allowedChars) {
+            int scripts[] = UScript.getCode(locale);
+            if (scripts != null) {
+                UnicodeSet tmpSet = new UnicodeSet();
+                for (int i = 0; i < scripts.length; i++) {
+                    tmpSet.applyIntPropertyValue(UProperty.SCRIPT, scripts[i]);
+                    allowedChars.addAll(tmpSet);
+                }
+            }
+            // else it's an unknown script.
+            // Maybe they asked for the script of "zxx", which refers to no linguistic content.
+            // Maybe they asked for the script of a newer locale that we don't know in the older version of ICU.
+        }
+
+        /**
+         * Limit the acceptable characters to those specified by a Unicode Set. Any previously specified character limit
+         * is is replaced by the new settings. This includes limits on characters that were set with the
+         * setAllowedLocales() function. Note that the RESTRICTED set is useful.
+         *
+         * The {@link #CHAR_LIMIT} test is automatically enabled for this SpoofChecker by this function.
+         *
+         * @param chars
+         *            A Unicode Set containing the list of characters that are permitted. The incoming set is cloned by
+         *            this function, so there are no restrictions on modifying or deleting the UnicodeSet after calling
+         *            this function. Note that this clears the allowedLocales set.
+         * @return self
+         * @stable ICU 4.6
+         */
+        public Builder setAllowedChars(UnicodeSet chars) {
+            fAllowedCharsSet.set(chars);
+            fAllowedLocales.clear();
+            fChecks |= CHAR_LIMIT;
+            return this;
+        }
+
+        /**
+         * Set the loosest restriction level allowed for strings. The default if this is not called is
+         * {@link RestrictionLevel#HIGHLY_RESTRICTIVE}. Calling this method enables the {@link #RESTRICTION_LEVEL} and
+         * {@link #MIXED_NUMBERS} checks, corresponding to Sections 5.1 and 5.2 of UTS 39. To customize which checks are
+         * to be performed by {@link SpoofChecker#failsChecks}, see {@link #setChecks}.
+         *
+         * @param restrictionLevel
+         *            The loosest restriction level allowed.
+         * @return self
+         * @provisional This API might change or be removed in a future release.
+         * @draft ICU 58
+         */
+        public Builder setRestrictionLevel(RestrictionLevel restrictionLevel) {
+            fRestrictionLevel = restrictionLevel;
+            fChecks |= RESTRICTION_LEVEL | MIXED_NUMBERS;
+            return this;
+        }
+
+        /*
+         * *****************************************************************************
+         * Internal classes for compililing confusable data into its binary (runtime) form.
+         * *****************************************************************************
+         */
+        // ---------------------------------------------------------------------
+        //
+        // buildConfusableData Compile the source confusable data, as defined by
+        // the Unicode data file confusables.txt, into the binary
+        // structures used by the confusable detector.
+        //
+        // The binary structures are described in uspoof_impl.h
+        //
+        // 1. parse the data, making a hash table mapping from a codepoint to a String.
+        //
+        // 2. Sort all of the strings encountered by length, since they will need to
+        // be stored in that order in the final string table.
+        // TODO: Sorting these strings by length is no longer needed since the removal of
+        // the string lengths table.  This logic can be removed to save processing time
+        // when building confusables data.
+        //
+        // 3. Build a list of keys (UChar32s) from the mapping table. Sort the
+        // list because that will be the ordering of our runtime table.
+        //
+        // 4. Generate the run time string table. This is generated before the key & value
+        // table because we need the string indexes when building those tables.
+        //
+        // 5. Build the run-time key and value table. These are parallel tables, and
+        // are built at the same time
+
+        // class ConfusabledataBuilder
+        // An instance of this class exists while the confusable data is being built from source.
+        // It encapsulates the intermediate data structures that are used for building.
+        // It exports one static function, to do a confusable data build.
+        private static class ConfusabledataBuilder {
+
+            private Hashtable<Integer, SPUString> fTable;
+            private UnicodeSet fKeySet; // A set of all keys (UChar32s) that go into the
+                                        // four mapping tables.
+
+            // The compiled data is first assembled into the following four collections,
+            // then output to the builder's SpoofData object.
+            private StringBuffer fStringTable;
+            private ArrayList<Integer> fKeyVec;
+            private ArrayList<Integer> fValueVec;
+            private SPUStringPool stringPool;
+            private Pattern fParseLine;
+            private Pattern fParseHexNum;
+            private int fLineNum;
+
+            ConfusabledataBuilder() {
+                fTable = new Hashtable<Integer, SPUString>();
+                fKeySet = new UnicodeSet();
+                fKeyVec = new ArrayList<Integer>();
+                fValueVec = new ArrayList<Integer>();
+                stringPool = new SPUStringPool();
+            }
+
+            void build(Reader confusables, SpoofData dest) throws ParseException, java.io.IOException {
+                StringBuffer fInput = new StringBuffer();
+
+                // Convert the user input data from UTF-8 to char (UTF-16)
+                LineNumberReader lnr = new LineNumberReader(confusables);
+                do {
+                    String line = lnr.readLine();
+                    if (line == null) {
+                        break;
+                    }
+                    fInput.append(line);
+                    fInput.append('\n');
+                } while (true);
+
+                // Regular Expression to parse a line from Confusables.txt. The expression will match
+                // any line. What was matched is determined by examining which capture groups have a match.
+                // Capture Group 1: the source char
+                // Capture Group 2: the replacement chars
+                // Capture Group 3-6 the table type, SL, SA, ML, or MA (deprecated)
+                // Capture Group 7: A blank or comment only line.
+                // Capture Group 8: A syntactically invalid line. Anything that didn't match before.
+                // Example Line from the confusables.txt source file:
+                // "1D702 ; 006E 0329 ; SL # MATHEMATICAL ITALIC SMALL ETA ... "
+                fParseLine = Pattern.compile("(?m)^[ \\t]*([0-9A-Fa-f]+)[ \\t]+;" + // Match the source char
+                        "[ \\t]*([0-9A-Fa-f]+" + // Match the replacement char(s)
+                        "(?:[ \\t]+[0-9A-Fa-f]+)*)[ \\t]*;" + // (continued)
+                        "\\s*(?:(SL)|(SA)|(ML)|(MA))" + // Match the table type
+                        "[ \\t]*(?:#.*?)?$" + // Match any trailing #comment
+                        "|^([ \\t]*(?:#.*?)?)$" + // OR match empty lines or lines with only a #comment
+                        "|^(.*?)$"); // OR match any line, which catches illegal lines.
+
+                // Regular expression for parsing a hex number out of a space-separated list of them.
+                // Capture group 1 gets the number, with spaces removed.
+                fParseHexNum = Pattern.compile("\\s*([0-9A-F]+)");
+
+                // Zap any Byte Order Mark at the start of input. Changing it to a space
+                // is benign given the syntax of the input.
+                if (fInput.charAt(0) == 0xfeff) {
+                    fInput.setCharAt(0, (char) 0x20);
+                }
+
+                // Parse the input, one line per iteration of this loop.
+                Matcher matcher = fParseLine.matcher(fInput);
+                while (matcher.find()) {
+                    fLineNum++;
+                    if (matcher.start(7) >= 0) {
+                        // this was a blank or comment line.
+                        continue;
+                    }
+                    if (matcher.start(8) >= 0) {
+                        // input file syntax error.
+                        // status = U_PARSE_ERROR;
+                        throw new ParseException(
+                                "Confusables, line " + fLineNum + ": Unrecognized Line: " + matcher.group(8),
+                                matcher.start(8));
+                    }
+
+                    // We have a good input line. Extract the key character and mapping
+                    // string, and
+                    // put them into the appropriate mapping table.
+                    int keyChar = Integer.parseInt(matcher.group(1), 16);
+                    if (keyChar > 0x10ffff) {
+                        throw new ParseException(
+                                "Confusables, line " + fLineNum + ": Bad code point: " + matcher.group(1),
+                                matcher.start(1));
+                    }
+                    Matcher m = fParseHexNum.matcher(matcher.group(2));
+
+                    StringBuilder mapString = new StringBuilder();
+                    while (m.find()) {
+                        int c = Integer.parseInt(m.group(1), 16);
+                        if (c > 0x10ffff) {
+                            throw new ParseException(
+                                    "Confusables, line " + fLineNum + ": Bad code point: " + Integer.toString(c, 16),
+                                    matcher.start(2));
+                        }
+                        mapString.appendCodePoint(c);
+                    }
+                    assert (mapString.length() >= 1);
+
+                    // Put the map (value) string into the string pool
+                    // This a little like a Java intern() - any duplicates will be
+                    // eliminated.
+                    SPUString smapString = stringPool.addString(mapString.toString());
+
+                    // Add the char . string mapping to the table.
+                    // For Unicode 8, the SL, SA and ML tables have been discontinued.
+                    // All input data from confusables.txt is tagged MA.
+                    fTable.put(keyChar, smapString);
+
+                    fKeySet.add(keyChar);
+                }
+
+                // Input data is now all parsed and collected.
+                // Now create the run-time binary form of the data.
+                //
+                // This is done in two steps. First the data is assembled into vectors and strings,
+                // for ease of construction, then the contents of these collections are copied
+                // into the actual SpoofData object.
+
+                // Build up the string array, and record the index of each string therein
+                // in the (build time only) string pool.
+                // Strings of length one are not entered into the strings array.
+                // (Strings in the table are sorted by length)
+
+                stringPool.sort();
+                fStringTable = new StringBuffer();
+                int poolSize = stringPool.size();
+                int i;
+                for (i = 0; i < poolSize; i++) {
+                    SPUString s = stringPool.getByIndex(i);
+                    int strLen = s.fStr.length();
+                    int strIndex = fStringTable.length();
+                    if (strLen == 1) {
+                        // strings of length one do not get an entry in the string table.
+                        // Keep the single string character itself here, which is the same
+                        // convention that is used in the final run-time string table index.
+                        s.fCharOrStrTableIndex = s.fStr.charAt(0);
+                    } else {
+                        s.fCharOrStrTableIndex = strIndex;
+                        fStringTable.append(s.fStr);
+                    }
+                }
+
+                // Construct the compile-time Key and Value table.
+                //
+                // The keys in the Key table follow the format described in uspoof.h for the
+                // Cfu confusables data structure.
+                //
+                // Starting in ICU 58, each code point has exactly one entry in the data
+                // structure.
+
+                for (String keyCharStr : fKeySet) {
+                    int keyChar = keyCharStr.codePointAt(0);
+                    SPUString targetMapping = fTable.get(keyChar);
+                    assert targetMapping != null;
+
+                    // Throw a sane exception if trying to consume a long string.  Otherwise,
+                    // codePointAndLengthToKey will throw an assertion error.
+                    if (targetMapping.fStr.length() > 256) {
+                        throw new IllegalArgumentException("Confusable prototypes cannot be longer than 256 entries.");
+                    }
+
+                    int key = ConfusableDataUtils.codePointAndLengthToKey(keyChar, targetMapping.fStr.length());
+                    int value = targetMapping.fCharOrStrTableIndex;
+
+                    fKeyVec.add(key);
+                    fValueVec.add(value);
+                }
+
+                // Put the assembled data into the destination SpoofData object.
+
+                // The Key Table
+                // While copying the keys to the output array,
+                // also sanity check that the keys are sorted.
+                int numKeys = fKeyVec.size();
+                dest.fCFUKeys = new int[numKeys];
+                int previousCodePoint = 0;
+                for (i = 0; i < numKeys; i++) {
+                    int key = fKeyVec.get(i);
+                    int codePoint = ConfusableDataUtils.keyToCodePoint(key);
+                    // strictly greater because there can be only one entry per code point
+                    assert codePoint > previousCodePoint;
+                    dest.fCFUKeys[i] = key;
+                    previousCodePoint = codePoint;
+                }
+
+                // The Value Table, parallels the key table
+                int numValues = fValueVec.size();
+                assert (numKeys == numValues);
+                dest.fCFUValues = new short[numValues];
+                i = 0;
+                for (int value : fValueVec) {
+                    assert (value < 0xffff);
+                    dest.fCFUValues[i++] = (short) value;
+                }
+
+                // The Strings Table.
+                dest.fCFUStrings = fStringTable.toString();
+            }
+
+            public static void buildConfusableData(Reader confusables, SpoofData dest)
+                    throws java.io.IOException, ParseException {
+                ConfusabledataBuilder builder = new ConfusabledataBuilder();
+                builder.build(confusables, dest);
+            }
+
+            /*
+             * *****************************************************************************
+             * Internal classes for compiling confusable data into its binary (runtime) form.
+             * *****************************************************************************
+             */
+            // SPUString
+            // Holds a string that is the result of one of the mappings defined
+            // by the confusable mapping data (confusables.txt from Unicode.org)
+            // Instances of SPUString exist during the compilation process only.
+
+            private static class SPUString {
+                String fStr; // The actual string.
+                int fCharOrStrTableIndex; // Index into the final runtime data for this string.
+                // (or, for length 1, the single string char itself,
+                // there being no string table entry for it.)
+
+                SPUString(String s) {
+                    fStr = s;
+                    fCharOrStrTableIndex = 0;
+                }
+            }
+
+            // Comparison function for ordering strings in the string pool.
+            // Compare by length first, then, within a group of the same length,
+            // by code point order.
+
+            private static class SPUStringComparator implements Comparator<SPUString> {
+                @Override
+                public int compare(SPUString sL, SPUString sR) {
+                    int lenL = sL.fStr.length();
+                    int lenR = sR.fStr.length();
+                    if (lenL < lenR) {
+                        return -1;
+                    } else if (lenL > lenR) {
+                        return 1;
+                    } else {
+                        return sL.fStr.compareTo(sR.fStr);
+                    }
+                }
+
+                final static SPUStringComparator INSTANCE = new SPUStringComparator();
+            }
+
+            // String Pool A utility class for holding the strings that are the result of
+            // the spoof mappings. These strings will utimately end up in the
+            // run-time String Table.
+            // This is sort of like a sorted set of strings, except that ICU's anemic
+            // built-in collections don't support those, so it is implemented with a
+            // combination of a uhash and a Vector.
+            private static class SPUStringPool {
+                public SPUStringPool() {
+                    fVec = new Vector<SPUString>();
+                    fHash = new Hashtable<String, SPUString>();
+                }
+
+                public int size() {
+                    return fVec.size();
+                }
+
+                // Get the n-th string in the collection.
+                public SPUString getByIndex(int index) {
+                    SPUString retString = fVec.elementAt(index);
+                    return retString;
+                }
+
+                // Add a string. Return the string from the table.
+                // If the input parameter string is already in the table, delete the
+                // input parameter and return the existing string.
+                public SPUString addString(String src) {
+                    SPUString hashedString = fHash.get(src);
+                    if (hashedString == null) {
+                        hashedString = new SPUString(src);
+                        fHash.put(src, hashedString);
+                        fVec.addElement(hashedString);
+                    }
+                    return hashedString;
+                }
+
+                // Sort the contents; affects the ordering of getByIndex().
+                public void sort() {
+                    Collections.sort(fVec, SPUStringComparator.INSTANCE);
+                }
+
+                private Vector<SPUString> fVec; // Elements are SPUString *
+                private Hashtable<String, SPUString> fHash; // Key: Value:
+            }
+
+        }
+    }
+
+    /**
+     * Get the Restriction Level that is being tested.
+     *
+     * @return The restriction level
+     * @internal
+     * @deprecated This API is ICU internal only.
+     */
+    @Deprecated
+    public RestrictionLevel getRestrictionLevel() {
+        return fRestrictionLevel;
+    }
+
+    /**
+     * Get the set of checks that this Spoof Checker has been configured to perform.
+     *
+     * @return The set of checks that this spoof checker will perform.
+     * @stable ICU 4.6
+     */
+    public int getChecks() {
+        return fChecks;
+    }
+
+    /**
+     * Get a read-only set of locales for the scripts that are acceptable in strings to be checked. If no limitations on
+     * scripts have been specified, an empty set will be returned.
+     *
+     * setAllowedChars() will reset the list of allowed locales to be empty.
+     *
+     * The returned set may not be identical to the originally specified set that is supplied to setAllowedLocales();
+     * the information other than languages from the originally specified locales may be omitted.
+     *
+     * @return A set of locales corresponding to the acceptable scripts.
+     *
+     * @stable ICU 4.6
+     */
+    public Set<ULocale> getAllowedLocales() {
+        return Collections.unmodifiableSet(fAllowedLocales);
+    }
+
+    /**
+     * Get a set of {@link java.util.Locale} instances for the scripts that are acceptable in strings to be checked. If
+     * no limitations on scripts have been specified, an empty set will be returned.
+     *
+     * @return A set of locales corresponding to the acceptable scripts.
+     * @stable ICU 54
+     */
+    public Set<Locale> getAllowedJavaLocales() {
+        HashSet<Locale> locales = new HashSet<Locale>(fAllowedLocales.size());
+        for (ULocale uloc : fAllowedLocales) {
+            locales.add(uloc.toLocale());
+        }
+        return locales;
+    }
+
+    /**
+     * Get a UnicodeSet for the characters permitted in an identifier. This corresponds to the limits imposed by the Set
+     * Allowed Characters functions. Limitations imposed by other checks will not be reflected in the set returned by
+     * this function.
+     *
+     * The returned set will be frozen, meaning that it cannot be modified by the caller.
+     *
+     * @return A UnicodeSet containing the characters that are permitted by the CHAR_LIMIT test.
+     * @stable ICU 4.6
+     */
+    public UnicodeSet getAllowedChars() {
+        return fAllowedCharsSet;
+    }
+
+    /**
+     * A struct-like class to hold the results of a Spoof Check operation. Tells which check(s) have failed.
+     *
+     * @stable ICU 4.6
+     */
+    public static class CheckResult {
+        /**
+         * Indicates which of the spoof check(s) have failed. The value is a bitwise OR of the constants for the tests
+         * in question: RESTRICTION_LEVEL, CHAR_LIMIT, and so on.
+         *
+         * @stable ICU 4.6
+         * @see Builder#setChecks
+         */
+        public int checks;
+
+        /**
+         * The index of the first string position that failed a check.
+         *
+         * @deprecated ICU 51. No longer supported. Always set to zero.
+         */
+        @Deprecated
+        public int position;
+
+        /**
+         * The numerics found in the string, if MIXED_NUMBERS was set; otherwise null.  The set will contain the zero
+         * digit from each decimal number system found in the input string.
+         *
+         * @draft ICU 58
+         * @provisional This API might change or be removed in a future release.
+         */
+        public UnicodeSet numerics;
+
+        /**
+         * The restriction level that the text meets, if RESTRICTION_LEVEL is set; otherwise null.
+         *
+         * @draft ICU 58
+         * @provisional This API might change or be removed in a future release.
+         */
+        public RestrictionLevel restrictionLevel;
+
+        /**
+         * Default constructor
+         *
+         * @stable ICU 4.6
+         */
+        public CheckResult() {
+            checks = 0;
+            position = 0;
+        }
+
+        /**
+         * {@inheritDoc}
+         *
+         * @stable ICU 4.6
+         */
+        @Override
+        public String toString() {
+            StringBuilder sb = new StringBuilder();
+            sb.append("checks:");
+            if (checks == 0) {
+                sb.append(" none");
+            } else if (checks == ALL_CHECKS) {
+                sb.append(" all");
+            } else {
+                if ((checks & SINGLE_SCRIPT_CONFUSABLE) != 0) {
+                    sb.append(" SINGLE_SCRIPT_CONFUSABLE");
+                }
+                if ((checks & MIXED_SCRIPT_CONFUSABLE) != 0) {
+                    sb.append(" MIXED_SCRIPT_CONFUSABLE");
+                }
+                if ((checks & WHOLE_SCRIPT_CONFUSABLE) != 0) {
+                    sb.append(" WHOLE_SCRIPT_CONFUSABLE");
+                }
+                if ((checks & ANY_CASE) != 0) {
+                    sb.append(" ANY_CASE");
+                }
+                if ((checks & RESTRICTION_LEVEL) != 0) {
+                    sb.append(" RESTRICTION_LEVEL");
+                }
+                if ((checks & INVISIBLE) != 0) {
+                    sb.append(" INVISIBLE");
+                }
+                if ((checks & CHAR_LIMIT) != 0) {
+                    sb.append(" CHAR_LIMIT");
+                }
+                if ((checks & MIXED_NUMBERS) != 0) {
+                    sb.append(" MIXED_NUMBERS");
+                }
+            }
+            sb.append(", numerics: ").append(numerics.toPattern(false));
+            sb.append(", position: ").append(position);
+            sb.append(", restrictionLevel: ").append(restrictionLevel);
+            return sb.toString();
+        }
+    }
+
+    /**
+     * Check the specified string for possible security issues. The text to be checked will typically be an identifier
+     * of some sort. The set of checks to be performed was specified when building the SpoofChecker.
+     *
+     * @param text
+     *            A String to be checked for possible security issues.
+     * @param checkResult
+     *            Output parameter, indicates which specific tests failed. May be null if the information is not wanted.
+     * @return True there any issue is found with the input string.
+     * @stable ICU 4.8
+     */
+    public boolean failsChecks(String text, CheckResult checkResult) {
+        int length = text.length();
+
+        int result = 0;
+        if (checkResult != null) {
+            checkResult.position = 0;
+            checkResult.numerics = null;
+            checkResult.restrictionLevel = null;
+        }
+
+        if (0 != (this.fChecks & RESTRICTION_LEVEL)) {
+            RestrictionLevel textRestrictionLevel = getRestrictionLevel(text);
+            if (textRestrictionLevel.compareTo(fRestrictionLevel) > 0) {
+                result |= RESTRICTION_LEVEL;
+            }
+            if (checkResult != null) {
+                checkResult.restrictionLevel = textRestrictionLevel;
+            }
+        }
+
+        if (0 != (this.fChecks & MIXED_NUMBERS)) {
+            UnicodeSet numerics = new UnicodeSet();
+            getNumerics(text, numerics);
+            if (numerics.size() > 1) {
+                result |= MIXED_NUMBERS;
+            }
+            if (checkResult != null) {
+                checkResult.numerics = numerics;
+            }
+        }
+
+        if (0 != (this.fChecks & CHAR_LIMIT)) {
+            int i;
+            int c;
+            for (i = 0; i < length;) {
+                // U16_NEXT(text, i, length, c);
+                c = Character.codePointAt(text, i);
+                i = Character.offsetByCodePoints(text, i, 1);
+                if (!this.fAllowedCharsSet.contains(c)) {
+                    result |= CHAR_LIMIT;
+                    break;
+                }
+            }
+        }
+
+        if (0 != (this.fChecks & INVISIBLE)) {
+            // This check needs to be done on NFD input
+            String nfdText = nfdNormalizer.normalize(text);
+
+            // scan for more than one occurrence of the same non-spacing mark
+            // in a sequence of non-spacing marks.
+            int i;
+            int c;
+            int firstNonspacingMark = 0;
+            boolean haveMultipleMarks = false;
+            UnicodeSet marksSeenSoFar = new UnicodeSet(); // Set of combining marks in a
+                                                          // single combining sequence.
+            for (i = 0; i < length;) {
+                c = Character.codePointAt(nfdText, i);
+                i = Character.offsetByCodePoints(nfdText, i, 1);
+                if (Character.getType(c) != UCharacterCategory.NON_SPACING_MARK) {
+                    firstNonspacingMark = 0;
+                    if (haveMultipleMarks) {
+                        marksSeenSoFar.clear();
+                        haveMultipleMarks = false;
+                    }
+                    continue;
+                }
+                if (firstNonspacingMark == 0) {
+                    firstNonspacingMark = c;
+                    continue;
+                }
+                if (!haveMultipleMarks) {
+                    marksSeenSoFar.add(firstNonspacingMark);
+                    haveMultipleMarks = true;
+                }
+                if (marksSeenSoFar.contains(c)) {
+                    // report the error, and stop scanning.
+                    // No need to find more than the first failure.
+                    result |= INVISIBLE;
+                    break;
+                }
+                marksSeenSoFar.add(c);
+            }
+        }
+        if (checkResult != null) {
+            checkResult.checks = result;
+        }
+        return (0 != result);
+    }
+
+    /**
+     * Check the specified string for possible security issues. The text to be checked will typically be an identifier
+     * of some sort. The set of checks to be performed was specified when building the SpoofChecker.
+     *
+     * @param text
+     *            A String to be checked for possible security issues.
+     * @return True there any issue is found with the input string.
+     * @stable ICU 4.8
+     */
+    public boolean failsChecks(String text) {
+        return failsChecks(text, null);
+    }
+
+    /**
+     * Check the whether two specified strings are visually confusable. The types of confusability to be tested - single
+     * script, mixed script, or whole script - are determined by the check options set for the SpoofChecker.
+     *
+     * The tests to be performed are controlled by the flags SINGLE_SCRIPT_CONFUSABLE MIXED_SCRIPT_CONFUSABLE
+     * WHOLE_SCRIPT_CONFUSABLE At least one of these tests must be selected.
+     *
+     * ANY_CASE is a modifier for the tests. Select it if the identifiers may be of mixed case. If identifiers are case
+     * folded for comparison and display to the user, do not select the ANY_CASE option.
+     *
+     *
+     * @param s1
+     *            The first of the two strings to be compared for confusability.
+     * @param s2
+     *            The second of the two strings to be compared for confusability.
+     * @return Non-zero if s1 and s1 are confusable. If not 0, the value will indicate the type(s) of confusability
+     *         found, as defined by spoof check test constants.
+     * @stable ICU 4.6
+     */
+    public int areConfusable(String s1, String s2) {
+        //
+        // See section 4 of UAX 39 for the algorithm for checking whether two strings are confusable,
+        // and for definitions of the types (single, whole, mixed-script) of confusables.
+
+        // We only care about a few of the check flags. Ignore the others.
+        // If no tests relevant to this function have been specified, signal an error.
+        // TODO: is this really the right thing to do? It's probably an error on
+        // the caller's part, but logically we would just return 0 (no error).
+        if ((this.fChecks & CONFUSABLE) == 0) {
+            throw new IllegalArgumentException("No confusable checks are enabled.");
+        }
+
+        // Compute the skeletons and check for confusability.
+        String s1Skeleton = getSkeleton(s1);
+        String s2Skeleton = getSkeleton(s2);
+        if (!s1Skeleton.equals(s2Skeleton)) {
+            return 0;
+        }
+
+        // If we get here, the strings are confusable. Now we just need to set the flags for the appropriate classes
+        // of confusables according to UTS 39 section 4.
+        // Start by computing the resolved script sets of s1 and s2.
+        ScriptSet s1RSS = new ScriptSet();
+        getResolvedScriptSet(s1, s1RSS);
+        ScriptSet s2RSS = new ScriptSet();
+        getResolvedScriptSet(s2, s2RSS);
+
+        // Turn on all applicable flags
+        int result = 0;
+        if (s1RSS.intersects(s2RSS)) {
+            result |= SINGLE_SCRIPT_CONFUSABLE;
+        } else {
+            result |= MIXED_SCRIPT_CONFUSABLE;
+            if (!s1RSS.isEmpty() && !s2RSS.isEmpty()) {
+                result |= WHOLE_SCRIPT_CONFUSABLE;
+            }
+        }
+
+        // Turn off flags that the user doesn't want
+        result &= fChecks;
+
+        return result;
+    }
+
+    /**
+     * Get the "skeleton" for an identifier string. Skeletons are a transformation of the input string; Two strings are
+     * confusable if their skeletons are identical. See Unicode UAX 39 for additional information.
+     *
+     * Using skeletons directly makes it possible to quickly check whether an identifier is confusable with any of some
+     * large set of existing identifiers, by creating an efficiently searchable collection of the skeletons.
+     *
+     * Skeletons are computed using the algorithm and data described in Unicode UAX 39.
+     *
+     * @param str
+     *            The input string whose skeleton will be generated.
+     * @return The output skeleton string.
+     *
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public String getSkeleton(CharSequence str) {
+        // Apply the skeleton mapping to the NFD normalized input string
+        // Accumulate the skeleton, possibly unnormalized, in a String.
+        String nfdId = nfdNormalizer.normalize(str);
+        int normalizedLen = nfdId.length();
+        StringBuilder skelSB = new StringBuilder();
+        for (int inputIndex = 0; inputIndex < normalizedLen;) {
+            int c = Character.codePointAt(nfdId, inputIndex);
+            inputIndex += Character.charCount(c);
+            this.fSpoofData.confusableLookup(c, skelSB);
+        }
+        String skelStr = skelSB.toString();
+        skelStr = nfdNormalizer.normalize(skelStr);
+        return skelStr;
+    }
+
+    /**
+     * Calls {@link SpoofChecker#getSkeleton(CharSequence id)}. Starting with ICU 55, the "type" parameter has been
+     * ignored, and starting with ICU 58, this function has been deprecated.
+     *
+     * @param type
+     *            No longer supported. Prior to ICU 55, was used to specify the mapping table SL, SA, ML, or MA.
+     * @param id
+     *            The input identifier whose skeleton will be generated.
+     * @return The output skeleton string.
+     *
+     * @deprecated ICU 58
+     */
+    @Deprecated
+    public String getSkeleton(int type, String id) {
+        return getSkeleton(id);
+    }
+
+    /**
+     * Equality function. Return true if the two SpoofChecker objects incorporate the same confusable data and have
+     * enabled the same set of checks.
+     *
+     * @param other
+     *            the SpoofChecker being compared with.
+     * @return true if the two SpoofCheckers are equal.
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    @Override
+    public boolean equals(Object other) {
+        if (!(other instanceof SpoofChecker)) {
+            return false;
+        }
+        SpoofChecker otherSC = (SpoofChecker) other;
+        if (fSpoofData != otherSC.fSpoofData && fSpoofData != null && !fSpoofData.equals(otherSC.fSpoofData)) {
+            return false;
+        }
+        if (fChecks != otherSC.fChecks) {
+            return false;
+        }
+        if (fAllowedLocales != otherSC.fAllowedLocales && fAllowedLocales != null
+                && !fAllowedLocales.equals(otherSC.fAllowedLocales)) {
+            return false;
+        }
+        if (fAllowedCharsSet != otherSC.fAllowedCharsSet && fAllowedCharsSet != null
+                && !fAllowedCharsSet.equals(otherSC.fAllowedCharsSet)) {
+            return false;
+        }
+        if (fRestrictionLevel != otherSC.fRestrictionLevel) {
+            return false;
+        }
+        return true;
+    }
+
+    /**
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    @Override
+    public int hashCode() {
+        return fChecks
+                ^ fSpoofData.hashCode()
+                ^ fAllowedLocales.hashCode()
+                ^ fAllowedCharsSet.hashCode()
+                ^ fRestrictionLevel.ordinal();
+    }
+
+    /**
+     * Computes the augmented script set for a code point, according to UTS 39 section 5.1.
+     */
+    private static void getAugmentedScriptSet(int codePoint, ScriptSet result) {
+        result.clear();
+        UScript.getScriptExtensions(codePoint, result);
+
+        // Section 5.1 step 1
+        if (result.get(UScript.HAN)) {
+            result.set(UScript.HAN_WITH_BOPOMOFO);
+            result.set(UScript.JAPANESE);
+            result.set(UScript.KOREAN);
+        }
+        if (result.get(UScript.HIRAGANA)) {
+            result.set(UScript.JAPANESE);
+        }
+        if (result.get(UScript.KATAKANA)) {
+            result.set(UScript.JAPANESE);
+        }
+        if (result.get(UScript.HANGUL)) {
+            result.set(UScript.KOREAN);
+        }
+        if (result.get(UScript.BOPOMOFO)) {
+            result.set(UScript.HAN_WITH_BOPOMOFO);
+        }
+
+        // Section 5.1 step 2
+        if (result.get(UScript.COMMON) || result.get(UScript.INHERITED)) {
+            result.setAll();
+        }
+    }
+
+    /**
+     * Computes the resolved script set for a string, according to UTS 39 section 5.1.
+     */
+    private void getResolvedScriptSet(CharSequence input, ScriptSet result) {
+        getResolvedScriptSetWithout(input, UScript.CODE_LIMIT, result);
+    }
+
+    /**
+     * Computes the resolved script set for a string, omitting characters having the specified script. If
+     * UScript.CODE_LIMIT is passed as the second argument, all characters are included.
+     */
+    private void getResolvedScriptSetWithout(CharSequence input, int script, ScriptSet result) {
+        result.setAll();
+
+        ScriptSet temp = new ScriptSet();
+        for (int utf16Offset = 0; utf16Offset < input.length();) {
+            int codePoint = Character.codePointAt(input, utf16Offset);
+            utf16Offset += Character.charCount(codePoint);
+
+            // Compute the augmented script set for the character
+            getAugmentedScriptSet(codePoint, temp);
+
+            // Intersect the augmented script set with the resolved script set, but only if the character doesn't
+            // have the script specified in the function call
+            if (script == UScript.CODE_LIMIT || !temp.get(script)) {
+                result.and(temp);
+            }
+        }
+    }
+
+    /**
+     * Computes the set of numerics for a string, according to UTS 39 section 5.3.
+     */
+    private void getNumerics(String input, UnicodeSet result) {
+        result.clear();
+
+        for (int utf16Offset = 0; utf16Offset < input.length();) {
+            int codePoint = Character.codePointAt(input, utf16Offset);
+            utf16Offset += Character.charCount(codePoint);
+
+            // Store a representative character for each kind of decimal digit
+            if (UCharacter.getType(codePoint) == UCharacterCategory.DECIMAL_DIGIT_NUMBER) {
+                // Store the zero character as a representative for comparison.
+                // Unicode guarantees it is codePoint - value
+                result.add(codePoint - UCharacter.getNumericValue(codePoint));
+            }
+        }
+    }
+
+    /**
+     * Computes the restriction level of a string, according to UTS 39 section 5.2.
+     */
+    private RestrictionLevel getRestrictionLevel(String input) {
+        // Section 5.2 step 1:
+        if (!fAllowedCharsSet.containsAll(input)) {
+            return RestrictionLevel.UNRESTRICTIVE;
+        }
+
+        // Section 5.2 step 2:
+        if (ASCII.containsAll(input)) {
+            return RestrictionLevel.ASCII;
+        }
+
+        // Section 5.2 steps 3:
+        ScriptSet resolvedScriptSet = new ScriptSet();
+        getResolvedScriptSet(input, resolvedScriptSet);
+
+        // Section 5.2 step 4:
+        if (!resolvedScriptSet.isEmpty()) {
+            return RestrictionLevel.SINGLE_SCRIPT_RESTRICTIVE;
+        }
+
+        // Section 5.2 step 5:
+        ScriptSet resolvedNoLatn = new ScriptSet();
+        getResolvedScriptSetWithout(input, UScript.LATIN, resolvedNoLatn);
+
+        // Section 5.2 step 6:
+        if (resolvedNoLatn.get(UScript.HAN_WITH_BOPOMOFO) || resolvedNoLatn.get(UScript.JAPANESE)
+                || resolvedNoLatn.get(UScript.KOREAN)) {
+            return RestrictionLevel.HIGHLY_RESTRICTIVE;
+        }
+
+        // Section 5.2 step 7:
+        if (!resolvedNoLatn.isEmpty() && !resolvedNoLatn.get(UScript.CYRILLIC) && !resolvedNoLatn.get(UScript.GREEK)
+                && !resolvedNoLatn.get(UScript.CHEROKEE)) {
+            return RestrictionLevel.MODERATELY_RESTRICTIVE;
+        }
+
+        // Section 5.2 step 8:
+        return RestrictionLevel.MINIMALLY_RESTRICTIVE;
+    }
+
+    // Data Members
+    private int fChecks; // Bit vector of checks to perform.
+    private SpoofData fSpoofData;
+    private Set<ULocale> fAllowedLocales; // The Set of allowed locales.
+    private UnicodeSet fAllowedCharsSet; // The UnicodeSet of allowed characters.
+    private RestrictionLevel fRestrictionLevel;
+
+    private static Normalizer2 nfdNormalizer = Normalizer2.getNFDInstance();
+
+    // Confusable Mappings Data Structures, version 2.0
+    //
+    // This description and the corresponding implementation are to be kept
+    // in-sync with the copy in icu4c uspoof_impl.h.
+    //
+    // For the confusable data, we are essentially implementing a map,
+    //     key: a code point
+    //     value: a string. Most commonly one char in length, but can be more.
+    //
+    // The keys are stored as a sorted array of 32 bit ints.
+    //         bits 0-23 a code point value
+    //         bits 24-31 length of value string, in UChars (between 1 and 256 UChars).
+    //     The key table is sorted in ascending code point order. (not on the
+    //     32 bit int value, the flag bits do not participate in the sorting.)
+    //
+    //     Lookup is done by means of a binary search in the key table.
+    //
+    // The corresponding values are kept in a parallel array of 16 bit ints.
+    //     If the value string is of length 1, it is literally in the value array.
+    //     For longer strings, the value array contains an index into the strings
+    //     table.
+    //
+    // String Table:
+    //     The strings table contains all of the value strings (those of length two or greater)
+    //     concatentated together into one long char (UTF-16) array.
+    //
+    //     There is no nul character or other mark between adjacent strings.
+    //
+    //----------------------------------------------------------------------------
+    //
+    //  Changes from format version 1 to format version 2:
+    //        1) Removal of the whole-script confusable data tables.
+    //        2) Removal of the SL/SA/ML/MA and multi-table flags in the key bitmask.
+    //        3) Expansion of string length value in the key bitmask from 2 bits to 8 bits.
+    //        4) Removal of the string lengths table since 8 bits is sufficient for the
+    //           lengths of all entries in confusables.txt.
+    //
+    private static final class ConfusableDataUtils {
+        public static final int FORMAT_VERSION = 2; // version for ICU 58
+
+        public static final int keyToCodePoint(int key) {
+            return key & 0x00ffffff;
+        }
+
+        public static final int keyToLength(int key) {
+            return ((key & 0xff000000) >> 24) + 1;
+        }
+
+        public static final int codePointAndLengthToKey(int codePoint, int length) {
+            assert (codePoint & 0x00ffffff) == codePoint;
+            assert length <= 256;
+            return codePoint | ((length - 1) << 24);
+        }
+    }
+
+    // -------------------------------------------------------------------------------------
+    //
+    // SpoofData
+    //
+    // This class corresponds to the ICU SpoofCheck data.
+    //
+    // The data can originate with the Binary ICU data that is generated in ICU4C,
+    // or it can originate from source rules that are compiled in ICU4J.
+    //
+    // This class does not include the set of checks to be performed, but only
+    // data that is serialized into the ICU binary data.
+    //
+    // Because Java cannot easily wrap binary data like ICU4C, the binary data is
+    // copied into Java structures that are convenient for use by the run time code.
+    //
+    // ---------------------------------------------------------------------------------------
+    private static class SpoofData {
+
+        // The Confusable data, Java data structures for.
+        int[] fCFUKeys;
+        short[] fCFUValues;
+        String fCFUStrings;
+
+        private static final int DATA_FORMAT = 0x43667520; // "Cfu "
+
+        private static final class IsAcceptable implements Authenticate {
+            @Override
+            public boolean isDataVersionAcceptable(byte version[]) {
+                return version[0] == ConfusableDataUtils.FORMAT_VERSION || version[1] != 0 || version[2] != 0
+                        || version[3] != 0;
+            }
+        }
+
+        private static final IsAcceptable IS_ACCEPTABLE = new IsAcceptable();
+
+        private static final class DefaultData {
+            private static SpoofData INSTANCE = null;
+            private static IOException EXCEPTION = null;
+
+            static {
+                // Note: Although this is static, the Java runtime can delay execution of this block until
+                // the data is actually requested via SpoofData.getDefault().
+                try {
+                    INSTANCE = new SpoofData(ICUBinary.getRequiredData("confusables.cfu"));
+                } catch (IOException e) {
+                    EXCEPTION = e;
+                }
+            }
+        }
+
+        /**
+         * @return instance for Unicode standard data
+         */
+        public static SpoofData getDefault() {
+            if (DefaultData.EXCEPTION != null) {
+                throw new MissingResourceException(
+                        "Could not load default confusables data: " + DefaultData.EXCEPTION.getMessage(),
+                        "SpoofChecker", "");
+            }
+            return DefaultData.INSTANCE;
+        }
+
+        // SpoofChecker Data constructor for use from data builder.
+        // Initializes a new, empty data area that will be populated later.
+        private SpoofData() {
+        }
+
+        // Constructor for use when creating from prebuilt default data.
+        // A ByteBuffer is what the ICU internal data loading functions provide.
+        private SpoofData(ByteBuffer bytes) throws java.io.IOException {
+            ICUBinary.readHeader(bytes, DATA_FORMAT, IS_ACCEPTABLE);
+            bytes.mark();
+            readData(bytes);
+        }
+
+        @Override
+        public boolean equals(Object other) {
+            if (!(other instanceof SpoofData)) {
+                return false;
+            }
+            SpoofData otherData = (SpoofData) other;
+            if (!Arrays.equals(fCFUKeys, otherData.fCFUKeys))
+                return false;
+            if (!Arrays.equals(fCFUValues, otherData.fCFUValues))
+                return false;
+            if (!Utility.sameObjects(fCFUStrings, otherData.fCFUStrings) && fCFUStrings != null
+                    && !fCFUStrings.equals(otherData.fCFUStrings))
+                return false;
+            return true;
+        }
+
+        @Override
+        public int hashCode() {
+            return Arrays.hashCode(fCFUKeys)
+                    ^ Arrays.hashCode(fCFUValues)
+                    ^ fCFUStrings.hashCode();
+        }
+
+        // Set the SpoofChecker data from pre-built binary data in a byte buffer.
+        // The binary data format is as described for ICU4C spoof data.
+        //
+        private void readData(ByteBuffer bytes) throws java.io.IOException {
+            int magic = bytes.getInt();
+            if (magic != 0x3845fdef) {
+                throw new IllegalArgumentException("Bad Spoof Check Data.");
+            }
+            @SuppressWarnings("unused")
+            int dataFormatVersion = bytes.getInt();
+            @SuppressWarnings("unused")
+            int dataLength = bytes.getInt();
+
+            int CFUKeysOffset = bytes.getInt();
+            int CFUKeysSize = bytes.getInt();
+
+            int CFUValuesOffset = bytes.getInt();
+            int CFUValuesSize = bytes.getInt();
+
+            int CFUStringTableOffset = bytes.getInt();
+            int CFUStringTableSize = bytes.getInt();
+
+            // We have now read the file header, and obtained the position for each
+            // of the data items. Now read each in turn, first seeking the
+            // input stream to the position of the data item.
+
+            bytes.reset();
+            ICUBinary.skipBytes(bytes, CFUKeysOffset);
+            fCFUKeys = ICUBinary.getInts(bytes, CFUKeysSize, 0);
+
+            bytes.reset();
+            ICUBinary.skipBytes(bytes, CFUValuesOffset);
+            fCFUValues = ICUBinary.getShorts(bytes, CFUValuesSize, 0);
+
+            bytes.reset();
+            ICUBinary.skipBytes(bytes, CFUStringTableOffset);
+            fCFUStrings = ICUBinary.getString(bytes, CFUStringTableSize, 0);
+        }
+
+        /**
+         * Append the confusable skeleton transform for a single code point to a StringBuilder. The string to be
+         * appended will between 1 and 18 characters as of Unicode 9.
+         *
+         * This is the heart of the confusable skeleton generation implementation.
+         */
+        public void confusableLookup(int inChar, StringBuilder dest) {
+            // Perform a binary search.
+            // [lo, hi), i.e lo is inclusive, hi is exclusive.
+            // The result after the loop will be in lo.
+            int lo = 0;
+            int hi = length();
+            do {
+                int mid = (lo + hi) / 2;
+                if (codePointAt(mid) > inChar) {
+                    hi = mid;
+                } else if (codePointAt(mid) < inChar) {
+                    lo = mid;
+                } else {
+                    // Found result. Break early.
+                    lo = mid;
+                    break;
+                }
+            } while (hi - lo > 1);
+
+            // Did we find an entry? If not, the char maps to itself.
+            if (codePointAt(lo) != inChar) {
+                dest.appendCodePoint(inChar);
+                return;
+            }
+
+            // Add the element to the string builder and return.
+            appendValueTo(lo, dest);
+            return;
+        }
+
+        /**
+         * Return the number of confusable entries in this SpoofData.
+         *
+         * @return The number of entries.
+         */
+        public int length() {
+            return fCFUKeys.length;
+        }
+
+        /**
+         * Return the code point (key) at the specified index.
+         *
+         * @param index
+         *            The index within the SpoofData.
+         * @return The code point.
+         */
+        public int codePointAt(int index) {
+            return ConfusableDataUtils.keyToCodePoint(fCFUKeys[index]);
+        }
+
+        /**
+         * Append the confusable skeleton at the specified index to the StringBuilder dest.
+         *
+         * @param index
+         *            The index within the SpoofData.
+         * @param dest
+         *            The StringBuilder to which to append the skeleton.
+         */
+        public void appendValueTo(int index, StringBuilder dest) {
+            int stringLength = ConfusableDataUtils.keyToLength(fCFUKeys[index]);
+
+            // Value is either a char (for strings of length 1) or
+            // an index into the string table (for longer strings)
+            short value = fCFUValues[index];
+            if (stringLength == 1) {
+                dest.append((char) value);
+            } else {
+                dest.append(fCFUStrings, value, value + stringLength);
+            }
+        }
+    }
+
+    // -------------------------------------------------------------------------------
+    //
+    // ScriptSet - Script code bit sets.
+    // Extends Java BitSet with input/output support and a few helper methods.
+    // Note: The I/O is not currently being used, so it has been commented out. If
+    // it is needed again, the code can be restored.
+    //
+    // -------------------------------------------------------------------------------
+    static class ScriptSet extends BitSet {
+
+        // Eclipse default value to quell warnings:
+        private static final long serialVersionUID = 1L;
+
+        // // The serialized version of this class can hold INT_CAPACITY * 32 scripts.
+        // private static final int INT_CAPACITY = 6;
+        // private static final long serialVersionUID = INT_CAPACITY;
+        // static {
+        // assert ScriptSet.INT_CAPACITY * Integer.SIZE <= UScript.CODE_LIMIT;
+        // }
+        //
+        // public ScriptSet() {
+        // }
+        //
+        // public ScriptSet(ByteBuffer bytes) throws java.io.IOException {
+        // for (int i = 0; i < INT_CAPACITY; i++) {
+        // int bits = bytes.getInt();
+        // for (int j = 0; j < Integer.SIZE; j++) {
+        // if ((bits & (1 << j)) != 0) {
+        // set(i * Integer.SIZE + j);
+        // }
+        // }
+        // }
+        // }
+        //
+        // public void output(DataOutputStream os) throws java.io.IOException {
+        // for (int i = 0; i < INT_CAPACITY; i++) {
+        // int bits = 0;
+        // for (int j = 0; j < Integer.SIZE; j++) {
+        // if (get(i * Integer.SIZE + j)) {
+        // bits |= (1 << j);
+        // }
+        // }
+        // os.writeInt(bits);
+        // }
+        // }
+
+        public void and(int script) {
+            this.clear(0, script);
+            this.clear(script + 1, UScript.CODE_LIMIT);
+        }
+
+        public void setAll() {
+            this.set(0, UScript.CODE_LIMIT);
+        }
+
+        public boolean isFull() {
+            return cardinality() == UScript.CODE_LIMIT;
+        }
+
+        public void appendStringTo(StringBuilder sb) {
+            sb.append("{ ");
+            if (isEmpty()) {
+                sb.append("- ");
+            } else if (isFull()) {
+                sb.append("* ");
+            } else {
+                for (int script = 0; script < UScript.CODE_LIMIT; script++) {
+                    if (get(script)) {
+                        sb.append(UScript.getShortName(script));
+                        sb.append(" ");
+                    }
+                }
+            }
+            sb.append("}");
+        }
+
+        @Override
+        public String toString() {
+            StringBuilder sb = new StringBuilder();
+            sb.append("<ScriptSet ");
+            appendStringTo(sb);
+            sb.append(">");
+            return sb.toString();
+        }
+    }
+}
diff --git a/app/src/main/java/com/ibm/icu/text/StringCharacterIterator.java b/icu4j/src/main/java/com/ibm/icu/text/StringCharacterIterator.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/StringCharacterIterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/StringCharacterIterator.java
index 244260c..f9ce834 100644
--- a/app/src/main/java/com/ibm/icu/text/StringCharacterIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/StringCharacterIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2014, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/StringMatcher.java b/icu4j/src/main/java/com/ibm/icu/text/StringMatcher.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/text/StringMatcher.java
rename to icu4j/src/main/java/com/ibm/icu/text/StringMatcher.java
index eefcc4c..fb56884 100644
--- a/app/src/main/java/com/ibm/icu/text/StringMatcher.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/StringMatcher.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2001-2004, International Business Machines Corporation and    *
@@ -36,7 +38,7 @@ class StringMatcher implements UnicodeMatcher, UnicodeReplacer {
      * match.
      */
     private int matchStart;
-    
+
     /**
      * Limit offset, in the match text, of the <em>rightmost</em>
      * match.
@@ -96,6 +98,7 @@ class StringMatcher implements UnicodeMatcher, UnicodeReplacer {
     /**
      * Implement UnicodeMatcher
      */
+    @Override
     public int matches(Replaceable text,
                        int[] offset,
                        int limit,
@@ -172,6 +175,7 @@ class StringMatcher implements UnicodeMatcher, UnicodeReplacer {
     /**
      * Implement UnicodeMatcher
      */
+    @Override
     public String toPattern(boolean escapeUnprintable) {
         StringBuffer result = new StringBuffer();
         StringBuffer quoteBuf = new StringBuffer();
@@ -200,6 +204,7 @@ class StringMatcher implements UnicodeMatcher, UnicodeReplacer {
     /**
      * Implement UnicodeMatcher
      */
+    @Override
     public boolean matchesIndexValue(int v) {
         if (pattern.length() == 0) {
             return true;
@@ -215,6 +220,7 @@ class StringMatcher implements UnicodeMatcher, UnicodeReplacer {
      * set.
      * @param toUnionTo the set into which to union the source characters
      */
+    @Override
     public void addMatchSetTo(UnicodeSet toUnionTo) {
         int ch;
         for (int i=0; i<pattern.length(); i+=UTF16.getCharCount(ch)) {
@@ -231,6 +237,7 @@ class StringMatcher implements UnicodeMatcher, UnicodeReplacer {
     /**
      * UnicodeReplacer API
      */
+    @Override
     public int replace(Replaceable text,
                        int start,
                        int limit,
@@ -257,6 +264,7 @@ class StringMatcher implements UnicodeMatcher, UnicodeReplacer {
     /**
      * UnicodeReplacer API
      */
+    @Override
     public String toReplacerPattern(boolean escapeUnprintable) {
         // assert(segmentNumber > 0);
         StringBuffer rule = new StringBuffer("$");
@@ -277,6 +285,7 @@ class StringMatcher implements UnicodeMatcher, UnicodeReplacer {
      * into the given set.
      * @param toUnionTo the set into which to union the output characters
      */
+    @Override
     public void addReplacementSetTo(UnicodeSet toUnionTo) {
         // The output of this replacer varies; it is the source text between
         // matchStart and matchLimit.  Since this varies depending on the
diff --git a/app/src/main/java/com/ibm/icu/text/StringPrep.java b/icu4j/src/main/java/com/ibm/icu/text/StringPrep.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/StringPrep.java
rename to icu4j/src/main/java/com/ibm/icu/text/StringPrep.java
index 1eccd4d..bdb6ebc 100644
--- a/app/src/main/java/com/ibm/icu/text/StringPrep.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/StringPrep.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2003-2015, International Business Machines Corporation and
@@ -225,8 +227,6 @@ public final class StringPrep {
     private int[] indexes;
     // mapping data read from the data file
     private char[] mappingData;
-    // format version of the data file
-    //private byte[] formatVersion;
     // the version of Unicode supported by the data file
     private VersionInfo sprepUniVer;
     // the Unicode version of last entry in the
@@ -285,9 +285,6 @@ public final class StringPrep {
         // load the rest of the data data and initialize the data members
         mappingData = reader.read(indexes[INDEX_MAPPING_DATA_SIZE]/2);
 
-        // get the data format version
-        /*formatVersion = */reader.getDataFormatVersion();
-
         // get the options
         doNFKC            = ((indexes[OPTIONS] & NORMALIZATION_ON) > 0);
         checkBiDi         = ((indexes[OPTIONS] & CHECK_BIDI_ON) > 0);
diff --git a/app/src/main/java/com/ibm/icu/text/StringPrepParseException.java b/icu4j/src/main/java/com/ibm/icu/text/StringPrepParseException.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/text/StringPrepParseException.java
rename to icu4j/src/main/java/com/ibm/icu/text/StringPrepParseException.java
index a321b41..1a73c86 100644
--- a/app/src/main/java/com/ibm/icu/text/StringPrepParseException.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/StringPrepParseException.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2003-2014, International Business Machines Corporation and    *
@@ -9,8 +11,8 @@ package com.ibm.icu.text;
 import java.text.ParseException;
 
 /**
- * Exception that signals an error has occurred while parsing the 
- * input to StringPrep or IDNA. 
+ * Exception that signals an error has occurred while parsing the
+ * input to StringPrep or IDNA.
  *
  * @author Ram Viswanadha
  * @stable ICU 2.8
@@ -18,7 +20,7 @@ import java.text.ParseException;
 public class StringPrepParseException extends ParseException {
     // Generated by serialver from JDK 1.4.1_01
     static final long serialVersionUID = 7160264827701651255L;
-    
+
     /**
      * @stable ICU 2.8
      */
@@ -59,21 +61,21 @@ public class StringPrepParseException extends ParseException {
      * @stable ICU 2.8
      */
     public static final int BUFFER_OVERFLOW_ERROR   = 9;
-    
+
     /**
      * @stable ICU 2.8
      */
     public static final int ZERO_LENGTH_LABEL   = 10;
-    
+
     /**
      * @stable ICU 3.8
      */
     public static final int DOMAIN_NAME_TOO_LONG_ERROR   = 11;
-    
+
     /**
      * Construct a ParseException object with the given message
      * and error code
-     * 
+     *
      * @param message A string describing the type of error that occurred
      * @param error   The error that has occurred
      * @stable ICU 2.8
@@ -83,31 +85,31 @@ public class StringPrepParseException extends ParseException {
         this.error = error;
         this.line = 0;
     }
-    
+
     /**
      * Construct a ParseException object with the given message and
      * error code
-     * 
+     *
      * @param message A string describing the type of error that occurred
      * @param error   The error that has occurred
-     * @param rules   The input rules string 
+     * @param rules   The input rules string
      * @param pos     The position of error in the rules string
      * @stable ICU 2.8
      */
     public StringPrepParseException(String message,int error, String rules, int pos){
         super(message, -1);
         this.error = error;
-        setContext(rules,pos);  
+        setContext(rules,pos);
         this.line = 0;
     }
     /**
      * Construct  a ParseException object with the given message and error code
-     * 
+     *
      * @param message    A string describing the type of error that occurred
      * @param error      The error that has occurred
-     * @param rules      The input rules string 
+     * @param rules      The input rules string
      * @param pos        The position of error in the rules string
-     * @param lineNumber The line number at which the error has occurred. 
+     * @param lineNumber The line number at which the error has occurred.
      *                   If the parse engine is not using this field, it should set it to zero.  Otherwise
      *                   it should be a positive integer. The default value of this field
      *                   is -1. It will be set to 0 if the code populating this struct is not
@@ -117,44 +119,47 @@ public class StringPrepParseException extends ParseException {
     public StringPrepParseException(String message, int error, String rules, int pos, int lineNumber){
         super(message, -1);
         this.error = error;
-        setContext(rules,pos);   
+        setContext(rules,pos);
         this.line = lineNumber;
     }
     /**
      * Compare this ParseException to another and evaluate if they are equal.
      * The comparison works only on the type of error and does not compare
      * the rules strings, if any, for equality.
-     * 
+     *
      * @param other The exception that this object should be compared to
      * @return true if the objects are equal, false if unequal
      * @stable ICU 2.8
      */
+    @Override
     public boolean equals(Object other){
         if(!(other instanceof StringPrepParseException)){
             return false;
         }
         return ((StringPrepParseException)other).error == this.error;
-        
+
     }
-    
+
     /**
      * Mock implementation of hashCode(). This implementation always returns a constant
      * value. When Java assertion is enabled, this method triggers an assertion failure.
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Override
     @Deprecated
     public int hashCode() {
         assert false : "hashCode not designed";
         return 42;
     }
-    
+
     /**
      * Returns the position of error in the rules string
-     * 
+     *
      * @return String
      * @stable ICU 2.8
      */
+    @Override
     public String toString(){
         StringBuilder buf = new StringBuilder();
         buf.append(super.getMessage());
@@ -169,7 +174,7 @@ public class StringPrepParseException extends ParseException {
     }
 
     private int error;
-    
+
     /**
      * The line on which the error occurred.  If the parse engine
      * is not using this field, it should set it to zero.  Otherwise
@@ -191,38 +196,38 @@ public class StringPrepParseException extends ParseException {
      * May be the empty string if not implemented by parser.
      */
     private StringBuffer postContext =  new StringBuffer();
-    
+
     private static final int PARSE_CONTEXT_LEN = 16;
-    
+
     private void setPreContext(String str, int pos){
         setPreContext(str.toCharArray(),pos);
     }
-    
+
     private void setPreContext(char[] str, int pos){
         int start = (pos <= PARSE_CONTEXT_LEN)? 0 : (pos - (PARSE_CONTEXT_LEN-1));
         int len = (start <= PARSE_CONTEXT_LEN)? start : PARSE_CONTEXT_LEN;
         preContext.append(str,start,len);
- 
+
     }
-    
+
     private void setPostContext(String str, int pos){
         setPostContext(str.toCharArray(),pos);
     }
-    
+
     private void setPostContext(char[] str, int pos){
         int start = pos;
-        int len  = str.length - start; 
+        int len  = str.length - start;
         postContext.append(str,start,len);
 
     }
-    
+
     private void setContext(String str,int pos){
         setPreContext(str,pos);
         setPostContext(str,pos);
     }
-    
+
     /**
-     * Returns the error code of this exception. 
+     * Returns the error code of this exception.
      * This method is only used for testing to verify the error.
      * @return The error code
      * @stable ICU 3.8
diff --git a/app/src/main/java/com/ibm/icu/text/StringReplacer.java b/icu4j/src/main/java/com/ibm/icu/text/StringReplacer.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/StringReplacer.java
rename to icu4j/src/main/java/com/ibm/icu/text/StringReplacer.java
index 5701631..3bd8d0e 100644
--- a/app/src/main/java/com/ibm/icu/text/StringReplacer.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/StringReplacer.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 **********************************************************************
 *   Copyright (c) 2002-2007, International Business Machines Corporation
@@ -108,6 +110,7 @@ class StringReplacer implements UnicodeReplacer {
     /**
      * UnicodeReplacer API
      */
+    @Override
     public int replace(Replaceable text,
                        int start,
                        int limit,
@@ -222,7 +225,7 @@ class StringReplacer implements UnicodeReplacer {
 
             // Delete the old text (the key)
             text.replace(start + outLen, limit + outLen, "");
-        }        
+        }
 
         if (hasCursor) {
             // Adjust the cursor for positions outside the key.  These
@@ -262,6 +265,7 @@ class StringReplacer implements UnicodeReplacer {
     /**
      * UnicodeReplacer API
      */
+    @Override
     public String toReplacerPattern(boolean escapeUnprintable) {
         StringBuffer rule = new StringBuffer();
         StringBuffer quoteBuf = new StringBuffer();
@@ -316,6 +320,7 @@ class StringReplacer implements UnicodeReplacer {
      * into the given set.
      * @param toUnionTo the set into which to union the output characters
      */
+    @Override
     public void addReplacementSetTo(UnicodeSet toUnionTo) {
         int ch;
         for (int i=0; i<output.length(); i+=UTF16.getCharCount(ch)) {
diff --git a/app/src/main/java/com/ibm/icu/text/StringSearch.java b/icu4j/src/main/java/com/ibm/icu/text/StringSearch.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/StringSearch.java
rename to icu4j/src/main/java/com/ibm/icu/text/StringSearch.java
index f19ee77..1223e8b 100644
--- a/app/src/main/java/com/ibm/icu/text/StringSearch.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/StringSearch.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and
@@ -1173,7 +1175,7 @@ public final class StringSearch extends SearchIterator {
             // * the match limit is a normalization boundary
             boolean allowMidclusterMatch =
                             breakIterator == null &&
-                            nextCEI != null && (((nextCEI.ce_) >>> 32) & 0xFFFF0000L) != 0 &&
+                            (((nextCEI.ce_) >>> 32) & 0xFFFF0000L) != 0 &&
                             maxLimit >= lastCEI.highIndex_ && nextCEI.highIndex_ > maxLimit &&
                             (nfd_.hasBoundaryBefore(codePointAt(targetText, maxLimit)) ||
                                     nfd_.hasBoundaryAfter(codePointBefore(targetText, maxLimit)));
@@ -1433,7 +1435,7 @@ public final class StringSearch extends SearchIterator {
                 // * the match limit is a normalization boundary
                 boolean allowMidclusterMatch =
                                 breakIterator == null &&
-                                nextCEI != null && (((nextCEI.ce_) >>> 32) & 0xFFFF0000L) != 0 &&
+                                (((nextCEI.ce_) >>> 32) & 0xFFFF0000L) != 0 &&
                                 maxLimit >= lastCEI.highIndex_ && nextCEI.highIndex_ > maxLimit &&
                                 (nfd_.hasBoundaryBefore(codePointAt(targetText, maxLimit)) ||
                                         nfd_.hasBoundaryAfter(codePointBefore(targetText, maxLimit)));
diff --git a/app/src/main/java/com/ibm/icu/text/StringTransform.java b/icu4j/src/main/java/com/ibm/icu/text/StringTransform.java
similarity index 87%
rename from app/src/main/java/com/ibm/icu/text/StringTransform.java
rename to icu4j/src/main/java/com/ibm/icu/text/StringTransform.java
index 65593db..eb1c3a1 100644
--- a/app/src/main/java/com/ibm/icu/text/StringTransform.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/StringTransform.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2009, Google, International Business Machines Corporation and    *
@@ -20,5 +22,6 @@ public interface StringTransform extends Transform<String,String> {
      * @return result
      * @stable ICU 3.8
      */
+    @Override
     public String transform(String source);
 }
\ No newline at end of file
diff --git a/app/src/main/java/com/ibm/icu/text/SymbolTable.java b/icu4j/src/main/java/com/ibm/icu/text/SymbolTable.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/text/SymbolTable.java
rename to icu4j/src/main/java/com/ibm/icu/text/SymbolTable.java
index 22f228c..fc68965 100644
--- a/app/src/main/java/com/ibm/icu/text/SymbolTable.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/SymbolTable.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2005, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/ThaiBreakEngine.java b/icu4j/src/main/java/com/ibm/icu/text/ThaiBreakEngine.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/ThaiBreakEngine.java
rename to icu4j/src/main/java/com/ibm/icu/text/ThaiBreakEngine.java
index e8e179d..8471701 100644
--- a/app/src/main/java/com/ibm/icu/text/ThaiBreakEngine.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/ThaiBreakEngine.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014, International Business Machines Corporation and         *
diff --git a/app/src/main/java/com/ibm/icu/text/TimeUnitFormat.java b/icu4j/src/main/java/com/ibm/icu/text/TimeUnitFormat.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/text/TimeUnitFormat.java
rename to icu4j/src/main/java/com/ibm/icu/text/TimeUnitFormat.java
index 80cdba6..756ba4d 100644
--- a/app/src/main/java/com/ibm/icu/text/TimeUnitFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/TimeUnitFormat.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  **************************************************************************
  * Copyright (C) 2008-2014, Google, International Business Machines
@@ -20,6 +22,7 @@ import java.util.TreeMap;
 
 import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
+import com.ibm.icu.impl.UResource;
 import com.ibm.icu.util.Measure;
 import com.ibm.icu.util.TimeUnit;
 import com.ibm.icu.util.TimeUnitAmount;
@@ -32,7 +35,7 @@ import com.ibm.icu.util.UResourceBundle;
  * Format or parse a TimeUnitAmount, using plural rules for the units where available.
  *
  * <P>
- * Code Sample: 
+ * Code Sample:
  * <pre>
  *   // create a time unit instance.
  *   // only SECOND, MINUTE, HOUR, DAY, WEEK, MONTH, and YEAR are supported
@@ -49,7 +52,7 @@ import com.ibm.icu.util.UResourceBundle;
  *   try {
  *       // parse a string into time unit amount
  *       TimeUnitAmount result = (TimeUnitAmount) format.parseObject(formatted);
- *       // result should equal to source 
+ *       // result should equal to source
  *   } catch (ParseException e) {
  *   }
  * </pre>
@@ -64,41 +67,41 @@ import com.ibm.icu.util.UResourceBundle;
 public class TimeUnitFormat extends MeasureFormat {
 
     /**
-     * Constant for full name style format. 
+     * Constant for full name style format.
      * For example, the full name for "hour" in English is "hour" or "hours".
      * @deprecated ICU 53 see {@link MeasureFormat.FormatWidth}
      */
     @Deprecated
     public static final int FULL_NAME = 0;
     /**
-     * Constant for abbreviated name style format. 
+     * Constant for abbreviated name style format.
      * For example, the abbreviated name for "hour" in English is "hr" or "hrs".
      * @deprecated ICU 53 see {@link MeasureFormat.FormatWidth}
      */
     @Deprecated
     public static final int ABBREVIATED_NAME = 1;
-    
+
     private static final int TOTAL_STYLES = 2;
 
     private static final long serialVersionUID = -3707773153184971529L;
-  
+
     // These fields are supposed to be the same as the fields in mf. They
     // are here for serialization backward compatibility and to support parsing.
     private NumberFormat format;
     private ULocale locale;
     private int style;
-     
+
     // We use this field in lieu of the super class because the super class
     // is immutable while this class is mutable. The contents of the super class
     // is an empty shell. Every public method of the super class is overridden to
     // delegate to this field. Each time this object mutates, it replaces this field with
     // a new immutable instance.
     private transient MeasureFormat mf;
-    
+
     private transient Map<TimeUnit, Map<String, Object[]>> timeUnitToCountToPatterns;
     private transient PluralRules pluralRules;
     private transient boolean isReady;
-    
+
     private static final String DEFAULT_PATTERN_FOR_SECOND = "{0} s";
     private static final String DEFAULT_PATTERN_FOR_MINUTE = "{0} min";
     private static final String DEFAULT_PATTERN_FOR_HOUR = "{0} h";
@@ -108,7 +111,7 @@ public class TimeUnitFormat extends MeasureFormat {
     private static final String DEFAULT_PATTERN_FOR_YEAR = "{0} y";
 
     /**
-     * Create empty format using full name style, for example, "hours". 
+     * Create empty format using full name style, for example, "hours".
      * Use setLocale and/or setFormat to modify.
      * @deprecated ICU 53 use {@link MeasureFormat} instead.
      */
@@ -155,13 +158,13 @@ public class TimeUnitFormat extends MeasureFormat {
         mf = MeasureFormat.getInstance(
                 locale, style == FULL_NAME ? FormatWidth.WIDE : FormatWidth.SHORT);
         this.style = style;
-        
+
         // Needed for getLocale(ULocale.VALID_LOCALE)
         setLocale(locale, locale);
         this.locale = locale;
         isReady = false;
     }
-    
+
     private TimeUnitFormat(ULocale locale, int style, NumberFormat numberFormat) {
         this(locale, style);
         if (numberFormat != null) {
@@ -188,7 +191,7 @@ public class TimeUnitFormat extends MeasureFormat {
     public TimeUnitFormat setLocale(ULocale locale) {
         if (locale != this.locale){
             mf = mf.withLocale(locale);
-            
+
             // Needed for getLocale(ULocale.VALID_LOCALE)
             setLocale(locale, locale);
             this.locale = locale;
@@ -196,7 +199,7 @@ public class TimeUnitFormat extends MeasureFormat {
         }
         return this;
     }
-    
+
     /**
      * Set the locale used for formatting or parsing.
      * @param locale   locale of this time unit formatter.
@@ -207,7 +210,7 @@ public class TimeUnitFormat extends MeasureFormat {
     public TimeUnitFormat setLocale(Locale locale) {
         return setLocale(ULocale.forLocale(locale));
     }
-    
+
     /**
      * Set the format used for formatting or parsing. Passing null is equivalent to passing
      * {@link NumberFormat#getNumberInstance(ULocale)}.
@@ -246,7 +249,7 @@ public class TimeUnitFormat extends MeasureFormat {
             FieldPosition pos) {
         return mf.format(obj, toAppendTo, pos);
     }
-    
+
     /**
      * Parse a TimeUnitAmount.
      * @see java.text.Format#parseObject(java.lang.String, java.text.ParsePosition)
@@ -339,7 +342,7 @@ public class TimeUnitFormat extends MeasureFormat {
             return new TimeUnitAmount(resultNumber, resultTimeUnit);
         }
     }
-    
+
     private void setup() {
         if (locale == null) {
             if (format != null) {
@@ -360,18 +363,37 @@ public class TimeUnitFormat extends MeasureFormat {
         setup("unitsShort/duration", timeUnitToCountToPatterns, ABBREVIATED_NAME, pluralKeywords);
         isReady = true;
     }
-    
-    private void setup(String resourceKey, Map<TimeUnit, Map<String, Object[]>> timeUnitToCountToPatterns, int style,
-            Set<String> pluralKeywords) {
-        // fill timeUnitToCountToPatterns from resource file
-        try {
-            ICUResourceBundle resource = (ICUResourceBundle) UResourceBundle.getBundleInstance(
-                    ICUData.ICU_UNIT_BASE_NAME, locale);
-            ICUResourceBundle unitsRes = resource.getWithFallback(resourceKey);
-            int size = unitsRes.getSize();
-            for (int index = 0; index < size; ++index) {
-                String timeUnitName = unitsRes.get(index).getKey();
+
+    private static final class TimeUnitFormatSetupSink extends UResource.Sink {
+        Map<TimeUnit, Map<String, Object[]>> timeUnitToCountToPatterns;
+        int style;
+        Set<String> pluralKeywords;
+        ULocale locale;
+        boolean beenHere;
+
+        TimeUnitFormatSetupSink(Map<TimeUnit, Map<String, Object[]>> timeUnitToCountToPatterns,
+                int style, Set<String> pluralKeywords, ULocale locale) {
+            this.timeUnitToCountToPatterns = timeUnitToCountToPatterns;
+            this.style = style;
+            this.pluralKeywords = pluralKeywords;
+            this.locale = locale;
+            this.beenHere = false;
+        }
+
+        @Override
+        public void put(UResource.Key key, UResource.Value value, boolean noFallback) {
+            // Skip all put() calls except the first one -- discard all fallback data.
+            if (beenHere) {
+                return;
+            } else {
+                beenHere = true;
+            }
+            
+            UResource.Table units = value.getTable();
+            for (int i = 0; units.getKeyAndValue(i, key, value); ++i) {
+                String timeUnitName = key.toString();
                 TimeUnit timeUnit = null;
+
                 if (timeUnitName.equals("year")) {
                     timeUnit = TimeUnit.YEAR;
                 } else if (timeUnitName.equals("month")) {
@@ -389,19 +411,18 @@ public class TimeUnitFormat extends MeasureFormat {
                 } else {
                     continue;
                 }
-                ICUResourceBundle oneUnitRes = unitsRes.getWithFallback(timeUnitName);
-                int count = oneUnitRes.getSize();
+
                 Map<String, Object[]> countToPatterns = timeUnitToCountToPatterns.get(timeUnit);
                 if (countToPatterns == null) {
                     countToPatterns = new TreeMap<String, Object[]>();
                     timeUnitToCountToPatterns.put(timeUnit, countToPatterns);
                 }
-                for (int pluralIndex = 0; pluralIndex < count; ++pluralIndex) {
-                    String pluralCount = oneUnitRes.get(pluralIndex).getKey();
+
+                UResource.Table countsToPatternTable = value.getTable();
+                for (int j = 0; countsToPatternTable.getKeyAndValue(j, key, value); ++j) {
+                    String pluralCount = key.toString();
                     if (!pluralKeywords.contains(pluralCount))
                         continue;
-                    String pattern = oneUnitRes.get(pluralIndex).getString();
-                    final MessageFormat messageFormat = new MessageFormat(pattern, locale);
                     // save both full name and abbreviated name in one table
                     // is good space-wise, but it degrades performance,
                     // since it needs to check whether the needed space
@@ -411,9 +432,27 @@ public class TimeUnitFormat extends MeasureFormat {
                         pair = new Object[2];
                         countToPatterns.put(pluralCount, pair);
                     }
-                    pair[style] = messageFormat;
+                    if (pair[style] == null) {
+                        String pattern = value.getString();
+                        final MessageFormat messageFormat = new MessageFormat(pattern, locale);
+                        pair[style] = messageFormat;
+                    }
                 }
             }
+        }
+    }
+
+    private void setup(String resourceKey, Map<TimeUnit, Map<String, Object[]>> timeUnitToCountToPatterns, int style,
+            Set<String> pluralKeywords) {
+        // fill timeUnitToCountToPatterns from resource file
+        try {
+
+            ICUResourceBundle resource = (ICUResourceBundle) UResourceBundle.getBundleInstance(
+                    ICUData.ICU_UNIT_BASE_NAME, locale);
+
+            TimeUnitFormatSetupSink sink = new TimeUnitFormatSetupSink(
+                    timeUnitToCountToPatterns, style, pluralKeywords, locale);
+            resource.getAllItemsWithFallback(resourceKey, sink);
         } catch (MissingResourceException e) {
         }
         // there should be patterns for each plural rule in each time unit.
@@ -490,7 +529,7 @@ public class TimeUnitFormat extends MeasureFormat {
         // then search the units resource fallback from the current level to root
         if (parentLocale == null && resourceKey.equals("unitsShort")) {
             searchInTree("units", styl, timeUnit, srcPluralCount, searchPluralCount, countToPatterns);
-            if (countToPatterns != null && countToPatterns.get(srcPluralCount) != null
+            if (countToPatterns.get(srcPluralCount) != null
                     && countToPatterns.get(srcPluralCount)[styl] != null) {
                 return;
             }
@@ -526,11 +565,11 @@ public class TimeUnitFormat extends MeasureFormat {
             searchInTree(resourceKey, styl, timeUnit, srcPluralCount, "other", countToPatterns);
         }
     }
-    
+
     // boilerplate code to make TimeUnitFormat otherwise follow the contract of
     // MeasureFormat
 
-    
+
     /**
      * @internal
      * @deprecated This API is ICU internal only.
@@ -541,7 +580,7 @@ public class TimeUnitFormat extends MeasureFormat {
             StringBuilder appendTo, FieldPosition fieldPosition, Measure... measures) {
         return mf.formatMeasures(appendTo, fieldPosition, measures);
     }
-    
+
     /**
      * @internal
      * @deprecated This API is ICU internal only.
@@ -551,7 +590,7 @@ public class TimeUnitFormat extends MeasureFormat {
     public MeasureFormat.FormatWidth getWidth() {
         return mf.getWidth();
     }
-    
+
     /**
      * @internal
      * @deprecated This API is ICU internal only.
@@ -561,7 +600,7 @@ public class TimeUnitFormat extends MeasureFormat {
     public NumberFormat getNumberFormat() {
         return mf.getNumberFormat();
     }
-    
+
     /**
      * @internal
      * @deprecated This API is ICU internal only.
@@ -574,13 +613,13 @@ public class TimeUnitFormat extends MeasureFormat {
         return result;
     }
     // End boilerplate.
-    
+
     // Serialization
-    
+
     private Object writeReplace() throws ObjectStreamException {
         return mf.toTimeUnitProxy();
     }
-    
+
     // Preserve backward serialize backward compatibility.
     private Object readResolve() throws ObjectStreamException {
         return new TimeUnitFormat(locale, style, format);
diff --git a/app/src/main/java/com/ibm/icu/text/TimeZoneFormat.java b/icu4j/src/main/java/com/ibm/icu/text/TimeZoneFormat.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/TimeZoneFormat.java
rename to icu4j/src/main/java/com/ibm/icu/text/TimeZoneFormat.java
index d1828c2..fb9b73d 100644
--- a/app/src/main/java/com/ibm/icu/text/TimeZoneFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/TimeZoneFormat.java
@@ -1,7 +1,9 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2011-2016, International Business Machines Corporation and    *
- * others. All Rights Reserved.                                                *
+ * Copyright (C) 2011-2016, International Business Machines Corporation and
+ * others. All Rights Reserved.
  *******************************************************************************
  */
 package com.ibm.icu.text;
@@ -28,6 +30,7 @@ import java.util.Locale;
 import java.util.MissingResourceException;
 import java.util.Set;
 
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.impl.SoftCache;
 import com.ibm.icu.impl.TZDBTimeZoneNames;
@@ -57,7 +60,7 @@ import com.ibm.icu.util.ULocale;
  * Unicode Locale Data Markup Language (LDML)</a>. {@link TimeZoneNames} represents the
  * time zone display name data model and this class implements the algorithm for actual
  * formatting and parsing.
- * 
+ *
  * @see SimpleDateFormat
  * @see TimeZoneNames
  * @stable ICU 49
@@ -71,7 +74,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * Time zone display format style enum used by format/parse APIs in <code>TimeZoneFormat</code>.
-     * 
+     *
      * @see TimeZoneFormat#format(Style, TimeZone, long)
      * @see TimeZoneFormat#format(Style, TimeZone, long, Output)
      * @see TimeZoneFormat#parse(Style, String, ParsePosition, Output)
@@ -207,7 +210,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
         EXEMPLAR_LOCATION (0x0800);
 
         final int flag;
-    
+
         private Style(int flag) {
             this.flag = flag;
         }
@@ -215,7 +218,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * Offset pattern type enum.
-     * 
+     *
      * @see TimeZoneFormat#getGMTOffsetPattern(GMTOffsetPatternType)
      * @see TimeZoneFormat#setGMTOffsetPattern(GMTOffsetPatternType, String)
      * @stable ICU 49
@@ -278,7 +281,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
     /**
      * Time type enum used for receiving time type (standard time, daylight time or unknown)
      * in <code>TimeZoneFormat</code> APIs.
-     * 
+     *
      * @stable ICU 49
      */
     public enum TimeType {
@@ -315,7 +318,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
          * When parsing a time zone display name in {@link Style#SPECIFIC_SHORT},
          * look for the IANA tz database compatible zone abbreviations in addition
          * to the localized names coming from the {@link TimeZoneNames} currently
-         * used by the {@link TimeZoneFormat}. 
+         * used by the {@link TimeZoneFormat}.
          * @stable ICU 54
          */
         TZ_DATABASE_ABBREVIATIONS;
@@ -369,7 +372,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
     private static final String UNKNOWN_LOCATION = "Unknown";
 
     // Order of GMT offset pattern parsing, *_HMS must be evaluated first
-    // because *_HM is most likely a substring of *_HMS 
+    // because *_HM is most likely a substring of *_HMS
     private static final GMTOffsetPatternType[] PARSE_GMT_OFFSET_TYPES = {
         GMTOffsetPatternType.POSITIVE_HMS, GMTOffsetPatternType.NEGATIVE_HMS,
         GMTOffsetPatternType.POSITIVE_HM, GMTOffsetPatternType.NEGATIVE_HM,
@@ -423,7 +426,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
         try {
             ICUResourceBundle bundle = (ICUResourceBundle) ICUResourceBundle.getBundleInstance(
-                    ICUResourceBundle.ICU_ZONE_BASE_NAME, locale);
+                    ICUData.ICU_ZONE_BASE_NAME, locale);
             try {
                 gmtPattern = bundle.getStringWithFallback("zoneStrings/gmtFormat");
             } catch (MissingResourceException e) {
@@ -477,7 +480,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * <p><b>Note</b>: The instance returned by this method is frozen. If you want to
      * customize a TimeZoneFormat, you must use {@link #cloneAsThawed()} to get a
      * thawed copy first.
-     * 
+     *
      * @param locale the locale.
      * @return a frozen instance of <code>TimeZoneFormat</code> for the given locale.
      * @stable ICU 49
@@ -495,7 +498,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * <p><b>Note</b>: The instance returned by this method is frozen. If you want to
      * customize a TimeZoneFormat, you must use {@link #cloneAsThawed()} to get a
      * thawed copy first.
-     * 
+     *
      * @param locale the {@link Locale}.
      * @return a frozen instance of <code>TimeZoneFormat</code> for the given locale.
      * @stable ICU 54
@@ -506,7 +509,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * Returns the time zone display name data used by this instance.
-     * 
+     *
      * @return the time zone display name data.
      * @see #setTimeZoneNames(TimeZoneNames)
      * @stable ICU 49
@@ -554,7 +557,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * Sets the time zone display name data to this instance.
-     * 
+     *
      * @param tznames the time zone display name data.
      * @return this object.
      * @throws UnsupportedOperationException when this object is frozen.
@@ -573,7 +576,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * Returns the localized GMT format pattern.
-     * 
+     *
      * @return the localized GMT format pattern.
      * @see #setGMTPattern(String)
      * @stable ICU 49
@@ -585,7 +588,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
     /**
      * Sets the localized GMT format pattern. The pattern must contain
      * a single argument {0}, for example "GMT {0}".
-     * 
+     *
      * @param pattern the localized GMT format pattern string
      * @return this object.
      * @throws IllegalArgumentException when the pattern string does not contain "{0}"
@@ -603,7 +606,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * Returns the offset pattern used for localized GMT format.
-     * 
+     *
      * @param type the offset pattern enum
      * @see #setGMTOffsetPattern(GMTOffsetPatternType, String)
      * @stable ICU 49
@@ -614,7 +617,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * Sets the offset pattern for the given offset type.
-     * 
+     *
      * @param type the offset pattern.
      * @param pattern the pattern string.
      * @return this object.
@@ -643,7 +646,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
     /**
      * Returns the decimal digit characters used for localized GMT format in a single string
      * containing from 0 to 9 in the ascending order.
-     * 
+     *
      * @return the decimal digits for localized GMT format.
      * @see #setGMTOffsetDigits(String)
      * @stable ICU 49
@@ -658,7 +661,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * Sets the decimal digit characters used for localized GMT format.
-     * 
+     *
      * @param digits a string contains the decimal digit characters from 0 to 9 n the ascending order.
      * @return this object.
      * @throws IllegalArgumentException when the string did not contain ten characters.
@@ -683,7 +686,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * Returns the localized GMT format string for GMT(UTC) itself (GMT offset is 0).
-     * 
+     *
      * @return the localized GMT string string for GMT(UTC) itself.
      * @see #setGMTZeroFormat(String)
      * @stable ICU 49
@@ -694,7 +697,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * Sets the localized GMT format string for GMT(UTC) itself (GMT offset is 0).
-     * 
+     *
      * @param gmtZeroFormat the localized GMT format string for GMT(UTC).
      * @return this object.
      * @throws UnsupportedOperationException when this object is frozen.
@@ -720,7 +723,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * <p>
      * <b>Note:</b> By default, an instance of <code>TimeZoneFormat</code>
      * created by {#link {@link #getInstance(ULocale)} has no parse options set.
-     * 
+     *
      * @param options the default parse options.
      * @return this object.
      * @see ParseOption
@@ -752,7 +755,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
     /**
      * Returns the ISO 8601 basic time zone string for the given offset.
      * For example, "-08", "-0830" and "Z"
-     * 
+     *
      * @param offset the offset from GMT(UTC) in milliseconds.
      * @param useUtcIndicator true if ISO 8601 UTC indicator "Z" is used when the offset is 0.
      * @param isShort true if shortest form is used.
@@ -771,7 +774,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
     /**
      * Returns the ISO 8601 extended time zone string for the given offset.
      * For example, "-08:00", "-08:30" and "Z"
-     * 
+     *
      * @param offset the offset from GMT(UTC) in milliseconds.
      * @param useUtcIndicator true if ISO 8601 UTC indicator "Z" is used when the offset is 0.
      * @param isShort true if shortest form is used.
@@ -836,7 +839,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
     /**
      * Returns the display name of the time zone at the given date for
      * the style.
-     * 
+     *
      * <p><b>Note</b>: A style may have fallback styles defined. For example,
      * when <code>GENERIC_LONG</code> is requested, but there is no display name
      * data available for <code>GENERIC_LONG</code> style, the implementation
@@ -844,7 +847,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * See UTS#35 UNICODE LOCALE DATA MARKUP LANGUAGE (LDML)
      * <a href="http://www.unicode.org/reports/tr35/#Time_Zone_Fallback">Appendix J: Time Zone Display Name</a>
      * for the details.
-     * 
+     *
      * @param style the style enum (e.g. <code>GENERIC_LONG</code>, <code>LOCALIZED_GMT</code>...)
      * @param tz the time zone.
      * @param date the date.
@@ -863,7 +866,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * in addition to the argument list of {@link #format(Style, TimeZone, long)}.
      * The argument is used for receiving the time type (standard time
      * or daylight saving time, or unknown) actually used for the display name.
-     * 
+     *
      * @param style the style enum (e.g. <code>GENERIC_LONG</code>, <code>LOCALIZED_GMT</code>...)
      * @param tz the time zone.
      * @param date the date.
@@ -1002,7 +1005,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * basic or extended time zone string. When the given string is not an ISO 8601 time
      * zone string, this method sets the current position as the error index
      * to <code>ParsePosition pos</code> and returns 0.
-     * 
+     *
      * @param text the text contains ISO 8601 style time zone string (e.g. "-08", "-0800", "-08:00", and "Z")
      * at the position.
      * @param pos the position.
@@ -1021,7 +1024,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * offset format string. When the given string cannot be parsed, this method
      * sets the current position as the error index to <code>ParsePosition pos</code>
      * and returns 0.
-     * 
+     *
      * @param text the text contains a localized GMT offset string at the position.
      * @param pos the position.
      * @return the offset from GMT(UTC) in milliseconds for the given localized GMT
@@ -1038,7 +1041,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * offset format string. When the given string cannot be parsed, this method
      * sets the current position as the error index to <code>ParsePosition pos</code>
      * and returns 0.
-     * 
+     *
      * @param text the text contains a short localized GMT offset string at the position.
      * @param pos the position.
      * @return the offset from GMT(UTC) in milliseconds for the given short localized GMT
@@ -1053,7 +1056,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
     /**
      * Returns a <code>TimeZone</code> by parsing the time zone string according to
      * the parse position, the style and the parse options.
-     * 
+     *
      * @param text the text contains a time zone string at the position.
      * @param style the format style.
      * @param pos the position.
@@ -1510,7 +1513,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * <p>
      * <b>Note</b>: This method is equivalent to {@link #parse(Style, String, ParsePosition, EnumSet, Output)
      * parse(style, text, pos, null, timeType)}.
-     * 
+     *
      * @param text the text contains a time zone string at the position.
      * @param style the format style
      * @param pos the position.
@@ -1533,7 +1536,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * <p>
      * <b>Note</b>: This method is equivalent to {@link #parse(Style, String, ParsePosition, EnumSet, Output)
      * parse(Style.GENERIC_LOCATION, text, pos, EnumSet.of(ParseOption.ALL_STYLES), timeType)}.
-     * 
+     *
      * @param text the text contains a time zone string at the position.
      * @param pos the position.
      * @return A <code>TimeZone</code>, or null if the input could not be parsed.
@@ -1566,7 +1569,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * @stable ICU 49
      */
     @Override
@@ -1597,7 +1600,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * @stable ICU 49
      */
     @Override
@@ -1615,7 +1618,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * @stable ICU 49
      */
     @Override
@@ -1766,7 +1769,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * Private method returning the time zone's specific format string.
-     * 
+     *
      * @param tz the time zone
      * @param stdType the name type used for standard time
      * @param dstType the name type used for daylight time
@@ -1792,7 +1795,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
     /**
      * Private method returning the time zone's exemplar location string.
      * This method will never return null.
-     * 
+     *
      * @param tz the time zone
      * @return the time zone's exemplar location name.
      */
@@ -1813,7 +1816,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * Private method returns a time zone ID. If tzID is not null, the value of tzID is returned.
      * If tzID is null, then this method look up a time zone ID for the current region. This is a
      * small helper method used by the parse implementation method
-     * 
+     *
      * @param tzID
      *            the time zone ID or null
      * @param mzID
@@ -1839,7 +1842,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * the locale of this instance. When a generic name is coming from
      * a meta zone, this region is used for checking if the time zone
      * is a reference zone of the meta zone.
-     * 
+     *
      * @return the target region
      */
     private synchronized String getTargetRegion() {
@@ -1880,7 +1883,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * Parses the localized GMT pattern string and initialize
      * localized gmt pattern fields including {{@link #_gmtPatternTokens}.
      * This method must be also called at deserialization time.
-     * 
+     *
      * @param gmtPattern the localized GMT pattern string such as "GMT {0}"
      * @throws IllegalArgumentException when the pattern string does not contain "{0}"
      */
@@ -1897,7 +1900,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * Unquotes the message format style pattern.
-     * 
+     *
      * @param s the pattern
      * @return the unquoted pattern string
      */
@@ -1930,7 +1933,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * Initialize localized GMT format offset hour/min/sec patterns.
      * This method parses patterns into optimized run-time format.
      * This method must be called at deserialization time.
-     * 
+     *
      * @param gmtOffsetPatterns patterns, String[4]
      * @throws IllegalArgumentException when patterns are not valid
      */
@@ -2002,7 +2005,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * Parse the GMT offset pattern into runtime optimized format
-     * 
+     *
      * @param pattern the offset pattern string
      * @param letters the required pattern letters such as "Hm"
      * @return An array of Object. Each array entry is either String (representing
@@ -2107,7 +2110,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * Appends seconds field to the offset pattern with hour/minute
-     * 
+     *
      * @param offsetHM the offset pattern including hours and minutes fields
      * @return the offset pattern including hours, minutes and seconds fields
      */
@@ -2127,7 +2130,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * Truncates minutes field from the offset pattern with hour/minute
-     * 
+     *
      * @param offsetHM the offset pattern including hours and minutes fields
      * @return the offset pattern including only hours field
      */
@@ -2152,7 +2155,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * Appends localized digits to the buffer.
      * <p>
      * Note: This code assumes that the input number is 0 - 59
-     * 
+     *
      * @param buf the target buffer
      * @param n the integer number
      * @param minDigits the minimum digits width
@@ -2187,7 +2190,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * offset format string. When the given string cannot be parsed, this method
      * sets the current position as the error index to <code>ParsePosition pos</code>
      * and returns 0.
-     * 
+     *
      * @param text the text contains a localized GMT offset string at the position.
      * @param pos the position.
      * @param isShort true if this parser to try the short format first
@@ -2273,7 +2276,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
                 break;
             }
             idx += len;
-    
+
             // Offset part
             int[] offsetLen = new int[1];
             offset = parseOffsetFields(text, idx, false, offsetLen);
@@ -2282,7 +2285,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
                 break;
             }
             idx += offsetLen[0];
-    
+
             // Suffix part
             len = _gmtPatternSuffix.length();
             if (len > 0 && !text.regionMatches(true, idx, _gmtPatternSuffix, 0, len)) {
@@ -2299,7 +2302,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * Parses localized GMT offset fields into offset.
-     * 
+     *
      * @param text the input text
      * @param start the start index
      * @param isShort true if this is a short format - currently not used
@@ -2373,7 +2376,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
 
     /**
      * Parses localized GMT offset fields with the given pattern
-     * 
+     *
      * @param text the input text
      * @param start the start index
      * @param patternItems the pattern (already itemized)
@@ -2628,7 +2631,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * Reads an offset field value. This method will stop parsing when
      * 1) number of digits reaches <code>maxDigits</code>
      * 2) just before already parsed number exceeds <code>maxVal</code>
-     * 
+     *
      * @param text the text
      * @param start the start offset
      * @param minDigits the minimum number of required digits
@@ -2711,7 +2714,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * Break input String into String[]. Each array element represents
      * a code point. This method is used for parsing localized digit
      * characters and support characters in Unicode supplemental planes.
-     * 
+     *
      * @param str the string
      * @return the array of code points in String[]
      */
@@ -2734,7 +2737,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * (basic format, extended format, or UTC indicator). When the given string is not an ISO 8601 time
      * zone string, this method sets the current position as the error index
      * to <code>ParsePosition pos</code> and returns 0.
-     * 
+     *
      * @param text the text contains ISO 8601 style time zone string (e.g. "-08", "-08:00", "Z")
      * at the position.
      * @param pos the position.
@@ -2802,7 +2805,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * <p>
      * Note: This method expects the input position is already at the start of
      * ASCII digits and does not parse sign (+/-).
-     * 
+     *
      * @param text The text contains a sequence of ASCII digits
      * @param pos The parse position
      * @param minFields The minimum Fields to be parsed
@@ -2894,7 +2897,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * <p>
      * Note: This method expects the input position is already at the start of
      * ASCII digits and does not parse sign (+/-).
-     * 
+     *
      * @param text The text
      * @param pos The parse position
      * @param sep The separator character
@@ -3139,7 +3142,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
     };
 
     /**
-     * 
+     *
      * @param oos the object output stream
      * @throws IOException
      */
@@ -3158,7 +3161,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
     }
 
     /**
-     * 
+     *
      * @param ois the object input stream
      * @throws ClassNotFoundException
      * @throws IOException
@@ -3253,6 +3256,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * {@inheritDoc}
      * @stable ICU 49
      */
+    @Override
     public boolean isFrozen() {
         return _frozen;
     }
@@ -3261,6 +3265,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * {@inheritDoc}
      * @stable ICU 49
      */
+    @Override
     public TimeZoneFormat freeze() {
         _frozen = true;
         return this;
@@ -3270,6 +3275,7 @@ public class TimeZoneFormat extends UFormat implements Freezable<TimeZoneFormat>
      * {@inheritDoc}
      * @stable ICU 49
      */
+    @Override
     public TimeZoneFormat cloneAsThawed() {
         TimeZoneFormat copy = (TimeZoneFormat)super.clone();
         copy._frozen = false;
diff --git a/app/src/main/java/com/ibm/icu/text/TimeZoneNames.java b/icu4j/src/main/java/com/ibm/icu/text/TimeZoneNames.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/TimeZoneNames.java
rename to icu4j/src/main/java/com/ibm/icu/text/TimeZoneNames.java
index e8defaf..a7bb189 100644
--- a/app/src/main/java/com/ibm/icu/text/TimeZoneNames.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/TimeZoneNames.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2011-2016, International Business Machines Corporation and
@@ -86,43 +88,43 @@ public abstract class TimeZoneNames implements Serializable {
     public enum NameType {
         /**
          * Long display name, such as "Eastern Time".
-         * 
+         *
          * @stable ICU 49
          */
         LONG_GENERIC,
         /**
          * Long display name for standard time, such as "Eastern Standard Time".
-         * 
+         *
          * @stable ICU 49
          */
         LONG_STANDARD,
         /**
          * Long display name for daylight saving time, such as "Eastern Daylight Time".
-         * 
+         *
          * @stable ICU 49
          */
         LONG_DAYLIGHT,
         /**
          * Short display name, such as "ET".
-         * 
+         *
          * @stable ICU 49
          */
         SHORT_GENERIC,
         /**
          * Short display name for standard time, such as "EST".
-         * 
+         *
          * @stable ICU 49
          */
         SHORT_STANDARD,
         /**
          * Short display name for daylight saving time, such as "EDT".
-         * 
+         *
          * @stable ICU 49
          */
         SHORT_DAYLIGHT,
         /**
          * Exemplar location name, such as "Los Angeles".
-         * 
+         *
          * @stable ICU 51
          */
         EXEMPLAR_LOCATION,
diff --git a/app/src/main/java/com/ibm/icu/text/TitlecaseTransliterator.java b/icu4j/src/main/java/com/ibm/icu/text/TitlecaseTransliterator.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/text/TitlecaseTransliterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/TitlecaseTransliterator.java
index 3c6826a..d3dc296 100644
--- a/app/src/main/java/com/ibm/icu/text/TitlecaseTransliterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/TitlecaseTransliterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  * Copyright (C) 1996-2011, International Business Machines Corporation and
  * others. All Rights Reserved.
@@ -19,12 +21,14 @@ import com.ibm.icu.util.ULocale;
 class TitlecaseTransliterator extends Transliterator {
 
     static final String _ID = "Any-Title";
+    // TODO: Add variants for tr/az, lt, default = default locale: ICU ticket #12720
 
     /**
      * System registration hook.
      */
     static void register() {
         Transliterator.registerFactory(_ID, new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new TitlecaseTransliterator(ULocale.US);
             }
@@ -33,9 +37,9 @@ class TitlecaseTransliterator extends Transliterator {
         registerSpecialInverse("Title", "Lower", false);
     }
 
-    private ULocale locale;
+    private final ULocale locale;
 
-    private UCaseProps csp;
+    private final UCaseProps csp;
     private ReplaceableContextIterator iter;
     private StringBuilder result;
     private int[] locCache;
@@ -54,10 +58,11 @@ class TitlecaseTransliterator extends Transliterator {
         locCache = new int[1];
         locCache[0]=0;
     }
-     
+
     /**
      * Implements {@link Transliterator#handleTransliterate}.
      */
+    @Override
     protected synchronized void handleTransliterate(Replaceable text,
                                        Position offsets, boolean isIncremental) {
         // TODO reimplement, see ustrcase.c
@@ -148,10 +153,10 @@ class TitlecaseTransliterator extends Transliterator {
         }
         offsets.start = offsets.limit;
     }
-    
+
     // NOTE: normally this would be static, but because the results vary by locale....
     SourceTargetUtility sourceTargetUtility = null;
-    
+
     /* (non-Javadoc)
      * @see com.ibm.icu.text.Transliterator#addSourceTargetSet(com.ibm.icu.text.UnicodeSet, com.ibm.icu.text.UnicodeSet, com.ibm.icu.text.UnicodeSet)
      */
@@ -160,8 +165,9 @@ class TitlecaseTransliterator extends Transliterator {
         synchronized (this) {
             if (sourceTargetUtility == null) {
                 sourceTargetUtility = new SourceTargetUtility(new Transform<String,String>() {
+                    @Override
                     public String transform(String source) {
-                        return UCharacter.toTitleCase(locale, source, null);                    
+                        return UCharacter.toTitleCase(locale, source, null);
                     }
                 });
             }
diff --git a/app/src/main/java/com/ibm/icu/text/Transform.java b/icu4j/src/main/java/com/ibm/icu/text/Transform.java
similarity index 88%
rename from app/src/main/java/com/ibm/icu/text/Transform.java
rename to icu4j/src/main/java/com/ibm/icu/text/Transform.java
index 5389fe3..297637e 100644
--- a/app/src/main/java/com/ibm/icu/text/Transform.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/Transform.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ********************************************************************************
  * Copyright (C) 2009-2010, Google, International Business Machines Corporation *
diff --git a/app/src/main/java/com/ibm/icu/text/TransformTransliterator.java b/icu4j/src/main/java/com/ibm/icu/text/TransformTransliterator.java
similarity index 100%
rename from app/src/main/java/com/ibm/icu/text/TransformTransliterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/TransformTransliterator.java
diff --git a/app/src/main/java/com/ibm/icu/text/TransliterationRule.java b/icu4j/src/main/java/com/ibm/icu/text/TransliterationRule.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/TransliterationRule.java
rename to icu4j/src/main/java/com/ibm/icu/text/TransliterationRule.java
index 05ddc90..270a8a7 100644
--- a/app/src/main/java/com/ibm/icu/text/TransliterationRule.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/TransliterationRule.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
@@ -540,12 +542,13 @@ class TransliterationRule {
      * Return a string representation of this object.
      * @return string representation of this object
      */
+    @Override
     public String toString() {
         return '{' + toRule(true) + '}';
     }
 
     /**
-     * Find the source and target sets, subject to the input filter. 
+     * Find the source and target sets, subject to the input filter.
      * There is a known issue with filters containing multiple characters.
      */
     // TODO: Problem: the rule is [{ab}]c > x
diff --git a/app/src/main/java/com/ibm/icu/text/TransliterationRuleSet.java b/icu4j/src/main/java/com/ibm/icu/text/TransliterationRuleSet.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/TransliterationRuleSet.java
rename to icu4j/src/main/java/com/ibm/icu/text/TransliterationRuleSet.java
index ed1a61c..3dbfa35 100644
--- a/app/src/main/java/com/ibm/icu/text/TransliterationRuleSet.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/TransliterationRuleSet.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/Transliterator.java b/icu4j/src/main/java/com/ibm/icu/text/Transliterator.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/Transliterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/Transliterator.java
index b8bbf42..7e324c9 100644
--- a/app/src/main/java/com/ibm/icu/text/Transliterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/Transliterator.java
@@ -1,7 +1,9 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 1996-2016, International Business Machines Corporation and    *
- * others. All Rights Reserved.                                                *
+ * Copyright (C) 1996-2016, International Business Machines Corporation and
+ * others. All Rights Reserved.
  *******************************************************************************
  */
 package com.ibm.icu.text;
@@ -16,6 +18,7 @@ import java.util.Locale;
 import java.util.Map;
 import java.util.MissingResourceException;
 
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.impl.Utility;
 import com.ibm.icu.impl.UtilityExtensions;
@@ -32,16 +35,16 @@ import com.ibm.icu.util.UResourceBundle;
  * changes Russian text written in Cyrillic characters to phonetically equivalent Latin characters. It does not
  * <em>translate</em> Russian to English! Transliteration, unlike translation, operates on characters, without reference
  * to the meanings of words and sentences.
- * 
+ *
  * <p>
  * Although script conversion is its most common use, a transliterator can actually perform a more general class of
  * tasks. In fact, <code>Transliterator</code> defines a very general API which specifies only that a segment of the
  * input text is replaced by new text. The particulars of this conversion are determined entirely by subclasses of
  * <code>Transliterator</code>.
- * 
+ *
  * <p>
  * <b>Transliterators are stateless</b>
- * 
+ *
  * <p>
  * <code>Transliterator</code> objects are <em>stateless</em>; they retain no information between calls to
  * <code>transliterate()</code>. As a result, threads may share transliterators without synchronizing them. This might
@@ -49,56 +52,56 @@ import com.ibm.icu.util.UResourceBundle;
  * transliterations by delaying the replacement of text until it is known that no other replacements are possible. In
  * other words, although the <code>Transliterator</code> objects are stateless, the source text itself embodies all the
  * needed information, and delayed operation allows arbitrary complexity.
- * 
+ *
  * <p>
  * <b>Batch transliteration</b>
- * 
+ *
  * <p>
  * The simplest way to perform transliteration is all at once, on a string of existing text. This is referred to as
  * <em>batch</em> transliteration. For example, given a string <code>input</code> and a transliterator <code>t</code>,
  * the call
- * 
+ *
  * <blockquote><code>String result = t.transliterate(input);
  * </code></blockquote>
- * 
+ *
  * will transliterate it and return the result. Other methods allow the client to specify a substring to be
  * transliterated and to use {@link Replaceable} objects instead of strings, in order to preserve out-of-band
  * information (such as text styles).
- * 
+ *
  * <p>
  * <b>Keyboard transliteration</b>
- * 
+ *
  * <p>
  * Somewhat more involved is <em>keyboard</em>, or incremental transliteration. This is the transliteration of text that
  * is arriving from some source (typically the user's keyboard) one character at a time, or in some other piecemeal
  * fashion.
- * 
+ *
  * <p>
  * In keyboard transliteration, a <code>Replaceable</code> buffer stores the text. As text is inserted, as much as
  * possible is transliterated on the fly. This means a GUI that displays the contents of the buffer may show text being
  * modified as each new character arrives.
- * 
+ *
  * <p>
  * Consider the simple <code>RuleBasedTransliterator</code>:
- * 
+ *
  * <blockquote><code>
  * th&gt;{theta}<br>
  * t&gt;{tau}
  * </code></blockquote>
- * 
+ *
  * When the user types 't', nothing will happen, since the transliterator is waiting to see if the next character is
  * 'h'. To remedy this, we introduce the notion of a cursor, marked by a '|' in the output string:
- * 
+ *
  * <blockquote><code>
  * t&gt;|{tau}<br>
  * {tau}h&gt;{theta}
  * </code></blockquote>
- * 
+ *
  * Now when the user types 't', tau appears, and if the next character is 'h', the tau changes to a theta. This is
  * accomplished by maintaining a cursor position (independent of the insertion point, and invisible in the GUI) across
  * calls to <code>transliterate()</code>. Typically, the cursor will be coincident with the insertion point, but in a
  * case like the one above, it will precede the insertion point.
- * 
+ *
  * <p>
  * Keyboard transliteration methods maintain a set of three indices that are updated with each call to
  * <code>transliterate()</code>, including the cursor, start, and limit. These indices are changed by the method, and
@@ -110,48 +113,48 @@ import com.ibm.icu.util.UResourceBundle;
  * <code>RuleBasedTransliterator</code>. Any characters before the <code>cursor</code> index are frozen; future keyboard
  * transliteration calls within this input sequence will not change them. New text is inserted at the <code>limit</code>
  * index, which marks the end of the substring that the transliterator looks at.
- * 
+ *
  * <p>
  * Because keyboard transliteration assumes that more characters are to arrive, it is conservative in its operation. It
  * only transliterates when it can do so unambiguously. Otherwise it waits for more characters to arrive. When the
  * client code knows that no more characters are forthcoming, perhaps because the user has performed some input
  * termination operation, then it should call <code>finishTransliteration()</code> to complete any pending
  * transliterations.
- * 
+ *
  * <p>
  * <b>Inverses</b>
- * 
+ *
  * <p>
  * Pairs of transliterators may be inverses of one another. For example, if transliterator <b>A</b> transliterates
  * characters by incrementing their Unicode value (so "abc" -&gt; "def"), and transliterator <b>B</b> decrements character
  * values, then <b>A</b> is an inverse of <b>B</b> and vice versa. If we compose <b>A</b> with <b>B</b> in a compound
  * transliterator, the result is the indentity transliterator, that is, a transliterator that does not change its input
  * text.
- * 
+ *
  * The <code>Transliterator</code> method <code>getInverse()</code> returns a transliterator's inverse, if one exists,
  * or <code>null</code> otherwise. However, the result of <code>getInverse()</code> usually will <em>not</em> be a true
  * mathematical inverse. This is because true inverse transliterators are difficult to formulate. For example, consider
  * two transliterators: <b>AB</b>, which transliterates the character 'A' to 'B', and <b>BA</b>, which transliterates
  * 'B' to 'A'. It might seem that these are exact inverses, since
- * 
+ *
  * <blockquote>"A" x <b>AB</b> -&gt; "B"<br>
  * "B" x <b>BA</b> -&gt; "A"</blockquote>
- * 
+ *
  * where 'x' represents transliteration. However,
- * 
+ *
  * <blockquote>"ABCD" x <b>AB</b> -&gt; "BBCD"<br>
  * "BBCD" x <b>BA</b> -&gt; "AACD"</blockquote>
- * 
+ *
  * so <b>AB</b> composed with <b>BA</b> is not the identity. Nonetheless, <b>BA</b> may be usefully considered to be
  * <b>AB</b>'s inverse, and it is on this basis that <b>AB</b><code>.getInverse()</code> could legitimately return
  * <b>BA</b>.
- * 
+ *
  * <p>
  * <b>Filtering</b>
  * <p>Each transliterator has a filter, which restricts changes to those characters selected by the filter. The
  * filter affects just the characters that are changed -- the characters outside of the filter are still part of the
  * context for the filter. For example, in the following even though 'x' is filtered out, and doesn't convert to y, it does affect the conversion of 'a'.
- * 
+ *
  * <pre>
  * String rules = &quot;x &gt; y; x{a} &gt; b; &quot;;
  * Transliterator tempTrans = Transliterator.createFromRules(&quot;temp&quot;, rules, Transliterator.FORWARD);
@@ -161,7 +164,7 @@ import com.ibm.icu.util.UResourceBundle;
  *</pre>
  * <p>
  * <b>IDs and display names</b>
- * 
+ *
  * <p>
  * A transliterator is designated by a short identifier string or <em>ID</em>. IDs follow the format
  * <em>source-destination</em>, where <em>source</em> describes the entity being replaced, and <em>destination</em>
@@ -170,27 +173,27 @@ import com.ibm.icu.util.UResourceBundle;
  * Russian to Latin might be named "Russian-Latin". A transliterator from keyboard escape sequences to Latin-1
  * characters might be named "KeyboardEscape-Latin1". By convention, system entity names are in English, with the
  * initial letters of words capitalized; user entity names may follow any format so long as they do not contain dashes.
- * 
+ *
  * <p>
  * In addition to programmatic IDs, transliterator objects have display names for presentation in user interfaces,
  * returned by {@link #getDisplayName}.
- * 
+ *
  * <p>
  * <b>Factory methods and registration</b>
- * 
+ *
  * <p>
  * In general, client code should use the factory method <code>getInstance()</code> to obtain an instance of a
  * transliterator given its ID. Valid IDs may be enumerated using <code>getAvailableIDs()</code>. Since transliterators
  * are stateless, multiple calls to <code>getInstance()</code> with the same ID will return the same object.
- * 
+ *
  * <p>
  * In addition to the system transliterators registered at startup, user transliterators may be registered by calling
  * <code>registerInstance()</code> at run time. To register a transliterator subclass without instantiating it (until it
  * is needed), users may call <code>registerClass()</code>.
- * 
+ *
  * <p>
  * <b>Composed transliterators</b>
- * 
+ *
  * <p>
  * In addition to built-in system transliterators like "Latin-Greek", there are also built-in <em>composed</em>
  * transliterators. These are implemented by composing two or more component transliterators. For example, if we have
@@ -201,26 +204,26 @@ import com.ibm.icu.util.UResourceBundle;
  * <sup>2</sup> - <em>n</em>, so as <em>n</em> gets larger the gain becomes significant. With 9 scripts, it's 18 vs. 72
  * rule sets, a big difference.) Note the use of "~" rather than "-" for the script separator here; this indicates that
  * the given transliterator is intended to be composed with others, rather than be used as is.
- * 
+ *
  * <p>
  * Composed transliterators can be instantiated as usual. For example, the system transliterator "Devanagari-Gujarati"
  * is a composed transliterator built internally as "Devanagari~InterIndic;InterIndic~Gujarati". When this
  * transliterator is instantiated, it appears externally to be a standard transliterator (e.g., getID() returns
  * "Devanagari-Gujarati").
- * 
+ *
  * <p>
  * <b>Subclassing</b>
- * 
+ *
  * <p>
  * Subclasses must implement the abstract method <code>handleTransliterate()</code>.
  * <p>
  * Subclasses should override the <code>transliterate()</code> method taking a <code>Replaceable</code> and the
  * <code>transliterate()</code> method taking a <code>String</code> and <code>StringBuffer</code> if the performance of
  * these methods can be improved over the performance obtained by the default implementations in this class.
- * 
+ *
  * <p>
  * Copyright &copy; IBM Corporation 1999. All rights reserved.
- * 
+ *
  * @author Alan Liu
  * @stable ICU 2.0
  */
@@ -359,6 +362,7 @@ public abstract class Transliterator implements StringTransform  {
          * Returns true if this Position is equal to the given object.
          * @stable ICU 2.6
          */
+        @Override
         public boolean equals(Object obj) {
             if (obj instanceof Position) {
                 Position pos = (Position) obj;
@@ -369,13 +373,14 @@ public abstract class Transliterator implements StringTransform  {
             }
             return false;
         }
-        
+
         /**
          * Mock implementation of hashCode(). This implementation always returns a constant
          * value. When Java assertion is enabled, this method triggers an assertion failure.
          * @internal
          * @deprecated This API is ICU internal only.
          */
+        @Override
         @Deprecated
         public int hashCode() {
             assert false : "hashCode not designed";
@@ -386,6 +391,7 @@ public abstract class Transliterator implements StringTransform  {
          * Returns a string representation of this Position.
          * @stable ICU 2.6
          */
+        @Override
         public String toString() {
             return "[cs=" + contextStart
                 + ", s=" + start
@@ -1226,7 +1232,7 @@ public abstract class Transliterator implements StringTransform  {
         // root will change to sun.text.resources.LocaleElements
 
         ICUResourceBundle bundle = (ICUResourceBundle)UResourceBundle.
-            getBundleInstance(ICUResourceBundle.ICU_TRANSLIT_BASE_NAME, inLocale);
+            getBundleInstance(ICUData.ICU_TRANSLIT_BASE_NAME, inLocale);
 
         // Normalize the ID
         String stv[] = TransliteratorIDParser.IDtoSTV(id);
@@ -1647,7 +1653,7 @@ public abstract class Transliterator implements StringTransform  {
     }
 
     /**
-     * Returns the intersectionof this instance's filter intersected with an external filter. 
+     * Returns the intersectionof this instance's filter intersected with an external filter.
      * The externalFilter must be frozen (it is frozen if not).
      * The result may be frozen, so don't attempt to modify.
      * @internal
@@ -1716,11 +1722,11 @@ public abstract class Transliterator implements StringTransform  {
     /**
      * Register a factory object with the given ID.  The factory
      * method should return a new instance of the given transliterator.
-     * 
+     *
      * <p>Because ICU may choose to cache Transliterator objects internally, this must
      * be called at application startup, prior to any calls to
      * Transliterator.getInstance to avoid undefined behavior.
-     * 
+     *
      * @param ID the ID of this transliterator
      * @param factory the factory object
      * @stable ICU 2.0
@@ -1731,11 +1737,11 @@ public abstract class Transliterator implements StringTransform  {
 
     /**
      * Register a Transliterator object with the given ID.
-     * 
+     *
      * <p>Because ICU may choose to cache Transliterator objects internally, this must
      * be called at application startup, prior to any calls to
      * Transliterator.getInstance to avoid undefined behavior.
-     * 
+     *
      * @param trans the Transliterator object
      * @stable ICU 2.2
      */
@@ -1745,11 +1751,11 @@ public abstract class Transliterator implements StringTransform  {
 
     /**
      * Register a Transliterator object.
-     * 
+     *
      * <p>Because ICU may choose to cache Transliterator objects internally, this must
      * be called at application startup, prior to any calls to
      * Transliterator.getInstance to avoid undefined behavior.
-     * 
+     *
      * @param trans the Transliterator object
      */
     static void registerInstance(Transliterator trans, boolean visible) {
@@ -1760,11 +1766,11 @@ public abstract class Transliterator implements StringTransform  {
      * Register an ID as an alias of another ID.  Instantiating
      * alias ID produces the same result as instantiating the original ID.
      * This is generally used to create short aliases of compound IDs.
-     * 
+     *
      * <p>Because ICU may choose to cache Transliterator objects internally, this must
      * be called at application startup, prior to any calls to
      * Transliterator.getInstance to avoid undefined behavior.
-     * 
+     *
      * @param aliasID The new ID being registered.
      * @param realID The existing ID that the new ID should be an alias of.
      * @stable ICU 3.6
@@ -1899,13 +1905,13 @@ public abstract class Transliterator implements StringTransform  {
          * <id> is the ID of the system transliterator being defined.  These
          * are public IDs enumerated by Transliterator.getAvailableIDs(),
          * unless the second field is "internal".
-         * 
+         *
          * <resource> is a ResourceReader resource name.  Currently these refer
          * to file names under com/ibm/text/resources.  This string is passed
          * directly to ResourceReader, together with <encoding>.
-         * 
+         *
          * <direction> is either "FORWARD" or "REVERSE".
-         * 
+         *
          * <getInstanceArg> is a string to be passed directly to
          * Transliterator.getInstance().  The returned Transliterator object
          * then has its ID changed to <id> and is returned.
@@ -1913,7 +1919,7 @@ public abstract class Transliterator implements StringTransform  {
          * The extra blank field on "alias" lines is to make the array square.
          */
         UResourceBundle bundle, transIDs, colBund;
-        bundle = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_TRANSLIT_BASE_NAME, ROOT);
+        bundle = UResourceBundle.getBundleInstance(ICUData.ICU_TRANSLIT_BASE_NAME, ROOT);
         transIDs = bundle.get(RB_RULE_BASED_IDS);
 
         int row, maxRows;
@@ -1944,7 +1950,6 @@ public abstract class Transliterator implements StringTransform  {
                 }
                 registry.put(ID,
                              resString, // resource
-                             "UTF-16", // encoding
                              dir,
                              !type.equals("internal"));
             } else if (type.equals("alias")) {
@@ -1975,7 +1980,7 @@ public abstract class Transliterator implements StringTransform  {
         BreakTransliterator.register();
         AnyTransliterator.register(); // do this last!
     }
-    
+
     /**
      * Register the script-based "Any" transliterators: Any-Latin, Any-Greek
      * @internal
@@ -2003,13 +2008,14 @@ public abstract class Transliterator implements StringTransform  {
          */
         Transliterator getInstance(String ID);
     }
-    
+
     /**
      * Implements StringTransform via this method.
      * @param source text to be transformed (eg lowercased)
      * @return result
      * @stable ICU 3.8
      */
+    @Override
     public String transform(String source) {
         return transliterate(source);
     }
diff --git a/app/src/main/java/com/ibm/icu/text/TransliteratorIDParser.java b/icu4j/src/main/java/com/ibm/icu/text/TransliteratorIDParser.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/TransliteratorIDParser.java
rename to icu4j/src/main/java/com/ibm/icu/text/TransliteratorIDParser.java
index 057b5fe..54487c5 100644
--- a/app/src/main/java/com/ibm/icu/text/TransliteratorIDParser.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/TransliteratorIDParser.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 **********************************************************************
 *   Copyright (c) 2002-2011, International Business Machines Corporation
diff --git a/app/src/main/java/com/ibm/icu/text/TransliteratorParser.java b/icu4j/src/main/java/com/ibm/icu/text/TransliteratorParser.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/TransliteratorParser.java
rename to icu4j/src/main/java/com/ibm/icu/text/TransliteratorParser.java
index e93b999..5398021 100644
--- a/app/src/main/java/com/ibm/icu/text/TransliteratorParser.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/TransliteratorParser.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 **********************************************************************
 *   Copyright (c) 2001-2011, International Business Machines
@@ -77,7 +79,7 @@ class TransliteratorParser {
 
     /**
      * Vector of StringMatcher objects for segments.  Used during the
-     * parsing of a single rule.  
+     * parsing of a single rule.
      * segmentStandins.charAt(0) is the standin for "$1" and corresponds
      * to StringMatcher object segmentObjects.elementAt(0), etc.
      */
@@ -177,7 +179,7 @@ class TransliteratorParser {
     private static final char ALT_FORWARD_RULE_OP = '\u2192'; // Right Arrow
     private static final char ALT_FWDREV_RULE_OP  = '\u2194'; // Left Right Arrow
     private static final char ALT_FUNCTION        = '\u2206'; // Increment (~Greek Capital Delta)
-    
+
     // Special characters disallowed at the top level
     private static UnicodeSet ILLEGAL_TOP = new UnicodeSet("[\\)]");
 
@@ -202,6 +204,7 @@ class TransliteratorParser {
         /**
          * Implement SymbolTable API.
          */
+        @Override
         public char[] lookup(String name) {
             return variableNames.get(name);
         }
@@ -209,6 +212,7 @@ class TransliteratorParser {
         /**
          * Implement SymbolTable API.
          */
+        @Override
         public UnicodeMatcher lookupMatcher(int ch) {
             // Note that we cannot use data.lookup() because the
             // set array has not been constructed yet.
@@ -223,6 +227,7 @@ class TransliteratorParser {
          * Implement SymbolTable API.  Parse out a symbol reference
          * name.
          */
+        @Override
         public String parseReference(String text, ParsePosition pos, int limit) {
             int start = pos.getIndex();
             int i = start;
@@ -327,9 +332,11 @@ class TransliteratorParser {
         String[] array;
         int i;
         public RuleArray(String[] array) { this.array = array; i = 0; }
+        @Override
         public String handleNextLine() {
             return (i < array.length) ? array[i++] : null;
         }
+        @Override
         public void reset() {
             i = 0;
         }
@@ -478,7 +485,7 @@ class TransliteratorParser {
                     }
                     pp.setIndex(pos-1); // Backup to opening '['
                     buf.append(parser.parseSet(rule, pp));
-                    pos = pp.getIndex();                    
+                    pos = pp.getIndex();
                     continue;
                 }
                 // Handle escapes
@@ -525,7 +532,7 @@ class TransliteratorParser {
                             }
                         }
                         quoteLimit = buf.length();
-                        
+
                         for (iq=quoteStart; iq<quoteLimit; ++iq) {
                             parser.checkVariableRange(buf.charAt(iq), rule, start);
                         }
@@ -540,7 +547,7 @@ class TransliteratorParser {
                 }
 
                 switch (c) {
-                    
+
                 //------------------------------------------------------
                 // Elements allowed within and out of segments
                 //------------------------------------------------------
@@ -687,7 +694,7 @@ class TransliteratorParser {
                             break;
                         }
                         ///CLOVER:ON
- 
+
                         int qstart, qlimit;
                         // The */+ follows an isolated character or quote
                         // or variable reference
@@ -713,9 +720,8 @@ class TransliteratorParser {
                         } catch (RuntimeException e) {
                             final String precontext = pos < 50 ? rule.substring(0, pos) : "..." + rule.substring(pos - 50, pos);
                             final String postContext = limit-pos <= 50 ? rule.substring(pos, limit) : rule.substring(pos, pos+50) + "...";
-                            throw (RuntimeException)
-                                new IllegalIcuArgumentException("Failure in rule: " + precontext + "$$$"
-                                        + postContext).initCause(e);
+                            throw new IllegalIcuArgumentException("Failure in rule: " + precontext + "$$$"
+                                    + postContext).initCause(e);
                         }
                         int min = 0;
                         int max = Quantifier.MAX;
@@ -866,7 +872,7 @@ class TransliteratorParser {
     public void parse(String rules, int dir) {
         parseRules(new RuleArray(new String[] { rules }), dir);
     }
-   
+
     /*
      * Parse a set of rules.  After the parse completes, examine the public
      * data members for results.
@@ -1308,7 +1314,7 @@ class TransliteratorParser {
         if (start > end || start < 0 || end > 0xFFFF) {
             throw new IllegalIcuArgumentException("Invalid variable range " + start + ", " + end);
         }
-        
+
         curData.variablesBase = (char) start; // first private use
 
         if (dataVector.size() == 0) {
@@ -1383,7 +1389,7 @@ class TransliteratorParser {
         // know that pos points to /use\s/i; we can skip 4 characters
         // immediately
         pos += 4;
-        
+
         // Here are the pragmas we recognize:
         // use variable range 0xE000 0xEFFF;
         // use maximum backup 16;
@@ -1495,7 +1501,7 @@ class TransliteratorParser {
         }
         return c;
     }
-    
+
     /**
      * Set the object for segment seg (1-based).
      */
diff --git a/app/src/main/java/com/ibm/icu/text/TransliteratorRegistry.java b/icu4j/src/main/java/com/ibm/icu/text/TransliteratorRegistry.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/TransliteratorRegistry.java
rename to icu4j/src/main/java/com/ibm/icu/text/TransliteratorRegistry.java
index 48333b5..2960310 100644
--- a/app/src/main/java/com/ibm/icu/text/TransliteratorRegistry.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/TransliteratorRegistry.java
@@ -1,6 +1,8 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 **********************************************************************
-*   Copyright (c) 2001-2011, International Business Machines
+*   Copyright (c) 2001-2016, International Business Machines
 *   Corporation and others.  All Rights Reserved.
 **********************************************************************
 *   Date        Name        Description
@@ -20,8 +22,10 @@ import java.util.Map;
 import java.util.MissingResourceException;
 import java.util.ResourceBundle;
 
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.impl.LocaleUtility;
+import com.ibm.icu.impl.Utility;
 import com.ibm.icu.lang.UScript;
 import com.ibm.icu.text.RuleBasedTransliterator.Data;
 import com.ibm.icu.util.CaseInsensitiveString;
@@ -120,7 +124,7 @@ class TransliteratorRegistry {
                 // If 'top' is not a script name, try a locale lookup
                 if (script == UScript.INVALID_CODE) {
                     Locale toploc = LocaleUtility.getLocaleFromName(top);
-                    res  = (ICUResourceBundle)UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_TRANSLIT_BASE_NAME,toploc);
+                    res  = (ICUResourceBundle)UResourceBundle.getBundleInstance(ICUData.ICU_TRANSLIT_BASE_NAME,toploc);
                     // Make sure we got the bundle we wanted; otherwise, don't use it
                     if (res!=null && LocaleUtility.isFallbackOf(res.getULocale().toString(), top)) {
                         isSpecLocale = true;
@@ -142,7 +146,7 @@ class TransliteratorRegistry {
         }
 
         public void reset() {
-            if (spec != top) { // [sic] pointer comparison
+            if (!Utility.sameObjects(spec, top)) {
                 spec = top;
                 isSpecLocale = (res != null);
                 setupNext();
@@ -164,7 +168,7 @@ class TransliteratorRegistry {
                 }
             } else {
                 // Fallback to the script, which may be null
-                if (nextSpec != scriptName) {
+                if (!Utility.sameObjects(nextSpec, scriptName)) {
                     nextSpec = scriptName;
                 } else {
                     nextSpec = null;
@@ -217,11 +221,9 @@ class TransliteratorRegistry {
 
     static class ResourceEntry {
         public String resource;
-        public String encoding;
         public int direction;
-        public ResourceEntry(String n, String enc, int d) {
+        public ResourceEntry(String n, int d) {
             resource = n;
-            encoding = enc;
             direction = d;
         }
     }
@@ -340,10 +342,9 @@ class TransliteratorRegistry {
      */
     public void put(String ID,
                     String resourceName,
-                    String encoding,
                     int dir,
                     boolean visible) {
-        registerEntry(ID, new ResourceEntry(resourceName, encoding, dir), visible);
+        registerEntry(ID, new ResourceEntry(resourceName, dir), visible);
     }
 
     /**
@@ -397,10 +398,12 @@ class TransliteratorRegistry {
             en = e;
         }
 
+        @Override
         public boolean hasMoreElements() {
             return en != null && en.hasMoreElements();
         }
 
+        @Override
         public String nextElement() {
             return (en.nextElement()).getString();
         }
@@ -871,10 +874,10 @@ class TransliteratorRegistry {
             TransliteratorParser parser = new TransliteratorParser();
 
             try {
-               
+
                 ResourceEntry re = (ResourceEntry) entry;
                 parser.parse(re.resource, re.direction);
-                
+
             } catch (ClassCastException e) {
                 // If we pull a rule from a locale resource bundle it will
                 // be a LocaleEntry.
diff --git a/icu4j/src/main/java/com/ibm/icu/text/UCharacterIterator.java b/icu4j/src/main/java/com/ibm/icu/text/UCharacterIterator.java
new file mode 100644
index 0000000..cfcf0a9
--- /dev/null
+++ b/icu4j/src/main/java/com/ibm/icu/text/UCharacterIterator.java
@@ -0,0 +1,409 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
+/*
+ *******************************************************************************
+ * Copyright (C) 1996-2016, International Business Machines Corporation and
+ * others. All Rights Reserved.
+ *******************************************************************************
+ */
+package com.ibm.icu.text;
+
+import java.text.CharacterIterator;
+
+import com.ibm.icu.impl.CharacterIteratorWrapper;
+import com.ibm.icu.impl.ReplaceableUCharacterIterator;
+import com.ibm.icu.impl.UCharArrayIterator;
+import com.ibm.icu.impl.UCharacterIteratorWrapper;
+
+/**
+ * Abstract class that defines an API for iteration on text objects.This is an interface for forward and backward
+ * iteration and random access into a text object. Forward iteration is done with post-increment and backward iteration
+ * is done with pre-decrement semantics, while the <code>java.text.CharacterIterator</code> interface methods provided
+ * forward iteration with "pre-increment" and backward iteration with pre-decrement semantics. This API is more
+ * efficient for forward iteration over code points. The other major difference is that this API can do both code unit
+ * and code point iteration, <code>java.text.CharacterIterator</code> can only iterate over code units and is limited to
+ * BMP (0 - 0xFFFF)
+ *
+ * @author Ram
+ * @stable ICU 2.4
+ */
+public abstract class UCharacterIterator implements Cloneable, UForwardCharacterIterator {
+
+    /**
+     * Protected default constructor for the subclasses
+     *
+     * @stable ICU 2.4
+     */
+    protected UCharacterIterator() {
+    }
+
+    // static final methods ----------------------------------------------------
+
+    /**
+     * Returns a <code>UCharacterIterator</code> object given a <code>Replaceable</code> object.
+     *
+     * @param source
+     *            a valid source as a <code>Replaceable</code> object
+     * @return UCharacterIterator object
+     * @exception IllegalArgumentException
+     *                if the argument is null
+     * @stable ICU 2.4
+     */
+    public static final UCharacterIterator getInstance(Replaceable source) {
+        return new ReplaceableUCharacterIterator(source);
+    }
+
+    /**
+     * Returns a <code>UCharacterIterator</code> object given a source string.
+     *
+     * @param source
+     *            a string
+     * @return UCharacterIterator object
+     * @exception IllegalArgumentException
+     *                if the argument is null
+     * @stable ICU 2.4
+     */
+    public static final UCharacterIterator getInstance(String source) {
+        return new ReplaceableUCharacterIterator(source);
+    }
+
+    /**
+     * Returns a <code>UCharacterIterator</code> object given a source character array.
+     *
+     * @param source
+     *            an array of UTF-16 code units
+     * @return UCharacterIterator object
+     * @exception IllegalArgumentException
+     *                if the argument is null
+     * @stable ICU 2.4
+     */
+    public static final UCharacterIterator getInstance(char[] source) {
+        return getInstance(source, 0, source.length);
+    }
+
+    /**
+     * Returns a <code>UCharacterIterator</code> object given a source character array.
+     *
+     * @param source
+     *            an array of UTF-16 code units
+     * @return UCharacterIterator object
+     * @exception IllegalArgumentException
+     *                if the argument is null
+     * @stable ICU 2.4
+     */
+    public static final UCharacterIterator getInstance(char[] source, int start, int limit) {
+        return new UCharArrayIterator(source, start, limit);
+    }
+
+    /**
+     * Returns a <code>UCharacterIterator</code> object given a source StringBuffer.
+     *
+     * @param source
+     *            an string buffer of UTF-16 code units
+     * @return UCharacterIterator object
+     * @exception IllegalArgumentException
+     *                if the argument is null
+     * @stable ICU 2.4
+     */
+    public static final UCharacterIterator getInstance(StringBuffer source) {
+        return new ReplaceableUCharacterIterator(source);
+    }
+
+    /**
+     * Returns a <code>UCharacterIterator</code> object given a CharacterIterator.
+     *
+     * @param source
+     *            a valid CharacterIterator object.
+     * @return UCharacterIterator object
+     * @exception IllegalArgumentException
+     *                if the argument is null
+     * @stable ICU 2.4
+     */
+    public static final UCharacterIterator getInstance(CharacterIterator source) {
+        return new CharacterIteratorWrapper(source);
+    }
+
+    // public methods ----------------------------------------------------------
+    /**
+     * Returns a <code>java.text.CharacterIterator</code> object for the underlying text of this iterator. The returned
+     * iterator is independent of this iterator.
+     *
+     * @return java.text.CharacterIterator object
+     * @stable ICU 2.4
+     */
+    public CharacterIterator getCharacterIterator() {
+        return new UCharacterIteratorWrapper(this);
+    }
+
+    /**
+     * Returns the code unit at the current index. If index is out of range, returns DONE. Index is not changed.
+     *
+     * @return current code unit
+     * @stable ICU 2.4
+     */
+    public abstract int current();
+
+    /**
+     * Returns the codepoint at the current index. If the current index is invalid, DONE is returned. If the current
+     * index points to a lead surrogate, and there is a following trail surrogate, then the code point is returned.
+     * Otherwise, the code unit at index is returned. Index is not changed.
+     *
+     * @return current codepoint
+     * @stable ICU 2.4
+     */
+    public int currentCodePoint() {
+        int ch = current();
+        if (UTF16.isLeadSurrogate((char) ch)) {
+            // advance the index to get the
+            // next code point
+            next();
+            // due to post increment semantics
+            // current() after next() actually
+            // returns the char we want
+            int ch2 = current();
+            // current should never change
+            // the current index so back off
+            previous();
+
+            if (UTF16.isTrailSurrogate((char) ch2)) {
+                // we found a surrogate pair
+                // return the codepoint
+                return Character.toCodePoint((char) ch, (char) ch2);
+            }
+        }
+        return ch;
+    }
+
+    /**
+     * Returns the length of the text
+     *
+     * @return length of the text
+     * @stable ICU 2.4
+     */
+    public abstract int getLength();
+
+    /**
+     * Gets the current index in text.
+     *
+     * @return current index in text.
+     * @stable ICU 2.4
+     */
+    public abstract int getIndex();
+
+    /**
+     * Returns the UTF16 code unit at index, and increments to the next code unit (post-increment semantics). If index
+     * is out of range, DONE is returned, and the iterator is reset to the limit of the text.
+     *
+     * @return the next UTF16 code unit, or DONE if the index is at the limit of the text.
+     * @stable ICU 2.4
+     */
+    @Override
+    public abstract int next();
+
+    /**
+     * Returns the code point at index, and increments to the next code point (post-increment semantics). If index does
+     * not point to a valid surrogate pair, the behavior is the same as <code>next()</code>. Otherwise the iterator is
+     * incremented past the surrogate pair, and the code point represented by the pair is returned.
+     *
+     * @return the next codepoint in text, or DONE if the index is at the limit of the text.
+     * @stable ICU 2.4
+     */
+    @Override
+    public int nextCodePoint() {
+        int ch1 = next();
+        if (UTF16.isLeadSurrogate((char) ch1)) {
+            int ch2 = next();
+            if (UTF16.isTrailSurrogate((char) ch2)) {
+                return Character.toCodePoint((char) ch1, (char) ch2);
+            } else if (ch2 != DONE) {
+                // unmatched surrogate so back out
+                previous();
+            }
+        }
+        return ch1;
+    }
+
+    /**
+     * Decrement to the position of the previous code unit in the text, and return it (pre-decrement semantics). If the
+     * resulting index is less than 0, the index is reset to 0 and DONE is returned.
+     *
+     * @return the previous code unit in the text, or DONE if the new index is before the start of the text.
+     * @stable ICU 2.4
+     */
+    public abstract int previous();
+
+    /**
+     * Retreat to the start of the previous code point in the text, and return it (pre-decrement semantics). If the
+     * index is not preceeded by a valid surrogate pair, the behavior is the same as <code>previous()</code>. Otherwise
+     * the iterator is decremented to the start of the surrogate pair, and the code point represented by the pair is
+     * returned.
+     *
+     * @return the previous code point in the text, or DONE if the new index is before the start of the text.
+     * @stable ICU 2.4
+     */
+    public int previousCodePoint() {
+        int ch1 = previous();
+        if (UTF16.isTrailSurrogate((char) ch1)) {
+            int ch2 = previous();
+            if (UTF16.isLeadSurrogate((char) ch2)) {
+                return Character.toCodePoint((char) ch2, (char) ch1);
+            } else if (ch2 != DONE) {
+                // unmatched trail surrogate so back out
+                next();
+            }
+        }
+        return ch1;
+    }
+
+    /**
+     * Sets the index to the specified index in the text.
+     *
+     * @param index
+     *            the index within the text.
+     * @exception IndexOutOfBoundsException
+     *                is thrown if an invalid index is supplied
+     * @stable ICU 2.4
+     */
+    public abstract void setIndex(int index);
+
+    /**
+     * Sets the current index to the limit.
+     *
+     * @stable ICU 2.4
+     */
+    public void setToLimit() {
+        setIndex(getLength());
+    }
+
+    /**
+     * Sets the current index to the start.
+     *
+     * @stable ICU 2.4
+     */
+    public void setToStart() {
+        setIndex(0);
+    }
+
+    /**
+     * Fills the buffer with the underlying text storage of the iterator If the buffer capacity is not enough a
+     * exception is thrown. The capacity of the fill in buffer should at least be equal to length of text in the
+     * iterator obtained by calling <code>getLength()</code>). <b>Usage:</b>
+     *
+     * <pre>
+     *         UChacterIterator iter = new UCharacterIterator.getInstance(text);
+     *         char[] buf = new char[iter.getLength()];
+     *         iter.getText(buf);
+     *
+     *         OR
+     *         char[] buf= new char[1];
+     *         int len = 0;
+     *         for(;;){
+     *             try{
+     *                 len = iter.getText(buf);
+     *                 break;
+     *             }catch(IndexOutOfBoundsException e){
+     *                 buf = new char[iter.getLength()];
+     *             }
+     *         }
+     * </pre>
+     *
+     * @param fillIn
+     *            an array of chars to fill with the underlying UTF-16 code units.
+     * @param offset
+     *            the position within the array to start putting the data.
+     * @return the number of code units added to fillIn, as a convenience
+     * @exception IndexOutOfBoundsException
+     *                exception if there is not enough room after offset in the array, or if offset &lt; 0.
+     * @stable ICU 2.4
+     */
+    public abstract int getText(char[] fillIn, int offset);
+
+    /**
+     * Convenience override for <code>getText(char[], int)</code> that provides an offset of 0.
+     *
+     * @param fillIn
+     *            an array of chars to fill with the underlying UTF-16 code units.
+     * @return the number of code units added to fillIn, as a convenience
+     * @exception IndexOutOfBoundsException
+     *                exception if there is not enough room in the array.
+     * @stable ICU 2.4
+     */
+    public final int getText(char[] fillIn) {
+        return getText(fillIn, 0);
+    }
+
+    /**
+     * Convenience method for returning the underlying text storage as as string
+     *
+     * @return the underlying text storage in the iterator as a string
+     * @stable ICU 2.4
+     */
+    public String getText() {
+        char[] text = new char[getLength()];
+        getText(text);
+        return new String(text);
+    }
+
+    /**
+     * Moves the current position by the number of code units specified, either forward or backward depending on the
+     * sign of delta (positive or negative respectively). If the resulting index would be less than zero, the index is
+     * set to zero, and if the resulting index would be greater than limit, the index is set to limit.
+     *
+     * @param delta
+     *            the number of code units to move the current index.
+     * @return the new index.
+     * @exception IndexOutOfBoundsException
+     *                is thrown if an invalid index is supplied
+     * @stable ICU 2.4
+     *
+     */
+    public int moveIndex(int delta) {
+        int x = Math.max(0, Math.min(getIndex() + delta, getLength()));
+        setIndex(x);
+        return x;
+    }
+
+    /**
+     * Moves the current position by the number of code points specified, either forward or backward depending on the
+     * sign of delta (positive or negative respectively). If the current index is at a trail surrogate then the first
+     * adjustment is by code unit, and the remaining adjustments are by code points. If the resulting index would be
+     * less than zero, the index is set to zero, and if the resulting index would be greater than limit, the index is
+     * set to limit.
+     *
+     * @param delta
+     *            the number of code units to move the current index.
+     * @return the new index
+     * @exception IndexOutOfBoundsException
+     *                is thrown if an invalid delta is supplied
+     * @stable ICU 2.4
+     */
+    public int moveCodePointIndex(int delta) {
+        if (delta > 0) {
+            while (delta > 0 && nextCodePoint() != DONE) {
+                delta--;
+            }
+        } else {
+            while (delta < 0 && previousCodePoint() != DONE) {
+                delta++;
+            }
+        }
+        if (delta != 0) {
+            throw new IndexOutOfBoundsException();
+        }
+
+        return getIndex();
+    }
+
+    /**
+     * Creates a copy of this iterator, independent from other iterators. If it is not possible to clone the iterator,
+     * returns null.
+     *
+     * @return copy of this iterator
+     * @stable ICU 2.4
+     */
+    @Override
+    public Object clone() throws CloneNotSupportedException {
+        return super.clone();
+    }
+
+}
diff --git a/app/src/main/java/com/ibm/icu/text/UFieldPosition.java b/icu4j/src/main/java/com/ibm/icu/text/UFieldPosition.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/text/UFieldPosition.java
rename to icu4j/src/main/java/com/ibm/icu/text/UFieldPosition.java
index 6fce6d1..537dd66 100644
--- a/app/src/main/java/com/ibm/icu/text/UFieldPosition.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/UFieldPosition.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2013-2014, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/UFormat.java b/icu4j/src/main/java/com/ibm/icu/text/UFormat.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/text/UFormat.java
rename to icu4j/src/main/java/com/ibm/icu/text/UFormat.java
index 35ac046..d372bec 100644
--- a/app/src/main/java/com/ibm/icu/text/UFormat.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/UFormat.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2003-2015, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/text/UForwardCharacterIterator.java b/icu4j/src/main/java/com/ibm/icu/text/UForwardCharacterIterator.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/text/UForwardCharacterIterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/UForwardCharacterIterator.java
index c2cd765..d81ccb4 100644
--- a/app/src/main/java/com/ibm/icu/text/UForwardCharacterIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/UForwardCharacterIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/UTF16.java b/icu4j/src/main/java/com/ibm/icu/text/UTF16.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/UTF16.java
rename to icu4j/src/main/java/com/ibm/icu/text/UTF16.java
index 657b98c..39ec183 100644
--- a/app/src/main/java/com/ibm/icu/text/UTF16.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/UTF16.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and
@@ -7,6 +9,8 @@
 
 package com.ibm.icu.text;
 
+import com.ibm.icu.impl.Utility;
+
 /**
  * <p>
  * Standalone utility class providing UTF16 character conversions and indexing conversions.
@@ -21,27 +25,27 @@ package com.ibm.icu.text;
  * <strong>Examples:</strong>
  * <p>
  * The following examples illustrate use of some of these methods.
- * 
+ *
  * <pre>
  * // iteration forwards: Original
  * for (int i = 0; i &lt; s.length(); ++i) {
  *     char ch = s.charAt(i);
  *     doSomethingWith(ch);
  * }
- * 
+ *
  * // iteration forwards: Changes for UTF-32
  * int ch;
  * for (int i = 0; i &lt; s.length(); i += UTF16.getCharCount(ch)) {
  *     ch = UTF16.charAt(s, i);
  *     doSomethingWith(ch);
  * }
- * 
+ *
  * // iteration backwards: Original
  * for (int i = s.length() - 1; i &gt;= 0; --i) {
  *     char ch = s.charAt(i);
  *     doSomethingWith(ch);
  * }
- * 
+ *
  * // iteration backwards: Changes for UTF-32
  * int ch;
  * for (int i = s.length() - 1; i &gt; 0; i -= UTF16.getCharCount(ch)) {
@@ -49,7 +53,7 @@ package com.ibm.icu.text;
  *     doSomethingWith(ch);
  * }
  * </pre>
- * 
+ *
  * <strong>Notes:</strong>
  * <ul>
  * <li> <strong>Naming:</strong> For clarity, High and Low surrogates are called <code>Lead</code>
@@ -73,7 +77,7 @@ package com.ibm.icu.text;
  * compiler doesn't fold static final methods. Since surrogate pairs will form an exceeding small
  * percentage of all the text in the world, the singleton case should always be optimized for. </li>
  * </ul>
- * 
+ *
  * @author Mark Davis, with help from Markus Scherer
  * @stable ICU 2.1
  */
@@ -85,7 +89,7 @@ public final class UTF16 {
      * Value returned in {@link #bounds(String, int) bounds()}.
      * These values are chosen specifically so that it actually represents the position of the
      * character [offset16 - (value &gt;&gt; 2), offset16 + (value &amp; 3)]
-     * 
+     *
      * @stable ICU 2.1
      */
     public static final int SINGLE_CHAR_BOUNDARY = 1, LEAD_SURROGATE_BOUNDARY = 2,
@@ -93,63 +97,63 @@ public final class UTF16 {
 
     /**
      * The lowest Unicode code point value.
-     * 
+     *
      * @stable ICU 2.1
      */
     public static final int CODEPOINT_MIN_VALUE = 0;
 
     /**
      * The highest Unicode code point value (scalar value) according to the Unicode Standard.
-     * 
+     *
      * @stable ICU 2.1
      */
     public static final int CODEPOINT_MAX_VALUE = 0x10ffff;
 
     /**
      * The minimum value for Supplementary code points
-     * 
+     *
      * @stable ICU 2.1
      */
     public static final int SUPPLEMENTARY_MIN_VALUE = 0x10000;
 
     /**
      * Lead surrogate minimum value
-     * 
+     *
      * @stable ICU 2.1
      */
     public static final int LEAD_SURROGATE_MIN_VALUE = 0xD800;
 
     /**
      * Trail surrogate minimum value
-     * 
+     *
      * @stable ICU 2.1
      */
     public static final int TRAIL_SURROGATE_MIN_VALUE = 0xDC00;
 
     /**
      * Lead surrogate maximum value
-     * 
+     *
      * @stable ICU 2.1
      */
     public static final int LEAD_SURROGATE_MAX_VALUE = 0xDBFF;
 
     /**
      * Trail surrogate maximum value
-     * 
+     *
      * @stable ICU 2.1
      */
     public static final int TRAIL_SURROGATE_MAX_VALUE = 0xDFFF;
 
     /**
      * Surrogate minimum value
-     * 
+     *
      * @stable ICU 2.1
      */
     public static final int SURROGATE_MIN_VALUE = LEAD_SURROGATE_MIN_VALUE;
 
     /**
      * Maximum surrogate value
-     * 
+     *
      * @stable ICU 2.1
      */
     public static final int SURROGATE_MAX_VALUE = TRAIL_SURROGATE_MAX_VALUE;
@@ -204,7 +208,7 @@ public final class UTF16 {
      * on the return value. If the char retrieved is part of a surrogate pair, its supplementary
      * character will be returned. If a complete supplementary character is not found the incomplete
      * character will be returned
-     * 
+     *
      * @param source Array of UTF-16 chars
      * @param offset16 UTF-16 offset to the start of the character.
      * @return UTF-32 value for the UTF-32 value that contains the char at offset16. The boundaries
@@ -258,7 +262,7 @@ public final class UTF16 {
      * on the return value. If the char retrieved is part of a surrogate pair, its supplementary
      * character will be returned. If a complete supplementary character is not found the incomplete
      * character will be returned
-     * 
+     *
      * @param source Array of UTF-16 chars
      * @param offset16 UTF-16 offset to the start of the character.
      * @return UTF-32 value for the UTF-32 value that contains the char at offset16. The boundaries
@@ -314,7 +318,7 @@ public final class UTF16 {
      * on the return value. If the char retrieved is part of a surrogate pair, its supplementary
      * character will be returned. If a complete supplementary character is not found the incomplete
      * character will be returned
-     * 
+     *
      * @param source UTF-16 chars string buffer
      * @param offset16 UTF-16 offset to the start of the character.
      * @return UTF-32 value for the UTF-32 value that contains the char at offset16. The boundaries
@@ -364,7 +368,7 @@ public final class UTF16 {
      * on the return value. If the char retrieved is part of a surrogate pair, its supplementary
      * character will be returned. If a complete supplementary character is not found the incomplete
      * character will be returned
-     * 
+     *
      * @param source Array of UTF-16 chars
      * @param start Offset to substring in the source array for analyzing
      * @param limit Offset to substring in the source array for analyzing
@@ -417,7 +421,7 @@ public final class UTF16 {
      * on the return value. If the char retrieved is part of a surrogate pair, its supplementary
      * character will be returned. If a complete supplementary character is not found the incomplete
      * character will be returned
-     * 
+     *
      * @param source UTF-16 chars string buffer
      * @param offset16 UTF-16 offset to the start of the character.
      * @return UTF-32 value for the UTF-32 value that contains the char at offset16. The boundaries
@@ -463,7 +467,7 @@ public final class UTF16 {
      * Determines how many chars this char32 requires. If a validity check is required, use <code>
      * <a href="../lang/UCharacter.html#isLegal(char)">isLegal()</a></code>
      * on char32 before calling.
-     * 
+     *
      * @param char32 The input codepoint.
      * @return 2 if is in supplementary space, otherwise 1.
      * @stable ICU 2.1
@@ -477,7 +481,7 @@ public final class UTF16 {
 
     /**
      * Returns the type of the boundaries around the char at offset16. Used for random access.
-     * 
+     *
      * @param source Text to analyse
      * @param offset16 UTF-16 offset
      * @return
@@ -513,7 +517,7 @@ public final class UTF16 {
 
     /**
      * Returns the type of the boundaries around the char at offset16. Used for random access.
-     * 
+     *
      * @param source String buffer to analyse
      * @param offset16 UTF16 offset
      * @return
@@ -551,7 +555,7 @@ public final class UTF16 {
      * Returns the type of the boundaries around the char at offset16. Used for random access. Note
      * that the boundaries are determined with respect to the subarray, hence the char array
      * {0xD800, 0xDC00} has the result SINGLE_CHAR_BOUNDARY for start = offset16 = 0 and limit = 1.
-     * 
+     *
      * @param source Char array to analyse
      * @param start Offset to substring in the source array for analyzing
      * @param limit Offset to substring in the source array for analyzing
@@ -593,7 +597,7 @@ public final class UTF16 {
 
     /**
      * Determines whether the code value is a surrogate.
-     * 
+     *
      * @param char16 The input character.
      * @return true If the input character is a surrogate.
      * @stable ICU 2.1
@@ -604,7 +608,7 @@ public final class UTF16 {
 
     /**
      * Determines whether the character is a trail surrogate.
-     * 
+     *
      * @param char16 The input character.
      * @return true If the input character is a trail surrogate.
      * @stable ICU 2.1
@@ -615,7 +619,7 @@ public final class UTF16 {
 
     /**
      * Determines whether the character is a lead surrogate.
-     * 
+     *
      * @param char16 The input character.
      * @return true If the input character is a lead surrogate
      * @stable ICU 2.1
@@ -628,7 +632,7 @@ public final class UTF16 {
      * Returns the lead surrogate. If a validity check is required, use
      * <code><a href="../lang/UCharacter.html#isLegal(char)">isLegal()</a></code> on char32
      * before calling.
-     * 
+     *
      * @param char32 The input character.
      * @return lead surrogate if the getCharCount(ch) is 2; <br>
      *         and 0 otherwise (note: 0 is not a valid lead surrogate).
@@ -645,7 +649,7 @@ public final class UTF16 {
      * Returns the trail surrogate. If a validity check is required, use
      * <code><a href="../lang/UCharacter.html#isLegal(char)">isLegal()</a></code> on char32
      * before calling.
-     * 
+     *
      * @param char32 The input character.
      * @return the trail surrogate if the getCharCount(ch) is 2; <br>
      *         otherwise the character itself
@@ -662,7 +666,7 @@ public final class UTF16 {
      * Convenience method corresponding to String.valueOf(char). Returns a one or two char string
      * containing the UTF-32 value in UTF16 format. If a validity check is required, use
      * {@link com.ibm.icu.lang.UCharacter#isLegal(int)} on char32 before calling.
-     * 
+     *
      * @param char32 The input character.
      * @return string value of char32 in UTF16 format
      * @exception IllegalArgumentException Thrown if char32 is a invalid codepoint.
@@ -682,7 +686,7 @@ public final class UTF16 {
      * required, use {@link com.ibm.icu.lang.UCharacter#isLegal(int)} on the
      * codepoint at offset16 before calling. The result returned will be a newly created String
      * obtained by calling source.substring(..) with the appropriate indexes.
-     * 
+     *
      * @param source The input string.
      * @param offset16 The UTF16 index to the codepoint in source
      * @return string value of char32 in UTF16 format
@@ -706,7 +710,7 @@ public final class UTF16 {
      * is required, use {@link com.ibm.icu.lang.UCharacter#isLegal(int)} on
      * the codepoint at offset16 before calling. The result returned will be a newly created String
      * obtained by calling source.substring(..) with the appropriate indexes.
-     * 
+     *
      * @param source The input string buffer.
      * @param offset16 The UTF16 index to the codepoint in source
      * @return string value of char32 in UTF16 format
@@ -732,7 +736,7 @@ public final class UTF16 {
      * {@link com.ibm.icu.lang.UCharacter#isLegal(int)} on the codepoint at
      * offset16 before calling. The result returned will be a newly created String containing the
      * relevant characters.
-     * 
+     *
      * @param source The input char array.
      * @param start Start index of the subarray
      * @param limit End index of the subarray
@@ -753,7 +757,7 @@ public final class UTF16 {
     /**
      * Returns the UTF-16 offset that corresponds to a UTF-32 offset. Used for random access. See
      * the {@link UTF16 class description} for notes on roundtripping.
-     * 
+     *
      * @param source The UTF-16 string
      * @param offset32 UTF-32 offset
      * @return UTF-16 offset
@@ -785,7 +789,7 @@ public final class UTF16 {
     /**
      * Returns the UTF-16 offset that corresponds to a UTF-32 offset. Used for random access. See
      * the {@link UTF16 class description} for notes on roundtripping.
-     * 
+     *
      * @param source The UTF-16 string buffer
      * @param offset32 UTF-32 offset
      * @return UTF-16 offset
@@ -817,7 +821,7 @@ public final class UTF16 {
     /**
      * Returns the UTF-16 offset that corresponds to a UTF-32 offset. Used for random access. See
      * the {@link UTF16 class description} for notes on roundtripping.
-     * 
+     *
      * @param source The UTF-16 char array whose substring is to be analysed
      * @param start Offset of the substring to be analysed
      * @param limit Offset of the substring to be analysed
@@ -856,11 +860,11 @@ public final class UTF16 {
      * of the <strong>lead</strong> of the pair is returned. </i>
      * <p>
      * To find the UTF-32 length of a string, use:
-     * 
+     *
      * <pre>
      * len32 = countCodePoint(source, source.length());
      * </pre>
-     * 
+     *
      * @param source Text to analyse
      * @param offset16 UTF-16 offset &lt; source text length.
      * @return UTF-32 offset
@@ -907,7 +911,7 @@ public final class UTF16 {
      * of the <strong>lead</strong> of the pair is returned. </i>
      * <p>
      * To find the UTF-32 length of a string, use:
-     * 
+     *
      * <pre>
      * len32 = countCodePoint(source);
      * </pre>
@@ -958,7 +962,7 @@ public final class UTF16 {
      * of the <strong>lead</strong> of the pair is returned. </i>
      * <p>
      * To find the UTF-32 length of a substring, use:
-     * 
+     *
      * <pre>
      * len32 = countCodePoint(source, start, limit);
      * </pre>
@@ -1008,7 +1012,7 @@ public final class UTF16 {
      * Append a single UTF-32 value to the end of a StringBuffer. If a validity check is required,
      * use {@link com.ibm.icu.lang.UCharacter#isLegal(int)} on char32 before
      * calling.
-     * 
+     *
      * @param target The buffer to append to
      * @param char32 Value to append.
      * @return the updated StringBuffer
@@ -1034,7 +1038,7 @@ public final class UTF16 {
     /**
      * Cover JDK 1.5 APIs. Append the code point to the buffer and return the buffer as a
      * convenience.
-     * 
+     *
      * @param target The buffer to append to
      * @param cp The code point to append
      * @return the updated StringBuffer
@@ -1047,7 +1051,7 @@ public final class UTF16 {
 
     /**
      * Adds a codepoint to offset16 position of the argument char array.
-     * 
+     *
      * @param target Char array to be append with the new code point
      * @param limit UTF16 offset which the codepoint will be appended.
      * @param char32 Code point to be appended
@@ -1073,7 +1077,7 @@ public final class UTF16 {
 
     /**
      * Number of codepoints in a UTF16 String
-     * 
+     *
      * @param source UTF16 string
      * @return number of codepoint in string
      * @stable ICU 2.1
@@ -1087,7 +1091,7 @@ public final class UTF16 {
 
     /**
      * Number of codepoints in a UTF16 String buffer
-     * 
+     *
      * @param source UTF16 string buffer
      * @return number of codepoint in string
      * @stable ICU 2.1
@@ -1101,7 +1105,7 @@ public final class UTF16 {
 
     /**
      * Number of codepoints in a UTF16 char array substring
-     * 
+     *
      * @param source UTF16 char array
      * @param start Offset of the substring
      * @param limit Offset of the substring
@@ -1119,7 +1123,7 @@ public final class UTF16 {
     /**
      * Set a code point into a UTF16 position. Adjusts target according if we are replacing a
      * non-supplementary codepoint with a supplementary and vice versa.
-     * 
+     *
      * @param target Stringbuffer
      * @param offset16 UTF16 position to insert into
      * @param char32 Code point
@@ -1150,7 +1154,7 @@ public final class UTF16 {
     /**
      * Set a code point into a UTF16 position in a char array. Adjusts target according if we are
      * replacing a non-supplementary codepoint with a supplementary and vice versa.
-     * 
+     *
      * @param target char array
      * @param limit numbers of valid chars in target, different from target.length. limit counts the
      *            number of chars in target that represents a string, not the size of array target.
@@ -1216,7 +1220,7 @@ public final class UTF16 {
 
     /**
      * Shifts offset16 by the argument number of codepoints
-     * 
+     *
      * @param source string
      * @param offset16 UTF16 position to shift
      * @param shift32 number of codepoints to shift
@@ -1270,7 +1274,7 @@ public final class UTF16 {
 
     /**
      * Shifts offset16 by the argument number of codepoints
-     * 
+     *
      * @param source String buffer
      * @param offset16 UTF16 position to shift
      * @param shift32 Number of codepoints to shift
@@ -1324,7 +1328,7 @@ public final class UTF16 {
 
     /**
      * Shifts offset16 by the argument number of codepoints within a subarray.
-     * 
+     *
      * @param source Char array
      * @param start Position of the subarray to be performed on
      * @param limit Position of the subarray to be performed on
@@ -1399,7 +1403,7 @@ public final class UTF16 {
      * <p>
      * The offset argument must be greater than or equal to 0, and less than or equal to the length
      * of source.
-     * 
+     *
      * @param target String buffer to insert to
      * @param offset16 Offset which char32 will be inserted in
      * @param char32 Codepoint to be inserted
@@ -1427,7 +1431,7 @@ public final class UTF16 {
      * </p>
      * <p>
      * The offset argument must be greater than or equal to 0, and less than or equal to the limit.
-     * 
+     *
      * @param target Char array to insert to
      * @param limit End index of the char array, limit &lt;= target.length
      * @param offset16 Offset which char32 will be inserted in
@@ -1456,7 +1460,7 @@ public final class UTF16 {
     /**
      * Removes the codepoint at the specified position in this target (shortening target by 1
      * character if the codepoint is a non-supplementary, 2 otherwise).
-     * 
+     *
      * @param target String buffer to remove codepoint from
      * @param offset16 Offset which the codepoint will be removed
      * @return a reference to target
@@ -1481,7 +1485,7 @@ public final class UTF16 {
     /**
      * Removes the codepoint at the specified position in this target (shortening target by 1
      * character if the codepoint is a non-supplementary, 2 otherwise).
-     * 
+     *
      * @param target String buffer to remove codepoint from
      * @param limit End index of the char array, limit &lt;= target.length
      * @param offset16 Offset which the codepoint will be removed
@@ -1521,7 +1525,7 @@ public final class UTF16 {
      * </p>
      * Note this method is provided as support to jdk 1.3, which does not support supplementary
      * characters to its fullest.
-     * 
+     *
      * @param source UTF16 format Unicode string that will be searched
      * @param char32 Codepoint to search for
      * @return the index of the first occurrence of the codepoint in the argument Unicode string, or
@@ -1575,7 +1579,7 @@ public final class UTF16 {
      * </p>
      * Note this method is provided as support to jdk 1.3, which does not support supplementary
      * characters to its fullest.
-     * 
+     *
      * @param source UTF16 format Unicode string that will be searched
      * @param str UTF16 format Unicode string to search for
      * @return the index of the first occurrence of the codepoint in the argument Unicode string, or
@@ -1621,7 +1625,7 @@ public final class UTF16 {
      * </p>
      * Note this method is provided as support to jdk 1.3, which does not support supplementary
      * characters to its fullest.
-     * 
+     *
      * @param source UTF16 format Unicode string that will be searched
      * @param char32 Codepoint to search for
      * @param fromIndex The index to start the search from.
@@ -1677,7 +1681,7 @@ public final class UTF16 {
      * </p>
      * Note this method is provided as support to jdk 1.3, which does not support supplementary
      * characters to its fullest.
-     * 
+     *
      * @param source UTF16 format Unicode string that will be searched
      * @param str UTF16 format Unicode string to search for
      * @param fromIndex The index to start the search from.
@@ -1724,7 +1728,7 @@ public final class UTF16 {
      * </p>
      * Note this method is provided as support to jdk 1.3, which does not support supplementary
      * characters to its fullest.
-     * 
+     *
      * @param source UTF16 format Unicode string that will be searched
      * @param char32 Codepoint to search for
      * @return the index of the last occurrence of the codepoint in source, or -1 if the codepoint
@@ -1778,7 +1782,7 @@ public final class UTF16 {
      * </p>
      * Note this method is provided as support to jdk 1.3, which does not support supplementary
      * characters to its fullest.
-     * 
+     *
      * @param source UTF16 format Unicode string that will be searched
      * @param str UTF16 format Unicode string to search for
      * @return the index of the last occurrence of the codepoint in source, or -1 if the codepoint
@@ -1830,7 +1834,7 @@ public final class UTF16 {
      * </p>
      * Note this method is provided as support to jdk 1.3, which does not support supplementary
      * characters to its fullest.
-     * 
+     *
      * @param source UTF16 format Unicode string that will be searched
      * @param char32 Codepoint to search for
      * @param fromIndex the index to start the search from. There is no restriction on the value of
@@ -1896,7 +1900,7 @@ public final class UTF16 {
      * </p>
      * Note this method is provided as support to jdk 1.3, which does not support supplementary
      * characters to its fullest.
-     * 
+     *
      * @param source UTF16 format Unicode string that will be searched
      * @param str UTF16 format Unicode string to search for
      * @param fromIndex the index to start the search from. There is no restriction on the value of
@@ -1951,7 +1955,7 @@ public final class UTF16 {
      * </p>
      * Note this method is provided as support to jdk 1.3, which does not support supplementary
      * characters to its fullest.
-     * 
+     *
      * @param source UTF16 format Unicode string which the codepoint replacements will be based on.
      * @param oldChar32 Non-zero old codepoint to be replaced.
      * @param newChar32 The new codepoint to replace oldChar32
@@ -2012,7 +2016,7 @@ public final class UTF16 {
      * </p>
      * Note this method is provided as support to jdk 1.3, which does not support supplementary
      * characters to its fullest.
-     * 
+     *
      * @param source UTF16 format Unicode string which the replacements will be based on.
      * @param oldStr Non-zero-length string to be replaced.
      * @param newStr The new string to replace oldStr
@@ -2047,7 +2051,7 @@ public final class UTF16 {
      * Examples:<br>
      * UTF16.reverse(new StringBuffer( "Supplementary characters \ud800\udc00\ud801\udc01"))<br>
      * returns "\ud801\udc01\ud800\udc00 sretcarahc yratnemelppuS".
-     * 
+     *
      * @param source The source StringBuffer that contains UTF16 format Unicode string to be reversed
      * @return a modified source with reversed UTF16 format Unicode string.
      * @stable ICU 2.6
@@ -2078,7 +2082,7 @@ public final class UTF16 {
      * certain range, and never needs to count more than 'number + 1' code points. Logically
      * equivalent to (countCodePoint(s) &gt; number). A Unicode code point may occupy either one or two
      * code units.
-     * 
+     *
      * @param source The input string.
      * @param number The number of code points in the string is compared against the 'number'
      *            parameter.
@@ -2140,7 +2144,7 @@ public final class UTF16 {
      * needs to count more than 'number + 1' code points. Logically equivalent to
      * (countCodePoint(source, start, limit) &gt; number). A Unicode code point may occupy either one
      * or two code units.
-     * 
+     *
      * @param source Array of UTF-16 chars
      * @param start Offset to substring in the source array for analyzing
      * @param limit Offset to substring in the source array for analyzing
@@ -2207,7 +2211,7 @@ public final class UTF16 {
      * length is within a certain range, and never needs to count more than 'number + 1' code
      * points. Logically equivalent to (countCodePoint(s) &gt; number). A Unicode code point may
      * occupy either one or two code units.
-     * 
+     *
      * @param source The input string buffer.
      * @param number The number of code points in the string buffer is compared against the 'number'
      *            parameter.
@@ -2264,7 +2268,7 @@ public final class UTF16 {
 
     /**
      * Cover JDK 1.5 API. Create a String from an array of codePoints.
-     * 
+     *
      * @param codePoints The code array
      * @param offset The start of the text in the code point array
      * @param count The number of code points
@@ -2324,7 +2328,7 @@ public final class UTF16 {
      * supplementary code points because they are stored as pairs of surrogates which are at
      * &#92;ud800..&#92;udfff.
      * </p>
-     * 
+     *
      * @see #FOLD_CASE_DEFAULT
      * @see #FOLD_CASE_EXCLUDE_SPECIAL_I
      * @stable ICU 2.1
@@ -2334,7 +2338,7 @@ public final class UTF16 {
 
         /**
          * Default constructor that does code unit comparison and case sensitive comparison.
-         * 
+         *
          * @stable ICU 2.1
          */
         public StringComparator() {
@@ -2343,7 +2347,7 @@ public final class UTF16 {
 
         /**
          * Constructor that does comparison based on the argument options.
-         * 
+         *
          * @param codepointcompare Flag to indicate true for code point comparison or false for code unit
          *            comparison.
          * @param ignorecase False for case sensitive comparison, true for case-insensitive comparison
@@ -2371,7 +2375,7 @@ public final class UTF16 {
          *
          * <p>Comparison is case insensitive, strings are folded using default mappings defined in
          * Unicode data file CaseFolding.txt, before comparison.
-         * 
+         *
          * @stable ICU 2.4
          */
         public static final int FOLD_CASE_DEFAULT = 0;
@@ -2383,7 +2387,7 @@ public final class UTF16 {
          *
          * <p>Comparison is case insensitive, strings are folded using modified mappings defined in
          * Unicode data file CaseFolding.txt, before comparison.
-         * 
+         *
          * @stable ICU 2.4
          * @see com.ibm.icu.lang.UCharacter#FOLD_CASE_EXCLUDE_SPECIAL_I
          */
@@ -2396,7 +2400,7 @@ public final class UTF16 {
         /**
          * Sets the comparison mode to code point compare if flag is true. Otherwise comparison mode
          * is set to code unit compare
-         * 
+         *
          * @param flag True for code point compare, false for code unit compare
          * @stable ICU 2.4
          */
@@ -2411,7 +2415,7 @@ public final class UTF16 {
         /**
          * Sets the Comparator to case-insensitive comparison mode if argument is true, otherwise
          * case sensitive comparison mode if set to false.
-         * 
+         *
          * @param ignorecase True for case-insitive comparison, false for case sensitive comparison
          * @param foldcaseoption FOLD_CASE_DEFAULT or FOLD_CASE_EXCLUDE_SPECIAL_I. This option is used only
          *            when ignorecase is set to true. If ignorecase is false, this option is
@@ -2432,7 +2436,7 @@ public final class UTF16 {
 
         /**
          * Checks if the comparison mode is code point compare.
-         * 
+         *
          * @return true for code point compare, false for code unit compare
          * @stable ICU 2.4
          */
@@ -2442,7 +2446,7 @@ public final class UTF16 {
 
         /**
          * Checks if Comparator is in the case insensitive mode.
-         * 
+         *
          * @return true if Comparator performs case insensitive comparison, false otherwise
          * @stable ICU 2.4
          */
@@ -2452,7 +2456,7 @@ public final class UTF16 {
 
         /**
          * Gets the fold case options set in Comparator to be used with case insensitive comparison.
-         * 
+         *
          * @return either FOLD_CASE_DEFAULT or FOLD_CASE_EXCLUDE_SPECIAL_I
          * @see #FOLD_CASE_DEFAULT
          * @see #FOLD_CASE_EXCLUDE_SPECIAL_I
@@ -2466,7 +2470,7 @@ public final class UTF16 {
 
         /**
          * Compare two strings depending on the options selected during construction.
-         * 
+         *
          * @param a first source string.
          * @param b second source string.
          * @return 0 returned if a == b. If a &lt; b, a negative value is returned. Otherwise if a &gt; b,
@@ -2474,8 +2478,9 @@ public final class UTF16 {
          * @exception ClassCastException thrown when either a or b is not a String object
          * @stable ICU 4.4
          */
+        @Override
         public int compare(String a, String b) {
-            if (a == b) {
+            if (Utility.sameObjects(a, b)) {
                 return 0;
             }
             if (a == null) {
@@ -2519,7 +2524,7 @@ public final class UTF16 {
         /**
          * Compares case insensitive. This is a direct port of ICU4C, to make maintainence life
          * easier.
-         * 
+         *
          * @param s1
          *            first string to compare
          * @param s2
@@ -2534,7 +2539,7 @@ public final class UTF16 {
         /**
          * Compares case sensitive. This is a direct port of ICU4C, to make maintainence life
          * easier.
-         * 
+         *
          * @param s1
          *            first string to compare
          * @param s2
@@ -2617,7 +2622,7 @@ public final class UTF16 {
         }
 
         // at this point, len = 2
-        int cp = Character.codePointAt(s, 0); 
+        int cp = Character.codePointAt(s, 0);
         if (cp > 0xFFFF) { // is surrogate pair
             return cp;
         }
@@ -2689,7 +2694,7 @@ public final class UTF16 {
      * <p>
      * The result is a string whose length is 1 for non-supplementary code points, 2 otherwise.
      * </p>
-     * 
+     *
      * @param ch
      *            code point
      * @return string representation of the code point
diff --git a/app/src/main/java/com/ibm/icu/text/UnescapeTransliterator.java b/icu4j/src/main/java/com/ibm/icu/text/UnescapeTransliterator.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/text/UnescapeTransliterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/UnescapeTransliterator.java
index e91f943..15b00f5 100644
--- a/app/src/main/java/com/ibm/icu/text/UnescapeTransliterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/UnescapeTransliterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 **********************************************************************
 *   Copyright (c) 2001-2011, International Business Machines
@@ -49,6 +51,7 @@ class UnescapeTransliterator extends Transliterator {
     static void register() {
         // Unicode: "U+10FFFF" hex, min=4, max=6
         Transliterator.registerFactory("Hex-Any/Unicode", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new UnescapeTransliterator("Hex-Any/Unicode", new char[] {
                     2, 0, 16, 4, 6, 'U', '+',
@@ -56,9 +59,10 @@ class UnescapeTransliterator extends Transliterator {
                 });
             }
         });
-        
+
         // Java: "\\uFFFF" hex, min=4, max=4
         Transliterator.registerFactory("Hex-Any/Java", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new UnescapeTransliterator("Hex-Any/Java", new char[] {
                     2, 0, 16, 4, 4, '\\', 'u',
@@ -66,9 +70,10 @@ class UnescapeTransliterator extends Transliterator {
                 });
             }
         });
-        
+
         // C: "\\uFFFF" hex, min=4, max=4; \\U0010FFFF hex, min=8, max=8
         Transliterator.registerFactory("Hex-Any/C", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new UnescapeTransliterator("Hex-Any/C", new char[] {
                     2, 0, 16, 4, 4, '\\', 'u',
@@ -77,9 +82,10 @@ class UnescapeTransliterator extends Transliterator {
                 });
             }
         });
-        
+
         // XML: "&#x10FFFF;" hex, min=1, max=6
         Transliterator.registerFactory("Hex-Any/XML", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new UnescapeTransliterator("Hex-Any/XML", new char[] {
                     3, 1, 16, 1, 6, '&', '#', 'x', ';',
@@ -90,6 +96,7 @@ class UnescapeTransliterator extends Transliterator {
 
         // XML10: "&1114111;" dec, min=1, max=7 (not really "Hex-Any")
         Transliterator.registerFactory("Hex-Any/XML10", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new UnescapeTransliterator("Hex-Any/XML10", new char[] {
                     2, 1, 10, 1, 7, '&', '#', ';',
@@ -100,6 +107,7 @@ class UnescapeTransliterator extends Transliterator {
 
         // Perl: "\\x{263A}" hex, min=1, max=6
         Transliterator.registerFactory("Hex-Any/Perl", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new UnescapeTransliterator("Hex-Any/Perl", new char[] {
                     3, 1, 16, 1, 6, '\\', 'x', '{', '}',
@@ -110,6 +118,7 @@ class UnescapeTransliterator extends Transliterator {
 
         // All: Java, C, Perl, XML, XML10, Unicode
         Transliterator.registerFactory("Hex-Any", new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new UnescapeTransliterator("Hex-Any", new char[] {
                     2, 0, 16, 4, 6, 'U', '+',            // Unicode
@@ -135,6 +144,7 @@ class UnescapeTransliterator extends Transliterator {
     /**
      * Implements {@link Transliterator#handleTransliterate}.
      */
+    @Override
     protected void handleTransliterate(Replaceable text,
                                        Position pos, boolean isIncremental) {
         int start = pos.start;
diff --git a/app/src/main/java/com/ibm/icu/text/UnhandledBreakEngine.java b/icu4j/src/main/java/com/ibm/icu/text/UnhandledBreakEngine.java
similarity index 66%
rename from app/src/main/java/com/ibm/icu/text/UnhandledBreakEngine.java
rename to icu4j/src/main/java/com/ibm/icu/text/UnhandledBreakEngine.java
index 3e2026b..f5d7a35 100644
--- a/app/src/main/java/com/ibm/icu/text/UnhandledBreakEngine.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/UnhandledBreakEngine.java
@@ -1,6 +1,8 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2014, International Business Machines Corporation and         *
+ * Copyright (C) 2016, International Business Machines Corporation and         *
  * others. All Rights Reserved.                                                *
  *******************************************************************************
  */
@@ -10,6 +12,7 @@ import static com.ibm.icu.impl.CharacterIteration.DONE32;
 
 import java.text.CharacterIterator;
 
+import com.ibm.icu.impl.CharacterIteration;
 import com.ibm.icu.lang.UCharacter;
 import com.ibm.icu.lang.UProperty;
 
@@ -30,7 +33,20 @@ final class UnhandledBreakEngine implements LanguageBreakEngine {
 
     public int findBreaks(CharacterIterator text, int startPos, int endPos,
             boolean reverse, int breakType, DictionaryBreakEngine.DequeI foundBreaks) {
-        text.setIndex(endPos);
+        if (breakType >= 0 && breakType < fHandled.length) { 
+            int c = CharacterIteration.current32(text); 
+            if (reverse) { 
+                while (text.getIndex() > startPos && fHandled[breakType].contains(c)) { 
+                    CharacterIteration.previous32(text); 
+                    c = CharacterIteration.current32(text); 
+                } 
+            } else { 
+                while (text.getIndex() < endPos && fHandled[breakType].contains(c)) { 
+                    CharacterIteration.next32(text); 
+                    c = CharacterIteration.current32(text); 
+                } 
+            } 
+        } 
         return 0;
     }
 
diff --git a/app/src/main/java/com/ibm/icu/text/UnicodeCompressor.java b/icu4j/src/main/java/com/ibm/icu/text/UnicodeCompressor.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/UnicodeCompressor.java
rename to icu4j/src/main/java/com/ibm/icu/text/UnicodeCompressor.java
index 30b437c..2f79285 100644
--- a/app/src/main/java/com/ibm/icu/text/UnicodeCompressor.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/UnicodeCompressor.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/UnicodeDecompressor.java b/icu4j/src/main/java/com/ibm/icu/text/UnicodeDecompressor.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/UnicodeDecompressor.java
rename to icu4j/src/main/java/com/ibm/icu/text/UnicodeDecompressor.java
index e799ea1..6789469 100644
--- a/app/src/main/java/com/ibm/icu/text/UnicodeDecompressor.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/UnicodeDecompressor.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/UnicodeFilter.java b/icu4j/src/main/java/com/ibm/icu/text/UnicodeFilter.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/text/UnicodeFilter.java
rename to icu4j/src/main/java/com/ibm/icu/text/UnicodeFilter.java
index a7e71a6..3f88e68 100644
--- a/app/src/main/java/com/ibm/icu/text/UnicodeFilter.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/UnicodeFilter.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and    *
@@ -32,6 +34,7 @@ public abstract class UnicodeFilter implements UnicodeMatcher {
      * filters.  Matches a single 16-bit code unit at offset.
      * @stable ICU 2.0
      */
+    @Override
     public int matches(Replaceable text,
                        int[] offset,
                        int limit,
diff --git a/app/src/main/java/com/ibm/icu/text/UnicodeMatcher.java b/icu4j/src/main/java/com/ibm/icu/text/UnicodeMatcher.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/text/UnicodeMatcher.java
rename to icu4j/src/main/java/com/ibm/icu/text/UnicodeMatcher.java
index a824e7f..1117a10 100644
--- a/app/src/main/java/com/ibm/icu/text/UnicodeMatcher.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/UnicodeMatcher.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2001-2016, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/UnicodeNameTransliterator.java b/icu4j/src/main/java/com/ibm/icu/text/UnicodeNameTransliterator.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/text/UnicodeNameTransliterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/UnicodeNameTransliterator.java
index f5bb5ad..6a7d16e 100644
--- a/app/src/main/java/com/ibm/icu/text/UnicodeNameTransliterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/UnicodeNameTransliterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  * Copyright (C) 1996-2010, International Business Machines Corporation and
  * others. All Rights Reserved.
@@ -23,6 +25,7 @@ class UnicodeNameTransliterator extends Transliterator {
      */
     static void register() {
         Transliterator.registerFactory(_ID, new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new UnicodeNameTransliterator(null);
             }
@@ -39,20 +42,21 @@ class UnicodeNameTransliterator extends Transliterator {
     /**
      * Implements {@link Transliterator#handleTransliterate}.
      */
+    @Override
     protected void handleTransliterate(Replaceable text,
                                        Position offsets, boolean isIncremental) {
         int cursor = offsets.start;
         int limit = offsets.limit;
-        
+
         StringBuilder str = new StringBuilder();
         str.append(OPEN_DELIM);
         int len;
         String name;
-        
+
         while (cursor < limit) {
             int c = text.char32At(cursor);
             if ((name=UCharacter.getExtendedName(c)) != null) {
-                
+
                 str.setLength(OPEN_DELIM_LEN);
                 str.append(name).append(CLOSE_DELIM);
 
diff --git a/app/src/main/java/com/ibm/icu/text/UnicodeReplacer.java b/icu4j/src/main/java/com/ibm/icu/text/UnicodeReplacer.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/text/UnicodeReplacer.java
rename to icu4j/src/main/java/com/ibm/icu/text/UnicodeReplacer.java
index 49c4c37..2a040e9 100644
--- a/app/src/main/java/com/ibm/icu/text/UnicodeReplacer.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/UnicodeReplacer.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 **********************************************************************
 *   Copyright (c) 2002, International Business Machines Corporation
diff --git a/app/src/main/java/com/ibm/icu/text/UnicodeSet.java b/icu4j/src/main/java/com/ibm/icu/text/UnicodeSet.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/UnicodeSet.java
rename to icu4j/src/main/java/com/ibm/icu/text/UnicodeSet.java
index 957bb82..38510c3 100644
--- a/app/src/main/java/com/ibm/icu/text/UnicodeSet.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/UnicodeSet.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and
@@ -505,6 +507,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
      * Return a new set that is equivalent to this one.
      * @stable ICU 2.0
      */
+    @Override
     public Object clone() {
         if (isFrozen()) {
             return this;
@@ -692,6 +695,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
      * will produce another set that is equal to this one.
      * @stable ICU 2.0
      */
+    @Override
     public String toPattern(boolean escapeUnprintable) {
         if (pat != null && !escapeUnprintable) {
             return pat;
@@ -862,6 +866,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
      * indexing.
      * @stable ICU 2.0
      */
+    @Override
     public boolean matchesIndexValue(int v) {
         /* The index value v, in the range [0,255], is contained in this set if
          * it is contained in any pair of this set.  Pairs either have the high
@@ -903,6 +908,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
      * longest possible multichar string.
      * @stable ICU 2.0
      */
+    @Override
     public int matches(Replaceable text,
             int[] offset,
             int limit,
@@ -913,7 +919,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
             // about them here.  If we ever allow zero-length strings
             // we much check for them here.
             if (contains(UnicodeMatcher.ETHER)) {
-                return incremental ? U_PARTIAL_MATCH : U_MATCH; 
+                return incremental ? U_PARTIAL_MATCH : U_MATCH;
             } else {
                 return U_MISMATCH;
             }
@@ -949,7 +955,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
                     // Strings are sorted, so we can optimize in the
                     // forward direction.
                     if (forward && c > firstChar) break;
-                    if (c != firstChar) continue; 
+                    if (c != firstChar) continue;
 
                     int length = matchRest(text, offset[0], limit, trial);
 
@@ -1028,7 +1034,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
     }
 
     /**
-     * Tests whether the text matches at the offset. If so, returns the end of the longest substring that it matches. If not, returns -1. 
+     * Tests whether the text matches at the offset. If so, returns the end of the longest substring that it matches. If not, returns -1.
      * @internal
      * @deprecated This API is ICU internal only.
      */
@@ -1096,6 +1102,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
      * @param toUnionTo the set into which to union the source characters
      * @stable ICU 2.2
      */
+    @Override
     public void addMatchSetTo(UnicodeSet toUnionTo) {
         toUnionTo.addAll(this);
     }
@@ -1262,7 +1269,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
             // c is before start of next range
             list[i] = c;
             // if we touched the HIGH mark, then add a new one
-            if (c == MAX_VALUE) { 
+            if (c == MAX_VALUE) {
                 ensureCapacity(len+1);
                 list[len++] = HIGH;
             }
@@ -1354,7 +1361,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
         if (s.length() == 1) return s.charAt(0);
 
         // at this point, len = 2
-        int cp = UTF16.charAt(s, 0); 
+        int cp = UTF16.charAt(s, 0);
         if (cp > 0xFFFF) { // is surrogate pair
             return cp;
         }
@@ -1497,7 +1504,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
      */
     public final UnicodeSet retain(CharSequence cs) {
 
-        int cp = getSingleCP(cs); 
+        int cp = getSingleCP(cs);
         if (cp < 0) {
             String s = cs.toString();
             boolean isIn = strings.contains(s);
@@ -1659,6 +1666,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
      * @return true if the test condition is met
      * @stable ICU 2.0
      */
+    @Override
     public boolean contains(int c) {
         if (c < MIN_VALUE || c > MAX_VALUE) {
             throw new IllegalArgumentException("Invalid code point U+" + Utility.hex(c, 6));
@@ -2323,6 +2331,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
      * @return <tt>true</tt> if the specified Object is equal to this set.
      * @stable ICU 2.0
      */
+    @Override
     public boolean equals(Object o) {
         if (o == null) {
             return false;
@@ -2350,6 +2359,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
      * @see java.lang.Object#hashCode()
      * @stable ICU 2.0
      */
+    @Override
     public int hashCode() {
         int result = len;
         for (int i = 0; i < len; ++i) {
@@ -2363,6 +2373,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
      * Return a programmer-readable string representation of this object.
      * @stable ICU 2.0
      */
+    @Override
     public String toString() {
         return toPattern(true);
     }
@@ -2434,17 +2445,17 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
 
     // Add constants to make the applyPattern() code easier to follow.
 
-    private static final int LAST0_START = 0, 
-            LAST1_RANGE = 1, 
+    private static final int LAST0_START = 0,
+            LAST1_RANGE = 1,
             LAST2_SET = 2;
 
-    private static final int MODE0_NONE = 0, 
-            MODE1_INBRACKET = 1, 
+    private static final int MODE0_NONE = 0,
+            MODE1_INBRACKET = 1,
             MODE2_OUTBRACKET = 2;
 
-    private static final int SETMODE0_NONE = 0, 
-            SETMODE1_UNICODESET = 1, 
-            SETMODE2_PROPERTYPAT = 2, 
+    private static final int SETMODE0_NONE = 0,
+            SETMODE1_UNICODESET = 1,
+            SETMODE2_PROPERTYPAT = 2,
             SETMODE3_PREPARSED = 3;
 
     /**
@@ -2883,7 +2894,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
     }
 
     /**
-     * Add the contents of the collection (as strings) into this UnicodeSet. 
+     * Add the contents of the collection (as strings) into this UnicodeSet.
      * The collection must not contain null.
      * @param source the collection to add
      * @return a reference to this object
@@ -2914,7 +2925,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
 
     private void ensureCapacity(int newLen) {
         if (newLen <= list.length) return;
-        int[] temp = new int[newLen + GROW_EXTRA]; 
+        int[] temp = new int[newLen + GROW_EXTRA];
         System.arraycopy(list, 0, temp, 0, len);
         list = temp;
     }
@@ -3173,6 +3184,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
     private static class NumericValueFilter implements Filter {
         double value;
         NumericValueFilter(double value) { this.value = value; }
+        @Override
         public boolean contains(int ch) {
             return UCharacter.getUnicodeNumericValue(ch) == value;
         }
@@ -3181,6 +3193,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
     private static class GeneralCategoryMaskFilter implements Filter {
         int mask;
         GeneralCategoryMaskFilter(int mask) { this.mask = mask; }
+        @Override
         public boolean contains(int ch) {
             return ((1 << UCharacter.getType(ch)) & mask) != 0;
         }
@@ -3193,6 +3206,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
             this.prop = prop;
             this.value = value;
         }
+        @Override
         public boolean contains(int ch) {
             return UCharacter.getIntPropertyValue(ch, prop) == value;
         }
@@ -3201,6 +3215,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
     private static class ScriptExtensionsFilter implements Filter {
         int script;
         ScriptExtensionsFilter(int script) { this.script = script; }
+        @Override
         public boolean contains(int c) {
             return UScript.hasScript(c, script);
         }
@@ -3212,11 +3227,12 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
     private static class VersionFilter implements Filter {
         VersionInfo version;
         VersionFilter(VersionInfo version) { this.version = version; }
+        @Override
         public boolean contains(int ch) {
             VersionInfo v = UCharacter.getAge(ch);
             // Reference comparison ok; VersionInfo caches and reuses
             // unique objects.
-            return v != NO_VERSION &&
+            return !Utility.sameObjects(v, NO_VERSION) &&
                     v.compareTo(version) <= 0;
         }
     }
@@ -3921,6 +3937,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
          * @draft ICU3.8 (retain)
          * @provisional This API might change or be removed in a future release.
          */
+        @Override
         public UnicodeMatcher lookupMatcher(int i) {
             return null;
         }
@@ -3931,7 +3948,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
          * <p>
          * This routine will be called whenever the parsing of a UnicodeSet pattern finds such a
          * propertyName+propertyValue combination.
-         * 
+         *
          * @param propertyName
          *            the name of the property
          * @param propertyValue
@@ -3952,6 +3969,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
          * @draft ICU3.8 (retain)
          * @provisional This API might change or be removed in a future release.
          */
+        @Override
         public char[] lookup(String s) {
             return null;
         }
@@ -3960,6 +3978,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
          * @draft ICU3.8 (retain)
          * @provisional This API might change or be removed in a future release.
          */
+        @Override
         public String parseReference(String text, ParsePosition pos, int limit) {
             return null;
         }
@@ -3967,20 +3986,22 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
 
     /**
      * Is this frozen, according to the Freezable interface?
-     * 
+     *
      * @return value
      * @stable ICU 3.8
      */
+    @Override
     public boolean isFrozen() {
         return (bmpSet != null || stringSpan != null);
     }
 
     /**
      * Freeze this class, according to the Freezable interface.
-     * 
+     *
      * @return this
      * @stable ICU 4.4
      */
+    @Override
     public UnicodeSet freeze() {
         if (!isFrozen()) {
             // Do most of what compact() does before freezing because
@@ -4188,6 +4209,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
      * @return the clone, not frozen
      * @stable ICU 4.4
      */
+    @Override
     public UnicodeSet cloneAsThawed() {
         UnicodeSet result = new UnicodeSet(this);
         assert !result.isFrozen();
@@ -4208,19 +4230,19 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
     /**
      * A struct-like class used for iteration through ranges, for faster iteration than by String.
      * Read about the restrictions on usage in {@link UnicodeSet#ranges()}.
-     * 
+     *
      * @stable ICU 54
      */
     public static class EntryRange {
         /**
          * The starting code point of the range.
-         * 
+         *
          * @stable ICU 54
          */
         public int codepoint;
         /**
          * The ending code point of the range
-         * 
+         *
          * @stable ICU 54
          */
         public int codepointEnd;
@@ -4230,13 +4252,13 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
 
         /**
          * {@inheritDoc}
-         * 
+         *
          * @stable ICU 54
          */
         @Override
         public String toString() {
             StringBuilder b = new StringBuilder();
-            return ( 
+            return (
                     codepoint == codepointEnd ? _appendToPat(b, codepoint, false)
                             : _appendToPat(_appendToPat(b, codepoint, false).append('-'), codepointEnd, false))
                             .toString();
@@ -4250,9 +4272,9 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
      *
      * <p><b>Warning: </b>To iterate over the full contents, you have to also iterate over the strings.
      *
-     * <p><b>Warning: </b>For speed, UnicodeSet iteration does not check for concurrent modification. 
+     * <p><b>Warning: </b>For speed, UnicodeSet iteration does not check for concurrent modification.
      * Do not alter the UnicodeSet while iterating.
-     * 
+     *
      * <pre>
      * // Sample code
      * for (EntryRange range : us1.ranges()) {
@@ -4262,7 +4284,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
      *     // do something with each string;
      * }
      * </pre>
-     * 
+     *
      * @stable ICU 54
      */
     public Iterable<EntryRange> ranges() {
@@ -4270,6 +4292,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
     }
 
     private class EntryRangeIterable implements Iterable<EntryRange> {
+        @Override
         public Iterator<EntryRange> iterator() {
             return new EntryRangeIterator();
         }
@@ -4279,9 +4302,11 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
         int pos;
         EntryRange result = new EntryRange();
 
+        @Override
         public boolean hasNext() {
             return pos < len-1;
         }
+        @Override
         public EntryRange next() {
             if (pos < len-1) {
                 result.codepoint = list[pos++];
@@ -4291,6 +4316,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
             }
             return result;
         }
+        @Override
         public void remove() {
             throw new UnsupportedOperationException();
         }
@@ -4299,16 +4325,17 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
 
     /**
      * Returns a string iterator. Uses the same order of iteration as {@link UnicodeSetIterator}.
-     * <p><b>Warning: </b>For speed, UnicodeSet iteration does not check for concurrent modification. 
+     * <p><b>Warning: </b>For speed, UnicodeSet iteration does not check for concurrent modification.
      * Do not alter the UnicodeSet while iterating.
      * @see java.util.Set#iterator()
      * @stable ICU 4.4
      */
+    @Override
     public Iterator<String> iterator() {
         return new UnicodeSetIterator2(this);
     }
 
-    // Cover for string iteration. 
+    // Cover for string iteration.
     private static class UnicodeSetIterator2 implements Iterator<String> {
         // Invariants:
         // sourceList != null then sourceList[item] is a valid character
@@ -4339,6 +4366,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
         /* (non-Javadoc)
          * @see java.util.Iterator#hasNext()
          */
+        @Override
         public boolean hasNext() {
             return sourceList != null || stringIterator.hasNext();
         }
@@ -4346,6 +4374,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
         /* (non-Javadoc)
          * @see java.util.Iterator#next()
          */
+        @Override
         public String next() {
             if (sourceList == null) {
                 return stringIterator.next();
@@ -4380,9 +4409,10 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
         /* (non-Javadoc)
          * @see java.util.Iterator#remove()
          */
+        @Override
         public void remove() {
             throw new UnsupportedOperationException();
-        }  
+        }
     }
 
     /**
@@ -4483,6 +4513,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
      * @see java.lang.Comparable#compareTo(java.lang.Object)
      * @stable ICU 4.4
      */
+    @Override
     public int compareTo(UnicodeSet o) {
         return compareTo(o, ComparisonStyle.SHORTER_FIRST);
     }
@@ -4510,7 +4541,8 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
                 if (o.list[i] == HIGH) {
                     if (o.strings.isEmpty()) return -1;
                     String item = o.strings.first();
-                    return -compare(item, list[i]);
+                    int compareResult = compare(item, list[i]);
+                    return compareResult > 0 ? -1 : compareResult < 0 ? 1 : 0; // Reverse the order.
                 }
                 // otherwise return the result if even index, or the reversal if not
                 return (i & 1) == 0 ? result : -result;
@@ -4532,7 +4564,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
     /**
      * Utility to compare a string to a code point.
      * Same results as turning the code point into a string (with the [ugly] new StringBuilder().appendCodePoint(codepoint).toString())
-     * and comparing, but much faster (no object creation). 
+     * and comparing, but much faster (no object creation).
      * Actually, there is one difference; a null compares as less.
      * Note that this (=String) order is UTF-16 order -- *not* code point order.
      * @stable ICU 4.4
@@ -4544,7 +4576,7 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
 
     /**
      * Utility to compare a string to a code point.
-     * Same results as turning the code point into a string and comparing, but much faster (no object creation). 
+     * Same results as turning the code point into a string and comparing, but much faster (no object creation).
      * Actually, there is one difference; a null compares as less.
      * Note that this (=String) order is UTF-16 order -- *not* code point order.
      * @stable ICU 4.4
@@ -4654,8 +4686,8 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
     }
 
     /**
-     * Simplify the ranges in a Unicode set by merging any ranges that are only separated by characters in the dontCare set. 
-     * For example, the ranges: \\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u2FF0-\\u2FFB\\u3000-\\u303E change to \\u2E80-\\u303E 
+     * Simplify the ranges in a Unicode set by merging any ranges that are only separated by characters in the dontCare set.
+     * For example, the ranges: \\u2E80-\\u2E99\\u2E9B-\\u2EF3\\u2F00-\\u2FD5\\u2FF0-\\u2FFB\\u3000-\\u303E change to \\u2E80-\\u303E
      * if the dontCare set includes unassigned characters (for a particular version of Unicode).
      * @param dontCare Set with the don't-care characters for spanning
      * @return the input set, modified
@@ -4851,14 +4883,14 @@ public class UnicodeSet extends UnicodeFilter implements Iterable<String>, Compa
      * Unassigned characters (gc=Cn) are different than in ICU other than in ICU, you MUST call
      * {@code UnicodeProperty.ResetCacheProperties} afterwards. If you then call {@code UnicodeSet.setDefaultXSymbolTable}
      * with null to clear the value, you MUST also call {@code UnicodeProperty.ResetCacheProperties}.
-     * 
+     *
      * @param xSymbolTable the new default symbol table.
      * @internal
      * @deprecated This API is ICU internal only.
      */
     @Deprecated
     public static void setDefaultXSymbolTable(XSymbolTable xSymbolTable) {
-        INCLUSIONS = null; // If the properties override inclusions, these have to be regenerated. 
+        INCLUSIONS = null; // If the properties override inclusions, these have to be regenerated.
         XSYMBOL_TABLE = xSymbolTable;
     }
 }
diff --git a/app/src/main/java/com/ibm/icu/text/UnicodeSetIterator.java b/icu4j/src/main/java/com/ibm/icu/text/UnicodeSetIterator.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/text/UnicodeSetIterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/UnicodeSetIterator.java
index cecfc44..e7e6c8e 100644
--- a/app/src/main/java/com/ibm/icu/text/UnicodeSetIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/UnicodeSetIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2014, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/text/UnicodeSetSpanner.java b/icu4j/src/main/java/com/ibm/icu/text/UnicodeSetSpanner.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/text/UnicodeSetSpanner.java
rename to icu4j/src/main/java/com/ibm/icu/text/UnicodeSetSpanner.java
index e8ca490..f52dc3f 100644
--- a/app/src/main/java/com/ibm/icu/text/UnicodeSetSpanner.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/UnicodeSetSpanner.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014-2016, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/text/UppercaseTransliterator.java b/icu4j/src/main/java/com/ibm/icu/text/UppercaseTransliterator.java
similarity index 62%
rename from app/src/main/java/com/ibm/icu/text/UppercaseTransliterator.java
rename to icu4j/src/main/java/com/ibm/icu/text/UppercaseTransliterator.java
index ae6beb9..77e2dfd 100644
--- a/app/src/main/java/com/ibm/icu/text/UppercaseTransliterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/text/UppercaseTransliterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2011, International Business Machines Corporation and    *
@@ -20,22 +22,23 @@ class UppercaseTransliterator extends Transliterator {
      * Package accessible ID.
      */
     static final String _ID = "Any-Upper";
-    // TODO: Add variants for tr, az, lt, default = default locale
+    // TODO: Add variants for tr/az, el, lt, default = default locale: ICU ticket #12720
 
     /**
      * System registration hook.
      */
     static void register() {
         Transliterator.registerFactory(_ID, new Transliterator.Factory() {
+            @Override
             public Transliterator getInstance(String ID) {
                 return new UppercaseTransliterator(ULocale.US);
             }
         });
     }
 
-    private ULocale locale;
+    private final ULocale locale;
 
-    private UCaseProps csp;
+    private final UCaseProps csp;
     private ReplaceableContextIterator iter;
     private StringBuilder result;
     private int[] locCache;
@@ -56,46 +59,47 @@ class UppercaseTransliterator extends Transliterator {
     /**
      * Implements {@link Transliterator#handleTransliterate}.
      */
+    @Override
     protected synchronized void handleTransliterate(Replaceable text,
-                                       Position offsets, boolean isIncremental) {
-    if(csp==null) {
-        return;
-    }
+                Position offsets, boolean isIncremental) {
+        if(csp==null) {
+            return;
+        }
 
-    if(offsets.start >= offsets.limit) {
-        return;
-    } 
+        if(offsets.start >= offsets.limit) {
+            return;
+        }
 
-    iter.setText(text);
-    result.setLength(0);
-    int c, delta;
+        iter.setText(text);
+        result.setLength(0);
+        int c, delta;
 
-    // Walk through original string
-    // If there is a case change, modify corresponding position in replaceable
+        // Walk through original string
+        // If there is a case change, modify corresponding position in replaceable
 
-    iter.setIndex(offsets.start);
-    iter.setLimit(offsets.limit);
-    iter.setContextLimits(offsets.contextStart, offsets.contextLimit);
-    while((c=iter.nextCaseMapCP())>=0) {
-        c=csp.toFullUpper(c, iter, result, locale, locCache);
+        iter.setIndex(offsets.start);
+        iter.setLimit(offsets.limit);
+        iter.setContextLimits(offsets.contextStart, offsets.contextLimit);
+        while((c=iter.nextCaseMapCP())>=0) {
+            c=csp.toFullUpper(c, iter, result, locale, locCache);
 
-        if(iter.didReachLimit() && isIncremental) {
-            // the case mapping function tried to look beyond the context limit
-            // wait for more input
-            offsets.start=iter.getCaseMapCPStart();
-            return;
-        }
+            if(iter.didReachLimit() && isIncremental) {
+                // the case mapping function tried to look beyond the context limit
+                // wait for more input
+                offsets.start=iter.getCaseMapCPStart();
+                return;
+            }
 
-        /* decode the result */
-        if(c<0) {
-            /* c mapped to itself, no change */
-            continue;
-        } else if(c<=UCaseProps.MAX_STRING_LENGTH) {
-            /* replace by the mapping string */
-            delta=iter.replace(result.toString());
-            result.setLength(0);
-        } else {
-            /* replace by single-code point mapping */
+            /* decode the result */
+            if(c<0) {
+                /* c mapped to itself, no change */
+                continue;
+            } else if(c<=UCaseProps.MAX_STRING_LENGTH) {
+                /* replace by the mapping string */
+                delta=iter.replace(result.toString());
+                result.setLength(0);
+            } else {
+                /* replace by single-code point mapping */
                 delta=iter.replace(UTF16.valueOf(c));
             }
 
@@ -109,7 +113,7 @@ class UppercaseTransliterator extends Transliterator {
 
     // NOTE: normally this would be static, but because the results vary by locale....
     SourceTargetUtility sourceTargetUtility = null;
-    
+
     /* (non-Javadoc)
      * @see com.ibm.icu.text.Transliterator#addSourceTargetSet(com.ibm.icu.text.UnicodeSet, com.ibm.icu.text.UnicodeSet, com.ibm.icu.text.UnicodeSet)
      */
@@ -118,6 +122,7 @@ class UppercaseTransliterator extends Transliterator {
         synchronized (this) {
             if (sourceTargetUtility == null) {
                 sourceTargetUtility = new SourceTargetUtility(new Transform<String,String>() {
+                    @Override
                     public String transform(String source) {
                         return UCharacter.toUpperCase(locale, source);
                     }
diff --git a/app/src/main/java/com/ibm/icu/util/AnnualTimeZoneRule.java b/icu4j/src/main/java/com/ibm/icu/util/AnnualTimeZoneRule.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/util/AnnualTimeZoneRule.java
rename to icu4j/src/main/java/com/ibm/icu/util/AnnualTimeZoneRule.java
index 20df6a6..5ae8516 100644
--- a/app/src/main/java/com/ibm/icu/util/AnnualTimeZoneRule.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/AnnualTimeZoneRule.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2007-2010, International Business Machines Corporation and    *
@@ -14,7 +16,7 @@ import com.ibm.icu.impl.Grego;
  * <code>AnnualTimeZoneRule</code> is a class used for representing a time zone
  * rule which takes effect annually.  Years used in this class are
  * all Gregorian calendar years.
- * 
+ *
  * @stable ICU 3.8
  */
 public class AnnualTimeZoneRule extends TimeZoneRule {
@@ -35,7 +37,7 @@ public class AnnualTimeZoneRule extends TimeZoneRule {
      * Constructs a <code>AnnualTimeZoneRule</code> with the name, the GMT offset of its
      * standard time, the amount of daylight saving offset adjustment,
      * the annual start time rule and the start/until years.
-     * 
+     *
      * @param name          The time zone name.
      * @param rawOffset     The GMT offset of its standard time in milliseconds.
      * @param dstSavings    The amount of daylight saving offset adjustment in
@@ -45,7 +47,7 @@ public class AnnualTimeZoneRule extends TimeZoneRule {
      * @param startYear     The first year when this rule takes effect.
      * @param endYear       The last year when this rule takes effect.  If this
      *                      rule is effective forever in future, specify MAX_YEAR.
-     * 
+     *
      * @stable ICU 3.8
      */
     public AnnualTimeZoneRule(String name, int rawOffset, int dstSavings,
@@ -53,15 +55,15 @@ public class AnnualTimeZoneRule extends TimeZoneRule {
         super(name, rawOffset, dstSavings);
         this.dateTimeRule = dateTimeRule;
         this.startYear = startYear;
-        this.endYear = endYear > MAX_YEAR ? MAX_YEAR : endYear;
+        this.endYear = endYear;
     }
 
     /**
      * Gets the start date/time rule associated used by this rule.
-     * 
+     *
      * @return  An <code>AnnualDateTimeRule</code> which represents the start date/time
      *          rule used by this time zone rule.
-     * 
+     *
      * @stable ICU 3.8
      */
     public DateTimeRule getRule() {
@@ -70,10 +72,10 @@ public class AnnualTimeZoneRule extends TimeZoneRule {
 
     /**
      * Gets the first year when this rule takes effect.
-     * 
+     *
      * @return  The start year of this rule.  The year is in Gregorian calendar
      *          with 0 == 1 BCE, -1 == 2 BCE, etc.
-     * 
+     *
      * @stable ICU 3.8
      */
     public int getStartYear() {
@@ -82,10 +84,10 @@ public class AnnualTimeZoneRule extends TimeZoneRule {
 
     /**
      * Gets the end year when this rule takes effect.
-     * 
+     *
      * @return  The end year of this rule (inclusive). The year is in Gregorian calendar
      *          with 0 == 1 BCE, -1 == 2 BCE, etc.
-     * 
+     *
      * @stable ICU 3.8
      */
     public int getEndYear() {
@@ -94,16 +96,16 @@ public class AnnualTimeZoneRule extends TimeZoneRule {
 
     /**
      * Gets the time when this rule takes effect in the given year.
-     * 
+     *
      * @param year              The Gregorian year, with 0 == 1 BCE, -1 == 2 BCE, etc.
      * @param prevRawOffset     The standard time offset from UTC before this rule
      *                          takes effect in milliseconds.
      * @param prevDSTSavings    The amount of daylight saving offset from the
      *                          standard time.
-     * 
+     *
      * @return  The time when this rule takes effect in the year, or
      *          null if this rule is not applicable in the year.
-     * 
+     *
      * @stable ICU 3.8
      */
     public Date getStartInYear(int year, int prevRawOffset, int prevDSTSavings) {
@@ -125,7 +127,7 @@ public class AnnualTimeZoneRule extends TimeZoneRule {
                     ruleDay += 7 * (weeks - 1);
                 } else {
                     after = false;
-                    ruleDay = Grego.fieldsToDay(year, dateTimeRule.getRuleMonth(), 
+                    ruleDay = Grego.fieldsToDay(year, dateTimeRule.getRuleMonth(),
                             Grego.monthLength(year, dateTimeRule.getRuleMonth()));
                     ruleDay += 7 * (weeks + 1);
                 }
@@ -166,6 +168,7 @@ public class AnnualTimeZoneRule extends TimeZoneRule {
      * {@inheritDoc}
      * @stable ICU 3.8
      */
+    @Override
     public Date getFirstStart(int prevRawOffset, int prevDSTSavings) {
         return getStartInYear(startYear, prevRawOffset, prevDSTSavings);
     }
@@ -174,6 +177,7 @@ public class AnnualTimeZoneRule extends TimeZoneRule {
      * {@inheritDoc}
      * @stable ICU 3.8
      */
+    @Override
     public Date getFinalStart(int prevRawOffset, int prevDSTSavings) {
         if (endYear == MAX_YEAR) {
             return null;
@@ -185,6 +189,7 @@ public class AnnualTimeZoneRule extends TimeZoneRule {
      * {@inheritDoc}
      * @stable ICU 3.8
      */
+    @Override
     public Date getNextStart(long base, int prevRawOffset, int prevDSTSavings, boolean inclusive) {
         int[] fields = Grego.timeToFields(base, null);
         int year = fields[0];
@@ -202,6 +207,7 @@ public class AnnualTimeZoneRule extends TimeZoneRule {
      * {@inheritDoc}
      * @stable ICU 3.8
      */
+    @Override
     public Date getPreviousStart(long base, int prevRawOffset, int prevDSTSavings, boolean inclusive) {
         int[] fields = Grego.timeToFields(base, null);
         int year = fields[0];
@@ -219,6 +225,7 @@ public class AnnualTimeZoneRule extends TimeZoneRule {
      * {@inheritDoc}
      * @stable ICU 3.8
      */
+    @Override
     public boolean isEquivalentTo(TimeZoneRule other) {
         if (!(other instanceof AnnualTimeZoneRule)) {
             return false;
@@ -237,6 +244,7 @@ public class AnnualTimeZoneRule extends TimeZoneRule {
      * Note: This method in <code>AnnualTimeZoneRule</code> always returns true.
      * @stable ICU 3.8
      */
+    @Override
     public boolean isTransitionRule() {
         return true;
     }
@@ -245,9 +253,10 @@ public class AnnualTimeZoneRule extends TimeZoneRule {
      * Returns a <code>String</code> representation of this <code>AnnualTimeZoneRule</code> object.
      * This method is used for debugging purpose only.  The string representation can be changed
      * in future version of ICU without any notice.
-     * 
+     *
      * @stable ICU 3.8
      */
+    @Override
     public String toString() {
         StringBuilder buf = new StringBuilder();
         buf.append(super.toString());
diff --git a/app/src/main/java/com/ibm/icu/util/BasicTimeZone.java b/icu4j/src/main/java/com/ibm/icu/util/BasicTimeZone.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/util/BasicTimeZone.java
rename to icu4j/src/main/java/com/ibm/icu/util/BasicTimeZone.java
index a95954c..055c544 100644
--- a/app/src/main/java/com/ibm/icu/util/BasicTimeZone.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/BasicTimeZone.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2007-2014, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/util/BuddhistCalendar.java b/icu4j/src/main/java/com/ibm/icu/util/BuddhistCalendar.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/util/BuddhistCalendar.java
rename to icu4j/src/main/java/com/ibm/icu/util/BuddhistCalendar.java
index 20eb376..1c94639 100644
--- a/app/src/main/java/com/ibm/icu/util/BuddhistCalendar.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/BuddhistCalendar.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2012, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/util/ByteArrayWrapper.java b/icu4j/src/main/java/com/ibm/icu/util/ByteArrayWrapper.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/util/ByteArrayWrapper.java
rename to icu4j/src/main/java/com/ibm/icu/util/ByteArrayWrapper.java
index d11c83f..ba1fd42 100644
--- a/app/src/main/java/com/ibm/icu/util/ByteArrayWrapper.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/ByteArrayWrapper.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and    *
@@ -58,7 +60,7 @@ public class ByteArrayWrapper implements Comparable<ByteArrayWrapper>
      * @stable ICU 3.2
      */
     public ByteArrayWrapper(byte[] bytesToAdopt, int size) {
-        if ((bytesToAdopt == null && size != 0) || size < 0 || size > bytesToAdopt.length) {
+        if ((bytesToAdopt == null && size != 0) || size < 0 || (bytesToAdopt != null && size > bytesToAdopt.length)) {
             throw new IndexOutOfBoundsException("illegal size: " + size);
         }
         this.bytes = bytesToAdopt;
@@ -113,7 +115,9 @@ public class ByteArrayWrapper implements Comparable<ByteArrayWrapper>
     {
         if (bytes == null || bytes.length < capacity) {
             byte[] newbytes = new byte[capacity];
-            copyBytes(bytes, 0, newbytes, 0, size);
+            if (bytes != null) {
+                copyBytes(bytes, 0, newbytes, 0, size);
+            }
             bytes = newbytes;
         }
         return this;
diff --git a/app/src/main/java/com/ibm/icu/util/BytesTrie.java b/icu4j/src/main/java/com/ibm/icu/util/BytesTrie.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/util/BytesTrie.java
rename to icu4j/src/main/java/com/ibm/icu/util/BytesTrie.java
index b817531..ba3d7f7 100644
--- a/app/src/main/java/com/ibm/icu/util/BytesTrie.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/BytesTrie.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 *   Copyright (C) 2010-2014, International Business Machines
@@ -421,6 +423,7 @@ public final class BytesTrie implements Cloneable, Iterable<BytesTrie.Entry> {
      * @return A new BytesTrie.Iterator.
      * @stable ICU 4.8
      */
+    @Override
     public Iterator iterator() {
         return new Iterator(bytes_, pos_, remainingMatchLength_, 0);
     }
@@ -562,6 +565,7 @@ public final class BytesTrie implements Cloneable, Iterable<BytesTrie.Entry> {
          * @return true if there are more elements.
          * @stable ICU 4.8
          */
+        @Override
         public boolean hasNext() /*const*/ { return pos_>=0 || !stack_.isEmpty(); }
 
         /**
@@ -575,6 +579,7 @@ public final class BytesTrie implements Cloneable, Iterable<BytesTrie.Entry> {
          * @throws NoSuchElementException - iteration has no more elements.
          * @stable ICU 4.8
          */
+        @Override
         public Entry next() {
             int pos=pos_;
             if(pos<0) {
@@ -644,6 +649,7 @@ public final class BytesTrie implements Cloneable, Iterable<BytesTrie.Entry> {
          * @throws UnsupportedOperationException (always)
          * @stable ICU 4.8
          */
+        @Override
         public void remove() {
             throw new UnsupportedOperationException();
         }
diff --git a/app/src/main/java/com/ibm/icu/util/BytesTrieBuilder.java b/icu4j/src/main/java/com/ibm/icu/util/BytesTrieBuilder.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/util/BytesTrieBuilder.java
rename to icu4j/src/main/java/com/ibm/icu/util/BytesTrieBuilder.java
index 45718ad..5e36cd3 100644
--- a/app/src/main/java/com/ibm/icu/util/BytesTrieBuilder.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/BytesTrieBuilder.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 *   Copyright (C) 2011-2014, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/util/CECalendar.java b/icu4j/src/main/java/com/ibm/icu/util/CECalendar.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/util/CECalendar.java
rename to icu4j/src/main/java/com/ibm/icu/util/CECalendar.java
index dd908e5..d327139 100644
--- a/app/src/main/java/com/ibm/icu/util/CECalendar.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/CECalendar.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2005-2011, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/util/Calendar.java b/icu4j/src/main/java/com/ibm/icu/util/Calendar.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/util/Calendar.java
rename to icu4j/src/main/java/com/ibm/icu/util/Calendar.java
index 049333e..ea0aee2 100644
--- a/app/src/main/java/com/ibm/icu/util/Calendar.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/Calendar.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *   Copyright (C) 1996-2016, International Business Machines
  *   Corporation and others.  All Rights Reserved.
@@ -15,9 +17,9 @@ import java.util.Date;
 import java.util.Locale;
 import java.util.MissingResourceException;
 
-import com.ibm.icu.impl.CalendarData;
 import com.ibm.icu.impl.CalendarUtil;
 import com.ibm.icu.impl.ICUCache;
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.impl.SimpleCache;
 import com.ibm.icu.impl.SimpleFormatterImpl;
@@ -134,7 +136,7 @@ import com.ibm.icu.util.ULocale.Category;
  * HOUR_OF_DAY
  * AM_PM + HOUR</pre>
  * </blockquote>
- * 
+ *
  * <p><strong>Ambiguous Wall Clock Time.</strong> When time offset from UTC has
  * changed, it produces an ambiguous time slot around the transition. For example,
  * many US locations observe daylight saving time. On the date switching to daylight
@@ -144,12 +146,12 @@ import com.ibm.icu.util.ULocale.Category;
  * Calendar resolves the time using the UTC offset before the transition by default.
  * In this example, 1:30 AM is interpreted as 1:30 AM standard time (non-exist),
  * so the final result will be 2:30 AM daylight time.
- * 
+ *
  * <p>On the date switching back to standard time, wall clock time is moved back one
  * hour at 2:00 AM. So wall clock time from 1:00 AM to 1:59 AM occur twice. In this
  * case, the ICU Calendar resolves the time using the UTC offset after the transition
  * by default. For example, 1:30 AM on the date is resolved as 1:30 AM standard time.
- * 
+ *
  * <p>Ambiguous wall clock time resolution behaviors can be customized by Calendar APIs
  * {@link #setRepeatedWallTimeOption(int)} and {@link #setSkippedWallTimeOption(int)}.
  * These methods are available in ICU 49 or later versions.
@@ -953,15 +955,17 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
     /**
      * The number of fields defined by this class.  Subclasses may define
      * addition fields starting with this number.
-     * @stable ICU 2.0
+     * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
      */
+    @Deprecated
     protected static final int BASE_FIELD_COUNT = 23;
 
     /**
      * The maximum number of fields possible.  Subclasses must not define
      * more total fields than this number.
-     * @stable ICU 2.0
+     * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
      */
+    @Deprecated
     protected static final int MAX_FIELD_COUNT = 32;
 
     /**
@@ -1591,7 +1595,7 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
 
     /*
      * Set valid/actual locale to this calendar during initialization.
-     * 
+     *
      * Valid or actual locale does not make much sense for Calendar
      * object. An instance of Calendar is initialized by week data
      * determine by region and calendar type (either region or keyword).
@@ -1932,7 +1936,7 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
         ArrayList<String> values = new ArrayList<String>();
 
         UResourceBundle rb = UResourceBundle.getBundleInstance(
-                ICUResourceBundle.ICU_BASE_NAME,
+                ICUData.ICU_BASE_NAME,
                 "supplementalData",
                 ICUResourceBundle.ICU_DATA_CLASS_LOADER);
         UResourceBundle calPref = rb.get("calendarPreferenceData");
@@ -1974,7 +1978,7 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
 
     /**
      * Sets this Calendar's current time with the given Date.
-     * 
+     *
      * <p>Note: Calling <code>setTime</code> with
      * <code>Date(Long.MAX_VALUE)</code> or <code>Date(Long.MIN_VALUE)</code>
      * may yield incorrect field values from {@link #get(int)}.
@@ -2357,6 +2361,7 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
      * <code>false</code> otherwise.
      * @stable ICU 2.0
      */
+    @Override
     public boolean equals(Object obj) {
         if (obj == null) {
             return false;
@@ -2399,6 +2404,7 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
      * @return a hash code value for this object.
      * @stable ICU 2.0
      */
+    @Override
     public int hashCode() {
         /* Don't include the time because (a) we don't want the hash value to
          * move around just because a calendar is set to different times, and
@@ -3408,6 +3414,7 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
      * calendar values.
      * @stable ICU 3.4
      */
+    @Override
     public int compareTo(Calendar that) {
         long v = getTimeInMillis() - that.getTimeInMillis();
         return v < 0 ? -1 : (v > 0 ? 1 : 0);
@@ -3604,9 +3611,7 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
             if (patternData == null) {
                 // Cache missed.  Get one from bundle
                 try {
-                    CalendarData calData = new CalendarData(loc, calType);
-                    patternData = new PatternData(calData.getDateTimePatterns(),
-                            calData.getOverrides());
+                    patternData = getPatternData(loc, calType);
                 } catch (MissingResourceException e) {
                     patternData = new PatternData(DEFAULT_PATTERNS, null);
                 }
@@ -3616,6 +3621,39 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
         }
     }
 
+    /**
+     * Retrieves the DateTime patterns and overrides from the resource bundle and generates a
+     * new PatternData object.
+     * @param locale Locale to retrieve.
+     * @param calType Calendar type to retrieve. If not found will fallback to gregorian.
+     * @return PatternData object for this locale and calendarType.
+     */
+    private static PatternData getPatternData(ULocale locale, String calType) {
+        ICUResourceBundle rb =
+                (ICUResourceBundle) UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, locale);
+        ICUResourceBundle dtPatternsRb = rb.findWithFallback("calendar/" + calType + "/DateTimePatterns");
+        if (dtPatternsRb == null) {
+            dtPatternsRb = rb.getWithFallback("calendar/gregorian/DateTimePatterns");
+        }
+
+        int patternsSize = dtPatternsRb.getSize();
+        String[] dateTimePatterns = new String[patternsSize];
+        String[] dateTimePatternsOverrides = new String[patternsSize];
+        for (int i = 0; i < patternsSize; i++) {
+            ICUResourceBundle concatenationPatternRb = (ICUResourceBundle) dtPatternsRb.get(i);
+            switch (concatenationPatternRb.getType()) {
+                case UResourceBundle.STRING:
+                    dateTimePatterns[i] = concatenationPatternRb.getString();
+                    break;
+                case UResourceBundle.ARRAY:
+                    dateTimePatterns[i] = concatenationPatternRb.getString(0);
+                    dateTimePatternsOverrides[i] = concatenationPatternRb.getString(1);
+                    break;
+            }
+        }
+        return new PatternData(dateTimePatterns, dateTimePatternsOverrides);
+    }
+
     /**
      * @internal
      * @deprecated This API is ICU internal only.
@@ -4111,16 +4149,16 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
      * (first occurrence). When <code>WALLTIME_LAST</code> is used, it will be
      * interpreted as 1:30 AM EST (last occurrence). The default value is
      * <code>WALLTIME_LAST</code>.
-     * 
+     *
      * @param option the behavior for handling repeating wall time, either
      * <code>WALLTIME_FIRST</code> or <code>WALLTIME_LAST</code>.
      * @throws IllegalArgumentException when <code>option</code> is neither
      * <code>WALLTIME_FIRST</code> nor <code>WALLTIME_LAST</code>.
-     * 
+     *
      * @see #getRepeatedWallTimeOption()
      * @see #WALLTIME_FIRST
      * @see #WALLTIME_LAST
-     * 
+     *
      * @stable ICU 49
      */
     public void setRepeatedWallTimeOption(int option) {
@@ -4133,14 +4171,14 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
     /**
      * {@icu}Gets the behavior for handling wall time repeating multiple times
      * at negative time zone offset transitions.
-     * 
+     *
      * @return the behavior for handling repeating wall time, either
      * <code>WALLTIME_FIRST</code> or <code>WALLTIME_LAST</code>.
-     * 
+     *
      * @see #setRepeatedWallTimeOption(int)
      * @see #WALLTIME_FIRST
      * @see #WALLTIME_LAST
-     * 
+     *
      * @stable ICU 49
      */
     public int getRepeatedWallTimeOption() {
@@ -4160,18 +4198,18 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
      * <p>
      * <b>Note:</b>This option is effective only when this calendar is {@link #isLenient() lenient}.
      * When the calendar is strict, such non-existing wall time will cause an exception.
-     * 
+     *
      * @param option the behavior for handling skipped wall time at positive time zone
      * offset transitions, one of <code>WALLTIME_FIRST</code>, <code>WALLTIME_LAST</code> and
      * <code>WALLTIME_NEXT_VALID</code>.
      * @throws IllegalArgumentException when <code>option</code> is not any of
      * <code>WALLTIME_FIRST</code>, <code>WALLTIME_LAST</code> and <code>WALLTIME_NEXT_VALID</code>.
-     * 
+     *
      * @see #getSkippedWallTimeOption()
      * @see #WALLTIME_FIRST
      * @see #WALLTIME_LAST
      * @see #WALLTIME_NEXT_VALID
-     * 
+     *
      * @stable ICU 49
      */
     public void setSkippedWallTimeOption(int option) {
@@ -4184,15 +4222,15 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
     /**
      * {@icu}Gets the behavior for handling skipped wall time at positive time zone offset
      * transitions.
-     * 
+     *
      * @return the behavior for handling skipped wall time, one of
      * <code>WALLTIME_FIRST</code>, <code>WALLTIME_LAST</code> and <code>WALLTIME_NEXT_VALID</code>.
-     * 
+     *
      * @see #setSkippedWallTimeOption(int)
      * @see #WALLTIME_FIRST
      * @see #WALLTIME_LAST
      * @see #WALLTIME_NEXT_VALID
-     * 
+     *
      * @stable ICU 49
      */
     public int getSkippedWallTimeOption() {
@@ -4217,7 +4255,7 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
     }
 
     /**
-     * Returns what the first day of the week is,      
+     * Returns what the first day of the week is,
      * where 1 = {@link #SUNDAY} and 7 = {@link #SATURDAY}.
      * e.g., Sunday in US, Monday in France
      * @return the first day of the week, where 1 = {@link #SUNDAY} and 7 = {@link #SATURDAY}.
@@ -4592,6 +4630,7 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
      * Overrides Cloneable
      * @stable ICU 2.0
      */
+    @Override
     public Object clone()
     {
         try {
@@ -4620,6 +4659,7 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
      * @return  a string representation of this calendar.
      * @stable ICU 2.0
      */
+    @Override
     public String toString() {
         StringBuilder buffer = new StringBuilder();
         buffer.append(getClass().getName());
@@ -4651,58 +4691,58 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
 
     /**
      * Simple, immutable struct-like class for access to the CLDR weekend data.
-     * 
+     *
      * @stable ICU 54
      */
     public static final class WeekData {
         /**
          * the first day of the week, where 1 = {@link #SUNDAY} and 7 = {@link #SATURDAY}
-         * 
+         *
          * @stable ICU 54
          */
         public final int firstDayOfWeek;
         /**
          * the minimal number of days in the first week
-         * 
+         *
          * @stable ICU 54
          */
         public final int minimalDaysInFirstWeek;
         /**
          * the onset day, where 1 = {@link #SUNDAY} and 7 = {@link #SATURDAY}
-         * 
+         *
          * @stable ICU 54
          */
         public final int weekendOnset;
         /**
          * the onset time in millis during the onset day
-         * 
+         *
          * @stable ICU 54
          */
         public final int weekendOnsetMillis;
         /**
          * the cease day, where 1 = {@link #SUNDAY} and 7 = {@link #SATURDAY}
-         * 
+         *
          * @stable ICU 54
          */
         public final int weekendCease;
         /**
          * the cease time in millis during the cease day. Exclusive, so the max is 24:00:00.000.
          * Note that this will format as 00:00 the next day.
-         * 
+         *
          * @stable ICU 54
          */
         public final int weekendCeaseMillis;
 
         /**
          * Constructor
-         * 
+         *
          * @param fdow the first day of the week, where 1 = {@link #SUNDAY} and 7 = {@link #SATURDAY}
          * @param mdifw the minimal number of days in the first week
          * @param weekendOnset the onset day, where 1 = Sunday and 7 = Saturday
          * @param weekendOnsetMillis the onset time in millis during the onset day
          * @param weekendCease the cease day, where 1 = Sunday and 7 = Saturday
          * @param weekendCeaseMillis the cease time in millis during the cease day.
-         * 
+         *
          * @stable ICU 54
          */
         public WeekData(int fdow, int mdifw,
@@ -4718,7 +4758,7 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
 
         /**
          * {@inheritDoc}
-         * 
+         *
          * @stable ICU 54
          */
         @Override
@@ -4729,7 +4769,7 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
 
         /**
          * {@inheritDoc}
-         * 
+         *
          * @stable ICU 54
          */
         @Override
@@ -4751,7 +4791,7 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
 
         /**
          * {@inheritDoc}
-         * 
+         *
          * @stable ICU 54
          */
         @Override
@@ -4770,28 +4810,28 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
      * {@icu} Return simple, immutable struct-like class for access to the CLDR weekend data.
      * @param region The input region. The results are undefined if the region code is not valid.
      * @return the WeekData for the input region. It is never null.
-     * 
+     *
      * @stable ICU 54
      */
     public static WeekData getWeekDataForRegion(String region) {
         return WEEK_DATA_CACHE.createInstance(region, region);
     }
-    
+
     /**
      * {@icu} Return simple, immutable struct-like class for access to the weekend data in this calendar.
      * @return the WeekData for this calendar.
-     * 
+     *
      * @stable ICU 54
      */
     public WeekData getWeekData() {
         return new WeekData(firstDayOfWeek, minimalDaysInFirstWeek, weekendOnset, weekendOnsetMillis, weekendCease, weekendCeaseMillis);
     }
-    
+
     /**
      * {@icu} Set data in this calendar based on the WeekData input.
      * @param wdata The week data to use
      * @return this, for chaining
-     * 
+     *
      * @stable ICU 54
      */
     public Calendar setWeekData(WeekData wdata) {
@@ -4811,7 +4851,7 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
         }
 
         UResourceBundle rb = UResourceBundle.getBundleInstance(
-                ICUResourceBundle.ICU_BASE_NAME,
+                ICUData.ICU_BASE_NAME,
                 "supplementalData",
                 ICUResourceBundle.ICU_DATA_CLASS_LOADER);
         UResourceBundle weekDataInfo = rb.get("weekData");
@@ -5443,7 +5483,7 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
 
     /**
      * Find the previous zone transtion near the given time.
-     * 
+     *
      * @param base The base time, inclusive.
      * @return The time of the previous transition, or null if not found.
      */
@@ -5627,7 +5667,7 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
                 int offsetBefore6 = zone.getOffset(tgmt - 6*60*60*1000);
                 int offsetDelta = (offsets[0] + offsets[1]) - offsetBefore6;
 
-                assert offsetDelta < -6*60*60*1000 : offsetDelta;
+                assert offsetDelta > -6*60*60*1000 : offsetDelta;
                 if (offsetDelta < 0) {
                     sawRecentNegativeShift = true;
                     // Negative shift within last 6 hours. When WALLTIME_FIRST is used and the given wall time falls
@@ -6296,7 +6336,7 @@ public abstract class Calendar implements Serializable, Cloneable, Comparable<Ca
      * The default implementation returns <code>true</code>. A subclass may
      * return <code>false</code> if such practice is not applicable (for example,
      * Chinese calendar and Japanese calendar).
-     * 
+     *
      * @return <code>true</code> if this calendar has a default century.
      * @internal
      * @deprecated This API is ICU internal only.
diff --git a/app/src/main/java/com/ibm/icu/util/CaseInsensitiveString.java b/icu4j/src/main/java/com/ibm/icu/util/CaseInsensitiveString.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/util/CaseInsensitiveString.java
rename to icu4j/src/main/java/com/ibm/icu/util/CaseInsensitiveString.java
index c498de0..ff0ba29 100644
--- a/app/src/main/java/com/ibm/icu/util/CaseInsensitiveString.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/CaseInsensitiveString.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
  *******************************************************************************
  * Copyright (C) 2001-2013, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/util/CharsTrie.java b/icu4j/src/main/java/com/ibm/icu/util/CharsTrie.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/util/CharsTrie.java
rename to icu4j/src/main/java/com/ibm/icu/util/CharsTrie.java
index 93e006e..6ffe5b0 100644
--- a/app/src/main/java/com/ibm/icu/util/CharsTrie.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/CharsTrie.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 *   Copyright (C) 2011-2014, International Business Machines
@@ -383,6 +385,7 @@ public final class CharsTrie implements Cloneable, Iterable<CharsTrie.Entry> {
      * @return A new CharsTrie.Iterator.
      * @stable ICU 4.8
      */
+    @Override
     public Iterator iterator() {
         return new Iterator(chars_, pos_, remainingMatchLength_, 0);
     }
@@ -478,6 +481,7 @@ public final class CharsTrie implements Cloneable, Iterable<CharsTrie.Entry> {
          * @return true if there are more elements.
          * @stable ICU 4.8
          */
+        @Override
         public boolean hasNext() /*const*/ { return pos_>=0 || !stack_.isEmpty(); }
 
         /**
@@ -491,6 +495,7 @@ public final class CharsTrie implements Cloneable, Iterable<CharsTrie.Entry> {
          * @throws NoSuchElementException - iteration has no more elements.
          * @stable ICU 4.8
          */
+        @Override
         public Entry next() {
             int pos=pos_;
             if(pos<0) {
@@ -576,6 +581,7 @@ public final class CharsTrie implements Cloneable, Iterable<CharsTrie.Entry> {
          * @throws UnsupportedOperationException (always)
          * @stable ICU 4.8
          */
+        @Override
         public void remove() {
             throw new UnsupportedOperationException();
         }
diff --git a/app/src/main/java/com/ibm/icu/util/CharsTrieBuilder.java b/icu4j/src/main/java/com/ibm/icu/util/CharsTrieBuilder.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/util/CharsTrieBuilder.java
rename to icu4j/src/main/java/com/ibm/icu/util/CharsTrieBuilder.java
index 66a4f55..4dc0d37 100644
--- a/app/src/main/java/com/ibm/icu/util/CharsTrieBuilder.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/CharsTrieBuilder.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 *   Copyright (C) 2011-2014, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/util/ChineseCalendar.java b/icu4j/src/main/java/com/ibm/icu/util/ChineseCalendar.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/util/ChineseCalendar.java
rename to icu4j/src/main/java/com/ibm/icu/util/ChineseCalendar.java
index a8dff55..13140f3 100644
--- a/app/src/main/java/com/ibm/icu/util/ChineseCalendar.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/ChineseCalendar.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*********************************************************************
  * Copyright (C) 2000-2014, International Business Machines
  * Corporation and others. All Rights Reserved.
diff --git a/app/src/main/java/com/ibm/icu/util/CompactByteArray.java b/icu4j/src/main/java/com/ibm/icu/util/CompactByteArray.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/util/CompactByteArray.java
rename to icu4j/src/main/java/com/ibm/icu/util/CompactByteArray.java
index 21af264..fe135ab 100644
--- a/app/src/main/java/com/ibm/icu/util/CompactByteArray.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/CompactByteArray.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2014, International Business Machines Corporation and    *
@@ -94,7 +96,7 @@ public final class CompactByteArray implements Cloneable {
             throw new IllegalArgumentException("Index out of bounds.");
         for (i = 0; i < INDEXCOUNT; ++i) {
             char index = indexArray[i];
-            if ((index < 0) || (index >= newValues.length+BLOCKCOUNT))
+            if (index >= newValues.length+BLOCKCOUNT)
                 throw new IllegalArgumentException("Index out of bounds.");
         }
         indices = indexArray;
@@ -148,7 +150,7 @@ public final class CompactByteArray implements Cloneable {
     {
         if (isCompact)
             expand();
-        values[(int)index] = value;
+        values[index] = value;
         touchBlock(index >> BLOCKSHIFT, value);
     }
 
@@ -305,6 +307,7 @@ public final class CompactByteArray implements Cloneable {
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Override
     @Deprecated
     public Object clone()
     {
@@ -327,6 +330,7 @@ public final class CompactByteArray implements Cloneable {
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Override
     @Deprecated
     public boolean equals(Object obj) {
         if (obj == null) return false;
@@ -348,6 +352,7 @@ public final class CompactByteArray implements Cloneable {
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Override
     @Deprecated
     public int hashCode() {
         int result = 0;
diff --git a/app/src/main/java/com/ibm/icu/util/CompactCharArray.java b/icu4j/src/main/java/com/ibm/icu/util/CompactCharArray.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/util/CompactCharArray.java
rename to icu4j/src/main/java/com/ibm/icu/util/CompactCharArray.java
index 87e4e06..65b0a43 100644
--- a/app/src/main/java/com/ibm/icu/util/CompactCharArray.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/CompactCharArray.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2014, International Business Machines Corporation and    *
@@ -95,7 +97,7 @@ public final class CompactCharArray implements Cloneable {
             throw new IllegalArgumentException("Index out of bounds.");
         for (i = 0; i < INDEXCOUNT; ++i) {
             char index = indexArray[i];
-            if ((index < 0) || (index >= newValues.length+BLOCKCOUNT))
+            if (index >= newValues.length+BLOCKCOUNT)
                 throw new IllegalArgumentException("Index out of bounds.");
         }
         indices = indexArray;
@@ -150,7 +152,7 @@ public final class CompactCharArray implements Cloneable {
     {
         if (isCompact)
             expand();
-         values[(int)index] = value;
+         values[index] = value;
         touchBlock(index >> BLOCKSHIFT, value);
     }
 
@@ -329,6 +331,7 @@ public final class CompactCharArray implements Cloneable {
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Override
     @Deprecated
     public Object clone()
     {
@@ -351,6 +354,7 @@ public final class CompactCharArray implements Cloneable {
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Override
     @Deprecated
     public boolean equals(Object obj) {
         if (obj == null) return false;
@@ -372,6 +376,7 @@ public final class CompactCharArray implements Cloneable {
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Override
     @Deprecated
     public int hashCode() {
         int result = 0;
diff --git a/app/src/main/java/com/ibm/icu/util/CopticCalendar.java b/icu4j/src/main/java/com/ibm/icu/util/CopticCalendar.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/util/CopticCalendar.java
rename to icu4j/src/main/java/com/ibm/icu/util/CopticCalendar.java
index f2654b9..fc86b38 100644
--- a/app/src/main/java/com/ibm/icu/util/CopticCalendar.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/CopticCalendar.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2005-2016, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/util/Currency.java b/icu4j/src/main/java/com/ibm/icu/util/Currency.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/util/Currency.java
rename to icu4j/src/main/java/com/ibm/icu/util/Currency.java
index 33aeb40..06300ca 100644
--- a/app/src/main/java/com/ibm/icu/util/Currency.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/Currency.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
  *******************************************************************************
  * Copyright (C) 2001-2016, International Business Machines Corporation and
@@ -21,10 +23,13 @@ import java.util.Map;
 import java.util.MissingResourceException;
 import java.util.Set;
 
+import com.ibm.icu.impl.CacheBase;
 import com.ibm.icu.impl.ICUCache;
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUDebug;
 import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.impl.SimpleCache;
+import com.ibm.icu.impl.SoftCache;
 import com.ibm.icu.impl.TextTrieMap;
 import com.ibm.icu.text.CurrencyDisplayNames;
 import com.ibm.icu.text.CurrencyMetaInfo;
@@ -73,15 +78,15 @@ public class Currency extends MeasureUnit {
      * @stable ICU 2.6
      */
     public static final int LONG_NAME = 1;
-   
+
     /**
-     * Selector for getName() indicating the plural long name for a 
-     * currency, such as "US dollar" for USD in "1 US dollar", 
+     * Selector for getName() indicating the plural long name for a
+     * currency, such as "US dollar" for USD in "1 US dollar",
      * and "US dollars" for USD in "2 US dollars".
      * @stable ICU 4.2
      */
     public static final int PLURAL_LONG_NAME = 2;
-    
+
     private static final EquivalenceRelation<String> EQUIVALENT_CURRENCY_SYMBOLS =
             new EquivalenceRelation<String>()
             .add("\u00a5", "\uffe5")
@@ -100,7 +105,7 @@ public class Currency extends MeasureUnit {
          * @stable ICU 54
          */
         STANDARD,
-        
+
         /**
          * a setting to specify currency usage which determines currency digit and rounding
          * for cash usage, for example: "50 NT$"
@@ -108,7 +113,7 @@ public class Currency extends MeasureUnit {
          */
         CASH
     }
-    
+
     // begin registry stuff
 
     // shim for service code
@@ -172,7 +177,7 @@ public class Currency extends MeasureUnit {
 
     /**
      * Returns an array of Strings which contain the currency
-     * identifiers that are valid for the given locale on the 
+     * identifiers that are valid for the given locale on the
      * given date.  If there are no such identifiers, returns null.
      * Returned identifiers are in preference order.
      * @param loc the locale for which to retrieve currency codes.
@@ -184,7 +189,7 @@ public class Currency extends MeasureUnit {
         String region = ULocale.getRegionForSupplementalData(loc, false);
         CurrencyFilter filter = CurrencyFilter.onDate(d).withRegion(region);
         List<String> list = getTenderCurrencies(filter);
-        // Note: Prior to 4.4 the spec didn't say that we return null if there are no results, but 
+        // Note: Prior to 4.4 the spec didn't say that we return null if there are no results, but
         // the test assumed it did.  Kept the behavior and amended the spec.
         if (list.isEmpty()) {
             return null;
@@ -210,10 +215,10 @@ public class Currency extends MeasureUnit {
      * Returns the set of available currencies. The returned set of currencies contains all of the
      * available currencies, including obsolete ones. The result set can be modified without
      * affecting the available currencies in the runtime.
-     * 
+     *
      * @return The set of available currencies. The returned set could be empty if there is no
      * currency data available.
-     * 
+     *
      * @stable ICU 49
      */
     public static Set<Currency> getAvailableCurrencies() {
@@ -227,39 +232,55 @@ public class Currency extends MeasureUnit {
     }
 
     private static final String EUR_STR = "EUR";
-    private static final ICUCache<ULocale, String> currencyCodeCache = new SimpleCache<ULocale, String>();
-    
+    private static final CacheBase<String, Currency, Void> regionCurrencyCache =
+            new SoftCache<String, Currency, Void>() {
+        @Override
+        protected Currency createInstance(String key, Void unused) {
+            return loadCurrency(key);
+        }
+    };
+
     /**
      * Instantiate a currency from resource data.
      */
     /* package */ static Currency createCurrency(ULocale loc) {
-        
         String variant = loc.getVariant();
         if ("EURO".equals(variant)) {
             return getInstance(EUR_STR);
         }
-        
-        String code = currencyCodeCache.get(loc);
-        if (code == null) {
-            String country = ULocale.getRegionForSupplementalData(loc, false);
-        
-            CurrencyMetaInfo info = CurrencyMetaInfo.getInstance();
-            List<String> list = info.currencies(CurrencyFilter.onRegion(country));
-            if (list.size() > 0) {
-                code = list.get(0);
-                boolean isPreEuro = "PREEURO".equals(variant);
-                if (isPreEuro && EUR_STR.equals(code)) {
-                    if (list.size() < 2) {
-                        return null;
-                    }
-                    code = list.get(1);
+
+        // Cache the currency by region, and whether variant=PREEURO.
+        // Minimizes the size of the cache compared with caching by ULocale.
+        String key = ULocale.getRegionForSupplementalData(loc, false);
+        if ("PREEURO".equals(variant)) {
+            key = key + '-';
+        }
+        return regionCurrencyCache.getInstance(key, null);
+    }
+
+    private static Currency loadCurrency(String key) {
+        String region;
+        boolean isPreEuro;
+        if (key.endsWith("-")) {
+            region = key.substring(0, key.length() - 1);
+            isPreEuro = true;
+        } else {
+            region = key;
+            isPreEuro = false;
+        }
+        CurrencyMetaInfo info = CurrencyMetaInfo.getInstance();
+        List<String> list = info.currencies(CurrencyFilter.onRegion(region));
+        if (!list.isEmpty()) {
+            String code = list.get(0);
+            if (isPreEuro && EUR_STR.equals(code)) {
+                if (list.size() < 2) {
+                    return null;
                 }
-            } else {
-                return null;
+                code = list.get(1);
             }
-            currencyCodeCache.put(loc, code);
+            return getInstance(code);
         }
-        return getInstance(code);
+        return null;
     }
 
     /**
@@ -281,8 +302,8 @@ public class Currency extends MeasureUnit {
         }
         return (Currency) MeasureUnit.internalGetInstance("currency", theISOCode.toUpperCase(Locale.ENGLISH));
     }
-    
-    
+
+
     private static boolean isAlpha3Code(String code) {
         if (code.length() != 3) {
             return false;
@@ -300,11 +321,11 @@ public class Currency extends MeasureUnit {
     /**
      * Registers a new currency for the provided locale.  The returned object
      * is a key that can be used to unregister this currency object.
-     * 
+     *
      * <p>Because ICU may choose to cache Currency objects internally, this must
      * be called at application startup, prior to any calls to
      * Currency.getInstance to avoid undefined behavior.
-     * 
+     *
      * @param currency the currency to register
      * @param locale the ulocale under which to register the currency
      * @return a registry key that can be used to unregister this currency
@@ -365,7 +386,7 @@ public class Currency extends MeasureUnit {
     /**
      * Given a key and a locale, returns an array of values for the key for which data
      * exists.  If commonlyUsed is true, these are the values that typically are used
-     * with this locale, otherwise these are all values for which data exists.  
+     * with this locale, otherwise these are all values for which data exists.
      * This is a common service API.
      * <p>
      * The only supported key is "currency", other values return an empty array.
@@ -377,11 +398,11 @@ public class Currency extends MeasureUnit {
      * If commonlyUsed is true, only the currencies known to be in use as of the current date
      * are returned.  When there are more than one, these are returned in preference order
      * (typically, this occurs when a country is transitioning to a new currency, and the
-     * newer currency is preferred), see 
-     * <a href="http://unicode.org/reports/tr35/#Supplemental_Currency_Data">Unicode TR#35 Sec. C1</a>.  
+     * newer currency is preferred), see
+     * <a href="http://unicode.org/reports/tr35/#Supplemental_Currency_Data">Unicode TR#35 Sec. C1</a>.
      * If commonlyUsed is false, all currencies ever used in any locale are returned, in no
      * particular order.
-     * 
+     *
      * @param key           key whose values to look up.  the only recognized key is "currency"
      * @param locale        the locale
      * @param commonlyUsed  if true, return only values that are currently used in the locale.
@@ -390,19 +411,19 @@ public class Currency extends MeasureUnit {
      *   array will be empty.
      * @stable ICU 4.2
      */
-    public static final String[] getKeywordValuesForLocale(String key, ULocale locale, 
+    public static final String[] getKeywordValuesForLocale(String key, ULocale locale,
             boolean commonlyUsed) {
-        
+
         // The only keyword we recognize is 'currency'
         if (!"currency".equals(key)) {
             return EMPTY_STRING_ARRAY;
         }
-        
+
         if (!commonlyUsed) {
             // Behavior change from 4.3.3, no longer sort the currencies
             return getAllTenderCurrencies().toArray(new String[0]);
         }
-        
+
         // Don't resolve region if the requested locale is 'und', it will resolve to US
         // which we don't want.
         if (UND.equals(locale)) {
@@ -411,11 +432,11 @@ public class Currency extends MeasureUnit {
         String prefRegion = ULocale.getRegionForSupplementalData(locale, true);
 
         CurrencyFilter filter = CurrencyFilter.now().withRegion(prefRegion);
-        
+
         // currencies are in region's preferred order when we're filtering on region, which
         // matches our spec
         List<String> result = getTenderCurrencies(filter);
-        
+
         // No fallback anymore (change from 4.3.3)
         if (result.size() == 0) {
             return EMPTY_STRING_ARRAY;
@@ -423,7 +444,7 @@ public class Currency extends MeasureUnit {
 
         return result.toArray(new String[result.size()]);
     }
-    
+
     private static final ULocale UND = new ULocale("und");
     private static final String[] EMPTY_STRING_ARRAY = new String[0];
 
@@ -446,7 +467,7 @@ public class Currency extends MeasureUnit {
         int result = 0;
         try {
             UResourceBundle bundle = UResourceBundle.getBundleInstance(
-                    ICUResourceBundle.ICU_BASE_NAME,
+                    ICUData.ICU_BASE_NAME,
                     "currencyNumericCodes",
                     ICUResourceBundle.ICU_DATA_CLASS_LOADER);
             UResourceBundle codeMap = bundle.get("codeMap");
@@ -493,9 +514,9 @@ public class Currency extends MeasureUnit {
 
     /**
      * Returns the display name for the given currency in the
-     * given locale.  
-     * This is a convenient method for 
-     * getName(ULocale, int, boolean[]); 
+     * given locale.
+     * This is a convenient method for
+     * getName(ULocale, int, boolean[]);
      * @stable ICU 3.2
      */
     public String getName(Locale locale,
@@ -510,7 +531,7 @@ public class Currency extends MeasureUnit {
      * currency object in the en_US locale is "$".
      * @param locale locale in which to display currency
      * @param nameStyle selector for which kind of name to return.
-     *                  The nameStyle should be either SYMBOL_NAME or 
+     *                  The nameStyle should be either SYMBOL_NAME or
      *                  LONG_NAME. Otherwise, throw IllegalArgumentException.
      * @param isChoiceFormat fill-in; isChoiceFormat[0] is set to true
      * if the returned value is a ChoiceFormat pattern; otherwise it
@@ -543,7 +564,7 @@ public class Currency extends MeasureUnit {
     }
 
     /**
-     * Returns the display name for the given currency in the given locale.  
+     * Returns the display name for the given currency in the given locale.
      * This is a convenience overload of getName(ULocale, int, String, boolean[]);
      * @stable ICU 4.2
      */
@@ -556,7 +577,7 @@ public class Currency extends MeasureUnit {
      * Returns the display name for the given currency in the
      * given locale.  For example, the SYMBOL_NAME for the USD
      * currency object in the en_US locale is "$".
-     * The PLURAL_LONG_NAME for the USD currency object when the currency 
+     * The PLURAL_LONG_NAME for the USD currency object when the currency
      * amount is plural is "US dollars", such as in "3.00 US dollars";
      * while the PLURAL_LONG_NAME for the USD currency object when the currency
      * amount is singular is "US dollar", such as in "1.00 US dollar".
@@ -586,7 +607,7 @@ public class Currency extends MeasureUnit {
         if (isChoiceFormat != null) {
             isChoiceFormat[0] = false;
         }
-        
+
         CurrencyDisplayNames names = CurrencyDisplayNames.getInstance(locale);
         return names.getPluralName(subType, pluralCount);
     }
@@ -599,7 +620,7 @@ public class Currency extends MeasureUnit {
      * Note: This method is a convenience equivalent for
      * {@link java.util.Currency#getDisplayName()} and is equivalent to
      * <code>getName(Locale.getDefault(), LONG_NAME, null)</code>.
-     * 
+     *
      * @return The display name of this currency
      * @see #getDisplayName(Locale)
      * @see #getName(Locale, int, boolean[])
@@ -618,7 +639,7 @@ public class Currency extends MeasureUnit {
      * Note: This method is a convenience equivalent for
      * {@link java.util.Currency#getDisplayName(java.util.Locale)} and is equivalent
      * to <code>getName(locale, LONG_NAME, null)</code>.
-     * 
+     *
      * @param locale locale in which to display currency
      * @return The display name of this currency for the specified locale
      * @see #getDisplayName(Locale)
@@ -655,9 +676,9 @@ public class Currency extends MeasureUnit {
     public static String parse(ULocale locale, String text, int type, ParsePosition pos) {
         List<TextTrieMap<CurrencyStringInfo>> currencyTrieVec = CURRENCY_NAME_CACHE.get(locale);
         if (currencyTrieVec == null) {
-            TextTrieMap<CurrencyStringInfo> currencyNameTrie = 
+            TextTrieMap<CurrencyStringInfo> currencyNameTrie =
                 new TextTrieMap<CurrencyStringInfo>(true);
-            TextTrieMap<CurrencyStringInfo> currencySymbolTrie = 
+            TextTrieMap<CurrencyStringInfo> currencySymbolTrie =
                 new TextTrieMap<CurrencyStringInfo>(false);
             currencyTrieVec = new ArrayList<TextTrieMap<CurrencyStringInfo>>();
             currencyTrieVec.add(currencySymbolTrie);
@@ -665,7 +686,7 @@ public class Currency extends MeasureUnit {
             setupCurrencyTrieVec(locale, currencyTrieVec);
             CURRENCY_NAME_CACHE.put(locale, currencyTrieVec);
         }
-        
+
         int maxLength = 0;
         String isoResult = null;
 
@@ -690,7 +711,7 @@ public class Currency extends MeasureUnit {
         return isoResult;
     }
 
-    private static void setupCurrencyTrieVec(ULocale locale, 
+    private static void setupCurrencyTrieVec(ULocale locale,
             List<TextTrieMap<CurrencyStringInfo>> trieVec) {
 
         TextTrieMap<CurrencyStringInfo> symTrie = trieVec.get(0);
@@ -732,16 +753,17 @@ public class Currency extends MeasureUnit {
         }
     }
 
-    private static class CurrencyNameResultHandler 
+    private static class CurrencyNameResultHandler
             implements TextTrieMap.ResultHandler<CurrencyStringInfo> {
         // The length of longest matching key
         private int bestMatchLength;
         // The currency ISO code of longest matching key
         private String bestCurrencyISOCode;
-    
+
         // As the trie is traversed, handlePrefixMatch is called at each node. matchLength is the
         // length length of the key at the current node; values is the list of all the values mapped to
         // that key. matchLength increases with each call as trie is traversed.
+        @Override
         public boolean handlePrefixMatch(int matchLength, Iterator<CurrencyStringInfo> values) {
             if (values.hasNext()) {
                 // Since the best match criteria is only based on length of key in trie and since all the
@@ -755,7 +777,7 @@ public class Currency extends MeasureUnit {
         public String getBestCurrencyISOCode() {
             return bestCurrencyISOCode;
         }
-        
+
         public int getBestMatchLength() {
             return bestMatchLength;
         }
@@ -833,6 +855,7 @@ public class Currency extends MeasureUnit {
      * Returns the ISO 4217 code for this currency.
      * @stable ICU 2.2
      */
+    @Override
     public String toString() {
         return subType;
     }
@@ -840,7 +863,7 @@ public class Currency extends MeasureUnit {
     /**
      * Constructs a currency object for the given ISO 4217 3-letter
      * code.  This constructor assumes that the code is valid.
-     * 
+     *
      * @param theISOCode The iso code used to construct the currency.
      * @stable ICU 3.4
      */
@@ -853,8 +876,8 @@ public class Currency extends MeasureUnit {
     }
 
     // POW10[i] = 10^i
-    private static final int[] POW10 = { 
-        1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000 
+    private static final int[] POW10 = {
+        1, 10, 100, 1000, 10000, 100000, 1000000, 10000000, 100000000, 1000000000
     };
 
 
@@ -875,7 +898,7 @@ public class Currency extends MeasureUnit {
         }
         return all;
     }
-    
+
     private static synchronized Set<String> getAllCurrenciesAsSet() {
         Set<String> all = (ALL_CODES_AS_SET == null) ? null : ALL_CODES_AS_SET.get();
         if (all == null) {
@@ -893,7 +916,7 @@ public class Currency extends MeasureUnit {
      * Note: For checking availability of a currency on a specific date, specify the date on both <code>from</code> and
      * <code>to</code>. When both <code>from</code> and <code>to</code> are null, this method checks if the specified
      * currency is available all time.
-     * 
+     *
      * @param code
      *            The ISO 4217 3-letter code.
      * @param from
@@ -904,7 +927,7 @@ public class Currency extends MeasureUnit {
      *            the currency any date after <code>from</code>
      * @return true if the given ISO 4217 3-letter code is supported on the specified date range.
      * @throws IllegalArgumentException when <code>to</code> is before <code>from</code>.
-     * 
+     *
      * @stable ICU 4.6
      */
     public static boolean isAvailable(String code, Date from, Date to) {
@@ -940,11 +963,11 @@ public class Currency extends MeasureUnit {
         CurrencyMetaInfo info = CurrencyMetaInfo.getInstance();
         return info.currencies(filter.withTender());
     }
-    
+
     private static final class EquivalenceRelation<T> {
-        
+
         private Map<T, Set<T>> data = new HashMap<T, Set<T>>();
-        
+
         @SuppressWarnings("unchecked")  // See ticket #11395, this is safe.
         public EquivalenceRelation<T> add(T... items) {
             Set<T> group = new HashSet<T>();
@@ -959,7 +982,7 @@ public class Currency extends MeasureUnit {
             }
             return this;
         }
-        
+
         public Set<T> get(T item) {
             Set<T> result = data.get(item);
             if (result == null) {
@@ -968,7 +991,7 @@ public class Currency extends MeasureUnit {
             return Collections.unmodifiableSet(result);
         }
     }
-    
+
     private Object writeReplace() throws ObjectStreamException {
         return new MeasureUnitProxy(type, subType);
     }
diff --git a/app/src/main/java/com/ibm/icu/util/CurrencyAmount.java b/icu4j/src/main/java/com/ibm/icu/util/CurrencyAmount.java
similarity index 92%
rename from app/src/main/java/com/ibm/icu/util/CurrencyAmount.java
rename to icu4j/src/main/java/com/ibm/icu/util/CurrencyAmount.java
index 8ba7e18..c7e118d 100644
--- a/app/src/main/java/com/ibm/icu/util/CurrencyAmount.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/CurrencyAmount.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 **********************************************************************
 * Copyright (c) 2004-2010, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/util/CurrencyServiceShim.java b/icu4j/src/main/java/com/ibm/icu/util/CurrencyServiceShim.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/util/CurrencyServiceShim.java
rename to icu4j/src/main/java/com/ibm/icu/util/CurrencyServiceShim.java
index f2ea058..fa0771f 100644
--- a/app/src/main/java/com/ibm/icu/util/CurrencyServiceShim.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/CurrencyServiceShim.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
  *******************************************************************************
  * Copyright (C) 2001-2011, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/util/DangiCalendar.java b/icu4j/src/main/java/com/ibm/icu/util/DangiCalendar.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/util/DangiCalendar.java
rename to icu4j/src/main/java/com/ibm/icu/util/DangiCalendar.java
index 0b7c398..e24824a 100644
--- a/app/src/main/java/com/ibm/icu/util/DangiCalendar.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/DangiCalendar.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2012-2014, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/util/DateInterval.java b/icu4j/src/main/java/com/ibm/icu/util/DateInterval.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/util/DateInterval.java
rename to icu4j/src/main/java/com/ibm/icu/util/DateInterval.java
index 8b1131b..8522297 100644
--- a/app/src/main/java/com/ibm/icu/util/DateInterval.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/DateInterval.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  *   Copyright (C) 2008-2009, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/util/DateRule.java b/icu4j/src/main/java/com/ibm/icu/util/DateRule.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/util/DateRule.java
rename to icu4j/src/main/java/com/ibm/icu/util/DateRule.java
index 0d0f2f9..d049bba 100644
--- a/app/src/main/java/com/ibm/icu/util/DateRule.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/DateRule.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/util/DateTimeRule.java b/icu4j/src/main/java/com/ibm/icu/util/DateTimeRule.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/util/DateTimeRule.java
rename to icu4j/src/main/java/com/ibm/icu/util/DateTimeRule.java
index 05fa068..e609082 100644
--- a/app/src/main/java/com/ibm/icu/util/DateTimeRule.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/DateTimeRule.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2007-2010, International Business Machines Corporation and    *
@@ -12,7 +14,7 @@ import java.io.Serializable;
  * <code>DateTimeRule</code> is a class representing a time in a year by
  * a rule specified by month, day of month, day of week and
  * time in the day.
- * 
+ *
  * @stable ICU 3.8
  */
 public class DateTimeRule implements Serializable {
@@ -22,7 +24,7 @@ public class DateTimeRule implements Serializable {
     /**
      * Date rule type defined by exact day of month.
      * For example, March 14.
-     * 
+     *
      * @stable ICU 3.8
      */
     public static final int DOM = 0;
@@ -30,7 +32,7 @@ public class DateTimeRule implements Serializable {
     /**
      * Date rule type defined by day of week in month.
      * For example, 2nd Sunday in March.
-     * 
+     *
      * @stable ICU 3.8
      */
     public static final int DOW = 1;
@@ -39,7 +41,7 @@ public class DateTimeRule implements Serializable {
      * Date rule type defined by first day of week on or
      * after exact day of month.
      * For example, 1st Monday on or after March 15.
-     * 
+     *
      * @stable ICU 3.8
      */
     public static final int DOW_GEQ_DOM = 2;
@@ -48,28 +50,28 @@ public class DateTimeRule implements Serializable {
      * Date rule type defined by last day of week on or
      * before exact day of month.
      * For example, last Saturday on or before March 15.
-     * 
+     *
      * @stable ICU 3.8
      */
     public static final int DOW_LEQ_DOM = 3;
-    
+
     /**
      * Time rule type for local wall time.
-     * 
+     *
      * @stable ICU 3.8
      */
     public static final int WALL_TIME = 0;
 
     /**
      * Time rule type for local standard time.
-     * 
+     *
      * @stable ICU 3.8
      */
     public static final int STANDARD_TIME = 1;
 
     /**
      * Time rule type for coordinated universal time.
-     * 
+     *
      * @stable ICU 3.8
      */
     public static final int UTC_TIME = 2;
@@ -88,13 +90,13 @@ public class DateTimeRule implements Serializable {
      * Constructs a <code>DateTimeRule</code> by the day of month and
      * the time rule.  The date rule type for an instance created by
      * this constructor is <code>DOM</code>.
-     * 
+     *
      * @param month         The rule month, for example, <code>Calendar.JANUARY</code>
      * @param dayOfMonth    The day of month, 1-based.
      * @param millisInDay   The milliseconds in the rule date.
      * @param timeType      The time type, <code>WALL_TIME</code> or <code>STANDARD_TIME</code>
      *                      or <code>UTC_TIME</code>.
-     * 
+     *
      * @stable ICU 3.8
      */
     public DateTimeRule(int month, int dayOfMonth,
@@ -105,7 +107,7 @@ public class DateTimeRule implements Serializable {
 
         this.millisInDay = millisInDay;
         this.timeRuleType = timeType;
-        
+
         // not used by this rule type
         this.dayOfWeek = 0;
         this.weekInMonth = 0;
@@ -115,7 +117,7 @@ public class DateTimeRule implements Serializable {
      * Constructs a <code>DateTimeRule</code> by the day of week and its oridinal
      * number and the time rule.  The date rule type for an instance created
      * by this constructor is <code>DOW</code>.
-     * 
+     *
      * @param month         The rule month, for example, <code>Calendar.JANUARY</code>.
      * @param weekInMonth   The ordinal number of the day of week.  Negative number
      *                      may be used for specifying a rule date counted from the
@@ -124,7 +126,7 @@ public class DateTimeRule implements Serializable {
      * @param millisInDay   The milliseconds in the rule date.
      * @param timeType      The time type, <code>WALL_TIME</code> or <code>STANDARD_TIME</code>
      *                      or <code>UTC_TIME</code>.
-     * 
+     *
      * @stable ICU 3.8
      */
     public DateTimeRule(int month, int weekInMonth, int dayOfWeek,
@@ -146,7 +148,7 @@ public class DateTimeRule implements Serializable {
      * on or after/before the day of month and the time rule.  The date rule
      * type for an instance created by this constructor is either
      * <code>DOM_GEQ_DOM</code> or <code>DOM_LEQ_DOM</code>.
-     * 
+     *
      * @param month         The rule month, for example, <code>Calendar.JANUARY</code>
      * @param dayOfMonth    The day of month, 1-based.
      * @param dayOfWeek     The day of week, for example, <code>Calendar.SUNDAY</code>.
@@ -154,7 +156,7 @@ public class DateTimeRule implements Serializable {
      * @param millisInDay   The milliseconds in the rule date.
      * @param timeType      The time type, <code>WALL_TIME</code> or <code>STANDARD_TIME</code>
      *                      or <code>UTC_TIME</code>.
-     * 
+     *
      * @stable ICU 3.8
      */
     public DateTimeRule(int month, int dayOfMonth, int dayOfWeek, boolean after,
@@ -173,9 +175,9 @@ public class DateTimeRule implements Serializable {
 
     /**
      * Gets the date rule type, such as <code>DOM</code>
-     * 
+     *
      * @return The date rule type.
-     * 
+     *
      * @stable ICU 3.8
      */
     public int getDateRuleType() {
@@ -184,9 +186,9 @@ public class DateTimeRule implements Serializable {
 
     /**
      * Gets the rule month.
-     * 
+     *
      * @return The rule month.
-     * 
+     *
      * @stable ICU 3.8
      */
     public int getRuleMonth() {
@@ -196,9 +198,9 @@ public class DateTimeRule implements Serializable {
     /**
      * Gets the rule day of month.  When the date rule type
      * is <code>DOW</code>, the value is always 0.
-     * 
+     *
      * @return The rule day of month
-     * 
+     *
      * @stable ICU 3.8
      */
     public int getRuleDayOfMonth() {
@@ -208,9 +210,9 @@ public class DateTimeRule implements Serializable {
     /**
      * Gets the rule day of week.  When the date rule type
      * is <code>DOM</code>, the value is always 0.
-     * 
+     *
      * @return The rule day of week.
-     * 
+     *
      * @stable ICU 3.8
      */
     public int getRuleDayOfWeek() {
@@ -221,9 +223,9 @@ public class DateTimeRule implements Serializable {
      * Gets the rule day of week ordinal number in the month.
      * When the date rule type is not <code>DOW</code>, the value is
      * always 0.
-     * 
+     *
      * @return The rule day of week ordinal number in the month.
-     * 
+     *
      * @stable ICU 3.8
      */
     public int getRuleWeekInMonth() {
@@ -232,10 +234,10 @@ public class DateTimeRule implements Serializable {
 
     /**
      * Gets the time rule type
-     * 
+     *
      * @return The time rule type, either <code>WALL_TIME</code> or <code>STANDARD_TIME</code>
      *         or <code>UTC_TIME</code>.
-     * 
+     *
      * @stable ICU 3.8
      */
     public int getTimeRuleType() {
@@ -244,15 +246,15 @@ public class DateTimeRule implements Serializable {
 
     /**
      * Gets the rule time in the rule day.
-     * 
+     *
      * @return The time in the rule day in milliseconds.
-     * 
+     *
      * @stable ICU 3.8
      */
     public int getRuleMillisInDay() {
         return millisInDay;
     }
-    
+
     private static final String[] DOWSTR = {"", "Sun", "Mon", "Tue", "Wed", "Thu", "Fri", "Sat"};
     private static final String[] MONSTR = {"Jan", "Feb", "Mar", "Apr", "May", "Jun", "Jul", "Aug", "Sep", "Oct", "Nov", "Dec"};
 
@@ -260,9 +262,10 @@ public class DateTimeRule implements Serializable {
      * Returns a <code>String</code> representation of this <code>DateTimeRule</code> object.
      * This method is used for debugging purpose only.  The string representation can be changed
      * in future version of ICU without any notice.
-     * 
+     *
      * @stable ICU 3.8
      */
+    @Override
     public String toString() {
         String sDate = null;
         String sTimeRuleType = null;
diff --git a/app/src/main/java/com/ibm/icu/util/EasterHoliday.java b/icu4j/src/main/java/com/ibm/icu/util/EasterHoliday.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/util/EasterHoliday.java
rename to icu4j/src/main/java/com/ibm/icu/util/EasterHoliday.java
index 9090c98..f950a8b 100644
--- a/app/src/main/java/com/ibm/icu/util/EasterHoliday.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/EasterHoliday.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2014, International Business Machines Corporation and    *
@@ -12,7 +14,7 @@ import java.util.Date;
 /**
  * <b>Note:</b> The Holiday framework is a technology preview.
  * Despite its age, is still draft API, and clients should treat it as such.
- * 
+ *
  * A Holiday subclass which represents holidays that occur
  * a fixed number of days before or after Easter.  Supports both the
  * Western and Orthodox methods for calculating Easter.
@@ -158,17 +160,19 @@ class EasterRule implements DateRule {
     }
 
     /**
-     * Return the first occurrance of this rule on or after the given date
+     * Return the first occurrence of this rule on or after the given date
      */
+    @Override
     public Date firstAfter(Date start)
     {
         return doFirstBetween(start, null);
     }
 
     /**
-     * Return the first occurrance of this rule on or after
+     * Return the first occurrence of this rule on or after
      * the given start date and before the given end date.
      */
+    @Override
     public Date firstBetween(Date start, Date end)
     {
         return doFirstBetween(start, end);
@@ -177,6 +181,7 @@ class EasterRule implements DateRule {
     /**
      * Return true if the given Date is on the same day as Easter
      */
+    @Override
     public boolean isOn(Date date)
     {
         synchronized(calendar) {
@@ -192,6 +197,7 @@ class EasterRule implements DateRule {
     /**
      * Return true if Easter occurs between the two dates given
      */
+    @Override
     public boolean isBetween(Date start, Date end)
     {
         return firstBetween(start, end) != null; // TODO: optimize?
diff --git a/app/src/main/java/com/ibm/icu/util/EthiopicCalendar.java b/icu4j/src/main/java/com/ibm/icu/util/EthiopicCalendar.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/util/EthiopicCalendar.java
rename to icu4j/src/main/java/com/ibm/icu/util/EthiopicCalendar.java
index 0cf3a16..89e0835 100644
--- a/app/src/main/java/com/ibm/icu/util/EthiopicCalendar.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/EthiopicCalendar.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2005-2016, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/util/Freezable.java b/icu4j/src/main/java/com/ibm/icu/util/Freezable.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/util/Freezable.java
rename to icu4j/src/main/java/com/ibm/icu/util/Freezable.java
index 3ca268e..b88ffe0 100644
--- a/app/src/main/java/com/ibm/icu/util/Freezable.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/Freezable.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ******************************************************************************
  * Copyright (C) 2005-2016, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/util/GenderInfo.java b/icu4j/src/main/java/com/ibm/icu/util/GenderInfo.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/util/GenderInfo.java
rename to icu4j/src/main/java/com/ibm/icu/util/GenderInfo.java
index c141141..170061d 100644
--- a/app/src/main/java/com/ibm/icu/util/GenderInfo.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/GenderInfo.java
@@ -1,7 +1,9 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ********************************************************************************
- * Copyright (C) 2003-2014, Google, International Business Machines Corporation *
- * and others. All Rights Reserved.                                             *
+ * Copyright (C) 2003-2016, Google, International Business Machines Corporation
+ * and others. All Rights Reserved.
  ********************************************************************************
 */
 package com.ibm.icu.util;
@@ -14,6 +16,7 @@ import java.util.Map;
 import java.util.MissingResourceException;
 
 import com.ibm.icu.impl.ICUCache;
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.impl.SimpleCache;
 
@@ -240,7 +243,7 @@ public class GenderInfo {
 
         private static GenderInfo load(ULocale ulocale) {
             UResourceBundle rb = UResourceBundle.getBundleInstance(
-                    ICUResourceBundle.ICU_BASE_NAME,
+                    ICUData.ICU_BASE_NAME,
                     "genderList",
                     ICUResourceBundle.ICU_DATA_CLASS_LOADER, true);
             UResourceBundle genderList = rb.get("genderList");
diff --git a/app/src/main/java/com/ibm/icu/util/GlobalizationPreferences.java b/icu4j/src/main/java/com/ibm/icu/util/GlobalizationPreferences.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/util/GlobalizationPreferences.java
rename to icu4j/src/main/java/com/ibm/icu/util/GlobalizationPreferences.java
index 9ea6dce..cab3bdf 100644
--- a/app/src/main/java/com/ibm/icu/util/GlobalizationPreferences.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/GlobalizationPreferences.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2004-2014, International Business Machines Corporation and
@@ -84,7 +86,7 @@ import com.ibm.icu.text.SimpleDateFormat;
 // - Other utilities?
 
 public class GlobalizationPreferences implements Freezable<GlobalizationPreferences> {
-    
+
     /**
      * Default constructor
      * @draft ICU 3.6
@@ -96,7 +98,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
      * @draft ICU 3.6
      * @provisional This API might change or be removed in a future release.
      */
-    public static final int 
+    public static final int
         NF_NUMBER = 0,      // NumberFormat.NUMBERSTYLE
         NF_CURRENCY = 1,    // NumberFormat.CURRENCYSTYLE
         NF_PERCENT = 2,     // NumberFormat.PERCENTSTYLE
@@ -129,7 +131,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
         ID_LANGUAGE = 1,
         ID_SCRIPT = 2,
         ID_TERRITORY = 3,
-        ID_VARIANT = 4, 
+        ID_VARIANT = 4,
         ID_KEYWORD = 5,
         ID_KEYWORD_VALUE = 6,
         ID_CURRENCY = 7,
@@ -158,8 +160,8 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
      * for the appropriate territory, currency, timezone, etc.  The
      * user should be given the opportunity to correct those defaults
      * in case they are incorrect.
-     * 
-     * @param inputLocales list of locales in priority order, eg {"be", "fr"} 
+     *
+     * @param inputLocales list of locales in priority order, eg {"be", "fr"}
      *     for Breton first, then French if that fails.
      * @return this, for chaining
      * @draft ICU 3.6
@@ -175,7 +177,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
 
     /**
      * Get a copy of the language/locale priority list
-     * 
+     *
      * @return a copy of the language/locale priority list.
      * @draft ICU 3.6
      * @provisional This API might change or be removed in a future release.
@@ -185,7 +187,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
         if (locales == null) {
             result = guessLocales();
         } else {
-            result = new ArrayList<ULocale>(); 
+            result = new ArrayList<ULocale>();
             result.addAll(locales);
         }
         return result;
@@ -212,7 +214,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
     /**
      * Convenience routine for setting the language/locale priority
      * list from an array.
-     * 
+     *
      * @see #setLocales(List locales)
      * @param uLocales list of locales in an array
      * @return this, for chaining
@@ -229,7 +231,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
     /**
      * Convenience routine for setting the language/locale priority
      * list from a single locale/language.
-     * 
+     *
      * @see #setLocales(List locales)
      * @param uLocale single locale
      * @return this, for chaining
@@ -247,7 +249,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
      * Convenience routine for setting the locale priority list from
      * an Accept-Language string.
      * @see #setLocales(List locales)
-     * @param acceptLanguageString Accept-Language list, as defined by 
+     * @param acceptLanguageString Accept-Language list, as defined by
      *     Section 14.4 of the RFC 2616 (HTTP 1.1)
      * @return this, for chaining
      * @draft ICU 3.6
@@ -271,7 +273,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
      * Convenience function to get a ResourceBundle instance using
      * the specified base name based on the language/locale priority list
      * stored in this object.
-     *  
+     *
      * @param baseName the base name of the resource bundle, a fully qualified
      * class name
      * @return a resource bundle for the given base name and locale based on the
@@ -287,7 +289,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
      * Convenience function to get a ResourceBundle instance using
      * the specified base name and class loader based on the language/locale
      * priority list stored in this object.
-     *  
+     *
      * @param baseName the base name of the resource bundle, a fully qualified
      * class name
      * @param loader the class object from which to load the resource bundle
@@ -338,14 +340,14 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
         }
         return urb;
     }
-    
+
     /**
      * Sets the territory, which is a valid territory according to for
      * RFC 3066 (or successor).  If not otherwise set, default
      * currency and timezone values will be set from this.  The user
      * should be given the opportunity to correct those defaults in
      * case they are incorrect.
-     * 
+     *
      * @param territory code
      * @return this, for chaining
      * @draft ICU 3.6
@@ -362,7 +364,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
     /**
      * Gets the territory setting. If it wasn't explicitly set, it is
      * computed from the general locale setting.
-     * 
+     *
      * @return territory code, explicit or implicit.
      * @draft ICU 3.6
      * @provisional This API might change or be removed in a future release.
@@ -376,7 +378,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
 
     /**
      * Sets the currency code. If this has not been set, uses default for territory.
-     * 
+     *
      * @param currency Valid ISO 4217 currency code.
      * @return this, for chaining
      * @draft ICU 3.6
@@ -392,7 +394,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
 
     /**
      * Get a copy of the currency computed according to the settings.
-     * 
+     *
      * @return currency code, explicit or implicit.
      * @draft ICU 3.6
      * @provisional This API might change or be removed in a future release.
@@ -406,7 +408,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
 
     /**
      * Sets the calendar. If this has not been set, uses default for territory.
-     * 
+     *
      * @param calendar arbitrary calendar
      * @return this, for chaining
      * @draft ICU 3.6
@@ -421,8 +423,8 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
     }
 
     /**
-     * Get a copy of the calendar according to the settings. 
-     * 
+     * Get a copy of the calendar according to the settings.
+     *
      * @return calendar explicit or implicit.
      * @draft ICU 3.6
      * @provisional This API might change or be removed in a future release.
@@ -439,7 +441,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
 
     /**
      * Sets the timezone ID.  If this has not been set, uses default for territory.
-     * 
+     *
      * @param timezone a valid TZID (see UTS#35).
      * @return this, for chaining
      * @draft ICU 3.6
@@ -456,7 +458,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
     /**
      * Get the timezone. It was either explicitly set, or is
      * heuristically computed from other settings.
-     * 
+     *
      * @return timezone, either implicitly or explicitly set
      * @draft ICU 3.6
      * @provisional This API might change or be removed in a future release.
@@ -469,8 +471,8 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
     }
 
     /**
-     * Get a copy of the collator according to the settings. 
-     * 
+     * Get a copy of the collator according to the settings.
+     *
      * @return collator explicit or implicit.
      * @draft ICU 3.6
      * @provisional This API might change or be removed in a future release.
@@ -498,7 +500,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
             throw new UnsupportedOperationException("Attempt to modify immutable object");
         }
         try {
-            this.collator = (Collator) collator.clone(); // clone for safety         
+            this.collator = (Collator) collator.clone(); // clone for safety
         } catch (CloneNotSupportedException e) {
                 throw new ICUCloneNotSupportedException("Error in cloning collator", e);
         }
@@ -508,7 +510,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
     /**
      * Get a copy of the break iterator for the specified type according to the
      * settings.
-     * 
+     *
      * @param type break type - BI_CHARACTER or BI_WORD, BI_LINE, BI_SENTENCE, BI_TITLE
      * @return break iterator explicit or implicit
      * @draft ICU 3.6
@@ -526,7 +528,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
 
     /**
      * Explicitly set the break iterator for this object.
-     * 
+     *
      * @param type break type - BI_CHARACTER or BI_WORD, BI_LINE, BI_SENTENCE, BI_TITLE
      * @param iterator a break iterator
      * @return this, for chaining
@@ -549,7 +551,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
     /**
      * Get the display name for an ID: language, script, territory, currency, timezone...
      * Uses the language priority list to do so.
-     * 
+     *
      * @param id language code, script code, ...
      * @param type specifies the type of the ID: ID_LANGUAGE, etc.
      * @return the display name
@@ -564,23 +566,23 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
             }
             switch (type) {
             case ID_LOCALE:
-                result = ULocale.getDisplayName(id, locale); 
+                result = ULocale.getDisplayName(id, locale);
                 break;
             case ID_LANGUAGE:
-                result = ULocale.getDisplayLanguage(id, locale); 
+                result = ULocale.getDisplayLanguage(id, locale);
                 break;
             case ID_SCRIPT:
-                result = ULocale.getDisplayScript("und-" + id, locale); 
+                result = ULocale.getDisplayScript("und-" + id, locale);
                 break;
             case ID_TERRITORY:
-                result = ULocale.getDisplayCountry("und-" + id, locale); 
+                result = ULocale.getDisplayCountry("und-" + id, locale);
                 break;
             case ID_VARIANT:
                 // TODO fix variant parsing
-                result = ULocale.getDisplayVariant("und-QQ-" + id, locale); 
+                result = ULocale.getDisplayVariant("und-QQ-" + id, locale);
                 break;
             case ID_KEYWORD:
-                result = ULocale.getDisplayKeyword(id, locale); 
+                result = ULocale.getDisplayKeyword(id, locale);
                 break;
             case ID_KEYWORD_VALUE:
                 String[] parts = new String[2];
@@ -594,12 +596,12 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
             case ID_CURRENCY_SYMBOL:
             case ID_CURRENCY:
                 Currency temp = new Currency(id);
-                result =temp.getName(locale, type==ID_CURRENCY 
-                                     ? Currency.LONG_NAME 
+                result =temp.getName(locale, type==ID_CURRENCY
+                                     ? Currency.LONG_NAME
                                      : Currency.SYMBOL_NAME, new boolean[1]);
                 // TODO: have method that doesn't take parameter. Add
                 // function to determine whether string is choice
-                // format.  
+                // format.
                 // TODO: have method that doesn't require us
                 // to create a currency
                 break;
@@ -610,7 +612,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
                 // TODO, have method that doesn't require us to create a timezone
                 // fix other hacks
                 // hack for couldn't match
-                
+
                 boolean isBadStr = false;
                 // Matcher badTimeZone = Pattern.compile("[A-Z]{2}|.*\\s\\([A-Z]{2}\\)").matcher("");
                 // badtzstr = badTimeZone.reset(result).matches();
@@ -652,7 +654,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
      * a particular combination of dateStyle and timeStyle. DF_NONE should
      * be used if for the style, where only the date or time format individually
      * is being set.
-     * 
+     *
      * @param dateStyle DF_FULL, DF_LONG, DF_MEDIUM, DF_SHORT or DF_NONE
      * @param timeStyle DF_FULL, DF_LONG, DF_MEDIUM, DF_SHORT or DF_NONE
      * @param format The date format
@@ -677,7 +679,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
      * is returned. Otherwise, the language priority list is used.
      * DF_NONE should be used for the style, where only the date or
      * time format individually is being gotten.
-     * 
+     *
      * @param dateStyle DF_FULL, DF_LONG, DF_MEDIUM, DF_SHORT or DF_NONE
      * @param timeStyle DF_FULL, DF_LONG, DF_MEDIUM, DF_SHORT or DF_NONE
      * @return a DateFormat, according to the above description
@@ -709,7 +711,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
      * there is an explicit (non-null) number format set, a copy of
      * that is returned.  Otherwise, the language priority list is
      * used.
-     * 
+     *
      * @param style NF_NUMBER, NF_CURRENCY, NF_PERCENT, NF_SCIENTIFIC, NF_INTEGER
      * @draft ICU 3.6
      * @provisional This API might change or be removed in a future release.
@@ -732,7 +734,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
 
     /**
      * Sets a number format explicitly. Overrides the general locale settings.
-     * 
+     *
      * @param style NF_NUMBER, NF_CURRENCY, NF_PERCENT, NF_SCIENTIFIC, NF_INTEGER
      * @param format The number format
      * @return this, for chaining
@@ -752,7 +754,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
 
     /**
      * Restore the object to the initial state.
-     * 
+     *
      * @return this, for chaining
      * @draft ICU 3.6
      * @provisional This API might change or be removed in a future release.
@@ -801,13 +803,13 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
      * Before: en_US, en, en_GB, en, en, fr_FR, fr
      * <br>
      * After: en_US, en_GB, en, fr_FR, fr
-     * <br> 
+     * <br>
      * <br>
      * The final locale list is used to produce a default value for the appropriate territory,
      * currency, timezone, etc.  The list also represents the lookup order used in
      * <code>getResourceBundle</code> for this object.  A subclass may override this method
      * to customize the algorithm used for populating the locale list.
-     * 
+     *
      * @param inputLocales The list of input locales
      * @draft ICU 3.6
      * @provisional This API might change or be removed in a future release.
@@ -851,7 +853,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
                         // We want to see zh_Hant_HK before zh_HK
                         result.add(j, uloc);
                         bInserted = true;
-                        break;                      
+                        break;
                     } else if (script.length() == 0 && country.length() > 0 && c.length() == 0) {
                         // We want to see zh_HK before zh_Hant
                         result.add(j, uloc);
@@ -893,8 +895,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
         int index = 0;
         while (index < result.size()) {
             ULocale uloc = result.get(index);
-            while (true) {
-                uloc = uloc.getFallback();
+            while ((uloc = uloc.getFallback()) != null) {
                 if (uloc.getLanguage().length() == 0) {
                     break;
                 }
@@ -906,7 +907,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
 
         /*
          * Step 3: Remove earlier occurrence of duplicated locales
-         * 
+         *
          * Example:
          *   Before - en_US_Boston, en_US, en, en_US, en, fr_FR, fr,
          *            zh_TW, zn, zh_Hant, zh, zh, fr_CA, fr
@@ -932,12 +933,12 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
         return result;
     }
 
-    
+
     /**
      * This function can be overridden by subclasses to use different heuristics.
      * <b>It MUST return a 'safe' value,
      * one whose modification will not affect this object.</b>
-     * 
+     *
      * @param dateStyle
      * @param timeStyle
      * @draft ICU 3.6
@@ -963,7 +964,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
      * This function can be overridden by subclasses to use different heuristics.
      * <b>It MUST return a 'safe' value,
      * one whose modification will not affect this object.</b>
-     * 
+     *
      * @param style
      * @draft ICU 3.6
      * @provisional This API might change or be removed in a future release.
@@ -999,7 +1000,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
 
     /**
      * This function can be overridden by subclasses to use different heuristics.
-     * 
+     *
      * @draft ICU 3.6
      * @provisional This API might change or be removed in a future release.
      */
@@ -1034,7 +1035,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
 
     /**
      * This function can be overridden by subclasses to use different heuristics
-     * 
+     *
      * @draft ICU 3.6
      * @provisional This API might change or be removed in a future release.
      */
@@ -1046,7 +1047,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
      * This function can be overridden by subclasses to use different heuristics
      * <b>It MUST return a 'safe' value,
      * one whose modification will not affect this object.</b>
-     * 
+     *
      * @draft ICU 3.6
      * @provisional This API might change or be removed in a future release.
      */
@@ -1063,7 +1064,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
      * This function can be overridden by subclasses to use different heuristics.
      * <b>It MUST return a 'safe' value,
      * one whose modification will not affect this object.</b>
-     * 
+     *
      * @draft ICU 3.6
      * @provisional This API might change or be removed in a future release.
      */
@@ -1079,7 +1080,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
      * This function can be overridden by subclasses to use different heuristics.
      * <b>It MUST return a 'safe' value,
      * one whose modification will not affect this object.</b>
-     * 
+     *
      * @param type
      * @draft ICU 3.6
      * @provisional This API might change or be removed in a future release.
@@ -1116,7 +1117,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
      * This function can be overridden by subclasses to use different heuristics.
      * <b>It MUST return a 'safe' value,
      * one whose modification will not affect this object.</b>
-     * 
+     *
      * @draft ICU 3.6
      * @provisional This API might change or be removed in a future release.
      */
@@ -1125,7 +1126,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
         // for single-zone countries, pick that zone
         // for others, pick the most populous zone
         // for now, just use fixed value
-        // NOTE: in a few cases can do better by looking at language. 
+        // NOTE: in a few cases can do better by looking at language.
         // Eg haw+US should go to Pacific/Honolulu
         // fr+CA should go to America/Montreal
         String timezoneString = territory_tzid_hack_map.get(getTerritory());
@@ -1150,7 +1151,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
      * This function can be overridden by subclasses to use different heuristics.
      * <b>It MUST return a 'safe' value,
      * one whose modification will not affect this object.</b>
-     * 
+     *
      * @draft ICU 3.6
      * @provisional This API might change or be removed in a future release.
      */
@@ -1161,9 +1162,9 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
         }
         return Calendar.getInstance(getTimeZone(), calLocale);
     }
-    
+
     // PRIVATES
-    
+
     private List<ULocale> locales;
     private String territory;
     private Currency currency;
@@ -1174,7 +1175,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
     private DateFormat[][] dateFormats;
     private NumberFormat[] numberFormats;
     private List<ULocale> implicitLocales;
-    
+
     {
         reset();
     }
@@ -1198,9 +1199,9 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
         if (bits != null && bits.get(type)) {
             return true;
         }
-        return false;        
+        return false;
     }
-    
+
     /*
      * Available locales for service types
      */
@@ -1271,7 +1272,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
     }
 
     /** WARNING: All of this data is temporary, until we start importing from CLDR!!!
-     * 
+     *
      */
     private static final Map<String, String> language_territory_hack_map = new HashMap<String, String>();
     private static final String[][] language_territory_hack = {
@@ -1466,7 +1467,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
         {"MH", "Pacific/Majuro"},
         {"MN", "Asia/Ulaanbaatar"},
         {"SJ", "Arctic/Longyearbyen"},
-        {"UM", "Pacific/Midway"},   
+        {"UM", "Pacific/Midway"},
     };
     static {
         for (int i = 0; i < territory_tzid_hack.length; ++i) {
@@ -1475,13 +1476,14 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
     }
 
     // Freezable implementation
-    
+
     private volatile boolean frozen;
 
     /**
      * @draft ICU 3.6
      * @provisional This API might change or be removed in a future release.
      */
+    @Override
     public boolean isFrozen() {
         return frozen;
     }
@@ -1490,6 +1492,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
      * @draft ICU 4.4
      * @provisional This API might change or be removed in a future release.
      */
+    @Override
     public GlobalizationPreferences freeze() {
         frozen = true;
         return this;
@@ -1499,6 +1502,7 @@ public class GlobalizationPreferences implements Freezable<GlobalizationPreferen
      * @draft ICU 4.4
      * @provisional This API might change or be removed in a future release.
      */
+    @Override
     public GlobalizationPreferences cloneAsThawed() {
         try {
             GlobalizationPreferences result = (GlobalizationPreferences) clone();
diff --git a/app/src/main/java/com/ibm/icu/util/GregorianCalendar.java b/icu4j/src/main/java/com/ibm/icu/util/GregorianCalendar.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/util/GregorianCalendar.java
rename to icu4j/src/main/java/com/ibm/icu/util/GregorianCalendar.java
index cc41ac8..9c0bf33 100644
--- a/app/src/main/java/com/ibm/icu/util/GregorianCalendar.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/GregorianCalendar.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  * Copyright (C) 1996-2016, International Business Machines
  * Corporation and others.  All Rights Reserved.
@@ -768,7 +770,7 @@ public class GregorianCalendar extends Calendar {
             eyear = (int) floorDivide(4*julianEpochDay + 1464, 1461);
             
             // Compute the Julian calendar day number for January 1, eyear
-            long january1 = 365*(eyear-1) + floorDivide(eyear-1, 4);
+            long january1 = 365L*(eyear-1L) + floorDivide(eyear-1L, 4L);
             dayOfYear = (int)(julianEpochDay - january1); // 0-based
             
             // Julian leap years occurred historically every 4 years starting
diff --git a/app/src/main/java/com/ibm/icu/util/HebrewCalendar.java b/icu4j/src/main/java/com/ibm/icu/util/HebrewCalendar.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/util/HebrewCalendar.java
rename to icu4j/src/main/java/com/ibm/icu/util/HebrewCalendar.java
index cd6c5c5..9cdbe48 100644
--- a/app/src/main/java/com/ibm/icu/util/HebrewCalendar.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/HebrewCalendar.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/util/HebrewHoliday.java b/icu4j/src/main/java/com/ibm/icu/util/HebrewHoliday.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/util/HebrewHoliday.java
rename to icu4j/src/main/java/com/ibm/icu/util/HebrewHoliday.java
index bb36af7..fe83b24 100644
--- a/app/src/main/java/com/ibm/icu/util/HebrewHoliday.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/HebrewHoliday.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/util/Holiday.java b/icu4j/src/main/java/com/ibm/icu/util/Holiday.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/util/Holiday.java
rename to icu4j/src/main/java/com/ibm/icu/util/Holiday.java
index fa25250..53e61c1 100644
--- a/app/src/main/java/com/ibm/icu/util/Holiday.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/Holiday.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2011, International Business Machines Corporation and    *
@@ -17,7 +19,7 @@ import com.ibm.icu.util.ULocale.Category;
 /**
  * <b>Note:</b> The Holiday framework is a technology preview.
  * Despite its age, is still draft API, and clients should treat it as such.
- * 
+ *
  * An abstract class representing a holiday.
  * @draft ICU 2.8 (retainAll)
  * @provisional This API might change or be removed in a future release.
@@ -72,6 +74,7 @@ public abstract class Holiday implements DateRule
      * @draft ICU 2.8
      * @provisional This API might change or be removed in a future release.
      */
+    @Override
     public Date firstAfter(Date start) {
         return rule.firstAfter(start);
     }
@@ -90,6 +93,7 @@ public abstract class Holiday implements DateRule
      * @draft ICU 2.8
      * @provisional This API might change or be removed in a future release.
      */
+    @Override
     public Date firstBetween(Date start, Date end) {
         return rule.firstBetween(start, end);
     }
@@ -104,6 +108,7 @@ public abstract class Holiday implements DateRule
      * @draft ICU 2.8
      * @provisional This API might change or be removed in a future release.
      */
+    @Override
     public boolean isOn(Date date) {
         //System.out.println(name + ".isOn(" + date.toString() + "):");
         return rule.isOn(date);
@@ -115,6 +120,7 @@ public abstract class Holiday implements DateRule
      * @draft ICU 2.8
      * @provisional This API might change or be removed in a future release.
      */
+    @Override
     public boolean isBetween(Date start, Date end) {
         return rule.isBetween(start, end);
     }
diff --git a/app/src/main/java/com/ibm/icu/util/ICUCloneNotSupportedException.java b/icu4j/src/main/java/com/ibm/icu/util/ICUCloneNotSupportedException.java
similarity index 92%
rename from app/src/main/java/com/ibm/icu/util/ICUCloneNotSupportedException.java
rename to icu4j/src/main/java/com/ibm/icu/util/ICUCloneNotSupportedException.java
index 91222c0..0ef2447 100644
--- a/app/src/main/java/com/ibm/icu/util/ICUCloneNotSupportedException.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/ICUCloneNotSupportedException.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014-2015, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/util/ICUException.java b/icu4j/src/main/java/com/ibm/icu/util/ICUException.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/util/ICUException.java
rename to icu4j/src/main/java/com/ibm/icu/util/ICUException.java
index 63d9291..7e429c8 100644
--- a/app/src/main/java/com/ibm/icu/util/ICUException.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/ICUException.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014-2015, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/util/ICUUncheckedIOException.java b/icu4j/src/main/java/com/ibm/icu/util/ICUUncheckedIOException.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/util/ICUUncheckedIOException.java
rename to icu4j/src/main/java/com/ibm/icu/util/ICUUncheckedIOException.java
index a90c2c9..044a5ee 100644
--- a/app/src/main/java/com/ibm/icu/util/ICUUncheckedIOException.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/ICUUncheckedIOException.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014-2015, International Business Machines Corporation and
diff --git a/app/src/main/java/com/ibm/icu/util/IllformedLocaleException.java b/icu4j/src/main/java/com/ibm/icu/util/IllformedLocaleException.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/util/IllformedLocaleException.java
rename to icu4j/src/main/java/com/ibm/icu/util/IllformedLocaleException.java
index dbe6e3d..36c8ac4 100644
--- a/app/src/main/java/com/ibm/icu/util/IllformedLocaleException.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/IllformedLocaleException.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2009-2012, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/util/IndianCalendar.java b/icu4j/src/main/java/com/ibm/icu/util/IndianCalendar.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/util/IndianCalendar.java
rename to icu4j/src/main/java/com/ibm/icu/util/IndianCalendar.java
index fea2bbd..5116f5b 100644
--- a/app/src/main/java/com/ibm/icu/util/IndianCalendar.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/IndianCalendar.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2011, International Business Machines Corporation and    *
@@ -448,11 +450,7 @@ public class IndianCalendar extends Calendar {
            month %= 12;
        }
        
-       if(month == 12) {
-           imonth = 1;
-       } else {
-           imonth = month +1;  
-       }
+       imonth = month + 1;  
        
        double jd = IndianToJD(year ,imonth, 1);
        
diff --git a/app/src/main/java/com/ibm/icu/util/InitialTimeZoneRule.java b/icu4j/src/main/java/com/ibm/icu/util/InitialTimeZoneRule.java
similarity index 92%
rename from app/src/main/java/com/ibm/icu/util/InitialTimeZoneRule.java
rename to icu4j/src/main/java/com/ibm/icu/util/InitialTimeZoneRule.java
index f2bf3ed..acb482e 100644
--- a/app/src/main/java/com/ibm/icu/util/InitialTimeZoneRule.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/InitialTimeZoneRule.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2007-2008, International Business Machines Corporation and    *
@@ -12,7 +14,7 @@ import java.util.Date;
  * <code>InitialTimeZoneRule</code> represents a time zone rule
  * representing a time zone effective from the beginning and
  * has no actual start times.
- * 
+ *
  * @stable ICU 3.8
  */
 public class InitialTimeZoneRule extends TimeZoneRule {
@@ -22,12 +24,12 @@ public class InitialTimeZoneRule extends TimeZoneRule {
     /**
      * Constructs a <code>InitialTimeZoneRule</code> with the name, the GMT offset of its
      * standard time and the amount of daylight saving offset adjustment.
-     * 
+     *
      * @param name          The time zone name.
      * @param rawOffset     The UTC offset of its standard time in milliseconds.
      * @param dstSavings    The amount of daylight saving offset adjustment in milliseconds.
      *                      If this ia a rule for standard time, the value of this argument is 0.
-     * 
+     *
      * @stable ICU 3.8
      */
     public InitialTimeZoneRule(String name, int rawOffset, int dstSavings) {
@@ -36,22 +38,24 @@ public class InitialTimeZoneRule extends TimeZoneRule {
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * @stable ICU 3.8
      */
+    @Override
     public boolean isEquivalentTo(TimeZoneRule other) {
         if (other instanceof InitialTimeZoneRule) {
             return super.isEquivalentTo(other);
         }
         return false;
     }
-    
+
     /**
      * {@inheritDoc}<br><br>
      * Note: This method in <code>InitialTimeZoneRule</code> always returns null.
-     * 
+     *
      * @stable ICU 3.8
      */
+    @Override
     public Date getFinalStart(int prevRawOffset, int prevDSTSavings) {
         // No start time available
         return null;
@@ -60,9 +64,10 @@ public class InitialTimeZoneRule extends TimeZoneRule {
     /**
      * {@inheritDoc}<br><br>
      * Note: This method in <code>InitialTimeZoneRule</code> always returns null.
-     * 
+     *
      * @stable ICU 3.8
      */
+    @Override
     public Date getFirstStart(int prevRawOffset, int prevDSTSavings) {
         // No start time available
         return null;
@@ -71,9 +76,10 @@ public class InitialTimeZoneRule extends TimeZoneRule {
     /**
      * {@inheritDoc}<br><br>
      * Note: This method in <code>InitialTimeZoneRule</code> always returns null.
-     * 
+     *
      * @stable ICU 3.8
      */
+    @Override
     public Date getNextStart(long base, int prevRawOffset, int prevDSTSavings,
             boolean inclusive) {
         // No start time available
@@ -83,9 +89,10 @@ public class InitialTimeZoneRule extends TimeZoneRule {
     /**
      * {@inheritDoc}<br><br>
      * Note: This method in <code>InitialTimeZoneRule</code> always returns null.
-     * 
+     *
      * @stable ICU 3.8
      */
+    @Override
     public Date getPreviousStart(long base, int prevRawOffset,
             int prevDSTSavings, boolean inclusive) {
         // No start time available
@@ -97,6 +104,7 @@ public class InitialTimeZoneRule extends TimeZoneRule {
      * Note: This method in <code>InitialTimeZoneRule</code> always returns false.
      * @stable ICU 3.8
      */
+    @Override
     public boolean isTransitionRule() {
         return false;
     }
diff --git a/app/src/main/java/com/ibm/icu/util/IslamicCalendar.java b/icu4j/src/main/java/com/ibm/icu/util/IslamicCalendar.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/util/IslamicCalendar.java
rename to icu4j/src/main/java/com/ibm/icu/util/IslamicCalendar.java
index 3ee1aeb..f50d49e 100644
--- a/app/src/main/java/com/ibm/icu/util/IslamicCalendar.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/IslamicCalendar.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and    *
@@ -21,7 +23,7 @@ import com.ibm.icu.util.ULocale.Category;
  * is used as the civil calendar in most of the Arab world and the
  * liturgical calendar of the Islamic faith worldwide.  This calendar
  * is also known as the "Hijri" calendar, since it starts at the time
- * of Mohammed's emigration (or "hijra") to Medinah on Thursday, 
+ * of Mohammed's emigration (or "hijra") to Medinah on Thursday,
  * July 15, 622 AD (Julian).
  * <p>
  * The Islamic calendar is strictly lunar, and thus an Islamic year of twelve
@@ -44,8 +46,8 @@ import com.ibm.icu.util.ULocale.Category;
  * This is the default behavior of a newly-created <code>IslamicCalendar</code>
  * object.
  * <p>
- * The Islamic <em>religious</em> calendar and Saudi Arabia's <em>Umm al-Qura</em> 
- * calendar, however, are based on the <em>observation</em> of the crescent moon.  
+ * The Islamic <em>religious</em> calendar and Saudi Arabia's <em>Umm al-Qura</em>
+ * calendar, however, are based on the <em>observation</em> of the crescent moon.
  * It is thus affected by the position at which the
  * observations are made, seasonal variations in the time of sunset, the
  * eccentricities of the moon's orbit, and even the weather at the observation
@@ -61,21 +63,21 @@ import com.ibm.icu.util.ULocale.Category;
  * calculations.  At present, the approximations used in this class are fairly
  * simplistic; they will be improved in later versions of the code.
  * <p>
- * Like the Islamic religious calendar, <em>Umm al-Qura</em> is also based 
+ * Like the Islamic religious calendar, <em>Umm al-Qura</em> is also based
  * on the sighting method of the crescent moon but is standardized by Saudi Arabia.
- * <p>  
+ * <p>
  * The {@link #setCalculationType(CalculationType) setCalculationType} method determines
  * which approach is used to determine the start of a month.  By default, the
  * fixed-cycle <em>civil</em> calendar is used.  However, if <code>setCalculationType(ISLAMIC)</code>
  * is called, an approximation of the true lunar calendar will be used.
- * Similarly, if <code>setCalculationType(ISLAMIC_UMALQURA)</code> is called, an approximation 
+ * Similarly, if <code>setCalculationType(ISLAMIC_UMALQURA)</code> is called, an approximation
  * of the Umm al-Qura lunar calendar will be used.
  * <p>
  * This class should not be subclassed.</p>
  * <p>
- * IslamicCalendar usually should be instantiated using 
+ * IslamicCalendar usually should be instantiated using
  * {@link com.ibm.icu.util.Calendar#getInstance(ULocale)} passing in a <code>ULocale</code>
- * with the tag <code>"@calendar=islamic"</code> or <code>"@calendar=islamic-civil"</code> 
+ * with the tag <code>"@calendar=islamic"</code> or <code>"@calendar=islamic-civil"</code>
  * or <code>"@calendar=islamic-umalqura"</code>.</p>
  *
  * @see com.ibm.icu.util.GregorianCalendar
@@ -92,76 +94,76 @@ public class IslamicCalendar extends Calendar {
     //-------------------------------------------------------------------------
     // Constants...
     //-------------------------------------------------------------------------
-    
+
     /**
-     * Constant for Muharram, the 1st month of the Islamic year. 
-     * @stable ICU 2.8 
+     * Constant for Muharram, the 1st month of the Islamic year.
+     * @stable ICU 2.8
      */
     public static final int MUHARRAM = 0;
 
     /**
-     * Constant for Safar, the 2nd month of the Islamic year. 
-     * @stable ICU 2.8 
+     * Constant for Safar, the 2nd month of the Islamic year.
+     * @stable ICU 2.8
      */
     public static final int SAFAR = 1;
 
     /**
-     * Constant for Rabi' al-awwal (or Rabi' I), the 3rd month of the Islamic year. 
-     * @stable ICU 2.8 
+     * Constant for Rabi' al-awwal (or Rabi' I), the 3rd month of the Islamic year.
+     * @stable ICU 2.8
      */
     public static final int RABI_1 = 2;
 
     /**
-     * Constant for Rabi' al-thani or (Rabi' II), the 4th month of the Islamic year. 
-     * @stable ICU 2.8 
+     * Constant for Rabi' al-thani or (Rabi' II), the 4th month of the Islamic year.
+     * @stable ICU 2.8
      */
     public static final int RABI_2 = 3;
 
     /**
-     * Constant for Jumada al-awwal or (Jumada I), the 5th month of the Islamic year. 
-     * @stable ICU 2.8 
+     * Constant for Jumada al-awwal or (Jumada I), the 5th month of the Islamic year.
+     * @stable ICU 2.8
      */
     public static final int JUMADA_1 = 4;
 
     /**
-     * Constant for Jumada al-thani or (Jumada II), the 6th month of the Islamic year. 
-     * @stable ICU 2.8 
+     * Constant for Jumada al-thani or (Jumada II), the 6th month of the Islamic year.
+     * @stable ICU 2.8
      */
     public static final int JUMADA_2 = 5;
 
     /**
-     * Constant for Rajab, the 7th month of the Islamic year. 
-     * @stable ICU 2.8 
+     * Constant for Rajab, the 7th month of the Islamic year.
+     * @stable ICU 2.8
      */
     public static final int RAJAB = 6;
 
     /**
-     * Constant for Sha'ban, the 8th month of the Islamic year. 
-     * @stable ICU 2.8 
+     * Constant for Sha'ban, the 8th month of the Islamic year.
+     * @stable ICU 2.8
      */
     public static final int SHABAN = 7;
 
     /**
-     * Constant for Ramadan, the 9th month of the Islamic year. 
-     * @stable ICU 2.8 
+     * Constant for Ramadan, the 9th month of the Islamic year.
+     * @stable ICU 2.8
      */
     public static final int RAMADAN = 8;
 
     /**
-     * Constant for Shawwal, the 10th month of the Islamic year. 
-     * @stable ICU 2.8 
+     * Constant for Shawwal, the 10th month of the Islamic year.
+     * @stable ICU 2.8
      */
     public static final int SHAWWAL = 9;
 
     /**
-     * Constant for Dhu al-Qi'dah, the 11th month of the Islamic year. 
-     * @stable ICU 2.8 
+     * Constant for Dhu al-Qi'dah, the 11th month of the Islamic year.
+     * @stable ICU 2.8
      */
     public static final int DHU_AL_QIDAH = 10;
 
     /**
-     * Constant for Dhu al-Hijjah, the 12th month of the Islamic year. 
-     * @stable ICU 2.8 
+     * Constant for Dhu al-Hijjah, the 12th month of the Islamic year.
+     * @stable ICU 2.8
      */
     public static final int DHU_AL_HIJJAH = 11;
 
@@ -329,7 +331,7 @@ public class IslamicCalendar extends Calendar {
     public void setCivil(boolean beCivil)
     {
         civil = beCivil;
-        
+
         if (beCivil && cType != CalculationType.ISLAMIC_CIVIL) {
             // The fields of the calendar will become invalid, because the calendar
             // rules are different
@@ -346,7 +348,7 @@ public class IslamicCalendar extends Calendar {
             setTimeInMillis(m);
         }
     }
-    
+
     /**
      * Returns <code>true</code> if this object is using the fixed-cycle civil
      * calendar, or <code>false</code> if using the religious, astronomical
@@ -360,7 +362,7 @@ public class IslamicCalendar extends Calendar {
         }
         return false;
     }
-    
+
     //-------------------------------------------------------------------------
     // Minimum / Maximum access functions
     //-------------------------------------------------------------------------
@@ -394,9 +396,9 @@ public class IslamicCalendar extends Calendar {
         {/*                                   */}, // JULIAN_DAY
         {/*                                   */}, // MILLISECONDS_IN_DAY
     };
-    
+
     /*
-     * bit map array where a bit turned on represents a month with 30 days. 
+     * bit map array where a bit turned on represents a month with 30 days.
      */
     private static final int[] UMALQURA_MONTHLENGTH = {
     //* 1300 -1302 */ "1010 1010 1010", "1101 0101 0100", "1110 1100 1001",
@@ -508,6 +510,7 @@ public class IslamicCalendar extends Calendar {
     /**
      * @stable ICU 2.8
      */
+    @Override
     protected int handleGetLimit(int field, int limitType) {
         return LIMITS[field][limitType];
     }
@@ -576,7 +579,7 @@ public class IslamicCalendar extends Calendar {
     {
         return (14 + 11 * year) % 30 < 11;
     }
-    
+
     /**
      * Return the day # on which the given year starts.  Days are counted
      * from the Hijri epoch, origin 0.
@@ -592,7 +595,7 @@ public class IslamicCalendar extends Calendar {
         } else if(cType == CalculationType.ISLAMIC_UMALQURA){
             year -= UMALQURA_YEAR_START;
             // rounded least-squares fit of the dates previously calculated from UMALQURA_MONTHLENGTH iteration
-            int yrStartLinearEstimate = (int)((354.36720 * (double)year) + 460322.05 + 0.5);
+            int yrStartLinearEstimate = (int)((354.36720 * year) + 460322.05 + 0.5);
             // need a slight correction to some
             ys = yrStartLinearEstimate + UMALQURA_YEAR_START_ESTIMATE_FIX[year];
         }
@@ -628,7 +631,7 @@ public class IslamicCalendar extends Calendar {
 
         return ms;
     }
-    
+
     /**
      * Find the day number on which a particular month of the true/lunar
      * Islamic calendar starts.
@@ -644,7 +647,7 @@ public class IslamicCalendar extends Calendar {
         if (start == CalendarCache.EMPTY)
         {
             // Make a guess at when the month started, using the average length
-            long origin = HIJRA_MILLIS 
+            long origin = HIJRA_MILLIS
                         + (long)Math.floor(month * CalendarAstronomer.SYNODIC_MONTH) * ONE_DAY;
 
             double age = moonAge(origin);
@@ -665,7 +668,7 @@ public class IslamicCalendar extends Calendar {
             }
 
             start = (origin - HIJRA_MILLIS) / ONE_DAY + 1;
-            
+
             cache.put(month, start);
         }
         return start;
@@ -674,7 +677,7 @@ public class IslamicCalendar extends Calendar {
     /**
      * Return the "age" of the moon at the given time; this is the difference
      * in ecliptic latitude between the moon and the sun.  This method simply
-     * calls CalendarAstronomer.moonAge, converts to degrees, 
+     * calls CalendarAstronomer.moonAge, converts to degrees,
      * and adjusts the resultto be in the range [-180, 180].
      *
      * @param time  The time at which the moon's age is desired,
@@ -683,7 +686,7 @@ public class IslamicCalendar extends Calendar {
     static final double moonAge(long time)
     {
         double age = 0;
-        
+
         synchronized(astro) {
             astro.setTime(time);
             age = astro.getMoonAge();
@@ -700,12 +703,12 @@ public class IslamicCalendar extends Calendar {
     //-------------------------------------------------------------------------
     // Internal data....
     //
-    
+
     // And an Astronomer object for the moon age calculations
     private static CalendarAstronomer astro = new CalendarAstronomer();
-    
+
     private static CalendarCache cache = new CalendarCache();
-    
+
     /**
      * <code>true</code> if this object uses the fixed-cycle Islamic civil calendar,
      * and <code>false</code> if it approximates the true religious calendar using
@@ -714,10 +717,10 @@ public class IslamicCalendar extends Calendar {
      * @serial
      */
     private boolean civil = true;
-    
+
     /**
      * determines the type of calculation to use for this instance
-     * 
+     *
      * @serial
      * @stable ICU 52
      */
@@ -734,27 +737,32 @@ public class IslamicCalendar extends Calendar {
      * @param month The hijri month, 0-based
      * @stable ICU 2.8
      */
+    @Override
     protected int handleGetMonthLength(int extendedYear, int month) {
 
-        int length = 0;
-        
+        int length;
+
         if (cType == CalculationType.ISLAMIC_CIVIL
                 || cType == CalculationType.ISLAMIC_TBLA
                 || (cType == CalculationType.ISLAMIC_UMALQURA && (extendedYear < UMALQURA_YEAR_START  || extendedYear > UMALQURA_YEAR_END) )) {
             length = 29 + (month+1) % 2;
             if (month == DHU_AL_HIJJAH && civilLeapYear(extendedYear)) {
                 length++;
-            } 
-        } else if (cType == CalculationType.ISLAMIC) {
+            }
+        }
+        else if (cType == CalculationType.ISLAMIC) {
             month = 12*(extendedYear-1) + month;
             length = (int)( trueMonthStart(month+1) - trueMonthStart(month) );
-        }else if (cType == CalculationType.ISLAMIC_UMALQURA){            
+        }
+        else { // cType == CalculationType.ISLAMIC_UMALQURA should be true at this point and not null.
             int idx = (extendedYear - UMALQURA_YEAR_START);     // calculate year offset into bit map array
-            int mask = (0x01 << (11 - month));                  // set mask for bit corresponding to month            
-            if((UMALQURA_MONTHLENGTH[idx] & mask) == 0 )    
+            int mask = (0x01 << (11 - month));                  // set mask for bit corresponding to month
+            if((UMALQURA_MONTHLENGTH[idx] & mask) == 0 ) {
                 length = 29;
-            else
+            }
+            else {
                 length = 30;
+            }
         }
         return length;
     }
@@ -763,8 +771,9 @@ public class IslamicCalendar extends Calendar {
      * Return the number of days in the given Islamic year
      * @stable ICU 2.8
      */
+    @Override
     protected int handleGetYearLength(int extendedYear) {
-        int length =0; 
+        int length =0;
         if (cType == CalculationType.ISLAMIC_CIVIL
                 || cType == CalculationType.ISLAMIC_TBLA
                 || (cType == CalculationType.ISLAMIC_UMALQURA && (extendedYear < UMALQURA_YEAR_START  || extendedYear > UMALQURA_YEAR_END) )) {
@@ -779,7 +788,7 @@ public class IslamicCalendar extends Calendar {
 
         return length;
     }
-    
+
     //-------------------------------------------------------------------------
     // Functions for converting from field values to milliseconds....
     //-------------------------------------------------------------------------
@@ -792,9 +801,10 @@ public class IslamicCalendar extends Calendar {
     /**
      * @stable ICU 2.8
      */
+    @Override
     protected int handleComputeMonthStart(int eyear, int month, boolean useMonth) {
         return (int)(monthStart(eyear, month) + ((cType ==  CalculationType.ISLAMIC_TBLA)? ASTRONOMICAL_EPOC: CIVIL_EPOC) - 1);
-    }    
+    }
 
     //-------------------------------------------------------------------------
     // Functions for converting from milliseconds to field values
@@ -803,6 +813,7 @@ public class IslamicCalendar extends Calendar {
     /**
      * @stable ICU 2.8
      */
+    @Override
     protected int handleGetExtendedYear() {
         int year;
         if (newerField(EXTENDED_YEAR, YEAR) == EXTENDED_YEAR) {
@@ -823,12 +834,13 @@ public class IslamicCalendar extends Calendar {
      * <li>DAY_OF_MONTH
      * <li>DAY_OF_YEAR
      * <li>EXTENDED_YEAR</ul>
-     * 
+     *
      * The DAY_OF_WEEK and DOW_LOCAL fields are already set when this
      * method is called. The getGregorianXxx() methods return Gregorian
      * calendar equivalents for the given Julian day.
      * @stable ICU 2.8
      */
+    @Override
     protected void handleComputeFields(int julianDay) {
         int year =0, month=0, dayOfMonth=0, dayOfYear=0;
         long monthStart;
@@ -872,14 +884,14 @@ public class IslamicCalendar extends Calendar {
             } else {
                 int y =UMALQURA_YEAR_START-1, m =0;
                 long d = 1;
-                while(d > 0) { 
-                    y++; 
+                while(d > 0) {
+                    y++;
                     d = days - yearStart(y) +1;
                     if(d == handleGetYearLength(y)) {
                         m=11;
                         break;
                     } else if(d < handleGetYearLength(y) ) {
-                        int monthLen = handleGetMonthLength(y, m); 
+                        int monthLen = handleGetMonthLength(y, m);
                         m=0;
                         while(d > monthLen) {
                             d -= monthLen;
@@ -894,24 +906,24 @@ public class IslamicCalendar extends Calendar {
             }
         }
 
-       
+
         dayOfMonth = (int)(days - monthStart(year, month)) + 1;
 
         // Now figure out the day of the year.
         dayOfYear = (int)(days - monthStart(year, 0) + 1);
-        
+
 
         internalSet(ERA, 0);
         internalSet(YEAR, year);
         internalSet(EXTENDED_YEAR, year);
         internalSet(MONTH, month);
         internalSet(DAY_OF_MONTH, dayOfMonth);
-        internalSet(DAY_OF_YEAR, dayOfYear);       
-    }    
-    
+        internalSet(DAY_OF_YEAR, dayOfYear);
+    }
+
     /**
      *  enumeration of available calendar calculation types
-     *  
+     *
      * @stable ICU 52
      */
     public enum CalculationType {
@@ -948,17 +960,17 @@ public class IslamicCalendar extends Calendar {
             return bcpType;
         }
     };
-    
+
     /**
      * sets the calculation type for this calendar.
-     * 
+     *
      * @stable ICU 55
      */
     public void setCalculationType(CalculationType type) {
         cType = type;
-        
+
         // ensure civil property is up-to-date
-        if(cType == CalculationType.ISLAMIC_CIVIL) 
+        if(cType == CalculationType.ISLAMIC_CIVIL)
             civil = true;
         else
             civil = false;
@@ -966,7 +978,7 @@ public class IslamicCalendar extends Calendar {
 
     /**
      * gets the calculation type for this calendar.
-     * 
+     *
      * @stable ICU 55
      */
     public CalculationType getCalculationType() {
@@ -978,23 +990,24 @@ public class IslamicCalendar extends Calendar {
      */
     private void setCalcTypeForLocale(ULocale locale) {
         String localeCalType = CalendarUtil.getCalendarType(locale);
-        if("islamic-civil".equals(localeCalType)) 
+        if("islamic-civil".equals(localeCalType))
             setCalculationType(CalculationType.ISLAMIC_CIVIL);
-        else if("islamic-umalqura".equals(localeCalType)) 
+        else if("islamic-umalqura".equals(localeCalType))
             setCalculationType(CalculationType.ISLAMIC_UMALQURA);
-        else if("islamic-tbla".equals(localeCalType)) 
+        else if("islamic-tbla".equals(localeCalType))
             setCalculationType(CalculationType.ISLAMIC_TBLA);
         else if(localeCalType.startsWith("islamic"))
-            setCalculationType(CalculationType.ISLAMIC);       // needs to be last so it's always the default if it's islamic-something-unhandled  
-        else 
+            setCalculationType(CalculationType.ISLAMIC);       // needs to be last so it's always the default if it's islamic-something-unhandled
+        else
             setCalculationType(CalculationType.ISLAMIC_CIVIL); // default for any non-islamic calendar locale
     }
 
-    
+
     /**
      * {@inheritDoc}
      * @stable ICU 3.8
      */
+    @Override
     public String getType() {
         if (cType == null) {
             // TODO: getType() is called during Islamic calendar
@@ -1005,20 +1018,19 @@ public class IslamicCalendar extends Calendar {
         return cType.bcpType();
     }
 
-    private void readObject(ObjectInputStream in) throws IOException,ClassNotFoundException 
-    {
-            in.defaultReadObject();
-            
-            if(cType != CalculationType.ISLAMIC_CIVIL)
-                return;     // we've serialized something new, nothing else to do
-            
-            // new calculation type is civil (default) but civil is false. This will only happen
-            // when deserializing a non-civil calender so need to adjust new CalculationType to match 
-            // serialized form
-            if(!civil)
-                cType = CalculationType.ISLAMIC;  
+    private void readObject(ObjectInputStream in) throws IOException,ClassNotFoundException {
+        in.defaultReadObject();
+
+        if (cType == null) {
+            // The serialized data was created by an ICU version before CalculationType
+            // was introduced.
+            cType = civil ? CalculationType.ISLAMIC_CIVIL : CalculationType.ISLAMIC;
+        } else {
+            // Make sure 'civil' is consistent with CalculationType
+            civil = (cType == CalculationType.ISLAMIC_CIVIL);
+        }
     }
-    
+
     /*
     private static CalendarFactory factory;
     public static CalendarFactory factory() {
diff --git a/app/src/main/java/com/ibm/icu/util/JapaneseCalendar.java b/icu4j/src/main/java/com/ibm/icu/util/JapaneseCalendar.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/util/JapaneseCalendar.java
rename to icu4j/src/main/java/com/ibm/icu/util/JapaneseCalendar.java
index a66ba0d..5463407 100644
--- a/app/src/main/java/com/ibm/icu/util/JapaneseCalendar.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/JapaneseCalendar.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2014, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/util/LocaleData.java b/icu4j/src/main/java/com/ibm/icu/util/LocaleData.java
similarity index 88%
rename from app/src/main/java/com/ibm/icu/util/LocaleData.java
rename to icu4j/src/main/java/com/ibm/icu/util/LocaleData.java
index daea1d6..be06c10 100644
--- a/app/src/main/java/com/ibm/icu/util/LocaleData.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/LocaleData.java
@@ -1,13 +1,16 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  **************************************************************************************
- * Copyright (C) 2009-2016, International Business Machines Corporation,              *
- * Google, Inc. and others. All Rights Reserved.                                      *
+ * Copyright (C) 2009-2016, International Business Machines Corporation,
+ * Google, Inc. and others. All Rights Reserved.
  **************************************************************************************
  */
 package com.ibm.icu.util;
 
 import java.util.MissingResourceException;
 
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.text.UnicodeSet;
 import com.ibm.icu.util.ULocale.Category;
@@ -31,7 +34,7 @@ public final class LocaleData {
 
     /**
      * EXType for {@link #getExemplarSet(int, int)}.
-     * Corresponds to the 'main' (aka 'standard') CLDR exemplars in 
+     * Corresponds to the 'main' (aka 'standard') CLDR exemplars in
      * <a href="http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements">
      *   http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements</a>.
      * @stable ICU 3.4
@@ -40,7 +43,7 @@ public final class LocaleData {
 
     /**
      * EXType for {@link #getExemplarSet(int, int)}.
-     * Corresponds to the 'auxiliary' CLDR exemplars in 
+     * Corresponds to the 'auxiliary' CLDR exemplars in
      * <a href="http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements">
      *   http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements</a>.
      * @stable ICU 3.4
@@ -49,7 +52,7 @@ public final class LocaleData {
 
     /**
      * EXType for {@link #getExemplarSet(int, int)}.
-     * Corresponds to the 'index' CLDR exemplars in 
+     * Corresponds to the 'index' CLDR exemplars in
      * <a href="http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements">
      *   http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements</a>.
      * @stable ICU 4.4
@@ -58,7 +61,7 @@ public final class LocaleData {
 
     /**
      * EXType for {@link #getExemplarSet(int, int)}.
-     * Corresponds to the 'currencySymbol' CLDR exemplars in 
+     * Corresponds to the 'currencySymbol' CLDR exemplars in
      * <a href="http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements">
      *   http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements</a>.
      * Note: This type is no longer supported.
@@ -68,7 +71,7 @@ public final class LocaleData {
     public static final int ES_CURRENCY = 3;
 
     /**
-     * Corresponds to the 'punctuation' CLDR exemplars in 
+     * Corresponds to the 'punctuation' CLDR exemplars in
      * <a href="http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements">
      *   http://www.unicode.org/reports/tr35/tr35-general.html#Character_Elements</a>.
      * EXType for {@link #getExemplarSet(int, int)}.
@@ -78,8 +81,9 @@ public final class LocaleData {
 
     /**
      * Count of EXTypes for {@link #getExemplarSet(int, int)}.
-     * @stable ICU 3.4
+     * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
      */
+    @Deprecated
     public static final int ES_COUNT = 5;
 
     /**
@@ -108,8 +112,9 @@ public final class LocaleData {
 
     /**
      * Count of delimiter types for {@link #getDelimiter(int)}.
-     * @stable ICU 3.4
+     * @deprecated ICU 58 The numeric value may change over time, see ICU ticket #12420.
      */
+    @Deprecated
     public static final int DELIMITER_COUNT = 4;
 
     // private constructor to prevent default construction
@@ -139,7 +144,7 @@ public final class LocaleData {
     }
 
     /**
-     * Returns the set of exemplar characters for a locale. 
+     * Returns the set of exemplar characters for a locale.
      * Equivalent to calling new LocaleData(locale).{@link #getExemplarSet(int, int)}.
      *
      * @param locale    Locale for which the exemplar character set
@@ -175,16 +180,16 @@ public final class LocaleData {
      *                  ES_STANDARD, ES_INDEX, ES_AUXILIARY, or ES_PUNCTUATION
      * @return          The set of exemplar characters for the given locale.
      *                  If there is nothing available for the locale,
-     *                  then null is returned if {@link #getNoSubstitute()} is true, otherwise the 
+     *                  then null is returned if {@link #getNoSubstitute()} is true, otherwise the
      *                  root value is returned (which may be UnicodeSet.EMPTY).
      * @exception       RuntimeException if the extype is invalid.
      * @stable ICU 3.4
      */
     public UnicodeSet getExemplarSet(int options, int extype) {
-        String [] exemplarSetTypes = { 
-                "ExemplarCharacters", 
+        String [] exemplarSetTypes = {
+                "ExemplarCharacters",
                 "AuxExemplarCharacters",
-                "ExemplarCharactersIndex", 
+                "ExemplarCharactersIndex",
                 "ExemplarCharactersCurrency",
                 "ExemplarCharactersPunctuation"
         };
@@ -198,7 +203,7 @@ public final class LocaleData {
             final String aKey = exemplarSetTypes[extype]; // will throw an out-of-bounds exception
             ICUResourceBundle stringBundle = (ICUResourceBundle) bundle.get(aKey);
 
-            if ( noSubstitute && (stringBundle.getLoadingStatus() == ICUResourceBundle.FROM_ROOT) ) {
+            if (noSubstitute && !bundle.isRoot() && stringBundle.isRoot()) {
                 return null;
             }
             String unicodeSetPattern = stringBundle.getString();
@@ -219,8 +224,8 @@ public final class LocaleData {
      */
     public static final LocaleData getInstance(ULocale locale) {
         LocaleData ld = new LocaleData();
-        ld.bundle = (ICUResourceBundle)UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, locale);
-        ld.langBundle = (ICUResourceBundle)UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_LANG_BASE_NAME, locale);
+        ld.bundle = (ICUResourceBundle)UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, locale);
+        ld.langBundle = (ICUResourceBundle)UResourceBundle.getBundleInstance(ICUData.ICU_LANG_BASE_NAME, locale);
         ld.noSubstitute = false;
         return ld;
     }
@@ -263,9 +268,9 @@ public final class LocaleData {
     }
 
     private static final String [] DELIMITER_TYPES = {
-        "quotationStart", 
-        "quotationEnd", 
-        "alternateQuotationStart", 
+        "quotationStart",
+        "quotationEnd",
+        "alternateQuotationStart",
         "alternateQuotationEnd"
     };
 
@@ -283,9 +288,9 @@ public final class LocaleData {
         // Only some of the quotation marks may be here. So we make sure that we do a multilevel fallback.
         ICUResourceBundle stringBundle = delimitersBundle.getWithFallback(DELIMITER_TYPES[type]);
 
-        if ( noSubstitute && (stringBundle.getLoadingStatus() == ICUResourceBundle.FROM_ROOT) )
+        if (noSubstitute && !bundle.isRoot() && stringBundle.isRoot()) {
             return null;
-
+        }
         return stringBundle.getString();
     }
 
@@ -298,7 +303,7 @@ public final class LocaleData {
         String region = ULocale.getRegionForSupplementalData(locale, true);
         try {
             UResourceBundle rb = UResourceBundle.getBundleInstance(
-                    ICUResourceBundle.ICU_BASE_NAME,
+                    ICUData.ICU_BASE_NAME,
                     "supplementalData",
                     ICUResourceBundle.ICU_DATA_CLASS_LOADER);
             UResourceBundle measurementData = rb.get("measurementData");
@@ -325,31 +330,24 @@ public final class LocaleData {
     public static final class MeasurementSystem{
         /**
          * Measurement system specified by Le Syst&#x00E8;me International d'Unit&#x00E9;s (SI)
-         * otherwise known as Metric system. 
+         * otherwise known as Metric system.
          * @stable ICU 2.8
          */
-        public static final MeasurementSystem SI = new MeasurementSystem(0);
+        public static final MeasurementSystem SI = new MeasurementSystem();
 
         /**
-         * Measurement system followed in the United States of America. 
+         * Measurement system followed in the United States of America.
          * @stable ICU 2.8
          */
-        public static final MeasurementSystem US = new MeasurementSystem(1);
+        public static final MeasurementSystem US = new MeasurementSystem();
 
         /**
          * Mix of metric and imperial units used in Great Britain.
          * @stable ICU 55
          */
-        public static final MeasurementSystem UK = new MeasurementSystem(2);
-
-        private int systemID;
-        private MeasurementSystem(int id){
-            systemID = id;
-        }
+        public static final MeasurementSystem UK = new MeasurementSystem();
 
-        private boolean equals(int id){
-            return systemID == id;
-        }
+        private MeasurementSystem() {}
     }
 
     /**
@@ -362,23 +360,19 @@ public final class LocaleData {
     public static final MeasurementSystem getMeasurementSystem(ULocale locale){
         UResourceBundle sysBundle = measurementTypeBundleForLocale(locale, MEASUREMENT_SYSTEM);
 
-        int system = sysBundle.getInt();
-        if(MeasurementSystem.US.equals(system)){
-            return MeasurementSystem.US;
-        }
-        if(MeasurementSystem.UK.equals(system)){
-            return MeasurementSystem.UK;
-        }
-        if(MeasurementSystem.SI.equals(system)){
-            return MeasurementSystem.SI;
+        switch (sysBundle.getInt()) {
+        case 0: return MeasurementSystem.SI;
+        case 1: return MeasurementSystem.US;
+        case 2: return MeasurementSystem.UK;
+        default:
+            // return null if the object is null or is not an instance
+            // of integer indicating an error
+            return null;
         }
-        // return null if the object is null or is not an instance
-        // of integer indicating an error
-        return null;
     }
 
     /**
-     * A class that represents the size of letter head 
+     * A class that represents the size of letter head
      * used in the country
      * @stable ICU 2.8
      */
@@ -390,9 +384,9 @@ public final class LocaleData {
             height = h;
             width = w;
         }
-        /** 
+        /**
          * Retruns the height of the paper
-         * @return the height 
+         * @return the height
          * @stable ICU 2.8
          */
         public int getHeight(){
@@ -409,9 +403,9 @@ public final class LocaleData {
     }
 
     /**
-     * Returns the size of paper used in the locale. The paper sizes returned are always in 
+     * Returns the size of paper used in the locale. The paper sizes returned are always in
      * <em>milli-meters</em>.
-     * @param locale The locale for which the measurement system to be retrieved. 
+     * @param locale The locale for which the measurement system to be retrieved.
      * @return The paper size used in the locale
      * @stable ICU 3.0
      */
@@ -425,7 +419,7 @@ public final class LocaleData {
      * Returns LocaleDisplayPattern for this locale, e.g., {0}({1})
      * @return locale display pattern as a String.
      * @stable ICU 4.2
-     */ 
+     */
     public String getLocaleDisplayPattern() {
         ICUResourceBundle locDispBundle = (ICUResourceBundle) langBundle.get(LOCALE_DISPLAY_PATTERN);
         String localeDisplayPattern = locDispBundle.getStringWithFallback(PATTERN);
@@ -436,7 +430,7 @@ public final class LocaleData {
      * Returns LocaleDisplaySeparator for this locale.
      * @return locale display separator as a char.
      * @stable ICU 4.2
-     */ 
+     */
     public String getLocaleSeparator() {
         String sub0 = "{0}";
         String sub1 = "{1}";
@@ -460,7 +454,7 @@ public final class LocaleData {
         // fetching this data should be idempotent.
         if(gCLDRVersion == null) {
             // from ZoneMeta.java
-            UResourceBundle supplementalDataBundle = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, "supplementalData", ICUResourceBundle.ICU_DATA_CLASS_LOADER);
+            UResourceBundle supplementalDataBundle = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME, "supplementalData", ICUResourceBundle.ICU_DATA_CLASS_LOADER);
             UResourceBundle cldrVersionBundle = supplementalDataBundle.get("cldrVersion");
             gCLDRVersion = VersionInfo.getInstance(cldrVersionBundle.getString());
         }
diff --git a/app/src/main/java/com/ibm/icu/util/LocaleMatcher.java b/icu4j/src/main/java/com/ibm/icu/util/LocaleMatcher.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/util/LocaleMatcher.java
rename to icu4j/src/main/java/com/ibm/icu/util/LocaleMatcher.java
index 62892ec..1a53cbb 100644
--- a/app/src/main/java/com/ibm/icu/util/LocaleMatcher.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/LocaleMatcher.java
@@ -1,7 +1,9 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ****************************************************************************************
- * Copyright (C) 2009-2016, Google, Inc.; International Business Machines Corporation   *
- * and others. All Rights Reserved.                                                     *
+ * Copyright (C) 2009-2016, Google, Inc.; International Business Machines Corporation
+ * and others. All Rights Reserved.
  ****************************************************************************************
  */
 package com.ibm.icu.util;
@@ -17,6 +19,7 @@ import java.util.Set;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.impl.Relation;
 import com.ibm.icu.impl.Row;
@@ -457,6 +460,12 @@ public class LocaleMatcher {
          */
         @Override
         public boolean equals(Object obj) {
+            if (obj == this) {
+                return true;
+            }
+            if (obj == null || !(obj instanceof LocalePatternMatcher)) {
+                return false;
+            }
             LocalePatternMatcher other = (LocalePatternMatcher) obj;
             return Utility.objectEquals(level, other.level)
                 && Utility.objectEquals(lang, other.lang)
@@ -662,21 +671,6 @@ public class LocaleMatcher {
             return 1.0 - diff;
         }
 
-
-        /**
-         * Add an exceptional distance between languages, typically because regional
-         * dialects were given their own language codes. At this point the code is
-         * symmetric. We don't bother producing an equivalence class because there are
-         * so few cases; this function depends on the other permutations being
-         * added specifically.
-         * @internal
-         * @deprecated This API is ICU internal only.
-         */
-        @SuppressWarnings("unused")
-        @Deprecated
-        private LanguageMatcherData addDistance(String desired, String supported, int percent) {
-            return addDistance(desired, supported, percent, false, null);
-        }
         /**
          * @internal
          * @deprecated This API is ICU internal only.
@@ -836,7 +830,7 @@ public class LocaleMatcher {
     @Deprecated
     public static ICUResourceBundle getICUSupplementalData() {
         ICUResourceBundle suppData = (ICUResourceBundle) UResourceBundle.getBundleInstance(
-            ICUResourceBundle.ICU_BASE_NAME,
+            ICUData.ICU_BASE_NAME,
             "supplementalData",
             ICUResourceBundle.ICU_DATA_CLASS_LOADER);
         return suppData;
diff --git a/app/src/main/java/com/ibm/icu/util/LocalePriorityList.java b/icu4j/src/main/java/com/ibm/icu/util/LocalePriorityList.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/util/LocalePriorityList.java
rename to icu4j/src/main/java/com/ibm/icu/util/LocalePriorityList.java
index ba4cb8b..b8a1a74 100644
--- a/app/src/main/java/com/ibm/icu/util/LocalePriorityList.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/LocalePriorityList.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2010-2016, Google, Inc.; International Business Machines      *
@@ -350,7 +352,8 @@ public class LocalePriorityList implements Iterable<ULocale> {
 
     private static Comparator<Double> myDescendingDouble = new Comparator<Double>() {
         public int compare(Double o1, Double o2) {
-            return -o1.compareTo(o2);
+            int result = o1.compareTo(o2);
+            return result > 0 ? -1 : result < 0 ? 1 : 0; // Reverse the order.
         }
     };
 }
diff --git a/app/src/main/java/com/ibm/icu/util/Measure.java b/icu4j/src/main/java/com/ibm/icu/util/Measure.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/util/Measure.java
rename to icu4j/src/main/java/com/ibm/icu/util/Measure.java
index a9937f2..f641fec 100644
--- a/app/src/main/java/com/ibm/icu/util/Measure.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/Measure.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 **********************************************************************
 * Copyright (c) 2004-2013, International Business Machines
@@ -29,7 +31,7 @@ package com.ibm.icu.util;
  * @stable ICU 3.0
  */
 public class Measure {
-    
+
     private final Number number;
     private final MeasureUnit unit;
 
@@ -46,12 +48,13 @@ public class Measure {
         this.number = number;
         this.unit = unit;
     }
-    
+
     /**
      * Returns true if the given object is equal to this object.
      * @return true if this object is equal to the given object
      * @stable ICU 3.0
      */
+    @Override
     public boolean equals(Object obj) {
         if (obj == this) {
             return true;
@@ -62,7 +65,7 @@ public class Measure {
         Measure m = (Measure) obj;
         return unit.equals(m.unit) && numbersEqual(number, m.number);
     }
-    
+
     /*
      * See if two numbers are identical or have the same double value.
      * @param a A number
@@ -85,6 +88,7 @@ public class Measure {
      * @return a 32-bit hash
      * @stable ICU 3.0
      */
+    @Override
     public int hashCode() {
         return 31 * Double.valueOf(number.doubleValue()).hashCode() + unit.hashCode();
     }
@@ -95,6 +99,7 @@ public class Measure {
      * code together with the numeric amount
      * @stable ICU 3.0
      */
+    @Override
     public String toString() {
         return number.toString() + ' ' + unit.toString();
     }
diff --git a/app/src/main/java/com/ibm/icu/util/MeasureUnit.java b/icu4j/src/main/java/com/ibm/icu/util/MeasureUnit.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/util/MeasureUnit.java
rename to icu4j/src/main/java/com/ibm/icu/util/MeasureUnit.java
index 4d69a63..ee87ee2 100644
--- a/app/src/main/java/com/ibm/icu/util/MeasureUnit.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/MeasureUnit.java
@@ -1,7 +1,9 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2004-2016, Google Inc, International Business Machines        *
- * Corporation and others. All Rights Reserved.                                *
+ * Copyright (C) 2004-2016, Google Inc, International Business Machines
+ * Corporation and others. All Rights Reserved.
  *******************************************************************************
  */
 package com.ibm.icu.util;
@@ -13,15 +15,15 @@ import java.io.ObjectOutput;
 import java.io.ObjectStreamException;
 import java.io.Serializable;
 import java.util.Collections;
-import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.HashSet;
 import java.util.Map;
-import java.util.MissingResourceException;
 import java.util.Set;
 
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.impl.Pair;
+import com.ibm.icu.impl.UResource;
 import com.ibm.icu.text.UnicodeSet;
 
 /**
@@ -36,14 +38,11 @@ import com.ibm.icu.text.UnicodeSet;
  */
 public class MeasureUnit implements Serializable {
     private static final long serialVersionUID = -1839973855554750484L;
-    
-    // Used to pre-fill the cache. These same constants appear in MeasureFormat too.
-    private static final String[] unitKeys = new String[]{"units", "unitsShort", "unitsNarrow"};
-    
+
     // Cache of MeasureUnits.
     // All access to the cache or cacheIsPopulated flag must be synchronized on class MeasureUnit,
     // i.e. from synchronized static methods. Beware of non-static methods.
-    private static final Map<String, Map<String,MeasureUnit>> cache 
+    private static final Map<String, Map<String,MeasureUnit>> cache
         = new HashMap<String, Map<String,MeasureUnit>>();
     private static boolean cacheIsPopulated = false;
 
@@ -53,14 +52,14 @@ public class MeasureUnit implements Serializable {
      */
     @Deprecated
     protected final String type;
-    
+
     /**
      * @internal
      * @deprecated This API is ICU internal only.
      */
     @Deprecated
     protected final String subType;
-    
+
     /**
      * @internal
      * @deprecated This API is ICU internal only.
@@ -70,16 +69,16 @@ public class MeasureUnit implements Serializable {
         this.type = type;
         this.subType = subType;
     }
-    
+
     /**
      * Get the type, such as "length"
-     * 
+     *
      * @stable ICU 53
      */
     public String getType() {
         return type;
     }
-    
+
 
     /**
      * Get the subType, such as “foot”.
@@ -89,22 +88,22 @@ public class MeasureUnit implements Serializable {
     public String getSubtype() {
         return subType;
     }
-    
-    
+
+
 
     /**
      * {@inheritDoc}
-     * 
+     *
      * @stable ICU 53
      */
     @Override
     public int hashCode() {
         return 31 * type.hashCode() + subType.hashCode();
     }
-    
+
     /**
      * {@inheritDoc}
-     * 
+     *
      * @stable ICU 53
      */
     @Override
@@ -118,24 +117,24 @@ public class MeasureUnit implements Serializable {
         MeasureUnit c = (MeasureUnit) rhs;
         return type.equals(c.type) && subType.equals(c.subType);
     }
-    
+
     /**
      * {@inheritDoc}
-     * 
+     *
      * @stable ICU 53
      */
     @Override
     public String toString() {
         return type + "-" + subType;
     }
-    
+
     /**
      * Get all of the available units' types. Returned set is unmodifiable.
-     * 
+     *
      * @stable ICU 53
      */
     public synchronized static Set<String> getAvailableTypes() {
-        populateCache();            
+        populateCache();
         return Collections.unmodifiableSet(cache.keySet());
     }
 
@@ -146,7 +145,7 @@ public class MeasureUnit implements Serializable {
      * @stable ICU 53
      */
     public synchronized static Set<MeasureUnit> getAvailable(String type) {
-        populateCache();            
+        populateCache();
         Map<String, MeasureUnit> units = cache.get(type);
         // Train users not to modify returned set from the start giving us more
         // flexibility for implementation.
@@ -201,7 +200,7 @@ public class MeasureUnit implements Serializable {
         }
         return MeasureUnit.addUnit(type, subType, factory);
     }
-    
+
     /**
      * For ICU use only.
      * @internal
@@ -230,87 +229,104 @@ public class MeasureUnit implements Serializable {
     }
 
     private static Factory UNIT_FACTORY = new Factory() {
+        @Override
         public MeasureUnit create(String type, String subType) {
             return new MeasureUnit(type, subType);
         }
     };
 
     static Factory CURRENCY_FACTORY = new Factory() {
+        @Override
         public MeasureUnit create(String unusedType, String subType) {
             return new Currency(subType);
         }
     };
-    
+
     static Factory TIMEUNIT_FACTORY = new Factory() {
+        @Override
         public MeasureUnit create(String type, String subType) {
            return new TimeUnit(type, subType);
         }
     };
 
+    /**
+     * Sink for enumerating the available measure units.
+     */
+    private static final class MeasureUnitSink extends UResource.Sink {
+        @Override
+        public void put(UResource.Key key, UResource.Value value, boolean noFallback) {
+            UResource.Table unitTypesTable = value.getTable();
+            for (int i2 = 0; unitTypesTable.getKeyAndValue(i2, key, value); ++i2) {
+                // Skip "compound" since it is treated differently from the other units
+                if (key.contentEquals("compound")) {
+                    continue;
+                }
+
+                String unitType = key.toString();
+                UResource.Table unitNamesTable = value.getTable();
+                for (int i3 = 0; unitNamesTable.getKeyAndValue(i3, key, value); ++i3) {
+                    String unitName = key.toString();
+                    internalGetInstance(unitType, unitName);
+                }
+            }
+        }
+    }
+
+    /**
+     * Sink for enumerating the currency numeric codes.
+     */
+    private static final class CurrencyNumericCodeSink extends UResource.Sink {
+        @Override
+        public void put(UResource.Key key, UResource.Value value, boolean noFallback) {
+            UResource.Table codesTable = value.getTable();
+            for (int i1 = 0; codesTable.getKeyAndValue(i1, key, value); ++i1) {
+                internalGetInstance("currency", key.toString());
+            }
+        }
+    }
+
     /**
      * Populate the MeasureUnit cache with all types from the data.
      * Population is done lazily, in response to MeasureUnit.getAvailable()
      * or other API that expects to see all of the MeasureUnits.
      *
      * <p>At static initialization time the MeasureUnits cache is populated
-     * with public static instances (G_FORCE, METER_PER_SECOND_SQUARED, etc.) only. 
-     * Adding of others is deferred until later to avoid circular static init 
+     * with public static instances (G_FORCE, METER_PER_SECOND_SQUARED, etc.) only.
+     * Adding of others is deferred until later to avoid circular static init
      * dependencies with classes Currency and TimeUnit.
      *
      * <p>Synchronization: this function must be called from static synchronized methods only.
-     * 
+     *
      * @internal
      */
     static private void populateCache() {
-        // load all of the units for English, since we know that that is a superset.
-        /**
-         *     units{
-         *            duration{
-         *                day{
-         *                    one{"{0} ден"}
-         *                    other{"{0} дена"}
-         *                }
-         */
         if (cacheIsPopulated) {
             return;
         }
-        ICUResourceBundle resource = (ICUResourceBundle)UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, "en");
-        for (String key : unitKeys) {
-            try {
-                ICUResourceBundle unitsTypeRes = resource.getWithFallback(key);
-                int size = unitsTypeRes.getSize();
-                for ( int index = 0; index < size; ++index) {
-                    UResourceBundle unitsRes = unitsTypeRes.get(index);
-                    String type = unitsRes.getKey();
-                    if (type.equals("compound")) {
-                        continue; // special type, does not have any unit plurals
-                    }
-                    int unitsSize = unitsRes.getSize();
-                    for ( int index2 = 0; index2 < unitsSize; ++index2) {
-                        ICUResourceBundle unitNameRes = (ICUResourceBundle)unitsRes.get(index2);
-                        if (unitNameRes.get("other") != null) {
-                            internalGetInstance(type, unitNameRes.getKey());
-                        }
-                    }
-                }
-            } catch ( MissingResourceException e ) {
-                continue;
-            }
-        }
-        // preallocate currencies
-        try {
-            UResourceBundle bundle = UResourceBundle.getBundleInstance(
-                    ICUResourceBundle.ICU_BASE_NAME,
-                    "currencyNumericCodes",
-                    ICUResourceBundle.ICU_DATA_CLASS_LOADER);
-            UResourceBundle codeMap = bundle.get("codeMap");
-            for (Enumeration<String> it = codeMap.getKeys(); it.hasMoreElements();) {
-                MeasureUnit.internalGetInstance("currency", it.nextElement());
-            }
-        } catch (MissingResourceException e) {
-            // fall through
-        }
         cacheIsPopulated = true;
+
+        /*  Schema:
+         *
+         *  units{
+         *    duration{
+         *      day{
+         *        one{"{0} ден"}
+         *        other{"{0} дена"}
+         *      }
+         */
+
+        // Load the unit types.  Use English, since we know that that is a superset.
+        ICUResourceBundle rb1 = (ICUResourceBundle) UResourceBundle.getBundleInstance(
+                ICUData.ICU_UNIT_BASE_NAME,
+                "en");
+        rb1.getAllItemsWithFallback("units", new MeasureUnitSink());
+
+        // Load the currencies
+        ICUResourceBundle rb2 = (ICUResourceBundle) UResourceBundle.getBundleInstance(
+                ICUData.ICU_BASE_NAME,
+                "currencyNumericCodes",
+                ICUResourceBundle.ICU_DATA_CLASS_LOADER);
+        rb2.getAllItemsWithFallback("codeMap", new CurrencyNumericCodeSink());
     }
 
     /**
@@ -324,7 +340,7 @@ public class MeasureUnit implements Serializable {
             cache.put(type, tmp = new HashMap<String, MeasureUnit>());
         } else {
             // "intern" the type by setting to first item's type.
-            type = tmp.entrySet().iterator().next().getValue().type; 
+            type = tmp.entrySet().iterator().next().getValue().type;
         }
         MeasureUnit unit = tmp.get(unitName);
         if (unit == null) {
@@ -337,7 +353,7 @@ public class MeasureUnit implements Serializable {
     /*
      * Useful constants. Not necessarily complete: see {@link #getAvailable()}.
      */
-    
+
 // All code between the "Start generated MeasureUnit constants" comment and
 // the "End generated MeasureUnit constants" comment is auto generated code
 // and must not be edited manually. For instructions on how to correctly
@@ -345,7 +361,7 @@ public class MeasureUnit implements Serializable {
 // http://site.icu-project.org/design/formatting/measureformat/updating-measure-unit
 //
     // Start generated MeasureUnit constants
-    
+
     /**
      * Constant for unit of acceleration: g-force
      * @stable ICU 53
@@ -384,8 +400,7 @@ public class MeasureUnit implements Serializable {
 
     /**
      * Constant for unit of angle: revolution
-     * @draft ICU 56
-     * @provisional This API might change or be removed in a future release.
+     * @stable ICU 56
      */
     public static final MeasureUnit REVOLUTION_ANGLE = MeasureUnit.internalGetInstance("angle", "revolution");
 
@@ -472,8 +487,7 @@ public class MeasureUnit implements Serializable {
 
     /**
      * Constant for unit of consumption: liter-per-100kilometers
-     * @draft ICU 56
-     * @provisional This API might change or be removed in a future release.
+     * @stable ICU 56
      */
     public static final MeasureUnit LITER_PER_100KILOMETERS = MeasureUnit.internalGetInstance("consumption", "liter-per-100kilometers");
 
@@ -496,6 +510,34 @@ public class MeasureUnit implements Serializable {
      */
     public static final MeasureUnit MILE_PER_GALLON_IMPERIAL = MeasureUnit.internalGetInstance("consumption", "mile-per-gallon-imperial");
 
+    /**
+     * Constant for unit of coordinate: east
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public static final MeasureUnit EAST = MeasureUnit.internalGetInstance("coordinate", "east");
+
+    /**
+     * Constant for unit of coordinate: north
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public static final MeasureUnit NORTH = MeasureUnit.internalGetInstance("coordinate", "north");
+
+    /**
+     * Constant for unit of coordinate: south
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public static final MeasureUnit SOUTH = MeasureUnit.internalGetInstance("coordinate", "south");
+
+    /**
+     * Constant for unit of coordinate: west
+     * @draft ICU 58
+     * @provisional This API might change or be removed in a future release.
+     */
+    public static final MeasureUnit WEST = MeasureUnit.internalGetInstance("coordinate", "west");
+
     /**
      * Constant for unit of digital: bit
      * @stable ICU 54
@@ -558,8 +600,7 @@ public class MeasureUnit implements Serializable {
 
     /**
      * Constant for unit of duration: century
-     * @draft ICU 56
-     * @provisional This API might change or be removed in a future release.
+     * @stable ICU 56
      */
     public static final MeasureUnit CENTURY = MeasureUnit.internalGetInstance("duration", "century");
 
@@ -781,8 +822,7 @@ public class MeasureUnit implements Serializable {
 
     /**
      * Constant for unit of length: mile-scandinavian
-     * @draft ICU 56
-     * @provisional This API might change or be removed in a future release.
+     * @stable ICU 56
      */
     public static final MeasureUnit MILE_SCANDINAVIAN = MeasureUnit.internalGetInstance("length", "mile-scandinavian");
 
@@ -968,8 +1008,7 @@ public class MeasureUnit implements Serializable {
 
     /**
      * Constant for unit of speed: knot
-     * @draft ICU 56
-     * @provisional This API might change or be removed in a future release.
+     * @stable ICU 56
      */
     public static final MeasureUnit KNOT = MeasureUnit.internalGetInstance("speed", "knot");
 
@@ -999,8 +1038,7 @@ public class MeasureUnit implements Serializable {
 
     /**
      * Constant for unit of temperature: generic
-     * @draft ICU 56
-     * @provisional This API might change or be removed in a future release.
+     * @stable ICU 56
      */
     public static final MeasureUnit GENERIC_TEMPERATURE = MeasureUnit.internalGetInstance("temperature", "generic");
 
@@ -1078,8 +1116,7 @@ public class MeasureUnit implements Serializable {
 
     /**
      * Constant for unit of volume: cup-metric
-     * @draft ICU 56
-     * @provisional This API might change or be removed in a future release.
+     * @stable ICU 56
      */
     public static final MeasureUnit CUP_METRIC = MeasureUnit.internalGetInstance("volume", "cup-metric");
 
@@ -1140,8 +1177,7 @@ public class MeasureUnit implements Serializable {
 
     /**
      * Constant for unit of volume: pint-metric
-     * @draft ICU 56
-     * @provisional This API might change or be removed in a future release.
+     * @stable ICU 56
      */
     public static final MeasureUnit PINT_METRIC = MeasureUnit.internalGetInstance("volume", "pint-metric");
 
@@ -1199,6 +1235,7 @@ public class MeasureUnit implements Serializable {
         public MeasureUnitProxy() {
         }
 
+        @Override
         public void writeExternal(ObjectOutput out) throws IOException {
             out.writeByte(0); // version
             out.writeUTF(type);
@@ -1206,6 +1243,7 @@ public class MeasureUnit implements Serializable {
             out.writeShort(0); // allow for more data.
         }
 
+        @Override
         public void readExternal(ObjectInput in) throws IOException, ClassNotFoundException {
             /* byte version = */ in.readByte(); // version
             type = in.readUTF();
diff --git a/app/src/main/java/com/ibm/icu/util/Output.java b/icu4j/src/main/java/com/ibm/icu/util/Output.java
similarity index 88%
rename from app/src/main/java/com/ibm/icu/util/Output.java
rename to icu4j/src/main/java/com/ibm/icu/util/Output.java
index 499e9ca..85a5cc4 100644
--- a/app/src/main/java/com/ibm/icu/util/Output.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/Output.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2011-2016, International Business Machines Corporation and    *
@@ -22,6 +24,7 @@ public class Output<T> {
      * {@inheritDoc}
      * @stable ICU 4.8
      */
+    @Override
     public String toString() {
         return value == null ? "null" : value.toString();
     }
@@ -31,7 +34,7 @@ public class Output<T> {
      * @stable ICU 4.8
      */
     public Output() {
-        
+
     }
 
     /**
diff --git a/app/src/main/java/com/ibm/icu/util/OutputInt.java b/icu4j/src/main/java/com/ibm/icu/util/OutputInt.java
similarity index 91%
rename from app/src/main/java/com/ibm/icu/util/OutputInt.java
rename to icu4j/src/main/java/com/ibm/icu/util/OutputInt.java
index adcd8d2..5abec5b 100644
--- a/app/src/main/java/com/ibm/icu/util/OutputInt.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/OutputInt.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2014, International Business Machines Corporation and
@@ -52,6 +54,7 @@ public class OutputInt {
      * @deprecated This API is ICU internal only.
      */
     @Deprecated
+    @Override
     public String toString() {
         return Integer.toString(value);
     }
diff --git a/app/src/main/java/com/ibm/icu/util/OverlayBundle.java b/icu4j/src/main/java/com/ibm/icu/util/OverlayBundle.java
similarity index 100%
rename from app/src/main/java/com/ibm/icu/util/OverlayBundle.java
rename to icu4j/src/main/java/com/ibm/icu/util/OverlayBundle.java
diff --git a/app/src/main/java/com/ibm/icu/util/PersianCalendar.java b/icu4j/src/main/java/com/ibm/icu/util/PersianCalendar.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/util/PersianCalendar.java
rename to icu4j/src/main/java/com/ibm/icu/util/PersianCalendar.java
index 54255bf..aa8cb83 100644
--- a/app/src/main/java/com/ibm/icu/util/PersianCalendar.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/PersianCalendar.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2014, International Business Machines Corporation and    *
@@ -420,7 +422,7 @@ public class PersianCalendar extends Calendar {
         long daysSinceEpoch = julianDay - PERSIAN_EPOCH;
         year = 1 + (int) floorDivide(33 * daysSinceEpoch + 3, 12053);
 
-        long farvardin1 = 365 * (year - 1) + floorDivide(8 * year + 21, 33);
+        long farvardin1 = 365L * (year - 1L) + floorDivide(8L * year + 21, 33L);
         dayOfYear = (int)(daysSinceEpoch - farvardin1); // 0-based
         if (dayOfYear < 216) { // Compute 0-based month
             month = dayOfYear / 31;
diff --git a/app/src/main/java/com/ibm/icu/util/RangeDateRule.java b/icu4j/src/main/java/com/ibm/icu/util/RangeDateRule.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/util/RangeDateRule.java
rename to icu4j/src/main/java/com/ibm/icu/util/RangeDateRule.java
index 910adef..cad5e4c 100644
--- a/app/src/main/java/com/ibm/icu/util/RangeDateRule.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/RangeDateRule.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/util/RangeValueIterator.java b/icu4j/src/main/java/com/ibm/icu/util/RangeValueIterator.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/util/RangeValueIterator.java
rename to icu4j/src/main/java/com/ibm/icu/util/RangeValueIterator.java
index 62e80d4..54e4853 100644
--- a/app/src/main/java/com/ibm/icu/util/RangeValueIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/RangeValueIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 1996-2016, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/util/Region.java b/icu4j/src/main/java/com/ibm/icu/util/Region.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/util/Region.java
rename to icu4j/src/main/java/com/ibm/icu/util/Region.java
index d5be972..16abca7 100644
--- a/app/src/main/java/com/ibm/icu/util/Region.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/Region.java
@@ -1,7 +1,9 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
- * Copyright (C) 2011-2015, International Business Machines Corporation        *
- * All Rights Reserved.                                                        *
+ * Copyright (C) 2011-2016, International Business Machines Corporation
+ * All Rights Reserved.
  *******************************************************************************
  */
 package com.ibm.icu.util;
@@ -15,6 +17,7 @@ import java.util.Map;
 import java.util.Set;
 import java.util.TreeSet;
 
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
 
 /**
@@ -165,11 +168,11 @@ public class Region implements Comparable<Region> {
         UResourceBundle territoryContainment = null;
         UResourceBundle groupingContainment = null;
 
-        UResourceBundle metadata = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME,"metadata",ICUResourceBundle.ICU_DATA_CLASS_LOADER);
+        UResourceBundle metadata = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME,"metadata",ICUResourceBundle.ICU_DATA_CLASS_LOADER);
         metadataAlias = metadata.get("alias");
         territoryAlias = metadataAlias.get("territory");
 
-        UResourceBundle supplementalData = UResourceBundle.getBundleInstance(ICUResourceBundle.ICU_BASE_NAME,"supplementalData", ICUResourceBundle.ICU_DATA_CLASS_LOADER);
+        UResourceBundle supplementalData = UResourceBundle.getBundleInstance(ICUData.ICU_BASE_NAME,"supplementalData", ICUResourceBundle.ICU_DATA_CLASS_LOADER);
         codeMappings = supplementalData.get("codeMappings");
         idValidity = supplementalData.get("idValidity");
         regionList = idValidity.get("region");
diff --git a/app/src/main/java/com/ibm/icu/util/RuleBasedTimeZone.java b/icu4j/src/main/java/com/ibm/icu/util/RuleBasedTimeZone.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/util/RuleBasedTimeZone.java
rename to icu4j/src/main/java/com/ibm/icu/util/RuleBasedTimeZone.java
index d79b671..e64c3a7 100644
--- a/app/src/main/java/com/ibm/icu/util/RuleBasedTimeZone.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/RuleBasedTimeZone.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2007-2014, International Business Machines Corporation and    *
@@ -347,7 +349,7 @@ public class RuleBasedTimeZone extends BasicTimeZone {
             return null;
         }
         boolean isFinal = false;
-        TimeZoneTransition result = null;
+        TimeZoneTransition result;
         TimeZoneTransition tzt = historicTransitions.get(0);
         long tt = tzt.getTime();
         if (tt > base || (inclusive && tt == base)) {
@@ -392,18 +394,16 @@ public class RuleBasedTimeZone extends BasicTimeZone {
                 result = prev;
             }
         }
-        if (result != null) {
-            // For now, this implementation ignore transitions with only zone name changes.
-            TimeZoneRule from = result.getFrom();
-            TimeZoneRule to = result.getTo();
-            if (from.getRawOffset() == to.getRawOffset()
-                    && from.getDSTSavings() == to.getDSTSavings()) {
-                // No offset changes.  Try next one if not final
-                if (isFinal) {
-                    return null;
-                } else {
-                    result = getNextTransition(result.getTime(), false /* always exclusive */);
-                }
+        // For now, this implementation ignore transitions with only zone name changes.
+        TimeZoneRule from = result.getFrom();
+        TimeZoneRule to = result.getTo();
+        if (from.getRawOffset() == to.getRawOffset()
+                && from.getDSTSavings() == to.getDSTSavings()) {
+            // No offset changes.  Try next one if not final
+            if (isFinal) {
+                return null;
+            } else {
+                result = getNextTransition(result.getTime(), false /* always exclusive */);
             }
         }
         return result;
@@ -420,7 +420,7 @@ public class RuleBasedTimeZone extends BasicTimeZone {
         if (historicTransitions == null) {
             return null;
         }
-        TimeZoneTransition result = null;
+        TimeZoneTransition result;
         TimeZoneTransition tzt = historicTransitions.get(0);
         long tt = tzt.getTime();
         if (inclusive && tt == base) {
@@ -462,15 +462,13 @@ public class RuleBasedTimeZone extends BasicTimeZone {
                 result = tzt;                
             }
         }
-        if (result != null) {
-            // For now, this implementation ignore transitions with only zone name changes.
-            TimeZoneRule from = result.getFrom();
-            TimeZoneRule to = result.getTo();
-            if (from.getRawOffset() == to.getRawOffset()
-                    && from.getDSTSavings() == to.getDSTSavings()) {
-                // No offset changes.  Try previous one
-                result = getPreviousTransition(result.getTime(), false /* always exclusive */);
-            }
+        // For now, this implementation ignore transitions with only zone name changes.
+        TimeZoneRule from = result.getFrom();
+        TimeZoneRule to = result.getTo();
+        if (from.getRawOffset() == to.getRawOffset()
+                && from.getDSTSavings() == to.getDSTSavings()) {
+            // No offset changes.  Try previous one
+            result = getPreviousTransition(result.getTime(), false /* always exclusive */);
         }
         return result;
     }
diff --git a/app/src/main/java/com/ibm/icu/util/STZInfo.java b/icu4j/src/main/java/com/ibm/icu/util/STZInfo.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/util/STZInfo.java
rename to icu4j/src/main/java/com/ibm/icu/util/STZInfo.java
index 9f02a3e..736e05a 100644
--- a/app/src/main/java/com/ibm/icu/util/STZInfo.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/STZInfo.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *   Copyright (C) 2005-2010, International Business Machines
  *   Corporation and others.  All Rights Reserved.
diff --git a/app/src/main/java/com/ibm/icu/util/SimpleDateRule.java b/icu4j/src/main/java/com/ibm/icu/util/SimpleDateRule.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/util/SimpleDateRule.java
rename to icu4j/src/main/java/com/ibm/icu/util/SimpleDateRule.java
index 4503b64..50106c4 100644
--- a/app/src/main/java/com/ibm/icu/util/SimpleDateRule.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/SimpleDateRule.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
@@ -219,9 +221,7 @@ public class SimpleDateRule implements DateRule
 //        calendar = c;
 //    }
 
-    private static GregorianCalendar gCalendar = new GregorianCalendar();
-
-    private Calendar calendar = gCalendar;
+    private Calendar calendar = new GregorianCalendar();
 
     private int     month;
     private int     dayOfMonth;
diff --git a/app/src/main/java/com/ibm/icu/util/SimpleHoliday.java b/icu4j/src/main/java/com/ibm/icu/util/SimpleHoliday.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/util/SimpleHoliday.java
rename to icu4j/src/main/java/com/ibm/icu/util/SimpleHoliday.java
index c464629..58a430d 100644
--- a/app/src/main/java/com/ibm/icu/util/SimpleHoliday.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/SimpleHoliday.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/util/SimpleTimeZone.java b/icu4j/src/main/java/com/ibm/icu/util/SimpleTimeZone.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/util/SimpleTimeZone.java
rename to icu4j/src/main/java/com/ibm/icu/util/SimpleTimeZone.java
index d736849..f91d80f 100644
--- a/app/src/main/java/com/ibm/icu/util/SimpleTimeZone.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/SimpleTimeZone.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
  /*
 *   Copyright (C) 1996-2016, International Business Machines
 *   Corporation and others.  All Rights Reserved.
@@ -789,6 +791,7 @@ public class SimpleTimeZone extends BasicTimeZone {
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Override
     @Deprecated
     public void getOffsetFromLocal(long date,
             int nonExistingTimeOpt, int duplicatedTimeOpt, int[] offsets) {
@@ -962,6 +965,7 @@ public class SimpleTimeZone extends BasicTimeZone {
      * {@inheritDoc}
      * @stable ICU 49
      */
+    @Override
     public boolean observesDaylightTime() {
         return useDaylight;
     }
@@ -1416,6 +1420,7 @@ public class SimpleTimeZone extends BasicTimeZone {
      * {@inheritDoc}
      * @stable ICU 49
      */
+    @Override
     public boolean isFrozen() {
         return isFrozen;
     }
@@ -1424,6 +1429,7 @@ public class SimpleTimeZone extends BasicTimeZone {
      * {@inheritDoc}
      * @stable ICU 49
      */
+    @Override
     public TimeZone freeze() {
         isFrozen = true;
         return this;
@@ -1433,6 +1439,7 @@ public class SimpleTimeZone extends BasicTimeZone {
      * {@inheritDoc}
      * @stable ICU 49
      */
+    @Override
     public TimeZone cloneAsThawed() {
         SimpleTimeZone tz = (SimpleTimeZone)super.cloneAsThawed();
         tz.isFrozen = false;
diff --git a/app/src/main/java/com/ibm/icu/util/StringTokenizer.java b/icu4j/src/main/java/com/ibm/icu/util/StringTokenizer.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/util/StringTokenizer.java
rename to icu4j/src/main/java/com/ibm/icu/util/StringTokenizer.java
index 9db95e7..fb75977 100644
--- a/app/src/main/java/com/ibm/icu/util/StringTokenizer.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/StringTokenizer.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /**
 *******************************************************************************
 * Copyright (C) 1996-2016, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/util/StringTrieBuilder.java b/icu4j/src/main/java/com/ibm/icu/util/StringTrieBuilder.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/util/StringTrieBuilder.java
rename to icu4j/src/main/java/com/ibm/icu/util/StringTrieBuilder.java
index 09b67fc..df3d74a 100644
--- a/app/src/main/java/com/ibm/icu/util/StringTrieBuilder.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/StringTrieBuilder.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 *******************************************************************************
 *   Copyright (C) 2011-2014, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/util/TaiwanCalendar.java b/icu4j/src/main/java/com/ibm/icu/util/TaiwanCalendar.java
similarity index 98%
rename from app/src/main/java/com/ibm/icu/util/TaiwanCalendar.java
rename to icu4j/src/main/java/com/ibm/icu/util/TaiwanCalendar.java
index 17ac2a1..30ec347 100644
--- a/app/src/main/java/com/ibm/icu/util/TaiwanCalendar.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/TaiwanCalendar.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2010, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/util/TimeArrayTimeZoneRule.java b/icu4j/src/main/java/com/ibm/icu/util/TimeArrayTimeZoneRule.java
similarity index 95%
rename from app/src/main/java/com/ibm/icu/util/TimeArrayTimeZoneRule.java
rename to icu4j/src/main/java/com/ibm/icu/util/TimeArrayTimeZoneRule.java
index b7e8073..9785c7a 100644
--- a/app/src/main/java/com/ibm/icu/util/TimeArrayTimeZoneRule.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/TimeArrayTimeZoneRule.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2007-2010, International Business Machines Corporation and    *
@@ -11,7 +13,7 @@ import java.util.Date;
 /**
  * <code>TimeArrayTimeZoneRule</code> represents a time zone rule whose start times are
  * defined by an array of milliseconds since the standard base time.
- * 
+ *
  * @stable ICU 3.8
  */
 public class TimeArrayTimeZoneRule extends TimeZoneRule {
@@ -25,7 +27,7 @@ public class TimeArrayTimeZoneRule extends TimeZoneRule {
      * Constructs a <code>TimeArrayTimeZoneRule</code> with the name, the GMT offset of its
      * standard time, the amount of daylight saving offset adjustment and
      * the array of times when this rule takes effect.
-     * 
+     *
      * @param name          The time zone name.
      * @param rawOffset     The UTC offset of its standard time in milliseconds.
      * @param dstSavings    The amount of daylight saving offset adjustment in
@@ -36,7 +38,7 @@ public class TimeArrayTimeZoneRule extends TimeZoneRule {
      * @param timeType      The time type of the start times, which is one of
      *                      <code>DataTimeRule.WALL_TIME</code>, <code>STANDARD_TIME</code>
      *                      and <code>UTC_TIME</code>.
-     * 
+     *
      * @stable ICU 3.8
      */
     public TimeArrayTimeZoneRule(String name, int rawOffset, int dstSavings, long[] startTimes, int timeType) {
@@ -52,7 +54,7 @@ public class TimeArrayTimeZoneRule extends TimeZoneRule {
 
     /**
      * Gets the array of start times used by this rule.
-     * 
+     *
      * @return  An array of the start times in milliseconds since the base time
      *          (January 1, 1970, 00:00:00 GMT).
      * @stable ICU 3.8
@@ -65,7 +67,7 @@ public class TimeArrayTimeZoneRule extends TimeZoneRule {
      * Gets the time type of the start times used by this rule.  The return value
      * is either <code>DateTimeRule.WALL_TIME</code> or <code>DateTimeRule.STANDARD_TIME</code>
      * or <code>DateTimeRule.UTC_TIME</code>.
-     * 
+     *
      * @return The time type used of the start times used by this rule.
      * @stable ICU 3.8
      */
@@ -77,6 +79,7 @@ public class TimeArrayTimeZoneRule extends TimeZoneRule {
      * {@inheritDoc}
      * @stable ICU 3.8
      */
+    @Override
     public Date getFirstStart(int prevRawOffset, int prevDSTSavings) {
         return new Date(getUTC(startTimes[0], prevRawOffset, prevDSTSavings));
     }
@@ -85,6 +88,7 @@ public class TimeArrayTimeZoneRule extends TimeZoneRule {
      * {@inheritDoc}
      * @stable ICU 3.8
      */
+    @Override
     public Date getFinalStart(int prevRawOffset, int prevDSTSavings) {
         return new Date(getUTC(startTimes[startTimes.length - 1], prevRawOffset, prevDSTSavings));
     }
@@ -93,6 +97,7 @@ public class TimeArrayTimeZoneRule extends TimeZoneRule {
      * {@inheritDoc}
      * @stable ICU 3.8
      */
+    @Override
     public Date getNextStart(long base, int prevOffset, int prevDSTSavings, boolean inclusive) {
         int i = startTimes.length - 1;
         for (; i >= 0; i--) {
@@ -111,6 +116,7 @@ public class TimeArrayTimeZoneRule extends TimeZoneRule {
      * {@inheritDoc}
      * @stable ICU 3.8
      */
+    @Override
     public Date getPreviousStart(long base, int prevOffset, int prevDSTSavings, boolean inclusive) {
         int i = startTimes.length - 1;
         for (; i >= 0; i--) {
@@ -126,6 +132,7 @@ public class TimeArrayTimeZoneRule extends TimeZoneRule {
      * {@inheritDoc}
      * @stable ICU 3.8
      */
+    @Override
     public boolean isEquivalentTo(TimeZoneRule other) {
         if (!(other instanceof TimeArrayTimeZoneRule)) {
             return false;
@@ -142,6 +149,7 @@ public class TimeArrayTimeZoneRule extends TimeZoneRule {
      * Note: This method in <code>TimeArrayTimeZoneRule</code> always returns true.
      * @stable ICU 3.8
      */
+    @Override
     public boolean isTransitionRule() {
         return true;
     }
@@ -161,9 +169,10 @@ public class TimeArrayTimeZoneRule extends TimeZoneRule {
      * Returns a <code>String</code> representation of this <code>TimeArrayTimeZoneRule</code> object.
      * This method is used for debugging purpose only.  The string representation can be changed
      * in future version of ICU without any notice.
-     * 
+     *
      * @stable ICU 3.8
      */
+    @Override
     public String toString() {
         StringBuilder buf = new StringBuilder();
         buf.append(super.toString());
diff --git a/app/src/main/java/com/ibm/icu/util/TimeUnit.java b/icu4j/src/main/java/com/ibm/icu/util/TimeUnit.java
similarity index 93%
rename from app/src/main/java/com/ibm/icu/util/TimeUnit.java
rename to icu4j/src/main/java/com/ibm/icu/util/TimeUnit.java
index 39d14ce..698d704 100644
--- a/app/src/main/java/com/ibm/icu/util/TimeUnit.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/TimeUnit.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  **************************************************************************
  * Copyright (C) 2008-2014, Google, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/util/TimeUnitAmount.java b/icu4j/src/main/java/com/ibm/icu/util/TimeUnitAmount.java
similarity index 89%
rename from app/src/main/java/com/ibm/icu/util/TimeUnitAmount.java
rename to icu4j/src/main/java/com/ibm/icu/util/TimeUnitAmount.java
index 00eaf7c..5c16cd3 100644
--- a/app/src/main/java/com/ibm/icu/util/TimeUnitAmount.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/TimeUnitAmount.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  **************************************************************************
  * Copyright (C) 2008-2009, Google, International Business Machines
diff --git a/app/src/main/java/com/ibm/icu/util/TimeZone.java b/icu4j/src/main/java/com/ibm/icu/util/TimeZone.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/util/TimeZone.java
rename to icu4j/src/main/java/com/ibm/icu/util/TimeZone.java
index 53b0e88..02c05a0 100644
--- a/app/src/main/java/com/ibm/icu/util/TimeZone.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/TimeZone.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  * @(#)TimeZone.java    1.51 00/01/19
  *
@@ -16,6 +18,7 @@ import java.util.logging.Logger;
 
 import com.ibm.icu.impl.Grego;
 import com.ibm.icu.impl.ICUConfig;
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.impl.JavaTimeZone;
 import com.ibm.icu.impl.TimeZoneAdapter;
@@ -68,7 +71,7 @@ import com.ibm.icu.util.ULocale.Category;
  * offset from GMT(=UTC) and does not observe daylight saving
  * time. For example, you might specify GMT+14:00 as a custom
  * time zone ID to create a TimeZone representing 14 hours ahead
- * of GMT (with no daylight saving time). In addition, 
+ * of GMT (with no daylight saving time). In addition,
  * <code>getCanonicalID</code> can also be used to
  * normalize a custom time zone ID.
  *
@@ -225,7 +228,7 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
     /**
      * {@icu} The time zone ID reserved for unknown time zone.
      * @see #getTimeZone(String)
-     * 
+     *
      * @stable ICU 4.8
      */
     public static final String UNKNOWN_ZONE_ID = "Etc/Unknown";
@@ -243,7 +246,7 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
      *
      * @see #UNKNOWN_ZONE_ID
      * @see #getTimeZone(String)
-     * 
+     *
      * @stable ICU 49
      */
     public static final TimeZone UNKNOWN_ZONE = new ConstantZone(0, UNKNOWN_ZONE_ID).freeze();
@@ -521,7 +524,7 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
         if (style < SHORT || style > GENERIC_LOCATION) {
             throw new IllegalArgumentException("Illegal style: " + style);
         }
-        
+
         return _getDisplayName(style, daylight, locale);
     }
 
@@ -667,7 +670,7 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
      * the implementation does not take past daylight saving time into account, so
      * that this method may return <code>false</code> even when {@link #useDaylightTime()} returns
      * <code>true</code>.
-     * 
+     *
      * @return <code>true</code> if this time zone is in daylight saving time or will observe
      * daylight saving time at any future time.
      * @see #useDaylightTime
@@ -742,7 +745,7 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
     /**
      * Gets the <code>TimeZone</code> for the given ID and the timezone type.
      * @param id time zone ID
-     * @param type time zone implementation type, TIMEZONE_JDK or TIMEZONE_ICU 
+     * @param type time zone implementation type, TIMEZONE_JDK or TIMEZONE_ICU
      * @param frozen specify if the returned object can be frozen
      * @return the specified <code>TimeZone</code> or UNKNOWN_ZONE if the given ID
      * cannot be understood.
@@ -753,7 +756,7 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
             result = JavaTimeZone.createTimeZone(id);
             if (result != null) {
                 return frozen ? result.freeze() : result;
-            } 
+            }
             result = getFrozenICUTimeZone(id, false);
         } else {
             result = getFrozenICUTimeZone(id, true);
@@ -764,7 +767,7 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
         }
         return frozen ? result : result.cloneAsThawed();
     }
-    
+
     /**
      * Returns a frozen ICU type TimeZone object given a time zone ID.
      * @param id the time zone ID
@@ -806,20 +809,20 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
         return TZ_IMPL;
     }
 
-    /** 
-     * {@icu} Returns a set of time zone ID strings with the given filter conditions. 
+    /**
+     * {@icu} Returns a set of time zone ID strings with the given filter conditions.
      * <p><b>Note:</b>A <code>Set</code> returned by this method is
      * immutable.
      * @param zoneType      The system time zone type.
-     * @param region        The ISO 3166 two-letter country code or UN M.49 three-digit area code. 
-     *                      When null, no filtering done by region. 
-     * @param rawOffset     An offset from GMT in milliseconds, ignoring the effect of daylight savings 
-     *                      time, if any. When null, no filtering done by zone offset. 
+     * @param region        The ISO 3166 two-letter country code or UN M.49 three-digit area code.
+     *                      When null, no filtering done by region.
+     * @param rawOffset     An offset from GMT in milliseconds, ignoring the effect of daylight savings
+     *                      time, if any. When null, no filtering done by zone offset.
      * @return an immutable set of system time zone IDs.
      * @see SystemTimeZoneType
-     * 
+     *
      * @stable ICU 4.8
-     */ 
+     */
     public static Set<String> getAvailableIDs(SystemTimeZoneType zoneType,
             String region, Integer rawOffset) {
         return ZoneMeta.getAvailableIDs(zoneType, region, rawOffset);
@@ -834,7 +837,7 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
      * @return an array of IDs for system TimeZones with the given
      * raw offset.  If there are none, return a zero-length array.
      * @see #getAvailableIDs(SystemTimeZoneType, String, Integer)
-     * 
+     *
      * @stable ICU 2.0
      */
     public static String[] getAvailableIDs(int rawOffset) {
@@ -852,7 +855,7 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
      * @return an array of IDs for system TimeZones in the given
      * country.  If there are none, return a zero-length array.
      * @see #getAvailableIDs(SystemTimeZoneType, String, Integer)
-     * 
+     *
      * @stable ICU 2.0
      */
     public static String[] getAvailableIDs(String country) {
@@ -867,7 +870,7 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
      * object.
      * @return an array of all system TimeZone IDs
      * @see #getAvailableIDs(SystemTimeZoneType, String, Integer)
-     * 
+     *
      * @stable ICU 2.0
      */
     public static String[] getAvailableIDs() {
@@ -1009,6 +1012,7 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
      * Overrides clone.
      * @stable ICU 2.0
      */
+    @Override
     public Object clone() {
         if (isFrozen()) {
             return this;
@@ -1020,6 +1024,7 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
      * Overrides equals.
      * @stable ICU 3.6
      */
+    @Override
     public boolean equals(Object obj){
         if (this == obj) return true;
         if (obj == null || getClass() != obj.getClass()) return false;
@@ -1030,6 +1035,7 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
      * Overrides hashCode.
      * @stable ICU 3.6
      */
+    @Override
     public int hashCode(){
         return ID.hashCode();
     }
@@ -1097,21 +1103,21 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
         return canonicalID;
     }
 
-    /** 
-     * {@icu} Returns the region code associated with the given 
-     * system time zone ID. The region code is either ISO 3166 
-     * 2-letter country code or UN M.49 3-digit area code. 
-     * When the time zone is not associated with a specific location, 
-     * for example - "Etc/UTC", "EST5EDT", then this method returns 
-     * "001" (UN M.49 area code for World). 
-     * @param id the system time zone ID. 
-     * @return the region code associated with the given 
-     * system time zone ID. 
-     * @throws IllegalArgumentException if <code>id</code> is not a known system ID. 
-     * @see #getAvailableIDs(String) 
-     * 
+    /**
+     * {@icu} Returns the region code associated with the given
+     * system time zone ID. The region code is either ISO 3166
+     * 2-letter country code or UN M.49 3-digit area code.
+     * When the time zone is not associated with a specific location,
+     * for example - "Etc/UTC", "EST5EDT", then this method returns
+     * "001" (UN M.49 area code for World).
+     * @param id the system time zone ID.
+     * @return the region code associated with the given
+     * system time zone ID.
+     * @throws IllegalArgumentException if <code>id</code> is not a known system ID.
+     * @see #getAvailableIDs(String)
+     *
      * @stable ICU 4.8
-     */ 
+     */
     public static String getRegion(String id) {
         String region = null;
         // "Etc/Unknown" is not a system time zone ID,
@@ -1129,21 +1135,21 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
     /**
      * {@icu} Converts a system time zone ID to an equivalent Windows time zone ID. For example,
      * Windows time zone ID "Pacific Standard Time" is returned for input "America/Los_Angeles".
-     * 
+     *
      * <p>There are system time zones that cannot be mapped to Windows zones. When the input
      * system time zone ID is unknown or unmappable to a Windows time zone, then this
      * method returns <code>null</code>.
-     * 
+     *
      * <p>This implementation utilizes <a href="http://unicode.org/cldr/charts/supplemental/zone_tzid.html">
      * Zone-Tzid mapping data</a>. The mapping data is updated time to time. To get the latest changes,
      * please read the ICU user guide section <a href="http://userguide.icu-project.org/datetime/timezone#TOC-Updating-the-Time-Zone-Data">
      * Updating the Time Zone Data</a>.
-     * 
+     *
      * @param id A system time zone ID
      * @return A Windows time zone ID mapped from the input system time zone ID,
      * or <code>null</code> when the input ID is unknown or unmappable.
      * @see #getIDForWindowsID(String, String)
-     * 
+     *
      * @stable ICU 52
      */
     public static String getWindowsID(String id) {
@@ -1152,11 +1158,11 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
         id = getCanonicalID(id, isSystemID);
         if (!isSystemID[0]) {
             // mapping data is only applicable to tz database IDs
-            return null; 
+            return null;
         }
 
         UResourceBundle top = UResourceBundle.getBundleInstance(
-                ICUResourceBundle.ICU_BASE_NAME, "windowsZones", ICUResourceBundle.ICU_DATA_CLASS_LOADER);
+                ICUData.ICU_BASE_NAME, "windowsZones", ICUResourceBundle.ICU_DATA_CLASS_LOADER);
         UResourceBundle mapTimezones = top.get("mapTimezones");
 
         UResourceBundleIterator resitr = mapTimezones.getIterator();
@@ -1185,11 +1191,11 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
 
     /**
      * {@icu} Converts a Windows time zone ID to an equivalent system time zone ID
-     * for a region. For example, system time zone ID "America/Los_Angeles" is returned 
+     * for a region. For example, system time zone ID "America/Los_Angeles" is returned
      * for input Windows ID "Pacific Standard Time" and region "US" (or <code>null</code>),
      * "America/Vancouver" is returned for the same Windows ID "Pacific Standard Time" and
      * region "CA".
-     * 
+     *
      * <p>Not all Windows time zones can be mapped to system time zones. When the input
      * Windows time zone ID is unknown or unmappable to a system time zone, then this
      * method returns <code>null</code>.
@@ -1204,14 +1210,14 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
      * @return A system time zone ID mapped from the input Windows time zone ID,
      * or <code>null</code> when the input ID is unknown or unmappable.
      * @see #getWindowsID(String)
-     * 
+     *
      * @stable ICU 52
      */
     public static String getIDForWindowsID(String winid, String region) {
         String id = null;
 
         UResourceBundle top = UResourceBundle.getBundleInstance(
-                ICUResourceBundle.ICU_BASE_NAME, "windowsZones", ICUResourceBundle.ICU_DATA_CLASS_LOADER);
+                ICUData.ICU_BASE_NAME, "windowsZones", ICUResourceBundle.ICU_DATA_CLASS_LOADER);
         UResourceBundle mapTimezones = top.get("mapTimezones");
 
         try {
@@ -1246,6 +1252,7 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
      * {@inheritDoc}
      * @stable ICU 49
      */
+    @Override
     public boolean isFrozen() {
         return false;
     }
@@ -1254,6 +1261,7 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
      * {@inheritDoc}
      * @stable ICU 49
      */
+    @Override
     public TimeZone freeze() {
         throw new UnsupportedOperationException("Needs to be implemented by the subclass.");
     }
@@ -1262,6 +1270,7 @@ abstract public class TimeZone implements Serializable, Cloneable, Freezable<Tim
      * {@inheritDoc}
      * @stable ICU 49
      */
+    @Override
     public TimeZone cloneAsThawed() {
         try {
             TimeZone other = (TimeZone) super.clone();
diff --git a/app/src/main/java/com/ibm/icu/util/TimeZoneRule.java b/icu4j/src/main/java/com/ibm/icu/util/TimeZoneRule.java
similarity index 92%
rename from app/src/main/java/com/ibm/icu/util/TimeZoneRule.java
rename to icu4j/src/main/java/com/ibm/icu/util/TimeZoneRule.java
index 14f4520..379d697 100644
--- a/app/src/main/java/com/ibm/icu/util/TimeZoneRule.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/TimeZoneRule.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2007-2016, International Business Machines Corporation and    *
@@ -13,10 +15,10 @@ import java.util.Date;
  * <code>TimeZoneRule</code> is an abstract class representing a rule for time zone.
  * <code>TimeZoneRule</code> has a set of time zone attributes, such as zone name,
  * raw offset (UTC offset for standard time) and daylight saving time offset.
- * 
+ *
  * @see com.ibm.icu.util.TimeZoneTransition
  * @see com.ibm.icu.util.RuleBasedTimeZone
- * 
+ *
  * @stable ICU 3.8
  */
 public abstract class TimeZoneRule implements Serializable {
@@ -30,12 +32,12 @@ public abstract class TimeZoneRule implements Serializable {
     /**
      * Constructs a <code>TimeZoneRule</code> with the name, the GMT offset of its
      * standard time and the amount of daylight saving offset adjustment.
-     * 
+     *
      * @param name          The time zone name.
      * @param rawOffset     The UTC offset of its standard time in milliseconds.
      * @param dstSavings    The amount of daylight saving offset adjustment in milliseconds.
      *                      If this is a rule for standard time, the value of this argument is 0.
-     * 
+     *
      * @stable ICU 3.8
      */
     public TimeZoneRule(String name, int rawOffset, int dstSavings) {
@@ -46,9 +48,9 @@ public abstract class TimeZoneRule implements Serializable {
 
     /**
      * Gets the name of this time zone.
-     * 
+     *
      * @return The name of this time zone.
-     * 
+     *
      * @stable ICU 3.8
      */
     public String getName() {
@@ -57,9 +59,9 @@ public abstract class TimeZoneRule implements Serializable {
 
     /**
      * Gets the standard time offset.
-     * 
+     *
      * @return The standard time offset from UTC in milliseconds.
-     * 
+     *
      * @stable ICU 3.8
      */
     public int getRawOffset() {
@@ -68,10 +70,10 @@ public abstract class TimeZoneRule implements Serializable {
 
     /**
      * Gets the amount of daylight saving delta time from the standard time.
-     * 
+     *
      * @return  The amount of daylight saving offset used by this rule
      *          in milliseconds.
-     * 
+     *
      * @stable ICU 3.8
      */
     public int getDSTSavings() {
@@ -85,7 +87,7 @@ public abstract class TimeZoneRule implements Serializable {
      *
      * @param other The <code>TimeZoneRule</code> object to be compared with.
      * @return true if the other <code>TimeZoneRule</code> is the same as this one.
-     * 
+     *
      * @stable ICU 3.8
      */
     public boolean isEquivalentTo(TimeZoneRule other) {
@@ -94,76 +96,76 @@ public abstract class TimeZoneRule implements Serializable {
         }
         return false;
     }
- 
+
     /**
      * Gets the very first time when this rule takes effect.
-     * 
+     *
      * @param prevRawOffset     The standard time offset from UTC before this rule
      *                          takes effect in milliseconds.
      * @param prevDSTSavings    The amount of daylight saving offset from the
-     *                          standard time. 
-     * 
+     *                          standard time.
+     *
      * @return  The very first time when this rule takes effect.
-     * 
+     *
      * @stable ICU 3.8
      */
     public abstract Date getFirstStart(int prevRawOffset, int prevDSTSavings);
 
     /**
      * Gets the final time when this rule takes effect.
-     * 
+     *
      * @param prevRawOffset     The standard time offset from UTC before this rule
      *                          takes effect in milliseconds.
      * @param prevDSTSavings    The amount of daylight saving offset from the
-     *                          standard time. 
-     * 
+     *                          standard time.
+     *
      * @return  The very last time when this rule takes effect,
      *          or null if this rule is applied for future dates infinitely.
-     * 
+     *
      * @stable ICU 3.8
      */
     public abstract Date getFinalStart(int prevRawOffset, int prevDSTSavings);
 
     /**
      * Gets the first time when this rule takes effect after the specified time.
-     * 
+     *
      * @param base              The first time after this time is returned.
      * @param prevRawOffset     The standard time offset from UTC before this rule
      *                          takes effect in milliseconds.
      * @param prevDSTSavings    The amount of daylight saving offset from the
-     *                          standard time. 
+     *                          standard time.
      * @param inclusive         Whether the base time is inclusive or not.
-     * 
+     *
      * @return  The first time when this rule takes effect after the specified time,
      *          or null when this rule never takes effect after the specified time.
-     * 
+     *
      * @stable ICU 3.8
      */
     public abstract Date getNextStart(long base, int prevRawOffset, int prevDSTSavings, boolean inclusive);
 
     /**
      * Gets the most recent time when this rule takes effect before the specified time.
-     * 
+     *
      * @param base              The most recent time when this rule takes effect before
      *                          this time is returned.
      * @param prevRawOffset     The standard time offset from UTC before this rule
      *                          takes effect in milliseconds.
      * @param prevDSTSavings    The amount of daylight saving offset from the
-     *                          standard time. 
+     *                          standard time.
      * @param inclusive         Whether the base time is inclusive or not.
-     * 
+     *
      * @return  The most recent time when this rule takes effect before the specified time,
      *          or null when this rule never takes effect before the specified time.
-     * 
+     *
      * @stable ICU 3.8
      */
     public abstract Date getPreviousStart(long base, int prevRawOffset, int prevDSTSavings, boolean inclusive);
 
     /**
      * Returns if this <code>TimeZoneRule</code> has one or more start times.
-     * 
+     *
      * @return true if this <code>TimeZoneRule</code> has one or more start times.
-     * 
+     *
      * @stable ICU 3.8
      */
     public abstract boolean isTransitionRule();
@@ -174,6 +176,7 @@ public abstract class TimeZoneRule implements Serializable {
      * in future version of ICU without any notice.
      * @stable ICU 3.8
      */
+    @Override
     public String toString() {
         StringBuilder buf = new StringBuilder();
         buf.append("name=" + name);
diff --git a/app/src/main/java/com/ibm/icu/util/TimeZoneTransition.java b/icu4j/src/main/java/com/ibm/icu/util/TimeZoneTransition.java
similarity index 92%
rename from app/src/main/java/com/ibm/icu/util/TimeZoneTransition.java
rename to icu4j/src/main/java/com/ibm/icu/util/TimeZoneTransition.java
index 01d0cf8..6d8de3a 100644
--- a/app/src/main/java/com/ibm/icu/util/TimeZoneTransition.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/TimeZoneTransition.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2007-2010, International Business Machines Corporation and    *
@@ -9,7 +11,7 @@ package com.ibm.icu.util;
  * <code>TimeZoneTransition</code> is a class representing a time zone transition.
  * An instance has a time of transition and rules for both before and
  * after the transition.
- * 
+ *
  * @stable ICU 3.8
  */
 public class TimeZoneTransition {
@@ -20,11 +22,11 @@ public class TimeZoneTransition {
     /**
      * Constructs a <code>TimeZoneTransition</code> with the time and the rules before/after
      * the transition.
-     * 
+     *
      * @param time  The time of transition in milliseconds since the base time.
      * @param from  The time zone rule used before the transition.
      * @param to    The time zone rule used after the transition.
-     * 
+     *
      * @stable ICU 3.8
      */
     public TimeZoneTransition(long time, TimeZoneRule from, TimeZoneRule to) {
@@ -35,9 +37,9 @@ public class TimeZoneTransition {
 
     /**
      * Returns the time of transition in milliseconds since the base time.
-     * 
+     *
      * @return The time of the transition in milliseconds since the base time.
-     * 
+     *
      * @stable ICU 3.8
      */
     public long getTime() {
@@ -46,9 +48,9 @@ public class TimeZoneTransition {
 
     /**
      * Returns the rule used after the transition.
-     * 
+     *
      * @return The time zone rule used after the transition.
-     * 
+     *
      * @stable ICU 3.8
      */
     public TimeZoneRule getTo() {
@@ -57,9 +59,9 @@ public class TimeZoneTransition {
 
     /**
      * Returns the rule used before the transition.
-     * 
+     *
      * @return The time zone rule used after the transition.
-     * 
+     *
      * @stable ICU 3.8
      */
     public TimeZoneRule getFrom() {
@@ -70,9 +72,10 @@ public class TimeZoneTransition {
      * Returns a <code>String</code> representation of this <code>TimeZoneTransition</code> object.
      * This method is used for debugging purpose only.  The string representation can be changed
      * in future version of ICU without any notice.
-     * 
+     *
      * @stable ICU 3.8
      */
+    @Override
     public String toString() {
         StringBuilder buf = new StringBuilder();
         buf.append("time=" + time);
diff --git a/app/src/main/java/com/ibm/icu/util/ULocale.java b/icu4j/src/main/java/com/ibm/icu/util/ULocale.java
similarity index 97%
rename from app/src/main/java/com/ibm/icu/util/ULocale.java
rename to icu4j/src/main/java/com/ibm/icu/util/ULocale.java
index 14f1c95..7332d6e 100644
--- a/app/src/main/java/com/ibm/icu/util/ULocale.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/ULocale.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  ******************************************************************************
  * Copyright (C) 2003-2016, International Business Machines Corporation and
@@ -24,13 +26,14 @@ import java.util.Set;
 import java.util.TreeMap;
 import java.util.TreeSet;
 
-import com.ibm.icu.impl.ICUCache;
+import com.ibm.icu.impl.CacheBase;
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.impl.ICUResourceTableAccess;
 import com.ibm.icu.impl.LocaleIDParser;
 import com.ibm.icu.impl.LocaleIDs;
 import com.ibm.icu.impl.LocaleUtility;
-import com.ibm.icu.impl.SimpleCache;
+import com.ibm.icu.impl.SoftCache;
 import com.ibm.icu.impl.locale.AsciiUtil;
 import com.ibm.icu.impl.locale.BaseLocale;
 import com.ibm.icu.impl.locale.Extension;
@@ -114,7 +117,12 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
     // using serialver from jdk1.4.2_05
     private static final long serialVersionUID = 3715177670352309217L;
 
-    private static ICUCache<String, String> nameCache = new SimpleCache<String, String>();
+    private static CacheBase<String, String, Void> nameCache = new SoftCache<String, String, Void>() {
+        @Override
+        protected String createInstance(String tmpLocaleID, Void unused) {
+            return new LocaleIDParser(tmpLocaleID).getName();
+        }
+    };
 
     /**
      * Useful constant for language.
@@ -304,7 +312,12 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
         FORMAT
     }
 
-    private static final SimpleCache<Locale, ULocale> CACHE = new SimpleCache<Locale, ULocale>();
+    private static final SoftCache<Locale, ULocale, Void> CACHE = new SoftCache<Locale, ULocale, Void>() {
+        @Override
+        protected ULocale createInstance(Locale key, Void unused) {
+            return JDKLocaleHelper.toULocale(key);
+        }
+    };
 
     /**
      * Cache the locale.
@@ -441,12 +454,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
         if (loc == null) {
             return null;
         }
-        ULocale result = CACHE.get(loc);
-        if (result == null) {
-            result = JDKLocaleHelper.toULocale(loc);
-            CACHE.put(loc, result);
-        }
-        return result;
+        return CACHE.getInstance(loc, null /* unused */);
     }
 
     /**
@@ -458,7 +466,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
      * are distinguished by position as indicated by the underscores.  The
      * start of the keyword list is indicated by '@', and consists of two
      * or more keyword/value pairs separated by semicolons(';').
-     * 
+     *
      * <p>This constructor does not canonicalize the localeID.  So, for
      * example, "zh__pinyin" remains unchanged instead of converting
      * to "zh@collation=pinyin".  By default ICU only recognizes the
@@ -573,7 +581,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
         // Locale.getDefault().
 
         // Note: The "user.script" property is only used by initialization.
-        // 
+        //
         if (JDKLocaleHelper.hasLocaleCategories()) {
             for (Category cat: Category.values()) {
                 int idx = cat.ordinal();
@@ -628,7 +636,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
      * or older systems supporting other <code>user.*</code> system properties to initialize
      * the default ULocale. The <code>user.script</code> override for default ULocale is not
      * used on Java 7, or if the current Java default Locale is changed after start up.
-     * 
+     *
      * @return the default ULocale.
      * @stable ICU 2.8
      */
@@ -694,7 +702,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
 
     /**
      * Returns the current default ULocale for the specified category.
-     * 
+     *
      * @param category the category
      * @return the default ULocale for the specified category.
      * @stable ICU 49
@@ -752,7 +760,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
      * of the JVM. If the caller does not have write permission to the
      * user.language property, a security exception will be thrown,
      * and the default ULocale for the specified Category will remain unchanged.
-     * 
+     *
      * @param category the specified category to set the default locale
      * @param newLocale the new default locale
      * @see SecurityManager#checkPermission(java.security.Permission)
@@ -772,6 +780,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
      * immutable, there is no reason to clone it, so this API returns 'this'.
      * @stable ICU 3.0
      */
+    @Override
     public Object clone() {
         return this;
     }
@@ -780,6 +789,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
      * Returns the hashCode.
      * @stable ICU 3.0
      */
+    @Override
     public int hashCode() {
         return localeID.hashCode();
     }
@@ -793,6 +803,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
      * @return true if this Locale is equal to the specified object.
      * @stable ICU 3.0
      */
+    @Override
     public boolean equals(Object obj) {
         if (this == obj) {
             return true;
@@ -806,14 +817,15 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
     /**
      * Compares two ULocale for ordering.
      * <p><b>Note:</b> The order might change in future.
-     * 
+     *
      * @param other the ULocale to be compared.
      * @return a negative integer, zero, or a positive integer as this ULocale is less than, equal to, or greater
      * than the specified ULocale.
      * @throws NullPointerException if <code>other</code> is null.
-     * 
+     *
      * @stable ICU 53
      */
+    @Override
     public int compareTo(ULocale other) {
         if (this == other) {
             return 0;
@@ -1164,18 +1176,14 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
         } else {
             tmpLocaleID = localeID;
         }
-        String name = nameCache.get(tmpLocaleID);
-        if (name == null) {
-            name = new LocaleIDParser(tmpLocaleID).getName();
-            nameCache.put(tmpLocaleID, name);
-        }
-        return name;
+        return nameCache.getInstance(tmpLocaleID, null /* unused */);
     }
 
     /**
      * Returns a string representation of this object.
      * @stable ICU 3.0
      */
+    @Override
     public String toString() {
         return localeID;
     }
@@ -1964,8 +1972,8 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
      * @stable ICU 4.0
      */
     public String getCharacterOrientation() {
-        return ICUResourceTableAccess.getTableString(ICUResourceBundle.ICU_BASE_NAME, this,
-                "layout", "characters");
+        return ICUResourceTableAccess.getTableString(ICUData.ICU_BASE_NAME, this,
+                "layout", "characters", "characters");
     }
 
     /**
@@ -1976,8 +1984,8 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
      * @stable ICU 4.0
      */
     public String getLineOrientation() {
-        return ICUResourceTableAccess.getTableString(ICUResourceBundle.ICU_BASE_NAME, this,
-                "layout", "lines");
+        return ICUResourceTableAccess.getTableString(ICUData.ICU_BASE_NAME, this,
+                "layout", "lines", "lines");
     }
 
     /**
@@ -2163,7 +2171,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
     /**
      * Package local method used for parsing Accept-Language string
      */
-    static ULocale[] parseAcceptLanguage(String acceptLanguage, boolean isLenient) 
+    static ULocale[] parseAcceptLanguage(String acceptLanguage, boolean isLenient)
             throws ParseException {
         class ULocaleAcceptLanguageQ implements Comparable<ULocaleAcceptLanguageQ> {
             private double q;
@@ -2172,6 +2180,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
                 q = theq;
                 serial = theserial;
             }
+            @Override
             public int compareTo(ULocaleAcceptLanguageQ other) {
                 if (q > other.q) { // reverse - to sort in descending order
                     return -1;
@@ -2189,7 +2198,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
         }
 
         // parse out the acceptLanguage into an array
-        TreeMap<ULocaleAcceptLanguageQ, ULocale> map = 
+        TreeMap<ULocaleAcceptLanguageQ, ULocale> map =
                 new TreeMap<ULocaleAcceptLanguageQ, ULocale>();
         StringBuilder languageRangeBuf = new StringBuilder();
         StringBuilder qvalBuf = new StringBuilder();
@@ -2334,7 +2343,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
                 }
                 break;
             case 8: // before q value fraction part
-                if ('0' <= c || c <= '9') {
+                if ('0' <= c && c <= '9') {
                     if (q1 && c != '0' && !isLenient) {
                         // if q value starts with 1, the fraction part must be 0
                         state = -1;
@@ -2498,64 +2507,64 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
      * @stable ICU 4.0
      */
     public static ULocale minimizeSubtags(ULocale loc) {
-        return minimizeSubtags(loc, Minimize.FAVOR_REGION); 
-    } 
+        return minimizeSubtags(loc, Minimize.FAVOR_REGION);
+    }
 
-    /** 
-     * Options for minimizeSubtags. 
+    /**
+     * Options for minimizeSubtags.
      * @internal
      * @deprecated This API is ICU internal only.
-     */ 
+     */
     @Deprecated
-    public enum Minimize { 
-        /** 
+    public enum Minimize {
+        /**
          * Favor including the script, when either the region <b>or</b> the script could be suppressed, but not both.
          * @internal
          * @deprecated This API is ICU internal only.
          */
         @Deprecated
-        FAVOR_SCRIPT,  
+        FAVOR_SCRIPT,
         /**
          * Favor including the region, when either the region <b>or</b> the script could be suppressed, but not both.
          * @internal
          * @deprecated This API is ICU internal only.
          */
         @Deprecated
-        FAVOR_REGION 
-    } 
-
-    /** 
-     * {@icu} Minimizes the subtags for a provided locale ID, per the algorithm described 
-     * in the following CLDR technical report:<blockquote> 
-     * 
-     *   <a href="http://www.unicode.org/reports/tr35/#Likely_Subtags" 
-     *>http://www.unicode.org/reports/tr35/#Likely_Subtags</a></blockquote> 
-     * 
-     * If the provided ULocale instance is already in the minimal form, or there 
-     * is no data available for minimization, it will be returned.  Since the 
-     * minimization algorithm relies on proper maximization, see the comments 
-     * for addLikelySubtags for reasons why there might not be any data. 
-     * 
-     * Examples:<pre> 
-     * 
-     * "en_Latn_US" minimizes to "en" 
-     * 
-     * "de_Latn_US" minimizes to "de" 
-     * 
-     * "sr_Cyrl_RS" minimizes to "sr" 
-     * 
-     * "zh_Hant_TW" minimizes to "zh_TW" if fieldToFavor == {@link Minimize#FAVOR_REGION} 
-     * "zh_Hant_TW" minimizes to "zh_Hant" if fieldToFavor == {@link Minimize#FAVOR_SCRIPT} 
-     * </pre> 
-     * The fieldToFavor only has an effect if either the region or the script could be suppressed, but not both. 
-     * @param loc The ULocale to minimize 
-     * @param fieldToFavor Indicate which should be preferred, when either the region <b>or</b> the script could be suppressed, but not both. 
-     * @return The minimized ULocale instance. 
+        FAVOR_REGION
+    }
+
+    /**
+     * {@icu} Minimizes the subtags for a provided locale ID, per the algorithm described
+     * in the following CLDR technical report:<blockquote>
+     *
+     *   <a href="http://www.unicode.org/reports/tr35/#Likely_Subtags"
+     *>http://www.unicode.org/reports/tr35/#Likely_Subtags</a></blockquote>
+     *
+     * If the provided ULocale instance is already in the minimal form, or there
+     * is no data available for minimization, it will be returned.  Since the
+     * minimization algorithm relies on proper maximization, see the comments
+     * for addLikelySubtags for reasons why there might not be any data.
+     *
+     * Examples:<pre>
+     *
+     * "en_Latn_US" minimizes to "en"
+     *
+     * "de_Latn_US" minimizes to "de"
+     *
+     * "sr_Cyrl_RS" minimizes to "sr"
+     *
+     * "zh_Hant_TW" minimizes to "zh_TW" if fieldToFavor == {@link Minimize#FAVOR_REGION}
+     * "zh_Hant_TW" minimizes to "zh_Hant" if fieldToFavor == {@link Minimize#FAVOR_SCRIPT}
+     * </pre>
+     * The fieldToFavor only has an effect if either the region or the script could be suppressed, but not both.
+     * @param loc The ULocale to minimize
+     * @param fieldToFavor Indicate which should be preferred, when either the region <b>or</b> the script could be suppressed, but not both.
+     * @return The minimized ULocale instance.
      * @internal
      * @deprecated This API is ICU internal only.
-     */ 
+     */
     @Deprecated
-    public static ULocale minimizeSubtags(ULocale loc, Minimize fieldToFavor) { 
+    public static ULocale minimizeSubtags(ULocale loc, Minimize fieldToFavor) {
         String[] tags = new String[3];
 
         int trailingIndex = parseTagString(
@@ -2619,85 +2628,85 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
         /**
          * Next, try the language and region.
          **/
-        if (fieldToFavor == Minimize.FAVOR_REGION) { 
-            if (originalRegion.length() != 0) { 
-                String tag = 
-                        createLikelySubtagsString( 
-                                originalLang, 
-                                null, 
-                                originalRegion, 
-                                null); 
-
-                if (tag.equals(maximizedLocaleID)) { 
-                    String newLocaleID = 
-                            createTagString( 
-                                    originalLang, 
-                                    null, 
-                                    originalRegion, 
-                                    originalTrailing); 
-
-                    return new ULocale(newLocaleID); 
-                } 
-            } 
-            if (originalScript.length() != 0){ 
-                String tag = 
-                        createLikelySubtagsString( 
-                                originalLang, 
-                                originalScript, 
-                                null, 
-                                null); 
-
-                if (tag.equals(maximizedLocaleID)) { 
-                    String newLocaleID = 
-                            createTagString( 
-                                    originalLang, 
-                                    originalScript, 
-                                    null, 
-                                    originalTrailing); 
-
-                    return new ULocale(newLocaleID); 
-                } 
-            } 
-        } else { // FAVOR_SCRIPT, so 
-            if (originalScript.length() != 0){ 
-                String tag = 
-                        createLikelySubtagsString( 
-                                originalLang, 
-                                originalScript, 
-                                null, 
-                                null); 
-
-                if (tag.equals(maximizedLocaleID)) { 
-                    String newLocaleID = 
-                            createTagString( 
-                                    originalLang, 
-                                    originalScript, 
-                                    null, 
-                                    originalTrailing); 
-
-                    return new ULocale(newLocaleID); 
-                } 
-            } 
-            if (originalRegion.length() != 0) { 
-                String tag = 
-                        createLikelySubtagsString( 
-                                originalLang, 
-                                null, 
-                                originalRegion, 
-                                null); 
-
-                if (tag.equals(maximizedLocaleID)) { 
-                    String newLocaleID = 
-                            createTagString( 
-                                    originalLang, 
-                                    null, 
-                                    originalRegion, 
-                                    originalTrailing); 
-
-                    return new ULocale(newLocaleID); 
-                } 
-            } 
-        } 
+        if (fieldToFavor == Minimize.FAVOR_REGION) {
+            if (originalRegion.length() != 0) {
+                String tag =
+                        createLikelySubtagsString(
+                                originalLang,
+                                null,
+                                originalRegion,
+                                null);
+
+                if (tag.equals(maximizedLocaleID)) {
+                    String newLocaleID =
+                            createTagString(
+                                    originalLang,
+                                    null,
+                                    originalRegion,
+                                    originalTrailing);
+
+                    return new ULocale(newLocaleID);
+                }
+            }
+            if (originalScript.length() != 0){
+                String tag =
+                        createLikelySubtagsString(
+                                originalLang,
+                                originalScript,
+                                null,
+                                null);
+
+                if (tag.equals(maximizedLocaleID)) {
+                    String newLocaleID =
+                            createTagString(
+                                    originalLang,
+                                    originalScript,
+                                    null,
+                                    originalTrailing);
+
+                    return new ULocale(newLocaleID);
+                }
+            }
+        } else { // FAVOR_SCRIPT, so
+            if (originalScript.length() != 0){
+                String tag =
+                        createLikelySubtagsString(
+                                originalLang,
+                                originalScript,
+                                null,
+                                null);
+
+                if (tag.equals(maximizedLocaleID)) {
+                    String newLocaleID =
+                            createTagString(
+                                    originalLang,
+                                    originalScript,
+                                    null,
+                                    originalTrailing);
+
+                    return new ULocale(newLocaleID);
+                }
+            }
+            if (originalRegion.length() != 0) {
+                String tag =
+                        createLikelySubtagsString(
+                                originalLang,
+                                null,
+                                originalRegion,
+                                null);
+
+                if (tag.equals(maximizedLocaleID)) {
+                    String newLocaleID =
+                            createTagString(
+                                    originalLang,
+                                    null,
+                                    originalRegion,
+                                    originalTrailing);
+
+                    return new ULocale(newLocaleID);
+                }
+            }
+        }
         return loc;
     }
 
@@ -2955,7 +2964,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
     private static String lookupLikelySubtags(String localeId) {
         UResourceBundle bundle =
                 UResourceBundle.getBundleInstance(
-                        ICUResourceBundle.ICU_BASE_NAME, "likelySubtags");
+                        ICUData.ICU_BASE_NAME, "likelySubtags");
         try {
             return bundle.getString(localeId);
         }
@@ -2991,7 +3000,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
                 System.err.println("Tag mismatch: \"" + likelySubtags + "\" \"(null)\"");
             }
             else if (!likelySubtags.equals(likelySubtags2)) {
-                System.err.println("Tag mismatch: \"" + likelySubtags + "\" \"" + likelySubtags2 
+                System.err.println("Tag mismatch: \"" + likelySubtags + "\" \"" + likelySubtags2
                     + "\"");
             }
              */
@@ -3174,7 +3183,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
      * locale does not define the key.
      * @throws IllegalArgumentException if the key is not well-formed
      * @throws NullPointerException if <code>key</code> is null
-     * 
+     *
      * @stable ICU 4.4
      */
     public String getUnicodeLocaleType(String key) {
@@ -3190,7 +3199,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
      *
      * @return The set of Unicode locale keys, or the empty set if this locale has
      * no Unicode locale keywords.
-     * 
+     *
      * @stable ICU 4.4
      */
     public Set<String> getUnicodeLocaleKeys() {
@@ -3211,7 +3220,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
      *
      * <p><b>Script:</b> If script is not well-formed (for example "12"
      * or "Latin"), it will be omitted.
-     * 
+     *
      * <p><b>Country:</b> If country is not well-formed (for example "12"
      * or "USA"), it will be omitted.
      *
@@ -3242,7 +3251,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
      * necessarily a valid BCP 47 language tag.  For example,
      * <pre>
      *   new Locale("xx", "YY").toLanguageTag();</pre>
-     * 
+     *
      * will return "xx-YY", but the language subtag "xx" and the
      * region subtag "YY" are invalid because they are not registered
      * in the IANA Language Subtag Registry.
@@ -3366,7 +3375,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
      * private use language tags.  Stand alone private use tags are
      * represented as empty language and extension 'x-whatever',
      * and grandfathered tags are converted to their canonical replacements
-     * where they exist.  
+     * where they exist.
      *
      * <p>Grandfathered tags with canonical replacements are as follows:
      *
@@ -3442,13 +3451,13 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
      * then the lower-case version of the input keyword will be returned.
      * For example,
      * <code>toUnicodeLocaleKey("ZZ")</code> returns "zz".
-     * 
+     *
      * @param keyword       the input locale keyword (either legacy key
      *                      such as "collation" or BCP 47 Unicode locale extension
      *                      key such as "co").
      * @return              the well-formed BCP 47 Unicode locale extension key,
      *                      or null if the specified locale keyword cannot be mapped
-     *                      to a well-formed BCP 47 Unicode locale extension key. 
+     *                      to a well-formed BCP 47 Unicode locale extension key.
      * @see #toLegacyKey(String)
      * @stable ICU 54
      */
@@ -3475,7 +3484,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
      * will be returned. For example,
      * <code>toUnicodeLocaleType("Foo", "Bar")</code> returns "bar",
      * <code>toUnicodeLocaleType("variableTop", "00A4")</code> returns "00a4".
-     * 
+     *
      * @param keyword       the locale keyword (either legacy key such as
      *                      "collation" or BCP 47 Unicode locale extension
      *                      key such as "co").
@@ -3501,7 +3510,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
      * {@icu} Converts the specified keyword (BCP 47 Unicode locale extension key, or
      * legacy key) to the legacy key. For example, legacy key "collation" is
      * returned for the input BCP 47 Unicode locale extension key "co".
-     * 
+     *
      * @param keyword       the input locale keyword (either BCP 47 Unicode locale
      *                      extension key or legacy key).
      * @return              the well-formed legacy key, or null if the specified
@@ -4462,6 +4471,7 @@ public final class ULocale implements Serializable, Comparable<ULocale> {
             if (System.getSecurityManager() != null) {
                 try {
                     val = AccessController.doPrivileged(new PrivilegedAction<String>() {
+                        @Override
                         public String run() {
                             return System.getProperty(fkey);
                         }
diff --git a/app/src/main/java/com/ibm/icu/util/UResourceBundle.java b/icu4j/src/main/java/com/ibm/icu/util/UResourceBundle.java
similarity index 75%
rename from app/src/main/java/com/ibm/icu/util/UResourceBundle.java
rename to icu4j/src/main/java/com/ibm/icu/util/UResourceBundle.java
index 0298c1b..16a25d3 100644
--- a/app/src/main/java/com/ibm/icu/util/UResourceBundle.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/UResourceBundle.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2004-2016, International Business Machines Corporation and
@@ -7,23 +9,22 @@
 
 package com.ibm.icu.util;
 
-import java.lang.ref.SoftReference;
 import java.nio.ByteBuffer;
 import java.util.Collections;
 import java.util.Enumeration;
 import java.util.HashMap;
 import java.util.Locale;
+import java.util.Map;
 import java.util.MissingResourceException;
 import java.util.ResourceBundle;
 import java.util.Set;
 import java.util.TreeSet;
 import java.util.concurrent.ConcurrentHashMap;
 
-import com.ibm.icu.impl.ICUCache;
+import com.ibm.icu.impl.ICUData;
 import com.ibm.icu.impl.ICUResourceBundle;
 import com.ibm.icu.impl.ICUResourceBundleReader;
 import com.ibm.icu.impl.ResourceBundleWrapper;
-import com.ibm.icu.impl.SimpleCache;
 
 /**
  * {@icuenhanced java.util.ResourceBundle}.{@icu _usage_}
@@ -73,14 +74,14 @@ import com.ibm.icu.impl.SimpleCache;
  * change.  To open ICU style organization use:
  *
  * <pre>
- *      UResourceBundle bundle = 
- *          UResourceBundle.getBundleInstance("com/mycompany/resources", 
+ *      UResourceBundle bundle =
+ *          UResourceBundle.getBundleInstance("com/mycompany/resources",
  *                                            "en_US", myClassLoader);
  * </pre>
  * To open Java/JDK style organization use:
  * <pre>
- *      UResourceBundle bundle = 
- *          UResourceBundle.getBundleInstance("com.mycompany.resources.LocaleElements", 
+ *      UResourceBundle bundle =
+ *          UResourceBundle.getBundleInstance("com.mycompany.resources.LocaleElements",
  *                                            "en_US", myClassLoader);
  * </pre>
  *
@@ -97,7 +98,8 @@ public abstract class UResourceBundle extends ResourceBundle {
     /**
      * {@icu} Creates a resource bundle using the specified base name and locale.
      * ICU_DATA_CLASS is used as the default root.
-     * @param baseName the base name of the resource bundle, a fully qualified class name
+     * @param baseName string containing the name of the data package.
+     *                    If null the default ICU package name is used.
      * @param localeName the locale for which a resource bundle is desired
      * @throws MissingResourceException If no resource bundle for the specified base name
      * can be found
@@ -105,14 +107,15 @@ public abstract class UResourceBundle extends ResourceBundle {
      * @stable ICU 3.0
      */
     public static UResourceBundle getBundleInstance(String baseName, String localeName){
-        return getBundleInstance(baseName, localeName, ICUResourceBundle.ICU_DATA_CLASS_LOADER, 
+        return getBundleInstance(baseName, localeName, ICUResourceBundle.ICU_DATA_CLASS_LOADER,
                                  false);
     }
 
     /**
      * {@icu} Creates a resource bundle using the specified base name, locale, and class root.
      *
-     * @param baseName the base name of the resource bundle, a fully qualified class name
+     * @param baseName string containing the name of the data package.
+     *                    If null the default ICU package name is used.
      * @param localeName the locale for which a resource bundle is desired
      * @param root the class object from which to load the resource bundle
      * @throws MissingResourceException If no resource bundle for the specified base name
@@ -120,7 +123,7 @@ public abstract class UResourceBundle extends ResourceBundle {
      * @return a resource bundle for the given base name and locale
      * @stable ICU 3.0
      */
-    public static UResourceBundle getBundleInstance(String baseName, String localeName, 
+    public static UResourceBundle getBundleInstance(String baseName, String localeName,
                                                     ClassLoader root){
         return getBundleInstance(baseName, localeName, root, false);
     }
@@ -129,7 +132,8 @@ public abstract class UResourceBundle extends ResourceBundle {
      * {@icu} Creates a resource bundle using the specified base name, locale, and class
      * root.
      *
-     * @param baseName the base name of the resource bundle, a fully qualified class name
+     * @param baseName string containing the name of the data package.
+     *                    If null the default ICU package name is used.
      * @param localeName the locale for which a resource bundle is desired
      * @param root the class object from which to load the resource bundle
      * @param disableFallback Option to disable locale inheritence.
@@ -140,7 +144,7 @@ public abstract class UResourceBundle extends ResourceBundle {
      * @stable ICU 3.0
      *
      */
-    protected static UResourceBundle getBundleInstance(String baseName, String localeName, 
+    protected static UResourceBundle getBundleInstance(String baseName, String localeName,
                                                        ClassLoader root, boolean disableFallback) {
         return instantiateBundle(baseName, localeName, root, disableFallback);
     }
@@ -166,32 +170,32 @@ public abstract class UResourceBundle extends ResourceBundle {
         if (locale==null) {
             locale = ULocale.getDefault();
         }
-        return getBundleInstance(ICUResourceBundle.ICU_BASE_NAME, locale.toString(), 
+        return getBundleInstance(ICUData.ICU_BASE_NAME, locale.getBaseName(),
                                  ICUResourceBundle.ICU_DATA_CLASS_LOADER, false);
     }
 
     /**
      * {@icu} Creates a UResourceBundle for the default locale and specified base name,
      * from which users can extract resources by using their corresponding keys.
-     * @param baseName  specifies the locale for which we want to open the resource.
-     *                If null the bundle for default locale is opened.
+     * @param baseName string containing the name of the data package.
+     *                    If null the default ICU package name is used.
      * @return a resource bundle for the given base name and default locale
      * @stable ICU 3.0
      */
     public static UResourceBundle getBundleInstance(String baseName) {
         if (baseName == null) {
-            baseName = ICUResourceBundle.ICU_BASE_NAME;
+            baseName = ICUData.ICU_BASE_NAME;
         }
         ULocale uloc = ULocale.getDefault();
-        return getBundleInstance(baseName, uloc.toString(), ICUResourceBundle.ICU_DATA_CLASS_LOADER, 
+        return getBundleInstance(baseName, uloc.getBaseName(), ICUResourceBundle.ICU_DATA_CLASS_LOADER,
                                  false);
     }
 
     /**
      * {@icu} Creates a UResourceBundle for the specified locale and specified base name,
      * from which users can extract resources by using their corresponding keys.
-     * @param baseName  specifies the locale for which we want to open the resource.
-     *                If null the bundle for default locale is opened.
+     * @param baseName string containing the name of the data package.
+     *                    If null the default ICU package name is used.
      * @param locale  specifies the locale for which we want to open the resource.
      *                If null the bundle for default locale is opened.
      * @return a resource bundle for the given base name and locale
@@ -200,12 +204,12 @@ public abstract class UResourceBundle extends ResourceBundle {
 
     public static UResourceBundle getBundleInstance(String baseName, Locale locale) {
         if (baseName == null) {
-            baseName = ICUResourceBundle.ICU_BASE_NAME;
+            baseName = ICUData.ICU_BASE_NAME;
         }
         ULocale uloc = locale == null ? ULocale.getDefault() : ULocale.forLocale(locale);
 
-        return getBundleInstance(baseName, uloc.toString(), ICUResourceBundle.ICU_DATA_CLASS_LOADER, 
-                                 false);
+        return getBundleInstance(baseName, uloc.getBaseName(),
+                                 ICUResourceBundle.ICU_DATA_CLASS_LOADER, false);
     }
 
     /**
@@ -220,33 +224,33 @@ public abstract class UResourceBundle extends ResourceBundle {
      */
     public static UResourceBundle getBundleInstance(String baseName, ULocale locale) {
         if (baseName == null) {
-            baseName = ICUResourceBundle.ICU_BASE_NAME;
+            baseName = ICUData.ICU_BASE_NAME;
         }
         if (locale == null) {
             locale = ULocale.getDefault();
         }
-        return getBundleInstance(baseName, locale.toString(), 
+        return getBundleInstance(baseName, locale.getBaseName(),
                                  ICUResourceBundle.ICU_DATA_CLASS_LOADER, false);
     }
 
     /**
      * {@icu} Creates a UResourceBundle for the specified locale and specified base name,
      * from which users can extract resources by using their corresponding keys.
-     * @param baseName  specifies the locale for which we want to open the resource.
-     *                If null the bundle for default locale is opened.
+     * @param baseName string containing the name of the data package.
+     *                    If null the default ICU package name is used.
      * @param locale  specifies the locale for which we want to open the resource.
      *                If null the bundle for default locale is opened.
      * @param loader  the loader to use
      * @return a resource bundle for the given base name and locale
      * @stable ICU 3.8
      */
-    public static UResourceBundle getBundleInstance(String baseName, Locale locale, 
+    public static UResourceBundle getBundleInstance(String baseName, Locale locale,
                                                     ClassLoader loader) {
         if (baseName == null) {
-            baseName = ICUResourceBundle.ICU_BASE_NAME;
+            baseName = ICUData.ICU_BASE_NAME;
         }
         ULocale uloc = locale == null ? ULocale.getDefault() : ULocale.forLocale(locale);
-        return getBundleInstance(baseName, uloc.toString(), loader, false);
+        return getBundleInstance(baseName, uloc.getBaseName(), loader, false);
     }
 
     /**
@@ -263,15 +267,15 @@ public abstract class UResourceBundle extends ResourceBundle {
      * @return a resource bundle for the given base name and locale
      * @stable ICU 3.8
      */
-    public static UResourceBundle getBundleInstance(String baseName, ULocale locale, 
+    public static UResourceBundle getBundleInstance(String baseName, ULocale locale,
                                                     ClassLoader loader) {
         if (baseName == null) {
-            baseName = ICUResourceBundle.ICU_BASE_NAME;
+            baseName = ICUData.ICU_BASE_NAME;
         }
         if (locale == null) {
             locale = ULocale.getDefault();
         }
-        return getBundleInstance(baseName, locale.toString(), loader, false);
+        return getBundleInstance(baseName, locale.getBaseName(), loader, false);
     }
 
     /**
@@ -312,214 +316,48 @@ public abstract class UResourceBundle extends ResourceBundle {
      * @return the locale of this resource bundle
      * @stable ICU 3.0
      */
+    @Override
     public Locale getLocale(){
         return getULocale().toLocale();
     }
 
-    // Cache for ResourceBundle instantiation
-    private static ICUCache<ResourceCacheKey, UResourceBundle> BUNDLE_CACHE =
-        new SimpleCache<ResourceCacheKey, UResourceBundle>();
-
-    /**
-     * @internal
-     * @deprecated This API is ICU internal only.
-     */
-    @Deprecated
-    public static void resetBundleCache() {
-        /*
-         * A HACK!!!!!
-         * Currently if a resourcebundle with fallback turned ON is added to the cache
-         * and then a getBundleInstance() is called for a bundle with fallback turned OFF
-         * it will actually search the cache for any bundle of the same locale
-         * regaurdless of fallback status. This method has been created so that if
-         * The calling method KNOWS that instances of the other fallback state may be in the
-         * cache, the calling method may call this method to clear out the cache.
-         *
-         */
-        //TODO figure a way around this method(see method comment)
-        BUNDLE_CACHE = new SimpleCache<ResourceCacheKey, UResourceBundle>();
-    }
-
-    /**
-     * Method used by subclasses to add a resource bundle object to the managed
-     * cache.  Works like a putIfAbsent(): If the cache already contains a matching
-     * bundle, that one will be retained and returned.
-     * @internal
-     * @deprecated This API is ICU internal only.
-     */
-    @Deprecated
-    protected static UResourceBundle addToCache(String fullName, ULocale defaultLocale, UResourceBundle b) {
-        synchronized(cacheKey){
-            cacheKey.setKeyValues(fullName, defaultLocale);
-            UResourceBundle cachedBundle = BUNDLE_CACHE.get(cacheKey);
-            if (cachedBundle != null) {
-                return cachedBundle;
-            }
-            BUNDLE_CACHE.put((ResourceCacheKey)cacheKey.clone(), b);
-            return b;
-        }
-    }
-
-    /**
-     * Method used by sub classes to load a resource bundle object from the managed cache
-     * @internal
-     * @deprecated This API is ICU internal only.
-     */
-    @Deprecated
-    protected static UResourceBundle loadFromCache(String fullName, ULocale defaultLocale) {
-        synchronized(cacheKey){
-            cacheKey.setKeyValues(fullName, defaultLocale);
-            return BUNDLE_CACHE.get(cacheKey);
-        }
-    }
-
-    /**
-     * Key used for cached resource bundles.  The key checks
-     * the resource name, the class root, and the default
-     * locale to determine if the resource is a match to the
-     * requested one. The root may be null, but the
-     * searchName and the default locale must have a non-null value.
-     * Note that the default locale may change over time, and
-     * lookup should always be based on the current default
-     * locale (if at all).
-     */
-    private static final class ResourceCacheKey implements Cloneable {
-        private String searchName;
-        private ULocale defaultLocale;
-        private int hashCodeCache;
-        ///CLOVER:OFF
-        public boolean equals(Object other) {
-            if (other == null) {
-                return false;
-            }
-            if (this == other) {
-                return true;
-            }
-            try {
-                final ResourceCacheKey otherEntry = (ResourceCacheKey) other;
-                //quick check to see if they are not equal
-                if (hashCodeCache != otherEntry.hashCodeCache) {
-                    return false;
-                }
-                //are the names the same?
-                if (!searchName.equals(otherEntry.searchName)) {
-                    return false;
-                }
-                // are the default locales the same?
-                if (defaultLocale == null) {
-                    if (otherEntry.defaultLocale != null) {
-                        return false;
-                    }
-                } else {
-                    if (!defaultLocale.equals(otherEntry.defaultLocale)) {
-                        return false;
-                    }
-                }
-                return true;
-            } catch (NullPointerException e) {
-                return false;
-            } catch (ClassCastException e) {
-                return false;
-            }
-        }
-
-        public int hashCode() {
-            return hashCodeCache;
-        }
-
-        public Object clone() {
-            try {
-                return super.clone();
-            } catch (CloneNotSupportedException e) {
-                //this should never happen
-                throw new ICUCloneNotSupportedException(e);
-            }
-        }
-
-        ///CLOVER:ON
-        private synchronized void setKeyValues(String searchName, ULocale defaultLocale) {
-            this.searchName = searchName;
-            hashCodeCache = searchName.hashCode();
-            this.defaultLocale = defaultLocale;
-            if (defaultLocale != null) {
-                hashCodeCache ^= defaultLocale.hashCode();
-            }
-        }
-        /*private void clear() {
-            setKeyValues(null, "", null);
-        }*/
-    }
-
-    private static final ResourceCacheKey cacheKey = new ResourceCacheKey();
-
-    private static final int ROOT_MISSING = 0;
-    private static final int ROOT_ICU = 1;
-    private static final int ROOT_JAVA = 2;
-
-    private static SoftReference<ConcurrentHashMap<String, Integer>> ROOT_CACHE =
-            new SoftReference<ConcurrentHashMap<String, Integer>>(new ConcurrentHashMap<String, Integer>());
+    private enum RootType { MISSING, ICU, JAVA }
 
-    private static int getRootType(String baseName, ClassLoader root) {
-        ConcurrentHashMap<String, Integer> m = null;
-        Integer rootType;
+    private static Map<String, RootType> ROOT_CACHE = new ConcurrentHashMap<String, RootType>();
 
-        m = ROOT_CACHE.get();
-        if (m == null) {
-            synchronized(UResourceBundle.class) {
-                m = ROOT_CACHE.get();
-                if (m == null) {
-                    m = new ConcurrentHashMap<String, Integer>();
-                    ROOT_CACHE = new SoftReference<ConcurrentHashMap<String, Integer>>(m);
-                }
-            }
-        }
-
-        rootType = m.get(baseName);
+    private static RootType getRootType(String baseName, ClassLoader root) {
+        RootType rootType = ROOT_CACHE.get(baseName);
 
         if (rootType == null) {
             String rootLocale = (baseName.indexOf('.')==-1) ? "root" : "";
-            int rt = ROOT_MISSING; // value set on success
             try{
                 ICUResourceBundle.getBundleInstance(baseName, rootLocale, root, true);
-                rt = ROOT_ICU;
+                rootType = RootType.ICU;
             }catch(MissingResourceException ex){
                 try{
                     ResourceBundleWrapper.getBundleInstance(baseName, rootLocale, root, true);
-                    rt = ROOT_JAVA;
+                    rootType = RootType.JAVA;
                 }catch(MissingResourceException e){
                     //throw away the exception
+                    rootType = RootType.MISSING;
                 }
             }
 
-            rootType = Integer.valueOf(rt);
-            m.putIfAbsent(baseName, rootType);
+            ROOT_CACHE.put(baseName, rootType);
         }
 
-        return rootType.intValue();
+        return rootType;
     }
 
-    private static void setRootType(String baseName, int rootType) {
-        Integer rt = Integer.valueOf(rootType);
-        ConcurrentHashMap<String, Integer> m = null;
-
-        m = ROOT_CACHE.get();
-        if (m == null) {
-            synchronized(UResourceBundle.class) {
-                m = ROOT_CACHE.get();
-                if (m == null) {
-                    m = new ConcurrentHashMap<String, Integer>();
-                    ROOT_CACHE = new SoftReference<ConcurrentHashMap<String, Integer>>(m);
-                }
-            }
-        }
-
-        m.put(baseName, rt);
+    private static void setRootType(String baseName, RootType rootType) {
+        ROOT_CACHE.put(baseName, rootType);
     }
 
     /**
      * {@icu} Loads a new resource bundle for the given base name, locale and class loader.
      * Optionally will disable loading of fallback bundles.
-     * @param baseName the base name of the resource bundle, a fully qualified class name
+     * @param baseName string containing the name of the data package.
+     *                    If null the default ICU package name is used.
      * @param localeName the locale for which a resource bundle is desired
      * @param root the class object from which to load the resource bundle
      * @param disableFallback disables loading of fallback lookup chain
@@ -530,41 +368,27 @@ public abstract class UResourceBundle extends ResourceBundle {
      */
     protected static UResourceBundle instantiateBundle(String baseName, String localeName,
                                                        ClassLoader root, boolean disableFallback) {
-        UResourceBundle b = null;
-        int rootType = getRootType(baseName, root);
-
-        ULocale defaultLocale = ULocale.getDefault();
-
-        switch (rootType)
-        {
-        case ROOT_ICU:
-            if(disableFallback) {
-                String fullName = ICUResourceBundleReader.getFullName(baseName, localeName);
-                b = loadFromCache(fullName, defaultLocale);
-                if (b == null) {
-                    b = ICUResourceBundle.getBundleInstance(baseName, localeName, root, 
-                                                            disableFallback);
-                }
-            } else {
-                b = ICUResourceBundle.getBundleInstance(baseName, localeName, root, 
-                                                        disableFallback);
-            }
+        RootType rootType = getRootType(baseName, root);
 
-            return b;
+        switch (rootType) {
+        case ICU:
+            return ICUResourceBundle.getBundleInstance(baseName, localeName, root, disableFallback);
 
-        case ROOT_JAVA:
-            return ResourceBundleWrapper.getBundleInstance(baseName, localeName, root, 
+        case JAVA:
+            return ResourceBundleWrapper.getBundleInstance(baseName, localeName, root,
                                                            disableFallback);
 
+        case MISSING:
         default:
+            UResourceBundle b;
             try{
-                b = ICUResourceBundle.getBundleInstance(baseName, localeName, root, 
+                b = ICUResourceBundle.getBundleInstance(baseName, localeName, root,
                                                         disableFallback);
-                setRootType(baseName, ROOT_ICU);
+                setRootType(baseName, RootType.ICU);
             }catch(MissingResourceException ex){
-                b = ResourceBundleWrapper.getBundleInstance(baseName, localeName, root, 
+                b = ResourceBundleWrapper.getBundleInstance(baseName, localeName, root,
                                                             disableFallback);
-                setRootType(baseName, ROOT_JAVA);
+                setRootType(baseName, RootType.JAVA);
             }
             return b;
         }
@@ -710,7 +534,6 @@ public abstract class UResourceBundle extends ResourceBundle {
         for (UResourceBundle res = this; res != null; res = res.getParent()) {
             UResourceBundle obj = res.handleGet(aKey, null, this);
             if (obj != null) {
-                ((ICUResourceBundle) obj).setLoadingStatus(getLocaleID());
                 return obj;
             }
         }
@@ -746,7 +569,7 @@ public abstract class UResourceBundle extends ResourceBundle {
     public UResourceBundle get(int index) {
         UResourceBundle obj = handleGet(index, null, this);
         if (obj == null) {
-            obj = (ICUResourceBundle) getParent();
+            obj = getParent();
             if (obj != null) {
                 obj = obj.get(index);
             }
@@ -756,7 +579,6 @@ public abstract class UResourceBundle extends ResourceBundle {
                                 + this.getClass().getName() + ", key "
                                 + getKey(), this.getClass().getName(), getKey());
         }
-        ((ICUResourceBundle)obj).setLoadingStatus(getLocaleID());
         return obj;
     }
 
@@ -781,7 +603,6 @@ public abstract class UResourceBundle extends ResourceBundle {
         for (UResourceBundle res = this; res != null; res = res.getParent()) {
             UResourceBundle obj = res.handleGet(index, null, this);
             if (obj != null) {
-                ((ICUResourceBundle) obj).setLoadingStatus(getLocaleID());
                 return obj;
             }
         }
@@ -794,6 +615,7 @@ public abstract class UResourceBundle extends ResourceBundle {
      *         which is empty if this is not a bundle or a table resource
      * @stable ICU 3.8
      */
+    @Override
     public Enumeration<String> getKeys() {
         return Collections.enumeration(keySet());
     }
@@ -805,6 +627,7 @@ public abstract class UResourceBundle extends ResourceBundle {
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Override
     @Deprecated
     public Set<String> keySet() {
         // TODO: Java 6 ResourceBundle has keySet() which calls handleKeySet()
@@ -856,6 +679,7 @@ public abstract class UResourceBundle extends ResourceBundle {
      * @internal
      * @deprecated This API is ICU internal only.
      */
+    @Override
     @Deprecated
     protected Set<String> handleKeySet() {
         return Collections.emptySet();
@@ -864,7 +688,7 @@ public abstract class UResourceBundle extends ResourceBundle {
     /**
      * {@icu} Returns the size of a resource. Size for scalar types is always 1, and for
      * vector/table types is the number of child resources.
-     * 
+     *
      * <br><b>Note:</b> Integer array is treated as a scalar type. There are no APIs to
      * access individual members of an integer array. It is always returned as a whole.
      * @return number of resources in a given resource.
@@ -975,7 +799,7 @@ public abstract class UResourceBundle extends ResourceBundle {
      * @return UResourceBundle a resource associated with the key
      * @stable ICU 3.8
      */
-    protected UResourceBundle handleGet(String aKey, HashMap<String, String> aliasesVisited, 
+    protected UResourceBundle handleGet(String aKey, HashMap<String, String> aliasesVisited,
                                         UResourceBundle requested) {
         return null;
     }
@@ -991,7 +815,7 @@ public abstract class UResourceBundle extends ResourceBundle {
      * @return UResourceBundle a resource associated with the index
      * @stable ICU 3.8
      */
-    protected UResourceBundle handleGet(int index, HashMap<String, String> aliasesVisited, 
+    protected UResourceBundle handleGet(int index, HashMap<String, String> aliasesVisited,
                                         UResourceBundle requested) {
         return null;
     }
@@ -1024,6 +848,7 @@ public abstract class UResourceBundle extends ResourceBundle {
     // this method is declared in ResourceBundle class
     // so cannot change the signature
     // Override this method
+    @Override
     protected Object handleGetObject(String aKey) {
         return handleGetObjectImpl(aKey, this);
     }
@@ -1075,15 +900,6 @@ public abstract class UResourceBundle extends ResourceBundle {
         return obj;
     }
 
-    /**
-     * This method is for setting the loading status of the resource.
-     * The status is analogous to the warning status in ICU4C.
-     * @internal
-     * @deprecated This API is ICU internal only.
-     */
-    @Deprecated
-    protected abstract void setLoadingStatus(int newStatus);
-
     /**
      * Is this a top-level resource, that is, a whole bundle?
      * @return true if this is a top-level resource
diff --git a/app/src/main/java/com/ibm/icu/util/UResourceBundleIterator.java b/icu4j/src/main/java/com/ibm/icu/util/UResourceBundleIterator.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/util/UResourceBundleIterator.java
rename to icu4j/src/main/java/com/ibm/icu/util/UResourceBundleIterator.java
index 5193558..6cd1fc4 100644
--- a/app/src/main/java/com/ibm/icu/util/UResourceBundleIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/UResourceBundleIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2004-2009, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/util/UResourceTypeMismatchException.java b/icu4j/src/main/java/com/ibm/icu/util/UResourceTypeMismatchException.java
similarity index 88%
rename from app/src/main/java/com/ibm/icu/util/UResourceTypeMismatchException.java
rename to icu4j/src/main/java/com/ibm/icu/util/UResourceTypeMismatchException.java
index 8f2810b..b0bd18c 100644
--- a/app/src/main/java/com/ibm/icu/util/UResourceTypeMismatchException.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/UResourceTypeMismatchException.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 2004-2006, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/util/UniversalTimeScale.java b/icu4j/src/main/java/com/ibm/icu/util/UniversalTimeScale.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/util/UniversalTimeScale.java
rename to icu4j/src/main/java/com/ibm/icu/util/UniversalTimeScale.java
index 6479058..a62a8b8 100644
--- a/app/src/main/java/com/ibm/icu/util/UniversalTimeScale.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/UniversalTimeScale.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *********************************************************************************
  * Copyright (C) 2004-2016, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/util/VTimeZone.java b/icu4j/src/main/java/com/ibm/icu/util/VTimeZone.java
similarity index 99%
rename from app/src/main/java/com/ibm/icu/util/VTimeZone.java
rename to icu4j/src/main/java/com/ibm/icu/util/VTimeZone.java
index 3aeed4a..9cf441e 100644
--- a/app/src/main/java/com/ibm/icu/util/VTimeZone.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/VTimeZone.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 2007-2015, International Business Machines Corporation and    *
diff --git a/app/src/main/java/com/ibm/icu/util/ValueIterator.java b/icu4j/src/main/java/com/ibm/icu/util/ValueIterator.java
similarity index 96%
rename from app/src/main/java/com/ibm/icu/util/ValueIterator.java
rename to icu4j/src/main/java/com/ibm/icu/util/ValueIterator.java
index c412925..751aacc 100644
--- a/app/src/main/java/com/ibm/icu/util/ValueIterator.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/ValueIterator.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
 ******************************************************************************
 * Copyright (C) 1996-2016, International Business Machines Corporation and   *
diff --git a/app/src/main/java/com/ibm/icu/util/VersionInfo.java b/icu4j/src/main/java/com/ibm/icu/util/VersionInfo.java
similarity index 94%
rename from app/src/main/java/com/ibm/icu/util/VersionInfo.java
rename to icu4j/src/main/java/com/ibm/icu/util/VersionInfo.java
index 3b36d9f..4507286 100644
--- a/app/src/main/java/com/ibm/icu/util/VersionInfo.java
+++ b/icu4j/src/main/java/com/ibm/icu/util/VersionInfo.java
@@ -1,3 +1,5 @@
+// © 2016 and later: Unicode, Inc. and others.
+// License & terms of use: http://www.unicode.org/copyright.html#License
 /*
  *******************************************************************************
  * Copyright (C) 1996-2016, International Business Machines Corporation and
@@ -161,6 +163,12 @@ public final class VersionInfo implements Comparable<VersionInfo>
      */
     public static final VersionInfo UNICODE_8_0;
 
+    /**
+     * Unicode 9.0 version
+     * @stable ICU 58
+     */
+    public static final VersionInfo UNICODE_9_0;
+
     /**
      * ICU4J current release version
      * @stable ICU 2.8
@@ -174,8 +182,8 @@ public final class VersionInfo implements Comparable<VersionInfo>
      * @deprecated This API is ICU internal only.
      */
     @Deprecated
-    public static final String ICU_DATA_VERSION_PATH = "57b";
-    
+    public static final String ICU_DATA_VERSION_PATH = "58b";
+
     /**
      * Data version in ICU4J.
      * @internal
@@ -390,6 +398,7 @@ public final class VersionInfo implements Comparable<VersionInfo>
      * @return String representative of VersionInfo
      * @stable ICU 2.6
      */
+    @Override
     public String toString()
     {
         StringBuilder result = new StringBuilder(7);
@@ -450,11 +459,24 @@ public final class VersionInfo implements Comparable<VersionInfo>
      *         false otherwise
      * @stable ICU 2.6
      */
+    @Override
     public boolean equals(Object other)
     {
         return other == this;
     }
 
+    /**
+     * Returns the hash code value for this set.
+     *
+     * @return the hash code value for this set.
+     * @see java.lang.Object#hashCode()
+     * @stable ICU 58
+     */
+    @Override
+    public int hashCode() {
+        return m_version_;
+    }
+
     /**
      * Compares other with this VersionInfo.
      * @param other VersionInfo to be compared
@@ -466,6 +488,7 @@ public final class VersionInfo implements Comparable<VersionInfo>
      *           has version information less than this object.
      * @stable ICU 2.6
      */
+    @Override
     public int compareTo(VersionInfo other)
     {
         return m_version_ - other.m_version_;
@@ -474,7 +497,11 @@ public final class VersionInfo implements Comparable<VersionInfo>
     // private data members ----------------------------------------------
 
     /**
-     * Unicode data version used by the current release
+     * Unicode data version used by the current release.
+     * Defined here privately for printing by the main() method in this class.
+     * Should be the same as {@link com.ibm.icu.lang.UCharacter#getUnicodeVersion()}
+     * which gets the version number from a data file.
+     * We do not want VersionInfo to have an import dependency on UCharacter.
      */
     private static final VersionInfo UNICODE_VERSION;
 
@@ -531,10 +558,11 @@ public final class VersionInfo implements Comparable<VersionInfo>
         UNICODE_6_3   = getInstance(6, 3, 0, 0);
         UNICODE_7_0   = getInstance(7, 0, 0, 0);
         UNICODE_8_0   = getInstance(8, 0, 0, 0);
+        UNICODE_9_0   = getInstance(9, 0, 0, 0);
 
-        ICU_VERSION   = getInstance(57, 1, 0, 0);
-        ICU_DATA_VERSION = getInstance(57, 1, 0, 0);
-        UNICODE_VERSION = UNICODE_8_0;
+        ICU_VERSION   = getInstance(58, 2, 0, 0);
+        ICU_DATA_VERSION = getInstance(58, 2, 0, 0);
+        UNICODE_VERSION = UNICODE_9_0;
 
         UCOL_RUNTIME_VERSION = getInstance(9);
         UCOL_BUILDER_VERSION = getInstance(9);
