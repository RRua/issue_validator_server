diff --git a/app/libs/Android-PullToRefresh/extras/PullToRefreshListFragment/src/com/handmark/pulltorefresh/extras/listfragment/PullToRefreshBaseListFragment.java b/app/libs/Android-PullToRefresh/extras/PullToRefreshListFragment/src/com/handmark/pulltorefresh/extras/listfragment/PullToRefreshBaseListFragment.java
deleted file mode 100644
index 4350f92..0000000
--- a/app/libs/Android-PullToRefresh/extras/PullToRefreshListFragment/src/com/handmark/pulltorefresh/extras/listfragment/PullToRefreshBaseListFragment.java
+++ /dev/null
@@ -1,68 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.extras.listfragment;
-
-import android.os.Bundle;
-import android.support.v4.app.ListFragment;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.widget.AbsListView;
-import android.widget.ListView;
-
-import com.handmark.pulltorefresh.library.PullToRefreshBase;
-
-abstract class PullToRefreshBaseListFragment<T extends PullToRefreshBase<? extends AbsListView>> extends ListFragment {
-
-	private T mPullToRefreshListView;
-
-	@Override
-	public final View onCreateView(LayoutInflater inflater, ViewGroup container, Bundle savedInstanceState) {
-		View layout = super.onCreateView(inflater, container, savedInstanceState);
-
-		ListView lv = (ListView) layout.findViewById(android.R.id.list);
-		ViewGroup parent = (ViewGroup) lv.getParent();
-
-		// Remove ListView and add PullToRefreshListView in its place
-		int lvIndex = parent.indexOfChild(lv);
-		parent.removeViewAt(lvIndex);
-		mPullToRefreshListView = onCreatePullToRefreshListView(inflater, savedInstanceState);
-		parent.addView(mPullToRefreshListView, lvIndex, lv.getLayoutParams());
-
-		return layout;
-	}
-
-	/**
-	 * @return The {@link PullToRefreshBase} attached to this ListFragment.
-	 */
-	public final T getPullToRefreshListView() {
-		return mPullToRefreshListView;
-	}
-
-	/**
-	 * Returns the {@link PullToRefreshBase} which will replace the ListView
-	 * created from ListFragment. You should override this method if you wish to
-	 * customise the {@link PullToRefreshBase} from the default.
-	 * 
-	 * @param inflater - LayoutInflater which can be used to inflate from XML.
-	 * @param savedInstanceState - Bundle passed through from
-	 *            {@link ListFragment#onCreateView(LayoutInflater, ViewGroup, Bundle)
-	 *            onCreateView(...)}
-	 * @return The {@link PullToRefreshBase} which will replace the ListView.
-	 */
-	protected abstract T onCreatePullToRefreshListView(LayoutInflater inflater, Bundle savedInstanceState);
-
-}
\ No newline at end of file
diff --git a/app/libs/Android-PullToRefresh/extras/PullToRefreshListFragment/src/com/handmark/pulltorefresh/extras/listfragment/PullToRefreshExpandableListFragment.java b/app/libs/Android-PullToRefresh/extras/PullToRefreshListFragment/src/com/handmark/pulltorefresh/extras/listfragment/PullToRefreshExpandableListFragment.java
deleted file mode 100644
index aca73a3..0000000
--- a/app/libs/Android-PullToRefresh/extras/PullToRefreshListFragment/src/com/handmark/pulltorefresh/extras/listfragment/PullToRefreshExpandableListFragment.java
+++ /dev/null
@@ -1,46 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.extras.listfragment;
-
-import android.os.Bundle;
-import android.support.v4.app.ListFragment;
-import android.view.LayoutInflater;
-
-import com.handmark.pulltorefresh.library.PullToRefreshExpandableListView;
-
-/**
- * A sample implementation of how to use {@link PullToRefreshExpandableListView}
- * with {@link ListFragment}. This implementation simply replaces the ListView
- * that {@code ListFragment} creates with a new
- * {@code PullToRefreshExpandableListView}. This means that ListFragment still
- * works 100% (e.g. <code>setListShown(...)</code> ).
- * <p/>
- * The new PullToRefreshListView is created in the method
- * {@link #onCreatePullToRefreshListView(LayoutInflater, Bundle)}. If you wish
- * to customise the {@code PullToRefreshExpandableListView} then override this
- * method and return your customised instance.
- * 
- * @author Chris Banes
- * 
- */
-public class PullToRefreshExpandableListFragment extends PullToRefreshBaseListFragment<PullToRefreshExpandableListView> {
-
-	protected PullToRefreshExpandableListView onCreatePullToRefreshListView(LayoutInflater inflater,
-			Bundle savedInstanceState) {
-		return new PullToRefreshExpandableListView(getActivity());
-	}
-
-}
\ No newline at end of file
diff --git a/app/libs/Android-PullToRefresh/extras/PullToRefreshListFragment/src/com/handmark/pulltorefresh/extras/listfragment/PullToRefreshListFragment.java b/app/libs/Android-PullToRefresh/extras/PullToRefreshListFragment/src/com/handmark/pulltorefresh/extras/listfragment/PullToRefreshListFragment.java
deleted file mode 100644
index e544797..0000000
--- a/app/libs/Android-PullToRefresh/extras/PullToRefreshListFragment/src/com/handmark/pulltorefresh/extras/listfragment/PullToRefreshListFragment.java
+++ /dev/null
@@ -1,44 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.extras.listfragment;
-
-import android.os.Bundle;
-import android.support.v4.app.ListFragment;
-import android.view.LayoutInflater;
-
-import com.handmark.pulltorefresh.library.PullToRefreshListView;
-
-/**
- * A sample implementation of how to use {@link PullToRefreshListView} with
- * {@link ListFragment}. This implementation simply replaces the ListView that
- * {@code ListFragment} creates with a new PullToRefreshListView. This means
- * that ListFragment still works 100% (e.g. <code>setListShown(...)</code> ).
- * <p/>
- * The new PullToRefreshListView is created in the method
- * {@link #onCreatePullToRefreshListView(LayoutInflater, Bundle)}. If you wish
- * to customise the {@code PullToRefreshListView} then override this method and
- * return your customised instance.
- * 
- * @author Chris Banes
- * 
- */
-public class PullToRefreshListFragment extends PullToRefreshBaseListFragment<PullToRefreshListView> {
-
-	protected PullToRefreshListView onCreatePullToRefreshListView(LayoutInflater inflater, Bundle savedInstanceState) {
-		return new PullToRefreshListView(getActivity());
-	}
-
-}
\ No newline at end of file
diff --git a/app/libs/Android-PullToRefresh/extras/PullToRefreshViewPager/src/com/handmark/pulltorefresh/extras/viewpager/PullToRefreshViewPager.java b/app/libs/Android-PullToRefresh/extras/PullToRefreshViewPager/src/com/handmark/pulltorefresh/extras/viewpager/PullToRefreshViewPager.java
deleted file mode 100644
index d5f845b..0000000
--- a/app/libs/Android-PullToRefresh/extras/PullToRefreshViewPager/src/com/handmark/pulltorefresh/extras/viewpager/PullToRefreshViewPager.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.extras.viewpager;
-
-import android.content.Context;
-import android.support.v4.view.PagerAdapter;
-import android.support.v4.view.ViewPager;
-import android.util.AttributeSet;
-
-import com.handmark.pulltorefresh.library.PullToRefreshBase;
-
-public class PullToRefreshViewPager extends PullToRefreshBase<ViewPager> {
-
-	public PullToRefreshViewPager(Context context) {
-		super(context);
-	}
-
-	public PullToRefreshViewPager(Context context, AttributeSet attrs) {
-		super(context, attrs);
-	}
-
-	@Override
-	public final Orientation getPullToRefreshScrollDirection() {
-		return Orientation.HORIZONTAL;
-	}
-
-	@Override
-	protected ViewPager createRefreshableView(Context context, AttributeSet attrs) {
-		ViewPager viewPager = new ViewPager(context, attrs);
-		viewPager.setId(R.id.viewpager);
-		return viewPager;
-	}
-
-	@Override
-	protected boolean isReadyForPullStart() {
-		ViewPager refreshableView = getRefreshableView();
-
-		PagerAdapter adapter = refreshableView.getAdapter();
-		if (null != adapter) {
-			return refreshableView.getCurrentItem() == 0;
-		}
-
-		return false;
-	}
-
-	@Override
-	protected boolean isReadyForPullEnd() {
-		ViewPager refreshableView = getRefreshableView();
-
-		PagerAdapter adapter = refreshableView.getAdapter();
-		if (null != adapter) {
-			return refreshableView.getCurrentItem() == adapter.getCount() - 1;
-		}
-
-		return false;
-	}
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/ILoadingLayout.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/ILoadingLayout.java
deleted file mode 100644
index ff2a957..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/ILoadingLayout.java
+++ /dev/null
@@ -1,57 +0,0 @@
-package com.handmark.pulltorefresh.library;
-
-import android.graphics.Typeface;
-import android.graphics.drawable.Drawable;
-
-public interface ILoadingLayout {
-
-	/**
-	 * Set the Last Updated Text. This displayed under the main label when
-	 * Pulling
-	 * 
-	 * @param label - Label to set
-	 */
-	public void setLastUpdatedLabel(CharSequence label);
-
-	/**
-	 * Set the drawable used in the loading layout. This is the same as calling
-	 * <code>setLoadingDrawable(drawable, Mode.BOTH)</code>
-	 * 
-	 * @param drawable - Drawable to display
-	 */
-	public void setLoadingDrawable(Drawable drawable);
-
-	/**
-	 * Set Text to show when the Widget is being Pulled
-	 * <code>setPullLabel(releaseLabel, Mode.BOTH)</code>
-	 * 
-	 * @param pullLabel - CharSequence to display
-	 */
-	public void setPullLabel(CharSequence pullLabel);
-
-	/**
-	 * Set Text to show when the Widget is refreshing
-	 * <code>setRefreshingLabel(releaseLabel, Mode.BOTH)</code>
-	 * 
-	 * @param refreshingLabel - CharSequence to display
-	 */
-	public void setRefreshingLabel(CharSequence refreshingLabel);
-
-	/**
-	 * Set Text to show when the Widget is being pulled, and will refresh when
-	 * released. This is the same as calling
-	 * <code>setReleaseLabel(releaseLabel, Mode.BOTH)</code>
-	 * 
-	 * @param releaseLabel - CharSequence to display
-	 */
-	public void setReleaseLabel(CharSequence releaseLabel);
-
-	/**
-	 * Set's the Sets the typeface and style in which the text should be
-	 * displayed. Please see
-	 * {@link android.widget.TextView#setTypeface(Typeface)
-	 * TextView#setTypeface(Typeface)}.
-	 */
-	public void setTextTypeface(Typeface tf);
-
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/IPullToRefresh.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/IPullToRefresh.java
deleted file mode 100644
index a06cdd7..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/IPullToRefresh.java
+++ /dev/null
@@ -1,246 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.library;
-
-import android.view.View;
-import android.view.animation.Interpolator;
-
-import com.handmark.pulltorefresh.library.PullToRefreshBase.Mode;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.OnPullEventListener;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.OnRefreshListener;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.OnRefreshListener2;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.State;
-
-public interface IPullToRefresh<T extends View> {
-
-	/**
-	 * Demos the Pull-to-Refresh functionality to the user so that they are
-	 * aware it is there. This could be useful when the user first opens your
-	 * app, etc. The animation will only happen if the Refresh View (ListView,
-	 * ScrollView, etc) is in a state where a Pull-to-Refresh could occur by a
-	 * user's touch gesture (i.e. scrolled to the top/bottom).
-	 * 
-	 * @return true - if the Demo has been started, false if not.
-	 */
-	public boolean demo();
-
-	/**
-	 * Get the mode that this view is currently in. This is only really useful
-	 * when using <code>Mode.BOTH</code>.
-	 * 
-	 * @return Mode that the view is currently in
-	 */
-	public Mode getCurrentMode();
-
-	/**
-	 * Returns whether the Touch Events are filtered or not. If true is
-	 * returned, then the View will only use touch events where the difference
-	 * in the Y-axis is greater than the difference in the X-axis. This means
-	 * that the View will not interfere when it is used in a horizontal
-	 * scrolling View (such as a ViewPager).
-	 * 
-	 * @return boolean - true if the View is filtering Touch Events
-	 */
-	public boolean getFilterTouchEvents();
-
-	/**
-	 * Returns a proxy object which allows you to call methods on all of the
-	 * LoadingLayouts (the Views which show when Pulling/Refreshing).
-	 * <p />
-	 * You should not keep the result of this method any longer than you need
-	 * it.
-	 * 
-	 * @return Object which will proxy any calls you make on it, to all of the
-	 *         LoadingLayouts.
-	 */
-	public ILoadingLayout getLoadingLayoutProxy();
-
-	/**
-	 * Returns a proxy object which allows you to call methods on the
-	 * LoadingLayouts (the Views which show when Pulling/Refreshing). The actual
-	 * LoadingLayout(s) which will be affected, are chosen by the parameters you
-	 * give.
-	 * <p />
-	 * You should not keep the result of this method any longer than you need
-	 * it.
-	 * 
-	 * @param includeStart - Whether to include the Start/Header Views
-	 * @param includeEnd - Whether to include the End/Footer Views
-	 * @return Object which will proxy any calls you make on it, to the
-	 *         LoadingLayouts included.
-	 */
-	public ILoadingLayout getLoadingLayoutProxy(boolean includeStart, boolean includeEnd);
-
-	/**
-	 * Get the mode that this view has been set to. If this returns
-	 * <code>Mode.BOTH</code>, you can use <code>getCurrentMode()</code> to
-	 * check which mode the view is currently in
-	 * 
-	 * @return Mode that the view has been set to
-	 */
-	public Mode getMode();
-
-	/**
-	 * Get the Wrapped Refreshable View. Anything returned here has already been
-	 * added to the content view.
-	 * 
-	 * @return The View which is currently wrapped
-	 */
-	public T getRefreshableView();
-
-	/**
-	 * Get whether the 'Refreshing' View should be automatically shown when
-	 * refreshing. Returns true by default.
-	 * 
-	 * @return - true if the Refreshing View will be show
-	 */
-	public boolean getShowViewWhileRefreshing();
-
-	/**
-	 * @return - The state that the View is currently in.
-	 */
-	public State getState();
-
-	/**
-	 * Whether Pull-to-Refresh is enabled
-	 * 
-	 * @return enabled
-	 */
-	public boolean isPullToRefreshEnabled();
-
-	/**
-	 * Gets whether Overscroll support is enabled. This is different to
-	 * Android's standard Overscroll support (the edge-glow) which is available
-	 * from GINGERBREAD onwards
-	 * 
-	 * @return true - if both PullToRefresh-OverScroll and Android's inbuilt
-	 *         OverScroll are enabled
-	 */
-	public boolean isPullToRefreshOverScrollEnabled();
-
-	/**
-	 * Returns whether the Widget is currently in the Refreshing mState
-	 * 
-	 * @return true if the Widget is currently refreshing
-	 */
-	public boolean isRefreshing();
-
-	/**
-	 * Returns whether the widget has enabled scrolling on the Refreshable View
-	 * while refreshing.
-	 * 
-	 * @return true if the widget has enabled scrolling while refreshing
-	 */
-	public boolean isScrollingWhileRefreshingEnabled();
-
-	/**
-	 * Mark the current Refresh as complete. Will Reset the UI and hide the
-	 * Refreshing View
-	 */
-	public void onRefreshComplete();
-
-	/**
-	 * Set the Touch Events to be filtered or not. If set to true, then the View
-	 * will only use touch events where the difference in the Y-axis is greater
-	 * than the difference in the X-axis. This means that the View will not
-	 * interfere when it is used in a horizontal scrolling View (such as a
-	 * ViewPager), but will restrict which types of finger scrolls will trigger
-	 * the View.
-	 * 
-	 * @param filterEvents - true if you want to filter Touch Events. Default is
-	 *            true.
-	 */
-	public void setFilterTouchEvents(boolean filterEvents);
-
-	/**
-	 * Set the mode of Pull-to-Refresh that this view will use.
-	 * 
-	 * @param mode - Mode to set the View to
-	 */
-	public void setMode(Mode mode);
-
-	/**
-	 * Set OnPullEventListener for the Widget
-	 * 
-	 * @param listener - Listener to be used when the Widget has a pull event to
-	 *            propogate.
-	 */
-	public void setOnPullEventListener(OnPullEventListener<T> listener);
-
-	/**
-	 * Set OnRefreshListener for the Widget
-	 * 
-	 * @param listener - Listener to be used when the Widget is set to Refresh
-	 */
-	public void setOnRefreshListener(OnRefreshListener<T> listener);
-
-	/**
-	 * Set OnRefreshListener for the Widget
-	 * 
-	 * @param listener - Listener to be used when the Widget is set to Refresh
-	 */
-	public void setOnRefreshListener(OnRefreshListener2<T> listener);
-
-	/**
-	 * Sets whether Overscroll support is enabled. This is different to
-	 * Android's standard Overscroll support (the edge-glow). This setting only
-	 * takes effect when running on device with Android v2.3 or greater.
-	 * 
-	 * @param enabled - true if you want Overscroll enabled
-	 */
-	public void setPullToRefreshOverScrollEnabled(boolean enabled);
-
-	/**
-	 * Sets the Widget to be in the refresh state. The UI will be updated to
-	 * show the 'Refreshing' view, and be scrolled to show such.
-	 */
-	public void setRefreshing();
-
-	/**
-	 * Sets the Widget to be in the refresh state. The UI will be updated to
-	 * show the 'Refreshing' view.
-	 * 
-	 * @param doScroll - true if you want to force a scroll to the Refreshing
-	 *            view.
-	 */
-	public void setRefreshing(boolean doScroll);
-
-	/**
-	 * Sets the Animation Interpolator that is used for animated scrolling.
-	 * Defaults to a DecelerateInterpolator
-	 * 
-	 * @param interpolator - Interpolator to use
-	 */
-	public void setScrollAnimationInterpolator(Interpolator interpolator);
-
-	/**
-	 * By default the Widget disables scrolling on the Refreshable View while
-	 * refreshing. This method can change this behaviour.
-	 * 
-	 * @param scrollingWhileRefreshingEnabled - true if you want to enable
-	 *            scrolling while refreshing
-	 */
-	public void setScrollingWhileRefreshingEnabled(boolean scrollingWhileRefreshingEnabled);
-
-	/**
-	 * A mutator to enable/disable whether the 'Refreshing' View should be
-	 * automatically shown when refreshing.
-	 * 
-	 * @param showView
-	 */
-	public void setShowViewWhileRefreshing(boolean showView);
-
-}
\ No newline at end of file
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/LoadingLayoutProxy.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/LoadingLayoutProxy.java
deleted file mode 100644
index 5f76645..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/LoadingLayoutProxy.java
+++ /dev/null
@@ -1,73 +0,0 @@
-package com.handmark.pulltorefresh.library;
-
-import java.util.HashSet;
-
-import android.graphics.Typeface;
-import android.graphics.drawable.Drawable;
-
-import com.handmark.pulltorefresh.library.internal.LoadingLayout;
-
-public class LoadingLayoutProxy implements ILoadingLayout {
-
-	private final HashSet<LoadingLayout> mLoadingLayouts;
-
-	LoadingLayoutProxy() {
-		mLoadingLayouts = new HashSet<LoadingLayout>();
-	}
-
-	/**
-	 * This allows you to add extra LoadingLayout instances to this proxy. This
-	 * is only necessary if you keep your own instances, and want to have them
-	 * included in any
-	 * {@link PullToRefreshBase#createLoadingLayoutProxy(boolean, boolean)
-	 * createLoadingLayoutProxy(...)} calls.
-	 * 
-	 * @param layout - LoadingLayout to have included.
-	 */
-	public void addLayout(LoadingLayout layout) {
-		if (null != layout) {
-			mLoadingLayouts.add(layout);
-		}
-	}
-
-	@Override
-	public void setLastUpdatedLabel(CharSequence label) {
-		for (LoadingLayout layout : mLoadingLayouts) {
-			layout.setLastUpdatedLabel(label);
-		}
-	}
-
-	@Override
-	public void setLoadingDrawable(Drawable drawable) {
-		for (LoadingLayout layout : mLoadingLayouts) {
-			layout.setLoadingDrawable(drawable);
-		}
-	}
-
-	@Override
-	public void setRefreshingLabel(CharSequence refreshingLabel) {
-		for (LoadingLayout layout : mLoadingLayouts) {
-			layout.setRefreshingLabel(refreshingLabel);
-		}
-	}
-
-	@Override
-	public void setPullLabel(CharSequence label) {
-		for (LoadingLayout layout : mLoadingLayouts) {
-			layout.setPullLabel(label);
-		}
-	}
-
-	@Override
-	public void setReleaseLabel(CharSequence label) {
-		for (LoadingLayout layout : mLoadingLayouts) {
-			layout.setReleaseLabel(label);
-		}
-	}
-
-	public void setTextTypeface(Typeface tf) {
-		for (LoadingLayout layout : mLoadingLayouts) {
-			layout.setTextTypeface(tf);
-		}
-	}
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/OverscrollHelper.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/OverscrollHelper.java
deleted file mode 100644
index 52a20de..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/OverscrollHelper.java
+++ /dev/null
@@ -1,178 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.library;
-
-import android.annotation.TargetApi;
-import android.util.Log;
-import android.view.View;
-
-import com.handmark.pulltorefresh.library.PullToRefreshBase.Mode;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.State;
-
-@TargetApi(9)
-public final class OverscrollHelper {
-
-	static final String LOG_TAG = "OverscrollHelper";
-	static final float DEFAULT_OVERSCROLL_SCALE = 1f;
-
-	/**
-	 * Helper method for Overscrolling that encapsulates all of the necessary
-	 * function.
-	 * <p/>
-	 * This should only be used on AdapterView's such as ListView as it just
-	 * calls through to overScrollBy() with the scrollRange = 0. AdapterView's
-	 * do not have a scroll range (i.e. getScrollY() doesn't work).
-	 * 
-	 * @param view - PullToRefreshView that is calling this.
-	 * @param deltaX - Change in X in pixels, passed through from from
-	 *            overScrollBy call
-	 * @param scrollX - Current X scroll value in pixels before applying deltaY,
-	 *            passed through from from overScrollBy call
-	 * @param deltaY - Change in Y in pixels, passed through from from
-	 *            overScrollBy call
-	 * @param scrollY - Current Y scroll value in pixels before applying deltaY,
-	 *            passed through from from overScrollBy call
-	 * @param isTouchEvent - true if this scroll operation is the result of a
-	 *            touch event, passed through from from overScrollBy call
-	 */
-	public static void overScrollBy(final PullToRefreshBase<?> view, final int deltaX, final int scrollX,
-			final int deltaY, final int scrollY, final boolean isTouchEvent) {
-		overScrollBy(view, deltaX, scrollX, deltaY, scrollY, 0, isTouchEvent);
-	}
-
-	/**
-	 * Helper method for Overscrolling that encapsulates all of the necessary
-	 * function. This version of the call is used for Views that need to specify
-	 * a Scroll Range but scroll back to it's edge correctly.
-	 * 
-	 * @param view - PullToRefreshView that is calling this.
-	 * @param deltaX - Change in X in pixels, passed through from from
-	 *            overScrollBy call
-	 * @param scrollX - Current X scroll value in pixels before applying deltaY,
-	 *            passed through from from overScrollBy call
-	 * @param deltaY - Change in Y in pixels, passed through from from
-	 *            overScrollBy call
-	 * @param scrollY - Current Y scroll value in pixels before applying deltaY,
-	 *            passed through from from overScrollBy call
-	 * @param scrollRange - Scroll Range of the View, specifically needed for
-	 *            ScrollView
-	 * @param isTouchEvent - true if this scroll operation is the result of a
-	 *            touch event, passed through from from overScrollBy call
-	 */
-	public static void overScrollBy(final PullToRefreshBase<?> view, final int deltaX, final int scrollX,
-			final int deltaY, final int scrollY, final int scrollRange, final boolean isTouchEvent) {
-		overScrollBy(view, deltaX, scrollX, deltaY, scrollY, scrollRange, 0, DEFAULT_OVERSCROLL_SCALE, isTouchEvent);
-	}
-
-	/**
-	 * Helper method for Overscrolling that encapsulates all of the necessary
-	 * function. This is the advanced version of the call.
-	 * 
-	 * @param view - PullToRefreshView that is calling this.
-	 * @param deltaX - Change in X in pixels, passed through from from
-	 *            overScrollBy call
-	 * @param scrollX - Current X scroll value in pixels before applying deltaY,
-	 *            passed through from from overScrollBy call
-	 * @param deltaY - Change in Y in pixels, passed through from from
-	 *            overScrollBy call
-	 * @param scrollY - Current Y scroll value in pixels before applying deltaY,
-	 *            passed through from from overScrollBy call
-	 * @param scrollRange - Scroll Range of the View, specifically needed for
-	 *            ScrollView
-	 * @param fuzzyThreshold - Threshold for which the values how fuzzy we
-	 *            should treat the other values. Needed for WebView as it
-	 *            doesn't always scroll back to it's edge. 0 = no fuzziness.
-	 * @param scaleFactor - Scale Factor for overscroll amount
-	 * @param isTouchEvent - true if this scroll operation is the result of a
-	 *            touch event, passed through from from overScrollBy call
-	 */
-	public static void overScrollBy(final PullToRefreshBase<?> view, final int deltaX, final int scrollX,
-			final int deltaY, final int scrollY, final int scrollRange, final int fuzzyThreshold,
-			final float scaleFactor, final boolean isTouchEvent) {
-
-		final int deltaValue, currentScrollValue, scrollValue;
-		switch (view.getPullToRefreshScrollDirection()) {
-			case HORIZONTAL:
-				deltaValue = deltaX;
-				scrollValue = scrollX;
-				currentScrollValue = view.getScrollX();
-				break;
-			case VERTICAL:
-			default:
-				deltaValue = deltaY;
-				scrollValue = scrollY;
-				currentScrollValue = view.getScrollY();
-				break;
-		}
-
-		// Check that OverScroll is enabled and that we're not currently
-		// refreshing.
-		if (view.isPullToRefreshOverScrollEnabled() && !view.isRefreshing()) {
-			final Mode mode = view.getMode();
-
-			// Check that Pull-to-Refresh is enabled, and the event isn't from
-			// touch
-			if (mode.permitsPullToRefresh() && !isTouchEvent && deltaValue != 0) {
-				final int newScrollValue = (deltaValue + scrollValue);
-
-				if (PullToRefreshBase.DEBUG) {
-					Log.d(LOG_TAG, "OverScroll. DeltaX: " + deltaX + ", ScrollX: " + scrollX + ", DeltaY: " + deltaY
-							+ ", ScrollY: " + scrollY + ", NewY: " + newScrollValue + ", ScrollRange: " + scrollRange
-							+ ", CurrentScroll: " + currentScrollValue);
-				}
-
-				if (newScrollValue < (0 - fuzzyThreshold)) {
-					// Check the mode supports the overscroll direction, and
-					// then move scroll
-					if (mode.showHeaderLoadingLayout()) {
-						// If we're currently at zero, we're about to start
-						// overscrolling, so change the state
-						if (currentScrollValue == 0) {
-							view.setState(State.OVERSCROLLING);
-						}
-
-						view.setHeaderScroll((int) (scaleFactor * (currentScrollValue + newScrollValue)));
-					}
-				} else if (newScrollValue > (scrollRange + fuzzyThreshold)) {
-					// Check the mode supports the overscroll direction, and
-					// then move scroll
-					if (mode.showFooterLoadingLayout()) {
-						// If we're currently at zero, we're about to start
-						// overscrolling, so change the state
-						if (currentScrollValue == 0) {
-							view.setState(State.OVERSCROLLING);
-						}
-
-						view.setHeaderScroll((int) (scaleFactor * (currentScrollValue + newScrollValue - scrollRange)));
-					}
-				} else if (Math.abs(newScrollValue) <= fuzzyThreshold
-						|| Math.abs(newScrollValue - scrollRange) <= fuzzyThreshold) {
-					// Means we've stopped overscrolling, so scroll back to 0
-					view.setState(State.RESET);
-				}
-			} else if (isTouchEvent && State.OVERSCROLLING == view.getState()) {
-				// This condition means that we were overscrolling from a fling,
-				// but the user has touched the View and is now overscrolling
-				// from touch instead. We need to just reset.
-				view.setState(State.RESET);
-			}
-		}
-	}
-
-	static boolean isAndroidOverScrollEnabled(View view) {
-		return view.getOverScrollMode() != View.OVER_SCROLL_NEVER;
-	}
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshAdapterViewBase.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshAdapterViewBase.java
deleted file mode 100644
index cfff837..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshAdapterViewBase.java
+++ /dev/null
@@ -1,475 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.library;
-
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.Gravity;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.ViewParent;
-import android.widget.AbsListView;
-import android.widget.AbsListView.OnScrollListener;
-import android.widget.Adapter;
-import android.widget.AdapterView;
-import android.widget.AdapterView.OnItemClickListener;
-import android.widget.FrameLayout;
-import android.widget.LinearLayout;
-import android.widget.ListAdapter;
-
-import com.handmark.pulltorefresh.library.internal.EmptyViewMethodAccessor;
-import com.handmark.pulltorefresh.library.internal.IndicatorLayout;
-
-public abstract class PullToRefreshAdapterViewBase<T extends AbsListView> extends PullToRefreshBase<T> implements
-		OnScrollListener {
-
-	private static FrameLayout.LayoutParams convertEmptyViewLayoutParams(ViewGroup.LayoutParams lp) {
-		FrameLayout.LayoutParams newLp = null;
-
-		if (null != lp) {
-			newLp = new FrameLayout.LayoutParams(lp);
-
-			if (lp instanceof LinearLayout.LayoutParams) {
-				newLp.gravity = ((LinearLayout.LayoutParams) lp).gravity;
-			} else {
-				newLp.gravity = Gravity.CENTER;
-			}
-		}
-
-		return newLp;
-	}
-
-	private boolean mLastItemVisible;
-	private OnScrollListener mOnScrollListener;
-	private OnLastItemVisibleListener mOnLastItemVisibleListener;
-	private View mEmptyView;
-
-	private IndicatorLayout mIndicatorIvTop;
-	private IndicatorLayout mIndicatorIvBottom;
-
-	private boolean mShowIndicator;
-	private boolean mScrollEmptyView = true;
-
-	public PullToRefreshAdapterViewBase(Context context) {
-		super(context);
-		mRefreshableView.setOnScrollListener(this);
-	}
-
-	public PullToRefreshAdapterViewBase(Context context, AttributeSet attrs) {
-		super(context, attrs);
-		mRefreshableView.setOnScrollListener(this);
-	}
-
-	public PullToRefreshAdapterViewBase(Context context, Mode mode) {
-		super(context, mode);
-		mRefreshableView.setOnScrollListener(this);
-	}
-
-	public PullToRefreshAdapterViewBase(Context context, Mode mode, AnimationStyle animStyle) {
-		super(context, mode, animStyle);
-		mRefreshableView.setOnScrollListener(this);
-	}
-
-	/**
-	 * Gets whether an indicator graphic should be displayed when the View is in
-	 * a state where a Pull-to-Refresh can happen. An example of this state is
-	 * when the Adapter View is scrolled to the top and the mode is set to
-	 * {@link Mode#PULL_FROM_START}. The default value is <var>true</var> if
-	 * {@link PullToRefreshBase#isPullToRefreshOverScrollEnabled()
-	 * isPullToRefreshOverScrollEnabled()} returns false.
-	 * 
-	 * @return true if the indicators will be shown
-	 */
-	public boolean getShowIndicator() {
-		return mShowIndicator;
-	}
-
-	public final void onScroll(final AbsListView view, final int firstVisibleItem, final int visibleItemCount,
-			final int totalItemCount) {
-
-		if (DEBUG) {
-			Log.d(LOG_TAG, "First Visible: " + firstVisibleItem + ". Visible Count: " + visibleItemCount
-					+ ". Total Items:" + totalItemCount);
-		}
-
-		/**
-		 * Set whether the Last Item is Visible. lastVisibleItemIndex is a
-		 * zero-based index, so we minus one totalItemCount to check
-		 */
-		if (null != mOnLastItemVisibleListener) {
-			mLastItemVisible = (totalItemCount > 0) && (firstVisibleItem + visibleItemCount >= totalItemCount - 1);
-		}
-
-		// If we're showing the indicator, check positions...
-		if (getShowIndicatorInternal()) {
-			updateIndicatorViewsVisibility();
-		}
-
-		// Finally call OnScrollListener if we have one
-		if (null != mOnScrollListener) {
-			mOnScrollListener.onScroll(view, firstVisibleItem, visibleItemCount, totalItemCount);
-		}
-	}
-
-	public final void onScrollStateChanged(final AbsListView view, final int state) {
-		/**
-		 * Check that the scrolling has stopped, and that the last item is
-		 * visible.
-		 */
-		if (state == OnScrollListener.SCROLL_STATE_IDLE && null != mOnLastItemVisibleListener && mLastItemVisible) {
-			mOnLastItemVisibleListener.onLastItemVisible();
-		}
-
-		if (null != mOnScrollListener) {
-			mOnScrollListener.onScrollStateChanged(view, state);
-		}
-	}
-
-	/**
-	 * Pass-through method for {@link PullToRefreshBase#getRefreshableView()
-	 * getRefreshableView()}.
-	 * {@link AdapterView#setAdapter(android.widget.Adapter)}
-	 * setAdapter(adapter)}. This is just for convenience!
-	 * 
-	 * @param adapter - Adapter to set
-	 */
-	public void setAdapter(ListAdapter adapter) {
-		((AdapterView<ListAdapter>) mRefreshableView).setAdapter(adapter);
-	}
-
-	/**
-	 * Sets the Empty View to be used by the Adapter View.
-	 * <p/>
-	 * We need it handle it ourselves so that we can Pull-to-Refresh when the
-	 * Empty View is shown.
-	 * <p/>
-	 * Please note, you do <strong>not</strong> usually need to call this method
-	 * yourself. Calling setEmptyView on the AdapterView will automatically call
-	 * this method and set everything up. This includes when the Android
-	 * Framework automatically sets the Empty View based on it's ID.
-	 * 
-	 * @param newEmptyView - Empty View to be used
-	 */
-	public final void setEmptyView(View newEmptyView) {
-		FrameLayout refreshableViewWrapper = getRefreshableViewWrapper();
-
-		if (null != newEmptyView) {
-			// New view needs to be clickable so that Android recognizes it as a
-			// target for Touch Events
-			newEmptyView.setClickable(true);
-
-			ViewParent newEmptyViewParent = newEmptyView.getParent();
-			if (null != newEmptyViewParent && newEmptyViewParent instanceof ViewGroup) {
-				((ViewGroup) newEmptyViewParent).removeView(newEmptyView);
-			}
-
-			// We need to convert any LayoutParams so that it works in our
-			// FrameLayout
-			FrameLayout.LayoutParams lp = convertEmptyViewLayoutParams(newEmptyView.getLayoutParams());
-			if (null != lp) {
-				refreshableViewWrapper.addView(newEmptyView, lp);
-			} else {
-				refreshableViewWrapper.addView(newEmptyView);
-			}
-		}
-
-		if (mRefreshableView instanceof EmptyViewMethodAccessor) {
-			((EmptyViewMethodAccessor) mRefreshableView).setEmptyViewInternal(newEmptyView);
-		} else {
-			mRefreshableView.setEmptyView(newEmptyView);
-		}
-		mEmptyView = newEmptyView;
-	}
-
-	/**
-	 * Pass-through method for {@link PullToRefreshBase#getRefreshableView()
-	 * getRefreshableView()}.
-	 * {@link AdapterView#setOnItemClickListener(OnItemClickListener)
-	 * setOnItemClickListener(listener)}. This is just for convenience!
-	 * 
-	 * @param listener - OnItemClickListener to use
-	 */
-	public void setOnItemClickListener(OnItemClickListener listener) {
-		mRefreshableView.setOnItemClickListener(listener);
-	}
-
-	public final void setOnLastItemVisibleListener(OnLastItemVisibleListener listener) {
-		mOnLastItemVisibleListener = listener;
-	}
-
-	public final void setOnScrollListener(OnScrollListener listener) {
-		mOnScrollListener = listener;
-	}
-
-	public final void setScrollEmptyView(boolean doScroll) {
-		mScrollEmptyView = doScroll;
-	}
-
-	/**
-	 * Sets whether an indicator graphic should be displayed when the View is in
-	 * a state where a Pull-to-Refresh can happen. An example of this state is
-	 * when the Adapter View is scrolled to the top and the mode is set to
-	 * {@link Mode#PULL_FROM_START}
-	 * 
-	 * @param showIndicator - true if the indicators should be shown.
-	 */
-	public void setShowIndicator(boolean showIndicator) {
-		mShowIndicator = showIndicator;
-
-		if (getShowIndicatorInternal()) {
-			// If we're set to Show Indicator, add/update them
-			addIndicatorViews();
-		} else {
-			// If not, then remove then
-			removeIndicatorViews();
-		}
-	}
-
-	;
-
-	@Override
-	protected void onPullToRefresh() {
-		super.onPullToRefresh();
-
-		if (getShowIndicatorInternal()) {
-			switch (getCurrentMode()) {
-				case PULL_FROM_END:
-					mIndicatorIvBottom.pullToRefresh();
-					break;
-				case PULL_FROM_START:
-					mIndicatorIvTop.pullToRefresh();
-					break;
-				default:
-					// NO-OP
-					break;
-			}
-		}
-	}
-
-	protected void onRefreshing(boolean doScroll) {
-		super.onRefreshing(doScroll);
-
-		if (getShowIndicatorInternal()) {
-			updateIndicatorViewsVisibility();
-		}
-	}
-
-	@Override
-	protected void onReleaseToRefresh() {
-		super.onReleaseToRefresh();
-
-		if (getShowIndicatorInternal()) {
-			switch (getCurrentMode()) {
-				case PULL_FROM_END:
-					mIndicatorIvBottom.releaseToRefresh();
-					break;
-				case PULL_FROM_START:
-					mIndicatorIvTop.releaseToRefresh();
-					break;
-				default:
-					// NO-OP
-					break;
-			}
-		}
-	}
-
-	@Override
-	protected void onReset() {
-		super.onReset();
-
-		if (getShowIndicatorInternal()) {
-			updateIndicatorViewsVisibility();
-		}
-	}
-
-	@Override
-	protected void handleStyledAttributes(TypedArray a) {
-		// Set Show Indicator to the XML value, or default value
-		mShowIndicator = a.getBoolean(R.styleable.PullToRefresh_ptrShowIndicator, !isPullToRefreshOverScrollEnabled());
-	}
-
-	protected boolean isReadyForPullStart() {
-		return isFirstItemVisible();
-	}
-
-	protected boolean isReadyForPullEnd() {
-		return isLastItemVisible();
-	}
-
-	@Override
-	protected void onScrollChanged(int l, int t, int oldl, int oldt) {
-		super.onScrollChanged(l, t, oldl, oldt);
-		if (null != mEmptyView && !mScrollEmptyView) {
-			mEmptyView.scrollTo(-l, -t);
-		}
-	}
-
-	@Override
-	protected void updateUIForMode() {
-		super.updateUIForMode();
-
-		// Check Indicator Views consistent with new Mode
-		if (getShowIndicatorInternal()) {
-			addIndicatorViews();
-		} else {
-			removeIndicatorViews();
-		}
-	}
-
-	private void addIndicatorViews() {
-		Mode mode = getMode();
-		FrameLayout refreshableViewWrapper = getRefreshableViewWrapper();
-
-		if (mode.showHeaderLoadingLayout() && null == mIndicatorIvTop) {
-			// If the mode can pull down, and we don't have one set already
-			mIndicatorIvTop = new IndicatorLayout(getContext(), Mode.PULL_FROM_START);
-			FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,
-					ViewGroup.LayoutParams.WRAP_CONTENT);
-			params.rightMargin = getResources().getDimensionPixelSize(R.dimen.indicator_right_padding);
-			params.gravity = Gravity.TOP | Gravity.RIGHT;
-			refreshableViewWrapper.addView(mIndicatorIvTop, params);
-
-		} else if (!mode.showHeaderLoadingLayout() && null != mIndicatorIvTop) {
-			// If we can't pull down, but have a View then remove it
-			refreshableViewWrapper.removeView(mIndicatorIvTop);
-			mIndicatorIvTop = null;
-		}
-
-		if (mode.showFooterLoadingLayout() && null == mIndicatorIvBottom) {
-			// If the mode can pull down, and we don't have one set already
-			mIndicatorIvBottom = new IndicatorLayout(getContext(), Mode.PULL_FROM_END);
-			FrameLayout.LayoutParams params = new FrameLayout.LayoutParams(ViewGroup.LayoutParams.WRAP_CONTENT,
-					ViewGroup.LayoutParams.WRAP_CONTENT);
-			params.rightMargin = getResources().getDimensionPixelSize(R.dimen.indicator_right_padding);
-			params.gravity = Gravity.BOTTOM | Gravity.RIGHT;
-			refreshableViewWrapper.addView(mIndicatorIvBottom, params);
-
-		} else if (!mode.showFooterLoadingLayout() && null != mIndicatorIvBottom) {
-			// If we can't pull down, but have a View then remove it
-			refreshableViewWrapper.removeView(mIndicatorIvBottom);
-			mIndicatorIvBottom = null;
-		}
-	}
-
-	private boolean getShowIndicatorInternal() {
-		return mShowIndicator && isPullToRefreshEnabled();
-	}
-
-	private boolean isFirstItemVisible() {
-		final Adapter adapter = mRefreshableView.getAdapter();
-
-		if (null == adapter || adapter.isEmpty()) {
-			if (DEBUG) {
-				Log.d(LOG_TAG, "isFirstItemVisible. Empty View.");
-			}
-			return true;
-
-		} else {
-
-			/**
-			 * This check should really just be:
-			 * mRefreshableView.getFirstVisiblePosition() == 0, but PtRListView
-			 * internally use a HeaderView which messes the positions up. For
-			 * now we'll just add one to account for it and rely on the inner
-			 * condition which checks getTop().
-			 */
-			if (mRefreshableView.getFirstVisiblePosition() <= 1) {
-				final View firstVisibleChild = mRefreshableView.getChildAt(0);
-				if (firstVisibleChild != null) {
-					return firstVisibleChild.getTop() >= mRefreshableView.getTop();
-				}
-			}
-		}
-
-		return false;
-	}
-
-	private boolean isLastItemVisible() {
-		final Adapter adapter = mRefreshableView.getAdapter();
-
-		if (null == adapter || adapter.isEmpty()) {
-			if (DEBUG) {
-				Log.d(LOG_TAG, "isLastItemVisible. Empty View.");
-			}
-			return true;
-		} else {
-			final int lastItemPosition = mRefreshableView.getCount() - 1;
-			final int lastVisiblePosition = mRefreshableView.getLastVisiblePosition();
-
-			if (DEBUG) {
-				Log.d(LOG_TAG, "isLastItemVisible. Last Item Position: " + lastItemPosition + " Last Visible Pos: "
-						+ lastVisiblePosition);
-			}
-
-			/**
-			 * This check should really just be: lastVisiblePosition ==
-			 * lastItemPosition, but PtRListView internally uses a FooterView
-			 * which messes the positions up. For me we'll just subtract one to
-			 * account for it and rely on the inner condition which checks
-			 * getBottom().
-			 */
-			if (lastVisiblePosition >= lastItemPosition - 1) {
-				final int childIndex = lastVisiblePosition - mRefreshableView.getFirstVisiblePosition();
-				final View lastVisibleChild = mRefreshableView.getChildAt(childIndex);
-				if (lastVisibleChild != null) {
-					return lastVisibleChild.getBottom() <= mRefreshableView.getBottom();
-				}
-			}
-		}
-
-		return false;
-	}
-
-	private void removeIndicatorViews() {
-		if (null != mIndicatorIvTop) {
-			getRefreshableViewWrapper().removeView(mIndicatorIvTop);
-			mIndicatorIvTop = null;
-		}
-
-		if (null != mIndicatorIvBottom) {
-			getRefreshableViewWrapper().removeView(mIndicatorIvBottom);
-			mIndicatorIvBottom = null;
-		}
-	}
-
-	private void updateIndicatorViewsVisibility() {
-		if (null != mIndicatorIvTop) {
-			if (!isRefreshing() && isReadyForPullStart()) {
-				if (!mIndicatorIvTop.isVisible()) {
-					mIndicatorIvTop.show();
-				}
-			} else {
-				if (mIndicatorIvTop.isVisible()) {
-					mIndicatorIvTop.hide();
-				}
-			}
-		}
-
-		if (null != mIndicatorIvBottom) {
-			if (!isRefreshing() && isReadyForPullEnd()) {
-				if (!mIndicatorIvBottom.isVisible()) {
-					mIndicatorIvBottom.show();
-				}
-			} else {
-				if (mIndicatorIvBottom.isVisible()) {
-					mIndicatorIvBottom.hide();
-				}
-			}
-		}
-	}
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshBase.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshBase.java
deleted file mode 100644
index e76b234..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshBase.java
+++ /dev/null
@@ -1,1653 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.library;
-
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.graphics.drawable.Drawable;
-import android.os.Build.VERSION;
-import android.os.Build.VERSION_CODES;
-import android.os.Bundle;
-import android.os.Parcelable;
-import android.util.AttributeSet;
-import android.util.Log;
-import android.view.Gravity;
-import android.view.MotionEvent;
-import android.view.View;
-import android.view.ViewConfiguration;
-import android.view.ViewGroup;
-import android.view.animation.DecelerateInterpolator;
-import android.view.animation.Interpolator;
-import android.widget.FrameLayout;
-import android.widget.LinearLayout;
-
-import com.handmark.pulltorefresh.library.internal.FlipLoadingLayout;
-import com.handmark.pulltorefresh.library.internal.LoadingLayout;
-import com.handmark.pulltorefresh.library.internal.RotateLoadingLayout;
-import com.handmark.pulltorefresh.library.internal.Utils;
-import com.handmark.pulltorefresh.library.internal.ViewCompat;
-
-public abstract class PullToRefreshBase<T extends View> extends LinearLayout implements IPullToRefresh<T> {
-
-	// ===========================================================
-	// Constants
-	// ===========================================================
-
-	static final boolean DEBUG = true;
-
-	static final boolean USE_HW_LAYERS = false;
-
-	static final String LOG_TAG = "PullToRefresh";
-
-	static final float FRICTION = 2.0f;
-
-	public static final int SMOOTH_SCROLL_DURATION_MS = 200;
-	public static final int SMOOTH_SCROLL_LONG_DURATION_MS = 325;
-	static final int DEMO_SCROLL_INTERVAL = 225;
-
-	static final String STATE_STATE = "ptr_state";
-	static final String STATE_MODE = "ptr_mode";
-	static final String STATE_CURRENT_MODE = "ptr_current_mode";
-	static final String STATE_SCROLLING_REFRESHING_ENABLED = "ptr_disable_scrolling";
-	static final String STATE_SHOW_REFRESHING_VIEW = "ptr_show_refreshing_view";
-	static final String STATE_SUPER = "ptr_super";
-
-	// ===========================================================
-	// Fields
-	// ===========================================================
-
-	private int mTouchSlop;
-	private float mLastMotionX, mLastMotionY;
-	private float mInitialMotionX, mInitialMotionY;
-
-	private boolean mIsBeingDragged = false;
-	private State mState = State.RESET;
-	private Mode mMode = Mode.getDefault();
-
-	private Mode mCurrentMode;
-	T mRefreshableView;
-	private FrameLayout mRefreshableViewWrapper;
-
-	private boolean mShowViewWhileRefreshing = true;
-	private boolean mScrollingWhileRefreshingEnabled = false;
-	private boolean mFilterTouchEvents = true;
-	private boolean mOverScrollEnabled = true;
-	private boolean mLayoutVisibilityChangesEnabled = true;
-
-	private Interpolator mScrollAnimationInterpolator;
-	private AnimationStyle mLoadingAnimationStyle = AnimationStyle.getDefault();
-
-	private LoadingLayout mHeaderLayout;
-	private LoadingLayout mFooterLayout;
-
-	private OnRefreshListener<T> mOnRefreshListener;
-	private OnRefreshListener2<T> mOnRefreshListener2;
-	private OnPullEventListener<T> mOnPullEventListener;
-
-	private SmoothScrollRunnable mCurrentSmoothScrollRunnable;
-
-	// ===========================================================
-	// Constructors
-	// ===========================================================
-
-	public PullToRefreshBase(Context context) {
-		super(context);
-		init(context, null);
-	}
-
-	public PullToRefreshBase(Context context, AttributeSet attrs) {
-		super(context, attrs);
-		init(context, attrs);
-	}
-
-	public PullToRefreshBase(Context context, Mode mode) {
-		super(context);
-		mMode = mode;
-		init(context, null);
-	}
-
-	public PullToRefreshBase(Context context, Mode mode, AnimationStyle animStyle) {
-		super(context);
-		mMode = mode;
-		mLoadingAnimationStyle = animStyle;
-		init(context, null);
-	}
-
-	@Override
-	public void addView(View child, int index, ViewGroup.LayoutParams params) {
-		if (DEBUG) {
-			Log.d(LOG_TAG, "addView: " + child.getClass().getSimpleName());
-		}
-
-		final T refreshableView = getRefreshableView();
-
-		if (refreshableView instanceof ViewGroup) {
-			((ViewGroup) refreshableView).addView(child, index, params);
-		} else {
-			throw new UnsupportedOperationException("Refreshable View is not a ViewGroup so can't addView");
-		}
-	}
-
-	@Override
-	public final boolean demo() {
-		if (mMode.showHeaderLoadingLayout() && isReadyForPullStart()) {
-			smoothScrollToAndBack(-getHeaderSize() * 2);
-			return true;
-		} else if (mMode.showFooterLoadingLayout() && isReadyForPullEnd()) {
-			smoothScrollToAndBack(getFooterSize() * 2);
-			return true;
-		}
-
-		return false;
-	}
-
-	@Override
-	public final Mode getCurrentMode() {
-		return mCurrentMode;
-	}
-
-	@Override
-	public final boolean getFilterTouchEvents() {
-		return mFilterTouchEvents;
-	}
-
-	@Override
-	public final ILoadingLayout getLoadingLayoutProxy() {
-		return getLoadingLayoutProxy(true, true);
-	}
-
-	@Override
-	public final ILoadingLayout getLoadingLayoutProxy(boolean includeStart, boolean includeEnd) {
-		return createLoadingLayoutProxy(includeStart, includeEnd);
-	}
-
-	@Override
-	public final Mode getMode() {
-		return mMode;
-	}
-
-	@Override
-	public final T getRefreshableView() {
-		return mRefreshableView;
-	}
-
-	@Override
-	public final boolean getShowViewWhileRefreshing() {
-		return mShowViewWhileRefreshing;
-	}
-
-	@Override
-	public final State getState() {
-		return mState;
-	}
-
-	/**
-	 * @deprecated See {@link #isScrollingWhileRefreshingEnabled()}.
-	 */
-	public final boolean isDisableScrollingWhileRefreshing() {
-		return !isScrollingWhileRefreshingEnabled();
-	}
-
-	@Override
-	public final boolean isPullToRefreshEnabled() {
-		return mMode.permitsPullToRefresh();
-	}
-
-	@Override
-	public final boolean isPullToRefreshOverScrollEnabled() {
-		return VERSION.SDK_INT >= VERSION_CODES.GINGERBREAD && mOverScrollEnabled
-				&& OverscrollHelper.isAndroidOverScrollEnabled(mRefreshableView);
-	}
-
-	@Override
-	public final boolean isRefreshing() {
-		return mState == State.REFRESHING || mState == State.MANUAL_REFRESHING;
-	}
-
-	@Override
-	public final boolean isScrollingWhileRefreshingEnabled() {
-		return mScrollingWhileRefreshingEnabled;
-	}
-
-	@Override
-	public final boolean onInterceptTouchEvent(MotionEvent event) {
-
-		if (!isPullToRefreshEnabled()) {
-			return false;
-		}
-
-		final int action = event.getAction();
-
-		if (action == MotionEvent.ACTION_CANCEL || action == MotionEvent.ACTION_UP) {
-			mIsBeingDragged = false;
-			return false;
-		}
-
-		if (action != MotionEvent.ACTION_DOWN && mIsBeingDragged) {
-			return true;
-		}
-
-		switch (action) {
-			case MotionEvent.ACTION_MOVE: {
-				// If we're refreshing, and the flag is set. Eat all MOVE events
-				if (!mScrollingWhileRefreshingEnabled && isRefreshing()) {
-					return true;
-				}
-
-				if (isReadyForPull()) {
-					final float y = event.getY(), x = event.getX();
-					final float diff, oppositeDiff, absDiff;
-
-					// We need to use the correct values, based on scroll
-					// direction
-					switch (getPullToRefreshScrollDirection()) {
-						case HORIZONTAL:
-							diff = x - mLastMotionX;
-							oppositeDiff = y - mLastMotionY;
-							break;
-						case VERTICAL:
-						default:
-							diff = y - mLastMotionY;
-							oppositeDiff = x - mLastMotionX;
-							break;
-					}
-					absDiff = Math.abs(diff);
-
-					if (absDiff > mTouchSlop && (!mFilterTouchEvents || absDiff > Math.abs(oppositeDiff))) {
-						if (mMode.showHeaderLoadingLayout() && diff >= 1f && isReadyForPullStart()) {
-							mLastMotionY = y;
-							mLastMotionX = x;
-							mIsBeingDragged = true;
-							if (mMode == Mode.BOTH) {
-								mCurrentMode = Mode.PULL_FROM_START;
-							}
-						} else if (mMode.showFooterLoadingLayout() && diff <= -1f && isReadyForPullEnd()) {
-							mLastMotionY = y;
-							mLastMotionX = x;
-							mIsBeingDragged = true;
-							if (mMode == Mode.BOTH) {
-								mCurrentMode = Mode.PULL_FROM_END;
-							}
-						}
-					}
-				}
-				break;
-			}
-			case MotionEvent.ACTION_DOWN: {
-				if (isReadyForPull()) {
-					mLastMotionY = mInitialMotionY = event.getY();
-					mLastMotionX = mInitialMotionX = event.getX();
-					mIsBeingDragged = false;
-				}
-				break;
-			}
-		}
-
-		return mIsBeingDragged;
-	}
-
-	@Override
-	public final void onRefreshComplete() {
-		if (isRefreshing()) {
-			setState(State.RESET);
-		}
-	}
-
-	@Override
-	public final boolean onTouchEvent(MotionEvent event) {
-
-		if (!isPullToRefreshEnabled()) {
-			return false;
-		}
-
-		// If we're refreshing, and the flag is set. Eat the event
-		if (!mScrollingWhileRefreshingEnabled && isRefreshing()) {
-			return true;
-		}
-
-		if (event.getAction() == MotionEvent.ACTION_DOWN && event.getEdgeFlags() != 0) {
-			return false;
-		}
-
-		switch (event.getAction()) {
-			case MotionEvent.ACTION_MOVE: {
-				if (mIsBeingDragged) {
-					mLastMotionY = event.getY();
-					mLastMotionX = event.getX();
-					pullEvent();
-					return true;
-				}
-				break;
-			}
-
-			case MotionEvent.ACTION_DOWN: {
-				if (isReadyForPull()) {
-					mLastMotionY = mInitialMotionY = event.getY();
-					mLastMotionX = mInitialMotionX = event.getX();
-					return true;
-				}
-				break;
-			}
-
-			case MotionEvent.ACTION_CANCEL:
-			case MotionEvent.ACTION_UP: {
-				if (mIsBeingDragged) {
-					mIsBeingDragged = false;
-
-					if (mState == State.RELEASE_TO_REFRESH
-							&& (null != mOnRefreshListener || null != mOnRefreshListener2)) {
-						setState(State.REFRESHING, true);
-						return true;
-					}
-
-					// If we're already refreshing, just scroll back to the top
-					if (isRefreshing()) {
-						smoothScrollTo(0);
-						return true;
-					}
-
-					// If we haven't returned by here, then we're not in a state
-					// to pull, so just reset
-					setState(State.RESET);
-
-					return true;
-				}
-				break;
-			}
-		}
-
-		return false;
-	}
-
-	public final void setScrollingWhileRefreshingEnabled(boolean allowScrollingWhileRefreshing) {
-		mScrollingWhileRefreshingEnabled = allowScrollingWhileRefreshing;
-	}
-
-	/**
-	 * @deprecated See {@link #setScrollingWhileRefreshingEnabled(boolean)}
-	 */
-	public void setDisableScrollingWhileRefreshing(boolean disableScrollingWhileRefreshing) {
-		setScrollingWhileRefreshingEnabled(!disableScrollingWhileRefreshing);
-	}
-
-	@Override
-	public final void setFilterTouchEvents(boolean filterEvents) {
-		mFilterTouchEvents = filterEvents;
-	}
-
-	/**
-	 * @deprecated You should now call this method on the result of
-	 *             {@link #getLoadingLayoutProxy()}.
-	 */
-	public void setLastUpdatedLabel(CharSequence label) {
-		getLoadingLayoutProxy().setLastUpdatedLabel(label);
-	}
-
-	/**
-	 * @deprecated You should now call this method on the result of
-	 *             {@link #getLoadingLayoutProxy()}.
-	 */
-	public void setLoadingDrawable(Drawable drawable) {
-		getLoadingLayoutProxy().setLoadingDrawable(drawable);
-	}
-
-	/**
-	 * @deprecated You should now call this method on the result of
-	 *             {@link #getLoadingLayoutProxy(boolean, boolean)}.
-	 */
-	public void setLoadingDrawable(Drawable drawable, Mode mode) {
-		getLoadingLayoutProxy(mode.showHeaderLoadingLayout(), mode.showFooterLoadingLayout()).setLoadingDrawable(
-				drawable);
-	}
-
-	@Override
-	public void setLongClickable(boolean longClickable) {
-		getRefreshableView().setLongClickable(longClickable);
-	}
-
-	@Override
-	public final void setMode(Mode mode) {
-		if (mode != mMode) {
-			if (DEBUG) {
-				Log.d(LOG_TAG, "Setting mode to: " + mode);
-			}
-			mMode = mode;
-			updateUIForMode();
-		}
-	}
-
-	public void setOnPullEventListener(OnPullEventListener<T> listener) {
-		mOnPullEventListener = listener;
-	}
-
-	@Override
-	public final void setOnRefreshListener(OnRefreshListener<T> listener) {
-		mOnRefreshListener = listener;
-		mOnRefreshListener2 = null;
-	}
-
-	@Override
-	public final void setOnRefreshListener(OnRefreshListener2<T> listener) {
-		mOnRefreshListener2 = listener;
-		mOnRefreshListener = null;
-	}
-
-	/**
-	 * @deprecated You should now call this method on the result of
-	 *             {@link #getLoadingLayoutProxy()}.
-	 */
-	public void setPullLabel(CharSequence pullLabel) {
-		getLoadingLayoutProxy().setPullLabel(pullLabel);
-	}
-
-	/**
-	 * @deprecated You should now call this method on the result of
-	 *             {@link #getLoadingLayoutProxy(boolean, boolean)}.
-	 */
-	public void setPullLabel(CharSequence pullLabel, Mode mode) {
-		getLoadingLayoutProxy(mode.showHeaderLoadingLayout(), mode.showFooterLoadingLayout()).setPullLabel(pullLabel);
-	}
-
-	/**
-	 * @param enable Whether Pull-To-Refresh should be used
-	 * @deprecated This simple calls setMode with an appropriate mode based on
-	 *             the passed value.
-	 */
-	public final void setPullToRefreshEnabled(boolean enable) {
-		setMode(enable ? Mode.getDefault() : Mode.DISABLED);
-	}
-
-	@Override
-	public final void setPullToRefreshOverScrollEnabled(boolean enabled) {
-		mOverScrollEnabled = enabled;
-	}
-
-	@Override
-	public final void setRefreshing() {
-		setRefreshing(true);
-	}
-
-	@Override
-	public final void setRefreshing(boolean doScroll) {
-		if (!isRefreshing()) {
-			setState(State.MANUAL_REFRESHING, doScroll);
-		}
-	}
-
-	/**
-	 * @deprecated You should now call this method on the result of
-	 *             {@link #getLoadingLayoutProxy()}.
-	 */
-	public void setRefreshingLabel(CharSequence refreshingLabel) {
-		getLoadingLayoutProxy().setRefreshingLabel(refreshingLabel);
-	}
-
-	/**
-	 * @deprecated You should now call this method on the result of
-	 *             {@link #getLoadingLayoutProxy(boolean, boolean)}.
-	 */
-	public void setRefreshingLabel(CharSequence refreshingLabel, Mode mode) {
-		getLoadingLayoutProxy(mode.showHeaderLoadingLayout(), mode.showFooterLoadingLayout()).setRefreshingLabel(
-				refreshingLabel);
-	}
-
-	/**
-	 * @deprecated You should now call this method on the result of
-	 *             {@link #getLoadingLayoutProxy()}.
-	 */
-	public void setReleaseLabel(CharSequence releaseLabel) {
-		setReleaseLabel(releaseLabel, Mode.BOTH);
-	}
-
-	/**
-	 * @deprecated You should now call this method on the result of
-	 *             {@link #getLoadingLayoutProxy(boolean, boolean)}.
-	 */
-	public void setReleaseLabel(CharSequence releaseLabel, Mode mode) {
-		getLoadingLayoutProxy(mode.showHeaderLoadingLayout(), mode.showFooterLoadingLayout()).setReleaseLabel(
-				releaseLabel);
-	}
-
-	public void setScrollAnimationInterpolator(Interpolator interpolator) {
-		mScrollAnimationInterpolator = interpolator;
-	}
-
-	@Override
-	public final void setShowViewWhileRefreshing(boolean showView) {
-		mShowViewWhileRefreshing = showView;
-	}
-
-	/**
-	 * @return Either {@link Orientation#VERTICAL} or
-	 *         {@link Orientation#HORIZONTAL} depending on the scroll direction.
-	 */
-	public abstract Orientation getPullToRefreshScrollDirection();
-
-	final void setState(State state, final boolean... params) {
-		mState = state;
-		if (DEBUG) {
-			Log.d(LOG_TAG, "State: " + mState.name());
-		}
-
-		switch (mState) {
-			case RESET:
-				onReset();
-				break;
-			case PULL_TO_REFRESH:
-				onPullToRefresh();
-				break;
-			case RELEASE_TO_REFRESH:
-				onReleaseToRefresh();
-				break;
-			case REFRESHING:
-			case MANUAL_REFRESHING:
-				onRefreshing(params[0]);
-				break;
-			case OVERSCROLLING:
-				// NO-OP
-				break;
-		}
-
-		// Call OnPullEventListener
-		if (null != mOnPullEventListener) {
-			mOnPullEventListener.onPullEvent(this, mState, mCurrentMode);
-		}
-	}
-
-	/**
-	 * Used internally for adding view. Need because we override addView to
-	 * pass-through to the Refreshable View
-	 */
-	protected final void addViewInternal(View child, int index, ViewGroup.LayoutParams params) {
-		super.addView(child, index, params);
-	}
-
-	/**
-	 * Used internally for adding view. Need because we override addView to
-	 * pass-through to the Refreshable View
-	 */
-	protected final void addViewInternal(View child, ViewGroup.LayoutParams params) {
-		super.addView(child, -1, params);
-	}
-
-	protected LoadingLayout createLoadingLayout(Context context, Mode mode, TypedArray attrs) {
-		LoadingLayout layout = mLoadingAnimationStyle.createLoadingLayout(context, mode,
-				getPullToRefreshScrollDirection(), attrs);
-		layout.setVisibility(View.INVISIBLE);
-		return layout;
-	}
-
-	/**
-	 * Used internally for {@link #getLoadingLayoutProxy(boolean, boolean)}.
-	 * Allows derivative classes to include any extra LoadingLayouts.
-	 */
-	protected LoadingLayoutProxy createLoadingLayoutProxy(final boolean includeStart, final boolean includeEnd) {
-		LoadingLayoutProxy proxy = new LoadingLayoutProxy();
-
-		if (includeStart && mMode.showHeaderLoadingLayout()) {
-			proxy.addLayout(mHeaderLayout);
-		}
-		if (includeEnd && mMode.showFooterLoadingLayout()) {
-			proxy.addLayout(mFooterLayout);
-		}
-
-		return proxy;
-	}
-
-	/**
-	 * This is implemented by derived classes to return the created View. If you
-	 * need to use a custom View (such as a custom ListView), override this
-	 * method and return an instance of your custom class.
-	 * <p/>
-	 * Be sure to set the ID of the view in this method, especially if you're
-	 * using a ListActivity or ListFragment.
-	 * 
-	 * @param context Context to create view with
-	 * @param attrs AttributeSet from wrapped class. Means that anything you
-	 *            include in the XML layout declaration will be routed to the
-	 *            created View
-	 * @return New instance of the Refreshable View
-	 */
-	protected abstract T createRefreshableView(Context context, AttributeSet attrs);
-
-	protected final void disableLoadingLayoutVisibilityChanges() {
-		mLayoutVisibilityChangesEnabled = false;
-	}
-
-	protected final LoadingLayout getFooterLayout() {
-		return mFooterLayout;
-	}
-
-	protected final int getFooterSize() {
-		return mFooterLayout.getContentSize();
-	}
-
-	protected final LoadingLayout getHeaderLayout() {
-		return mHeaderLayout;
-	}
-
-	protected final int getHeaderSize() {
-		return mHeaderLayout.getContentSize();
-	}
-
-	protected int getPullToRefreshScrollDuration() {
-		return SMOOTH_SCROLL_DURATION_MS;
-	}
-
-	protected int getPullToRefreshScrollDurationLonger() {
-		return SMOOTH_SCROLL_LONG_DURATION_MS;
-	}
-
-	protected FrameLayout getRefreshableViewWrapper() {
-		return mRefreshableViewWrapper;
-	}
-
-	/**
-	 * Allows Derivative classes to handle the XML Attrs without creating a
-	 * TypedArray themsevles
-	 * 
-	 * @param a - TypedArray of PullToRefresh Attributes
-	 */
-	protected void handleStyledAttributes(TypedArray a) {
-	}
-
-	/**
-	 * Implemented by derived class to return whether the View is in a state
-	 * where the user can Pull to Refresh by scrolling from the end.
-	 * 
-	 * @return true if the View is currently in the correct state (for example,
-	 *         bottom of a ListView)
-	 */
-	protected abstract boolean isReadyForPullEnd();
-
-	/**
-	 * Implemented by derived class to return whether the View is in a state
-	 * where the user can Pull to Refresh by scrolling from the start.
-	 * 
-	 * @return true if the View is currently the correct state (for example, top
-	 *         of a ListView)
-	 */
-	protected abstract boolean isReadyForPullStart();
-
-	/**
-	 * Called by {@link #onRestoreInstanceState(Parcelable)} so that derivative
-	 * classes can handle their saved instance state.
-	 * 
-	 * @param savedInstanceState - Bundle which contains saved instance state.
-	 */
-	protected void onPtrRestoreInstanceState(Bundle savedInstanceState) {
-	}
-
-	/**
-	 * Called by {@link #onSaveInstanceState()} so that derivative classes can
-	 * save their instance state.
-	 * 
-	 * @param saveState - Bundle to be updated with saved state.
-	 */
-	protected void onPtrSaveInstanceState(Bundle saveState) {
-	}
-
-	/**
-	 * Called when the UI has been to be updated to be in the
-	 * {@link State#PULL_TO_REFRESH} state.
-	 */
-	protected void onPullToRefresh() {
-		switch (mCurrentMode) {
-			case PULL_FROM_END:
-				mFooterLayout.pullToRefresh();
-				break;
-			case PULL_FROM_START:
-				mHeaderLayout.pullToRefresh();
-				break;
-			default:
-				// NO-OP
-				break;
-		}
-	}
-
-	/**
-	 * Called when the UI has been to be updated to be in the
-	 * {@link State#REFRESHING} or {@link State#MANUAL_REFRESHING} state.
-	 * 
-	 * @param doScroll - Whether the UI should scroll for this event.
-	 */
-	protected void onRefreshing(final boolean doScroll) {
-		if (mMode.showHeaderLoadingLayout()) {
-			mHeaderLayout.refreshing();
-		}
-		if (mMode.showFooterLoadingLayout()) {
-			mFooterLayout.refreshing();
-		}
-
-		if (doScroll) {
-			if (mShowViewWhileRefreshing) {
-
-				// Call Refresh Listener when the Scroll has finished
-				OnSmoothScrollFinishedListener listener = new OnSmoothScrollFinishedListener() {
-					@Override
-					public void onSmoothScrollFinished() {
-						callRefreshListener();
-					}
-				};
-
-				switch (mCurrentMode) {
-					case MANUAL_REFRESH_ONLY:
-					case PULL_FROM_END:
-						smoothScrollTo(getFooterSize(), listener);
-						break;
-					default:
-					case PULL_FROM_START:
-						smoothScrollTo(-getHeaderSize(), listener);
-						break;
-				}
-			} else {
-				smoothScrollTo(0);
-			}
-		} else {
-			// We're not scrolling, so just call Refresh Listener now
-			callRefreshListener();
-		}
-	}
-
-	/**
-	 * Called when the UI has been to be updated to be in the
-	 * {@link State#RELEASE_TO_REFRESH} state.
-	 */
-	protected void onReleaseToRefresh() {
-		switch (mCurrentMode) {
-			case PULL_FROM_END:
-				mFooterLayout.releaseToRefresh();
-				break;
-			case PULL_FROM_START:
-				mHeaderLayout.releaseToRefresh();
-				break;
-			default:
-				// NO-OP
-				break;
-		}
-	}
-
-	/**
-	 * Called when the UI has been to be updated to be in the
-	 * {@link State#RESET} state.
-	 */
-	protected void onReset() {
-		mIsBeingDragged = false;
-		mLayoutVisibilityChangesEnabled = true;
-
-		// Always reset both layouts, just in case...
-		mHeaderLayout.reset();
-		mFooterLayout.reset();
-
-		smoothScrollTo(0);
-	}
-
-	@Override
-	protected final void onRestoreInstanceState(Parcelable state) {
-		if (state instanceof Bundle) {
-			Bundle bundle = (Bundle) state;
-
-			setMode(Mode.mapIntToValue(bundle.getInt(STATE_MODE, 0)));
-			mCurrentMode = Mode.mapIntToValue(bundle.getInt(STATE_CURRENT_MODE, 0));
-
-			mScrollingWhileRefreshingEnabled = bundle.getBoolean(STATE_SCROLLING_REFRESHING_ENABLED, false);
-			mShowViewWhileRefreshing = bundle.getBoolean(STATE_SHOW_REFRESHING_VIEW, true);
-
-			// Let super Restore Itself
-			super.onRestoreInstanceState(bundle.getParcelable(STATE_SUPER));
-
-			State viewState = State.mapIntToValue(bundle.getInt(STATE_STATE, 0));
-			if (viewState == State.REFRESHING || viewState == State.MANUAL_REFRESHING) {
-				setState(viewState, true);
-			}
-
-			// Now let derivative classes restore their state
-			onPtrRestoreInstanceState(bundle);
-			return;
-		}
-
-		super.onRestoreInstanceState(state);
-	}
-
-	@Override
-	protected final Parcelable onSaveInstanceState() {
-		Bundle bundle = new Bundle();
-
-		// Let derivative classes get a chance to save state first, that way we
-		// can make sure they don't overrite any of our values
-		onPtrSaveInstanceState(bundle);
-
-		bundle.putInt(STATE_STATE, mState.getIntValue());
-		bundle.putInt(STATE_MODE, mMode.getIntValue());
-		bundle.putInt(STATE_CURRENT_MODE, mCurrentMode.getIntValue());
-		bundle.putBoolean(STATE_SCROLLING_REFRESHING_ENABLED, mScrollingWhileRefreshingEnabled);
-		bundle.putBoolean(STATE_SHOW_REFRESHING_VIEW, mShowViewWhileRefreshing);
-		bundle.putParcelable(STATE_SUPER, super.onSaveInstanceState());
-
-		return bundle;
-	}
-
-	@Override
-	protected final void onSizeChanged(int w, int h, int oldw, int oldh) {
-		if (DEBUG) {
-			Log.d(LOG_TAG, String.format("onSizeChanged. W: %d, H: %d", w, h));
-		}
-
-		super.onSizeChanged(w, h, oldw, oldh);
-
-		// We need to update the header/footer when our size changes
-		refreshLoadingViewsSize();
-
-		// Update the Refreshable View layout
-		refreshRefreshableViewSize(w, h);
-
-		/**
-		 * As we're currently in a Layout Pass, we need to schedule another one
-		 * to layout any changes we've made here
-		 */
-		post(new Runnable() {
-			@Override
-			public void run() {
-				requestLayout();
-			}
-		});
-	}
-
-	/**
-	 * Re-measure the Loading Views height, and adjust internal padding as
-	 * necessary
-	 */
-	protected final void refreshLoadingViewsSize() {
-		final int maximumPullScroll = (int) (getMaximumPullScroll() * 1.2f);
-
-		int pLeft = getPaddingLeft();
-		int pTop = getPaddingTop();
-		int pRight = getPaddingRight();
-		int pBottom = getPaddingBottom();
-
-		switch (getPullToRefreshScrollDirection()) {
-			case HORIZONTAL:
-				if (mMode.showHeaderLoadingLayout()) {
-					mHeaderLayout.setWidth(maximumPullScroll);
-					pLeft = -maximumPullScroll;
-				} else {
-					pLeft = 0;
-				}
-
-				if (mMode.showFooterLoadingLayout()) {
-					mFooterLayout.setWidth(maximumPullScroll);
-					pRight = -maximumPullScroll;
-				} else {
-					pRight = 0;
-				}
-				break;
-
-			case VERTICAL:
-				if (mMode.showHeaderLoadingLayout()) {
-					mHeaderLayout.setHeight(maximumPullScroll);
-					pTop = -maximumPullScroll;
-				} else {
-					pTop = 0;
-				}
-
-				if (mMode.showFooterLoadingLayout()) {
-					mFooterLayout.setHeight(maximumPullScroll);
-					pBottom = -maximumPullScroll;
-				} else {
-					pBottom = 0;
-				}
-				break;
-		}
-
-		if (DEBUG) {
-			Log.d(LOG_TAG, String.format("Setting Padding. L: %d, T: %d, R: %d, B: %d", pLeft, pTop, pRight, pBottom));
-		}
-		setPadding(pLeft, pTop, pRight, pBottom);
-	}
-
-	protected final void refreshRefreshableViewSize(int width, int height) {
-		// We need to set the Height of the Refreshable View to the same as
-		// this layout
-		LinearLayout.LayoutParams lp = (LinearLayout.LayoutParams) mRefreshableViewWrapper.getLayoutParams();
-
-		switch (getPullToRefreshScrollDirection()) {
-			case HORIZONTAL:
-				if (lp.width != width) {
-					lp.width = width;
-					mRefreshableViewWrapper.requestLayout();
-				}
-				break;
-			case VERTICAL:
-				if (lp.height != height) {
-					lp.height = height;
-					mRefreshableViewWrapper.requestLayout();
-				}
-				break;
-		}
-	}
-
-	/**
-	 * Helper method which just calls scrollTo() in the correct scrolling
-	 * direction.
-	 * 
-	 * @param value - New Scroll value
-	 */
-	protected final void setHeaderScroll(int value) {
-		if (DEBUG) {
-			Log.d(LOG_TAG, "setHeaderScroll: " + value);
-		}
-
-		// Clamp value to with pull scroll range
-		final int maximumPullScroll = getMaximumPullScroll();
-		value = Math.min(maximumPullScroll, Math.max(-maximumPullScroll, value));
-
-		if (mLayoutVisibilityChangesEnabled) {
-			if (value < 0) {
-				mHeaderLayout.setVisibility(View.VISIBLE);
-			} else if (value > 0) {
-				mFooterLayout.setVisibility(View.VISIBLE);
-			} else {
-				mHeaderLayout.setVisibility(View.INVISIBLE);
-				mFooterLayout.setVisibility(View.INVISIBLE);
-			}
-		}
-
-		if (USE_HW_LAYERS) {
-			/**
-			 * Use a Hardware Layer on the Refreshable View if we've scrolled at
-			 * all. We don't use them on the Header/Footer Views as they change
-			 * often, which would negate any HW layer performance boost.
-			 */
-			ViewCompat.setLayerType(mRefreshableViewWrapper, value != 0 ? View.LAYER_TYPE_HARDWARE
-					: View.LAYER_TYPE_NONE);
-		}
-
-		switch (getPullToRefreshScrollDirection()) {
-			case VERTICAL:
-				scrollTo(0, value);
-				break;
-			case HORIZONTAL:
-				scrollTo(value, 0);
-				break;
-		}
-	}
-
-	/**
-	 * Smooth Scroll to position using the default duration of
-	 * {@value #SMOOTH_SCROLL_DURATION_MS} ms.
-	 * 
-	 * @param scrollValue - Position to scroll to
-	 */
-	protected final void smoothScrollTo(int scrollValue) {
-		smoothScrollTo(scrollValue, getPullToRefreshScrollDuration());
-	}
-
-	/**
-	 * Smooth Scroll to position using the default duration of
-	 * {@value #SMOOTH_SCROLL_DURATION_MS} ms.
-	 * 
-	 * @param scrollValue - Position to scroll to
-	 * @param listener - Listener for scroll
-	 */
-	protected final void smoothScrollTo(int scrollValue, OnSmoothScrollFinishedListener listener) {
-		smoothScrollTo(scrollValue, getPullToRefreshScrollDuration(), 0, listener);
-	}
-
-	/**
-	 * Smooth Scroll to position using the longer default duration of
-	 * {@value #SMOOTH_SCROLL_LONG_DURATION_MS} ms.
-	 * 
-	 * @param scrollValue - Position to scroll to
-	 */
-	protected final void smoothScrollToLonger(int scrollValue) {
-		smoothScrollTo(scrollValue, getPullToRefreshScrollDurationLonger());
-	}
-
-	/**
-	 * Updates the View State when the mode has been set. This does not do any
-	 * checking that the mode is different to current state so always updates.
-	 */
-	protected void updateUIForMode() {
-		// We need to use the correct LayoutParam values, based on scroll
-		// direction
-		final LinearLayout.LayoutParams lp = getLoadingLayoutLayoutParams();
-
-		// Remove Header, and then add Header Loading View again if needed
-		if (this == mHeaderLayout.getParent()) {
-			removeView(mHeaderLayout);
-		}
-		if (mMode.showHeaderLoadingLayout()) {
-			addViewInternal(mHeaderLayout, 0, lp);
-		}
-
-		// Remove Footer, and then add Footer Loading View again if needed
-		if (this == mFooterLayout.getParent()) {
-			removeView(mFooterLayout);
-		}
-		if (mMode.showFooterLoadingLayout()) {
-			addViewInternal(mFooterLayout, lp);
-		}
-
-		// Hide Loading Views
-		refreshLoadingViewsSize();
-
-		// If we're not using Mode.BOTH, set mCurrentMode to mMode, otherwise
-		// set it to pull down
-		mCurrentMode = (mMode != Mode.BOTH) ? mMode : Mode.PULL_FROM_START;
-	}
-
-	private void addRefreshableView(Context context, T refreshableView) {
-		mRefreshableViewWrapper = new FrameLayout(context);
-		mRefreshableViewWrapper.addView(refreshableView, ViewGroup.LayoutParams.MATCH_PARENT,
-				ViewGroup.LayoutParams.MATCH_PARENT);
-
-		addViewInternal(mRefreshableViewWrapper, new LinearLayout.LayoutParams(LayoutParams.MATCH_PARENT,
-				LayoutParams.MATCH_PARENT));
-	}
-
-	private void callRefreshListener() {
-		if (null != mOnRefreshListener) {
-			mOnRefreshListener.onRefresh(this);
-		} else if (null != mOnRefreshListener2) {
-			if (mCurrentMode == Mode.PULL_FROM_START) {
-				mOnRefreshListener2.onPullDownToRefresh(this);
-			} else if (mCurrentMode == Mode.PULL_FROM_END) {
-				mOnRefreshListener2.onPullUpToRefresh(this);
-			}
-		}
-	}
-
-	@SuppressWarnings("deprecation")
-	private void init(Context context, AttributeSet attrs) {
-		switch (getPullToRefreshScrollDirection()) {
-			case HORIZONTAL:
-				setOrientation(LinearLayout.HORIZONTAL);
-				break;
-			case VERTICAL:
-			default:
-				setOrientation(LinearLayout.VERTICAL);
-				break;
-		}
-
-		setGravity(Gravity.CENTER);
-
-		ViewConfiguration config = ViewConfiguration.get(context);
-		mTouchSlop = config.getScaledTouchSlop();
-
-		// Styleables from XML
-		TypedArray a = context.obtainStyledAttributes(attrs, R.styleable.PullToRefresh);
-
-		if (a.hasValue(R.styleable.PullToRefresh_ptrMode)) {
-			mMode = Mode.mapIntToValue(a.getInteger(R.styleable.PullToRefresh_ptrMode, 0));
-		}
-
-		if (a.hasValue(R.styleable.PullToRefresh_ptrAnimationStyle)) {
-			mLoadingAnimationStyle = AnimationStyle.mapIntToValue(a.getInteger(
-					R.styleable.PullToRefresh_ptrAnimationStyle, 0));
-		}
-
-		// Refreshable View
-		// By passing the attrs, we can add ListView/GridView params via XML
-		mRefreshableView = createRefreshableView(context, attrs);
-		addRefreshableView(context, mRefreshableView);
-
-		// We need to create now layouts now
-		mHeaderLayout = createLoadingLayout(context, Mode.PULL_FROM_START, a);
-		mFooterLayout = createLoadingLayout(context, Mode.PULL_FROM_END, a);
-
-		/**
-		 * Styleables from XML
-		 */
-		if (a.hasValue(R.styleable.PullToRefresh_ptrRefreshableViewBackground)) {
-			Drawable background = a.getDrawable(R.styleable.PullToRefresh_ptrRefreshableViewBackground);
-			if (null != background) {
-				mRefreshableView.setBackgroundDrawable(background);
-			}
-		} else if (a.hasValue(R.styleable.PullToRefresh_ptrAdapterViewBackground)) {
-			Utils.warnDeprecation("ptrAdapterViewBackground", "ptrRefreshableViewBackground");
-			Drawable background = a.getDrawable(R.styleable.PullToRefresh_ptrAdapterViewBackground);
-			if (null != background) {
-				mRefreshableView.setBackgroundDrawable(background);
-			}
-		}
-
-		if (a.hasValue(R.styleable.PullToRefresh_ptrOverScroll)) {
-			mOverScrollEnabled = a.getBoolean(R.styleable.PullToRefresh_ptrOverScroll, true);
-		}
-
-		if (a.hasValue(R.styleable.PullToRefresh_ptrScrollingWhileRefreshingEnabled)) {
-			mScrollingWhileRefreshingEnabled = a.getBoolean(
-					R.styleable.PullToRefresh_ptrScrollingWhileRefreshingEnabled, false);
-		}
-
-		// Let the derivative classes have a go at handling attributes, then
-		// recycle them...
-		handleStyledAttributes(a);
-		a.recycle();
-
-		// Finally update the UI for the modes
-		updateUIForMode();
-	}
-
-	private boolean isReadyForPull() {
-		switch (mMode) {
-			case PULL_FROM_START:
-				return isReadyForPullStart();
-			case PULL_FROM_END:
-				return isReadyForPullEnd();
-			case BOTH:
-				return isReadyForPullEnd() || isReadyForPullStart();
-			default:
-				return false;
-		}
-	}
-
-	/**
-	 * Actions a Pull Event
-	 * 
-	 * @return true if the Event has been handled, false if there has been no
-	 *         change
-	 */
-	private void pullEvent() {
-		final int newScrollValue;
-		final int itemDimension;
-		final float initialMotionValue, lastMotionValue;
-
-		switch (getPullToRefreshScrollDirection()) {
-			case HORIZONTAL:
-				initialMotionValue = mInitialMotionX;
-				lastMotionValue = mLastMotionX;
-				break;
-			case VERTICAL:
-			default:
-				initialMotionValue = mInitialMotionY;
-				lastMotionValue = mLastMotionY;
-				break;
-		}
-
-		switch (mCurrentMode) {
-			case PULL_FROM_END:
-				newScrollValue = Math.round(Math.max(initialMotionValue - lastMotionValue, 0) / FRICTION);
-				itemDimension = getFooterSize();
-				break;
-			case PULL_FROM_START:
-			default:
-				newScrollValue = Math.round(Math.min(initialMotionValue - lastMotionValue, 0) / FRICTION);
-				itemDimension = getHeaderSize();
-				break;
-		}
-
-		setHeaderScroll(newScrollValue);
-
-		if (newScrollValue != 0 && !isRefreshing()) {
-			float scale = Math.abs(newScrollValue) / (float) itemDimension;
-			switch (mCurrentMode) {
-				case PULL_FROM_END:
-					mFooterLayout.onPull(scale);
-					break;
-				case PULL_FROM_START:
-				default:
-					mHeaderLayout.onPull(scale);
-					break;
-			}
-
-			if (mState != State.PULL_TO_REFRESH && itemDimension >= Math.abs(newScrollValue)) {
-				setState(State.PULL_TO_REFRESH);
-			} else if (mState == State.PULL_TO_REFRESH && itemDimension < Math.abs(newScrollValue)) {
-				setState(State.RELEASE_TO_REFRESH);
-			}
-		}
-	}
-
-	private LinearLayout.LayoutParams getLoadingLayoutLayoutParams() {
-		switch (getPullToRefreshScrollDirection()) {
-			case HORIZONTAL:
-				return new LinearLayout.LayoutParams(LinearLayout.LayoutParams.WRAP_CONTENT,
-						LinearLayout.LayoutParams.MATCH_PARENT);
-			case VERTICAL:
-			default:
-				return new LinearLayout.LayoutParams(LinearLayout.LayoutParams.MATCH_PARENT,
-						LinearLayout.LayoutParams.WRAP_CONTENT);
-		}
-	}
-
-	private int getMaximumPullScroll() {
-		switch (getPullToRefreshScrollDirection()) {
-			case HORIZONTAL:
-				return Math.round(getWidth() / FRICTION);
-			case VERTICAL:
-			default:
-				return Math.round(getHeight() / FRICTION);
-		}
-	}
-
-	/**
-	 * Smooth Scroll to position using the specific duration
-	 * 
-	 * @param scrollValue - Position to scroll to
-	 * @param duration - Duration of animation in milliseconds
-	 */
-	private final void smoothScrollTo(int scrollValue, long duration) {
-		smoothScrollTo(scrollValue, duration, 0, null);
-	}
-
-	private final void smoothScrollTo(int newScrollValue, long duration, long delayMillis,
-			OnSmoothScrollFinishedListener listener) {
-		if (null != mCurrentSmoothScrollRunnable) {
-			mCurrentSmoothScrollRunnable.stop();
-		}
-
-		final int oldScrollValue;
-		switch (getPullToRefreshScrollDirection()) {
-			case HORIZONTAL:
-				oldScrollValue = getScrollX();
-				break;
-			case VERTICAL:
-			default:
-				oldScrollValue = getScrollY();
-				break;
-		}
-
-		if (oldScrollValue != newScrollValue) {
-			if (null == mScrollAnimationInterpolator) {
-				// Default interpolator is a Decelerate Interpolator
-				mScrollAnimationInterpolator = new DecelerateInterpolator();
-			}
-			mCurrentSmoothScrollRunnable = new SmoothScrollRunnable(oldScrollValue, newScrollValue, duration, listener);
-
-			if (delayMillis > 0) {
-				postDelayed(mCurrentSmoothScrollRunnable, delayMillis);
-			} else {
-				post(mCurrentSmoothScrollRunnable);
-			}
-		}
-	}
-
-	private final void smoothScrollToAndBack(int y) {
-		smoothScrollTo(y, SMOOTH_SCROLL_DURATION_MS, 0, new OnSmoothScrollFinishedListener() {
-
-			@Override
-			public void onSmoothScrollFinished() {
-				smoothScrollTo(0, SMOOTH_SCROLL_DURATION_MS, DEMO_SCROLL_INTERVAL, null);
-			}
-		});
-	}
-
-	public static enum AnimationStyle {
-		/**
-		 * This is the default for Android-PullToRefresh. Allows you to use any
-		 * drawable, which is automatically rotated and used as a Progress Bar.
-		 */
-		ROTATE,
-
-		/**
-		 * This is the old default, and what is commonly used on iOS. Uses an
-		 * arrow image which flips depending on where the user has scrolled.
-		 */
-		FLIP;
-
-		static AnimationStyle getDefault() {
-			return ROTATE;
-		}
-
-		/**
-		 * Maps an int to a specific mode. This is needed when saving state, or
-		 * inflating the view from XML where the mode is given through a attr
-		 * int.
-		 * 
-		 * @param modeInt - int to map a Mode to
-		 * @return Mode that modeInt maps to, or ROTATE by default.
-		 */
-		static AnimationStyle mapIntToValue(int modeInt) {
-			switch (modeInt) {
-				case 0x0:
-				default:
-					return ROTATE;
-				case 0x1:
-					return FLIP;
-			}
-		}
-
-		LoadingLayout createLoadingLayout(Context context, Mode mode, Orientation scrollDirection, TypedArray attrs) {
-			switch (this) {
-				case ROTATE:
-				default:
-					return new RotateLoadingLayout(context, mode, scrollDirection, attrs);
-				case FLIP:
-					return new FlipLoadingLayout(context, mode, scrollDirection, attrs);
-			}
-		}
-	}
-
-	public static enum Mode {
-
-		/**
-		 * Disable all Pull-to-Refresh gesture and Refreshing handling
-		 */
-		DISABLED(0x0),
-
-		/**
-		 * Only allow the user to Pull from the start of the Refreshable View to
-		 * refresh. The start is either the Top or Left, depending on the
-		 * scrolling direction.
-		 */
-		PULL_FROM_START(0x1),
-
-		/**
-		 * Only allow the user to Pull from the end of the Refreshable View to
-		 * refresh. The start is either the Bottom or Right, depending on the
-		 * scrolling direction.
-		 */
-		PULL_FROM_END(0x2),
-
-		/**
-		 * Allow the user to both Pull from the start, from the end to refresh.
-		 */
-		BOTH(0x3),
-
-		/**
-		 * Disables Pull-to-Refresh gesture handling, but allows manually
-		 * setting the Refresh state via
-		 * {@link PullToRefreshBase#setRefreshing() setRefreshing()}.
-		 */
-		MANUAL_REFRESH_ONLY(0x4);
-
-		/**
-		 * @deprecated Use {@link #PULL_FROM_START} from now on.
-		 */
-		public static Mode PULL_DOWN_TO_REFRESH = Mode.PULL_FROM_START;
-
-		/**
-		 * @deprecated Use {@link #PULL_FROM_END} from now on.
-		 */
-		public static Mode PULL_UP_TO_REFRESH = Mode.PULL_FROM_END;
-
-		/**
-		 * Maps an int to a specific mode. This is needed when saving state, or
-		 * inflating the view from XML where the mode is given through a attr
-		 * int.
-		 * 
-		 * @param modeInt - int to map a Mode to
-		 * @return Mode that modeInt maps to, or PULL_FROM_START by default.
-		 */
-		static Mode mapIntToValue(final int modeInt) {
-			for (Mode value : Mode.values()) {
-				if (modeInt == value.getIntValue()) {
-					return value;
-				}
-			}
-
-			// If not, return default
-			return getDefault();
-		}
-
-		static Mode getDefault() {
-			return PULL_FROM_START;
-		}
-
-		private int mIntValue;
-
-		// The modeInt values need to match those from attrs.xml
-		Mode(int modeInt) {
-			mIntValue = modeInt;
-		}
-
-		/**
-		 * @return true if the mode permits Pull-to-Refresh
-		 */
-		boolean permitsPullToRefresh() {
-			return !(this == DISABLED || this == MANUAL_REFRESH_ONLY);
-		}
-
-		/**
-		 * @return true if this mode wants the Loading Layout Header to be shown
-		 */
-		public boolean showHeaderLoadingLayout() {
-			return this == PULL_FROM_START || this == BOTH;
-		}
-
-		/**
-		 * @return true if this mode wants the Loading Layout Footer to be shown
-		 */
-		public boolean showFooterLoadingLayout() {
-			return this == PULL_FROM_END || this == BOTH || this == MANUAL_REFRESH_ONLY;
-		}
-
-		int getIntValue() {
-			return mIntValue;
-		}
-
-	}
-
-	// ===========================================================
-	// Inner, Anonymous Classes, and Enumerations
-	// ===========================================================
-
-	/**
-	 * Simple Listener that allows you to be notified when the user has scrolled
-	 * to the end of the AdapterView. See (
-	 * {@link PullToRefreshAdapterViewBase#setOnLastItemVisibleListener}.
-	 * 
-	 * @author Chris Banes
-	 */
-	public static interface OnLastItemVisibleListener {
-
-		/**
-		 * Called when the user has scrolled to the end of the list
-		 */
-		public void onLastItemVisible();
-
-	}
-
-	/**
-	 * Listener that allows you to be notified when the user has started or
-	 * finished a touch event. Useful when you want to append extra UI events
-	 * (such as sounds). See (
-	 * {@link PullToRefreshAdapterViewBase#setOnPullEventListener}.
-	 * 
-	 * @author Chris Banes
-	 */
-	public static interface OnPullEventListener<V extends View> {
-
-		/**
-		 * Called when the internal state has been changed, usually by the user
-		 * pulling.
-		 * 
-		 * @param refreshView - View which has had it's state change.
-		 * @param state - The new state of View.
-		 * @param direction - One of {@link Mode#PULL_FROM_START} or
-		 *            {@link Mode#PULL_FROM_END} depending on which direction
-		 *            the user is pulling. Only useful when <var>state</var> is
-		 *            {@link State#PULL_TO_REFRESH} or
-		 *            {@link State#RELEASE_TO_REFRESH}.
-		 */
-		public void onPullEvent(final PullToRefreshBase<V> refreshView, State state, Mode direction);
-
-	}
-
-	/**
-	 * Simple Listener to listen for any callbacks to Refresh.
-	 * 
-	 * @author Chris Banes
-	 */
-	public static interface OnRefreshListener<V extends View> {
-
-		/**
-		 * onRefresh will be called for both a Pull from start, and Pull from
-		 * end
-		 */
-		public void onRefresh(final PullToRefreshBase<V> refreshView);
-
-	}
-
-	/**
-	 * An advanced version of the Listener to listen for callbacks to Refresh.
-	 * This listener is different as it allows you to differentiate between Pull
-	 * Ups, and Pull Downs.
-	 * 
-	 * @author Chris Banes
-	 */
-	public static interface OnRefreshListener2<V extends View> {
-		// TODO These methods need renaming to START/END rather than DOWN/UP
-
-		/**
-		 * onPullDownToRefresh will be called only when the user has Pulled from
-		 * the start, and released.
-		 */
-		public void onPullDownToRefresh(final PullToRefreshBase<V> refreshView);
-
-		/**
-		 * onPullUpToRefresh will be called only when the user has Pulled from
-		 * the end, and released.
-		 */
-		public void onPullUpToRefresh(final PullToRefreshBase<V> refreshView);
-
-	}
-
-	public static enum Orientation {
-		VERTICAL, HORIZONTAL;
-	}
-
-	public static enum State {
-
-		/**
-		 * When the UI is in a state which means that user is not interacting
-		 * with the Pull-to-Refresh function.
-		 */
-		RESET(0x0),
-
-		/**
-		 * When the UI is being pulled by the user, but has not been pulled far
-		 * enough so that it refreshes when released.
-		 */
-		PULL_TO_REFRESH(0x1),
-
-		/**
-		 * When the UI is being pulled by the user, and <strong>has</strong>
-		 * been pulled far enough so that it will refresh when released.
-		 */
-		RELEASE_TO_REFRESH(0x2),
-
-		/**
-		 * When the UI is currently refreshing, caused by a pull gesture.
-		 */
-		REFRESHING(0x8),
-
-		/**
-		 * When the UI is currently refreshing, caused by a call to
-		 * {@link PullToRefreshBase#setRefreshing() setRefreshing()}.
-		 */
-		MANUAL_REFRESHING(0x9),
-
-		/**
-		 * When the UI is currently overscrolling, caused by a fling on the
-		 * Refreshable View.
-		 */
-		OVERSCROLLING(0x10);
-
-		/**
-		 * Maps an int to a specific state. This is needed when saving state.
-		 * 
-		 * @param stateInt - int to map a State to
-		 * @return State that stateInt maps to
-		 */
-		static State mapIntToValue(final int stateInt) {
-			for (State value : State.values()) {
-				if (stateInt == value.getIntValue()) {
-					return value;
-				}
-			}
-
-			// If not, return default
-			return RESET;
-		}
-
-		private int mIntValue;
-
-		State(int intValue) {
-			mIntValue = intValue;
-		}
-
-		int getIntValue() {
-			return mIntValue;
-		}
-	}
-
-	final class SmoothScrollRunnable implements Runnable {
-		private final Interpolator mInterpolator;
-		private final int mScrollToY;
-		private final int mScrollFromY;
-		private final long mDuration;
-		private OnSmoothScrollFinishedListener mListener;
-
-		private boolean mContinueRunning = true;
-		private long mStartTime = -1;
-		private int mCurrentY = -1;
-
-		public SmoothScrollRunnable(int fromY, int toY, long duration, OnSmoothScrollFinishedListener listener) {
-			mScrollFromY = fromY;
-			mScrollToY = toY;
-			mInterpolator = mScrollAnimationInterpolator;
-			mDuration = duration;
-			mListener = listener;
-		}
-
-		@Override
-		public void run() {
-
-			/**
-			 * Only set mStartTime if this is the first time we're starting,
-			 * else actually calculate the Y delta
-			 */
-			if (mStartTime == -1) {
-				mStartTime = System.currentTimeMillis();
-			} else {
-
-				/**
-				 * We do do all calculations in long to reduce software float
-				 * calculations. We use 1000 as it gives us good accuracy and
-				 * small rounding errors
-				 */
-				long normalizedTime = (1000 * (System.currentTimeMillis() - mStartTime)) / mDuration;
-				normalizedTime = Math.max(Math.min(normalizedTime, 1000), 0);
-
-				final int deltaY = Math.round((mScrollFromY - mScrollToY)
-						* mInterpolator.getInterpolation(normalizedTime / 1000f));
-				mCurrentY = mScrollFromY - deltaY;
-				setHeaderScroll(mCurrentY);
-			}
-
-			// If we're not at the target Y, keep going...
-			if (mContinueRunning && mScrollToY != mCurrentY) {
-				ViewCompat.postOnAnimation(PullToRefreshBase.this, this);
-			} else {
-				if (null != mListener) {
-					mListener.onSmoothScrollFinished();
-				}
-			}
-		}
-
-		public void stop() {
-			mContinueRunning = false;
-			removeCallbacks(this);
-		}
-	}
-
-	static interface OnSmoothScrollFinishedListener {
-		void onSmoothScrollFinished();
-	}
-
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshExpandableListView.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshExpandableListView.java
deleted file mode 100644
index 649020c..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshExpandableListView.java
+++ /dev/null
@@ -1,103 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.library;
-
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.os.Build.VERSION;
-import android.os.Build.VERSION_CODES;
-import android.util.AttributeSet;
-import android.view.View;
-import android.widget.ExpandableListView;
-
-import com.handmark.pulltorefresh.library.internal.EmptyViewMethodAccessor;
-
-public class PullToRefreshExpandableListView extends PullToRefreshAdapterViewBase<ExpandableListView> {
-
-	public PullToRefreshExpandableListView(Context context) {
-		super(context);
-	}
-
-	public PullToRefreshExpandableListView(Context context, AttributeSet attrs) {
-		super(context, attrs);
-	}
-
-	public PullToRefreshExpandableListView(Context context, Mode mode) {
-		super(context, mode);
-	}
-
-	public PullToRefreshExpandableListView(Context context, Mode mode, AnimationStyle style) {
-		super(context, mode, style);
-	}
-
-	@Override
-	public final Orientation getPullToRefreshScrollDirection() {
-		return Orientation.VERTICAL;
-	}
-
-	@Override
-	protected ExpandableListView createRefreshableView(Context context, AttributeSet attrs) {
-		final ExpandableListView lv;
-		if (VERSION.SDK_INT >= VERSION_CODES.GINGERBREAD) {
-			lv = new InternalExpandableListViewSDK9(context, attrs);
-		} else {
-			lv = new InternalExpandableListView(context, attrs);
-		}
-
-		// Set it to this so it can be used in ListActivity/ListFragment
-		lv.setId(android.R.id.list);
-		return lv;
-	}
-
-	class InternalExpandableListView extends ExpandableListView implements EmptyViewMethodAccessor {
-
-		public InternalExpandableListView(Context context, AttributeSet attrs) {
-			super(context, attrs);
-		}
-
-		@Override
-		public void setEmptyView(View emptyView) {
-			PullToRefreshExpandableListView.this.setEmptyView(emptyView);
-		}
-
-		@Override
-		public void setEmptyViewInternal(View emptyView) {
-			super.setEmptyView(emptyView);
-		}
-	}
-
-	@TargetApi(9)
-	final class InternalExpandableListViewSDK9 extends InternalExpandableListView {
-
-		public InternalExpandableListViewSDK9(Context context, AttributeSet attrs) {
-			super(context, attrs);
-		}
-
-		@Override
-		protected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX,
-				int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent) {
-
-			final boolean returnValue = super.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX,
-					scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent);
-
-			// Does all of the hard work...
-			OverscrollHelper.overScrollBy(PullToRefreshExpandableListView.this, deltaX, scrollX, deltaY, scrollY,
-					isTouchEvent);
-
-			return returnValue;
-		}
-	}
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshGridView.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshGridView.java
deleted file mode 100644
index f950688..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshGridView.java
+++ /dev/null
@@ -1,102 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.library;
-
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.os.Build.VERSION;
-import android.os.Build.VERSION_CODES;
-import android.util.AttributeSet;
-import android.view.View;
-import android.widget.GridView;
-
-import com.handmark.pulltorefresh.library.internal.EmptyViewMethodAccessor;
-
-public class PullToRefreshGridView extends PullToRefreshAdapterViewBase<GridView> {
-
-	public PullToRefreshGridView(Context context) {
-		super(context);
-	}
-
-	public PullToRefreshGridView(Context context, AttributeSet attrs) {
-		super(context, attrs);
-	}
-
-	public PullToRefreshGridView(Context context, Mode mode) {
-		super(context, mode);
-	}
-
-	public PullToRefreshGridView(Context context, Mode mode, AnimationStyle style) {
-		super(context, mode, style);
-	}
-
-	@Override
-	public final Orientation getPullToRefreshScrollDirection() {
-		return Orientation.VERTICAL;
-	}
-
-	@Override
-	protected final GridView createRefreshableView(Context context, AttributeSet attrs) {
-		final GridView gv;
-		if (VERSION.SDK_INT >= VERSION_CODES.GINGERBREAD) {
-			gv = new InternalGridViewSDK9(context, attrs);
-		} else {
-			gv = new InternalGridView(context, attrs);
-		}
-
-		// Use Generated ID (from res/values/ids.xml)
-		gv.setId(R.id.gridview);
-		return gv;
-	}
-
-	class InternalGridView extends GridView implements EmptyViewMethodAccessor {
-
-		public InternalGridView(Context context, AttributeSet attrs) {
-			super(context, attrs);
-		}
-
-		@Override
-		public void setEmptyView(View emptyView) {
-			PullToRefreshGridView.this.setEmptyView(emptyView);
-		}
-
-		@Override
-		public void setEmptyViewInternal(View emptyView) {
-			super.setEmptyView(emptyView);
-		}
-	}
-
-	@TargetApi(9)
-	final class InternalGridViewSDK9 extends InternalGridView {
-
-		public InternalGridViewSDK9(Context context, AttributeSet attrs) {
-			super(context, attrs);
-		}
-
-		@Override
-		protected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX,
-				int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent) {
-
-			final boolean returnValue = super.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX,
-					scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent);
-
-			// Does all of the hard work...
-			OverscrollHelper.overScrollBy(PullToRefreshGridView.this, deltaX, scrollX, deltaY, scrollY, isTouchEvent);
-
-			return returnValue;
-		}
-	}
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshHorizontalScrollView.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshHorizontalScrollView.java
deleted file mode 100644
index a70f7ad..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshHorizontalScrollView.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.library;
-
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.os.Build.VERSION;
-import android.os.Build.VERSION_CODES;
-import android.util.AttributeSet;
-import android.view.View;
-import android.widget.HorizontalScrollView;
-
-public class PullToRefreshHorizontalScrollView extends PullToRefreshBase<HorizontalScrollView> {
-
-	public PullToRefreshHorizontalScrollView(Context context) {
-		super(context);
-	}
-
-	public PullToRefreshHorizontalScrollView(Context context, AttributeSet attrs) {
-		super(context, attrs);
-	}
-
-	public PullToRefreshHorizontalScrollView(Context context, Mode mode) {
-		super(context, mode);
-	}
-
-	public PullToRefreshHorizontalScrollView(Context context, Mode mode, AnimationStyle style) {
-		super(context, mode, style);
-	}
-
-	@Override
-	public final Orientation getPullToRefreshScrollDirection() {
-		return Orientation.HORIZONTAL;
-	}
-
-	@Override
-	protected HorizontalScrollView createRefreshableView(Context context, AttributeSet attrs) {
-		HorizontalScrollView scrollView;
-
-		if (VERSION.SDK_INT >= VERSION_CODES.GINGERBREAD) {
-			scrollView = new InternalHorizontalScrollViewSDK9(context, attrs);
-		} else {
-			scrollView = new HorizontalScrollView(context, attrs);
-		}
-
-		scrollView.setId(R.id.scrollview);
-		return scrollView;
-	}
-
-	@Override
-	protected boolean isReadyForPullStart() {
-		return mRefreshableView.getScrollX() == 0;
-	}
-
-	@Override
-	protected boolean isReadyForPullEnd() {
-		View scrollViewChild = mRefreshableView.getChildAt(0);
-		if (null != scrollViewChild) {
-			return mRefreshableView.getScrollX() >= (scrollViewChild.getWidth() - getWidth());
-		}
-		return false;
-	}
-
-	@TargetApi(9)
-	final class InternalHorizontalScrollViewSDK9 extends HorizontalScrollView {
-
-		public InternalHorizontalScrollViewSDK9(Context context, AttributeSet attrs) {
-			super(context, attrs);
-		}
-
-		@Override
-		protected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX,
-				int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent) {
-
-			final boolean returnValue = super.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX,
-					scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent);
-
-			// Does all of the hard work...
-			OverscrollHelper.overScrollBy(PullToRefreshHorizontalScrollView.this, deltaX, scrollX, deltaY, scrollY,
-					getScrollRange(), isTouchEvent);
-
-			return returnValue;
-		}
-
-		/**
-		 * Taken from the AOSP ScrollView source
-		 */
-		private int getScrollRange() {
-			int scrollRange = 0;
-			if (getChildCount() > 0) {
-				View child = getChildAt(0);
-				scrollRange = Math.max(0, child.getWidth() - (getWidth() - getPaddingLeft() - getPaddingRight()));
-			}
-			return scrollRange;
-		}
-	}
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshListView.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshListView.java
deleted file mode 100644
index 0aa9a27..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshListView.java
+++ /dev/null
@@ -1,337 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.library;
-
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.graphics.Canvas;
-import android.os.Build.VERSION;
-import android.os.Build.VERSION_CODES;
-import android.util.AttributeSet;
-import android.view.Gravity;
-import android.view.MotionEvent;
-import android.view.View;
-import android.widget.FrameLayout;
-import android.widget.ListAdapter;
-import android.widget.ListView;
-
-import com.handmark.pulltorefresh.library.internal.EmptyViewMethodAccessor;
-import com.handmark.pulltorefresh.library.internal.LoadingLayout;
-
-public class PullToRefreshListView extends PullToRefreshAdapterViewBase<ListView> {
-
-	private LoadingLayout mHeaderLoadingView;
-	private LoadingLayout mFooterLoadingView;
-
-	private FrameLayout mLvFooterLoadingFrame;
-
-	private boolean mListViewExtrasEnabled;
-
-	public PullToRefreshListView(Context context) {
-		super(context);
-	}
-
-	public PullToRefreshListView(Context context, AttributeSet attrs) {
-		super(context, attrs);
-	}
-
-	public PullToRefreshListView(Context context, Mode mode) {
-		super(context, mode);
-	}
-
-	public PullToRefreshListView(Context context, Mode mode, AnimationStyle style) {
-		super(context, mode, style);
-	}
-
-	@Override
-	public final Orientation getPullToRefreshScrollDirection() {
-		return Orientation.VERTICAL;
-	}
-
-	@Override
-	protected void onRefreshing(final boolean doScroll) {
-		/**
-		 * If we're not showing the Refreshing view, or the list is empty, the
-		 * the header/footer views won't show so we use the normal method.
-		 */
-		ListAdapter adapter = mRefreshableView.getAdapter();
-		if (!mListViewExtrasEnabled || !getShowViewWhileRefreshing() || null == adapter || adapter.isEmpty()) {
-			super.onRefreshing(doScroll);
-			return;
-		}
-
-		super.onRefreshing(false);
-
-		final LoadingLayout origLoadingView, listViewLoadingView, oppositeListViewLoadingView;
-		final int selection, scrollToY;
-
-		switch (getCurrentMode()) {
-			case MANUAL_REFRESH_ONLY:
-			case PULL_FROM_END:
-				origLoadingView = getFooterLayout();
-				listViewLoadingView = mFooterLoadingView;
-				oppositeListViewLoadingView = mHeaderLoadingView;
-				selection = mRefreshableView.getCount() - 1;
-				scrollToY = getScrollY() - getFooterSize();
-				break;
-			case PULL_FROM_START:
-			default:
-				origLoadingView = getHeaderLayout();
-				listViewLoadingView = mHeaderLoadingView;
-				oppositeListViewLoadingView = mFooterLoadingView;
-				selection = 0;
-				scrollToY = getScrollY() + getHeaderSize();
-				break;
-		}
-
-		// Hide our original Loading View
-		origLoadingView.reset();
-		origLoadingView.hideAllViews();
-
-		// Make sure the opposite end is hidden too
-		oppositeListViewLoadingView.setVisibility(View.GONE);
-
-		// Show the ListView Loading View and set it to refresh.
-		listViewLoadingView.setVisibility(View.VISIBLE);
-		listViewLoadingView.refreshing();
-
-		if (doScroll) {
-			// We need to disable the automatic visibility changes for now
-			disableLoadingLayoutVisibilityChanges();
-
-			// We scroll slightly so that the ListView's header/footer is at the
-			// same Y position as our normal header/footer
-			setHeaderScroll(scrollToY);
-
-			// Make sure the ListView is scrolled to show the loading
-			// header/footer
-			mRefreshableView.setSelection(selection);
-
-			// Smooth scroll as normal
-			smoothScrollTo(0);
-		}
-	}
-
-	@Override
-	protected void onReset() {
-		/**
-		 * If the extras are not enabled, just call up to super and return.
-		 */
-		if (!mListViewExtrasEnabled) {
-			super.onReset();
-			return;
-		}
-
-		final LoadingLayout originalLoadingLayout, listViewLoadingLayout;
-		final int scrollToHeight, selection;
-		final boolean scrollLvToEdge;
-
-		switch (getCurrentMode()) {
-			case MANUAL_REFRESH_ONLY:
-			case PULL_FROM_END:
-				originalLoadingLayout = getFooterLayout();
-				listViewLoadingLayout = mFooterLoadingView;
-				selection = mRefreshableView.getCount() - 1;
-				scrollToHeight = getFooterSize();
-				scrollLvToEdge = Math.abs(mRefreshableView.getLastVisiblePosition() - selection) <= 1;
-				break;
-			case PULL_FROM_START:
-			default:
-				originalLoadingLayout = getHeaderLayout();
-				listViewLoadingLayout = mHeaderLoadingView;
-				scrollToHeight = -getHeaderSize();
-				selection = 0;
-				scrollLvToEdge = Math.abs(mRefreshableView.getFirstVisiblePosition() - selection) <= 1;
-				break;
-		}
-
-		// If the ListView header loading layout is showing, then we need to
-		// flip so that the original one is showing instead
-		if (listViewLoadingLayout.getVisibility() == View.VISIBLE) {
-
-			// Set our Original View to Visible
-			originalLoadingLayout.showInvisibleViews();
-
-			// Hide the ListView Header/Footer
-			listViewLoadingLayout.setVisibility(View.GONE);
-
-			/**
-			 * Scroll so the View is at the same Y as the ListView
-			 * header/footer, but only scroll if: we've pulled to refresh, it's
-			 * positioned correctly
-			 */
-			if (scrollLvToEdge && getState() != State.MANUAL_REFRESHING) {
-				mRefreshableView.setSelection(selection);
-				setHeaderScroll(scrollToHeight);
-			}
-		}
-
-		// Finally, call up to super
-		super.onReset();
-	}
-
-	@Override
-	protected LoadingLayoutProxy createLoadingLayoutProxy(final boolean includeStart, final boolean includeEnd) {
-		LoadingLayoutProxy proxy = super.createLoadingLayoutProxy(includeStart, includeEnd);
-
-		if (mListViewExtrasEnabled) {
-			final Mode mode = getMode();
-
-			if (includeStart && mode.showHeaderLoadingLayout()) {
-				proxy.addLayout(mHeaderLoadingView);
-			}
-			if (includeEnd && mode.showFooterLoadingLayout()) {
-				proxy.addLayout(mFooterLoadingView);
-			}
-		}
-
-		return proxy;
-	}
-
-	protected ListView createListView(Context context, AttributeSet attrs) {
-		final ListView lv;
-		if (VERSION.SDK_INT >= VERSION_CODES.GINGERBREAD) {
-			lv = new InternalListViewSDK9(context, attrs);
-		} else {
-			lv = new InternalListView(context, attrs);
-		}
-		return lv;
-	}
-
-	@Override
-	protected ListView createRefreshableView(Context context, AttributeSet attrs) {
-		ListView lv = createListView(context, attrs);
-
-		// Set it to this so it can be used in ListActivity/ListFragment
-		lv.setId(android.R.id.list);
-		return lv;
-	}
-
-	@Override
-	protected void handleStyledAttributes(TypedArray a) {
-		super.handleStyledAttributes(a);
-
-		mListViewExtrasEnabled = a.getBoolean(R.styleable.PullToRefresh_ptrListViewExtrasEnabled, true);
-
-		if (mListViewExtrasEnabled) {
-			final FrameLayout.LayoutParams lp = new FrameLayout.LayoutParams(FrameLayout.LayoutParams.MATCH_PARENT,
-					FrameLayout.LayoutParams.WRAP_CONTENT, Gravity.CENTER_HORIZONTAL);
-
-			// Create Loading Views ready for use later
-			FrameLayout frame = new FrameLayout(getContext());
-			mHeaderLoadingView = createLoadingLayout(getContext(), Mode.PULL_FROM_START, a);
-			mHeaderLoadingView.setVisibility(View.GONE);
-			frame.addView(mHeaderLoadingView, lp);
-			mRefreshableView.addHeaderView(frame, null, false);
-
-			mLvFooterLoadingFrame = new FrameLayout(getContext());
-			mFooterLoadingView = createLoadingLayout(getContext(), Mode.PULL_FROM_END, a);
-			mFooterLoadingView.setVisibility(View.GONE);
-			mLvFooterLoadingFrame.addView(mFooterLoadingView, lp);
-
-			/**
-			 * If the value for Scrolling While Refreshing hasn't been
-			 * explicitly set via XML, enable Scrolling While Refreshing.
-			 */
-			if (!a.hasValue(R.styleable.PullToRefresh_ptrScrollingWhileRefreshingEnabled)) {
-				setScrollingWhileRefreshingEnabled(true);
-			}
-		}
-	}
-
-	@TargetApi(9)
-	final class InternalListViewSDK9 extends InternalListView {
-
-		public InternalListViewSDK9(Context context, AttributeSet attrs) {
-			super(context, attrs);
-		}
-
-		@Override
-		protected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX,
-				int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent) {
-
-			final boolean returnValue = super.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX,
-					scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent);
-
-			// Does all of the hard work...
-			OverscrollHelper.overScrollBy(PullToRefreshListView.this, deltaX, scrollX, deltaY, scrollY, isTouchEvent);
-
-			return returnValue;
-		}
-	}
-
-	protected class InternalListView extends ListView implements EmptyViewMethodAccessor {
-
-		private boolean mAddedLvFooter = false;
-
-		public InternalListView(Context context, AttributeSet attrs) {
-			super(context, attrs);
-		}
-
-		@Override
-		protected void dispatchDraw(Canvas canvas) {
-			/**
-			 * This is a bit hacky, but Samsung's ListView has got a bug in it
-			 * when using Header/Footer Views and the list is empty. This masks
-			 * the issue so that it doesn't cause an FC. See Issue #66.
-			 */
-			try {
-				super.dispatchDraw(canvas);
-			} catch (IndexOutOfBoundsException e) {
-				e.printStackTrace();
-			}
-		}
-
-		@Override
-		public boolean dispatchTouchEvent(MotionEvent ev) {
-			/**
-			 * This is a bit hacky, but Samsung's ListView has got a bug in it
-			 * when using Header/Footer Views and the list is empty. This masks
-			 * the issue so that it doesn't cause an FC. See Issue #66.
-			 */
-			try {
-				return super.dispatchTouchEvent(ev);
-			} catch (IndexOutOfBoundsException e) {
-				e.printStackTrace();
-				return false;
-			}
-		}
-
-		@Override
-		public void setAdapter(ListAdapter adapter) {
-			// Add the Footer View at the last possible moment
-			if (null != mLvFooterLoadingFrame && !mAddedLvFooter) {
-				addFooterView(mLvFooterLoadingFrame, null, false);
-				mAddedLvFooter = true;
-			}
-
-			super.setAdapter(adapter);
-		}
-
-		@Override
-		public void setEmptyView(View emptyView) {
-			PullToRefreshListView.this.setEmptyView(emptyView);
-		}
-
-		@Override
-		public void setEmptyViewInternal(View emptyView) {
-			super.setEmptyView(emptyView);
-		}
-
-	}
-
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshScrollView.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshScrollView.java
deleted file mode 100644
index 3ae3627..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshScrollView.java
+++ /dev/null
@@ -1,109 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.library;
-
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.os.Build.VERSION;
-import android.os.Build.VERSION_CODES;
-import android.util.AttributeSet;
-import android.view.View;
-import android.widget.ScrollView;
-
-public class PullToRefreshScrollView extends PullToRefreshBase<ScrollView> {
-
-	public PullToRefreshScrollView(Context context) {
-		super(context);
-	}
-
-	public PullToRefreshScrollView(Context context, AttributeSet attrs) {
-		super(context, attrs);
-	}
-
-	public PullToRefreshScrollView(Context context, Mode mode) {
-		super(context, mode);
-	}
-
-	public PullToRefreshScrollView(Context context, Mode mode, AnimationStyle style) {
-		super(context, mode, style);
-	}
-
-	@Override
-	public final Orientation getPullToRefreshScrollDirection() {
-		return Orientation.VERTICAL;
-	}
-
-	@Override
-	protected ScrollView createRefreshableView(Context context, AttributeSet attrs) {
-		ScrollView scrollView;
-		if (VERSION.SDK_INT >= VERSION_CODES.GINGERBREAD) {
-			scrollView = new InternalScrollViewSDK9(context, attrs);
-		} else {
-			scrollView = new ScrollView(context, attrs);
-		}
-
-		scrollView.setId(R.id.scrollview);
-		return scrollView;
-	}
-
-	@Override
-	protected boolean isReadyForPullStart() {
-		return mRefreshableView.getScrollY() == 0;
-	}
-
-	@Override
-	protected boolean isReadyForPullEnd() {
-		View scrollViewChild = mRefreshableView.getChildAt(0);
-		if (null != scrollViewChild) {
-			return mRefreshableView.getScrollY() >= (scrollViewChild.getHeight() - getHeight());
-		}
-		return false;
-	}
-
-	@TargetApi(9)
-	final class InternalScrollViewSDK9 extends ScrollView {
-
-		public InternalScrollViewSDK9(Context context, AttributeSet attrs) {
-			super(context, attrs);
-		}
-
-		@Override
-		protected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX,
-				int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent) {
-
-			final boolean returnValue = super.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX,
-					scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent);
-
-			// Does all of the hard work...
-			OverscrollHelper.overScrollBy(PullToRefreshScrollView.this, deltaX, scrollX, deltaY, scrollY,
-					getScrollRange(), isTouchEvent);
-
-			return returnValue;
-		}
-
-		/**
-		 * Taken from the AOSP ScrollView source
-		 */
-		private int getScrollRange() {
-			int scrollRange = 0;
-			if (getChildCount() > 0) {
-				View child = getChildAt(0);
-				scrollRange = Math.max(0, child.getHeight() - (getHeight() - getPaddingBottom() - getPaddingTop()));
-			}
-			return scrollRange;
-		}
-	}
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshWebView.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshWebView.java
deleted file mode 100644
index 3f873de..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/PullToRefreshWebView.java
+++ /dev/null
@@ -1,165 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.library;
-
-import android.annotation.TargetApi;
-import android.content.Context;
-import android.os.Build.VERSION;
-import android.os.Build.VERSION_CODES;
-import android.os.Bundle;
-import android.util.AttributeSet;
-import android.util.FloatMath;
-import android.webkit.WebChromeClient;
-import android.webkit.WebView;
-
-public class PullToRefreshWebView extends PullToRefreshBase<WebView> {
-
-	private static final OnRefreshListener<WebView> defaultOnRefreshListener = new OnRefreshListener<WebView>() {
-
-		@Override
-		public void onRefresh(PullToRefreshBase<WebView> refreshView) {
-			refreshView.getRefreshableView().reload();
-		}
-
-	};
-
-	private final WebChromeClient defaultWebChromeClient = new WebChromeClient() {
-
-		@Override
-		public void onProgressChanged(WebView view, int newProgress) {
-			if (newProgress == 100) {
-				onRefreshComplete();
-			}
-		}
-
-	};
-
-	public PullToRefreshWebView(Context context) {
-		super(context);
-
-		/**
-		 * Added so that by default, Pull-to-Refresh refreshes the page
-		 */
-		setOnRefreshListener(defaultOnRefreshListener);
-		mRefreshableView.setWebChromeClient(defaultWebChromeClient);
-	}
-
-	public PullToRefreshWebView(Context context, AttributeSet attrs) {
-		super(context, attrs);
-
-		/**
-		 * Added so that by default, Pull-to-Refresh refreshes the page
-		 */
-		setOnRefreshListener(defaultOnRefreshListener);
-		mRefreshableView.setWebChromeClient(defaultWebChromeClient);
-	}
-
-	public PullToRefreshWebView(Context context, Mode mode) {
-		super(context, mode);
-
-		/**
-		 * Added so that by default, Pull-to-Refresh refreshes the page
-		 */
-		setOnRefreshListener(defaultOnRefreshListener);
-		mRefreshableView.setWebChromeClient(defaultWebChromeClient);
-	}
-
-	public PullToRefreshWebView(Context context, Mode mode, AnimationStyle style) {
-		super(context, mode, style);
-
-		/**
-		 * Added so that by default, Pull-to-Refresh refreshes the page
-		 */
-		setOnRefreshListener(defaultOnRefreshListener);
-		mRefreshableView.setWebChromeClient(defaultWebChromeClient);
-	}
-
-	@Override
-	public final Orientation getPullToRefreshScrollDirection() {
-		return Orientation.VERTICAL;
-	}
-
-	@Override
-	protected WebView createRefreshableView(Context context, AttributeSet attrs) {
-		WebView webView;
-		if (VERSION.SDK_INT >= VERSION_CODES.GINGERBREAD) {
-			webView = new InternalWebViewSDK9(context, attrs);
-		} else {
-			webView = new WebView(context, attrs);
-		}
-
-		webView.setId(R.id.webview);
-		return webView;
-	}
-
-	@Override
-	protected boolean isReadyForPullStart() {
-		return mRefreshableView.getScrollY() == 0;
-	}
-
-	@Override
-	protected boolean isReadyForPullEnd() {
-		float exactContentHeight = FloatMath.floor(mRefreshableView.getContentHeight() * mRefreshableView.getScale());
-		return mRefreshableView.getScrollY() >= (exactContentHeight - mRefreshableView.getHeight());
-	}
-
-	@Override
-	protected void onPtrRestoreInstanceState(Bundle savedInstanceState) {
-		super.onPtrRestoreInstanceState(savedInstanceState);
-		mRefreshableView.restoreState(savedInstanceState);
-	}
-
-	@Override
-	protected void onPtrSaveInstanceState(Bundle saveState) {
-		super.onPtrSaveInstanceState(saveState);
-		mRefreshableView.saveState(saveState);
-	}
-
-	@TargetApi(9)
-	final class InternalWebViewSDK9 extends WebView {
-
-		// WebView doesn't always scroll back to it's edge so we add some
-		// fuzziness
-		static final int OVERSCROLL_FUZZY_THRESHOLD = 2;
-
-		// WebView seems quite reluctant to overscroll so we use the scale
-		// factor to scale it's value
-		static final float OVERSCROLL_SCALE_FACTOR = 1.5f;
-
-		public InternalWebViewSDK9(Context context, AttributeSet attrs) {
-			super(context, attrs);
-		}
-
-		@Override
-		protected boolean overScrollBy(int deltaX, int deltaY, int scrollX, int scrollY, int scrollRangeX,
-				int scrollRangeY, int maxOverScrollX, int maxOverScrollY, boolean isTouchEvent) {
-
-			final boolean returnValue = super.overScrollBy(deltaX, deltaY, scrollX, scrollY, scrollRangeX,
-					scrollRangeY, maxOverScrollX, maxOverScrollY, isTouchEvent);
-
-			// Does all of the hard work...
-			OverscrollHelper.overScrollBy(PullToRefreshWebView.this, deltaX, scrollX, deltaY, scrollY,
-					getScrollRange(), OVERSCROLL_FUZZY_THRESHOLD, OVERSCROLL_SCALE_FACTOR, isTouchEvent);
-
-			return returnValue;
-		}
-
-		private int getScrollRange() {
-			return (int) Math.max(0, FloatMath.floor(mRefreshableView.getContentHeight() * mRefreshableView.getScale())
-					- (getHeight() - getPaddingBottom() - getPaddingTop()));
-		}
-	}
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/extras/PullToRefreshWebView2.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/extras/PullToRefreshWebView2.java
deleted file mode 100644
index 7819203..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/extras/PullToRefreshWebView2.java
+++ /dev/null
@@ -1,132 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.library.extras;
-
-import java.util.concurrent.atomic.AtomicBoolean;
-
-import android.content.Context;
-import android.util.AttributeSet;
-import android.webkit.WebView;
-
-import com.handmark.pulltorefresh.library.PullToRefreshWebView;
-
-/**
- * An advanced version of {@link PullToRefreshWebView} which delegates the
- * triggering of the PullToRefresh gesture to the Javascript running within the
- * WebView. This means that you should only use this class if:
- * <p/>
- * <ul>
- * <li>{@link PullToRefreshWebView} doesn't work correctly because you're using
- * <code>overflow:scroll</code> or something else which means
- * {@link WebView#getScrollY()} doesn't return correct values.</li>
- * <li>You control the web content being displayed, as you need to write some
- * Javascript callbacks.</li>
- * </ul>
- * <p/>
- * <p/>
- * The way this call works is that when a PullToRefresh gesture is in action,
- * the following Javascript methods will be called:
- * <code>isReadyForPullDown()</code> and <code>isReadyForPullUp()</code>, it is
- * your job to calculate whether the view is in a state where a PullToRefresh
- * can happen, and return the result via the callback mechanism. An example can
- * be seen below:
- * <p/>
- * 
- * <pre>
- * function isReadyForPullDown() {
- *   var result = ...  // Probably using the .scrollTop DOM attribute
- *   ptr.isReadyForPullDownResponse(result);
- * }
- * 
- * function isReadyForPullUp() {
- *   var result = ...  // Probably using the .scrollBottom DOM attribute
- *   ptr.isReadyForPullUpResponse(result);
- * }
- * </pre>
- * 
- * @author Chris Banes
- */
-public class PullToRefreshWebView2 extends PullToRefreshWebView {
-
-	static final String JS_INTERFACE_PKG = "ptr";
-	static final String DEF_JS_READY_PULL_DOWN_CALL = "javascript:isReadyForPullDown();";
-	static final String DEF_JS_READY_PULL_UP_CALL = "javascript:isReadyForPullUp();";
-
-	public PullToRefreshWebView2(Context context) {
-		super(context);
-	}
-
-	public PullToRefreshWebView2(Context context, AttributeSet attrs) {
-		super(context, attrs);
-	}
-
-	public PullToRefreshWebView2(Context context, Mode mode) {
-		super(context, mode);
-	}
-
-	private JsValueCallback mJsCallback;
-	private final AtomicBoolean mIsReadyForPullDown = new AtomicBoolean(false);
-	private final AtomicBoolean mIsReadyForPullUp = new AtomicBoolean(false);
-
-	@Override
-	protected WebView createRefreshableView(Context context, AttributeSet attrs) {
-		WebView webView = super.createRefreshableView(context, attrs);
-
-		// Need to add JS Interface so we can get the response back
-		mJsCallback = new JsValueCallback();
-		webView.addJavascriptInterface(mJsCallback, JS_INTERFACE_PKG);
-
-		return webView;
-	}
-
-	@Override
-	protected boolean isReadyForPullStart() {
-		// Call Javascript...
-		getRefreshableView().loadUrl(DEF_JS_READY_PULL_DOWN_CALL);
-
-		// Response will be given to JsValueCallback, which will update
-		// mIsReadyForPullDown
-
-		return mIsReadyForPullDown.get();
-	}
-
-	@Override
-	protected boolean isReadyForPullEnd() {
-		// Call Javascript...
-		getRefreshableView().loadUrl(DEF_JS_READY_PULL_UP_CALL);
-
-		// Response will be given to JsValueCallback, which will update
-		// mIsReadyForPullUp
-
-		return mIsReadyForPullUp.get();
-	}
-
-	/**
-	 * Used for response from Javascript
-	 * 
-	 * @author Chris Banes
-	 */
-	final class JsValueCallback {
-
-		public void isReadyForPullUpResponse(boolean response) {
-			mIsReadyForPullUp.set(response);
-		}
-
-		public void isReadyForPullDownResponse(boolean response) {
-			mIsReadyForPullDown.set(response);
-		}
-	}
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/extras/SoundPullEventListener.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/extras/SoundPullEventListener.java
deleted file mode 100644
index a7aac30..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/extras/SoundPullEventListener.java
+++ /dev/null
@@ -1,96 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.library.extras;
-
-import java.util.HashMap;
-
-import android.content.Context;
-import android.media.MediaPlayer;
-import android.view.View;
-
-import com.handmark.pulltorefresh.library.PullToRefreshBase;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.Mode;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.State;
-
-public class SoundPullEventListener<V extends View> implements PullToRefreshBase.OnPullEventListener<V> {
-
-	private final Context mContext;
-	private final HashMap<State, Integer> mSoundMap;
-
-	private MediaPlayer mCurrentMediaPlayer;
-
-	/**
-	 * Constructor
-	 * 
-	 * @param context - Context
-	 */
-	public SoundPullEventListener(Context context) {
-		mContext = context;
-		mSoundMap = new HashMap<State, Integer>();
-	}
-
-	@Override
-	public final void onPullEvent(PullToRefreshBase<V> refreshView, State event, Mode direction) {
-		Integer soundResIdObj = mSoundMap.get(event);
-		if (null != soundResIdObj) {
-			playSound(soundResIdObj.intValue());
-		}
-	}
-
-	/**
-	 * Set the Sounds to be played when a Pull Event happens. You specify which
-	 * sound plays for which events by calling this method multiple times for
-	 * each event.
-	 * <p/>
-	 * If you've already set a sound for a certain event, and add another sound
-	 * for that event, only the new sound will be played.
-	 * 
-	 * @param event - The event for which the sound will be played.
-	 * @param resId - Resource Id of the sound file to be played (e.g.
-	 *            <var>R.raw.pull_sound</var>)
-	 */
-	public void addSoundEvent(State event, int resId) {
-		mSoundMap.put(event, resId);
-	}
-
-	/**
-	 * Clears all of the previously set sounds and events.
-	 */
-	public void clearSounds() {
-		mSoundMap.clear();
-	}
-
-	/**
-	 * Gets the current (or last) MediaPlayer instance.
-	 */
-	public MediaPlayer getCurrentMediaPlayer() {
-		return mCurrentMediaPlayer;
-	}
-
-	private void playSound(int resId) {
-		// Stop current player, if there's one playing
-		if (null != mCurrentMediaPlayer) {
-			mCurrentMediaPlayer.stop();
-			mCurrentMediaPlayer.release();
-		}
-
-		mCurrentMediaPlayer = MediaPlayer.create(mContext, resId);
-		if (null != mCurrentMediaPlayer) {
-			mCurrentMediaPlayer.start();
-		}
-	}
-
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/EmptyViewMethodAccessor.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/EmptyViewMethodAccessor.java
deleted file mode 100644
index 369f21e..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/EmptyViewMethodAccessor.java
+++ /dev/null
@@ -1,43 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.library.internal;
-
-import android.view.View;
-
-/**
- * Interface that allows PullToRefreshBase to hijack the call to
- * AdapterView.setEmptyView()
- * 
- * @author chris
- */
-public interface EmptyViewMethodAccessor {
-
-	/**
-	 * Calls upto AdapterView.setEmptyView()
-	 * 
-	 * @param emptyView - to set as Empty View
-	 */
-	public void setEmptyViewInternal(View emptyView);
-
-	/**
-	 * Should call PullToRefreshBase.setEmptyView() which will then
-	 * automatically call through to setEmptyViewInternal()
-	 * 
-	 * @param emptyView - to set as Empty View
-	 */
-	public void setEmptyView(View emptyView);
-
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/FlipLoadingLayout.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/FlipLoadingLayout.java
deleted file mode 100644
index fef3160..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/FlipLoadingLayout.java
+++ /dev/null
@@ -1,146 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.library.internal;
-
-import android.annotation.SuppressLint;
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.graphics.Matrix;
-import android.graphics.drawable.Drawable;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.animation.Animation;
-import android.view.animation.RotateAnimation;
-import android.widget.ImageView.ScaleType;
-
-import com.handmark.pulltorefresh.library.PullToRefreshBase.Mode;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.Orientation;
-import com.handmark.pulltorefresh.library.R;
-
-@SuppressLint("ViewConstructor")
-public class FlipLoadingLayout extends LoadingLayout {
-
-	static final int FLIP_ANIMATION_DURATION = 150;
-
-	private final Animation mRotateAnimation, mResetRotateAnimation;
-
-	public FlipLoadingLayout(Context context, final Mode mode, final Orientation scrollDirection, TypedArray attrs) {
-		super(context, mode, scrollDirection, attrs);
-
-		final int rotateAngle = mode == Mode.PULL_FROM_START ? -180 : 180;
-
-		mRotateAnimation = new RotateAnimation(0, rotateAngle, Animation.RELATIVE_TO_SELF, 0.5f,
-				Animation.RELATIVE_TO_SELF, 0.5f);
-		mRotateAnimation.setInterpolator(ANIMATION_INTERPOLATOR);
-		mRotateAnimation.setDuration(FLIP_ANIMATION_DURATION);
-		mRotateAnimation.setFillAfter(true);
-
-		mResetRotateAnimation = new RotateAnimation(rotateAngle, 0, Animation.RELATIVE_TO_SELF, 0.5f,
-				Animation.RELATIVE_TO_SELF, 0.5f);
-		mResetRotateAnimation.setInterpolator(ANIMATION_INTERPOLATOR);
-		mResetRotateAnimation.setDuration(FLIP_ANIMATION_DURATION);
-		mResetRotateAnimation.setFillAfter(true);
-	}
-
-	@Override
-	protected void onLoadingDrawableSet(Drawable imageDrawable) {
-		if (null != imageDrawable) {
-			final int dHeight = imageDrawable.getIntrinsicHeight();
-			final int dWidth = imageDrawable.getIntrinsicWidth();
-
-			/**
-			 * We need to set the width/height of the ImageView so that it is
-			 * square with each side the size of the largest drawable dimension.
-			 * This is so that it doesn't clip when rotated.
-			 */
-			ViewGroup.LayoutParams lp = mHeaderImage.getLayoutParams();
-			lp.width = lp.height = Math.max(dHeight, dWidth);
-			mHeaderImage.requestLayout();
-
-			/**
-			 * We now rotate the Drawable so that is at the correct rotation,
-			 * and is centered.
-			 */
-			mHeaderImage.setScaleType(ScaleType.MATRIX);
-			Matrix matrix = new Matrix();
-			matrix.postTranslate((lp.width - dWidth) / 2f, (lp.height - dHeight) / 2f);
-			matrix.postRotate(getDrawableRotationAngle(), lp.width / 2f, lp.height / 2f);
-			mHeaderImage.setImageMatrix(matrix);
-		}
-	}
-
-	@Override
-	protected void onPullImpl(float scaleOfLayout) {
-		// NO-OP
-	}
-
-	@Override
-	protected void pullToRefreshImpl() {
-		// Only start reset Animation, we've previously show the rotate anim
-		if (mRotateAnimation == mHeaderImage.getAnimation()) {
-			mHeaderImage.startAnimation(mResetRotateAnimation);
-		}
-	}
-
-	@Override
-	protected void refreshingImpl() {
-		mHeaderImage.clearAnimation();
-		mHeaderImage.setVisibility(View.INVISIBLE);
-		mHeaderProgress.setVisibility(View.VISIBLE);
-	}
-
-	@Override
-	protected void releaseToRefreshImpl() {
-		mHeaderImage.startAnimation(mRotateAnimation);
-	}
-
-	@Override
-	protected void resetImpl() {
-		mHeaderImage.clearAnimation();
-		mHeaderProgress.setVisibility(View.GONE);
-		mHeaderImage.setVisibility(View.VISIBLE);
-	}
-
-	@Override
-	protected int getDefaultDrawableResId() {
-		return R.drawable.default_ptr_flip;
-	}
-
-	private float getDrawableRotationAngle() {
-		float angle = 0f;
-		switch (mMode) {
-			case PULL_FROM_END:
-				if (mScrollDirection == Orientation.HORIZONTAL) {
-					angle = 90f;
-				} else {
-					angle = 180f;
-				}
-				break;
-
-			case PULL_FROM_START:
-				if (mScrollDirection == Orientation.HORIZONTAL) {
-					angle = 270f;
-				}
-				break;
-
-			default:
-				break;
-		}
-
-		return angle;
-	}
-
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/IndicatorLayout.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/IndicatorLayout.java
deleted file mode 100644
index a9069f2..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/IndicatorLayout.java
+++ /dev/null
@@ -1,147 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.library.internal;
-
-import android.annotation.SuppressLint;
-import android.content.Context;
-import android.graphics.Matrix;
-import android.graphics.drawable.Drawable;
-import android.view.View;
-import android.view.animation.Animation;
-import android.view.animation.Animation.AnimationListener;
-import android.view.animation.AnimationUtils;
-import android.view.animation.Interpolator;
-import android.view.animation.LinearInterpolator;
-import android.view.animation.RotateAnimation;
-import android.widget.FrameLayout;
-import android.widget.ImageView;
-import android.widget.ImageView.ScaleType;
-
-import com.handmark.pulltorefresh.library.PullToRefreshBase;
-import com.handmark.pulltorefresh.library.R;
-
-@SuppressLint("ViewConstructor")
-public class IndicatorLayout extends FrameLayout implements AnimationListener {
-
-	static final int DEFAULT_ROTATION_ANIMATION_DURATION = 150;
-
-	private Animation mInAnim, mOutAnim;
-	private ImageView mArrowImageView;
-
-	private final Animation mRotateAnimation, mResetRotateAnimation;
-
-	public IndicatorLayout(Context context, PullToRefreshBase.Mode mode) {
-		super(context);
-		mArrowImageView = new ImageView(context);
-
-		Drawable arrowD = getResources().getDrawable(R.drawable.indicator_arrow);
-		mArrowImageView.setImageDrawable(arrowD);
-
-		final int padding = getResources().getDimensionPixelSize(R.dimen.indicator_internal_padding);
-		mArrowImageView.setPadding(padding, padding, padding, padding);
-		addView(mArrowImageView);
-
-		int inAnimResId, outAnimResId;
-		switch (mode) {
-			case PULL_FROM_END:
-				inAnimResId = R.anim.slide_in_from_bottom;
-				outAnimResId = R.anim.slide_out_to_bottom;
-				setBackgroundResource(R.drawable.indicator_bg_bottom);
-
-				// Rotate Arrow so it's pointing the correct way
-				mArrowImageView.setScaleType(ScaleType.MATRIX);
-				Matrix matrix = new Matrix();
-				matrix.setRotate(180f, arrowD.getIntrinsicWidth() / 2f, arrowD.getIntrinsicHeight() / 2f);
-				mArrowImageView.setImageMatrix(matrix);
-				break;
-			default:
-			case PULL_FROM_START:
-				inAnimResId = R.anim.slide_in_from_top;
-				outAnimResId = R.anim.slide_out_to_top;
-				setBackgroundResource(R.drawable.indicator_bg_top);
-				break;
-		}
-
-		mInAnim = AnimationUtils.loadAnimation(context, inAnimResId);
-		mInAnim.setAnimationListener(this);
-
-		mOutAnim = AnimationUtils.loadAnimation(context, outAnimResId);
-		mOutAnim.setAnimationListener(this);
-
-		final Interpolator interpolator = new LinearInterpolator();
-		mRotateAnimation = new RotateAnimation(0, -180, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF,
-				0.5f);
-		mRotateAnimation.setInterpolator(interpolator);
-		mRotateAnimation.setDuration(DEFAULT_ROTATION_ANIMATION_DURATION);
-		mRotateAnimation.setFillAfter(true);
-
-		mResetRotateAnimation = new RotateAnimation(-180, 0, Animation.RELATIVE_TO_SELF, 0.5f,
-				Animation.RELATIVE_TO_SELF, 0.5f);
-		mResetRotateAnimation.setInterpolator(interpolator);
-		mResetRotateAnimation.setDuration(DEFAULT_ROTATION_ANIMATION_DURATION);
-		mResetRotateAnimation.setFillAfter(true);
-
-	}
-
-	public final boolean isVisible() {
-		Animation currentAnim = getAnimation();
-		if (null != currentAnim) {
-			return mInAnim == currentAnim;
-		}
-
-		return getVisibility() == View.VISIBLE;
-	}
-
-	public void hide() {
-		startAnimation(mOutAnim);
-	}
-
-	public void show() {
-		mArrowImageView.clearAnimation();
-		startAnimation(mInAnim);
-	}
-
-	@Override
-	public void onAnimationEnd(Animation animation) {
-		if (animation == mOutAnim) {
-			mArrowImageView.clearAnimation();
-			setVisibility(View.GONE);
-		} else if (animation == mInAnim) {
-			setVisibility(View.VISIBLE);
-		}
-
-		clearAnimation();
-	}
-
-	@Override
-	public void onAnimationRepeat(Animation animation) {
-		// NO-OP
-	}
-
-	@Override
-	public void onAnimationStart(Animation animation) {
-		setVisibility(View.VISIBLE);
-	}
-
-	public void releaseToRefresh() {
-		mArrowImageView.startAnimation(mRotateAnimation);
-	}
-
-	public void pullToRefresh() {
-		mArrowImageView.startAnimation(mResetRotateAnimation);
-	}
-
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/LoadingLayout.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/LoadingLayout.java
deleted file mode 100644
index 9c12586..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/LoadingLayout.java
+++ /dev/null
@@ -1,393 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.library.internal;
-
-import android.annotation.SuppressLint;
-import android.content.Context;
-import android.content.res.ColorStateList;
-import android.content.res.TypedArray;
-import android.graphics.Typeface;
-import android.graphics.drawable.AnimationDrawable;
-import android.graphics.drawable.Drawable;
-import android.text.TextUtils;
-import android.util.TypedValue;
-import android.view.Gravity;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.animation.Interpolator;
-import android.view.animation.LinearInterpolator;
-import android.widget.FrameLayout;
-import android.widget.ImageView;
-import android.widget.ProgressBar;
-import android.widget.TextView;
-
-import com.handmark.pulltorefresh.library.ILoadingLayout;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.Mode;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.Orientation;
-import com.handmark.pulltorefresh.library.R;
-
-@SuppressLint("ViewConstructor")
-public abstract class LoadingLayout extends FrameLayout implements ILoadingLayout {
-
-	static final String LOG_TAG = "PullToRefresh-LoadingLayout";
-
-	static final Interpolator ANIMATION_INTERPOLATOR = new LinearInterpolator();
-
-	private FrameLayout mInnerLayout;
-
-	protected final ImageView mHeaderImage;
-	protected final ProgressBar mHeaderProgress;
-
-	private boolean mUseIntrinsicAnimation;
-
-	private final TextView mHeaderText;
-	private final TextView mSubHeaderText;
-
-	protected final Mode mMode;
-	protected final Orientation mScrollDirection;
-
-	private CharSequence mPullLabel;
-	private CharSequence mRefreshingLabel;
-	private CharSequence mReleaseLabel;
-
-	public LoadingLayout(Context context, final Mode mode, final Orientation scrollDirection, TypedArray attrs) {
-		super(context);
-		mMode = mode;
-		mScrollDirection = scrollDirection;
-
-		switch (scrollDirection) {
-			case HORIZONTAL:
-				LayoutInflater.from(context).inflate(R.layout.pull_to_refresh_header_horizontal, this);
-				break;
-			case VERTICAL:
-			default:
-				LayoutInflater.from(context).inflate(R.layout.pull_to_refresh_header_vertical, this);
-				break;
-		}
-
-		mInnerLayout = (FrameLayout) findViewById(R.id.fl_inner);
-		mHeaderText = (TextView) mInnerLayout.findViewById(R.id.pull_to_refresh_text);
-		mHeaderProgress = (ProgressBar) mInnerLayout.findViewById(R.id.pull_to_refresh_progress);
-		mSubHeaderText = (TextView) mInnerLayout.findViewById(R.id.pull_to_refresh_sub_text);
-		mHeaderImage = (ImageView) mInnerLayout.findViewById(R.id.pull_to_refresh_image);
-
-		FrameLayout.LayoutParams lp = (FrameLayout.LayoutParams) mInnerLayout.getLayoutParams();
-
-		switch (mode) {
-			case PULL_FROM_END:
-				lp.gravity = scrollDirection == Orientation.VERTICAL ? Gravity.TOP : Gravity.LEFT;
-
-				// Load in labels
-				mPullLabel = context.getString(R.string.pull_to_refresh_from_bottom_pull_label);
-				mRefreshingLabel = context.getString(R.string.pull_to_refresh_from_bottom_refreshing_label);
-				mReleaseLabel = context.getString(R.string.pull_to_refresh_from_bottom_release_label);
-				break;
-
-			case PULL_FROM_START:
-			default:
-				lp.gravity = scrollDirection == Orientation.VERTICAL ? Gravity.BOTTOM : Gravity.RIGHT;
-
-				// Load in labels
-				mPullLabel = context.getString(R.string.pull_to_refresh_pull_label);
-				mRefreshingLabel = context.getString(R.string.pull_to_refresh_refreshing_label);
-				mReleaseLabel = context.getString(R.string.pull_to_refresh_release_label);
-				break;
-		}
-
-		if (attrs.hasValue(R.styleable.PullToRefresh_ptrHeaderBackground)) {
-			Drawable background = attrs.getDrawable(R.styleable.PullToRefresh_ptrHeaderBackground);
-			if (null != background) {
-				ViewCompat.setBackground(this, background);
-			}
-		}
-
-		if (attrs.hasValue(R.styleable.PullToRefresh_ptrHeaderTextAppearance)) {
-			TypedValue styleID = new TypedValue();
-			attrs.getValue(R.styleable.PullToRefresh_ptrHeaderTextAppearance, styleID);
-			setTextAppearance(styleID.data);
-		}
-		if (attrs.hasValue(R.styleable.PullToRefresh_ptrSubHeaderTextAppearance)) {
-			TypedValue styleID = new TypedValue();
-			attrs.getValue(R.styleable.PullToRefresh_ptrSubHeaderTextAppearance, styleID);
-			setSubTextAppearance(styleID.data);
-		}
-
-		// Text Color attrs need to be set after TextAppearance attrs
-		if (attrs.hasValue(R.styleable.PullToRefresh_ptrHeaderTextColor)) {
-			ColorStateList colors = attrs.getColorStateList(R.styleable.PullToRefresh_ptrHeaderTextColor);
-			if (null != colors) {
-				setTextColor(colors);
-			}
-		}
-		if (attrs.hasValue(R.styleable.PullToRefresh_ptrHeaderSubTextColor)) {
-			ColorStateList colors = attrs.getColorStateList(R.styleable.PullToRefresh_ptrHeaderSubTextColor);
-			if (null != colors) {
-				setSubTextColor(colors);
-			}
-		}
-
-		// Try and get defined drawable from Attrs
-		Drawable imageDrawable = null;
-		if (attrs.hasValue(R.styleable.PullToRefresh_ptrDrawable)) {
-			imageDrawable = attrs.getDrawable(R.styleable.PullToRefresh_ptrDrawable);
-		}
-
-		// Check Specific Drawable from Attrs, these overrite the generic
-		// drawable attr above
-		switch (mode) {
-			case PULL_FROM_START:
-			default:
-				if (attrs.hasValue(R.styleable.PullToRefresh_ptrDrawableStart)) {
-					imageDrawable = attrs.getDrawable(R.styleable.PullToRefresh_ptrDrawableStart);
-				} else if (attrs.hasValue(R.styleable.PullToRefresh_ptrDrawableTop)) {
-					Utils.warnDeprecation("ptrDrawableTop", "ptrDrawableStart");
-					imageDrawable = attrs.getDrawable(R.styleable.PullToRefresh_ptrDrawableTop);
-				}
-				break;
-
-			case PULL_FROM_END:
-				if (attrs.hasValue(R.styleable.PullToRefresh_ptrDrawableEnd)) {
-					imageDrawable = attrs.getDrawable(R.styleable.PullToRefresh_ptrDrawableEnd);
-				} else if (attrs.hasValue(R.styleable.PullToRefresh_ptrDrawableBottom)) {
-					Utils.warnDeprecation("ptrDrawableBottom", "ptrDrawableEnd");
-					imageDrawable = attrs.getDrawable(R.styleable.PullToRefresh_ptrDrawableBottom);
-				}
-				break;
-		}
-
-		// If we don't have a user defined drawable, load the default
-		if (null == imageDrawable) {
-			imageDrawable = context.getResources().getDrawable(getDefaultDrawableResId());
-		}
-
-		// Set Drawable, and save width/height
-		setLoadingDrawable(imageDrawable);
-
-		reset();
-	}
-
-	public final void setHeight(int height) {
-		ViewGroup.LayoutParams lp = (ViewGroup.LayoutParams) getLayoutParams();
-		lp.height = height;
-		requestLayout();
-	}
-
-	public final void setWidth(int width) {
-		ViewGroup.LayoutParams lp = (ViewGroup.LayoutParams) getLayoutParams();
-		lp.width = width;
-		requestLayout();
-	}
-
-	public final int getContentSize() {
-		switch (mScrollDirection) {
-			case HORIZONTAL:
-				return mInnerLayout.getWidth();
-			case VERTICAL:
-			default:
-				return mInnerLayout.getHeight();
-		}
-	}
-
-	public final void hideAllViews() {
-		if (View.VISIBLE == mHeaderText.getVisibility()) {
-			mHeaderText.setVisibility(View.INVISIBLE);
-		}
-		if (View.VISIBLE == mHeaderProgress.getVisibility()) {
-			mHeaderProgress.setVisibility(View.INVISIBLE);
-		}
-		if (View.VISIBLE == mHeaderImage.getVisibility()) {
-			mHeaderImage.setVisibility(View.INVISIBLE);
-		}
-		if (View.VISIBLE == mSubHeaderText.getVisibility()) {
-			mSubHeaderText.setVisibility(View.INVISIBLE);
-		}
-	}
-
-	public final void onPull(float scaleOfLayout) {
-		if (!mUseIntrinsicAnimation) {
-			onPullImpl(scaleOfLayout);
-		}
-	}
-
-	public final void pullToRefresh() {
-		if (null != mHeaderText) {
-			mHeaderText.setText(mPullLabel);
-		}
-
-		// Now call the callback
-		pullToRefreshImpl();
-	}
-
-	public final void refreshing() {
-		if (null != mHeaderText) {
-			mHeaderText.setText(mRefreshingLabel);
-		}
-
-		if (mUseIntrinsicAnimation) {
-			((AnimationDrawable) mHeaderImage.getDrawable()).start();
-		} else {
-			// Now call the callback
-			refreshingImpl();
-		}
-
-		if (null != mSubHeaderText) {
-			mSubHeaderText.setVisibility(View.GONE);
-		}
-	}
-
-	public final void releaseToRefresh() {
-		if (null != mHeaderText) {
-			mHeaderText.setText(mReleaseLabel);
-		}
-
-		// Now call the callback
-		releaseToRefreshImpl();
-	}
-
-	public final void reset() {
-		if (null != mHeaderText) {
-			mHeaderText.setText(mPullLabel);
-		}
-		mHeaderImage.setVisibility(View.VISIBLE);
-
-		if (mUseIntrinsicAnimation) {
-			((AnimationDrawable) mHeaderImage.getDrawable()).stop();
-		} else {
-			// Now call the callback
-			resetImpl();
-		}
-
-		if (null != mSubHeaderText) {
-			if (TextUtils.isEmpty(mSubHeaderText.getText())) {
-				mSubHeaderText.setVisibility(View.GONE);
-			} else {
-				mSubHeaderText.setVisibility(View.VISIBLE);
-			}
-		}
-	}
-
-	@Override
-	public void setLastUpdatedLabel(CharSequence label) {
-		setSubHeaderText(label);
-	}
-
-	public final void setLoadingDrawable(Drawable imageDrawable) {
-		// Set Drawable
-		mHeaderImage.setImageDrawable(imageDrawable);
-		mUseIntrinsicAnimation = (imageDrawable instanceof AnimationDrawable);
-
-		// Now call the callback
-		onLoadingDrawableSet(imageDrawable);
-	}
-
-	public void setPullLabel(CharSequence pullLabel) {
-		mPullLabel = pullLabel;
-	}
-
-	public void setRefreshingLabel(CharSequence refreshingLabel) {
-		mRefreshingLabel = refreshingLabel;
-	}
-
-	public void setReleaseLabel(CharSequence releaseLabel) {
-		mReleaseLabel = releaseLabel;
-	}
-
-	@Override
-	public void setTextTypeface(Typeface tf) {
-		mHeaderText.setTypeface(tf);
-	}
-
-	public final void showInvisibleViews() {
-		if (View.INVISIBLE == mHeaderText.getVisibility()) {
-			mHeaderText.setVisibility(View.VISIBLE);
-		}
-		if (View.INVISIBLE == mHeaderProgress.getVisibility()) {
-			mHeaderProgress.setVisibility(View.VISIBLE);
-		}
-		if (View.INVISIBLE == mHeaderImage.getVisibility()) {
-			mHeaderImage.setVisibility(View.VISIBLE);
-		}
-		if (View.INVISIBLE == mSubHeaderText.getVisibility()) {
-			mSubHeaderText.setVisibility(View.VISIBLE);
-		}
-	}
-
-	/**
-	 * Callbacks for derivative Layouts
-	 */
-
-	protected abstract int getDefaultDrawableResId();
-
-	protected abstract void onLoadingDrawableSet(Drawable imageDrawable);
-
-	protected abstract void onPullImpl(float scaleOfLayout);
-
-	protected abstract void pullToRefreshImpl();
-
-	protected abstract void refreshingImpl();
-
-	protected abstract void releaseToRefreshImpl();
-
-	protected abstract void resetImpl();
-
-	private void setSubHeaderText(CharSequence label) {
-		if (null != mSubHeaderText) {
-			if (TextUtils.isEmpty(label)) {
-				mSubHeaderText.setVisibility(View.GONE);
-			} else {
-				mSubHeaderText.setText(label);
-
-				// Only set it to Visible if we're GONE, otherwise VISIBLE will
-				// be set soon
-				if (View.GONE == mSubHeaderText.getVisibility()) {
-					mSubHeaderText.setVisibility(View.VISIBLE);
-				}
-			}
-		}
-	}
-
-	private void setSubTextAppearance(int value) {
-		if (null != mSubHeaderText) {
-			mSubHeaderText.setTextAppearance(getContext(), value);
-		}
-	}
-
-	private void setSubTextColor(ColorStateList color) {
-		if (null != mSubHeaderText) {
-			mSubHeaderText.setTextColor(color);
-		}
-	}
-
-	private void setTextAppearance(int value) {
-		if (null != mHeaderText) {
-			mHeaderText.setTextAppearance(getContext(), value);
-		}
-		if (null != mSubHeaderText) {
-			mSubHeaderText.setTextAppearance(getContext(), value);
-		}
-	}
-
-	private void setTextColor(ColorStateList color) {
-		if (null != mHeaderText) {
-			mHeaderText.setTextColor(color);
-		}
-		if (null != mSubHeaderText) {
-			mSubHeaderText.setTextColor(color);
-		}
-	}
-
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/RotateLoadingLayout.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/RotateLoadingLayout.java
deleted file mode 100644
index bda7b2f..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/RotateLoadingLayout.java
+++ /dev/null
@@ -1,110 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.library.internal;
-
-import android.content.Context;
-import android.content.res.TypedArray;
-import android.graphics.Matrix;
-import android.graphics.drawable.Drawable;
-import android.view.animation.Animation;
-import android.view.animation.RotateAnimation;
-import android.widget.ImageView.ScaleType;
-
-import com.handmark.pulltorefresh.library.PullToRefreshBase.Mode;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.Orientation;
-import com.handmark.pulltorefresh.library.R;
-
-public class RotateLoadingLayout extends LoadingLayout {
-
-	static final int ROTATION_ANIMATION_DURATION = 1200;
-
-	private final Animation mRotateAnimation;
-	private final Matrix mHeaderImageMatrix;
-
-	private float mRotationPivotX, mRotationPivotY;
-
-	private final boolean mRotateDrawableWhilePulling;
-
-	public RotateLoadingLayout(Context context, Mode mode, Orientation scrollDirection, TypedArray attrs) {
-		super(context, mode, scrollDirection, attrs);
-
-		mRotateDrawableWhilePulling = attrs.getBoolean(R.styleable.PullToRefresh_ptrRotateDrawableWhilePulling, true);
-
-		mHeaderImage.setScaleType(ScaleType.MATRIX);
-		mHeaderImageMatrix = new Matrix();
-		mHeaderImage.setImageMatrix(mHeaderImageMatrix);
-
-		mRotateAnimation = new RotateAnimation(0, 720, Animation.RELATIVE_TO_SELF, 0.5f, Animation.RELATIVE_TO_SELF,
-				0.5f);
-		mRotateAnimation.setInterpolator(ANIMATION_INTERPOLATOR);
-		mRotateAnimation.setDuration(ROTATION_ANIMATION_DURATION);
-		mRotateAnimation.setRepeatCount(Animation.INFINITE);
-		mRotateAnimation.setRepeatMode(Animation.RESTART);
-	}
-
-	public void onLoadingDrawableSet(Drawable imageDrawable) {
-		if (null != imageDrawable) {
-			mRotationPivotX = Math.round(imageDrawable.getIntrinsicWidth() / 2f);
-			mRotationPivotY = Math.round(imageDrawable.getIntrinsicHeight() / 2f);
-		}
-	}
-
-	protected void onPullImpl(float scaleOfLayout) {
-		float angle;
-		if (mRotateDrawableWhilePulling) {
-			angle = scaleOfLayout * 90f;
-		} else {
-			angle = Math.max(0f, Math.min(180f, scaleOfLayout * 360f - 180f));
-		}
-
-		mHeaderImageMatrix.setRotate(angle, mRotationPivotX, mRotationPivotY);
-		mHeaderImage.setImageMatrix(mHeaderImageMatrix);
-	}
-
-	@Override
-	protected void refreshingImpl() {
-		mHeaderImage.startAnimation(mRotateAnimation);
-	}
-
-	@Override
-	protected void resetImpl() {
-		mHeaderImage.clearAnimation();
-		resetImageRotation();
-	}
-
-	private void resetImageRotation() {
-		if (null != mHeaderImageMatrix) {
-			mHeaderImageMatrix.reset();
-			mHeaderImage.setImageMatrix(mHeaderImageMatrix);
-		}
-	}
-
-	@Override
-	protected void pullToRefreshImpl() {
-		// NO-OP
-	}
-
-	@Override
-	protected void releaseToRefreshImpl() {
-		// NO-OP
-	}
-
-	@Override
-	protected int getDefaultDrawableResId() {
-		return R.drawable.default_ptr_rotate;
-	}
-
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/Utils.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/Utils.java
deleted file mode 100644
index 7343218..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/Utils.java
+++ /dev/null
@@ -1,13 +0,0 @@
-package com.handmark.pulltorefresh.library.internal;
-
-import android.util.Log;
-
-public class Utils {
-
-	static final String LOG_TAG = "PullToRefresh";
-
-	public static void warnDeprecation(String depreacted, String replacement) {
-		Log.w(LOG_TAG, "You're using the deprecated " + depreacted + " attr, please switch over to " + replacement);
-	}
-
-}
diff --git a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/ViewCompat.java b/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/ViewCompat.java
deleted file mode 100644
index 618bace..0000000
--- a/app/libs/Android-PullToRefresh/library/src/com/handmark/pulltorefresh/library/internal/ViewCompat.java
+++ /dev/null
@@ -1,70 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.library.internal;
-
-import android.annotation.TargetApi;
-import android.graphics.drawable.Drawable;
-import android.os.Build.VERSION;
-import android.os.Build.VERSION_CODES;
-import android.view.View;
-
-@SuppressWarnings("deprecation")
-public class ViewCompat {
-
-	public static void postOnAnimation(View view, Runnable runnable) {
-		if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN) {
-			SDK16.postOnAnimation(view, runnable);
-		} else {
-			view.postDelayed(runnable, 16);
-		}
-	}
-
-	public static void setBackground(View view, Drawable background) {
-		if (VERSION.SDK_INT >= VERSION_CODES.JELLY_BEAN) {
-			SDK16.setBackground(view, background);
-		} else {
-			view.setBackgroundDrawable(background);
-		}
-	}
-
-	public static void setLayerType(View view, int layerType) {
-		if (VERSION.SDK_INT >= VERSION_CODES.HONEYCOMB) {
-			SDK11.setLayerType(view, layerType);
-		}
-	}
-
-	@TargetApi(11)
-	static class SDK11 {
-
-		public static void setLayerType(View view, int layerType) {
-			view.setLayerType(layerType, null);
-		}
-	}
-
-	@TargetApi(16)
-	static class SDK16 {
-
-		public static void postOnAnimation(View view, Runnable runnable) {
-			view.postOnAnimation(runnable);
-		}
-
-		public static void setBackground(View view, Drawable background) {
-			view.setBackground(background);
-		}
-
-	}
-
-}
diff --git a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/LauncherActivity.java b/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/LauncherActivity.java
deleted file mode 100644
index 8eb47bc..0000000
--- a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/LauncherActivity.java
+++ /dev/null
@@ -1,77 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.samples;
-
-import android.app.ListActivity;
-import android.content.Intent;
-import android.os.Bundle;
-import android.view.View;
-import android.widget.ArrayAdapter;
-import android.widget.ListView;
-
-public class LauncherActivity extends ListActivity {
-
-	public static final String[] options = { "ListView", "ExpandableListView", "GridView", "WebView", "ScrollView",
-			"Horizontal ScrollView", "ViewPager", "ListView Fragment", "WebView Advanced", "ListView in ViewPager" };
-
-	@Override
-	protected void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setListAdapter(new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, options));
-	}
-
-	@Override
-	protected void onListItemClick(ListView l, View v, int position, long id) {
-		Intent intent;
-
-		switch (position) {
-			default:
-			case 0:
-				intent = new Intent(this, PullToRefreshListActivity.class);
-				break;
-			case 1:
-				intent = new Intent(this, PullToRefreshExpandableListActivity.class);
-				break;
-			case 2:
-				intent = new Intent(this, PullToRefreshGridActivity.class);
-				break;
-			case 3:
-				intent = new Intent(this, PullToRefreshWebViewActivity.class);
-				break;
-			case 4:
-				intent = new Intent(this, PullToRefreshScrollViewActivity.class);
-				break;
-			case 5:
-				intent = new Intent(this, PullToRefreshHorizontalScrollViewActivity.class);
-				break;
-			case 6:
-				intent = new Intent(this, PullToRefreshViewPagerActivity.class);
-				break;
-			case 7:
-				intent = new Intent(this, PullToRefreshListFragmentActivity.class);
-				break;
-			case 8:
-				intent = new Intent(this, PullToRefreshWebView2Activity.class);
-				break;
-			case 9:
-				intent = new Intent(this, PullToRefreshListInViewPagerActivity.class);
-				break;
-		}
-
-		startActivity(intent);
-	}
-
-}
diff --git a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshExpandableListActivity.java b/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshExpandableListActivity.java
deleted file mode 100644
index 05de38c..0000000
--- a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshExpandableListActivity.java
+++ /dev/null
@@ -1,117 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.samples;
-
-import java.util.ArrayList;
-import java.util.HashMap;
-import java.util.List;
-import java.util.Map;
-
-import android.app.ExpandableListActivity;
-import android.os.AsyncTask;
-import android.os.Bundle;
-import android.widget.ExpandableListView;
-import android.widget.SimpleExpandableListAdapter;
-
-import com.handmark.pulltorefresh.library.PullToRefreshBase;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.OnRefreshListener;
-import com.handmark.pulltorefresh.library.PullToRefreshExpandableListView;
-
-public final class PullToRefreshExpandableListActivity extends ExpandableListActivity {
-	private static final String KEY = "key";
-
-	private List<Map<String, String>> groupData = new ArrayList<Map<String, String>>();
-	private List<List<Map<String, String>>> childData = new ArrayList<List<Map<String, String>>>();
-
-	private PullToRefreshExpandableListView mPullRefreshListView;
-	private SimpleExpandableListAdapter mAdapter;
-
-	/** Called when the activity is first created. */
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.activity_ptr_expandable_list);
-
-		mPullRefreshListView = (PullToRefreshExpandableListView) findViewById(R.id.pull_refresh_expandable_list);
-
-		// Set a listener to be invoked when the list should be refreshed.
-		mPullRefreshListView.setOnRefreshListener(new OnRefreshListener<ExpandableListView>() {
-			@Override
-			public void onRefresh(PullToRefreshBase<ExpandableListView> refreshView) {
-				// Do work to refresh the list here.
-				new GetDataTask().execute();
-			}
-		});
-
-		for (String group : mGroupStrings) {
-			Map<String, String> groupMap1 = new HashMap<String, String>();
-			groupData.add(groupMap1);
-			groupMap1.put(KEY, group);
-
-			List<Map<String, String>> childList = new ArrayList<Map<String, String>>();
-			for (String string : mChildStrings) {
-				Map<String, String> childMap = new HashMap<String, String>();
-				childList.add(childMap);
-				childMap.put(KEY, string);
-			}
-			childData.add(childList);
-		}
-
-		mAdapter = new SimpleExpandableListAdapter(this, groupData, android.R.layout.simple_expandable_list_item_1,
-				new String[] { KEY }, new int[] { android.R.id.text1 }, childData,
-				android.R.layout.simple_expandable_list_item_2, new String[] { KEY }, new int[] { android.R.id.text1 });
-		setListAdapter(mAdapter);
-	}
-
-	private class GetDataTask extends AsyncTask<Void, Void, String[]> {
-
-		@Override
-		protected String[] doInBackground(Void... params) {
-			// Simulates a background job.
-			try {
-				Thread.sleep(2000);
-			} catch (InterruptedException e) {
-			}
-			return mChildStrings;
-		}
-
-		@Override
-		protected void onPostExecute(String[] result) {
-			Map<String, String> newMap = new HashMap<String, String>();
-			newMap.put(KEY, "Added after refresh...");
-			groupData.add(newMap);
-
-			List<Map<String, String>> childList = new ArrayList<Map<String, String>>();
-			for (String string : mChildStrings) {
-				Map<String, String> childMap = new HashMap<String, String>();
-				childMap.put(KEY, string);
-				childList.add(childMap);
-			}
-			childData.add(childList);
-
-			mAdapter.notifyDataSetChanged();
-
-			// Call onRefreshComplete when the list has been refreshed.
-			mPullRefreshListView.onRefreshComplete();
-
-			super.onPostExecute(result);
-		}
-	}
-
-	private String[] mChildStrings = { "Child One", "Child Two", "Child Three", "Child Four", "Child Five", "Child Six" };
-
-	private String[] mGroupStrings = { "Group One", "Group Two", "Group Three" };
-}
diff --git a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshGridActivity.java b/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshGridActivity.java
deleted file mode 100644
index 9d87e35..0000000
--- a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshGridActivity.java
+++ /dev/null
@@ -1,141 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.samples;
-
-import java.util.Arrays;
-import java.util.LinkedList;
-
-import android.app.Activity;
-import android.os.AsyncTask;
-import android.os.Bundle;
-import android.view.Gravity;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.widget.ArrayAdapter;
-import android.widget.GridView;
-import android.widget.TextView;
-import android.widget.Toast;
-
-import com.handmark.pulltorefresh.library.PullToRefreshBase;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.Mode;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.OnRefreshListener2;
-import com.handmark.pulltorefresh.library.PullToRefreshGridView;
-
-public final class PullToRefreshGridActivity extends Activity {
-
-	static final int MENU_SET_MODE = 0;
-
-	private LinkedList<String> mListItems;
-	private PullToRefreshGridView mPullRefreshGridView;
-	private GridView mGridView;
-	private ArrayAdapter<String> mAdapter;
-
-	/** Called when the activity is first created. */
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.activity_ptr_grid);
-
-		mPullRefreshGridView = (PullToRefreshGridView) findViewById(R.id.pull_refresh_grid);
-		mGridView = mPullRefreshGridView.getRefreshableView();
-
-		// Set a listener to be invoked when the list should be refreshed.
-		mPullRefreshGridView.setOnRefreshListener(new OnRefreshListener2<GridView>() {
-
-			@Override
-			public void onPullDownToRefresh(PullToRefreshBase<GridView> refreshView) {
-				Toast.makeText(PullToRefreshGridActivity.this, "Pull Down!", Toast.LENGTH_SHORT).show();
-				new GetDataTask().execute();
-			}
-
-			@Override
-			public void onPullUpToRefresh(PullToRefreshBase<GridView> refreshView) {
-				Toast.makeText(PullToRefreshGridActivity.this, "Pull Up!", Toast.LENGTH_SHORT).show();
-				new GetDataTask().execute();
-			}
-
-		});
-
-		mListItems = new LinkedList<String>();
-
-		TextView tv = new TextView(this);
-		tv.setGravity(Gravity.CENTER);
-		tv.setText("Empty View, Pull Down/Up to Add Items");
-		mPullRefreshGridView.setEmptyView(tv);
-
-		mAdapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, mListItems);
-		mGridView.setAdapter(mAdapter);
-	}
-
-	private class GetDataTask extends AsyncTask<Void, Void, String[]> {
-
-		@Override
-		protected String[] doInBackground(Void... params) {
-			// Simulates a background job.
-			try {
-				Thread.sleep(2000);
-			} catch (InterruptedException e) {
-			}
-			return mStrings;
-		}
-
-		@Override
-		protected void onPostExecute(String[] result) {
-			mListItems.addFirst("Added after refresh...");
-			mListItems.addAll(Arrays.asList(result));
-			mAdapter.notifyDataSetChanged();
-
-			// Call onRefreshComplete when the list has been refreshed.
-			mPullRefreshGridView.onRefreshComplete();
-
-			super.onPostExecute(result);
-		}
-	}
-
-	@Override
-	public boolean onCreateOptionsMenu(Menu menu) {
-		menu.add(0, MENU_SET_MODE, 0,
-				mPullRefreshGridView.getMode() == Mode.BOTH ? "Change to MODE_PULL_DOWN"
-						: "Change to MODE_PULL_BOTH");
-		return super.onCreateOptionsMenu(menu);
-	}
-
-	@Override
-	public boolean onPrepareOptionsMenu(Menu menu) {
-		MenuItem setModeItem = menu.findItem(MENU_SET_MODE);
-		setModeItem.setTitle(mPullRefreshGridView.getMode() == Mode.BOTH ? "Change to MODE_PULL_FROM_START"
-				: "Change to MODE_PULL_BOTH");
-
-		return super.onPrepareOptionsMenu(menu);
-	}
-
-	@Override
-	public boolean onOptionsItemSelected(MenuItem item) {
-		switch (item.getItemId()) {
-			case MENU_SET_MODE:
-				mPullRefreshGridView
-						.setMode(mPullRefreshGridView.getMode() == Mode.BOTH ? Mode.PULL_FROM_START
-								: Mode.BOTH);
-				break;
-		}
-
-		return super.onOptionsItemSelected(item);
-	}
-
-	private String[] mStrings = { "Abbaye de Belloc", "Abbaye du Mont des Cats", "Abertam", "Abondance", "Ackawi",
-			"Acorn", "Adelost", "Affidelice au Chablis", "Afuega'l Pitu", "Airag", "Airedale", "Aisy Cendre",
-			"Allgauer Emmentaler" };
-}
diff --git a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshHorizontalScrollViewActivity.java b/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshHorizontalScrollViewActivity.java
deleted file mode 100644
index 81e2165..0000000
--- a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshHorizontalScrollViewActivity.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.samples;
-
-import android.app.Activity;
-import android.os.AsyncTask;
-import android.os.Bundle;
-import android.widget.HorizontalScrollView;
-
-import com.handmark.pulltorefresh.library.PullToRefreshBase;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.OnRefreshListener;
-import com.handmark.pulltorefresh.library.PullToRefreshHorizontalScrollView;
-
-public final class PullToRefreshHorizontalScrollViewActivity extends Activity {
-
-	PullToRefreshHorizontalScrollView mPullRefreshScrollView;
-	HorizontalScrollView mScrollView;
-
-	/** Called when the activity is first created. */
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.activity_ptr_horizontalscrollview);
-
-		mPullRefreshScrollView = (PullToRefreshHorizontalScrollView) findViewById(R.id.pull_refresh_horizontalscrollview);
-		mPullRefreshScrollView.setOnRefreshListener(new OnRefreshListener<HorizontalScrollView>() {
-
-			@Override
-			public void onRefresh(PullToRefreshBase<HorizontalScrollView> refreshView) {
-				new GetDataTask().execute();
-			}
-		});
-
-		mScrollView = mPullRefreshScrollView.getRefreshableView();
-	}
-
-	private class GetDataTask extends AsyncTask<Void, Void, String[]> {
-
-		@Override
-		protected String[] doInBackground(Void... params) {
-			// Simulates a background job.
-			try {
-				Thread.sleep(4000);
-			} catch (InterruptedException e) {
-			}
-			return null;
-		}
-
-		@Override
-		protected void onPostExecute(String[] result) {
-			// Do some stuff here
-
-			// Call onRefreshComplete when the list has been refreshed.
-			mPullRefreshScrollView.onRefreshComplete();
-
-			super.onPostExecute(result);
-		}
-	}
-
-}
diff --git a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshListActivity.java b/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshListActivity.java
deleted file mode 100755
index 13b572e..0000000
--- a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshListActivity.java
+++ /dev/null
@@ -1,202 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.samples;
-
-import java.util.Arrays;
-import java.util.LinkedList;
-
-import android.app.ListActivity;
-import android.os.AsyncTask;
-import android.os.Bundle;
-import android.text.format.DateUtils;
-import android.view.ContextMenu;
-import android.view.ContextMenu.ContextMenuInfo;
-import android.view.Menu;
-import android.view.MenuItem;
-import android.view.View;
-import android.widget.AdapterView.AdapterContextMenuInfo;
-import android.widget.ArrayAdapter;
-import android.widget.ListView;
-import android.widget.Toast;
-
-import com.handmark.pulltorefresh.library.PullToRefreshBase;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.Mode;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.OnLastItemVisibleListener;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.OnRefreshListener;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.State;
-import com.handmark.pulltorefresh.library.PullToRefreshListView;
-import com.handmark.pulltorefresh.library.extras.SoundPullEventListener;
-
-public final class PullToRefreshListActivity extends ListActivity {
-
-	static final int MENU_MANUAL_REFRESH = 0;
-	static final int MENU_DISABLE_SCROLL = 1;
-	static final int MENU_SET_MODE = 2;
-	static final int MENU_DEMO = 3;
-
-	private LinkedList<String> mListItems;
-	private PullToRefreshListView mPullRefreshListView;
-	private ArrayAdapter<String> mAdapter;
-
-	/** Called when the activity is first created. */
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.activity_ptr_list);
-
-		mPullRefreshListView = (PullToRefreshListView) findViewById(R.id.pull_refresh_list);
-
-		// Set a listener to be invoked when the list should be refreshed.
-		mPullRefreshListView.setOnRefreshListener(new OnRefreshListener<ListView>() {
-			@Override
-			public void onRefresh(PullToRefreshBase<ListView> refreshView) {
-				String label = DateUtils.formatDateTime(getApplicationContext(), System.currentTimeMillis(),
-						DateUtils.FORMAT_SHOW_TIME | DateUtils.FORMAT_SHOW_DATE | DateUtils.FORMAT_ABBREV_ALL);
-
-				// Update the LastUpdatedLabel
-				refreshView.getLoadingLayoutProxy().setLastUpdatedLabel(label);
-
-				// Do work to refresh the list here.
-				new GetDataTask().execute();
-			}
-		});
-
-		// Add an end-of-list listener
-		mPullRefreshListView.setOnLastItemVisibleListener(new OnLastItemVisibleListener() {
-
-			@Override
-			public void onLastItemVisible() {
-				Toast.makeText(PullToRefreshListActivity.this, "End of List!", Toast.LENGTH_SHORT).show();
-			}
-		});
-
-		ListView actualListView = mPullRefreshListView.getRefreshableView();
-
-		// Need to use the Actual ListView when registering for Context Menu
-		registerForContextMenu(actualListView);
-
-		mListItems = new LinkedList<String>();
-		mListItems.addAll(Arrays.asList(mStrings));
-
-		mAdapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, mListItems);
-
-		/**
-		 * Add Sound Event Listener
-		 */
-		SoundPullEventListener<ListView> soundListener = new SoundPullEventListener<ListView>(this);
-		soundListener.addSoundEvent(State.PULL_TO_REFRESH, R.raw.pull_event);
-		soundListener.addSoundEvent(State.RESET, R.raw.reset_sound);
-		soundListener.addSoundEvent(State.REFRESHING, R.raw.refreshing_sound);
-		mPullRefreshListView.setOnPullEventListener(soundListener);
-
-		// You can also just use setListAdapter(mAdapter) or
-		// mPullRefreshListView.setAdapter(mAdapter)
-		actualListView.setAdapter(mAdapter);
-	}
-
-	private class GetDataTask extends AsyncTask<Void, Void, String[]> {
-
-		@Override
-		protected String[] doInBackground(Void... params) {
-			// Simulates a background job.
-			try {
-				Thread.sleep(4000);
-			} catch (InterruptedException e) {
-			}
-			return mStrings;
-		}
-
-		@Override
-		protected void onPostExecute(String[] result) {
-			mListItems.addFirst("Added after refresh...");
-			mAdapter.notifyDataSetChanged();
-
-			// Call onRefreshComplete when the list has been refreshed.
-			mPullRefreshListView.onRefreshComplete();
-
-			super.onPostExecute(result);
-		}
-	}
-
-	@Override
-	public boolean onCreateOptionsMenu(Menu menu) {
-		menu.add(0, MENU_MANUAL_REFRESH, 0, "Manual Refresh");
-		menu.add(0, MENU_DISABLE_SCROLL, 1,
-				mPullRefreshListView.isScrollingWhileRefreshingEnabled() ? "Disable Scrolling while Refreshing"
-						: "Enable Scrolling while Refreshing");
-		menu.add(0, MENU_SET_MODE, 0, mPullRefreshListView.getMode() == Mode.BOTH ? "Change to MODE_PULL_DOWN"
-				: "Change to MODE_PULL_BOTH");
-		menu.add(0, MENU_DEMO, 0, "Demo");
-		return super.onCreateOptionsMenu(menu);
-	}
-
-	@Override
-	public void onCreateContextMenu(ContextMenu menu, View v, ContextMenuInfo menuInfo) {
-		AdapterContextMenuInfo info = (AdapterContextMenuInfo) menuInfo;
-
-		menu.setHeaderTitle("Item: " + getListView().getItemAtPosition(info.position));
-		menu.add("Item 1");
-		menu.add("Item 2");
-		menu.add("Item 3");
-		menu.add("Item 4");
-
-		super.onCreateContextMenu(menu, v, menuInfo);
-	}
-
-	@Override
-	public boolean onPrepareOptionsMenu(Menu menu) {
-		MenuItem disableItem = menu.findItem(MENU_DISABLE_SCROLL);
-		disableItem
-				.setTitle(mPullRefreshListView.isScrollingWhileRefreshingEnabled() ? "Disable Scrolling while Refreshing"
-						: "Enable Scrolling while Refreshing");
-
-		MenuItem setModeItem = menu.findItem(MENU_SET_MODE);
-		setModeItem.setTitle(mPullRefreshListView.getMode() == Mode.BOTH ? "Change to MODE_FROM_START"
-				: "Change to MODE_PULL_BOTH");
-
-		return super.onPrepareOptionsMenu(menu);
-	}
-
-	@Override
-	public boolean onOptionsItemSelected(MenuItem item) {
-
-		switch (item.getItemId()) {
-			case MENU_MANUAL_REFRESH:
-				new GetDataTask().execute();
-				mPullRefreshListView.setRefreshing(false);
-				break;
-			case MENU_DISABLE_SCROLL:
-				mPullRefreshListView.setScrollingWhileRefreshingEnabled(!mPullRefreshListView
-						.isScrollingWhileRefreshingEnabled());
-				break;
-			case MENU_SET_MODE:
-				mPullRefreshListView.setMode(mPullRefreshListView.getMode() == Mode.BOTH ? Mode.PULL_FROM_START
-						: Mode.BOTH);
-				break;
-			case MENU_DEMO:
-				mPullRefreshListView.demo();
-				break;
-		}
-
-		return super.onOptionsItemSelected(item);
-	}
-
-	private String[] mStrings = { "Abbaye de Belloc", "Abbaye du Mont des Cats", "Abertam", "Abondance", "Ackawi",
-			"Acorn", "Adelost", "Affidelice au Chablis", "Afuega'l Pitu", "Airag", "Airedale", "Aisy Cendre",
-			"Allgauer Emmentaler", "Abbaye de Belloc", "Abbaye du Mont des Cats", "Abertam", "Abondance", "Ackawi",
-			"Acorn", "Adelost", "Affidelice au Chablis", "Afuega'l Pitu", "Airag", "Airedale", "Aisy Cendre",
-			"Allgauer Emmentaler" };
-}
diff --git a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshListFragmentActivity.java b/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshListFragmentActivity.java
deleted file mode 100644
index 4361c60..0000000
--- a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshListFragmentActivity.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.samples;
-
-import java.util.Arrays;
-import java.util.LinkedList;
-
-import android.os.AsyncTask;
-import android.os.Bundle;
-import android.support.v4.app.FragmentActivity;
-import android.widget.ArrayAdapter;
-import android.widget.ListView;
-
-import com.handmark.pulltorefresh.extras.listfragment.PullToRefreshListFragment;
-import com.handmark.pulltorefresh.library.PullToRefreshBase;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.OnRefreshListener;
-import com.handmark.pulltorefresh.library.PullToRefreshListView;
-
-public final class PullToRefreshListFragmentActivity extends FragmentActivity implements OnRefreshListener<ListView> {
-
-	private LinkedList<String> mListItems;
-	private ArrayAdapter<String> mAdapter;
-
-	private PullToRefreshListFragment mPullRefreshListFragment;
-	private PullToRefreshListView mPullRefreshListView;
-
-	/** Called when the activity is first created. */
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.activity_ptr_list_fragment);
-
-		mPullRefreshListFragment = (PullToRefreshListFragment) getSupportFragmentManager().findFragmentById(
-				R.id.frag_ptr_list);
-
-		// Get PullToRefreshListView from Fragment
-		mPullRefreshListView = mPullRefreshListFragment.getPullToRefreshListView();
-
-		// Set a listener to be invoked when the list should be refreshed.
-		mPullRefreshListView.setOnRefreshListener(this);
-
-		// You can also just use mPullRefreshListFragment.getListView()
-		ListView actualListView = mPullRefreshListView.getRefreshableView();
-
-		mListItems = new LinkedList<String>();
-		mListItems.addAll(Arrays.asList(mStrings));
-		mAdapter = new ArrayAdapter<String>(this, android.R.layout.simple_list_item_1, mListItems);
-
-		// You can also just use setListAdapter(mAdapter) or
-		// mPullRefreshListView.setAdapter(mAdapter)
-		actualListView.setAdapter(mAdapter);
-
-		mPullRefreshListFragment.setListShown(true);
-	}
-
-	@Override
-	public void onRefresh(PullToRefreshBase<ListView> refreshView) {
-		// Do work to refresh the list here.
-		new GetDataTask().execute();
-	}
-
-	private class GetDataTask extends AsyncTask<Void, Void, String[]> {
-
-		@Override
-		protected String[] doInBackground(Void... params) {
-			// Simulates a background job.
-			try {
-				Thread.sleep(4000);
-			} catch (InterruptedException e) {
-			}
-			return mStrings;
-		}
-
-		@Override
-		protected void onPostExecute(String[] result) {
-			mListItems.addFirst("Added after refresh...");
-			mAdapter.notifyDataSetChanged();
-
-			// Call onRefreshComplete when the list has been refreshed.
-			mPullRefreshListView.onRefreshComplete();
-
-			super.onPostExecute(result);
-		}
-	}
-
-	private String[] mStrings = { "Abbaye de Belloc", "Abbaye du Mont des Cats", "Abertam", "Abondance", "Ackawi",
-			"Acorn", "Adelost", "Affidelice au Chablis", "Afuega'l Pitu", "Airag", "Airedale", "Aisy Cendre",
-			"Allgauer Emmentaler", "Abbaye de Belloc", "Abbaye du Mont des Cats", "Abertam", "Abondance", "Ackawi",
-			"Acorn", "Adelost", "Affidelice au Chablis", "Afuega'l Pitu", "Airag", "Airedale", "Aisy Cendre",
-			"Allgauer Emmentaler" };
-}
diff --git a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshListInViewPagerActivity.java b/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshListInViewPagerActivity.java
deleted file mode 100644
index 45b9b1e..0000000
--- a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshListInViewPagerActivity.java
+++ /dev/null
@@ -1,110 +0,0 @@
-package com.handmark.pulltorefresh.samples;
-
-import java.util.Arrays;
-
-import android.app.Activity;
-import android.content.Context;
-import android.os.AsyncTask;
-import android.os.Bundle;
-import android.support.v4.view.PagerAdapter;
-import android.support.v4.view.ViewPager;
-import android.view.LayoutInflater;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.ViewGroup.LayoutParams;
-import android.widget.ArrayAdapter;
-import android.widget.ListAdapter;
-import android.widget.ListView;
-
-import com.handmark.pulltorefresh.library.PullToRefreshBase;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.OnRefreshListener;
-import com.handmark.pulltorefresh.library.PullToRefreshListView;
-
-public class PullToRefreshListInViewPagerActivity extends Activity implements OnRefreshListener<ListView> {
-
-	private static final String[] STRINGS = { "Abbaye de Belloc", "Abbaye du Mont des Cats", "Abertam", "Abondance",
-			"Ackawi", "Acorn", "Adelost", "Affidelice au Chablis", "Afuega'l Pitu", "Airag", "Airedale", "Aisy Cendre",
-			"Allgauer Emmentaler", "Abbaye de Belloc", "Abbaye du Mont des Cats", "Abertam", "Abondance", "Ackawi",
-			"Acorn", "Adelost", "Affidelice au Chablis", "Afuega'l Pitu", "Airag", "Airedale", "Aisy Cendre",
-			"Allgauer Emmentaler" };
-
-	private ViewPager mViewPager;
-
-	@Override
-	protected void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.activity_ptr_list_in_vp);
-
-		mViewPager = (ViewPager) findViewById(R.id.vp_list);
-		mViewPager.setAdapter(new ListViewPagerAdapter());
-	}
-
-	private class ListViewPagerAdapter extends PagerAdapter {
-
-		@Override
-		public View instantiateItem(ViewGroup container, int position) {
-			Context context = container.getContext();
-
-			PullToRefreshListView plv = (PullToRefreshListView) LayoutInflater.from(context).inflate(
-					R.layout.layout_listview_in_viewpager, container, false);
-
-			ListAdapter adapter = new ArrayAdapter<String>(context, android.R.layout.simple_list_item_1,
-					Arrays.asList(STRINGS));
-			plv.setAdapter(adapter);
-
-			plv.setOnRefreshListener(PullToRefreshListInViewPagerActivity.this);
-
-			// Now just add ListView to ViewPager and return it
-			container.addView(plv, LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
-
-			return plv;
-		}
-
-		@Override
-		public void destroyItem(ViewGroup container, int position, Object object) {
-			container.removeView((View) object);
-		}
-
-		@Override
-		public boolean isViewFromObject(View view, Object object) {
-			return view == object;
-		}
-
-		@Override
-		public int getCount() {
-			return 3;
-		}
-
-	}
-
-	@Override
-	public void onRefresh(PullToRefreshBase<ListView> refreshView) {
-		new GetDataTask(refreshView).execute();
-	}
-
-	private static class GetDataTask extends AsyncTask<Void, Void, Void> {
-
-		PullToRefreshBase<?> mRefreshedView;
-
-		public GetDataTask(PullToRefreshBase<?> refreshedView) {
-			mRefreshedView = refreshedView;
-		}
-
-		@Override
-		protected Void doInBackground(Void... params) {
-			// Simulates a background job.
-			try {
-				Thread.sleep(4000);
-			} catch (InterruptedException e) {
-			}
-			return null;
-		}
-
-		@Override
-		protected void onPostExecute(Void result) {
-			mRefreshedView.onRefreshComplete();
-			super.onPostExecute(result);
-		}
-	}
-
-}
diff --git a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshScrollViewActivity.java b/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshScrollViewActivity.java
deleted file mode 100644
index 008b920..0000000
--- a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshScrollViewActivity.java
+++ /dev/null
@@ -1,73 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.samples;
-
-import android.app.Activity;
-import android.os.AsyncTask;
-import android.os.Bundle;
-import android.widget.ScrollView;
-
-import com.handmark.pulltorefresh.library.PullToRefreshBase;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.OnRefreshListener;
-import com.handmark.pulltorefresh.library.PullToRefreshScrollView;
-
-public final class PullToRefreshScrollViewActivity extends Activity {
-
-	PullToRefreshScrollView mPullRefreshScrollView;
-	ScrollView mScrollView;
-
-	/** Called when the activity is first created. */
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.activity_ptr_scrollview);
-
-		mPullRefreshScrollView = (PullToRefreshScrollView) findViewById(R.id.pull_refresh_scrollview);
-		mPullRefreshScrollView.setOnRefreshListener(new OnRefreshListener<ScrollView>() {
-
-			@Override
-			public void onRefresh(PullToRefreshBase<ScrollView> refreshView) {
-				new GetDataTask().execute();
-			}
-		});
-
-		mScrollView = mPullRefreshScrollView.getRefreshableView();
-	}
-
-	private class GetDataTask extends AsyncTask<Void, Void, String[]> {
-
-		@Override
-		protected String[] doInBackground(Void... params) {
-			// Simulates a background job.
-			try {
-				Thread.sleep(4000);
-			} catch (InterruptedException e) {
-			}
-			return null;
-		}
-
-		@Override
-		protected void onPostExecute(String[] result) {
-			// Do some stuff here
-
-			// Call onRefreshComplete when the list has been refreshed.
-			mPullRefreshScrollView.onRefreshComplete();
-
-			super.onPostExecute(result);
-		}
-	}
-
-}
diff --git a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshViewPagerActivity.java b/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshViewPagerActivity.java
deleted file mode 100644
index df05fdd..0000000
--- a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshViewPagerActivity.java
+++ /dev/null
@@ -1,104 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.samples;
-
-import android.app.Activity;
-import android.os.AsyncTask;
-import android.os.Bundle;
-import android.support.v4.view.PagerAdapter;
-import android.support.v4.view.ViewPager;
-import android.view.View;
-import android.view.ViewGroup;
-import android.view.ViewGroup.LayoutParams;
-import android.widget.ImageView;
-
-import com.handmark.pulltorefresh.extras.viewpager.PullToRefreshViewPager;
-import com.handmark.pulltorefresh.library.PullToRefreshBase;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.OnRefreshListener;
-
-public class PullToRefreshViewPagerActivity extends Activity implements OnRefreshListener<ViewPager> {
-
-	private PullToRefreshViewPager mPullToRefreshViewPager;
-
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.activity_ptr_viewpager);
-
-		mPullToRefreshViewPager = (PullToRefreshViewPager) findViewById(R.id.pull_refresh_viewpager);
-		mPullToRefreshViewPager.setOnRefreshListener(this);
-
-		ViewPager vp = mPullToRefreshViewPager.getRefreshableView();
-		vp.setAdapter(new SamplePagerAdapter());
-	}
-
-	@Override
-	public void onRefresh(PullToRefreshBase<ViewPager> refreshView) {
-		new GetDataTask().execute();
-	}
-
-	static class SamplePagerAdapter extends PagerAdapter {
-
-		private static int[] sDrawables = { R.drawable.wallpaper, R.drawable.wallpaper, R.drawable.wallpaper,
-				R.drawable.wallpaper, R.drawable.wallpaper, R.drawable.wallpaper };
-
-		@Override
-		public int getCount() {
-			return sDrawables.length;
-		}
-
-		@Override
-		public View instantiateItem(ViewGroup container, int position) {
-			ImageView imageView = new ImageView(container.getContext());
-			imageView.setImageResource(sDrawables[position]);
-
-			// Now just add ImageView to ViewPager and return it
-			container.addView(imageView, LayoutParams.MATCH_PARENT, LayoutParams.MATCH_PARENT);
-
-			return imageView;
-		}
-
-		@Override
-		public void destroyItem(ViewGroup container, int position, Object object) {
-			container.removeView((View) object);
-		}
-
-		@Override
-		public boolean isViewFromObject(View view, Object object) {
-			return view == object;
-		}
-	}
-
-	private class GetDataTask extends AsyncTask<Void, Void, Void> {
-
-		@Override
-		protected Void doInBackground(Void... params) {
-			// Simulates a background job.
-			try {
-				Thread.sleep(4000);
-			} catch (InterruptedException e) {
-			}
-			return null;
-		}
-
-		@Override
-		protected void onPostExecute(Void result) {
-			mPullToRefreshViewPager.onRefreshComplete();
-			super.onPostExecute(result);
-		}
-	}
-
-}
diff --git a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshWebView2Activity.java b/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshWebView2Activity.java
deleted file mode 100644
index 786f195..0000000
--- a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshWebView2Activity.java
+++ /dev/null
@@ -1,66 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.samples;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.webkit.WebView;
-import android.webkit.WebViewClient;
-
-import com.handmark.pulltorefresh.library.PullToRefreshBase;
-import com.handmark.pulltorefresh.library.PullToRefreshBase.OnRefreshListener;
-import com.handmark.pulltorefresh.library.extras.PullToRefreshWebView2;
-
-public final class PullToRefreshWebView2Activity extends Activity implements OnRefreshListener<WebView> {
-
-	/** Called when the activity is first created. */
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.activity_ptr_webview2);
-
-		PullToRefreshWebView2 pullRefreshWebView = (PullToRefreshWebView2) findViewById(R.id.pull_refresh_webview2);
-		pullRefreshWebView.setOnRefreshListener(this);
-
-		WebView webView = pullRefreshWebView.getRefreshableView();
-		webView.getSettings().setJavaScriptEnabled(true);
-		webView.setWebViewClient(new SampleWebViewClient());
-
-		// We just load a prepared HTML page from the assets folder for this
-		// sample, see that file for the Javascript implementation
-		webView.loadUrl("file:///android_asset/ptr_webview2_sample.html");
-	}
-
-	private static class SampleWebViewClient extends WebViewClient {
-		@Override
-		public boolean shouldOverrideUrlLoading(WebView view, String url) {
-			view.loadUrl(url);
-			return true;
-		}
-	}
-
-	@Override
-	public void onRefresh(final PullToRefreshBase<WebView> refreshView) {
-		// This is very contrived example, we just wait 2 seconds, then call
-		// onRefreshComplete()
-		refreshView.postDelayed(new Runnable() {
-			@Override
-			public void run() {
-				refreshView.onRefreshComplete();
-			}
-		}, 2 * 1000);
-	}
-}
diff --git a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshWebViewActivity.java b/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshWebViewActivity.java
deleted file mode 100644
index 1a42a06..0000000
--- a/app/libs/Android-PullToRefresh/sample/src/com/handmark/pulltorefresh/samples/PullToRefreshWebViewActivity.java
+++ /dev/null
@@ -1,53 +0,0 @@
-/*******************************************************************************
- * Copyright 2011, 2012 Chris Banes.
- *
- * Licensed under the Apache License, Version 2.0 (the "License");
- * you may not use this file except in compliance with the License.
- * You may obtain a copy of the License at
- *
- * http://www.apache.org/licenses/LICENSE-2.0
- *
- * Unless required by applicable law or agreed to in writing, software
- * distributed under the License is distributed on an "AS IS" BASIS,
- * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
- * See the License for the specific language governing permissions and
- * limitations under the License.
- *******************************************************************************/
-package com.handmark.pulltorefresh.samples;
-
-import android.app.Activity;
-import android.os.Bundle;
-import android.webkit.WebView;
-import android.webkit.WebViewClient;
-
-import com.handmark.pulltorefresh.library.PullToRefreshWebView;
-
-public final class PullToRefreshWebViewActivity extends Activity {
-
-	PullToRefreshWebView mPullRefreshWebView;
-	WebView mWebView;
-
-	/** Called when the activity is first created. */
-	@Override
-	public void onCreate(Bundle savedInstanceState) {
-		super.onCreate(savedInstanceState);
-		setContentView(R.layout.activity_ptr_webview);
-
-		mPullRefreshWebView = (PullToRefreshWebView) findViewById(R.id.pull_refresh_webview);
-		mWebView = mPullRefreshWebView.getRefreshableView();
-
-		mWebView.getSettings().setJavaScriptEnabled(true);
-		mWebView.setWebViewClient(new SampleWebViewClient());
-		mWebView.loadUrl("http://www.google.com");
-
-	}
-
-	private static class SampleWebViewClient extends WebViewClient {
-		@Override
-		public boolean shouldOverrideUrlLoading(WebView view, String url) {
-			view.loadUrl(url);
-			return true;
-		}
-	}
-
-}
diff --git a/app/src/main/java/com/memetro/android/Application.java b/app/src/main/java/com/memetro/android/Application.java
index bf3ce63..1e14230 100644
--- a/app/src/main/java/com/memetro/android/Application.java
+++ b/app/src/main/java/com/memetro/android/Application.java
@@ -16,10 +16,6 @@
 
 package com.memetro.android;
 
-import android.content.Context;
-
-import com.activeandroid.ActiveAndroid;
-import com.activeandroid.Configuration;
 
 import dagger.hilt.android.HiltAndroidApp;
 
