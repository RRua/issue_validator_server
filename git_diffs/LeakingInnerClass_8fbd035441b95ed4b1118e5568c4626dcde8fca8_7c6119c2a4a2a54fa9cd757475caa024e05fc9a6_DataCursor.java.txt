diff --git a/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/DetailActivity.java b/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/DetailActivity.java
index 2a0bb52..6f506de 100644
--- a/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/DetailActivity.java
+++ b/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/DetailActivity.java
@@ -1,28 +1,22 @@
 package net.kuratkoo.locusaddon.gsakdatabase;
 
-import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.content.Intent;
-import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
-import android.location.Location;
 import android.os.Bundle;
 import android.preference.PreferenceManager;
 import android.widget.Toast;
 
+import androidx.annotation.Nullable;
+
 import net.kuratkoo.locusaddon.gsakdatabase.util.Gsak;
+import net.kuratkoo.locusaddon.gsakdatabase.util.GsakReader;
 
 import java.io.File;
-import java.text.SimpleDateFormat;
-import java.util.ArrayList;
-import java.util.Date;
+import java.text.ParseException;
 
-import menion.android.locus.addon.publiclib.LocusConst;
-import menion.android.locus.addon.publiclib.geoData.Point;
-import menion.android.locus.addon.publiclib.geoData.PointGeocachingAttributes;
-import menion.android.locus.addon.publiclib.geoData.PointGeocachingData;
-import menion.android.locus.addon.publiclib.geoData.PointGeocachingDataLog;
-import menion.android.locus.addon.publiclib.geoData.PointGeocachingDataWaypoint;
+import locus.api.android.utils.LocusUtils;
+import locus.api.objects.geoData.Point;
 
 /**
  * DetailActivity
@@ -30,7 +24,7 @@ import menion.android.locus.addon.publiclib.geoData.PointGeocachingDataWaypoint;
  */
 public class DetailActivity extends Activity {
 
-    private static final String TAG = "DetailActivity";
+//    private static final String TAG = "DetailActivity";
 
     @Override
     public void onCreate(Bundle savedInstanceState) {
@@ -47,107 +41,18 @@ public class DetailActivity extends Activity {
 
         if (intent.hasExtra("cacheId")) {
             String value = intent.getStringExtra("cacheId");
-            try {
-                SQLiteDatabase database = SQLiteDatabase.openDatabase(PreferenceManager.getDefaultSharedPreferences(this).getString("db", ""), null, SQLiteDatabase.NO_LOCALIZED_COLLATORS);
-                Cursor c = database.rawQuery("SELECT * FROM CachesAll WHERE Code = ?", new String[]{value});
-                c.moveToNext();
-
-                Location loc = new Location(TAG);
-                loc.setLatitude(c.getDouble(c.getColumnIndex("Latitude")));
-                loc.setLongitude(c.getDouble(c.getColumnIndex("Longitude")));
-                Point p = new Point(c.getString(c.getColumnIndex("Name")), loc);
-
-                PointGeocachingData gcData = new PointGeocachingData();
-                gcData.cacheID = c.getString(c.getColumnIndex("Code"));
-                gcData.name = c.getString(c.getColumnIndex("Name"));
-                gcData.owner = c.getString(c.getColumnIndex("PlacedBy"));
-                gcData.placedBy = c.getString(c.getColumnIndex("PlacedBy"));
-                gcData.difficulty = c.getFloat(c.getColumnIndex("Difficulty"));
-                gcData.terrain = c.getFloat(c.getColumnIndex("Terrain"));
-                gcData.country = c.getString(c.getColumnIndex("Country"));
-                gcData.state = c.getString(c.getColumnIndex("State"));
-                gcData.container = Gsak.convertContainer(c.getString(c.getColumnIndex("Container")));
-                gcData.type = Gsak.convertCacheType(c.getString(c.getColumnIndex("CacheType")));
-                gcData.available = Gsak.isAvailable(c.getString(c.getColumnIndex("Status")));
-                gcData.archived = Gsak.isArchived(c.getString(c.getColumnIndex("Status")));
-                gcData.found = Gsak.isFound(c.getInt(c.getColumnIndex("Found")));
-                gcData.premiumOnly = Gsak.isPremium(c.getInt(c.getColumnIndex("Found")));
-                gcData.computed = Gsak.isCorrected(c.getInt(c.getColumnIndex("HasCorrected")));
-
-                @SuppressLint("SimpleDateFormat") SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
-                Date date = new Date();
-                gcData.exported = dateFormat.format(date);
-
-                String lastUpdated = c.getString(c.getColumnIndex("LastUserDate"));
-                if (lastUpdated.length() == 10) {
-                    gcData.lastUpdated = lastUpdated + "T";
-                }
-
-                gcData.hidden = c.getString(c.getColumnIndex("PlacedDate")) + "T";
-
-                // More!
-                gcData.notes = c.getString(c.getColumnIndex("UserNote"));
-                gcData.encodedHints = c.getString(c.getColumnIndex("Hints"));
-                gcData.shortDescription = c.getString(c.getColumnIndex("ShortDescription"));
-                gcData.longDescription = c.getString(c.getColumnIndex("LongDescription"));
-
-                /* TB & GC */
-                gcData.travelBugs = Gsak.parseTravelBug(c.getString(c.getColumnIndex("TravelBugs")));
-                c.close();
-
-                /* Add waypoints to Geocache */
-                ArrayList<PointGeocachingDataWaypoint> pgdws = new ArrayList<>();
-
-                Cursor wp = database.rawQuery("SELECT * FROM WayAll WHERE cParent = ?", new String[]{gcData.cacheID});
-                while (wp.moveToNext()) {
-                    PointGeocachingDataWaypoint pgdw = new PointGeocachingDataWaypoint();
-                    pgdw.lat = wp.getDouble(wp.getColumnIndex("cLat"));
-                    pgdw.lon = wp.getDouble(wp.getColumnIndex("cLon"));
-                    pgdw.name = wp.getString(wp.getColumnIndex("cName"));
-                    pgdw.type = Gsak.convertWaypointType(wp.getString(wp.getColumnIndex("cType")));
-                    pgdw.description = wp.getString(wp.getColumnIndex("cComment"));
-                    pgdw.code = wp.getString(wp.getColumnIndex("cCode"));
-                    pgdws.add(pgdw);
-                }
-                wp.close();
 
-                gcData.waypoints = pgdws;
-
-                /* Add logs to Geocache */
-                String limit = PreferenceManager.getDefaultSharedPreferences(this).getString("logs_count", "20");
-                Cursor logs = database.rawQuery("SELECT * FROM LogsAll WHERE lParent = ? ORDER BY lDate DESC LIMIT ?", new String[]{gcData.cacheID, limit});
-                ArrayList<PointGeocachingDataLog> pgdls = new ArrayList<>();
-
-                while (logs.moveToNext()) {
-                    PointGeocachingDataLog pgdl = new PointGeocachingDataLog();
-                    pgdl.date = logs.getString(logs.getColumnIndex("lDate")) + "T00:00:00Z";
-                    pgdl.finder = logs.getString(logs.getColumnIndex("lBy"));
-                    pgdl.logText = logs.getString(logs.getColumnIndex("lText"));
-                    pgdl.type = Gsak.convertLogType(logs.getString(logs.getColumnIndex("lType")));
-                    pgdls.add(pgdl);
-                }
-                logs.close();
-                gcData.logs = pgdls;
-
-                /* Add attributes to Geocache */
-                Cursor at = database.rawQuery("SELECT * FROM Attributes WHERE aCode = ?", new String[]{gcData.cacheID});
-                ArrayList<PointGeocachingAttributes> pgas = new ArrayList<>();
-
-                while (at.moveToNext()) {
-                    boolean isPositive = at.getInt(at.getColumnIndex("aInc")) == 1;
-                    PointGeocachingAttributes pga = new PointGeocachingAttributes(at.getInt(at.getColumnIndex("aId")), isPositive);
-                    pgas.add(pga);
+            try {
+                Point point = readGeocacheFromDatabase("db", value);
+                if (point == null) {
+                    point = readGeocacheFromDatabase("db2", value);
+                    if (point == null) {
+                        point = readGeocacheFromDatabase("db3", value);
+                    }
                 }
-                at.close();
-                gcData.attributes = pgas;
-
-                p.setGeocachingData(gcData);
-                database.close();
-
-                Intent retIntent = new Intent();
-                retIntent.putExtra(LocusConst.EXTRA_POINT, p);
-                setResult(RESULT_OK, retIntent);
-
+                // return data
+                Intent retIntent = LocusUtils.INSTANCE.prepareResultExtraOnDisplayIntent(point, true);
+                setResult(Activity.RESULT_OK, retIntent);
             } catch (Exception e) {
                 Toast.makeText(this, getText(R.string.unable_to_load_detail) + " " + e.getLocalizedMessage(), Toast.LENGTH_LONG).show();
             } finally {
@@ -155,4 +60,16 @@ public class DetailActivity extends Activity {
             }
         }
     }
+
+    @Nullable
+    private Point readGeocacheFromDatabase(String dbId, String gcCode) throws ParseException {
+        String dbPath = PreferenceManager.getDefaultSharedPreferences(this).getString(dbId, "");
+        if (dbPath.length() == 0) {
+            return null;
+        }
+        SQLiteDatabase database = SQLiteDatabase.openDatabase(dbPath, null, SQLiteDatabase.NO_LOCALIZED_COLLATORS + SQLiteDatabase.OPEN_READONLY);
+        Point p = GsakReader.readGeocache(database, gcCode, true);
+        database.close();
+        return p;
+    }
 }
diff --git a/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/LoadActivity.java b/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/LoadActivity.java
index da97b9c..0ebc73c 100644
--- a/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/LoadActivity.java
+++ b/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/LoadActivity.java
@@ -1,6 +1,5 @@
 package net.kuratkoo.locusaddon.gsakdatabase;
 
-import android.annotation.SuppressLint;
 import android.app.Activity;
 import android.app.AlertDialog;
 import android.app.ProgressDialog;
@@ -8,35 +7,36 @@ import android.content.DialogInterface;
 import android.content.DialogInterface.OnClickListener;
 import android.content.Intent;
 import android.content.SharedPreferences;
-import android.database.Cursor;
 import android.database.sqlite.SQLiteDatabase;
-import android.location.Location;
 import android.os.AsyncTask;
 import android.os.Bundle;
 import android.widget.Toast;
 
 import net.kuratkoo.locusaddon.gsakdatabase.util.Gsak;
+import net.kuratkoo.locusaddon.gsakdatabase.util.GsakReader;
+import net.kuratkoo.locusaddon.gsakdatabase.util.Pair;
+
+import org.jetbrains.annotations.NotNull;
+import org.jetbrains.annotations.Nullable;
 
 import java.io.File;
-import java.text.SimpleDateFormat;
 import java.util.ArrayList;
 import java.util.Collections;
 import java.util.Comparator;
-import java.util.Date;
 import java.util.HashSet;
 import java.util.List;
 import java.util.Set;
 
-import menion.android.locus.addon.publiclib.DisplayData;
-import menion.android.locus.addon.publiclib.LocusIntents;
-import menion.android.locus.addon.publiclib.geoData.Point;
-import menion.android.locus.addon.publiclib.geoData.PointGeocachingData;
-import menion.android.locus.addon.publiclib.geoData.PointGeocachingDataWaypoint;
-import menion.android.locus.addon.publiclib.geoData.PointsData;
-import menion.android.locus.addon.publiclib.utils.RequiredVersionMissingException;
+import locus.api.android.ActionDisplayPoints;
+import locus.api.android.ActionDisplayVarious;
+import locus.api.android.objects.LocusVersion;
+import locus.api.android.objects.PackPoints;
+import locus.api.android.utils.IntentHelper;
+import locus.api.android.utils.exceptions.RequiredVersionMissingException;
+import locus.api.objects.extra.Location;
+import locus.api.objects.geoData.Point;
 
 import static android.preference.PreferenceManager.getDefaultSharedPreferences;
-import static java.lang.Float.parseFloat;
 import static java.lang.Integer.parseInt;
 
 /**
@@ -47,8 +47,7 @@ public class LoadActivity extends Activity implements DialogInterface.OnDismissL
 
     private static final String TAG = "LoadActivity";
     private ProgressDialog progress;
-    private ArrayList<PointsData> data;
-    private File fd;
+    private PackPoints pd;
     private Point point;
     private LoadAsyncTask loadAsyncTask;
 
@@ -97,19 +96,19 @@ public class LoadActivity extends Activity implements DialogInterface.OnDismissL
 
                 Location curr = pointSet[0].getLocation();
                 if (db != null) {
-                    loadGCCodes(db, gcCodes, alreadyLoaded, curr);
+                    GsakReader.loadGCCodes(LoadActivity.this, this, db, gcCodes, alreadyLoaded, curr);
                     if (isCancelled()) {
                         return null;
                     }
                 }
                 if (db2 != null) {
-                    loadGCCodes(db2, gcCodes, alreadyLoaded, curr);
+                    GsakReader.loadGCCodes(LoadActivity.this, this, db2, gcCodes, alreadyLoaded, curr);
                     if (isCancelled()) {
                         return null;
                     }
                 }
                 if (db3 != null) {
-                    loadGCCodes(db3, gcCodes, alreadyLoaded, curr);
+                    GsakReader.loadGCCodes(LoadActivity.this, this, db3, gcCodes, alreadyLoaded, curr);
                     if (isCancelled()) {
                         return null;
                     }
@@ -126,7 +125,7 @@ public class LoadActivity extends Activity implements DialogInterface.OnDismissL
                     });
                 }
 
-                PointsData pd = new PointsData("GSAK data");
+                pd = new PackPoints("GSAK data");
                 for (Pair pair : gcCodes) {
                     if (isCancelled()) {
                         return null;
@@ -138,71 +137,13 @@ public class LoadActivity extends Activity implements DialogInterface.OnDismissL
                     if (++count % 10 == 0) {
                         publishProgress(count);
                     }
-                    Cursor c = pair.db.rawQuery("SELECT * FROM CachesAll WHERE Code = ?", new String[]{gcCode});
-                    c.moveToNext();
-                    Location loc = new Location(TAG);
-                    loc.setLatitude(c.getDouble(c.getColumnIndex("Latitude")));
-                    loc.setLongitude(c.getDouble(c.getColumnIndex("Longitude")));
-                    Point p = new Point(c.getString(c.getColumnIndex("Name")), loc);
-
-                    PointGeocachingData gcData = new PointGeocachingData();
-                    gcData.cacheID = c.getString(c.getColumnIndex("Code"));
-                    gcData.name = c.getString(c.getColumnIndex("Name"));
-                    gcData.owner = c.getString(c.getColumnIndex("OwnerName"));
-                    gcData.placedBy = c.getString(c.getColumnIndex("PlacedBy"));
-                    gcData.difficulty = c.getFloat(c.getColumnIndex("Difficulty"));
-                    gcData.terrain = c.getFloat(c.getColumnIndex("Terrain"));
-                    gcData.country = c.getString(c.getColumnIndex("Country"));
-                    gcData.state = c.getString(c.getColumnIndex("State"));
-                    gcData.container = Gsak.convertContainer(c.getString(c.getColumnIndex("Container")));
-                    gcData.type = Gsak.convertCacheType(c.getString(c.getColumnIndex("CacheType")));
-                    gcData.available = Gsak.isAvailable(c.getString(c.getColumnIndex("Status")));
-                    gcData.archived = Gsak.isArchived(c.getString(c.getColumnIndex("Status")));
-                    gcData.found = Gsak.isFound(c.getInt(c.getColumnIndex("Found")));
-                    gcData.premiumOnly = Gsak.isPremium(c.getInt(c.getColumnIndex("IsPremium")));
-                    gcData.computed = Gsak.isCorrected(c.getInt(c.getColumnIndex("HasCorrected")));
-
-                    @SuppressLint("SimpleDateFormat") SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'");
-                    Date date = new Date();
-                    gcData.exported = dateFormat.format(date);
-
-                    String lastUpdated = c.getString(c.getColumnIndex("LastUserDate"));
-                    if (lastUpdated.length() == 10) {
-                        gcData.lastUpdated = lastUpdated + "T";
-                    }
-                    gcData.hidden = c.getString(c.getColumnIndex("PlacedDate")) + "T";
-
-                    c.close();
-
-                    /* Add waypoints to Geocache */
-                    ArrayList<PointGeocachingDataWaypoint> pgdws = new ArrayList<>();
-
-                    Cursor wp = pair.db.rawQuery("SELECT * FROM WayAll WHERE cParent = ?", new String[]{gcData.cacheID});
-                    while (wp.moveToNext()) {
-                        if (this.isCancelled()) {
-                            wp.close();
-                            return null;
-                        }
-                        PointGeocachingDataWaypoint pgdw = new PointGeocachingDataWaypoint();
-                        pgdw.lat = wp.getDouble(wp.getColumnIndex("cLat"));
-                        pgdw.lon = wp.getDouble(wp.getColumnIndex("cLon"));
-                        pgdw.name = wp.getString(wp.getColumnIndex("cName"));
-                        pgdw.type = Gsak.convertWaypointType(wp.getString(wp.getColumnIndex("cType")));
-                        pgdw.description = wp.getString(wp.getColumnIndex("cComment"));
-                        pgdw.code = wp.getString(wp.getColumnIndex("cCode"));
-                        pgdws.add(pgdw);
+                    SQLiteDatabase database = pair.db;
+                    Point p = GsakReader.readGeocache(database, gcCode, false);
+                    if (p != null) {
+                        pd.addPoint(p);
                     }
-                    wp.close();
-                    gcData.waypoints = pgdws;
-
-                    p.setGeocachingData(gcData);
-                    p.setExtraOnDisplay("net.kuratkoo.locusaddon.gsakdatabase", "net.kuratkoo.locusaddon.gsakdatabase.DetailActivity", "cacheId", gcData.cacheID);
-                    pd.addPoint(p);
                 }
 
-                data = new ArrayList<>();
-                data.add(pd);
-
                 if (isCancelled()) {
                     return null;
                 }
@@ -212,96 +153,6 @@ public class LoadActivity extends Activity implements DialogInterface.OnDismissL
             }
         }
 
-        private void loadGCCodes(SQLiteDatabase database, List<Pair> gcCodes, Set<String> alreadyLoaded, Location curr) {
-            String sql = buildCacheSQL();
-
-            float radiusMeter = parseFloat(getDefaultSharedPreferences(LoadActivity.this).getString("radius", "25")) * 1000;
-            float radiusLatLon = radiusMeter / 1000 / 70;
-            float radiusNorthSouth = 360f / (40007863 / radiusMeter);
-            float radiusEastWest = 360f / (40075017 / radiusMeter) / (float)Math.cos(curr.getLatitude() / 180 * Math.PI);
-            String[] cond = new String[]{
-                    String.valueOf(curr.getLatitude() - radiusNorthSouth),
-                    String.valueOf(curr.getLatitude() + radiusNorthSouth),
-                    String.valueOf(curr.getLongitude() - radiusEastWest),
-                    String.valueOf(curr.getLongitude() + radiusEastWest)
-            };
-            /* Load GC codes */
-            Location loc = new Location(TAG);
-            Cursor c = database.rawQuery(sql, cond);
-            while (c.moveToNext()) {
-                if (isCancelled()) {
-                    c.close();
-                    return;
-                }
-                String code = c.getString(c.getColumnIndex("Code"));
-                if (!alreadyLoaded.contains(code)) {
-                    alreadyLoaded.add(code);
-                    loc.setLatitude(c.getDouble(c.getColumnIndex("Latitude")));
-                    loc.setLongitude(c.getDouble(c.getColumnIndex("Longitude")));
-                    if (loc.distanceTo(curr) <= radiusMeter) {
-                        gcCodes.add(new Pair(loc.distanceTo(curr), code, database));
-                    }
-                }
-            }
-            c.close();
-        }
-
-        private String buildCacheSQL() {
-            StringBuilder sql = new StringBuilder(256);
-            sql.append("SELECT Latitude, Longitude, Code FROM Caches WHERE (status = 'A'");
-
-            // Disable geocaches
-            SharedPreferences sharedPreferences = getDefaultSharedPreferences(LoadActivity.this);
-            if (sharedPreferences.getBoolean("disable", false)) {
-                sql.append(" OR status = 'T'");
-            }
-            // Archived geocaches
-            if (sharedPreferences.getBoolean("archive", false)) {
-                sql.append(" OR status = 'X'");
-            }
-            sql.append(") ");
-
-            // Found and not Found
-            boolean found = sharedPreferences.getBoolean("found", false);
-            boolean notfound = sharedPreferences.getBoolean("notfound", true);
-            if (found || notfound) {
-                sql.append(" AND ( 1=0 ");
-                if (found) {
-                    sql.append(" OR Found = 1");
-                }
-                if (notfound) {
-                    sql.append(" OR Found = 0");
-                }
-                sql.append(" ) ");
-            }
-
-            if (!sharedPreferences.getBoolean("own", false)) {
-                sql.append(" AND PlacedBy != '");
-                sql.append(sharedPreferences.getString("nick", ""));
-                sql.append("'");
-            }
-
-            List<String> geocacheTypes = Gsak.geocacheTypesFromFilter(sharedPreferences);
-            boolean first = true;
-            StringBuilder sqlType = new StringBuilder(256);
-            for (String geocacheType : geocacheTypes) {
-                if (first) {
-                    sqlType.append(geocacheType);
-                    first = false;
-                } else {
-                    sqlType.append(" OR ").append(geocacheType);
-                }
-            }
-            if (sqlType.length() > 0) {
-                sql.append(" AND (");
-                sql.append(sqlType);
-                sql.append(")");
-            }
-
-            sql.append(" AND CAST(Latitude AS REAL) > ? AND CAST(Latitude AS REAL) < ? AND CAST(Longitude AS REAL) > ? AND CAST(Longitude AS REAL) < ?");
-            return sql.toString();
-        }
-
         @Override
         protected void onPostExecute(Exception ex) {
             closeDatabases();
@@ -313,13 +164,18 @@ public class LoadActivity extends Activity implements DialogInterface.OnDismissL
                 return;
             }
 
-            String filePath = fd.getParent() + File.separator + "data.locus";
+//            String filePath = fd.getParent() + File.separator + "data.locus";
 
             try {
-                DisplayData.sendDataFile(LoadActivity.this,
+                ActionDisplayVarious.ExtraAction action = getDefaultSharedPreferences(LoadActivity.this).getBoolean("import", true) ?
+                        ActionDisplayVarious.ExtraAction.IMPORT :
+                        ActionDisplayVarious.ExtraAction.CENTER;
+                ActionDisplayPoints.INSTANCE.sendPack(LoadActivity.this, pd, action);
+
+/*                DisplayData.sendDataFile(LoadActivity.this,
                         data,
                         filePath,
-                        getDefaultSharedPreferences(LoadActivity.this).getBoolean("import", true));
+                        getDefaultSharedPreferences(LoadActivity.this).getBoolean("import", true));*/
             } catch (OutOfMemoryError e) {
                 AlertDialog.Builder ad = new AlertDialog.Builder(LoadActivity.this);
                 ad.setIcon(android.R.drawable.ic_dialog_alert);
@@ -373,7 +229,7 @@ public class LoadActivity extends Activity implements DialogInterface.OnDismissL
         progress.setOnDismissListener(this);
 
         SharedPreferences sharedPreferences = getDefaultSharedPreferences(LoadActivity.this);
-        fd = new File(sharedPreferences.getString("db", ""));
+        File fd = new File(sharedPreferences.getString("db", ""));
         if (!Gsak.isGsakDatabase(fd)) {
             Toast.makeText(LoadActivity.this, R.string.no_db_file, Toast.LENGTH_LONG).show();
             finish();
@@ -392,34 +248,32 @@ public class LoadActivity extends Activity implements DialogInterface.OnDismissL
             return;
         }
 
+        try {
         Intent fromIntent = getIntent();
-        if (LocusIntents.isIntentOnPointAction(fromIntent)) {
-            point = LocusIntents.handleIntentOnPointAction(fromIntent);
-        } else if (LocusIntents.isIntentMainFunction(fromIntent)) {
-            LocusIntents.handleIntentMainFunction(fromIntent, new LocusIntents.OnIntentMainFunction() {
-
-                public void onLocationReceived(boolean gpsEnabled, Location locGps, Location locMapCenter) {
-                    point = new Point("Map center", locMapCenter);
+        if (IntentHelper.INSTANCE.isIntentPointTools(fromIntent)) {
+            point = IntentHelper.INSTANCE.getPointFromIntent(this, fromIntent);
+        } else if (IntentHelper.INSTANCE.isIntentMainFunctionGc(fromIntent)) {
+            IntentHelper.INSTANCE.handleIntentMainFunctionGc(LoadActivity.this, fromIntent, new IntentHelper.OnIntentReceived() {
+                @Override
+                public void onReceived(@NotNull LocusVersion locusVersion, @Nullable Location gpsLocation, @Nullable Location mapCenterlocation) {
+                    if (mapCenterlocation != null) {
+                        point = new Point("Map center", mapCenterlocation);
+                    }
                 }
 
+                @Override
                 public void onFailed() {
                 }
             });
         }
-        loadAsyncTask = new LoadAsyncTask();
-        loadAsyncTask.execute(point);
+        if (point != null) {
+            loadAsyncTask = new LoadAsyncTask();
+            loadAsyncTask.execute(point);
+        }
+        } catch (RequiredVersionMissingException rvme) {
+            Toast.makeText(LoadActivity.this, "Error: " + rvme.getLocalizedMessage(), Toast.LENGTH_LONG).show();
+        }
     }
 
-    private static class Pair {
-
-        private final String gcCode;
-        private final float distance;
-        private final SQLiteDatabase db;
 
-        public Pair(final float dist, final String code, final SQLiteDatabase db) {
-            this.distance = dist;
-            this.gcCode = code;
-            this.db = db;
-        }
-    }
 }
diff --git a/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/MainActivity.java b/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/MainActivity.java
index b070cbd..bad33e0 100644
--- a/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/MainActivity.java
+++ b/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/MainActivity.java
@@ -14,7 +14,8 @@ import android.text.Html;
 import android.text.Spanned;
 import android.widget.Toast;
 
-import menion.android.locus.addon.publiclib.LocusUtils;
+import locus.api.android.ActionFiles;
+
 
 /**
  * MainActivity
@@ -86,7 +87,7 @@ public class MainActivity extends PreferenceActivity implements OnSharedPreferen
 
             public boolean onPreferenceClick(Preference pref) {
                 try {
-                    LocusUtils.intentPickFile(MainActivity.this, requestCode, getText(R.string.pref_db_pick_title).toString(), new String[]{".db3"});
+                    ActionFiles.INSTANCE.actionPickFile(MainActivity.this, requestCode, getText(R.string.pref_db_pick_title).toString(), new String[]{".db3"});
                 } catch (ActivityNotFoundException anfe) {
                     Toast.makeText(MainActivity.this, "Error: " + anfe.getLocalizedMessage(), Toast.LENGTH_LONG).show();
                 }
diff --git a/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/receiver/PointLoader.java b/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/receiver/PointLoader.java
index 04beead..a5e872f 100644
--- a/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/receiver/PointLoader.java
+++ b/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/receiver/PointLoader.java
@@ -16,14 +16,6 @@ import java.io.File;
 import java.util.ArrayList;
 import java.util.List;
 
-import menion.android.locus.addon.publiclib.DisplayData;
-import menion.android.locus.addon.publiclib.PeriodicUpdate;
-import menion.android.locus.addon.publiclib.PeriodicUpdate.UpdateContainer;
-import menion.android.locus.addon.publiclib.geoData.Point;
-import menion.android.locus.addon.publiclib.geoData.PointGeocachingData;
-import menion.android.locus.addon.publiclib.geoData.PointsData;
-import menion.android.locus.addon.publiclib.utils.RequiredVersionMissingException;
-
 /**
  * PointLoader
  * @author Radim -kuratkoo- Vaculik <kuratkoo@gmail.com>
@@ -34,7 +26,7 @@ public class PointLoader {
     private static PointLoader mInstance;
     private Context context;
     private Intent intent;
-    private MapLoadAsyncTask mapLoadAsyncTask;
+    //private MapLoadAsyncTask mapLoadAsyncTask;
 
     public static PointLoader getInstance() {
         if (mInstance == null) {
@@ -55,7 +47,7 @@ public class PointLoader {
     }
 
     public void run() {
-        PeriodicUpdate pu = PeriodicUpdate.getInstance();
+/*        PeriodicUpdate pu = PeriodicUpdate.getInstance();
         pu.setLocNotificationLimit(50.0);
         pu.onReceive(context, intent, new PeriodicUpdate.OnUpdate() {
 
@@ -74,10 +66,10 @@ public class PointLoader {
 
             public void onIncorrectData() {
             }
-        });
+        });*/
     }
 
-    private class MapLoadAsyncTask extends AsyncTask<UpdateContainer, Integer, Exception> {
+    /*private class MapLoadAsyncTask extends AsyncTask<UpdateContainer, Integer, Exception> {
 
         private PointsData pd;
         private SQLiteDatabase db;
@@ -211,5 +203,5 @@ public class PointLoader {
             db.close();
             db = null;
         }
-    }
+    }*/
 }
diff --git a/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/util/Gsak.java b/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/util/Gsak.java
index e67029a..93e5aca 100644
--- a/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/util/Gsak.java
+++ b/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/util/Gsak.java
@@ -9,8 +9,10 @@ import java.util.regex.MatchResult;
 import java.util.regex.Matcher;
 import java.util.regex.Pattern;
 
-import menion.android.locus.addon.publiclib.geoData.PointGeocachingData;
-import menion.android.locus.addon.publiclib.geoData.PointGeocachingDataTravelBug;
+import locus.api.objects.geocaching.GeocachingData;
+import locus.api.objects.geocaching.GeocachingLog;
+import locus.api.objects.geocaching.GeocachingTrackable;
+import locus.api.objects.geocaching.GeocachingWaypoint;
 
 /**
  * Gsak
@@ -25,69 +27,69 @@ public class Gsak {
     public static int convertContainer(String size) {
         switch (size) {
             case "Small":
-                return PointGeocachingData.CACHE_SIZE_SMALL;
+                return GeocachingData.CACHE_SIZE_SMALL;
             case "Large":
-                return PointGeocachingData.CACHE_SIZE_LARGE;
+                return GeocachingData.CACHE_SIZE_LARGE;
             case "Micro":
-                return PointGeocachingData.CACHE_SIZE_MICRO;
+                return GeocachingData.CACHE_SIZE_MICRO;
             case "Not chosen":
             case "Unknown":
-                return PointGeocachingData.CACHE_SIZE_NOT_CHOSEN;
+                return GeocachingData.CACHE_SIZE_NOT_CHOSEN;
             case "Other":
-                return PointGeocachingData.CACHE_SIZE_OTHER;
+                return GeocachingData.CACHE_SIZE_OTHER;
             case "Regular":
-                return PointGeocachingData.CACHE_SIZE_REGULAR;
+                return GeocachingData.CACHE_SIZE_REGULAR;
             default:
-                return PointGeocachingData.CACHE_SIZE_NOT_CHOSEN;
+                return GeocachingData.CACHE_SIZE_NOT_CHOSEN;
         }
     }
 
     public static int convertCacheType(String type) {
         switch (type) {
             case "C":
-                return PointGeocachingData.CACHE_TYPE_CACHE_IN_TRASH_OUT;
+                return GeocachingData.CACHE_TYPE_CACHE_IN_TRASH_OUT;
             case "R":
-                return PointGeocachingData.CACHE_TYPE_EARTH;
+                return GeocachingData.CACHE_TYPE_EARTH;
             case "E":
-                return PointGeocachingData.CACHE_TYPE_EVENT;
+                return GeocachingData.CACHE_TYPE_EVENT;
             case "B":
-                return PointGeocachingData.CACHE_TYPE_LETTERBOX;
+                return GeocachingData.CACHE_TYPE_LETTERBOX;
             case "Q":
-                return PointGeocachingData.CACHE_TYPE_ADVENTURE_LAB;
+                return GeocachingData.CACHE_TYPE_LAB_CACHE;
             case "Z":
-                return PointGeocachingData.CACHE_TYPE_MEGA_EVENT;
+                return GeocachingData.CACHE_TYPE_MEGA_EVENT;
             case "J":
-                return PointGeocachingData.CACHE_TYPE_GIGA_EVENT;
+                return GeocachingData.CACHE_TYPE_GIGA_EVENT;
             case "M":
-                return PointGeocachingData.CACHE_TYPE_MULTI;
+                return GeocachingData.CACHE_TYPE_MULTI;
             case "T":
-                return PointGeocachingData.CACHE_TYPE_TRADITIONAL;
+                return GeocachingData.CACHE_TYPE_TRADITIONAL;
             case "U":
-                return PointGeocachingData.CACHE_TYPE_MYSTERY;
+                return GeocachingData.CACHE_TYPE_MYSTERY;
             case "V":
-                return PointGeocachingData.CACHE_TYPE_VIRTUAL;
+                return GeocachingData.CACHE_TYPE_VIRTUAL;
             case "W":
-                return PointGeocachingData.CACHE_TYPE_WEBCAM;
+                return GeocachingData.CACHE_TYPE_WEBCAM;
             case "I":
-                return PointGeocachingData.CACHE_TYPE_WHERIGO;
+                return GeocachingData.CACHE_TYPE_WHERIGO;
             case "A":
-                return PointGeocachingData.CACHE_TYPE_PROJECT_APE;
+                return GeocachingData.CACHE_TYPE_PROJECT_APE;
             case "L":
-                return PointGeocachingData.CACHE_TYPE_LOCATIONLESS;
+                return GeocachingData.CACHE_TYPE_LOCATIONLESS;
             case "G":
-                return PointGeocachingData.CACHE_TYPE_BENCHMARK;
+                return GeocachingData.CACHE_TYPE_BENCHMARK;
             case "H":
-                return PointGeocachingData.CACHE_TYPE_GROUNDSPEAK;
+                return GeocachingData.CACHE_TYPE_GROUNDSPEAK;
             case "X":
-                return PointGeocachingData.CACHE_TYPE_MAZE_EXHIBIT;
+                return GeocachingData.CACHE_TYPE_MAZE_EXHIBIT;
             case "Y":
-                return PointGeocachingData.CACHE_TYPE_WAYMARK;
+                return GeocachingData.CACHE_TYPE_WAYMARK;
             case "F":
-                return PointGeocachingData.CACHE_TYPE_LF_EVENT;
+                return GeocachingData.CACHE_TYPE_LF_EVENT;
             case "D":
-                return PointGeocachingData.CACHE_TYPE_GC_HQ_BLOCK_PARTY;
+                return GeocachingData.CACHE_TYPE_GC_HQ_BLOCK_PARTY;
             default:
-                return PointGeocachingData.CACHE_TYPE_TRADITIONAL;
+                return GeocachingData.CACHE_TYPE_TRADITIONAL;
         }
     }
 
@@ -110,62 +112,62 @@ public class Gsak {
     public static String convertWaypointType(String waypointType) {
         switch (waypointType) {
             case "Final Location":
-                return PointGeocachingData.CACHE_WAYPOINT_TYPE_FINAL;
+                return GeocachingWaypoint.CACHE_WAYPOINT_TYPE_FINAL;
             case "Parking Area":
-                return PointGeocachingData.CACHE_WAYPOINT_TYPE_PARKING;
+                return GeocachingWaypoint.CACHE_WAYPOINT_TYPE_PARKING;
             case "Question to Answer":
-                return PointGeocachingData.CACHE_WAYPOINT_TYPE_QUESTION;
+                return GeocachingWaypoint.CACHE_WAYPOINT_TYPE_QUESTION;
             case "Reference Point":
-                return PointGeocachingData.CACHE_WAYPOINT_TYPE_REFERENCE;
+                return GeocachingWaypoint.CACHE_WAYPOINT_TYPE_REFERENCE;
             case "Stages of a Multicache":
-                return PointGeocachingData.CACHE_WAYPOINT_TYPE_STAGES;
+                return GeocachingWaypoint.CACHE_WAYPOINT_TYPE_STAGES;
             case "Trailhead":
-                return PointGeocachingData.CACHE_WAYPOINT_TYPE_TRAILHEAD;
+                return GeocachingWaypoint.CACHE_WAYPOINT_TYPE_TRAILHEAD;
             case "Physical Stage":
-                return PointGeocachingData.CACHE_WAYPOINT_TYPE_PHYSICAL_STAGE;
+                return GeocachingWaypoint.CACHE_WAYPOINT_TYPE_PHYSICAL_STAGE;
             case "Virtual Stage":
-                return PointGeocachingData.CACHE_WAYPOINT_TYPE_VIRTUAL_STAGE;
+                return GeocachingWaypoint.CACHE_WAYPOINT_TYPE_VIRTUAL_STAGE;
             case "Original Coordinates":
-                return PointGeocachingData.CACHE_WAYPOINT_TYPE_REFERENCE;
+                return GeocachingWaypoint.CACHE_WAYPOINT_TYPE_REFERENCE;
             default:
-                return PointGeocachingData.CACHE_WAYPOINT_TYPE_REFERENCE;
+                return GeocachingWaypoint.CACHE_WAYPOINT_TYPE_REFERENCE;
         }
     }
 
     public static int convertLogType(String logType) {
         switch (logType) {
             case "Announcement":
-                return PointGeocachingData.CACHE_LOG_TYPE_ANNOUNCEMENT;
+                return GeocachingLog.CACHE_LOG_TYPE_ANNOUNCEMENT;
             case "Attended":
-                return PointGeocachingData.CACHE_LOG_TYPE_ATTENDED;
+                return GeocachingLog.CACHE_LOG_TYPE_ATTENDED;
             case "Didn't find it":
-                return PointGeocachingData.CACHE_LOG_TYPE_NOT_FOUNDED;
+                return GeocachingLog.CACHE_LOG_TYPE_NOT_FOUND;
             case "Enable Listing":
-                return PointGeocachingData.CACHE_LOG_TYPE_ENABLE_LISTING;
+                return GeocachingLog.CACHE_LOG_TYPE_ENABLE_LISTING;
             case "Found it":
-                return PointGeocachingData.CACHE_LOG_TYPE_FOUNDED;
+                return GeocachingLog.CACHE_LOG_TYPE_FOUND;
             case "Needs Archived":
-                return PointGeocachingData.CACHE_LOG_TYPE_NEEDS_ARCHIVED;
+                return GeocachingLog.CACHE_LOG_TYPE_NEEDS_ARCHIVED;
             case "Needs Maintenance":
-                return PointGeocachingData.CACHE_LOG_TYPE_NEEDS_MAINTENANCE;
+                return GeocachingLog.CACHE_LOG_TYPE_NEEDS_MAINTENANCE;
             case "Owner Maintenance":
-                return PointGeocachingData.CACHE_LOG_TYPE_OWNER_MAINTENANCE;
+                return GeocachingLog.CACHE_LOG_TYPE_OWNER_MAINTENANCE;
             case "Post Reviewer Note":
-                return PointGeocachingData.CACHE_LOG_TYPE_POST_REVIEWER_NOTE;
+                return GeocachingLog.CACHE_LOG_TYPE_POST_REVIEWER_NOTE;
             case "Publish Listing":
-                return PointGeocachingData.CACHE_LOG_TYPE_PUBLISH_LISTING;
+                return GeocachingLog.CACHE_LOG_TYPE_PUBLISH_LISTING;
             case "Temporarily Disable Listing":
-                return PointGeocachingData.CACHE_LOG_TYPE_TEMPORARILY_DISABLE_LISTING;
+                return GeocachingLog.CACHE_LOG_TYPE_TEMPORARILY_DISABLE_LISTING;
             case "Update Coordinates":
-                return PointGeocachingData.CACHE_LOG_TYPE_UPDATE_COORDINATES;
+                return GeocachingLog.CACHE_LOG_TYPE_UPDATE_COORDINATES;
             case "Webcam Photo Taken":
-                return PointGeocachingData.CACHE_LOG_TYPE_WEBCAM_PHOTO_TAKEN;
+                return GeocachingLog.CACHE_LOG_TYPE_WEBCAM_PHOTO_TAKEN;
             case "Will Attend":
-                return PointGeocachingData.CACHE_LOG_TYPE_WILL_ATTEND;
+                return GeocachingLog.CACHE_LOG_TYPE_WILL_ATTEND;
             case "Write note":
-                return PointGeocachingData.CACHE_LOG_TYPE_WRITE_NOTE;
+                return GeocachingLog.CACHE_LOG_TYPE_WRITE_NOTE;
             default:
-                return PointGeocachingData.CACHE_LOG_TYPE_UNKNOWN;
+                return GeocachingLog.CACHE_LOG_TYPE_UNKNOWN;
         }
     }
 
@@ -173,15 +175,15 @@ public class Gsak {
         return correction == 1;
     }
 
-    public static ArrayList<PointGeocachingDataTravelBug> parseTravelBug(String tb) {
-        ArrayList<PointGeocachingDataTravelBug> pgdtbl = new ArrayList<>();
+    public static List<GeocachingTrackable> parseTravelBug(String tb) {
+        ArrayList<GeocachingTrackable> pgdtbl = new ArrayList<>();
         Pattern p = Pattern.compile("<BR>([^(]+)\\(id = ([0-9]+), ref = ([A-Z0-9]+)\\)");
         Matcher m = p.matcher(tb);
         while (m.find()) {
             MatchResult mr = m.toMatchResult();
-            PointGeocachingDataTravelBug pgdtb = new PointGeocachingDataTravelBug();
-            pgdtb.name = mr.group(1);
-            pgdtb.srcDetails = "http://www.geocaching.com/track/details.aspx?tracker=" + mr.group(3);
+            GeocachingTrackable pgdtb = new GeocachingTrackable();
+            pgdtb.setName(mr.group(1));
+            pgdtb.setSrcDetails("http://www.geocaching.com/track/details.aspx?tracker=" + mr.group(3));
             pgdtbl.add(pgdtb);
         }
         return pgdtbl;
diff --git a/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/util/GsakReader.java b/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/util/GsakReader.java
new file mode 100644
index 0000000..560f153
--- /dev/null
+++ b/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/util/GsakReader.java
@@ -0,0 +1,248 @@
+package net.kuratkoo.locusaddon.gsakdatabase.util;
+
+import android.annotation.SuppressLint;
+import android.content.Context;
+import android.content.SharedPreferences;
+import android.database.Cursor;
+import android.database.sqlite.SQLiteDatabase;
+import android.os.AsyncTask;
+import android.preference.PreferenceManager;
+
+import net.kuratkoo.locusaddon.gsakdatabase.LoadActivity;
+
+import org.jetbrains.annotations.Nullable;
+
+import java.text.ParseException;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.List;
+import java.util.Set;
+
+import locus.api.objects.extra.Location;
+import locus.api.objects.geoData.Point;
+import locus.api.objects.geocaching.GeocachingAttribute;
+import locus.api.objects.geocaching.GeocachingData;
+import locus.api.objects.geocaching.GeocachingLog;
+import locus.api.objects.geocaching.GeocachingWaypoint;
+
+import static android.preference.PreferenceManager.getDefaultSharedPreferences;
+import static java.lang.Float.parseFloat;
+
+public class GsakReader {
+
+    public static void loadGCCodes(Context context, AsyncTask asyncTask, SQLiteDatabase database,
+                                   List<Pair> gcCodes, Set<String> alreadyLoaded, Location curr) {
+        String sql = buildCacheSQL(context);
+
+        float radiusMeter = parseFloat(getDefaultSharedPreferences(context).getString("radius", "25")) * 1000;
+        float radiusNorthSouth = 360f / (40007863 / radiusMeter);
+        float radiusEastWest = 360f / (40075017 / radiusMeter) / (float)Math.cos(curr.getLatitude() / 180 * Math.PI);
+        String[] cond = new String[]{
+                String.valueOf(curr.getLatitude() - radiusNorthSouth),
+                String.valueOf(curr.getLatitude() + radiusNorthSouth),
+                String.valueOf(curr.getLongitude() - radiusEastWest),
+                String.valueOf(curr.getLongitude() + radiusEastWest)
+        };
+        /* Load GC codes */
+        Location loc = new Location();
+        Cursor c = database.rawQuery(sql, cond);
+        while (c.moveToNext()) {
+            if (asyncTask !=null && asyncTask.isCancelled()) {
+                c.close();
+                return;
+            }
+            String code = c.getString(c.getColumnIndex("Code"));
+            if (!alreadyLoaded.contains(code)) {
+                alreadyLoaded.add(code);
+                loc.setLatitude(c.getDouble(c.getColumnIndex("Latitude")));
+                loc.setLongitude(c.getDouble(c.getColumnIndex("Longitude")));
+                if (loc.distanceTo(curr) <= radiusMeter) {
+                    gcCodes.add(new Pair(loc.distanceTo(curr), code, database));
+                }
+            }
+        }
+        c.close();
+    }
+
+    private static String buildCacheSQL(Context context) {
+        StringBuilder sql = new StringBuilder(256);
+        sql.append("SELECT Latitude, Longitude, Code FROM Caches WHERE (status = 'A'");
+
+        // Disable geocaches
+        SharedPreferences sharedPreferences = getDefaultSharedPreferences(context);
+        if (sharedPreferences.getBoolean("disable", false)) {
+            sql.append(" OR status = 'T'");
+        }
+        // Archived geocaches
+        if (sharedPreferences.getBoolean("archive", false)) {
+            sql.append(" OR status = 'X'");
+        }
+        sql.append(") ");
+
+        // Found and not Found
+        boolean found = sharedPreferences.getBoolean("found", false);
+        boolean notfound = sharedPreferences.getBoolean("notfound", true);
+        if (found || notfound) {
+            sql.append(" AND ( 1=0 ");
+            if (found) {
+                sql.append(" OR Found = 1");
+            }
+            if (notfound) {
+                sql.append(" OR Found = 0");
+            }
+            sql.append(" ) ");
+        }
+
+        if (!sharedPreferences.getBoolean("own", false)) {
+            sql.append(" AND PlacedBy != '");
+            sql.append(sharedPreferences.getString("nick", ""));
+            sql.append("'");
+        }
+
+        List<String> geocacheTypes = Gsak.geocacheTypesFromFilter(sharedPreferences);
+        boolean first = true;
+        StringBuilder sqlType = new StringBuilder(256);
+        for (String geocacheType : geocacheTypes) {
+            if (first) {
+                sqlType.append(geocacheType);
+                first = false;
+            } else {
+                sqlType.append(" OR ").append(geocacheType);
+            }
+        }
+        if (sqlType.length() > 0) {
+            sql.append(" AND (");
+            sql.append(sqlType);
+            sql.append(")");
+        }
+
+        sql.append(" AND CAST(Latitude AS REAL) > ? AND CAST(Latitude AS REAL) < ? AND CAST(Longitude AS REAL) > ? AND CAST(Longitude AS REAL) < ?");
+        return sql.toString();
+    }
+
+    @Nullable
+    public static Point readGeocache(SQLiteDatabase database, String gcCode, boolean withDetails) throws ParseException {
+        Cursor cacheCursor = database.rawQuery("SELECT * FROM CachesAll WHERE Code = ?", new String[]{gcCode});
+        cacheCursor.moveToNext();
+        Location loc = new Location(cacheCursor.getDouble(cacheCursor.getColumnIndex("Latitude")), cacheCursor.getDouble(cacheCursor.getColumnIndex("Longitude")));
+        Point point = new Point(cacheCursor.getString(cacheCursor.getColumnIndex("Name")), loc);
+
+        GeocachingData gcData = new GeocachingData();
+        gcData.setCacheID(cacheCursor.getString(cacheCursor.getColumnIndex("Code")));
+        gcData.setName(cacheCursor.getString(cacheCursor.getColumnIndex("Name")));
+        gcData.setOwner(cacheCursor.getString(cacheCursor.getColumnIndex("OwnerName")));
+        gcData.setPlacedBy(cacheCursor.getString(cacheCursor.getColumnIndex("PlacedBy")));
+        gcData.setDifficulty(cacheCursor.getFloat(cacheCursor.getColumnIndex("Difficulty")));
+        gcData.setTerrain(cacheCursor.getFloat(cacheCursor.getColumnIndex("Terrain")));
+        gcData.setCountry(cacheCursor.getString(cacheCursor.getColumnIndex("Country")));
+        gcData.setState(cacheCursor.getString(cacheCursor.getColumnIndex("State")));
+        gcData.setContainer(Gsak.convertContainer(cacheCursor.getString(cacheCursor.getColumnIndex("Container"))));
+        gcData.setType(Gsak.convertCacheType(cacheCursor.getString(cacheCursor.getColumnIndex("CacheType"))));
+        gcData.setAvailable(Gsak.isAvailable(cacheCursor.getString(cacheCursor.getColumnIndex("Status"))));
+        gcData.setArchived(Gsak.isArchived(cacheCursor.getString(cacheCursor.getColumnIndex("Status"))));
+        gcData.setFound(Gsak.isFound(cacheCursor.getInt(cacheCursor.getColumnIndex("Found"))));
+        gcData.setPremiumOnly(Gsak.isPremium(cacheCursor.getInt(cacheCursor.getColumnIndex("IsPremium"))));
+        gcData.setComputed(Gsak.isCorrected(cacheCursor.getInt(cacheCursor.getColumnIndex("HasCorrected"))));
+
+        gcData.setLatOriginal(cacheCursor.getDouble(cacheCursor.getColumnIndex("LatOriginal")));
+        gcData.setLonOriginal(cacheCursor.getDouble(cacheCursor.getColumnIndex("LonOriginal")));
+//        gcData.setCacheUrl();
+        gcData.setFavoritePoints(cacheCursor.getInt(cacheCursor.getColumnIndex("FavPoints")));
+//        gcData.setGcVoteNumOfVotes(cacheCursor.getInt(cacheCursor.getColumnIndex("??")));
+//        gcData.setGcVoteAverage(cacheCursor.getFloat(cacheCursor.getColumnIndex("??")));
+//        gcData.setGcVoteUserVote(cacheCursor.getFloat(cacheCursor.getColumnIndex("??")));
+
+        //gcData.setexported = dateFormat.format(date);
+        gcData.setDateUpdated(getDate(cacheCursor, "LastUserDate"));
+        gcData.setDateHidden(getDate(cacheCursor,"PlacedDate")); //TODO
+        gcData.setDatePublished(getDate(cacheCursor,"PlacedDate")); // TODO
+
+        if (withDetails) {
+            // More!
+            gcData.setNotes(cacheCursor.getString(cacheCursor.getColumnIndex("UserNote")));
+            gcData.setEncodedHints(cacheCursor.getString(cacheCursor.getColumnIndex("Hints")));
+            gcData.setDescriptions(cacheCursor.getString(cacheCursor.getColumnIndex("ShortDescription")),
+                    cacheCursor.getInt(cacheCursor.getColumnIndex("ShortHtm")) == 1,
+                    cacheCursor.getString(cacheCursor.getColumnIndex("LongDescription")),
+                    cacheCursor.getInt(cacheCursor.getColumnIndex("LongHtm")) == 1);
+
+            // TB & GC
+            gcData.setTrackables(Gsak.parseTravelBug(cacheCursor.getString(cacheCursor.getColumnIndex("TravelBugs"))));
+        }
+
+        cacheCursor.close();
+
+        /* Add waypoints to Geocache */
+        ArrayList<GeocachingWaypoint> pgdws = new ArrayList<>();
+
+        Cursor wpCursor = database.rawQuery("SELECT * FROM WayAll WHERE cParent = ?", new String[]{gcData.getCacheID()});
+        while (wpCursor.moveToNext()) {
+/*            if (this.isCancelled()) {
+                wpCursor.close();
+                return null;
+            }*/
+            GeocachingWaypoint waypoint = new GeocachingWaypoint();
+            waypoint.setLat(wpCursor.getDouble(wpCursor.getColumnIndex("cLat")));
+            waypoint.setLon(wpCursor.getDouble(wpCursor.getColumnIndex("cLon")));
+            waypoint.setName(wpCursor.getString(wpCursor.getColumnIndex("cName")));
+            waypoint.setType(Gsak.convertWaypointType(wpCursor.getString(wpCursor.getColumnIndex("cType"))));
+            waypoint.setDesc(wpCursor.getString(wpCursor.getColumnIndex("cComment")));
+            waypoint.setCode(wpCursor.getString(wpCursor.getColumnIndex("cCode")));
+//            waypoint.setDescModified();
+            pgdws.add(waypoint);
+        }
+        wpCursor.close();
+        gcData.setWaypoints(pgdws);
+
+        if (withDetails) {
+            // Add logsCursor to Geocache
+            //String limit = PreferenceManager.getDefaultSharedPreferences(context).getString("logs_count", "20");
+            String limit = "20";
+            Cursor logsCursor = database.rawQuery("SELECT * FROM LogsAll WHERE lParent = ? ORDER BY lDate DESC LIMIT ?",
+                    new String[]{gcData.getCacheID(), limit});
+            ArrayList<GeocachingLog> pgdls = new ArrayList<>();
+
+            while (logsCursor.moveToNext()) {
+                GeocachingLog pgdl = new GeocachingLog();
+                pgdl.setDate(getDate(logsCursor, "lDate"));
+                pgdl.setFinder(logsCursor.getString(logsCursor.getColumnIndex("lBy")));
+                pgdl.setLogText(logsCursor.getString(logsCursor.getColumnIndex("lText")));
+                pgdl.setType(Gsak.convertLogType(logsCursor.getString(logsCursor.getColumnIndex("lType"))));
+                pgdls.add(pgdl);
+            }
+            logsCursor.close();
+            gcData.setLogs(pgdls);
+        }
+
+        if (withDetails) {
+            // Add attributes to Geocache
+            Cursor at = database.rawQuery("SELECT * FROM Attributes WHERE aCode = ?", new String[]{gcData.getCacheID()});
+            List<GeocachingAttribute> pgas = new ArrayList<>();
+
+            while (at.moveToNext()) {
+                boolean isPositive = at.getInt(at.getColumnIndex("aInc")) == 1;
+                GeocachingAttribute pga = new GeocachingAttribute(at.getInt(at.getColumnIndex("aId")), isPositive);
+                pgas.add(pga);
+            }
+            at.close();
+            gcData.setAttributes(pgas);
+        }
+
+        point.setGcData(gcData);
+        point.setExtraOnDisplay("net.kuratkoo.locusaddon.gsakdatabase",
+                "net.kuratkoo.locusaddon.gsakdatabase.DetailActivity",
+                "cacheId", gcData.getCacheID());
+        return point;
+    }
+
+    private static long getDate(Cursor c, final String columnName) throws ParseException {
+        @SuppressLint("SimpleDateFormat") SimpleDateFormat dateFormat = new SimpleDateFormat("yyyy-MM-dd");
+        final String text = c.getString(c.getColumnIndex(columnName));
+        if (text.length() == 10) {
+            return dateFormat.parse(text).getTime();
+        }
+        return 0L;
+    }
+
+
+}
diff --git a/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/util/Pair.java b/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/util/Pair.java
new file mode 100644
index 0000000..10672f9
--- /dev/null
+++ b/locusAddonGSAK/src/main/java/net/kuratkoo/locusaddon/gsakdatabase/util/Pair.java
@@ -0,0 +1,16 @@
+package net.kuratkoo.locusaddon.gsakdatabase.util;
+
+import android.database.sqlite.SQLiteDatabase;
+
+public class Pair {
+
+    public final String gcCode;
+    public final float distance;
+    public final SQLiteDatabase db;
+
+    public Pair(final float dist, final String code, final SQLiteDatabase db) {
+        this.distance = dist;
+        this.gcCode = code;
+        this.db = db;
+    }
+}
diff --git a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/DisplayData.java b/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/DisplayData.java
deleted file mode 100644
index 38ceb29..0000000
--- a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/DisplayData.java
+++ /dev/null
@@ -1,398 +0,0 @@
-/*  
- * Copyright 2011, Asamm Software, s.r.o.
- * 
- * This file is part of LocusAddonPublicLib.
- * 
- * LocusAddonPublicLib is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *  
- * LocusAddonPublicLib is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *  
- * You should have received a copy of the GNU General Public License
- * along with LocusAddonPublicLib.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package menion.android.locus.addon.publiclib;
-
-import java.io.DataInputStream;
-import java.io.DataOutputStream;
-import java.io.File;
-import java.io.FileInputStream;
-import java.io.FileOutputStream;
-import java.util.ArrayList;
-
-import menion.android.locus.addon.publiclib.geoData.PointsData;
-import menion.android.locus.addon.publiclib.geoData.Track;
-import menion.android.locus.addon.publiclib.utils.DataStorage;
-import menion.android.locus.addon.publiclib.utils.RequiredVersionMissingException;
-import android.content.Context;
-import android.content.Intent;
-import android.os.Parcel;
-import android.util.Log;
-
-public class DisplayData {
-
-	private static final String TAG = "DisplayData";
-	
-	/*******************************/
-	/*        DISPLAY POINTS       */
-	/*******************************/
-	
-	/**
-	 * Simple way how to send data over intent to Locus. Count that intent in
-	 * Android have some size limits so for larger data, use another method
-	 * @param context actual {@link Context}
-	 * @param data {@link PointsData} object that should be send to Locus
-	 * @param callImport whether import with this data should be called after Locus starts
-	 * @return true if success
-	 * @throws RequiredVersionMissingException 
-	 */
-	public static boolean sendData(Context context, PointsData data, boolean callImport)
-			throws RequiredVersionMissingException {
-		return sendData(LocusConst.INTENT_DISPLAY_DATA, context, data, callImport);
-	}
-	
-	public static boolean sendDataSilent(Context context, PointsData data)
-			throws RequiredVersionMissingException {
-		return sendData(LocusConst.ACTION_DISPLAY_DATA_SILENTLY, context, data, false);
-	}
-	
-	private static boolean sendData(String action, Context context, PointsData data, boolean callImport)
-			throws RequiredVersionMissingException {
-		if (data == null)
-			return false;
-		Intent intent = new Intent();
-		intent.putExtra(LocusConst.EXTRA_POINTS_DATA, data);
-		return sendData(action, context, intent, callImport);
-	}
-	
-	/**
-	 * Simple way how to send ArrayList<PointsData> object over intent to Locus. Count that
-	 * intent in Android have some size limits so for larger data, use another method
-	 * @param context actual {@link Context}
-	 * @param data {@link ArrayList} of data that should be send to Locus
-	 * @return true if success
-	 * @throws RequiredVersionMissingException 
-	 */
-	public static boolean sendData(Context context, ArrayList<PointsData> data, boolean callImport)
-			throws RequiredVersionMissingException {
-		return sendData(LocusConst.INTENT_DISPLAY_DATA, context, data, callImport);
-	}
-	
-	public static boolean sendDataSilent(Context context, ArrayList<PointsData> data)
-			throws RequiredVersionMissingException {
-		return sendData(LocusConst.ACTION_DISPLAY_DATA_SILENTLY, context, data, false);
-	}
-	
-	private static boolean sendData(String action, Context context, ArrayList<PointsData> data, boolean callImport)
-			throws RequiredVersionMissingException {
-		if (data == null)
-			return false;
-		Intent intent = new Intent();
-		intent.putParcelableArrayListExtra(LocusConst.EXTRA_POINTS_DATA_ARRAY, data);
-		return sendData(action, context, intent, callImport);
-	}
-	
-	private static final int FILE_VERSION = 1;
-	
-	/**
-	 * Allow to send data to locus, by storing serialized version of data into file. This method
-	 * can have advantage over cursor in simplicity of implementation and also that filesize is
-	 * not limited as in Cursor method. On second case, need permission for disk access and should
-	 * be slower due to IO operations. Be careful about size of data. This method can cause OutOfMemory
-	 * error on Locus side if data are too big
-	 *   
-	 * @param context
-	 * @param data
-	 * @param filepath
-	 * @param callImport
-	 * @return
-	 * @throws RequiredVersionMissingException 
-	 */
-	public static boolean sendDataFile(Context context, ArrayList<PointsData> data, String filepath, boolean callImport)
-			throws RequiredVersionMissingException {
-		return sendDataFile(LocusConst.INTENT_DISPLAY_DATA, context, data, filepath, callImport);
-	}
-	
-	public static boolean sendDataFileSilent(Context context, ArrayList<PointsData> data, String filepath) 
-			throws RequiredVersionMissingException {
-		return sendDataFile(LocusConst.ACTION_DISPLAY_DATA_SILENTLY, context, data, filepath, false);
-	}
-	
-	private static boolean sendDataFile(String action, Context context, ArrayList<PointsData> data, String filepath,
-			boolean callImport) throws RequiredVersionMissingException {
-		if (sendDataWriteOnCard(data, filepath)) {
-			Intent intent = new Intent();
-			intent.putExtra(LocusConst.EXTRA_POINTS_FILE_PATH, filepath);
-			return sendData(action, context, intent, callImport);	
-		} else {
-			return false;
-		}
-	}
-	
-	public static boolean sendDataWriteOnCard(ArrayList<PointsData> data, String filepath) {
-		if (data == null || data.size() == 0)
-			return false;
-		
-		FileOutputStream os = null;
-		DataOutputStream dos = null;
-		try {
-			File file = new File(filepath);
-			file.getParentFile().mkdirs();
-
-			if (file.exists())
-				file.delete();
-			if (!file.exists()) {
-				file.createNewFile();
-			}
-
-			os = new FileOutputStream(file, false);
-			dos = new DataOutputStream(os);
-	
-			// write current version
-			dos.writeInt(FILE_VERSION);
-			
-			// write data
-			for (int i = 0; i < data.size(); i++) {
-				// get byte array
-				Parcel par = Parcel.obtain();
-				data.get(i).writeToParcel(par, 0);
-				byte[] byteData = par.marshall();
-				
-				// write data
-				dos.writeInt(byteData.length);
-				dos.write(byteData);
-			}
-				
-			os.flush();
-			return true;
-		} catch (Exception e) {
-			Log.e(TAG, "sendDataWriteOnCard(" + filepath + ", " + data + ")", e);
-			return false;
-		} finally {
-			try {
-				if (dos != null) {
-					dos.close();
-				}
-			} catch (Exception e) {
-				Log.e(TAG, "sendDataWriteOnCard(" + filepath + ", " + data + ")", e);
-			}
-		}
-	}
-
-	/**
-	 * Invert method to {@link #sendDataFile}. This load serialized data from file object
-	 * @param filepath
-	 * @return
-	 */
-	public static ArrayList<PointsData> getDataFile(String filepath) {
-		ArrayList<PointsData> returnData = new ArrayList<PointsData>();
-		
-		// check file
-		File file = new File(filepath);
-		if (!file.exists())
-			return returnData;
-		
-		DataInputStream dis = null;
-		try {
-			dis = new DataInputStream(new FileInputStream(file));
-			
-			// check version
-			if (dis.readInt() != FILE_VERSION) {
-				Log.e(TAG, "getDataFile(" + filepath + "), unsupported (old) version!");
-				return returnData;
-			}
-			
-			while (true) {
-				if (dis.available() == 0)
-					break;
-
-				int size = dis.readInt();
-				byte[] data = new byte[size];
-				dis.read(data);
-				
-				Parcel par = Parcel.obtain();
-				par.unmarshall(data, 0, data.length);
-				par.setDataPosition(0);
-				
-				PointsData pd = PointsData.CREATOR.createFromParcel(par);
-				if (pd != null)
-					returnData.add(pd);
-			}
-			return returnData;
-		} catch (Exception e) {
-			Log.e(TAG, "getDataFile(" + filepath + ")", e);
-			return null;
-		} finally {
-			try {
-				if (dis != null)
-					dis.close();
-			} catch (Exception e) {}
-		}
-	}
-	
-	/**
-	 * Way how to send ArrayList<PointsData> object over intent to Locus. Data are
-	 * stored in ContentProvider so don't forget to register it in manifest. More in
-	 * sample application. This is recommended way how to send huge data to Locus 
-	 * @param context actual context
-	 * @param data ArrayList of data that should be send to Locus
-	 * @param callImport whether import with this data should be called after Locus starts
-	 * @return true if success
-	 * @throws RequiredVersionMissingException 
-	 */
-	public static boolean sendDataCursor(Context context, PointsData data, String uri, boolean callImport)
-			throws RequiredVersionMissingException {
-		return sendDataCursor(LocusConst.INTENT_DISPLAY_DATA, context, data, uri, callImport);
-	}
-	
-	public static boolean sendDataCursorSilent(Context context, PointsData data, String uri)
-			throws RequiredVersionMissingException {
-		return sendDataCursor(LocusConst.ACTION_DISPLAY_DATA_SILENTLY, context, data, uri, false);
-	}
-	
-	private static boolean sendDataCursor(String action, Context context, PointsData data, String uri,
-			boolean callImport) throws RequiredVersionMissingException {
-		if (data == null)
-			return false;
-		// set data
-		DataStorage.setData(data);
-		Intent intent = new Intent();
-		intent.putExtra(LocusConst.EXTRA_POINTS_CURSOR_URI, uri);
-		return sendData(action, context, intent, callImport);
-	}
-	
-	/**
-	 * Way how to send ArrayList<PointsData> object over intent to Locus. Data are
-	 * stored in ContentProvider so don't forget to register it in manifest. More in
-	 * sample application. This is recommended way how to send huge data to Locus 
-	 * @param context actual context
-	 * @param data ArrayList of data that should be send to Locus
-	 * @return true if success
-	 * @throws RequiredVersionMissingException 
-	 */
-	public static boolean sendDataCursor(Context context, ArrayList<PointsData> data,
-			String uri, boolean callImport) throws RequiredVersionMissingException {
-		return sendDataCursor(LocusConst.INTENT_DISPLAY_DATA, context, data, uri, callImport);
-	}
-	
-	public static boolean sendDataCursorSilent(Context context, ArrayList<PointsData> data,
-			String uri) throws RequiredVersionMissingException {
-		return sendDataCursor(LocusConst.ACTION_DISPLAY_DATA_SILENTLY, context, data, uri, false);
-	}
-	
-	private static boolean sendDataCursor(String action, Context context, ArrayList<PointsData> data,
-			String uri, boolean callImport) throws RequiredVersionMissingException {
-		if (data == null)
-			return false;
-		// set data
-		DataStorage.setData(data);
-		Intent intent = new Intent();
-		intent.putExtra(LocusConst.EXTRA_POINTS_CURSOR_URI, uri);
-		return sendData(action, context, intent, callImport);
-	}
-
-	/*******************************/
-	/*        DISPLAY TRACKS       */
-	/*******************************/
-	
-	public static boolean sendData(Context context, Track track, boolean callImport)
-			throws RequiredVersionMissingException {
-		return sendData(LocusConst.INTENT_DISPLAY_DATA, context, track, callImport);
-	}
-	
-	public static boolean sendDataSilent(Context context, Track track)
-			throws RequiredVersionMissingException {
-		return sendData(LocusConst.ACTION_DISPLAY_DATA_SILENTLY, context, track, false);
-	}
-	
-	private static boolean sendData(String action, Context context, Track track, boolean callImport)
-			throws RequiredVersionMissingException {
-		if (track == null)
-			return false;
-		Intent intent = new Intent();
-		intent.putExtra(LocusConst.EXTRA_TRACKS_SINGLE, track);
-		return sendData(action, context, intent, callImport, 64, 125);
-	}
-	
-	public static boolean sendDataTracks(Context context, ArrayList<Track> tracks, boolean callImport)
-			throws RequiredVersionMissingException {
-		return sendDataTracks(LocusConst.INTENT_DISPLAY_DATA, context, tracks, callImport);
-	}
-	
-	public static boolean sendDataTracksSilent(Context context, ArrayList<Track> tracks)
-			throws RequiredVersionMissingException {
-		return sendDataTracks(LocusConst.ACTION_DISPLAY_DATA_SILENTLY, context, tracks, false);
-	}
-	
-	private static boolean sendDataTracks(String action, Context context, ArrayList<Track> tracks, boolean callImport)
-			throws RequiredVersionMissingException {
-		if (tracks == null || tracks.size() == 0)
-			return false;
-		Intent intent = new Intent();
-		intent.putParcelableArrayListExtra(LocusConst.EXTRA_TRACKS_MULTI, tracks);
-		return sendData(action, context, intent, callImport, 69, 131);
-	}
-	
-	/*******************************/
-	/*        PRIVATE CALLS        */
-	/*******************************/
-	
-	private static boolean sendData(String action, Context context, Intent intent,
-			boolean callImport) throws RequiredVersionMissingException{
-		return sendData(action, context, intent, callImport, -1, -1);
-	}
-	
-	private static boolean sendData(String action, Context context, Intent intent,
-			boolean callImport, int versionPro, int versionFree) throws RequiredVersionMissingException {
-		// set correct versions (mainly due to new functionality)
-		if (action.equals(LocusConst.ACTION_DISPLAY_DATA_SILENTLY)) {
-			versionFree = Math.max(versionFree, 202);
-			versionPro = Math.max(versionPro, 202);
-		}
-		
-		// really exist locus?
-		if (!LocusUtils.isLocusAvailable(context, versionPro, versionFree)) {
-			throw new RequiredVersionMissingException(versionPro, versionFree);
-		}
-		
-		// check intent firstly
-		if (!hasData(intent)) {
-			Log.w(TAG, "Intent 'null' or not contain any data");
-			return false;
-		}
-		
-		// create intent with right calling method
-		intent.setAction(action);
-		
-		// set import tag
-		if (action.equals(LocusConst.ACTION_DISPLAY_DATA_SILENTLY)) {
-			context.sendBroadcast(intent);
-		} else {
-			// set import tag
-			intent.putExtra(LocusConst.EXTRA_CALL_IMPORT, callImport);
-			// finally start activity
-			context.startActivity(intent);			
-		}
-		
-		return true;
-	}
-	
-	public static boolean hasData(Intent intent) {
-		if (intent == null)
-			return false;
-		
-		return !(
-				intent.getParcelableArrayListExtra(LocusConst.EXTRA_POINTS_DATA_ARRAY) == null && 
-				intent.getParcelableExtra(LocusConst.EXTRA_POINTS_DATA) == null &&
-				intent.getStringExtra(LocusConst.EXTRA_POINTS_CURSOR_URI) == null && 
-				intent.getStringExtra(LocusConst.EXTRA_POINTS_FILE_PATH) == null &&
-				intent.getParcelableExtra(LocusConst.EXTRA_TRACKS_SINGLE) == null &&
-				intent.getParcelableArrayListExtra(LocusConst.EXTRA_TRACKS_MULTI) == null);
-	}
-}
diff --git a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/LocusConst.java b/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/LocusConst.java
deleted file mode 100644
index 725097b..0000000
--- a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/LocusConst.java
+++ /dev/null
@@ -1,144 +0,0 @@
-/*  
- * Copyright 2011, Asamm Software, s.r.o.
- * 
- * This file is part of LocusAddonPublicLib.
- * 
- * LocusAddonPublicLib is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *  
- * LocusAddonPublicLib is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *  
- * You should have received a copy of the GNU General Public License
- * along with LocusAddonPublicLib.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package menion.android.locus.addon.publiclib;
-
-public class LocusConst {
-
-	/* 
-	 * these intent are used for extending functionality of Locus. All description is 
-	 * in 'LocusIntents' class 
-	 */
-	public static final String INTENT_GET_LOCATION = "menion.android.locus.GET_POINT";
-	public static final String INTENT_ON_POINT_ACTION = "menion.android.locus.ON_POINT_ACTION";
-
-	/**
-	 * This Filter add your activity into list of main functions
-	 */
-	public static final String INTENT_ITEM_MAIN_FUNCTION = "menion.android.locus.MAIN_FUNCTION";
-	/**
-	 * This Filter add your activity into list of search options in Locus "Search" function
-	 */
-	public static final String INTENT_ITEM_SEARCH_LIST = "menion.android.locus.SEARCH_LIST";
-	/**
-	 * This Filter add your activity into list of tools in Points screen
-	 */
-	public static final String INTENT_ITEM_POINTS_SCREEN_TOOLS = "menion.android.locus.POINTS_SCREEN_TOOLS";
-	
-	/**
-	 * Intent used for getting location from Locus to your application. This one, is used just to start
-	 * Locus with this request.
-	 * Available since Locus 1.15.4 (Pro 64, Free 126).
-	 */
-	public static final String ACTION_PICK_LOCATION = "android.intent.action.LOCUS_PICK_LOCATION";
-	
-	/**
-	 * Intent that allow to send WMS url link directly into Locus
-	 * Available since Locus 2.4.1 (code 216)
-	 */
-	public static final String ACTION_ADD_NEW_WMS_MAP = "android.intent.action.LOCUS_ADD_NEW_WMS_MAP";
-	public static final String EXTRA_ADD_NEW_WMS_MAP_URL = "wms_url";
-	
-	/**
-	 * Action used for receiving Location from Locus
-	 */
-	public static final String ACTION_RECEIVE_LOCATION = "android.intent.action.ON_LOCATION_RECEIVE";
-
-	/**
-	 * Basic intent used for display data. Use API for creating intent and not directly
-	 */
-	public static final String INTENT_DISPLAY_DATA = "android.intent.action.LOCUS_PUBLIC_LIB_DATA";
-//	public static final String INTENT_DISPLAY_DATA = "locus.api.android.ACTION_DISPLAY_DATA";
-
-	/* one PointData object, send over intent */
-	public static final String EXTRA_POINTS_DATA = "EXTRA_POINTS_DATA";
-	/* array of PointData objects, send over intent */
-	public static final String EXTRA_POINTS_DATA_ARRAY = "EXTRA_POINTS_DATA_ARRAY";
-	/* data stored in ContentProvider and send request as URI over intent */
-	public static final String EXTRA_POINTS_CURSOR_URI = "EXTRA_POINTS_CURSOR_URI";
-	/* sends points data serialized as byte[] through file stored on SD card */
-	public static final String EXTRA_POINTS_FILE_PATH = "EXTRA_POINTS_FILE_PATH";
-	
-	/**
-	 * Sends one single track to Locus
-	 * Available since Locus 1.15.4 (Pro 64, Free 126).
-	 */
-	public static final String EXTRA_TRACKS_SINGLE = "EXTRA_TRACKS_SINGLE";
-	
-	/**
-	 * Sends multiple tracks to Locus
-	 * Available since Locus 1.16.3 (Pro 69, Free 131).
-	 */
-	public static final String EXTRA_TRACKS_MULTI = "EXTRA_TRACKS_MULTI";
-	
-	/**
-	 * Extra parameter that set if data should be firstly imported. This is used in intent 
-	 * that sends also 
-	 */ 
-	public static final String EXTRA_CALL_IMPORT = "EXTRA_CALL_IMPORT";
-	
-	/**
-	 * If you set to any point "setExtraOnDisplay" callback, then when Locus display points and
-	 * ask for extended version, return result as Point object included in extra place in intent
-	 */
-	public static final String EXTRA_POINT = "EXTRA_POINT";
-	/** 
-	 * Optional boolean value in returning intent. Settings to true, Locus will overwrite point
-	 * in database. If you want to call "setExtraOnDisplay" next time, don't forget to set it
-	 * in updated waypoint!
-	 */
-	public static final String EXTRA_POINT_OVERWRITE = "EXTRA_POINT_OVERWRITE";
-	
-	/**********************************/
-	/*        BROADCAST PART          */
-	/**********************************/
-	
-	/**
-	 * Used for receiving locations from Locus
-	 */
-	public static final String ACTION_PERIODIC_UPDATE = "menion.android.locus.PERIODIC_UPDATE";
-
-	// content of PERIODIC UPDATE event (PERIDIC_UPDATE_EXTRA)
-	public static final String PUE_VISIBILITY_MAP_SCREEN = "visibility_map_screen";
-
-	public static final String PUE_LOCATION_MAP_CENTER = "location_map_center";
-	public static final String PUE_LOCATION_GPS = "location_gps";
-	
-	public static final String PUE_MAP_BOUNDING_BOX = "map_bounding_box";
-	public static final String PUE_MAP_ZOOM_LEVEL = "map_zoom_level";
-	
-	public static final String PUE_ACTIVITY_TRACK_RECORD_RECORDING = "activity_track_record_recording";
-	public static final String PUE_ACTIVITY_TRACK_RECORD_PAUSED = "activity_track_record_paused";
-	public static final String PUE_ACTIVITY_TRACK_RECORD_DISTANCE = "activity_track_record_distance";
-	public static final String PUE_ACTIVITY_TRACK_RECORD_TIME = "activity_track_record_time";
-	public static final String PUE_ACTIVITY_TRACK_RECORD_POINTS = "activity_track_record_points";
-	
-	/**
-	 * Used for sending data to Locus. These data should be small (and fast).
-	 * 
-	 * Content is same as with sending data by INTENT_DISPLAY_DATA anyway think mainly on best user
-	 * experience!! So suggestion is to send intent filled by EXTRA_POINTS_DATA or EXTRA_POINTS_DATA_ARRAY.
-	 * These are fastest methods and should be enough for sending useful amount of informations
-	 * 
-	 * Also, these data will have automatically EXTRA_CALL_IMPORT set to false, so they'll be directly
-	 * displayed on map without possibility for import! Also after display, map will not be centered.  
-	 */
-	public static final String ACTION_DISPLAY_DATA_SILENTLY = "android.intent.action.DISPLAY_DATA_SILENTLY";
-//	public static final String ACTION_DISPLAY_DATA_SILENTLY = "locus.api.android.ACTION_DISPLAY_DATA_SILENTLY";
-}
diff --git a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/LocusIntents.java b/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/LocusIntents.java
deleted file mode 100644
index ed9a27f..0000000
--- a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/LocusIntents.java
+++ /dev/null
@@ -1,408 +0,0 @@
-/*  
- * Copyright 2011, Asamm Software, s.r.o.
- * 
- * This file is part of LocusAddonPublicLib.
- * 
- * LocusAddonPublicLib is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *  
- * LocusAddonPublicLib is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *  
- * You should have received a copy of the GNU General Public License
- * along with LocusAddonPublicLib.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package menion.android.locus.addon.publiclib;
-
-import java.io.File;
-import java.io.InvalidObjectException;
-import java.util.ArrayList;
-
-import menion.android.locus.addon.publiclib.geoData.Point;
-import menion.android.locus.addon.publiclib.geoData.PointsData;
-import menion.android.locus.addon.publiclib.utils.RequiredVersionMissingException;
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.database.Cursor;
-import android.location.Location;
-import android.net.Uri;
-import android.text.TextUtils;
-
-public class LocusIntents {
-
-	private static final String TAG = "LocusIntents";
-	
-	/*
-	   Add POI from your application
- 	  -------------------------------
- 	   - on places where is location needed, you may add link to your application. So for example, when
- 	   you display Edit point dialog, you may see next to coordinates button "New". This is list of
- 	   location sources and also place when your application appear with this method
- 	   
- 	   1. register intent-filter for your activity
- 	   
-       	<intent-filter>
-          	<action android:name="menion.android.locus.GET_POINT" />
-          	<category android:name="android.intent.category.DEFAULT" />
-       	</intent-filter>
-       
-       2. register intent receiver in your application
-
-		if (getIntent().getAction().equals(LocusConst.INTENT_GET_POINT)) {
-   			// get some data here and finally return value back, more below
-		}
-	 */
-	
-	public static boolean isIntentGetLocation(Intent intent) {
-		return isRequiredAction(intent, LocusConst.INTENT_GET_LOCATION);
-	}
-	
-	public interface OnIntentGetLocation {
-		/**
-		 * Handle received request
-		 * @param locGps if GPS is enabled, location is included (may be null)
-		 * @param locMapCenter center location of displayed map (may be null)
-		 */
-		public void onReceived(Location locGps, Location locMapCenter);
-		/**
-		 * If intent is not INTENT_GET_LOCATION intent or other problem occur
-		 */
-		public void onFailed();
-	}
-	
-	public static void handleIntentGetLocation(Context context, Intent intent,
-			OnIntentGetLocation handler) 
-			throws NullPointerException {
-		// check source data
-		if (intent == null)
-			throw new NullPointerException("Intent cannot be null");
-		// check intent itself
-		if (!isIntentGetLocation(intent)) {
-			handler.onFailed();
-			return;
-		}
-
-		// variables that may be obtain from intent (since locus pro 68/ free 130)
-		if (LocusUtils.isLocusAvailable(context, 68, 130)) {
-			handler.onReceived(
-					(Location) intent.getParcelableExtra("locGps"),
-					(Location) intent.getParcelableExtra("locCenter"));
-		} else {
-			handler.onReceived(null, null);
-		}
-	}
-	
-	public static boolean sendGetLocationData(Activity activity, 
-			String name, double lat, double lon, double alt, double acc) {
-		if (lat == 0.0 && lon == 0.0) {
-			return false;
-		} else {
-			Intent intent = new Intent();
-			// string value name
-			intent.putExtra("name", name); // optional
-			// rest are all DOUBLE values (to avoid problems even when for acc and alt isn't double needed)
-			intent.putExtra("latitude", lat); // required, not 0.0
-			intent.putExtra("longitude", lon); // required, not 0.0
-			intent.putExtra("altitude", alt); // optional
-			intent.putExtra("accuracy", acc); // optional
-			activity.setResult(Activity.RESULT_OK, intent);
-			activity.finish();
-			return true;
-		}
-	}
-	
-	/*
-	   Add action under point sub-menu
- 	  -------------------------------
- 	   - when you tap on any point on map or in Point screen, under last bottom button, are functions for 
- 	   calling to some external application. Under this menu appear also your application. If you want specify
- 	   action only on your points displayed in Locus, use 'setExtraCallback' function on 'Point' object instead
- 	   of this. It has same functionality but allow displaying only on yours points.
- 	   
- 	   1. register intent-filter for your activity
- 	   
-		<intent-filter>
-      		<action android:name="menion.android.locus.ON_POINT_ACTION" />
-      		<category android:name="android.intent.category.DEFAULT" />
-   		</intent-filter>
-   		
-   		- extra possibility to act only on geocache point
-		<intent-filter>
-      		<action android:name="menion.android.locus.ON_POINT_ACTION" />
-      		<category android:name="android.intent.category.DEFAULT" />
-      		<data android:scheme="locus" />
-      		<data android:path="menion.android.locus/point_geocache" />
-		</intent-filter>
-       
-       2. register intent receiver in your application or use functions below
-
-		if (getIntent().getAction().equals(LocusConst.INTENT_ON_POINT_ACTION)) {
-   			double lat = getIntent().getDoubleExtra("latitude", 0.0);
-   			double lon = getIntent().getDoubleExtra("longitude", 0.0);
-   			double alt = getIntent().getDoubleExtra("altitude", 0.0);
-   			double acc = getIntent().getDoubleExtra("accuracy", 0.0);
-   
-   			// do what you want with this ...
-		}
-	 */
-	
-	public static boolean isIntentOnPointAction(Intent intent) {
-		return isRequiredAction(intent, LocusConst.INTENT_ON_POINT_ACTION);
-	}
-	
-	public static Point handleIntentOnPointAction(Intent intent) 
-			throws NullPointerException {
-		// check source data
-		if (intent == null)
-			throw new NullPointerException("Intent cannot be null");
-		// check intent itself
-		if (!isIntentOnPointAction(intent)) {
-			return null;
-		}
-		
-		// last version (Locus 1.15.0 and more)
-		if (intent.hasExtra("object")) {
-			return intent.getParcelableExtra("object");
-		}
-		// or use this in older version
-		else {
-			String name = intent.getStringExtra("name");
-			Location loc;
-			// in new version is already whole location as parcelable
-			if (intent.getParcelableExtra("loc") != null) {
-				loc = intent.getParcelableExtra("loc");
-			} else {
-				loc = new Location(TAG);
-				loc.setLatitude(intent.getDoubleExtra("latitude", 0.0));
-				loc.setLongitude(intent.getDoubleExtra("longitude", 0.0));
-				loc.setAltitude(intent.getDoubleExtra("altitude", 0.0));
-				loc.setAccuracy((float) intent.getDoubleExtra("accuracy", 0.0));
-			}
-
-			return new Point(name, loc);			
-		}
-	}
-	
-	/*
-	   Add action under main function menu
- 	  -------------------------------------
- 	   - when you display menu->functions, your application appear here. Also you application (activity) may
- 	    be added to right quick menu. Application will be called with current map center coordinates
- 	   
- 	   1. register intent-filter for your activity
- 	   
-		<intent-filter>
-      		<action android:name="menion.android.locus.MAIN_FUNCTION" />
-      		<category android:name="android.intent.category.DEFAULT" />
-   		</intent-filter>
-       
-       2. register intent receiver in your application
-
-		if (getIntent().getAction().equals(LocusConst.INTENT_MAIN_FUNCTION)) {
-   			// more below ...
-		}
-	 */
-
-	public static boolean isIntentMainFunction(Intent intent) {
-		return isIntentMenuItem(intent, LocusConst.INTENT_ITEM_MAIN_FUNCTION);
-	}
-	
-	public static void handleIntentMainFunction(Intent intent, OnIntentMainFunction handler) 
-			throws NullPointerException {
-		handleIntentMenuItem(intent, handler, LocusConst.INTENT_ITEM_MAIN_FUNCTION);
-	}
-	
-	public static boolean isIntentSearchList(Intent intent) {
-		return isIntentMenuItem(intent, LocusConst.INTENT_ITEM_SEARCH_LIST);
-	}
-	
-	public static void handleIntentSearchList(Intent intent, OnIntentMainFunction handler) 
-			throws NullPointerException {
-		handleIntentMenuItem(intent, handler, LocusConst.INTENT_ITEM_SEARCH_LIST);
-	}
-	
-	public static boolean isIntentPointsScreenTools(Intent intent) {
-		return isRequiredAction(intent, LocusConst.INTENT_ITEM_POINTS_SCREEN_TOOLS);
-	}
-	
-	public static ArrayList<PointsData> handleIntentPointsScreenTools(Intent intent) {
-		ArrayList<PointsData> data = null;
-		if (intent.hasExtra(LocusConst.EXTRA_POINTS_FILE_PATH)) {
-			String filepath = intent.getStringExtra(LocusConst.EXTRA_POINTS_FILE_PATH);
-			if (filepath != null && new File(filepath).exists()) {
-				// data stored in file, proceed
-				data = DisplayData.getDataFile(filepath);
-			}
-		}
-		return data;
-	}
-	
-	public static boolean isIntentMenuItem(Intent intent, String item) {
-		return isRequiredAction(intent, item);
-	}
-	
-	public static void handleIntentMenuItem(Intent intent, OnIntentMainFunction handler, String item) 
-			throws NullPointerException {
-		// check source data
-		if (intent == null)
-			throw new NullPointerException("Intent cannot be null");
-		if (handler == null)
-			throw new NullPointerException("Handler cannot be null");
-		// check intent itself
-		if (!isIntentMenuItem(intent, item)) {
-			handler.onFailed();
-			return;
-		}
-		
-		getLocationFromIntent(intent, handler);
-	}
-	
-	public interface OnIntentMainFunction {
-		/**
-		 * When intent really contain location, result is returned by this function
-		 * @param gpsEnabled true/false if GPS in Locus is enabled
-		 * @param locGps if gpsEnabled is true, variable contain location, otherwise null
-		 * @param locMapCenter contain current map center location
-		 */
-		public void onLocationReceived(boolean gpsEnabled, Location locGps, Location locMapCenter);
-		public void onFailed();
-	}
-	
-	public static void getLocationFromIntent(Intent intent, OnIntentMainFunction handler) {
-		boolean gpsEnabled = intent.getBooleanExtra("gpsEnabled", false);
-		handler.onLocationReceived(gpsEnabled,
-				gpsEnabled ? (Location)intent.getParcelableExtra("locGps") : null,
-				(Location) intent.getParcelableExtra("locCenter"));
-	}	
-	
-	/*
-	   Pick location from Locus
-	  -------------------------------
-	   - this feature can be used to obtain location from Locus, from same dialog (locus usually pick location). 
-	   Because GetLocation dialog, used in Locus need to have already initialized whole core of Locus, this dialog
-	   cannot be called directly, but needs to be started from Main map screen. This screen have anyway flag
-	   android:launchMode="singleTask", so there is no possibility to use startActivityForResult in this way.
-	   
-	   Be careful with this function, because Locus will after "pick location" action, call new intent with 
-	   ON_LOCATION_RECEIVE action, which will start your activity again without "singleTask" or similar flag
-	   
-	   Current functionality can be created by
-	   
-	   1. register intent-filter for your activity
-	   
-		<intent-filter>
-   			<action android:name="android.intent.action.ON_LOCATION_RECEIVE" />
-   			<category android:name="android.intent.category.DEFAULT" />
-		</intent-filter>
-    
-		2. register intent receiver in your application
-		
-		check sample application, where this functionality is implemented
-
-	 */
-	
-	public static boolean isIntentReceiveLocation(Intent intent) {
-		return isRequiredAction(intent, LocusConst.ACTION_RECEIVE_LOCATION);
-	}
-	
-	public static Point handleActionReceiveLocation(Intent intent) 
-			throws NullPointerException {
-		// check source data
-		if (intent == null)
-			throw new NullPointerException("Intent cannot be null");
-		// check intent itself
-		if (!isIntentReceiveLocation(intent)) {
-			return null;
-		}
-		
-		// last version (Locus 1.15.0 and more)
-		if (intent.hasExtra("location")) {
-			return intent.getParcelableExtra("location");
-		} else {
-			return null;
-		}
-	}
-	
-	/*
-	  Add own WMS map
-	  ------------------------------------
-	  - this feature allow 3rd party application, add web address directly to list of WMS services in
-	  Map Manager screen / WMS tab
-	 */
-	
-	public static void callAddNewWmsMap(Context context, String wmsUrl)
-			throws RequiredVersionMissingException, InvalidObjectException {
-		// check availability and start action
-		if (!LocusUtils.isLocusAvailable(context, 217)) {
-			throw new RequiredVersionMissingException(217);
-		}
-		if (TextUtils.isEmpty(wmsUrl)) {
-			throw new InvalidObjectException("WMS Url address \'" + wmsUrl + "\', is not valid!");
-		}
-		
-		Intent intent = new Intent(LocusConst.ACTION_ADD_NEW_WMS_MAP);
-		intent.putExtra(LocusConst.EXTRA_ADD_NEW_WMS_MAP_URL, wmsUrl);
-		context.startActivity(intent);
-	}
-	
-	/**********************************/
-	/*      SOME HANDY FUNCTIONS      */
-	/**********************************/
-	
-	private static boolean isRequiredAction(Intent intent, String action) {
-		return intent != null && intent.getAction() != null &&
-				intent.getAction().equals(action);
-	}
-	
-	public static void addPointToIntent(Intent intent, Point point) {
-		intent.putExtra(LocusConst.EXTRA_POINT, point);
-	}
-	
-	public static Intent prepareResultExtraOnDisplayIntent(Point p, boolean overridePoint) {
-		Intent intent = new Intent();
-		intent.putExtra(LocusConst.EXTRA_POINT, p);
-		intent.putExtra(LocusConst.EXTRA_POINT_OVERWRITE, overridePoint);
-		return intent;
-	}
-	
-	/**********************************/
-	/*         INFO FUNCTIONS         */
-	/**********************************/
-	
-	public static String getLocusRootDirectory(Context context) throws RequiredVersionMissingException {
-		Cursor cursor = null;
-		if (LocusUtils.isLocusFreeAvailable(context, 206))
-			cursor = context.getContentResolver().query(
-					Uri.parse("content://menion.android.locus.free.LocusInfoData"),
-					null, null, null, null);
-		else if (LocusUtils.isLocusProAvailable(context, 206))
-			cursor = context.getContentResolver().query(
-					Uri.parse("content://menion.android.locus.pro.LocusInfoData"),
-					null, null, null, null);
-		
-		if (cursor == null) {
-			throw new RequiredVersionMissingException(206);
-		}
-		
-		try {
-			for (int i = 0; i < cursor.getCount(); i++)  {
-				cursor.moveToPosition(i);
-				String key = cursor.getString(0);
-				String value = cursor.getString(1);
-				if (key.equals("rootDir"))
-					return value;
-			}
-		} catch (Exception e) {
-			e.printStackTrace();
-		} finally {
-			cursor.close();
-		}
-		return null;
-	}
-}
diff --git a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/LocusUtils.java b/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/LocusUtils.java
deleted file mode 100644
index eb2f909..0000000
--- a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/LocusUtils.java
+++ /dev/null
@@ -1,333 +0,0 @@
-/*  
- * Copyright 2011, Asamm Software, s.r.o.
- * 
- * This file is part of LocusAddonPublicLib.
- * 
- * LocusAddonPublicLib is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *  
- * LocusAddonPublicLib is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *  
- * You should have received a copy of the GNU General Public License
- * along with LocusAddonPublicLib.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package menion.android.locus.addon.publiclib;
-
-import java.io.File;
-
-import menion.android.locus.addon.publiclib.utils.Utils;
-
-import android.app.Activity;
-import android.content.ActivityNotFoundException;
-import android.content.Context;
-import android.content.Intent;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-import android.location.Location;
-import android.net.Uri;
-import android.os.Parcel;
-
-/**
- * Locus Helper class
- * 
- * @author Menion Asamm
- * @author Arcao
- * 
- */
-public class LocusUtils {
-
-//	private static final String TAG = "LocusUtils";
-	
-	/***********************************/
-	/*           CHECK PART            */
-	/***********************************/
-	
-	/** Locus Free package name */
-	public static final String LOCUS_FREE_PACKAGE_NAME = "menion.android.locus";
-	/** Locus Pro package name */
-	public static final String LOCUS_PRO_PACKAGE_NAME = "menion.android.locus.pro";
-	/** All Locus package names */
-	public static final String[] LOCUS_PACKAGE_NAMES = new String[] {
-			LOCUS_PRO_PACKAGE_NAME, LOCUS_FREE_PACKAGE_NAME };
-
-	/**
-	 * Returns <code>true</code> if Locus Pro or Locus Free is installed.
-	 * 
-	 * @param context
-	 *            actual {@link Context}
-	 * @return true or false
-	 */
-	public static boolean isLocusAvailable(Context context) {
-		return getLocusPackageInfo(context) != null;
-	}
-	
-	/**
-	 * Use for versions above 200 (So 2.0.0 and above). They have same ID now 
-	 * @param context
-	 * @param version
-	 * @return
-	 */
-	public static boolean isLocusAvailable(Context context, int version) {
-		return isLocusAvailable(context, version, version);
-	}
-	
-	public static boolean isLocusAvailable(Context context, int versionPro, int versionFree) {
-		if (isLocusFreeAvailable(context, versionFree))
-			return true;
-		if (isLocusProAvailable(context, versionPro))
-			return true;
-		return false;
-	}
-	
-	public static boolean isLocusProAvailable(Context context, int version) {
-		return isLocusAvailable(context, LOCUS_PRO_PACKAGE_NAME, version);
-	}
-
-	public static boolean isLocusFreeAvailable(Context context, int version) {
-		return isLocusAvailable(context, LOCUS_FREE_PACKAGE_NAME, version);
-	}
-	
-	public static boolean isLocusAvailable(Context context, String packageName, int version) {
-		return Utils.isAppAvailable(context, packageName, version);
-	}
-
-	/**
-	 * Returns {@link PackageInfo} with information about Locus or null if Locus
-	 * is not installed.
-	 * 
-	 * @param context
-	 *            actual {@link Context}
-	 * @return instance of PackageInfo object
-	 */
-	public static PackageInfo getLocusPackageInfo(Context context) {
-		PackageInfo info = null;
-		for (String p : LOCUS_PACKAGE_NAMES) {
-			try {
-				info = context.getPackageManager().getPackageInfo(p, 0);
-				break;
-			} catch (PackageManager.NameNotFoundException e) {
-			}
-		}
-
-		return info;
-	}
-
-	/**
-	 * Returns Locus version, e.g. <code>"1.9.5.1"</code>. If Locus is not
-	 * installed returns <code>null</code>.
-	 * 
-	 * @param context
-	 *            actual {@link Context}
-	 * @return version
-	 */
-	public static String getLocusVersion(Context context) {
-		PackageInfo info = getLocusPackageInfo(context);
-
-		if (info == null)
-			return null;
-
-		return info.versionName;
-	}
-
-	// use direct check isLocusAvailable()
-	@Deprecated
-	public static int getLocusVersionCode(Context context) {
-		PackageInfo info = getLocusPackageInfo(context);
-
-		if (info == null)
-			return -1;
-
-		return info.versionCode;
-	}
-
-	/**
-	 * Returns <code>true</code> if Locus Pro is installed.
-	 * 
-	 * @param context
-	 *            actual {@link Context}
-	 * @return true or false
-	 */
-	public static boolean isLocusProInstalled(Context context) {
-		try {
-			context.getPackageManager().getPackageInfo(LOCUS_PRO_PACKAGE_NAME, 0);
-			return true;
-		} catch (PackageManager.NameNotFoundException e) {
-			return false;
-		}
-	}
-
-	/**
-	 * Returns a package name of Locus (Pro). If Locus is not installed returns
-	 * null.
-	 * 
-	 * @param context
-	 *            actual {@link Context}
-	 * @return package name
-	 */
-	public static String getLocusPackageName(Context context) {
-		PackageInfo info = getLocusPackageInfo(context);
-		if (info == null)
-			return null;
-		return info.packageName;
-	}
-
-	/**
-	 * Returns a package name like {@link #getLocusPackageName(Context)} but if
-	 * Locus is not installed returns a default package name constant
-	 * {@link #LOCUS_FREE_PACKAGE_NAME}.
-	 * 
-	 * @param context
-	 *            actual {@link Context}
-	 * @return package name
-	 */
-	public static String getLocusDefaultPackageName(Context context) {
-		String name = getLocusPackageName(context);
-		if (name == null)
-			return LOCUS_FREE_PACKAGE_NAME;
-		return name;
-	}
-	
-	/***********************************/
-	/*        SHARE DATA PART          */
-	/***********************************/
-	
-	/**
-	 * Generic call to system for applications that can import your file.
-	 * @param context
-	 * @param file
-	 * @return
-	 */
-	public static boolean importFileSystem(Context context, File file) {
-		if (!isReadyForImport(context, file))
-			return false;
-		
-    	Intent sendIntent = new Intent(Intent.ACTION_VIEW);
-    	Uri uri = Uri.fromFile(file);
-    	sendIntent.setDataAndType(uri, getMimeType(file));
-    	context.startActivity(sendIntent);
-    	return true;
-	}
-
-	/**
-	 * Import GPX/KML files directly into Locus application. 
-	 * Return false if file don't exist or Locus is not installed
-	 * @param context
-	 * @param file
-	 */
-	public static boolean importFileLocus(Context context, File file) {
-		return importFileLocus(context, file, true);
-	}
-	
-	/**
-	 * Import GPX/KML files directly into Locus application. 
-	 * Return false if file don't exist or Locus is not installed
-	 * @param context
-	 * @param file
-     * @param callImport
-	 */
-	public static boolean importFileLocus(Context context, File file, boolean callImport) {
-		if (!isReadyForImport(context, file))
-			return false;
-		
-    	Intent sendIntent = new Intent(Intent.ACTION_VIEW);
-    	PackageInfo pi = getLocusPackageInfo(context);
-    	sendIntent.setClassName(pi.packageName, "menion.android.locus.core.MainActivity");
-    	Uri uri = Uri.fromFile(file);
-    	sendIntent.setDataAndType(uri, getMimeType(file));
-    	sendIntent.putExtra(LocusConst.EXTRA_CALL_IMPORT, callImport);
-    	context.startActivity(sendIntent);
-    	return true;
-	}
-	
-	private static boolean isReadyForImport(Context context, File file) {
-		if (file == null || !file.exists() || !isLocusAvailable(context))
-			return false;
-		return true;
-	}
-	
-	private static String getMimeType(File file) {
-		String name = file.getName();
-		int index = name.lastIndexOf(".");
-		if (index == -1)
-			return "*/*";
-		return "application/" + name.substring(index + 1);
-	}
-	
-	/***********************************/
-	/*          USEFUL TOOLS           */
-	/***********************************/
-	
-	/**
-	 * Allow to call activity for File pick. You can use Locus picker for this purpose, but
-	 * check if Locus version 202 and above are installed <b>isLocusAvailable(context, 202)</b>!
-	 * @param activity
-	 * @param id
-	 * @throws ActivityNotFoundException
-	 */
-	public static void intentPickFile(Activity activity, int requestCode) 
-			throws ActivityNotFoundException {
-		intentPick("org.openintents.action.PICK_FILE",
-				activity, requestCode, null, null);
-	}
-	
-	public static void intentPickFile(Activity activity, int requestCode, String title, String[] filter) 
-			throws ActivityNotFoundException {
-		intentPick("org.openintents.action.PICK_FILE",
-				activity, requestCode, title, filter);
-	}
-	
-	public static void intentPickDir(Activity activity, int requestCode) 
-			throws ActivityNotFoundException {
-		intentPick("org.openintents.action.PICK_DIRECTORY",
-				activity, requestCode, null, null);
-	}
-	
-	public static void intentPickDir(Activity activity, int requestCode, String title) 
-			throws ActivityNotFoundException {
-		intentPick("org.openintents.action.PICK_DIRECTORY",
-				activity, requestCode, title, null);
-	}
-	
-	private static void intentPick(String action, Activity activity, int requestCode, String title, String[] filter) {
-		Intent intent = new Intent(action);
-		if (title != null && title.length() > 0)
-			intent.putExtra("org.openintents.extra.TITLE", title);
-		if (filter != null && filter.length > 0)
-			intent.putExtra("org.openintents.extra.FILTER", filter);
-		activity.startActivityForResult(intent, requestCode);
-	}
-	
-	
-	/***********************************/
-	/*        PARCELABLE PART          */
-	/***********************************/
-	
-	public static void writeLocation(Parcel dest, Location loc) {
-		dest.writeString(loc.getProvider());
-		dest.writeLong(loc.getTime());
-		dest.writeDouble(loc.getLatitude());
-		dest.writeDouble(loc.getLongitude());
-		dest.writeDouble(loc.getAltitude());
-		dest.writeFloat(loc.getAccuracy());
-		dest.writeFloat(loc.getBearing());
-		dest.writeFloat(loc.getSpeed());
-	}
-	
-	public static Location readLocation(Parcel in) {
-		Location loc = new Location(in.readString());
-		loc.setTime(in.readLong());
-		loc.setLatitude(in.readDouble());
-		loc.setLongitude(in.readDouble());
-		loc.setAltitude(in.readDouble());
-		loc.setAccuracy(in.readFloat());
-		loc.setBearing(in.readFloat());
-		loc.setSpeed(in.readFloat());
-		return loc;
-	}
-}
diff --git a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/PeriodicUpdate.java b/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/PeriodicUpdate.java
deleted file mode 100644
index a0d8df3..0000000
--- a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/PeriodicUpdate.java
+++ /dev/null
@@ -1,180 +0,0 @@
-package menion.android.locus.addon.publiclib;
-
-import android.content.Context;
-import android.content.Intent;
-import android.location.Location;
-import android.os.Parcelable;
-
-public class PeriodicUpdate {
-
-	private Location mLastMapCenter;
-	private Location mLastGps;
-	private int mLastZoomLevel;
-	
-	private double mLocMinDistance;
-	
-	private static PeriodicUpdate mPU;
-	public static PeriodicUpdate getInstance() {
-		if (mPU == null) {
-			mPU = new PeriodicUpdate();
-		}
-		return mPU;
-	}
-	
-	private PeriodicUpdate() {
-		this.mLocMinDistance = 1.0;
-		this.mLastZoomLevel = -1;
-	}
-	
-	/**
-	 * Set notification limit used for check if distance between previous and
-	 * new location is higher than this value. So new locations is market as NEW 
-	 * @param minDistance distance in metres
-	 */
-	public void setLocNotificationLimit(double locMinDistance) {
-		this.mLocMinDistance = locMinDistance;
-	}
-	
-	public Location getLastMapCenter() {
-		return mLastMapCenter;
-	}
-	
-	public Location getLastGps() {
-		return mLastGps;
-	}
-	
-	public interface OnUpdate {
-		
-		public void onUpdate(UpdateContainer update);
-		
-		public void onIncorrectData();
-	}
-	
-	public class UpdateContainer {
-		
-		// is map currently visible
-		public boolean mapVisible = false;
-
-		// is new map center available
-		public boolean newMapCenter = false;
-		// is new GPS location available
-		public boolean newGps = false;
-		// is new zoom level on map
-		public boolean newZoomLevel;
-
-		// current map zoom level (zoom 8 == whole world (1 tile 256x256px))
-		public int mapZoomLevel;
-		// location of top-left map corner
-		public Location mapTopLeft = null;
-		// location of bottom-right map corner
-		public Location mapBottomRight = null;
-		
-		// is track recording enabled
-		public boolean trackRecRecording = false;
-		// if track rec is enabled, is running or paused
-		public boolean trackRecPaused = false;
-		// already recorded distance in metres
-		public double trackRecDist = 0.0;
-		// already recorded times in ms
-		public long trackRecTime = 0L;
-		// already recorded points
-		public int trackRecPoints = 0;
-		
-		@Override
-		public String toString() {
-			StringBuilder sb = new StringBuilder();
-			sb.append("UpdateContainer [");
-			sb.append("mapVisible:" + mapVisible).append(", ");
-			sb.append("newMapCenter:" + newMapCenter).append(", ");
-			sb.append("newGps:" + newGps).append(", ");
-			sb.append("newZoomLevel:" + newZoomLevel).append(", ");
-			sb.append("mapZoomLevel:" + mapZoomLevel).append(", ");
-			sb.append("mapTopLeft:" + (mapTopLeft != null)).append(", ");
-			sb.append("mapBottomRight:" + (mapBottomRight != null)).append(", ");
-			sb.append("trackRecRecording:" + trackRecRecording).append(", ");
-			sb.append("trackRecPaused:" + trackRecPaused).append(", ");
-			sb.append("trackRecDist:" + trackRecDist).append(", ");
-			sb.append("trackRecTime:" + trackRecTime).append(", ");
-			sb.append("trackRecPoints:" + trackRecPoints);
-			sb.append("]");
-			return sb.toString();
-		}
-	}
-	
-	public void onReceive(final Context context, Intent intent, OnUpdate handler) {
-		if (context == null || intent == null || handler == null)
-			throw new IllegalArgumentException("Incorrect arguments");
-		
-		if (!intent.getAction().equals(LocusConst.ACTION_PERIODIC_UPDATE)) {
-			handler.onIncorrectData();
-			return;
-		}
-		
-		// print content of object, for debug only
-//		Bundle extra = intent.getExtras();
-//		Iterator<String> keys = extra.keySet().iterator();
-//		while (keys.hasNext()) {
-//			String key = keys.next();
-//			Object object = extra.get(key);
-//			Log.w("INFO", "key:" + key + ", obj:" + object);	
-//		}
-
-		UpdateContainer update = new UpdateContainer();
-		
-		// check VISIBILITY
-		update.mapVisible = intent.getBooleanExtra(
-				LocusConst.PUE_VISIBILITY_MAP_SCREEN, false);
-		
-		// check LOCATIONS
-		update.newMapCenter = false;
-		if (intent.hasExtra(LocusConst.PUE_LOCATION_MAP_CENTER)) {
-			Location loc = intent.getParcelableExtra(LocusConst.PUE_LOCATION_MAP_CENTER);
-			if (mLastMapCenter == null ||
-					mLastMapCenter.distanceTo(loc) > mLocMinDistance) {
-				mLastMapCenter = loc;
-				update.newMapCenter = true;
-			} 
-		}
-
-		update.newGps = false;
-		if (intent.hasExtra(LocusConst.PUE_LOCATION_GPS)) {
-			Location loc = intent.getParcelableExtra(LocusConst.PUE_LOCATION_GPS);
-			if (mLastGps == null ||
-					mLastGps.distanceTo(loc) > mLocMinDistance) {
-				mLastGps = loc;
-				update.newGps = true;
-			} 
-		}
-		
-		// check MAP
-		update.mapZoomLevel = intent.getIntExtra(LocusConst.PUE_MAP_ZOOM_LEVEL, 0);
-		update.newZoomLevel = update.mapZoomLevel != mLastZoomLevel;
-		mLastZoomLevel = update.mapZoomLevel;
-
-		if (intent.hasExtra(LocusConst.PUE_MAP_BOUNDING_BOX)) {
-			// direct conversion not work, so use this hack
-			Parcelable[] locs = intent.getParcelableArrayExtra(
-					LocusConst.PUE_MAP_BOUNDING_BOX);
-			
-			if (locs != null && locs.length == 2) {
-				update.mapTopLeft = (Location) locs[0];
-				update.mapBottomRight = (Location) locs[1];
-			}
-		}
-		
-		// check TRACK RECORD
-		update.trackRecRecording = intent.getBooleanExtra(
-				LocusConst.PUE_ACTIVITY_TRACK_RECORD_RECORDING, false); 
-		update.trackRecPaused = intent.getBooleanExtra(
-				LocusConst.PUE_ACTIVITY_TRACK_RECORD_PAUSED, false);
-		update.trackRecDist = intent.getDoubleExtra(
-				LocusConst.PUE_ACTIVITY_TRACK_RECORD_DISTANCE, 0.0);
-		update.trackRecTime = intent.getLongExtra(
-				LocusConst.PUE_ACTIVITY_TRACK_RECORD_TIME, 0L);
-		update.trackRecPoints = intent.getIntExtra(
-				LocusConst.PUE_ACTIVITY_TRACK_RECORD_POINTS, 0);
-		
-		// send update back by handler
-		handler.onUpdate(update);
-	}
-}
diff --git a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/Point.java b/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/Point.java
deleted file mode 100644
index 11bf224..0000000
--- a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/Point.java
+++ /dev/null
@@ -1,230 +0,0 @@
-/*  
- * Copyright 2011, Asamm Software, s.r.o.
- * 
- * This file is part of LocusAddonPublicLib.
- * 
- * LocusAddonPublicLib is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *  
- * LocusAddonPublicLib is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *  
- * You should have received a copy of the GNU General Public License
- * along with LocusAddonPublicLib.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package menion.android.locus.addon.publiclib.geoData;
-
-import menion.android.locus.addon.publiclib.LocusUtils;
-import android.location.Location;
-import android.os.Parcel;
-import android.os.Parcelable;
-
-public class Point implements Parcelable {
-	
-	private static final int VERSION = 1;
-	
-	/* I cannot simply change version to 2, because this will completely destroy
-	 * compatibility with add-ons that use this lib, damn! */
-//	/* point unique ID */
-//	private long mId; 
-	/* mName of object */
-	private String mName;
-	/* mDesc of object */
-	private String mDesc;
-	/* mLoc of this point */
-	private Location mLoc;
-	/* extra intent data */
-	private String mExtraCallback;
-	/* extra data used when point is displayed */
-	private String mExtraOnDisplay;
-	/* additional geoCaching data */
-	private PointGeocachingData mGeoCachingData;
-	
-	public Point(String name, Location loc) {
-//		this(0L, name, loc);
-//	}
-//	
-//	public Point(long id, String name, Location loc) {
-//		this.mId = id;
-		this.mName = name;
-		this.mDesc = null;
-		this.mLoc = loc;
-		this.mExtraCallback = null;
-		this.mExtraOnDisplay = null;
-		this.mGeoCachingData = null;
-	}
-
-//	public long getId() {
-//		return mId;
-//	}
-	
-	public String getName() {
-		return mName;
-	}
-
-	public void setName(String name) {
-		if (name != null && name.length() > 0)
-			this.mName = name;
-	}
-	
-	public String getDescription() {
-		return mDesc;
-	}
-	
-	public void setDescription(String desc) {
-		if (desc != null && desc.length() > 0)
-			this.mDesc = desc;
-	}
-	
-	public Location getLocation() {
-		return mLoc;
-	}
-	
-	public String getExtraCallback() {
-		return mExtraCallback;
-	}
-	
-	public String getExtraOnDisplay() {
-		return mExtraOnDisplay;
-	}
-	
-	/**
-	 * Simply allow set callback value on point. This appear when you click on point
-	 * and then under last button will be your button. Clicking on it, launch by you,
-	 * defined intent
-	 * <br /><br />
-	 * Do not forget to set this http://developer.android.com/guide/topics/manifest/activity-element.html#exported
-	 * to your activity, if you'll set callback to other then launcher activity
-	 * @param btnName Name displayed on button
-	 * @param packageName this value is used for creating intent that
-	 *  will be called in callback (for example com.super.application)
-	 * @param className the name of the class inside of com.super.application
-	 *  that implements the component (for example com.super.application.Main)
-	 * @param returnDataName String under which data will be stored. Can be
-	 *  retrieved by String data = getIntent.getStringExtra("returnData");
-	 * @param returnDataValue String under which data will be stored. Can be
-	 *  retrieved by String data = getIntent.getStringExtra("returnData");
-	 */
-	public void setExtraCallback(String btnName, String packageName, String className,
-			String returnDataName, String returnDataValue) {
-		StringBuffer buff = new StringBuffer();
-		buff.append("intent").append(";");
-		buff.append(btnName).append(";");
-		buff.append(packageName).append(";");
-		buff.append(className).append(";");
-		buff.append(returnDataName).append(";");
-		buff.append(returnDataValue).append(";");
-		this.mExtraCallback = buff.toString();
-	}
-	
-	/**********************************/
-	/*      EXTRA_ON_DISPLAY PART     */
-	/**********************************/
-	
-	/**
-	 * Extra feature that allow to send to locus only partial point data. When you click on
-	 * point (in time when small point dialog should appear), locus send intent to your app,
-	 * you can then fill complete point and send it back to Locus. Clear and clever
-	 * <br /><br />
-	 * Do not forget to set this http://developer.android.com/guide/topics/manifest/activity-element.html#exported
-	 * to your activity, if you'll set callback to other then launcher activity
-	 * 
-	 * @param btnName Name displayed on button
-	 * @param packageName this value is used for creating intent that
-	 *  will be called in callback (for example com.super.application)
-	 * @param className the name of the class inside of com.super.application
-	 *  that implements the component (for example com.super.application.Main)
-	 * @param returnDataName String under which data will be stored. Can be
-	 *  retrieved by String data = getIntent.getStringExtra("returnData");
-	 * @param returnDataValue String under which data will be stored. Can be
-	 *  retrieved by String data = getIntent.getStringExtra("returnData");
-	 */
-	public void setExtraOnDisplay(String packageName, String className,
-			String returnDataName, String returnDataValue) {
-		StringBuffer buff = new StringBuffer();
-		buff.append("intent").append(";");
-		buff.append(packageName).append(";");
-		buff.append(className).append(";");
-		buff.append(returnDataName).append(";");
-		buff.append(returnDataValue).append(";");
-		this.mExtraOnDisplay = buff.toString();
-	}
-	
-	public PointGeocachingData getGeocachingData() {
-		return mGeoCachingData;
-	}
-	
-	public void setGeocachingData(PointGeocachingData gcData) {
-		this.mGeoCachingData = gcData;
-	}
-	
-	/****************************/
-	/*      PARCELABLE PART     */
-	/****************************/
-	
-    public static final Parcelable.Creator<Point> CREATOR = new Parcelable.Creator<Point>() {
-        public Point createFromParcel(Parcel in) {
-            return new Point(in);
-        }
-
-        public Point[] newArray(int size) {
-            return new Point[size];
-        }
-    };
-    
-    private Point(Parcel in) {
-    	int version = in.readInt();
-//    	// load id
-//    	mId = 0L;
-//    	if (version == 2)
-//    		mId = in.readLong();
-		// load name
-		mName = in.readString();
-		// load description
-		mDesc = in.readString();
-		// load separate location
-		mLoc = LocusUtils.readLocation(in);
-    	
-    	switch (version) {
-    	case 0:
-    		// load extra data
-    		mExtraCallback = in.readString();
-			break;
-    	case 1:
-    		// load extra data
-    		mExtraCallback = in.readString();
-    		mExtraOnDisplay = in.readString();
-    		break;
-    	}
-		// load geocaching data
-		mGeoCachingData = in.readParcelable(PointGeocachingData.class.getClassLoader());//PointGeocachingData.CREATOR.createFromParcel(in);
-    }
-    
-	@Override
-	public int describeContents() {
-		return 0;
-	}
-
-	@Override
-	public void writeToParcel(Parcel dest, int flags) {
-		dest.writeInt(VERSION);
-//		// write ID
-//		dest.writeLong(mId);
-		// write name
-		dest.writeString(mName);
-		// write description
-		dest.writeString(mDesc);
-		// write location as separate values (due to some problems with 'magic number')
-		LocusUtils.writeLocation(dest, mLoc);
-		// write extra
-		dest.writeString(mExtraCallback);
-		dest.writeString(mExtraOnDisplay);
-		// write geocaching data
-		dest.writeParcelable(mGeoCachingData, flags);
-	}
-}
diff --git a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/PointGeocachingAttributes.java b/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/PointGeocachingAttributes.java
deleted file mode 100644
index 726da1a..0000000
--- a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/PointGeocachingAttributes.java
+++ /dev/null
@@ -1,174 +0,0 @@
-/*  
- * Copyright 2011, Asamm Software, s.r.o.
- * 
- * This file is part of LocusAddonPublicLib.
- * 
- * LocusAddonPublicLib is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *  
- * LocusAddonPublicLib is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *  
- * You should have received a copy of the GNU General Public License
- * along with LocusAddonPublicLib.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package menion.android.locus.addon.publiclib.geoData;
-
-import java.util.Hashtable;
-
-import android.os.Parcel;
-import android.os.Parcelable;
-
-/**
- * Class for holding geocaching attributes
- * <br /><br />
- * Every instance holds just one attribute, defined by it's unique ID number. If
- * you want to set correct value, use constructor that allow set directly by number
- * or by attribute URL
- * <br /><br />
- * @author menion
- */
-public class PointGeocachingAttributes implements Parcelable {
-
-	private static final int VERSION = 0;
-	
-	private int id;
-
-	public PointGeocachingAttributes(int id, boolean possitive) {
-		if (!possitive) {
-			this.id = id;
-		} else {
-			this.id = (id + 100);
-		}
-	}
-	
-	public PointGeocachingAttributes(String url) {
-		if (url != null && url.length() > 0) {
-			id = attrIds.get(url.substring(0, url.lastIndexOf("-")));
-			if (url.contains("-yes."))
-				id += 100;
-		}
-	}
-	
-	public int getId() {
-		return id;
-	}
-	
-	/**
-	 * Force some ID number to this attribute. Use only if you know what you're doing.
-	 * This feature is mainly used directly in Locus to fill data
-	 * 
-	 * @param id number, already increased by 100 if it's possitive attribute
-	 */
-	public void setId(int id) {
-		this.id = id;
-	}
-	
-	private static Hashtable<String, Integer> attrIds = new Hashtable<String, Integer>();
-	static {
-		attrIds.put("http://www.geocaching.com/images/attributes/dogs", 1);
-		attrIds.put("http://www.geocaching.com/images/attributes/fee", 2);
-		attrIds.put("http://www.geocaching.com/images/attributes/rappelling", 3);
-		attrIds.put("http://www.geocaching.com/images/attributes/boat", 4);
-		attrIds.put("http://www.geocaching.com/images/attributes/scuba", 5);
-		attrIds.put("http://www.geocaching.com/images/attributes/kids", 6);
-		attrIds.put("http://www.geocaching.com/images/attributes/onehour", 7);
-		attrIds.put("http://www.geocaching.com/images/attributes/scenic", 8);
-		attrIds.put("http://www.geocaching.com/images/attributes/hiking", 9);
-		attrIds.put("http://www.geocaching.com/images/attributes/climbing", 10);
-		attrIds.put("http://www.geocaching.com/images/attributes/wading", 11);
-		attrIds.put("http://www.geocaching.com/images/attributes/swimming", 12);
-		attrIds.put("http://www.geocaching.com/images/attributes/available", 13);
-		attrIds.put("http://www.geocaching.com/images/attributes/night", 14);
-		attrIds.put("http://www.geocaching.com/images/attributes/winter", 15);
-		attrIds.put("http://www.geocaching.com/images/attributes/camping", 16);
-		attrIds.put("http://www.geocaching.com/images/attributes/poisonoak", 17);
-		attrIds.put("http://www.geocaching.com/images/attributes/snakes", 18);
-		attrIds.put("http://www.geocaching.com/images/attributes/ticks", 19);
-		attrIds.put("http://www.geocaching.com/images/attributes/mine", 20);
-		attrIds.put("http://www.geocaching.com/images/attributes/cliff", 21);
-		attrIds.put("http://www.geocaching.com/images/attributes/hunting", 22);
-		attrIds.put("http://www.geocaching.com/images/attributes/danger", 23);
-		attrIds.put("http://www.geocaching.com/images/attributes/wheelchair", 24);
-		attrIds.put("http://www.geocaching.com/images/attributes/parking", 25);
-		attrIds.put("http://www.geocaching.com/images/attributes/public", 26);
-		attrIds.put("http://www.geocaching.com/images/attributes/water", 27);
-		attrIds.put("http://www.geocaching.com/images/attributes/restrooms", 28);
-		attrIds.put("http://www.geocaching.com/images/attributes/phone", 29);
-		attrIds.put("http://www.geocaching.com/images/attributes/picnic", 30);
-		attrIds.put("http://www.geocaching.com/images/attributes/camping", 31);
-		attrIds.put("http://www.geocaching.com/images/attributes/bicycles", 32);
-		attrIds.put("http://www.geocaching.com/images/attributes/motorcycles", 33);
-		attrIds.put("http://www.geocaching.com/images/attributes/quads", 34);
-		attrIds.put("http://www.geocaching.com/images/attributes/jeeps", 35);
-		attrIds.put("http://www.geocaching.com/images/attributes/snowmobiles", 36);
-		attrIds.put("http://www.geocaching.com/images/attributes/horses", 37);
-		attrIds.put("http://www.geocaching.com/images/attributes/campfires", 38);
-		attrIds.put("http://www.geocaching.com/images/attributes/thorn",39 );
-		attrIds.put("http://www.geocaching.com/images/attributes/stealth", 40); 
-		attrIds.put("http://www.geocaching.com/images/attributes/stroller", 41);
-		attrIds.put("http://www.geocaching.com/images/attributes/firstaid", 42);
-		attrIds.put("http://www.geocaching.com/images/attributes/cow", 43);
-		attrIds.put("http://www.geocaching.com/images/attributes/flashlight", 44);
-		attrIds.put("http://www.geocaching.com/images/attributes/landf", 45);
-		attrIds.put("http://www.geocaching.com/images/attributes/rv", 46);
-		attrIds.put("http://www.geocaching.com/images/attributes/field_puzzle", 47);
-		attrIds.put("http://www.geocaching.com/images/attributes/UV", 48);
-		attrIds.put("http://www.geocaching.com/images/attributes/snowshoes", 49);
-		attrIds.put("http://www.geocaching.com/images/attributes/skiis", 50);
-		attrIds.put("http://www.geocaching.com/images/attributes/s-tool", 51);
-		attrIds.put("http://www.geocaching.com/images/attributes/nightcache", 52);
-		attrIds.put("http://www.geocaching.com/images/attributes/parkngrab", 53);
-		attrIds.put("http://www.geocaching.com/images/attributes/AbandonedBuilding", 54);
-		attrIds.put("http://www.geocaching.com/images/attributes/hike_short", 55);
-		attrIds.put("http://www.geocaching.com/images/attributes/hike_med", 56);
-		attrIds.put("http://www.geocaching.com/images/attributes/hike_long", 57);
-		attrIds.put("http://www.geocaching.com/images/attributes/fuel", 58);
-		attrIds.put("http://www.geocaching.com/images/attributes/food", 59);
-		attrIds.put("http://www.geocaching.com/images/attributes/wirelessbeacon", 60);
-		attrIds.put("http://www.geocaching.com/images/attributes/partnership", 61);
-		attrIds.put("http://www.geocaching.com/images/attributes/seasonal", 62);
-		attrIds.put("http://www.geocaching.com/images/attributes/touristOK", 63);
-		attrIds.put("http://www.geocaching.com/images/attributes/treeclimbing", 64);
-		attrIds.put("http://www.geocaching.com/images/attributes/frontyard", 65);
-		attrIds.put("http://www.geocaching.com/images/attributes/teamwork", 66);
-	}
-	
-	/****************************/
-	/*      PARCELABLE PART     */
-	/****************************/
-	
-    public static final Parcelable.Creator<PointGeocachingAttributes> CREATOR = new Parcelable.Creator<PointGeocachingAttributes>() {
-        public PointGeocachingAttributes createFromParcel(Parcel in) {
-            return new PointGeocachingAttributes(in);
-        }
-
-        public PointGeocachingAttributes[] newArray(int size) {
-            return new PointGeocachingAttributes[size];
-        }
-    };
-    
-    public PointGeocachingAttributes(Parcel in) {
-    	switch (in.readInt()) {
-    	case 0:
-    		id = in.readInt();
-    		break;
-    	}
-    }
-    
-	@Override
-	public void writeToParcel(Parcel dest, int flags) {
-		dest.writeInt(VERSION);
-		dest.writeInt(id);
-	}
-	
-	@Override
-	public int describeContents() {
-		return 0;
-	}
-}
diff --git a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/PointGeocachingData.java b/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/PointGeocachingData.java
deleted file mode 100644
index 628e808..0000000
--- a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/PointGeocachingData.java
+++ /dev/null
@@ -1,353 +0,0 @@
-/*  
- * Copyright 2011, Asamm Software, s.r.o.
- * 
- * This file is part of LocusAddonPublicLib.
- * 
- * LocusAddonPublicLib is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *  
- * LocusAddonPublicLib is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *  
- * You should have received a copy of the GNU General Public License
- * along with LocusAddonPublicLib.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package menion.android.locus.addon.publiclib.geoData;
-
-import android.os.Parcel;
-import android.os.Parcelable;
-import android.util.Log;
-
-import java.io.ByteArrayInputStream;
-import java.io.ByteArrayOutputStream;
-import java.io.InputStreamReader;
-import java.util.ArrayList;
-import java.util.zip.GZIPInputStream;
-import java.util.zip.GZIPOutputStream;
-
-public class PointGeocachingData implements Parcelable {
-	
-	private static final int VERSION = 2;
-	
-	public static final int CACHE_TYPE_TRADITIONAL = 0;
-	public static final int CACHE_TYPE_MULTI = 1;
-	public static final int CACHE_TYPE_MYSTERY = 2;
-	public static final int CACHE_TYPE_VIRTUAL = 3;
-	public static final int CACHE_TYPE_EARTH = 4;
-	public static final int CACHE_TYPE_PROJECT_APE = 5;
-	public static final int CACHE_TYPE_LETTERBOX = 6;
-	public static final int CACHE_TYPE_WHERIGO = 7;
-	public static final int CACHE_TYPE_EVENT = 8;
-	public static final int CACHE_TYPE_MEGA_EVENT = 9;
-	public static final int CACHE_TYPE_CACHE_IN_TRASH_OUT = 10;
-	public static final int CACHE_TYPE_GPS_ADVENTURE = 11;
-	public static final int CACHE_TYPE_WEBCAM = 12;
-	public static final int CACHE_TYPE_LOCATIONLESS = 13;
-	public static final int CACHE_TYPE_BENCHMARK = 14;
-	public static final int CACHE_TYPE_MAZE_EXHIBIT = 15;
-	public static final int CACHE_TYPE_WAYMARK = 16;
-	public static final int CACHE_TYPE_GROUNDSPEAK = 17;
-	public static final int CACHE_TYPE_LF_EVENT = 18;
-	public static final int CACHE_TYPE_LF_CELEBRATION = 19;
-	public static final int CACHE_TYPE_GIGA_EVENT = 20;
-	public static final int CACHE_TYPE_ADVENTURE_LAB = 21;
-	public static final int CACHE_TYPE_GC_HQ_BLOCK_PARTY = 22;
-
-	public static final int CACHE_LOG_TYPE_UNKNOWN = -1;
-	public static final int CACHE_LOG_TYPE_FOUNDED = 0;
-	public static final int CACHE_LOG_TYPE_NOT_FOUNDED = 1;
-	public static final int CACHE_LOG_TYPE_WRITE_NOTE = 2;
-	public static final int CACHE_LOG_TYPE_NEEDS_MAINTENANCE = 3;
-	public static final int CACHE_LOG_TYPE_OWNER_MAINTENANCE = 4;
-	public static final int CACHE_LOG_TYPE_PUBLISH_LISTING = 5;
-	public static final int CACHE_LOG_TYPE_ENABLE_LISTING = 6;
-	public static final int CACHE_LOG_TYPE_TEMPORARILY_DISABLE_LISTING = 7;
-	public static final int CACHE_LOG_TYPE_UPDATE_COORDINATES = 8;
-	public static final int CACHE_LOG_TYPE_ANNOUNCEMENT = 9;
-	public static final int CACHE_LOG_TYPE_WILL_ATTEND = 10;
-	public static final int CACHE_LOG_TYPE_ATTENDED = 11;
-	public static final int CACHE_LOG_TYPE_POST_REVIEWER_NOTE = 12;
-	public static final int CACHE_LOG_TYPE_NEEDS_ARCHIVED = 13;
-	public static final int CACHE_LOG_TYPE_WEBCAM_PHOTO_TAKEN = 14;
-	public static final int CACHE_LOG_TYPE_RETRACT_LISTING = 15;
-	
-	public static final int CACHE_SIZE_NOT_CHOSEN = 0;
-	public static final int CACHE_SIZE_MICRO = 1;
-	public static final int CACHE_SIZE_SMALL = 2;
-	public static final int CACHE_SIZE_REGULAR = 3;
-	public static final int CACHE_SIZE_LARGE = 4;
-	public static final int CACHE_SIZE_HUGE = 5;
-	public static final int CACHE_SIZE_OTHER = 6;
-	
-	public static final String CACHE_WAYPOINT_TYPE_QUESTION = "Question to Answer";
-	public static final String CACHE_WAYPOINT_TYPE_FINAL = "Final Location";
-	public static final String CACHE_WAYPOINT_TYPE_PARKING = "Parking Area";
-	public static final String CACHE_WAYPOINT_TYPE_TRAILHEAD = "Trailhead";
-	public static final String CACHE_WAYPOINT_TYPE_STAGES = "Stages of a Multicache";
-	public static final String CACHE_WAYPOINT_TYPE_REFERENCE = "Reference Point";
-	public static final String CACHE_WAYPOINT_TYPE_VIRTUAL_STAGE = "Virtual Stage";
-	public static final String CACHE_WAYPOINT_TYPE_PHYSICAL_STAGE = "Physical Stage";
-	/*
-	 * INFO
-	 * 
-	 * all times are in format '2009-09-22T14:16:03.0000000+0200', where important is only first 
-	 * part (Date), so it should looks for example only as '2009-09-22T'. This should work
-	 */
-	
-	/* id of point - not needed as I remember */
-	public int id;
-	/* whole cache ID from gc.com - so GC... - !REQUIRED! */
-	public String cacheID;
-	/* is available or disable */
-	public boolean available;
-	/* cache already archived or not */
-	public boolean archived;
-	/* available only for premium members */
-	public boolean premiumOnly;
-	/* name of cache - !REQUIRED! */
-	public String name;
-	/* String with date of last update - groundspeak:lastUpdated*/
-	public String lastUpdated;
-	/* String with date of last exported - groundspeak:exported */
-	public String exported;
-	/**
-	 * name of person who placed cache (groundspeak:placed_by)
-	 * <br /><br />
-	 * - displayed in Locus when tapped on point or in main GC page
-	 */
-	public String placedBy;
-	/**
-	 * name of cache owner (groundspeak:owner)
-	 * <br /><br />
-	 * - this value is not displayed in locus
-	 */
-	public String owner;
-	/* String with date of hidden - value from CachePrinter */
-	public String hidden;
-	/* cache type */
-	public int type;
-	/* container size */
-	public int container;
-	/* dificulty value - 1.0 - 5.0 (by 0.5) */
-	public float difficulty;
-	/* terrain value - 1.0 - 5.0 (by 0.5) */ 
-	public float terrain;
-	/* country name */
-	public String country;
-	/* state name */
-	public String state;
-	/* short description of cache */
-	public String shortDescription;
-	/* full description with complete (HTML) listing */
-	public String longDescription;
-	/* encoded hints */
-	public String encodedHints;
-	/* list of attributes */
-	public ArrayList<PointGeocachingAttributes> attributes;
-	/* list of logs */
-	public ArrayList<PointGeocachingDataLog> logs;
-	/* list of travel bugs */
-	public ArrayList<PointGeocachingDataTravelBug> travelBugs;
-	/* list of waypoints */
-	public ArrayList<PointGeocachingDataWaypoint> waypoints;
-	/* user notes */
-	public String notes;
-	/* if cache is already computed - have final waypoint and is placed on it's location */
-	public boolean computed;
-	/* if cache is already found */
-	public boolean found;
-	
-	public PointGeocachingData() {
-		id = 0;
-		cacheID = "";
-		available = true;
-		archived = false;
-		premiumOnly = false;
-		name = "";
-		lastUpdated = "";
-		exported = "";
-		placedBy = "";
-		owner = "";
-		hidden = "";
-		type = CACHE_TYPE_TRADITIONAL;
-		container = CACHE_SIZE_NOT_CHOSEN;
-		difficulty = -1.0f;
-		terrain = -1.0f;
-		country = "";
-		state = "";
-		shortDescription = "";
-		longDescription = "";
-		encodedHints = "";
-		attributes = new ArrayList<PointGeocachingAttributes>();
-		logs = new ArrayList<PointGeocachingDataLog>();
-		travelBugs = new ArrayList<PointGeocachingDataTravelBug>();
-		waypoints = new ArrayList<PointGeocachingDataWaypoint>();
-		notes = "";
-		computed = false;
-		found = false;
-	}
-	
-	/****************************/
-	/*      PARCELABLE PART     */
-	/****************************/
-	
-    public static final Parcelable.Creator<PointGeocachingData> CREATOR = new Parcelable.Creator<PointGeocachingData>() {
-        public PointGeocachingData createFromParcel(Parcel in) {
-            return new PointGeocachingData(in);
-        }
-
-        public PointGeocachingData[] newArray(int size) {
-            return new PointGeocachingData[size];
-        }
-    };
-    
-    @SuppressWarnings("unchecked")
-	public PointGeocachingData(Parcel in) {
-    	int version = in.readInt();
-    	if (version == 0) {
-    		 id = in.readInt();
-    		 cacheID = in.readString();
-    		 available = in.readInt() == 1;
-    		 archived = in.readInt() == 1;
-    		 premiumOnly = in.readInt() == 1;
-    		 name = in.readString();
-    		 lastUpdated = in.readString();
-    		 exported = in.readString();
-    		 placedBy = in.readString();
-    		 owner = in.readString();
-    		 hidden = in.readString();
-    		 type = in.readInt();
-    		 container = in.readInt();
-    		 difficulty = in.readFloat();
-    		 terrain = in.readFloat();
-    		 country = in.readString();
-    		 state = in.readString();
-    		 shortDescription = in.readString();
-    		 longDescription = in.readString();
-    		 encodedHints = in.readString();
-    		 attributes = in.readArrayList(PointGeocachingAttributes.class.getClassLoader());
-    		 logs = in.readArrayList(PointGeocachingDataLog.class.getClassLoader());
-    		 travelBugs = in.readArrayList(PointGeocachingDataTravelBug.class.getClassLoader());
-    		 waypoints = in.readArrayList(PointGeocachingDataWaypoint.class.getClassLoader());
-    		 notes = in.readString();
-    		 computed = in.readInt() == 1;
-    	} else if (version > 0) {
-    		id = in.readInt();
-   		 	cacheID = in.readString();
-   		 	available = in.readInt() == 1;
-   		 	archived = in.readInt() == 1;
-   		 	premiumOnly = in.readInt() == 1;
-   		 	name = in.readString();
-   		 	lastUpdated = in.readString();
-   		 	exported = in.readString();
-   		 	placedBy = in.readString();
-   		 	owner = in.readString();
-   		 	hidden = in.readString();
-   		 	type = in.readInt();
-   		 	container = in.readInt();
-   		 	difficulty = in.readFloat();
-   		 	terrain = in.readFloat();
-   		 	country = in.readString();
-   		 	state = in.readString();
-   		 	try {
-   		 		int size = in.readInt();
-   		 		int lengthSD = in.readInt();
-   		 		
-   		 		byte[] data = new byte[size];
-   		 		in.readByteArray(data);
-
-   		 		GZIPInputStream zis = new GZIPInputStream(new ByteArrayInputStream(data), 10240);
-   		 		StringBuffer buffer = new StringBuffer();
-   		 		
-   		 		InputStreamReader isr = new InputStreamReader(zis, "UTF-8");
-   		 		char[] dataD = new char[1024];
-   		 		int charsRead;
-   		 		while ((charsRead = isr.read(dataD)) != -1) {
-   		 			buffer.append(dataD, 0, charsRead);
-   		 		}
-   		 		String result = buffer.toString();
-   		 		isr.close();
-   		 		
-   		 		// read short description
-   		 		if (lengthSD > 0) {
-   		 			shortDescription = result.substring(0, lengthSD);
-   		 		} else {
-   		 			shortDescription = "";
-   		 		}
-   		 		
-   		 		// read long description
-		 		longDescription = result.substring(lengthSD);
-   		 	} catch (Exception e) {
-   		 		Log.e("PointGeocachingData", "Problem in ZIP compression - read", e);
-   		 	}
-   		 	encodedHints = in.readString();
-   		 	attributes = in.readArrayList(PointGeocachingAttributes.class.getClassLoader());
-   		 	logs = in.readArrayList(PointGeocachingDataLog.class.getClassLoader());
-   		 	travelBugs = in.readArrayList(PointGeocachingDataTravelBug.class.getClassLoader());
-   		 	waypoints = in.readArrayList(PointGeocachingDataWaypoint.class.getClassLoader());
-   		 	notes = in.readString();
-   		 	computed = in.readInt() == 1;
-   		 	if (version == 2) {
-   		 		found = in.readInt() == 1;
-   		 	}
-    	}
-    }
-
-	@Override
-	public void writeToParcel(Parcel dest, int flags) {
-		dest.writeInt(VERSION);
-		dest.writeInt(id);
-		dest.writeString(cacheID);
-		dest.writeInt(available ? 1 : 0);
-		dest.writeInt(archived ? 1 : 0);
-		dest.writeInt(premiumOnly ? 1 : 0);
-		dest.writeString(name);
-		dest.writeString(lastUpdated);
-		dest.writeString(exported);
-		dest.writeString(placedBy);
-		dest.writeString(owner);
-		dest.writeString(hidden);
-		dest.writeInt(type);
-		dest.writeInt(container);
-		dest.writeFloat(difficulty);
-		dest.writeFloat(terrain);
-		dest.writeString(country);
-		dest.writeString(state);
-		try {
-			ByteArrayOutputStream baos = new ByteArrayOutputStream();
-			GZIPOutputStream zos = new GZIPOutputStream(baos);
-			
-			zos.write(shortDescription.getBytes("utf-8"));
-			zos.write(longDescription.getBytes("utf-8"));
-			zos.close();
-			
-			byte[] data = baos.toByteArray();
-			baos.close();
-			
-			dest.writeInt(data.length);
-			dest.writeInt(shortDescription.length());
-			dest.writeByteArray(data);
-		} catch (Exception e) {
-			Log.e("PointGeocachingData", "Problem in ZIP compression - write", e);
-		}
-
-		dest.writeString(encodedHints);
-		dest.writeList(attributes);
-		dest.writeList(logs);
-		dest.writeList(travelBugs);
-		dest.writeList(waypoints);
-		dest.writeString(notes);
-		dest.writeInt(computed ? 1 : 0);
-		dest.writeInt(found ? 1 : 0);
-	}
-	
-	@Override
-	public int describeContents() {
-		return 0;
-	}
-}
diff --git a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/PointGeocachingDataLog.java b/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/PointGeocachingDataLog.java
deleted file mode 100644
index 52ca0b8..0000000
--- a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/PointGeocachingDataLog.java
+++ /dev/null
@@ -1,91 +0,0 @@
-/*  
- * Copyright 2011, Asamm Software, s.r.o.
- * 
- * This file is part of LocusAddonPublicLib.
- * 
- * LocusAddonPublicLib is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *  
- * LocusAddonPublicLib is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *  
- * You should have received a copy of the GNU General Public License
- * along with LocusAddonPublicLib.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package menion.android.locus.addon.publiclib.geoData;
-
-import android.os.Parcel;
-import android.os.Parcelable;
-
-public class PointGeocachingDataLog  implements Parcelable {
-	
-	private static final int VERSION = 1;
-	
-	public int id;
-	public int type;
-	/**
-	 * Date of log in format "yyyy-MM-dd'T'HH:mm:ss'Z'"
-	 */
-	public String date;
-	public String finder;
-	public int finderFound;
-	public String logText;
-
-	public PointGeocachingDataLog() {
-		id = 0;
-		type = PointGeocachingData.CACHE_LOG_TYPE_UNKNOWN;
-		date = "";
-		finder = "";
-		finderFound = 0;
-		logText = "";
-	}
-	
-	/****************************/
-	/*      PARCELABLE PART     */
-	/****************************/
-	
-    public static final Parcelable.Creator<PointGeocachingDataLog> CREATOR = new Parcelable.Creator<PointGeocachingDataLog>() {
-        public PointGeocachingDataLog createFromParcel(Parcel in) {
-            return new PointGeocachingDataLog(in);
-        }
-
-        public PointGeocachingDataLog[] newArray(int size) {
-            return new PointGeocachingDataLog[size];
-        }
-    };
-    
-    public PointGeocachingDataLog(Parcel in) {
-    	switch (in.readInt()) {
-    	case 1:
-    		id = in.readInt();
-    	case 0:
-    		type = in.readInt();
-    		date = in.readString();
-    		finder = in.readString();
-    		finderFound = in.readInt();
-    		logText = in.readString();
-    		break;
-    	}
-    }
-    
-	@Override
-	public void writeToParcel(Parcel dest, int flags) {
-		dest.writeInt(VERSION);
-		dest.writeInt(id);
-		dest.writeInt(type);
-		dest.writeString(date);
-		dest.writeString(finder);
-		dest.writeInt(finderFound);
-		dest.writeString(logText);
-	}
-	
-	@Override
-	public int describeContents() {
-		return 0;
-	}
-}
\ No newline at end of file
diff --git a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/PointGeocachingDataTravelBug.java b/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/PointGeocachingDataTravelBug.java
deleted file mode 100644
index e322b65..0000000
--- a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/PointGeocachingDataTravelBug.java
+++ /dev/null
@@ -1,105 +0,0 @@
-/*  
- * Copyright 2011, Asamm Software, s.r.o.
- * 
- * This file is part of LocusAddonPublicLib.
- * 
- * LocusAddonPublicLib is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *  
- * LocusAddonPublicLib is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *  
- * You should have received a copy of the GNU General Public License
- * along with LocusAddonPublicLib.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package menion.android.locus.addon.publiclib.geoData;
-
-import android.os.Parcel;
-import android.os.Parcelable;
-
-public class PointGeocachingDataTravelBug implements Parcelable {
-	
-	private static final int VERSION = 0;
-	
-	/* name of travel bug */
-	public String name;
-	/* image url to this travel bug */
-	public String imgUrl;
-	/* original page data */
-	public String srcDetails;
-	
-	/* owner of TB */
-	public String owner;
-	/* String date of release */
-	public String released;
-	/* origin place */
-	public String origin;
-	/* goal of this TB */
-	public String goal;
-	/* details */
-	public String details;
-	
-	public PointGeocachingDataTravelBug() {
-		name = "";
-		imgUrl = "";
-		srcDetails = "";
-		
-		owner = "";
-		released = "";
-		origin = "";
-		goal = "";
-		details = "";
-	}
-
-	/****************************/
-	/*      PARCELABLE PART     */
-	/****************************/
-	
-    public static final Parcelable.Creator<PointGeocachingDataTravelBug> CREATOR = new Parcelable.Creator<PointGeocachingDataTravelBug>() {
-        public PointGeocachingDataTravelBug createFromParcel(Parcel in) {
-            return new PointGeocachingDataTravelBug(in);
-        }
-
-        public PointGeocachingDataTravelBug[] newArray(int size) {
-            return new PointGeocachingDataTravelBug[size];
-        }
-    };
-    
-    public PointGeocachingDataTravelBug(Parcel in) {
-    	switch (in.readInt()) {
-    	case 0:
-    		name = in.readString();
-    		imgUrl = in.readString();
-    		srcDetails = in.readString();
-    		owner = in.readString();
-    		released = in.readString();
-    		origin = in.readString();
-    		goal = in.readString();
-    		details = in.readString();
-    		break;
-    	}
-    }
-    
-	@Override
-	public void writeToParcel(Parcel dest, int flags) {
-		dest.writeInt(VERSION);
-		dest.writeString(name);
-		dest.writeString(imgUrl);
-		dest.writeString(srcDetails);
-		dest.writeString(owner);
-		dest.writeString(released);
-		dest.writeString(origin);
-		dest.writeString(goal);
-		dest.writeString(details);
-	}
-	
-	@Override
-	public int describeContents() {
-		return 0;
-	}
-}
\ No newline at end of file
diff --git a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/PointGeocachingDataWaypoint.java b/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/PointGeocachingDataWaypoint.java
deleted file mode 100644
index 1773c67..0000000
--- a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/PointGeocachingDataWaypoint.java
+++ /dev/null
@@ -1,99 +0,0 @@
-/*  
- * Copyright 2011, Asamm Software, s.r.o.
- * 
- * This file is part of LocusAddonPublicLib.
- * 
- * LocusAddonPublicLib is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *  
- * LocusAddonPublicLib is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *  
- * You should have received a copy of the GNU General Public License
- * along with LocusAddonPublicLib.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package menion.android.locus.addon.publiclib.geoData;
-
-import android.os.Parcel;
-import android.os.Parcelable;
-
-public class PointGeocachingDataWaypoint implements Parcelable {
-	
-	private static final int VERSION = 1;
-	
-	/* code of wpt */
-	public String code;
-	/* name of waypoint */
-	public String name;
-	/* description (may be HTML code) */
-	public String description;
-	/* type of waypoint (defined in PointGeocachingData) */
-	public String type;
-	/* image URL to this wpt (not needed) */
-	public String typeImagePath;
-	/* latitude of waypoint */
-	public double lat;
-	/* longitude of waypoint */
-	public double lon;
-	
-	public PointGeocachingDataWaypoint() {
-		code = "";
-		name = "";
-		description = "";
-		type = "";
-		typeImagePath = "";
-		lat = 0.0;
-		lon = 0.0;
-	}
-
-	/****************************/
-	/*      PARCELABLE PART     */
-	/****************************/
-	
-    public static final Parcelable.Creator<PointGeocachingDataWaypoint> CREATOR = new Parcelable.Creator<PointGeocachingDataWaypoint>() {
-        public PointGeocachingDataWaypoint createFromParcel(Parcel in) {
-            return new PointGeocachingDataWaypoint(in);
-        }
-
-        public PointGeocachingDataWaypoint[] newArray(int size) {
-            return new PointGeocachingDataWaypoint[size];
-        }
-    };
-    
-    public PointGeocachingDataWaypoint(Parcel in) {
-    	switch (in.readInt()) {
-    	case 1:
-    		code = in.readString();
-    	case 0:
-    		name = in.readString();
-    		description = in.readString();
-    		type = in.readString();
-    		typeImagePath = in.readString();
-    		lat = in.readDouble();
-    		lon = in.readDouble();
-    		break;
-    	}
-    }
-    
-	@Override
-	public void writeToParcel(Parcel dest, int flags) {
-		dest.writeInt(VERSION);
-		dest.writeString(code);
-		dest.writeString(name);
-		dest.writeString(description);
-		dest.writeString(type);
-		dest.writeString(typeImagePath);
-		dest.writeDouble(lat);
-		dest.writeDouble(lon);
-	}
-	
-	@Override
-	public int describeContents() {
-		return 0;
-	}
-}
\ No newline at end of file
diff --git a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/PointsData.java b/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/PointsData.java
deleted file mode 100644
index 73d0c13..0000000
--- a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/PointsData.java
+++ /dev/null
@@ -1,146 +0,0 @@
-/*  
- * Copyright 2011, Asamm Software, s.r.o.
- * 
- * This file is part of LocusAddonPublicLib.
- * 
- * LocusAddonPublicLib is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *  
- * LocusAddonPublicLib is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *  
- * You should have received a copy of the GNU General Public License
- * along with LocusAddonPublicLib.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package menion.android.locus.addon.publiclib.geoData;
-
-import java.io.ByteArrayOutputStream;
-import java.util.ArrayList;
-
-import android.graphics.Bitmap;
-import android.graphics.BitmapFactory;
-import android.os.Parcel;
-import android.os.Parcelable;
-
-public class PointsData implements Parcelable {
-
-	private static final int VERSION = 1;
-	
-	// Unique name. PointsData send to Locus with same name will be overwrite in Locus
-	private String mName;
-	// icon applied to whole PointsData
-	private Bitmap mBitmap;
-	// ArrayList of all points stored in this object
-	private ArrayList<Point> mPoints;
-	
-	public PointsData(String uniqueName) {
-		this.mName = uniqueName;
-		this.mBitmap = null;
-		this.mPoints = new ArrayList<Point>();
-	}
-	
-	public String getName() {
-		return mName;
-	}
-	
-	public Bitmap getBitmap() {
-		return mBitmap;
-	}
-	
-	public void setBitmap(Bitmap bitmap) {
-		this.mBitmap = bitmap;
-	}
-
-	public void addPoint(Point point) {
-		this.mPoints.add(point);
-	}
-	
-	public ArrayList<Point> getPoints() {
-		return mPoints;
-	}
-
-	/****************************/
-	/*      PARCELABLE PART     */
-	/****************************/
-	
-    public static final Parcelable.Creator<PointsData> CREATOR = new Parcelable.Creator<PointsData>() {
-        public PointsData createFromParcel(Parcel in) {
-            return new PointsData(in);
-        }
-
-        public PointsData[] newArray(int size) {
-            return new PointsData[size];
-        }
-    };
-    
-	@Override
-	public int describeContents() {
-		return 0;
-	}
-
-    @SuppressWarnings("unchecked")
-	private PointsData(Parcel in) {
-    	int version = in.readInt();
-		mName = in.readString();
-		int size = in.readInt();
-		if (size > 0) {
-			byte[] data = new byte[size];
-			in.readByteArray(data);
-			mBitmap = BitmapFactory.decodeByteArray(data, 0, data.length);
-		} else {
-			mBitmap = null;
-		}
-
-    	switch (version) {
-    	case 0:
-    		mPoints = in.readArrayList(Point.class.getClassLoader());
-    		break;
-    	case 1:
-    		mPoints = new ArrayList<Point>();
-    		in.readTypedList(mPoints, Point.CREATOR);
-    		break;
-    	}
-    }
-    
-	@Override
-	public void writeToParcel(Parcel dest, int flags) {
-		dest.writeInt(VERSION);
-		dest.writeString(mName);
-		if (mBitmap == null) {
-			dest.writeInt(0);
-		} else {
-			byte[] data = getBitmapAsByte(mBitmap);
-			if (data == null || data.length == 0) {
-				dest.writeInt(0);
-			} else {
-				dest.writeInt(data.length);
-				dest.writeByteArray(data);
-			}
-		}
-		dest.writeTypedList(mPoints);
-	}
-	
-	private static byte[] getBitmapAsByte(Bitmap bitmap) {
-		ByteArrayOutputStream baos = null;
-		try {
-			baos = new ByteArrayOutputStream();
-			bitmap.compress(Bitmap.CompressFormat.PNG, 100, baos);
-			return baos.toByteArray();
-		} catch (Exception e) {
-			return null;
-		} finally {
-			try {
-				if (baos != null){
-					baos.close();
-					baos = null;
-				}
-			} catch (Exception e) {}
-		}
-	}
-	
-}
diff --git a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/Track.java b/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/Track.java
deleted file mode 100644
index 9b39578..0000000
--- a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/geoData/Track.java
+++ /dev/null
@@ -1,177 +0,0 @@
-/*  
- * Copyright 2011, Asamm Software, s.r.o.
- * 
- * This file is part of LocusAddonPublicLib.
- * 
- * LocusAddonPublicLib is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *  
- * LocusAddonPublicLib is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *  
- * You should have received a copy of the GNU General Public License
- * along with LocusAddonPublicLib.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package menion.android.locus.addon.publiclib.geoData;
-
-import java.util.ArrayList;
-
-import menion.android.locus.addon.publiclib.LocusUtils;
-
-import android.graphics.Color;
-import android.location.Location;
-import android.os.Parcel;
-import android.os.Parcelable;
-
-public class Track implements Parcelable {
-
-	private static final int VERSION = 1;
-	
-	/* name of object, have to be unique */
-	private String mName;
-	/* description of object */
-	private String mDesc;
-	/* locations of this track */
-	private ArrayList<Location> mLocs;
-	/* extra points (also may include routing data - TODO) */
-	private ArrayList<Point> mPoints;
-
-	/* color of displayed track */
-	private int mDrawColor;
-	/* width in pixels */
-	private float mDrawWidth;
-	
-	public Track() {
-		mDrawColor = Color.BLUE;
-		mDrawWidth = 5.0f;
-	}
-
-	public String getName() {
-		return mName;
-	}
-	
-	public void setName(String name) {
-		this.mName = name;
-	}
-	
-	public String getDescription() {
-		return mDesc;
-	}
-	
-	public void setDescription(String desc) {
-		this.mDesc = desc;
-	}
-
-	public void addLocation(Location loc) {
-		if (mLocs == null)
-			mLocs = new ArrayList<Location>();
-		mLocs.add(loc);
-	}
-	
-	public ArrayList<Location> getLocations() {
-		return mLocs;
-	}
-	
-	public void setLocations(ArrayList<Location> locs) {
-		this.mLocs = locs;
-	}
-	
-	public void addPoint(Point p) {
-		if (mPoints == null)
-			mPoints = new ArrayList<Point>();
-		mPoints.add(p);
-	}
-	
-	public ArrayList<Point> getPoints() {
-		return mPoints;
-	}
-	
-	public void setPoints(ArrayList<Point> pts) {
-		this.mPoints = pts;
-	}
-	
-	public int getColor() {
-		return mDrawColor;
-	}
-	
-	public float getWidth() {
-		return mDrawWidth;
-	}
-	
-	public void setStyle(int color, float width) {
-		mDrawColor = color;
-		mDrawWidth = width;
-	}
-	
-	/****************************/
-	/*      PARCELABLE PART     */
-	/****************************/
-	
-    public static final Parcelable.Creator<Track> CREATOR = new Parcelable.Creator<Track>() {
-        public Track createFromParcel(Parcel in) {
-            return new Track(in);
-        }
-
-        public Track[] newArray(int size) {
-            return new Track[size];
-        }
-    };
-    
-    private Track(Parcel in) {
-    	@SuppressWarnings("unused")
-		int version = in.readInt();
-		// load name
-		mName = in.readString();
-		// load description
-		mDesc = in.readString();
-		// load separate location
-		int size = in.readInt();
-		mLocs = new ArrayList<Location>(size);
-		for (int i = 0; i < size; i++) {
-			mLocs.add(LocusUtils.readLocation(in));
-		}
-		// load points
-		size = in.readInt();
-		mPoints = new ArrayList<Point>(size);
-		for (int i = 0; i < size; i++) {
-			mPoints.add(Point.CREATOR.createFromParcel(in));
-		}
-		// read style
-		mDrawColor = in.readInt();
-		mDrawWidth = in.readFloat();
-    }
-    
-	@Override
-	public int describeContents() {
-		return 0;
-	}
-
-	@Override
-	public void writeToParcel(Parcel dest, int flags) {
-		dest.writeInt(VERSION);
-		// write name
-		dest.writeString(mName);
-		// write description
-		dest.writeString(mDesc);
-		// write locations
-		int size = mLocs == null ? 0 : mLocs.size();
-		dest.writeInt(size);
-		for (int i = 0; i < size; i++) {
-			LocusUtils.writeLocation(dest, mLocs.get(i));
-		}
-		// write extra points
-		size = mPoints == null ? 0 : mPoints.size();
-		dest.writeInt(size);
-		for (int i = 0; i < size; i++) {
-			mPoints.get(i).writeToParcel(dest, flags);
-		}
-		// write style
-		dest.writeInt(mDrawColor);
-		dest.writeFloat(mDrawWidth);
-	}
-}
diff --git a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/utils/DataCursor.java b/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/utils/DataCursor.java
deleted file mode 100644
index 441c19d..0000000
--- a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/utils/DataCursor.java
+++ /dev/null
@@ -1,350 +0,0 @@
-/*  
- * Copyright 2011, Asamm Software, s.r.o.
- * 
- * This file is part of LocusAddonPublicLib.
- * 
- * LocusAddonPublicLib is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *  
- * LocusAddonPublicLib is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *  
- * You should have received a copy of the GNU General Public License
- * along with LocusAddonPublicLib.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package menion.android.locus.addon.publiclib.utils;
-
-import java.util.ArrayList;
-
-import android.database.AbstractCursor;
-import android.database.CursorIndexOutOfBoundsException;
-import android.database.CursorWindow;
-
-/**
- * A mutable cursor implementation backed by an array of {@code Object}s. Use
- * {@link #newRow()} to add rows. Automatically expands internal capacity as
- * needed.
- */
-public class DataCursor extends AbstractCursor {
-
-	private final String[] columnNames;
-	private Object[] data;
-	private int rowCount = 0;
-	private final int columnCount;
-
-	/**
-	 * Constructs a new cursor with the given initial capacity.
-	 * 
-	 * @param columnNames
-	 *            names of the columns, the ordering of which determines column
-	 *            ordering elsewhere in this cursor
-	 * @param initialCapacity
-	 *            in rows
-	 */
-	public DataCursor(String[] columnNames, int initialCapacity) {
-		this.columnNames = columnNames;
-		this.columnCount = columnNames.length;
-
-		if (initialCapacity < 1) {
-			initialCapacity = 1;
-		}
-
-		this.data = new Object[columnCount * initialCapacity];
-	}
-
-	/**
-	 * Constructs a new cursor.
-	 * 
-	 * @param columnNames
-	 *            names of the columns, the ordering of which determines column
-	 *            ordering elsewhere in this cursor
-	 */
-	public DataCursor(String[] columnNames) {
-		this(columnNames, 16);
-	}
-
-	/**
-	 * Gets value at the given column for the current row.
-	 */
-	private Object get(int column) {
-		if (column < 0 || column >= columnCount) {
-			throw new CursorIndexOutOfBoundsException("Requested column: "
-					+ column + ", # of columns: " + columnCount);
-		}
-		if (mPos < 0) {
-			throw new CursorIndexOutOfBoundsException("Before first row.");
-		}
-		if (mPos >= rowCount) {
-			throw new CursorIndexOutOfBoundsException("After last row.");
-		}
-		return data[mPos * columnCount + column];
-	}
-
-	/**
-	 * Adds a new row to the end and returns a builder for that row. Not safe
-	 * for concurrent use.
-	 * 
-	 * @return builder which can be used to set the column values for the new
-	 *         row
-	 */
-	public RowBuilder newRow() {
-		rowCount++;
-		int endIndex = rowCount * columnCount;
-		ensureCapacity(endIndex);
-		int start = endIndex - columnCount;
-		return new RowBuilder(start, endIndex);
-	}
-
-	/**
-	 * Adds a new row to the end with the given column values. Not safe for
-	 * concurrent use.
-	 * 
-	 * @throws IllegalArgumentException
-	 *             if {@code columnValues.length !=
-	 *  columnNames.length}
-	 * @param columnValues
-	 *            in the same order as the the column names specified at cursor
-	 *            construction time
-	 */
-	public void addRow(Object[] columnValues) {
-		if (columnValues.length != columnCount) {
-			throw new IllegalArgumentException("columnNames.length = "
-					+ columnCount + ", columnValues.length = "
-					+ columnValues.length);
-		}
-
-		int start = rowCount++ * columnCount;
-		ensureCapacity(start + columnCount);
-		System.arraycopy(columnValues, 0, data, start, columnCount);
-	}
-
-	/**
-	 * Adds a new row to the end with the given column values. Not safe for
-	 * concurrent use.
-	 * 
-	 * @throws IllegalArgumentException
-	 *             if {@code columnValues.size() !=
-	 *  columnNames.length}
-	 * @param columnValues
-	 *            in the same order as the the column names specified at cursor
-	 *            construction time
-	 */
-	public void addRow(Iterable<?> columnValues) {
-		int start = rowCount * columnCount;
-		int end = start + columnCount;
-		ensureCapacity(end);
-
-		if (columnValues instanceof ArrayList<?>) {
-			addRow((ArrayList<?>) columnValues, start);
-			return;
-		}
-
-		int current = start;
-		Object[] localData = data;
-		for (Object columnValue : columnValues) {
-			if (current == end) {
-				// TODO: null out row?
-				throw new IllegalArgumentException(
-						"columnValues.size() > columnNames.length");
-			}
-			localData[current++] = columnValue;
-		}
-
-		if (current != end) {
-			// TODO: null out row?
-			throw new IllegalArgumentException(
-					"columnValues.size() < columnNames.length");
-		}
-
-		// Increase row count here in case we encounter an exception.
-		rowCount++;
-	}
-
-	/** Optimization for {@link ArrayList}. */
-	private void addRow(ArrayList<?> columnValues, int start) {
-		int size = columnValues.size();
-		if (size != columnCount) {
-			throw new IllegalArgumentException("columnNames.length = "
-					+ columnCount + ", columnValues.size() = " + size);
-		}
-
-		rowCount++;
-		Object[] localData = data;
-		for (int i = 0; i < size; i++) {
-			localData[start + i] = columnValues.get(i);
-		}
-	}
-
-	/** Ensures that this cursor has enough capacity. */
-	private void ensureCapacity(int size) {
-		if (size > data.length) {
-			Object[] oldData = this.data;
-			int newSize = data.length * 2;
-			if (newSize < size) {
-				newSize = size;
-			}
-			this.data = new Object[newSize];
-			System.arraycopy(oldData, 0, this.data, 0, oldData.length);
-		}
-	}
-
-	/**
-	 * Builds a row, starting from the left-most column and adding one column
-	 * value at a time. Follows the same ordering as the column names specified
-	 * at cursor construction time.
-	 */
-	public class RowBuilder {
-
-		private int index;
-		private final int endIndex;
-
-		RowBuilder(int index, int endIndex) {
-			this.index = index;
-			this.endIndex = endIndex;
-		}
-
-		/**
-		 * Sets the next column value in this row.
-		 * 
-		 * @throws CursorIndexOutOfBoundsException
-		 *             if you try to add too many values
-		 * @return this builder to support chaining
-		 */
-		public RowBuilder add(Object columnValue) {
-			if (index == endIndex) {
-				throw new CursorIndexOutOfBoundsException(
-						"No more columns left.");
-			}
-
-			data[index++] = columnValue;
-			return this;
-		}
-	}
-
-	// AbstractCursor implementation.
-
-	@Override
-	public int getCount() {
-		return rowCount;
-	}
-
-	@Override
-	public String[] getColumnNames() {
-		return columnNames;
-	}
-
-	@Override
-	public String getString(int column) {
-		Object value = get(column);
-		if (value == null)
-			return null;
-		return value.toString();
-	}
-
-	@Override
-	public short getShort(int column) {
-		Object value = get(column);
-		if (value == null)
-			return 0;
-		if (value instanceof Number)
-			return ((Number) value).shortValue();
-		return Short.parseShort(value.toString());
-	}
-
-	@Override
-	public int getInt(int column) {
-		Object value = get(column);
-		if (value == null)
-			return 0;
-		if (value instanceof Number)
-			return ((Number) value).intValue();
-		return Integer.parseInt(value.toString());
-	}
-
-	@Override
-	public long getLong(int column) {
-		Object value = get(column);
-		if (value == null)
-			return 0;
-		if (value instanceof Number)
-			return ((Number) value).longValue();
-		return Long.parseLong(value.toString());
-	}
-
-	@Override
-	public float getFloat(int column) {
-		Object value = get(column);
-		if (value == null)
-			return 0.0f;
-		if (value instanceof Number)
-			return ((Number) value).floatValue();
-		return Float.parseFloat(value.toString());
-	}
-
-	@Override
-	public double getDouble(int column) {
-		Object value = get(column);
-		if (value == null)
-			return 0.0d;
-		if (value instanceof Number)
-			return ((Number) value).doubleValue();
-		return Double.parseDouble(value.toString());
-	}
-
-	@Override
-	public byte[] getBlob(int column) {
-		Object value = get(column);
-		if (value == null)
-			return new byte[0];
-		if (value instanceof byte[])
-			return ((byte[]) value);
-		return new byte[0];
-	}
-
-	@Override
-	public boolean isNull(int column) {
-		return get(column) == null;
-	}
-
-	public void fillWindow(int position, CursorWindow window) {
-		if (position < 0 || position >= getCount()) {
-			return;
-		}
-		window.acquireReference();
-		try {
-			int oldpos = mPos;
-			mPos = position - 1;
-			window.clear();
-			window.setStartPosition(position);
-			int columnNum = getColumnCount();
-			window.setNumColumns(columnNum);
-			while (moveToNext() && window.allocRow()) {
-				for (int i = 0; i < columnNum; i++) {
-					byte[] field = getBlob(i);
-					if (field != null) {
-						if (!window.putBlob(field, mPos, i)) {
-							window.freeLastRow();
-							break;
-						}
-					} else {
-						if (!window.putNull(mPos, i)) {
-							window.freeLastRow();
-							break;
-						}
-					}
-				}
-			}
-
-			mPos = oldpos;
-		} catch (IllegalStateException e) {
-			// simply ignore it
-		} finally {
-			window.releaseReference();
-		}
-	}
-}
diff --git a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/utils/DataStorage.java b/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/utils/DataStorage.java
deleted file mode 100644
index 9365816..0000000
--- a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/utils/DataStorage.java
+++ /dev/null
@@ -1,47 +0,0 @@
-/*  
- * Copyright 2011, Asamm Software, s.r.o.
- * 
- * This file is part of LocusAddonPublicLib.
- * 
- * LocusAddonPublicLib is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *  
- * LocusAddonPublicLib is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *  
- * You should have received a copy of the GNU General Public License
- * along with LocusAddonPublicLib.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package menion.android.locus.addon.publiclib.utils;
-
-import java.util.ArrayList;
-
-import menion.android.locus.addon.publiclib.geoData.PointsData;
-
-public class DataStorage {
-
-	private static ArrayList<PointsData> mData;
-	
-	public static ArrayList<PointsData> getData() {
-		return mData;
-	}
-	
-	public static void setData(ArrayList<PointsData> data) {
-		DataStorage.mData = data;
-	}
-	
-	public static void setData(PointsData data) {
-		DataStorage.mData = new ArrayList<PointsData>();
-		DataStorage.mData.add(data);
-	}
-	
-	public static void clearData() {
-		DataStorage.mData.clear();
-		DataStorage.mData = null;
-	}
-}
diff --git a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/utils/RequiredVersionMissingException.java b/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/utils/RequiredVersionMissingException.java
deleted file mode 100644
index cb4c438..0000000
--- a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/utils/RequiredVersionMissingException.java
+++ /dev/null
@@ -1,39 +0,0 @@
-/*  
- * Copyright 2011, Asamm Software, s.r.o.
- * 
- * This file is part of LocusAddonPublicLib.
- * 
- * LocusAddonPublicLib is free software: you can redistribute it and/or modify
- * it under the terms of the GNU General Public License as published by
- * the Free Software Foundation, either version 3 of the License, or
- * (at your option) any later version.
- *  
- * LocusAddonPublicLib is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- * GNU General Public License for more details.
- *  
- * You should have received a copy of the GNU General Public License
- * along with LocusAddonPublicLib.  If not, see <http://www.gnu.org/licenses/>.
- */
-
-package menion.android.locus.addon.publiclib.utils;
-
-public class RequiredVersionMissingException extends Exception {
-
-	private static final long serialVersionUID = 1L;
-	
-	private String mistake;
-	
-	public RequiredVersionMissingException(int version) {
-		this(version, version);
-	}
-	
-	public RequiredVersionMissingException(int versionPro, int versionFree) {
-		super("Required version: Pro (" + versionPro + "), or Free (" + versionFree + "), not installed!");
-	}
-	
-	public String getError() {
-		return mistake;
-	}
-}
diff --git a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/utils/Utils.java b/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/utils/Utils.java
deleted file mode 100644
index 15ca41b..0000000
--- a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/utils/Utils.java
+++ /dev/null
@@ -1,20 +0,0 @@
-package menion.android.locus.addon.publiclib.utils;
-
-import android.content.Context;
-import android.content.pm.PackageInfo;
-import android.content.pm.PackageManager;
-
-public class Utils {
-
-	public static boolean isAppAvailable(Context context, String packageName, int version) {
-		//Log.i(TAG, "isAppAvailable(" + context + ", " + packageName + ", " + version + ")");
-		try {
-			PackageInfo info = context.getPackageManager().getPackageInfo(packageName, 0);
-			if (info == null)
-				return false;
-			return info.versionCode >= version;
-		} catch (PackageManager.NameNotFoundException e) {
-			return false;
-		}
-	}
-}
diff --git a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/utils/UtilsAddonAR.java b/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/utils/UtilsAddonAR.java
deleted file mode 100644
index 40c93d6..0000000
--- a/locusAddonPublicLib/src/main/java/menion/android/locus/addon/publiclib/utils/UtilsAddonAR.java
+++ /dev/null
@@ -1,97 +0,0 @@
-package menion.android.locus.addon.publiclib.utils;
-
-import java.security.NoSuchAlgorithmException;
-import java.util.ArrayList;
-
-import menion.android.locus.addon.publiclib.DisplayData;
-import menion.android.locus.addon.publiclib.LocusConst;
-import menion.android.locus.addon.publiclib.geoData.PointsData;
-import menion.android.locus.addon.publiclib.geoData.Track;
-import android.app.Activity;
-import android.content.Context;
-import android.content.Intent;
-import android.location.Location;
-import android.util.Log;
-
-public class UtilsAddonAR {
-
-	private static final String TAG = "UtilsAddonAR";
-	
-	// value that point have no altitude
-	public static final float NO_ALTITUDE = Float.MIN_VALUE;
-	
-	// intent call to view AR
-	public static final String INTENT = "menion.android.locus.addon.ar.VIEW";
-	
-	// id used for recognizing if add-on is closed or not. Register receiver in your 
-	// starting activity on this number
-	public static final int REQUEST_ADDON_AR = 30001;
-	
-	// extra ident for intent - location
-	public static final String EXTRA_LOCATION = "EXTRA_LOCATION";
-	// identificator of actual guiding item
-	public static final String EXTRA_GUIDING_ID = "EXTRA_GUIDING_ID";
-	// event to kill process
-	public static final String EXTRA_END_AR = "EXTRA_END_AR";
-	
-	// result id of selected point
-	public static final String RESULT_WPT_ID = "RESULT_WPT_ID";
-
-	// broadcast identificator
-	public final static String BROADCAST_DATA = "menion.android.locus.addon.ar.NEW_DATA";
-	
-	// last used location
-	private static Location lastLocation;
-	
-	public static boolean isInstalled(Context context) {
-		// check if exist new version of AR add-on. Older version used
-		// different and deprecated API, so not usable anymore
-		return Utils.isAppAvailable(context, "menion.android.locus.addon.ar", 3);
-	}
-	
-	public static boolean showPoints(Activity context, ArrayList<PointsData> data,
-			Location yourLoc, long guidedWptId) {
-		if (!isInstalled(context)) {
-			Log.i(TAG, "missing required version 3");
-			return false;
-		}
-		
-		// prepare intent and start it
-		Intent intent = new Intent(INTENT);
-		intent.putExtra(LocusConst.EXTRA_POINTS_DATA_ARRAY, data);
-		intent.putExtra(EXTRA_LOCATION, yourLoc);
-		intent.putExtra(EXTRA_GUIDING_ID, guidedWptId);
-		
-		// check intent firstly
-		if (!DisplayData.hasData(intent)) {
-			Log.w(TAG, "Intent 'null' or not contain any data");
-			return false;
-		}
-
-		// store location
-		lastLocation = yourLoc;
-
-		// finally start activity
-		context.startActivityForResult(intent, REQUEST_ADDON_AR);
-		return true;
-	}
-	
-	public static void updateLocation(Context context, Location loc) {
-		// do some tests if is really need to send new location
-		if ((loc.getTime() - lastLocation.getTime()) < 5000 ||
-			(loc.distanceTo(lastLocation) < 5 &&
-					Math.abs(loc.getAltitude() - lastLocation.getAltitude()) < 10)) {
-			return;
-		} else {
-			lastLocation = loc;
-			Intent intent = new Intent(BROADCAST_DATA);
-			intent.putExtra(EXTRA_LOCATION, lastLocation);
-			context.sendBroadcast(intent);
-		}
-	}
-	
-	public static void showTracks(Context context, ArrayList<Track> tracks)
-			throws NoSuchAlgorithmException {
-		throw new NoSuchAlgorithmException("Not yet implemented");
-	}
-}
